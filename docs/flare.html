<!DOCTYPE html><html><head><title>Help for package flare</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flare}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.slim'>
<p>Extract Model Coefficients for an object with S3 class <code>"slim"</code></p></a></li>
<li><a href='#eyedata'>
<p>The Bardet-Biedl syndrome Gene expression data from Scheetz et al. (2006)</p></a></li>
<li><a href='#flare-internal'><p>Internal flare functions</p></a></li>
<li><a href='#flare-package'>
<p>flare: a new Family of Lasso Regression</p></a></li>
<li><a href='#plot.roc'>
<p>Plot Function for &quot;roc&quot;</p></a></li>
<li><a href='#plot.select'>
<p>Plot Function for &quot;select&quot;</p></a></li>
<li><a href='#plot.sim'>
<p>Plot Function for &quot;sim&quot;</p></a></li>
<li><a href='#plot.slim'>
<p>Plot Function for &quot;slim&quot;</p></a></li>
<li><a href='#plot.sugm'>
<p>Plot Function for &quot;sugm&quot;</p></a></li>
<li><a href='#predict.slim'>
<p>Prediction for an object with S3 class <code>"slim"</code></p></a></li>
<li><a href='#print.roc'>
<p>Print Function for for an object with S3 class <code>"roc"</code></p></a></li>
<li><a href='#print.select'>
<p>Print Function for for an object with S3 class <code>"select"</code></p></a></li>
<li><a href='#print.sim'>
<p>Print Function for for an object with S3 class <code>"sim"</code></p></a></li>
<li><a href='#print.slim'>
<p>Print Function for an object with S3 class <code>"slim"</code></p></a></li>
<li><a href='#print.sugm'>
<p>Print Function for an object with S3 class <code>"sugm"</code></p></a></li>
<li><a href='#slim'>
<p>Sparse Linear Regression using Nonsmooth Loss Functions and L1 Regularization</p></a></li>
<li><a href='#sugm'>
<p>High-deimensional Sparse Undirected Graphical Models.</p></a></li>
<li><a href='#sugm.generator'>
<p>Data generator for sparse undirected graph estimation.</p></a></li>
<li><a href='#sugm.plot'>
<p>Graph visualization for an object with S3 class <code>"sugm"</code></p></a></li>
<li><a href='#sugm.roc'>
<p>Draw ROC Curve for an object with S3 class <code>"sugm"</code></p></a></li>
<li><a href='#sugm.select'>
<p>Model selection for high-dimensional undirected graphical models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Family of Lasso Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan, and Han Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xingguo Li &lt;xingguo.leo@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), lattice, MASS, Matrix, igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide the implementation of a family of Lasso variants including Dantzig Selector, LAD Lasso, SQRT Lasso, Lq Lasso for estimating high dimensional sparse linear model. We adopt the alternating direction method of multipliers and convert the original optimization problem into a sequential L1 penalized least square minimization problem, which can be efficiently solved by linearization algorithm. A multi-stage screening approach is adopted for further acceleration. Besides the sparse linear model estimation, we also provide the extension of these Lasso variants to sparse Gaussian graphical model estimation including TIGER and CLIME using either L1 or adaptive penalty. Missing values can be tolerated for Dantzig selector and CLIME. The computation is memory-optimized using the sparse matrix output. For more information, please refer to <a href="https://www.jmlr.org/papers/volume16/li15a/li15a.pdf">https://www.jmlr.org/papers/volume16/li15a/li15a.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-23 07:35:38 UTC; hornik</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-23 08:02:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.slim'>
Extract Model Coefficients for an object with S3 class <code>"slim"</code>
</h2><span id='topic+coef.slim'></span>

<h3>Description</h3>

<p>Extract estimated regression coefficient vectors from the solution path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slim'
coef(object, lambda.idx = c(1:3), beta.idx = c(1:3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.slim_+3A_object">object</code></td>
<td>

<p>An object with S3 class <code>"slim"</code> 
</p>
</td></tr>
<tr><td><code id="coef.slim_+3A_lambda.idx">lambda.idx</code></td>
<td>

<p>The indices of the regularizaiton parameters in the solution path to be displayed. The default values are <code>c(1:3)</code>.
</p>
</td></tr>
<tr><td><code id="coef.slim_+3A_beta.idx">beta.idx</code></td>
<td>

<p>The indices of the estimate regression coefficient vectors in the solution path to be displayed. The default values are <code>c(1:3)</code>.
</p>
</td></tr>
<tr><td><code id="coef.slim_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slim">slim</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>

<hr>
<h2 id='eyedata'>
The Bardet-Biedl syndrome Gene expression data from Scheetz et al. (2006)
</h2><span id='topic+eyedata'></span><span id='topic+x'></span><span id='topic+y'></span>

<h3>Description</h3>

<p>Gene expression data (20 genes for 120 samples) from the microarray experiments of mammalianeye tissue samples of Scheetz et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eyedata)</code></pre>


<h3>Format</h3>

<p>The format is a list containing conatins a matrix and a vector.
1. x - an 120 by 200 matrix, which represents the data of 120 rats with 200 gene probes.
2. y - a 120-dimensional vector of, which represents the expression level of TRIM32 gene.
</p>


<h3>Details</h3>

<p>This data set contains 120 samples with 200 predictors
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. T. Scheetz, k. Kim, R. Swiderski, A. Philp, T. Braun, K. Knudtson, A. Dorrance, G. DiBona, J. Huang, T. Casavant, V. Sheffield, E. Stone .Regulation of gene expression in the mammalian eye and its relevance to eye disease. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flare-package">flare-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eyedata)
image(x)
</code></pre>

<hr>
<h2 id='flare-internal'>Internal flare functions</h2><span id='topic+sugm.likelihood'></span><span id='topic+sugm.tracel2'></span><span id='topic+sugm.cv'></span><span id='topic+part.cv'></span><span id='topic+sugm.clime.ladm.scr'></span><span id='topic+sugm.tiger.ladm.scr'></span><span id='topic+slim.lad.ladm.scr.btr'></span><span id='topic+slim.sqrt.ladm.scr'></span><span id='topic+slim.dantzig.ladm.scr'></span><span id='topic+slim.lq.ladm.scr.btr'></span><span id='topic+slim.lasso.ladm.scr'></span>

<h3>Description</h3>

<p>Internal flare functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sugm.likelihood(Sigma, Omega)
sugm.tracel2(Sigma, Omega)
sugm.cv(obj, loss=c("likelihood", "tracel2"), fold=5)
part.cv(n, fold)
sugm.clime.ladm.scr(Sigma, lambda, nlambda, n, d, maxdf, rho, shrink, prec, 
                    max.ite, verbose)
sugm.tiger.ladm.scr(data, n, d, maxdf, rho, lambda, shrink, prec, 
                    max.ite, verbose)
slim.lad.ladm.scr.btr(Y, X, lambda, nlambda, n, d, maxdf, rho, max.ite, prec, 
                      intercept, verbose)
slim.sqrt.ladm.scr(Y, X, lambda, nlambda, n, d, maxdf, rho, max.ite, prec, 
                   intercept, verbose)
slim.dantzig.ladm.scr(Y, X, lambda, nlambda, n, d, maxdf, rho, max.ite, prec, 
                      intercept, verbose)
slim.lq.ladm.scr.btr(Y, X, q, lambda, nlambda, n, d, maxdf, rho, max.ite, prec, 
                     intercept, verbose)
slim.lasso.ladm.scr(Y, X, lambda, nlambda, n, d, maxdf, max.ite, prec, 
                    intercept, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flare-internal_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_omega">Omega</code></td>
<td>
<p>Inverse covariance matrix.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_obj">obj</code></td>
<td>
<p>An object with S3 class returned from <code>"sugm"</code>.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_loss">loss</code></td>
<td>
<p>Type of loss function for cross validation.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_fold">fold</code></td>
<td>
<p>The number of fold for cross validatio.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_n">n</code></td>
<td>
<p>The number of observations (sample size).</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_d">d</code></td>
<td>
<p>Dimension of data.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_maxdf">maxdf</code></td>
<td>
<p>Maximal degree of freedom.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_lambda">lambda</code></td>
<td>
<p>Grid of non-negative values for the regularization parameter lambda.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of the regularization parameter lambda.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_shrink">shrink</code></td>
<td>
<p>Shrinkage of regularization parameter based on precision of estimation.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_rho">rho</code></td>
<td>
<p>Value of augmented Lagrangian multipiler.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_prec">prec</code></td>
<td>
<p>Stopping criterion.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_max.ite">max.ite</code></td>
<td>
<p>Maximal value of iterations.</p>
</td></tr>
<tr><td><code id="flare-internal_+3A_data">data</code></td>
<td>
<p><code>n</code> by <code>d</code> data matrix. </p>
</td></tr>
<tr><td><code id="flare-internal_+3A_y">Y</code></td>
<td>
<p>Dependent variables in linear regression. </p>
</td></tr>
<tr><td><code id="flare-internal_+3A_x">X</code></td>
<td>
<p>Design matrix in linear regression. </p>
</td></tr>
<tr><td><code id="flare-internal_+3A_q">q</code></td>
<td>
<p>The vector norm used for the loss term. </p>
</td></tr>
<tr><td><code id="flare-internal_+3A_intercept">intercept</code></td>
<td>
<p>The indicator of whether including intercepts specifically. </p>
</td></tr>
<tr><td><code id="flare-internal_+3A_verbose">verbose</code></td>
<td>
<p>Tracing information printing is disabled if <code>verbose = FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are not intended for use by users.   
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code>, <code><a href="#topic+slim">slim</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>

<hr>
<h2 id='flare-package'>
flare: a new Family of Lasso Regression
</h2><span id='topic+flare-package'></span><span id='topic+flare'></span>

<h3>Description</h3>

<p>The package &quot;flare&quot; provides the implementation of a family of novel regression methods (Lasso, Dantzig Selector, LAD Lasso, SQRT Lasso, Lq Lasso) and their extensions to sparse precision matrix estimation (TIGER and CLIME using L1) in high dimensions. We adopt the alternating direction method of multipliers and convert the original optimization problem into a sequence of L1-penalized least square minimization problems with the linearization method and multi-stage screening of variables. Missing values can be tolerated for Dantzig selector in the design matrix and response vector, and CLIME in the data matrix. The computation is memory-optimized using the sparse matrix output. In addition, we also provide several convenient regularization parameter selection and visulaization tools.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> flare</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.7.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-11-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang , Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. E. Candes and T. Tao. The Dantzig selector: Statistical estimation when p is much larger than n. <em>Annals of Statistics</em>, 2007.<br />
2. A. Belloni, V. Chernozhukov and L. Wang. Pivotal recovery of sparse signals via conic programming. <em>Biometrika</em>, 2012.<br />
3. L. Wang. L1 penalized LAD estimator for high dimensional linear regression. <em>Journal of Multivariate Analysis</em>, 2012.<br />
4. J. Liu and J. Ye. Efficient L1/Lq Norm Regularization. <em>Technical Report</em>, 2010.
5. T. Cai, W. Liu and X. Luo. A constrained <code class="reqn">\ell_1</code> minimization approach to sparse precision matrix estimation. <em>Journal of the American Statistical Association</em>, 2011.<br />
6. S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein, Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers. <em>Foundations and Trends in Machine Learning</em>, 2011.
7. H. Liu and L. Wang. TIGER: A tuning-insensitive approach for optimally estimating large undirected graphs. <em>Technical Report</em>, 2012. <br />
8. B. He and X. Yuan. On non-ergodic convergence rate of Douglas-Rachford alternating direction method of multipliers. <em>Technical Report</em>, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+slim">slim</a></code>.
</p>

<hr>
<h2 id='plot.roc'>
Plot Function for &quot;roc&quot;
</h2><span id='topic+plot.roc'></span>

<h3>Description</h3>

<p>Plot the ROC curve for an object with S3 class <code>"roc"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.roc_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"roc"</code> 
</p>
</td></tr>
<tr><td><code id="plot.roc_+3A_...">...</code></td>
<td>

<p>System reserved (No specific usage)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm.roc">sugm.roc</a></code>, <code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>

<hr>
<h2 id='plot.select'>
Plot Function for &quot;select&quot;
</h2><span id='topic+plot.select'></span>

<h3>Description</h3>

<p>Plot the optimal graph by model selection. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'select'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.select_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"select"</code> 
</p>
</td></tr>
<tr><td><code id="plot.select_+3A_...">...</code></td>
<td>

<p>System reserved (No specific usage)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+sugm.select">sugm.select</a></code>
</p>

<hr>
<h2 id='plot.sim'>
Plot Function for &quot;sim&quot;
</h2><span id='topic+plot.sim'></span>

<h3>Description</h3>

<p>Visualize the covariance matrix, the empirical covariance matrix, the adjacency matrix and the graph pattern of the true graph structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sim_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"sim"</code> 
</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm.generator">sugm.generator</a></code>, <code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>

<hr>
<h2 id='plot.slim'>
Plot Function for &quot;slim&quot;
</h2><span id='topic+plot.slim'></span>

<h3>Description</h3>

<p>Visualize the solution path of regression estimate corresponding to regularization paramters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slim'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.slim_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"slim"</code>.
</p>
</td></tr>
<tr><td><code id="plot.slim_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slim">slim</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>

<hr>
<h2 id='plot.sugm'>
Plot Function for &quot;sugm&quot;
</h2><span id='topic+plot.sugm'></span>

<h3>Description</h3>

<p>Plot sparsity level information and 3 typical sparse graphs from the graph path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sugm'
plot(x, align = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sugm_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"sugm"</code> 
</p>
</td></tr>
<tr><td><code id="plot.sugm_+3A_align">align</code></td>
<td>

<p>If <code>align = FALSE</code>, 3 plotted graphs are aligned
</p>
</td></tr>
<tr><td><code id="plot.sugm_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>

<hr>
<h2 id='predict.slim'>
Prediction for an object with S3 class <code>"slim"</code>
</h2><span id='topic+predict.slim'></span>

<h3>Description</h3>

<p>Predicting responses of the given design data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slim'
predict(object, newdata, lambda.idx = c(1:3), Y.pred.idx = c(1:5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.slim_+3A_object">object</code></td>
<td>

<p>An object with S3 class <code>"slim"</code> 
</p>
</td></tr>
<tr><td><code id="predict.slim_+3A_newdata">newdata</code></td>
<td>

<p>An optional data frame in which to look for variables with which to predict. If omitted, the traning data of the are used.
</p>
</td></tr>
<tr><td><code id="predict.slim_+3A_lambda.idx">lambda.idx</code></td>
<td>

<p>The indices of the regularizaiton parameters in the solution path to be displayed. The default values are <code>c(1:3)</code>.
</p>
</td></tr>
<tr><td><code id="predict.slim_+3A_y.pred.idx">Y.pred.idx</code></td>
<td>

<p>The indices of the predicted response vectors in the solution path to be displayed. The default values are <code>c(1:5)</code>.
</p>
</td></tr>
<tr><td><code id="predict.slim_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.slim</code> produces predicted values of the responses of the <code>newdata</code> from the estimated <code>beta</code> values in the <code>object</code>, i.e.
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{Y} = \hat{\beta}_0 + X_{new} \hat{\beta}.
    </code>
</p>
<p><br />
</p>


<h3>Value</h3>



<table>
<tr><td><code>Y.pred</code></td>
<td>

<p>The predicted response vectors based on the estimated models.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slim">slim</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load library
library(flare)
## generate data
set.seed(123)
n = 100
d = 200
d1 = 10
rho0 = 0.3
lambda = c(3:1)*sqrt(log(d)/n)
Sigma = matrix(0,nrow=d,ncol=d)
Sigma[1:d1,1:d1] = rho0
diag(Sigma) = 1
mu = rep(0,d)
X = mvrnorm(n=2*n,mu=mu,Sigma=Sigma)
X.fit = X[1:n,]
X.pred = X[(n+1):(2*n),]
eps = rt(n=n,df=n-1)
beta = c(rep(sqrt(1/3),3),rep(0,d-3))
Y.fit = X.fit%*%beta+eps

## Regression with "dantzig".
out=slim(X=X.fit,Y=Y.fit,lambda=lambda,method = "lq",q=1)

## Display results
Y=predict(out,X.pred)
</code></pre>

<hr>
<h2 id='print.roc'>
Print Function for for an object with S3 class <code>"roc"</code>
</h2><span id='topic+print.roc'></span>

<h3>Description</h3>

<p>Print the information about true positive rates, false positive rates, the area under curve and maximum F1 score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.roc_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"roc"</code>
</p>
</td></tr>
<tr><td><code id="print.roc_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm.roc">sugm.roc</a></code>, <code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>

<hr>
<h2 id='print.select'>
Print Function for for an object with S3 class <code>"select"</code>
</h2><span id='topic+print.select'></span>

<h3>Description</h3>

<p>Print the information about the model usage, graph dimension, model selection criterion, sparsity level of the optimal graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'select'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.select_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"select"</code>
</p>
</td></tr>
<tr><td><code id="print.select_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm.select">sugm.select</a></code>, <code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>

<hr>
<h2 id='print.sim'>
Print Function for for an object with S3 class <code>"sim"</code>
</h2><span id='topic+print.sim'></span>

<h3>Description</h3>

<p>Print the information about the sample size, the dimension, the pattern and sparsity of the true graph structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sim_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"sim"</code>.
</p>
</td></tr>
<tr><td><code id="print.sim_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+sugm.generator">sugm.generator</a></code>
</p>

<hr>
<h2 id='print.slim'>
Print Function for an object with S3 class <code>"slim"</code>
</h2><span id='topic+print.slim'></span>

<h3>Description</h3>

<p>Print a summary of the information about an object with S3 class <code>"slim"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.slim_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"slim"</code>.
</p>
</td></tr>
<tr><td><code id="print.slim_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This call simply outlines the options used for computing a slim object.
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slim">slim</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>

<hr>
<h2 id='print.sugm'>
Print Function for an object with S3 class <code>"sugm"</code>
</h2><span id='topic+print.sugm'></span>

<h3>Description</h3>

<p>Print a summary of the information about an object with S3 class <code>"slim"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sugm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sugm_+3A_x">x</code></td>
<td>

<p>An object with S3 class <code>"sugm"</code>.
</p>
</td></tr>
<tr><td><code id="print.sugm_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This call simply outlines the options used for computing a sugm object.
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>

<hr>
<h2 id='slim'>
Sparse Linear Regression using Nonsmooth Loss Functions and L1 Regularization
</h2><span id='topic+slim'></span>

<h3>Description</h3>

<p>The function &quot;slim&quot; implements a family of Lasso variants for estimating high dimensional sparse linear models including Dantzig Selector, LAD Lasso, SQRT Lasso, Lq Lasso for estimating high dimensional sparse linear model. We adopt the alternating direction method of multipliers (ADMM) and convert the original optimization problem into a sequential L1-penalized least square minimization problem, which can be efficiently solved by combining the linearization and multi-stage screening of varialbes. Missing values can be tolerated for Dantzig selector in the design matrix and response vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slim(X, Y, lambda = NULL, nlambda = NULL, 
     lambda.min.value = NULL,lambda.min.ratio = NULL, 
     rho = 1, method="lq", q = 2, res.sd = FALSE, 
     prec = 1e-5, max.ite = 1e5, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slim_+3A_y">Y</code></td>
<td>
<p>The <code class="reqn">n</code>-dimensional response vector.</p>
</td></tr>
<tr><td><code id="slim_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">n</code> by <code class="reqn">d</code> design matrix. <code>d</code><code class="reqn"> \ge </code>2 is required.</p>
</td></tr>
<tr><td><code id="slim_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decresing positive numbers to control the regularization. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. Default value is from <code>lambda.max</code> to <code>lambda.min.ratio*lambda.max</code>. For Lq regression, the default value of <code>lambda.max</code> is <code class="reqn">\pi\sqrt{\log(d)/n}</code>. For Dantzig selector, the default value of <code>lambda.max</code> is the minimum regularization parameter, which yields an all-zero estiamtes.</p>
</td></tr>
<tr><td><code id="slim_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of values used in <code>lambda</code>. Default value is 5.</p>
</td></tr>
<tr><td><code id="slim_+3A_lambda.min.value">lambda.min.value</code></td>
<td>
<p>The smallest value for <code>lambda</code>, as a fraction of the uppperbound (<code>lambda.max</code>) of the regularization parameter. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>lambda.max</code> to <code>lambda.min.ratio*lambda.max</code> in log scale. The default value is <code class="reqn">\log(d)/n</code> for for Dantzig selector 0.3<code>*lambda.max</code> for Lq Lasso.</p>
</td></tr>
<tr><td><code id="slim_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>The smallest ratio of the value for <code>lambda</code>. The default value is 0.3 for Lq Lasso and 0.5 for Dantzig selector.</p>
</td></tr>
<tr><td><code id="slim_+3A_rho">rho</code></td>
<td>
<p>The penalty parameter used in <code>ADMM</code>. The default value is <code class="reqn">\sqrt{d}</code>.</p>
</td></tr>
<tr><td><code id="slim_+3A_method">method</code></td>
<td>
<p>Dantzig selector is applied if <code>method = "dantzig"</code> and <code class="reqn">L_q</code> Lasso is applied if <code>method = "lq"</code>. Standard Lasso is provided if <code>method = "lasso"</code>. The default value is <code>"lq"</code>.</p>
</td></tr>
<tr><td><code id="slim_+3A_q">q</code></td>
<td>
<p>The loss function used in Lq Lasso. It is only applicable when <code>method = "lq"</code> and must be in [1,2]. The default value is 2.</p>
</td></tr>
<tr><td><code id="slim_+3A_res.sd">res.sd</code></td>
<td>
<p>Flag of whether the response varialbles are standardized. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="slim_+3A_prec">prec</code></td>
<td>
<p>Stopping criterion. The default value is 1e-5.</p>
</td></tr>
<tr><td><code id="slim_+3A_max.ite">max.ite</code></td>
<td>
<p>The iteration limit. The default value is 1e5.</p>
</td></tr>
<tr><td><code id="slim_+3A_verbose">verbose</code></td>
<td>
<p>Tracing information printing is disabled if <code>verbose = FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Standard Lasso<br />
</p>
<p style="text-align: center;"><code class="reqn">
    \min {\frac{1}{2n}}|| Y - X \beta ||_2^2 + \lambda || \beta ||_1
    </code>
</p>
<p><br />
Dantzig selector solves the following optimization problem<br />
</p>
<p style="text-align: center;"><code class="reqn">
    \min || \beta ||_1, \quad \textrm{s.t. } || X'(Y - X \beta) ||_{\infty} &lt; \lambda
    </code>
</p>
<p><br />
<code class="reqn">L_q</code> loss Lasso solves the following optimization problem<br />
</p>
<p style="text-align: center;"><code class="reqn">
    \min n^{-\frac{1}{q}}|| Y - X \beta ||_q + \lambda || \beta ||_1
    </code>
</p>
<p><br />
where <code class="reqn">1&lt;= q &lt;=2</code>. Lq Lasso is equivalent to LAD Lasso and SQR Lasso when <code class="reqn">q=1</code> and <code class="reqn">q=2</code> respectively.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"slim"</code> is returned: 
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>A matrix of regression estimates whose columns correspond to regularization parameters.
</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>The value of intercepts corresponding to regularization parameters. </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The value of <code>Y</code> used in the program. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The value of <code>X</code> used in the program. </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> used in the program.
</p>
</td></tr>
<tr><td><code>nlambda</code></td>
<td>

<p>The number of values used in <code>lambda</code>.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The <code>method</code> from the input. 
</p>
</td></tr>
<tr><td><code>sparsity</code></td>
<td>

<p>The sparsity levels of the solution path.
</p>
</td></tr>
<tr><td><code>ite</code></td>
<td>

<p>A list of vectors where ite[[1]] is the number of external iteration and ite[[2]] is the number of internal iteration with the i-th entry corresponding to the i-th regularization parameter. 
</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>
<p>The <code>verbose</code> from the input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. E. Candes and T. Tao. The Dantzig selector: Statistical estimation when p is much larger than n. <em>Annals of Statistics</em>, 2007.<br />
2. A. Belloni, V. Chernozhukov and L. Wang. Pivotal recovery of sparse signals via conic programming. <em>Biometrika</em>, 2012.<br />
3. L. Wang. L1 penalized LAD estimator for high dimensional linear regression. <em>Journal of Multivariate Analysis</em>, 2012.<br />
4. J. Liu and J. Ye. Efficient L1/Lq Norm Regularization. <em>Technical Report</em>, 2010.
5. S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein, Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers. <em>Foundations and Trends in Machine Learning</em>, 2011.
6. B. He and X. Yuan. On non-ergodic convergence rate of Douglas-Rachford alternating direction method of multipliers. <em>Technical Report</em>, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flare-package">flare-package</a></code>, <code><a href="#topic+print.slim">print.slim</a></code>, <code><a href="#topic+plot.slim">plot.slim</a></code>, <code><a href="#topic+coef.slim">coef.slim</a></code> and <code><a href="#topic+predict.slim">predict.slim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load library
library(flare)
## generate data
n = 50
d = 100
X = matrix(rnorm(n*d), n, d)
beta = c(3,2,0,1.5,rep(0,d-4))
eps = rnorm(n)
Y = X%*%beta + eps
nlamb = 5
ratio = 0.3

## Regression with "dantzig", general "lq" and "lasso" respectively
out1 = slim(X=X,Y=Y,nlambda=nlamb,lambda.min.ratio=ratio,method="dantzig")
out2 = slim(X=X,Y=Y,nlambda=nlamb,lambda.min.ratio=ratio,method="lq",q=1)
out3 = slim(X=X,Y=Y,nlambda=nlamb,lambda.min.ratio=ratio,method="lq",q=1.5)
out4 = slim(X=X,Y=Y,nlambda=nlamb,lambda.min.ratio=ratio,method="lq",q=2)
out5 = slim(X=X,Y=Y,nlambda=nlamb,lambda.min.ratio=ratio,method="lasso")

## Display results
print(out4)
plot(out4)
coef(out4)
</code></pre>

<hr>
<h2 id='sugm'>
High-deimensional Sparse Undirected Graphical Models.
</h2><span id='topic+sugm'></span>

<h3>Description</h3>

<p>The function &quot;sugm&quot; estimates sparse undirected graphical models, i.e. Gaussian precision matrix, in high dimensions. We adopt two estimation procedures based on column by column regression scheme: (1) Tuning-Insensitive Graph Estimation and Regression based on square root Lasso (tiger); (2) The Constrained L1 Minimization for Sparse Precision Matrix Estimation using either L1 penalty (clime). The optimization algorithm for all three methods are implemented based on the alternating direction method of multipliers (ADMM) with the linearization method and multi-stage screening of variables. Missing values can be tolerated for CLIME in the data matrix. The computation is memory-optimized using the sparse matrix output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sugm(data, lambda = NULL, nlambda = NULL, lambda.min.ratio = NULL, 
     rho = NULL, method = "tiger", sym = "or", shrink=NULL, 
     prec = 1e-4, max.ite = 1e4, standardize = FALSE, 
     perturb = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sugm_+3A_data">data</code></td>
<td>
<p>There are 2 options for <code>"clime"</code>: (1) <code>data</code> is an <code>n</code> by <code>d</code> data matrix (2) a <code>d</code> by <code>d</code> sample covariance matrix. The program automatically identifies the input matrix by checking the symmetry. (<code>n</code> is the sample size and <code>d</code> is the dimension). For <code>"tiger"</code>, covariance input is not supported and <code>d</code><code class="reqn"> \ge </code>3 is required. For <code>"clime"</code>, <code>d</code><code class="reqn"> \ge </code>2 is required.</p>
</td></tr>
<tr><td><code id="sugm_+3A_lambda">lambda</code></td>
<td>
<p>A sequence of decresing positive numbers to control the regularization. Typical usage is to leave the input <code>lambda = NULL</code> and have the program compute its own <code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.min.ratio</code>. Users can also specify a sequence to override this. Default value is from <code>lambda.max</code> to <code>lambda.min.ratio*lambda.max</code>. For <code>"tiger"</code>, the default value of <code>lambda.max</code> is <code class="reqn">\pi\sqrt{\log(d)/n}</code>. For <code>"clime"</code> , the default value of <code>lambda.max</code> is the minimum regularization parameter, which yields an all-zero off-diagonal estiamtes.</p>
</td></tr>
<tr><td><code id="sugm_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of values used in <code>lambda</code>. Default value is 5.</p>
</td></tr>
<tr><td><code id="sugm_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>The smallest value for <code>lambda</code>, as a fraction of the uppperbound (<code>lambda.max</code>) of the regularization parameter. The program can automatically generate <code>lambda</code> as a sequence of length = <code>nlambda</code> starting from <code>lambda.max</code> to <code>lambda.min.ratio*lambda.max</code> in log scale. The default value is 0.25 for <code>"tiger"</code> and 0.5 for <code>"clime"</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_rho">rho</code></td>
<td>
<p>Penalty parameter used in the optimization algorithm for <code>clime</code>. The default value is <code class="reqn">\sqrt{d}</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_method">method</code></td>
<td>
<p><code>"tiger"</code> is applied if <code>method = "tiger"</code> and <code>"clime"</code> is applied if <code>method="clime"</code>. Default value is <code>"tiger"</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_sym">sym</code></td>
<td>
<p>Symmetrization of output graphs. If <code>sym = "and"</code>, the edge between node <code>i</code> and node <code>j</code> is selected ONLY when both node <code>i</code> and node <code>j</code> are selected as neighbors for each other. If <code>sym = "or"</code>, the edge is selected when either node <code>i</code> or node <code>j</code> is selected as the neighbor for each other. The default value is <code>"or"</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_shrink">shrink</code></td>
<td>
<p>Shrinkage of regularization parameter based on precision of estimation. The default value is 1.5 if <code>method = "clime"</code> and the default value is 0 if <code>method="tiger"</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_prec">prec</code></td>
<td>
<p>Stopping criterion. The default value is 1e-4.</p>
</td></tr>
<tr><td><code id="sugm_+3A_max.ite">max.ite</code></td>
<td>
<p>The iteration limit. The default value is 1e4.</p>
</td></tr>
<tr><td><code id="sugm_+3A_standardize">standardize</code></td>
<td>
<p>Variables are standardized to have mean zero and unit standard deviation if <code>standardize = TRUE</code>. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_perturb">perturb</code></td>
<td>
<p>The diagonal of <code>Sigma</code> is added by a positive value to guarantee that <code>Sigma</code> is positive definite if <code>perturb = TRUE</code>. User can specify a numeric value for <code>perturbe</code>. The default value is <code>perturb = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sugm_+3A_verbose">verbose</code></td>
<td>
<p>Tracing information printing is disabled if <code>verbose = FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CLIME solves the following minimization problem<br />
</p>
<p style="text-align: center;"><code class="reqn">
    \min || \Omega ||_1 \quad \textrm{s.t. } || S \Omega - I ||_\infty \le \lambda,
  </code>
</p>
<p><br />
where <code class="reqn">||\cdot||_1</code> and <code class="reqn">||\cdot||_\infty</code> are element-wise 1-norm and <code class="reqn">\infty</code>-norm respectively. 
</p>
<p><code>"tiger"</code> solves the following minimization problem<br />
</p>
<p style="text-align: center;"><code class="reqn">
    \min ||X-XB||_{2,1} + \lambda ||B||_1 \quad \textrm{s.t. } B_{jj} = 0,
  </code>
</p>
<p><br />
where <code class="reqn">||\cdot||_{1}</code> and <code class="reqn">||\cdot||_{2,1}</code> are element-wise 1-norm and <code class="reqn">L_{2,1}</code>-norm respectively.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"sugm"</code> is returned:  
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> data matrix or <code>d</code> by <code>d</code> sample covariance matrix from the input.
</p>
</td></tr>
<tr><td><code>cov.input</code></td>
<td>

<p>An indicator of the sample covariance. 
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The sequence of regularization parameters <code>lambda</code> used in the program.
</p>
</td></tr>
<tr><td><code>nlambda</code></td>
<td>

<p>The number of values used in <code>lambda</code>.
</p>
</td></tr>
<tr><td><code>icov</code></td>
<td>

<p>A list of <code>d</code> by <code>d</code> precision matrices corresponding to regularization parameters.
</p>
</td></tr>
<tr><td><code>sym</code></td>
<td>

<p>The <code>sym</code> from the input.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>The <code>method</code> from the input. 
</p>
</td></tr>
<tr><td><code>path</code></td>
<td>

<p>A list of <code>d</code> by <code>d</code> adjacency matrices of estimated graphs as a graph path corresponding to <code>lambda</code>.
</p>
</td></tr>
<tr><td><code>sparsity</code></td>
<td>

<p>The sparsity levels of the graph path.
</p>
</td></tr>
<tr><td><code>ite</code></td>
<td>

<p>If <code>method = "clime"</code>, it is a list of two matrices where ite[[1]] is the number of external iterations and ite[[2]] is the number of internal iterations with the entry of (i,j) as the number of iteration of i-th column and j-th lambda. If <code>method="tiger"</code>, it is a matrix of iteration with the entry of (i,j) as the number of iteration of i-th column and j-th lambda. 
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>It is a <code>d</code> by <code>nlambda</code> matrix. Each row contains the number of nonzero coefficients along the lasso solution path. 
</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>The <code>standardize</code> from the input.</p>
</td></tr>
<tr><td><code>perturb</code></td>
<td>
<p>The <code>perturb</code> from the input.</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>
<p>The <code>verbose</code> from the input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. T. Cai, W. Liu and X. Luo. A constrained L1 minimization approach to sparse precision matrix estimation. <em>Journal of the American Statistical Association</em>, 2011. <br />
2. H. Liu, L. Wang. TIGER: A tuning-insensitive approach for optimally estimating large undirected graphs. <em>Technical Report</em>, 2012. <br />
3. B. He and X. Yuan. On non-ergodic convergence rate of Douglas-Rachford alternating direction method of multipliers. <em>Technical Report</em>, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flare-package">flare-package</a></code>, <code><a href="#topic+sugm.generator">sugm.generator</a></code>, <code><a href="#topic+sugm.select">sugm.select</a></code>, <code><a href="#topic+sugm.plot">sugm.plot</a></code>, <code><a href="#topic+sugm.roc">sugm.roc</a></code>, <code><a href="#topic+plot.sugm">plot.sugm</a></code>, <code><a href="#topic+plot.select">plot.select</a></code>, <code><a href="#topic+plot.roc">plot.roc</a></code>, <code><a href="#topic+plot.sim">plot.sim</a></code>, <code><a href="#topic+print.sugm">print.sugm</a></code>, <code><a href="#topic+print.select">print.select</a></code>, <code><a href="#topic+print.roc">print.roc</a></code> and <code><a href="#topic+print.sim">print.sim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load package required
library(flare)

## generating data
n = 50
d = 50
D = sugm.generator(n=n,d=d,graph="band",g=1)
plot(D)

## sparse precision matrix estimation with method "clime"
out1 = sugm(D$data, method = "clime")
plot(out1)
sugm.plot(out1$path[[4]])

## sparse precision matrix estimation with method "tiger"
out2 = sugm(D$data, method = "tiger")
plot(out2)
sugm.plot(out2$path[[5]])
</code></pre>

<hr>
<h2 id='sugm.generator'>
Data generator for sparse undirected graph estimation.
</h2><span id='topic+sugm.generator'></span>

<h3>Description</h3>

<p>Implements the data generation from multivariate normal distributions with different graph structures, including <code>"random"</code>, <code>"hub"</code>, <code>"cluster"</code>, <code>"band"</code>, and <code>"scale-free"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sugm.generator(n = 200, d = 50, graph = "random", v = NULL, u = NULL,
      g = NULL, prob = NULL, seed = NULL, vis = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sugm.generator_+3A_n">n</code></td>
<td>

<p>The number of observations (sample size). The default value is <code class="reqn">200</code>.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_d">d</code></td>
<td>

<p>The number of variables (dimension). For <code>"hub"</code> and <code>"cluster"</code>, <code>d</code><code class="reqn"> \ge </code>4 is required. For <code>"random"</code>, <code>"band"</code> and <code>"scale-free"</code>, <code>d</code><code class="reqn"> \ge </code>3 is required. The default value is <code class="reqn">50</code>.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_graph">graph</code></td>
<td>

<p>The graph structure with 5 options: <code>"random"</code>, <code>"hub"</code>, <code>"cluster"</code>, <code>"band"</code>, and <code>"scale-free"</code>.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_v">v</code></td>
<td>

<p>The off-diagonal elements of the precision matrix, controlling the magnitude of partial correlations with <code>u</code>. The default value is 0.3.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_u">u</code></td>
<td>

<p>A positive number being added to the diagonal elements of the precision matrix, to control the magnitude of partial correlations. The default value is 0.1.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_g">g</code></td>
<td>

<p>For <code>"cluster"</code> or <code>"hub"</code> graph, <code>g</code> is the number of hubs or clusters in the graph. The default value is about <code>d</code>/20 if <code>d</code><code class="reqn"> \ge</code> 40 and 2 if <code>d</code><code class="reqn"> &lt;</code> 40. For <code>"band"</code> graph, <code>g</code> is the bandwidth and the default value is <code class="reqn">1</code>. NOT applicable to <code>"random"</code> graph.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_prob">prob</code></td>
<td>

<p>For <code>"random"</code> graph, it is the probability that a pair of nodes has an edge. The default value is 3/<code>d</code>. For <code>"cluster"</code> graph, it is the probability that a pair of nodes has an edge in each cluster. The default value is 6<code class="reqn">*</code><code>g/d</code> if <code>d/g</code><code class="reqn"> \le</code> 30 and 0.3 if <code>d/g</code><code class="reqn"> &gt;</code> 30. NOT applicable to <code>"hub"</code>, <code>"band"</code>, and <code>"scale-free"</code> graphs.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_seed">seed</code></td>
<td>

<p>Set seed for data generation. The default value is 1.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_vis">vis</code></td>
<td>

<p>Visualize the adjacency matrix of the true graph structure, the graph pattern, the covariance matrix and the empirical covariance matrix. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="sugm.generator_+3A_verbose">verbose</code></td>
<td>

<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the adjacency matrix <code>theta</code>, the graph patterns are generated as below:<br /><br />
(I) <code>"random"</code>: Each pair of off-diagonal elements are randomly set <code>theta[i,j]=theta[j,i]=1</code> for <code>i!=j</code> with probability <code>prob</code>, and <code>0</code> other wise. It results in about <code>d*(d-1)*prob/2</code> edges in the graph.<br /><br />
(II)<code>"hub"</code>:The row/columns are evenly partitioned into <code>g</code> disjoint groups. Each group is associated with a &quot;center&quot; row <code>i</code> in that group. Each pair of off-diagonal elements are set <code>theta[i,j]=theta[j,i]=1</code> for <code>i!=j</code> if <code>j</code> also belongs to the same group as <code>i</code> and <code>0</code> otherwise. It results in <code>d - g</code> edges in the graph.<br /><br />
(III)<code>"cluster"</code>:The row/columns are evenly partitioned into <code>g</code> disjoint groups. Each pair of off-diagonal elements are set <code>theta[i,j]=theta[j,i]=1</code> for <code>i!=j</code> with the probability <code>prob</code>if both <code>i</code> and <code>j</code> belong to the same group, and <code>0</code> other wise. It results in about <code>g*(d/g)*(d/g-1)*prob/2</code> edges in the graph.<br /><br />
(IV)<code>"band"</code>: The off-diagonal elements are set to be <code>theta[i,j]=1</code> if <code>1&lt;=|i-j|&lt;=g</code> and <code>0</code> other wise. It results in <code>(2d-1-g)*g/2</code> edges in the graph.<br /><br />
(V) <code>"scale-free"</code>: The graph is generated using B-A algorithm. The initial graph has two connected nodes and each new node is connected to only one node in the existing graph with the probability proportional to the degree of the each node in the existing graph. It results in <code>d</code> edges in the graph.<br /><br />
</p>
<p>The adjacency matrix <code>theta</code> has all diagonal elements equal to <code>0</code>. To obtain a positive definite covariance matrix, the smallest eigenvalue of <code>theta*v</code> (denoted by <code>e</code>) is computed. Then we set the covariance matrix equal to <code>cov2cor(solve(theta*v+(|e|+0.1+u)*I))</code> to generate multivariate normal data.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;sim&quot; is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>The <code>n</code> by <code>d</code> matrix for the generated data
</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>

<p>The covariance matrix for the generated data
</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>

<p>The precision matrix for the generated data
</p>
</td></tr>
<tr><td><code>sigmahat</code></td>
<td>

<p>The empirical covariance matrix for the generated data
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>

<p>The adjacency matrix of true graph structure (in sparse matrix representation) for the generated data
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flare">flare</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load package required
library(flare)

## band graph with bandwidth 3
L = sugm.generator(graph = "band", g = 3)
plot(L)

## random sparse graph
L = sugm.generator(vis = TRUE)

## hub graph with 6 hubs
L = sugm.generator(graph = "hub", g = 6, vis = TRUE)

## cluster graph with 8 clusters
L = sugm.generator(graph = "cluster", g = 8, vis = TRUE)

## scale-free graphs
L = sugm.generator(graph="scale-free", vis = TRUE)
</code></pre>

<hr>
<h2 id='sugm.plot'>
Graph visualization for an object with S3 class <code>"sugm"</code>
</h2><span id='topic+sugm.plot'></span>

<h3>Description</h3>

<p>Implements the graph visualization using adjacency matrix. It can automatic organize 2D embedding layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sugm.plot(G, epsflag = FALSE, graph.name = "default", cur.num = 1, 
          location)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sugm.plot_+3A_g">G</code></td>
<td>

<p>The adjacency matrix corresponding to the graph.
</p>
</td></tr>
<tr><td><code id="sugm.plot_+3A_epsflag">epsflag</code></td>
<td>

<p>If <code>epsflag = TRUE</code>, save the plot as an eps file in the target directory. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="sugm.plot_+3A_graph.name">graph.name</code></td>
<td>

<p>The name of the output eps files. The default value is &quot;default&quot;.
</p>
</td></tr>
<tr><td><code id="sugm.plot_+3A_cur.num">cur.num</code></td>
<td>

<p>The number of plots saved as eps files. Only applicable when <code>epsflag = TRUE</code>. The default value is 1.
</p>
</td></tr>
<tr><td><code id="sugm.plot_+3A_location">location</code></td>
<td>

<p>Target directory. The default value is the current working directory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can change <code>cur.num</code> to plot several figures and select the best one. The implementation is based on the popular package &quot;igraph&quot;.
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flare">flare</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load package required
library(flare)

## visualize the hub graph
L = sugm.generator(graph = "hub")
sugm.plot(L$theta)

## visualize the band graph
L = sugm.generator(graph = "band",g=5)
sugm.plot(L$theta)

## visualize the cluster graph
L = sugm.generator(graph = "cluster")
sugm.plot(L$theta)

## Not run: 
#show working directory
getwd()
#plot 5 graphs and save the plots as eps files in the working directory  
sugm.plot(L$theta, epsflag = TRUE, cur.num = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='sugm.roc'>
Draw ROC Curve for an object with S3 class <code>"sugm"</code>
</h2><span id='topic+sugm.roc'></span>

<h3>Description</h3>

<p>Draws ROC curve for a graph path according to the true graph structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sugm.roc(path, theta, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sugm.roc_+3A_path">path</code></td>
<td>

<p>A graph path.
</p>
</td></tr>
<tr><td><code id="sugm.roc_+3A_theta">theta</code></td>
<td>

<p>The true graph structure.
</p>
</td></tr>
<tr><td><code id="sugm.roc_+3A_verbose">verbose</code></td>
<td>

<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To avoid the horizontal oscillation, false positive rates is automatically sorted in the ascent oder and true positive rates also follow the same order.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;roc&quot; is returned:
</p>
<table>
<tr><td><code>F1</code></td>
<td>

<p>The F1 scores along the graph path.
</p>
</td></tr>
<tr><td><code>tp</code></td>
<td>

<p>The true positive rates along the graph path
</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>

<p>The false positive rates along the graph paths
</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>

<p>Area under the ROC curve
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a lasso regression,  the number of nonzero coefficients is at most <code>n-1</code>. If <code>d&gt;&gt;n</code>, even when regularization parameter is very small, the estimated graph may still be sparse. In this case, the AUC may not be a good choice to evaluate the performance.
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load package required
library(flare)

#generate data
L = sugm.generator(d = 30, graph = "random", prob = 0.1)
out1 = sugm(L$data, lambda=10^(seq(log10(.4), log10(0.03), length.out=20)))

#draw ROC curve
Z1 = sugm.roc(out1$path,L$theta)

#Maximum F1 score
max(Z1$F1)
</code></pre>

<hr>
<h2 id='sugm.select'>
Model selection for high-dimensional undirected graphical models
</h2><span id='topic+sugm.select'></span>

<h3>Description</h3>

<p>Implements the regularization parameter selection for high dimensional undirected graphical models. The optional approaches are stability approach to regularization selection (stars) and cross validation selection (cv).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sugm.select(est, criterion = "stars", stars.subsample.ratio = NULL, 
            stars.thresh = 0.1,rep.num = 20, fold = 5, 
            loss="likelihood", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sugm.select_+3A_est">est</code></td>
<td>

<p>An object with S3 class <code>"sugm"</code>
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_criterion">criterion</code></td>
<td>

<p>Model selection criterion. <code>"stars"</code> and <code>"cv"</code> are available for both graph estimation methods. The default value is <code>"stars"</code>.
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_stars.subsample.ratio">stars.subsample.ratio</code></td>
<td>

<p>The subsampling ratio. The default value is <code>10*sqrt(n)/n</code> when <code>n&gt;144</code> and <code>0.8</code> when <code>n&lt;=144</code>, where <code>n</code> is the sample size. Only applicable when <code>criterion = "stars"</code>.
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_stars.thresh">stars.thresh</code></td>
<td>

<p>The variability threshold in stars. The default value is <code>0.1</code>. Only applicable when <code>criterion = "stars"</code>.
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_rep.num">rep.num</code></td>
<td>

<p>The number of subsamplings. The default value is <code>20</code>. 
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_fold">fold</code></td>
<td>

<p>The number of folds used in cross validation. The default value is <code>5</code>. Only applicable when <code>criterion = "cv"</code>.
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_loss">loss</code></td>
<td>

<p>Loss to be used in cross validation. Two losses are available: <code>"likelihood"</code> and <code>"tracel2"</code>. Default <code>"likelihood"</code>. Only applicable when <code>criterion = "cv"</code>.
</p>
</td></tr>
<tr><td><code id="sugm.select_+3A_verbose">verbose</code></td>
<td>

<p>If <code>verbose = FALSE</code>, tracing information printing is disabled. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stability approach to regularization selection (stars) is a natural way to select optimal regularization parameter for all three estimation methods. It selects the optimal graph by variability of subsamplings and tends to over-select edges in Gaussian graphical models. Besides selecting the regularization parameters, stars can also provide an additional estimated graph by merging the corresponding subsampled graphs using the frequency counts. The K-fold cross validation is also provided for selecting the parameter <code>lambda</code>, and two loss functions are adopted as follow
</p>
<p style="text-align: center;"><code class="reqn">
likelihood: Tr(\Sigma \Omega) - \log|\Omega|
</code>
</p>

<p style="text-align: center;"><code class="reqn">
tracel2: Tr(diag(\Sigma \Omega - I)^2).
</code>
</p>



<h3>Value</h3>

<p>An object with S3 class &quot;select&quot; is returned:
</p>
<table>
<tr><td><code>refit</code></td>
<td>

<p>The optimal graph selected from the graph path
</p>
</td></tr>
<tr><td><code>opt.icov</code></td>
<td>

<p>The optimal precision matrix selected.
</p>
</td></tr>
<tr><td><code>merge</code></td>
<td>

<p>The graph path estimated by merging the subsampling paths. Only applicable when the input <code>criterion = "stars"</code>.
</p>
</td></tr>
<tr><td><code>variability</code></td>
<td>

<p>The variability along the subsampling paths. Only applicable when the input <code>criterion = "stars"</code>.
</p>
</td></tr>
<tr><td><code>opt.index</code></td>
<td>

<p>The index of the selected regularization parameter.
</p>
</td></tr>
<tr><td><code>opt.lambda</code></td>
<td>

<p>The selected regularization/thresholding parameter.
</p>
</td></tr>
<tr><td><code>opt.sparsity</code></td>
<td>

<p>The sparsity level of <code>"refit"</code>.
</p>
</td></tr>
</table>
<p>and anything else inluded in the input <code>est</code>
</p>


<h3>Note</h3>

<p>The model selection is NOT available when the data input is the sample covaraince matrix.
</p>


<h3>Author(s)</h3>

<p>Xingguo Li, Tuo Zhao, Lie Wang, Xiaoming Yuan and Han Liu <br />
Maintainer: Xingguo Li &lt;xingguo.leo@gmail.com&gt;
</p>


<h3>References</h3>

<p>1. T. Cai, W. Liu and X. Luo. A constrained <code class="reqn">\ell_1</code> minimization approach to sparse precision matrix estimation. <em>Journal of the American Statistical Association</em>, 2011.<br />
2. B. He and X. Yuan. On non-ergodic convergence rate of Douglas-Rachford alternating direction method of multipliers. <em>Technical Report</em>, 2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sugm">sugm</a></code> and <code><a href="#topic+flare-package">flare-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load package required
library(flare)

#generate data
L = sugm.generator(d = 10, graph="hub")
out1 = sugm(L$data)

#model selection using stars
#out1.select1 = sugm.select(out1, criterion = "stars", stars.thresh = 0.1)
#plot(out1.select1)

#model selection using cross validation
out1.select2 = sugm.select(out1, criterion = "cv")
plot(out1.select2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
