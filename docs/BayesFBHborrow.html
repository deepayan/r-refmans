<!DOCTYPE html><html><head><title>Help for package BayesFBHborrow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesFBHborrow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.beta_MH_MALA'><p>Proposal beta with a Metropolis Adjusted Langevin (MALA)</p></a></li>
<li><a href='#.beta_MH_NR'><p>Newton Raphson MH move</p></a></li>
<li><a href='#.beta_MH_RW'><p>Beta Metropolis-Hastings Random walk move</p></a></li>
<li><a href='#.beta_mom'><p>Mean for MALA using derivative for beta proposal</p></a></li>
<li><a href='#.beta_mom.NR.fun'><p>First and second derivative of target for mode and variance of proposal</p></a></li>
<li><a href='#.beta.MH.RW.glm'><p>Beta MH RW sampler from freq PEM fit</p></a></li>
<li><a href='#.birth_move'><p>Birth move in RJMCMC</p></a></li>
<li><a href='#.dataframe_fun'><p>Create data.frame for piecewise exponential models</p></a></li>
<li><a href='#.death_move'><p>Death move in RJMCMC</p></a></li>
<li><a href='#.glmFit'><p>Fit frequentist piecewise exponential model for MLE and information matrix of beta</p></a></li>
<li><a href='#.ICAR_calc'><p>Calculate covariance matrix in the MVN-ICAR</p></a></li>
<li><a href='#.input_check'><p>Input checker</p></a></li>
<li><a href='#.J_RJMCMC'><p>RJMCMC (with Bayesian Borrowing)</p></a></li>
<li><a href='#.J_RJMCMC_NoBorrow'><p>RJMCMC (without Bayesian Borrowing)</p></a></li>
<li><a href='#.lambda_0_MH_cp'><p>Lambda_0 MH step, proposal from conditional conjugate posterior</p></a></li>
<li><a href='#.lambda_0_MH_cp_NoBorrow'><p>Lambda_0 MH step, proposal from conditional conjugate posterior</p></a></li>
<li><a href='#.lambda_conj_prop'><p>Propose lambda from a gamma conditional conjugate posterior proposal</p></a></li>
<li><a href='#.lambda_MH_cp'><p>Lambda MH step, proposal from conditional conjugate posterior</p></a></li>
<li><a href='#.lgamma_ratio'><p>Calculate log gamma ratio for two different parameter values</p></a></li>
<li><a href='#.llikelihood_ratio_beta'><p>Loglikelihood ratio calculation for beta parameters</p></a></li>
<li><a href='#.llikelihood_ratio_lambda'><p>Log likelihood for lambda / lambda_0 update</p></a></li>
<li><a href='#.log_likelihood'><p>Log likelihood function</p></a></li>
<li><a href='#.logsumexp'><p>Computes the logarithmic sum of an exponential</p></a></li>
<li><a href='#.lprop_density_beta'><p>Log density of proposal for MALA</p></a></li>
<li><a href='#.lprop.dens.beta.NR'><p>log Gaussian proposal density for Newton Raphson proposal</p></a></li>
<li><a href='#.ltau_dprior'><p>Calculate log density tau prior</p></a></li>
<li><a href='#.mu_update'><p>Calculate mu posterior update</p></a></li>
<li><a href='#.normalize_prob'><p>Normalize a set of probability to one, using the the log-sum-exp trick</p></a></li>
<li><a href='#.nu_sigma_update'><p>Calculates nu and sigma2 for the Gaussian Markov random field prior,</p>
for a given split point j</a></li>
<li><a href='#.shuffle_split_point_location'><p>Metropolis Hastings step: shuffle the split point locations (with</p>
Bayesian borrowing)</a></li>
<li><a href='#.shuffle_split_point_location_NoBorrow'><p>Metropolis Hastings step: shuffle the split point locations (without</p>
Bayesian borrowing)</a></li>
<li><a href='#.sigma2_update'><p>Calculate sigma2 posterior update</p></a></li>
<li><a href='#.tau_update'><p>Sample tau from posterior distribution</p></a></li>
<li><a href='#BayesFBHborrow'><p>BayesFBHborrow: Run MCMC for a piecewise exponential model</p></a></li>
<li><a href='#BayesFBHborrow.NoBorrow'><p>Run the MCMC sampler without Bayesian Borrowing</p></a></li>
<li><a href='#BayesFBHborrow.WBorrow'><p>Run the MCMC sampler with Bayesian Borrowing</p></a></li>
<li><a href='#coef.BayesFBHborrow'><p>Extract mean posterior values</p></a></li>
<li><a href='#GibbsMH'><p>S3 generic, calls the correct GibbsMH sampler</p></a></li>
<li><a href='#GibbsMH.NoBorrow'><p>GibbsMH sampler, without Bayesian Borrowing</p></a></li>
<li><a href='#GibbsMH.WBorrow'><p>GibbsMH sampler, with Bayesian Borrowing</p></a></li>
<li><a href='#group_summary'><p>Create group level data</p></a></li>
<li><a href='#init_lambda_hyperparameters'><p>Initialize lambda hyperparameters</p></a></li>
<li><a href='#piecewise_exp_cc'><p>Example data, simulated from a piecewise exponential model.</p></a></li>
<li><a href='#piecewise_exp_hist'><p>Example data, simulated from a piecewise exponential model.</p></a></li>
<li><a href='#plot_hist'><p>Plot histogram from MCMC samples</p></a></li>
<li><a href='#plot_matrix'><p>Plot smoothed baseline hazards</p></a></li>
<li><a href='#plot_trace'><p>Plot MCMC trace</p></a></li>
<li><a href='#plot.BayesFBHborrow'><p>Plot the MCMC results</p></a></li>
<li><a href='#summary.BayesFBHborrow'><p>Summarize fixed MCMC results</p></a></li>
<li><a href='#weibull_cc'><p>Example data, simulated from a Weibull distribution.</p></a></li>
<li><a href='#weibull_hist'><p>Example data, simulated from a Weibull distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Dynamic Borrowing with Flexible Baseline Hazard
Function</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows Bayesian borrowing from a historical dataset for time-to-
    event data. A flexible baseline hazard function is achieved via a piecewise
    exponential likelihood with time varying split points and smoothing prior on the
    historic baseline hazards. The method is described in Scott and Lewin (2024) 
    &lt;<a href="https://doi.org/10.48550/arXiv.2401.06082">doi:10.48550/arXiv.2401.06082</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Darren Scott [aut, cre],
  Sophia Axillus [aut]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tibble, readxl, testthat (&ge; 3.0.0), rmarkdown, ggfortify,
condSURV</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, stats, survival, invgamma, mvtnorm, checkmate,
magrittr, ggplot2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 14:15:14 UTC; hidden</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Darren Scott &lt;darren.scott@astrazeneca.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-27 19:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.beta_MH_MALA'>Proposal beta with a Metropolis Adjusted Langevin (MALA)</h2><span id='topic+.beta_MH_MALA'></span>

<h3>Description</h3>

<p>Proposal beta with a Metropolis Adjusted Langevin (MALA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.beta_MH_MALA(df, beta, bp, cprop_beta, beta_count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".beta_MH_MALA_+3A_df">df</code></td>
<td>
<p>Data frame with indicators</p>
</td></tr>
<tr><td><code id=".beta_MH_MALA_+3A_beta">beta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id=".beta_MH_MALA_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".beta_MH_MALA_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>proposal variance standard deviation</p>
</td></tr>
<tr><td><code id=".beta_MH_MALA_+3A_beta_count">beta_count</code></td>
<td>
<p>count number of accepts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated beta vector
</p>

<hr>
<h2 id='.beta_MH_NR'>Newton Raphson MH move</h2><span id='topic+.beta_MH_NR'></span>

<h3>Description</h3>

<p>Sample beta from RW sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.beta_MH_NR(df, beta, bp, cprop_beta, beta_count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".beta_MH_NR_+3A_df">df</code></td>
<td>
<p>Data frame with indicators</p>
</td></tr>
<tr><td><code id=".beta_MH_NR_+3A_beta">beta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id=".beta_MH_NR_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".beta_MH_NR_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>proposal scalar</p>
</td></tr>
<tr><td><code id=".beta_MH_NR_+3A_beta_count">beta_count</code></td>
<td>
<p>count number of accepts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated beta
</p>

<hr>
<h2 id='.beta_MH_RW'>Beta Metropolis-Hastings Random walk move</h2><span id='topic+.beta_MH_RW'></span>

<h3>Description</h3>

<p>Update beta via a Metropolis-Hastings Random Walk move
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.beta_MH_RW(df, beta, bp, cprop_beta, beta_count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".beta_MH_RW_+3A_df">df</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".beta_MH_RW_+3A_beta">beta</code></td>
<td>
<p>beta values</p>
</td></tr>
<tr><td><code id=".beta_MH_RW_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".beta_MH_RW_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>hyperparameter for beta proposal standard deviation</p>
</td></tr>
<tr><td><code id=".beta_MH_RW_+3A_beta_count">beta_count</code></td>
<td>
<p>number of moves done for beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta, either old or new move
</p>

<hr>
<h2 id='.beta_mom'>Mean for MALA using derivative for beta proposal</h2><span id='topic+.beta_mom'></span>

<h3>Description</h3>

<p>Mean for MALA using derivative for beta proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.beta_mom(df, k, beta, bp, cprop_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".beta_mom_+3A_df">df</code></td>
<td>
<p>Data frame with indicators</p>
</td></tr>
<tr><td><code id=".beta_mom_+3A_k">k</code></td>
<td>
<p>index for beta</p>
</td></tr>
<tr><td><code id=".beta_mom_+3A_beta">beta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id=".beta_mom_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".beta_mom_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>proposal standard dev</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proposal mean
</p>

<hr>
<h2 id='.beta_mom.NR.fun'>First and second derivative of target for mode and variance of proposal</h2><span id='topic+.beta_mom.NR.fun'></span>

<h3>Description</h3>

<p>First and second derivative of target for mode and variance of proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.beta_mom.NR.fun(df, k, beta, bp, cprop_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".beta_mom.NR.fun_+3A_df">df</code></td>
<td>
<p>Data frame with indicators</p>
</td></tr>
<tr><td><code id=".beta_mom.NR.fun_+3A_k">k</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id=".beta_mom.NR.fun_+3A_beta">beta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id=".beta_mom.NR.fun_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".beta_mom.NR.fun_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>proposal variance standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>First and second derivative mode and variance
</p>

<hr>
<h2 id='.beta.MH.RW.glm'>Beta MH RW sampler from freq PEM fit</h2><span id='topic+.beta.MH.RW.glm'></span>

<h3>Description</h3>

<p>Sample beta from RW sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.beta.MH.RW.glm(df, beta, beta_count, cprop_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".beta.MH.RW.glm_+3A_df">df</code></td>
<td>
<p>Data frame with indicators</p>
</td></tr>
<tr><td><code id=".beta.MH.RW.glm_+3A_beta">beta</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id=".beta.MH.RW.glm_+3A_beta_count">beta_count</code></td>
<td>
<p>count number of accepted proposals</p>
</td></tr>
<tr><td><code id=".beta.MH.RW.glm_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>proposal scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta, either old or new move
</p>

<hr>
<h2 id='.birth_move'>Birth move in RJMCMC</h2><span id='topic+.birth_move'></span>

<h3>Description</h3>

<p>Calculates new values of x when proposing another split point, based on a 
weighted mean, as x_new/x &lt;- (1-U)/U
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.birth_move(U, sj, s_star, sjm1, x, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".birth_move_+3A_u">U</code></td>
<td>
<p>uniform random number</p>
</td></tr>
<tr><td><code id=".birth_move_+3A_sj">sj</code></td>
<td>
<p>upcoming split point location, j</p>
</td></tr>
<tr><td><code id=".birth_move_+3A_s_star">s_star</code></td>
<td>
<p>new split point location, *</p>
</td></tr>
<tr><td><code id=".birth_move_+3A_sjm1">sjm1</code></td>
<td>
<p>previous split point location, j-1</p>
</td></tr>
<tr><td><code id=".birth_move_+3A_x">x</code></td>
<td>
<p>vector of parameter values, length J + 1</p>
</td></tr>
<tr><td><code id=".birth_move_+3A_j">j</code></td>
<td>
<p>split point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with adjusted parameter values after additional split point,
length J + 2
</p>

<hr>
<h2 id='.dataframe_fun'>Create data.frame for piecewise exponential models</h2><span id='topic+.dataframe_fun'></span>

<h3>Description</h3>

<p>Construct a split data.frame for updated split points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.dataframe_fun(Y, I, X, s, lambda, bp, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".dataframe_fun_+3A_y">Y</code></td>
<td>
<p>time-to-event</p>
</td></tr>
<tr><td><code id=".dataframe_fun_+3A_i">I</code></td>
<td>
<p>censor indicator</p>
</td></tr>
<tr><td><code id=".dataframe_fun_+3A_x">X</code></td>
<td>
<p>design Matrix</p>
</td></tr>
<tr><td><code id=".dataframe_fun_+3A_s">s</code></td>
<td>
<p>split point locations, including start and end (length J + 2)</p>
</td></tr>
<tr><td><code id=".dataframe_fun_+3A_lambda">lambda</code></td>
<td>
<p>baseline Hazards (length J+1)</p>
</td></tr>
<tr><td><code id=".dataframe_fun_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".dataframe_fun_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns c(tstart, id, X1,..., Xp, Y, I, lambda)
</p>

<hr>
<h2 id='.death_move'>Death move in RJMCMC</h2><span id='topic+.death_move'></span>

<h3>Description</h3>

<p>Calculates new values of x when proposing the death of a split point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.death_move(sjp1, sj, sjm1, x, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".death_move_+3A_sjp1">sjp1</code></td>
<td>
<p>upcoming split point location, J + 1</p>
</td></tr>
<tr><td><code id=".death_move_+3A_sj">sj</code></td>
<td>
<p>split point location to be removed, j</p>
</td></tr>
<tr><td><code id=".death_move_+3A_sjm1">sjm1</code></td>
<td>
<p>previous split point location, j-1</p>
</td></tr>
<tr><td><code id=".death_move_+3A_x">x</code></td>
<td>
<p>vector of parameter values, length J + 1</p>
</td></tr>
<tr><td><code id=".death_move_+3A_j">j</code></td>
<td>
<p>split point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with adjusted parameter values after removal of split point,
length J
</p>

<hr>
<h2 id='.glmFit'>Fit frequentist piecewise exponential model for MLE and information matrix of beta</h2><span id='topic+.glmFit'></span>

<h3>Description</h3>

<p>Compute MLE for PEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.glmFit(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".glmFit_+3A_df">df</code></td>
<td>
<p>Data frame with time-to-event, censoring indicator and covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta MLE and inverse of information matrix
</p>

<hr>
<h2 id='.ICAR_calc'>Calculate covariance matrix in the MVN-ICAR</h2><span id='topic+.ICAR_calc'></span>

<h3>Description</h3>

<p>Calculate covariance matrix in the MVN-ICAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ICAR_calc(s, J, clam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ICAR_calc_+3A_s">s</code></td>
<td>
<p>split points, J + 2</p>
</td></tr>
<tr><td><code id=".ICAR_calc_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".ICAR_calc_+3A_clam">clam</code></td>
<td>
<p>controls neighbor interactions, in range (0, 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sigma_s = (I - W)^(-1) * Q, W, Q
</p>

<hr>
<h2 id='.input_check'>Input checker</h2><span id='topic+.input_check'></span>

<h3>Description</h3>

<p>Checks inputs before Gibbs sampler is run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.input_check(
  Y,
  Y_0,
  X,
  X_0,
  tuning_parameters,
  initial_values = NULL,
  hyperparameters
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".input_check_+3A_y">Y</code></td>
<td>
<p>current time-to-event data</p>
</td></tr>
<tr><td><code id=".input_check_+3A_y_0">Y_0</code></td>
<td>
<p>historical time-to-event data</p>
</td></tr>
<tr><td><code id=".input_check_+3A_x">X</code></td>
<td>
<p>design Matrix</p>
</td></tr>
<tr><td><code id=".input_check_+3A_x_0">X_0</code></td>
<td>
<p>design Matrix for historical data</p>
</td></tr>
<tr><td><code id=".input_check_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of tuning parameters</p>
</td></tr>
<tr><td><code id=".input_check_+3A_initial_values">initial_values</code></td>
<td>
<p>list of initial values (optional)</p>
</td></tr>
<tr><td><code id=".input_check_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list of hyperparameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a print statement
</p>

<hr>
<h2 id='.J_RJMCMC'>RJMCMC (with Bayesian Borrowing)</h2><span id='topic+.J_RJMCMC'></span>

<h3>Description</h3>

<p>Metropolis-Hastings Green Reversible Jump move, with Bayesian 
Borrowing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.J_RJMCMC(
  df_hist,
  df_curr,
  Y,
  Y_0,
  I,
  I_0,
  X,
  X_0,
  lambda,
  lambda_0,
  beta,
  beta_0,
  mu,
  sigma2,
  tau,
  s,
  J,
  Jmax,
  bp,
  bp_0,
  clam_smooth,
  a_tau = NULL,
  b_tau = NULL,
  c_tau = NULL,
  d_tau = NULL,
  type,
  p_0 = NULL,
  phi,
  pi_b,
  maxSj
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".J_RJMCMC_+3A_df_hist">df_hist</code></td>
<td>
<p>data_frame containing historical data.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_df_curr">df_curr</code></td>
<td>
<p>data_frame containing current trial data.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_y">Y</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_y_0">Y_0</code></td>
<td>
<p>historical data.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_i">I</code></td>
<td>
<p>censoring indicator.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_i_0">I_0</code></td>
<td>
<p>historical trial censoring indicator.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_x">X</code></td>
<td>
<p>design matrix.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_x_0">X_0</code></td>
<td>
<p>historical trial design matrix.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_lambda_0">lambda_0</code></td>
<td>
<p>historical trial baseline hazard.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_beta">beta</code></td>
<td>
<p>current trial parameters.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_beta_0">beta_0</code></td>
<td>
<p>historical trial parameters.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_mu">mu</code></td>
<td>
<p>prior mean for baseline hazard.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_sigma2">sigma2</code></td>
<td>
<p>prior variance hyperparameter for baseline hazard.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_tau">tau</code></td>
<td>
<p>borrowing parameter.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_s">s</code></td>
<td>
<p>split point locations, J + 2.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_j">J</code></td>
<td>
<p>number of split points.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_jmax">Jmax</code></td>
<td>
<p>maximum number of split points.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_bp">bp</code></td>
<td>
<p>number of covariates in current trial.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates in historical trial.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_clam_smooth">clam_smooth</code></td>
<td>
<p>neighbor interactions, in range (0, 1), for ICAR update.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_a_tau">a_tau</code></td>
<td>
<p>tau hyperparameter.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_b_tau">b_tau</code></td>
<td>
<p>tau hyperparameter.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_c_tau">c_tau</code></td>
<td>
<p>tau hyperparameter.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_d_tau">d_tau</code></td>
<td>
<p>tau hyperparameter.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_type">type</code></td>
<td>
<p>choice of borrowing, &quot;mix&quot;, &quot;uni&quot;, or any other string for 
borrowing on every baseline hazard without mixture.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_p_0">p_0</code></td>
<td>
<p>mixture ratio.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_phi">phi</code></td>
<td>
<p>J hyperparameter.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_pi_b">pi_b</code></td>
<td>
<p>probability of birth move.</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_+3A_maxsj">maxSj</code></td>
<td>
<p>maximal time point, either current or historic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of proposed J and s, with adjusted values of lambda, lambda_0, 
tau, Sigma_s, and data_frames for historical and current trial data.
</p>

<hr>
<h2 id='.J_RJMCMC_NoBorrow'>RJMCMC (without Bayesian Borrowing)</h2><span id='topic+.J_RJMCMC_NoBorrow'></span>

<h3>Description</h3>

<p>Metropolis-Hastings Green Reversible Jump move, without Bayesian 
Borrowing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.J_RJMCMC_NoBorrow(
  df,
  Y_0,
  I_0,
  X_0,
  lambda_0,
  beta_0,
  mu,
  sigma2,
  s,
  J,
  Jmax,
  bp_0,
  clam_smooth,
  phi,
  pi_b
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_df">df</code></td>
<td>
<p>data_frame</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_y_0">Y_0</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_i_0">I_0</code></td>
<td>
<p>censoring indicator</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_x_0">X_0</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_lambda_0">lambda_0</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_beta_0">beta_0</code></td>
<td>
<p>historical trial parameters</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_mu">mu</code></td>
<td>
<p>prior mean for baseline hazard</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_sigma2">sigma2</code></td>
<td>
<p>prior variance hyperparameter for baseline hazard</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_s">s</code></td>
<td>
<p>split point locations, J + 2</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_jmax">Jmax</code></td>
<td>
<p>maximum number of split points</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates in historical trial</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_clam_smooth">clam_smooth</code></td>
<td>
<p>neighbor interactions, in range (0, 1), for ICAR update</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_phi">phi</code></td>
<td>
<p>J hyperparameter</p>
</td></tr>
<tr><td><code id=".J_RJMCMC_NoBorrow_+3A_pi_b">pi_b</code></td>
<td>
<p>probability of birth move</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of proposed J and s, with adjusted values of lambda, lambda_0, 
tau, Sigma_s, and data_frames for historical and current trial data
</p>

<hr>
<h2 id='.lambda_0_MH_cp'>Lambda_0 MH step, proposal from conditional conjugate posterior</h2><span id='topic+.lambda_0_MH_cp'></span>

<h3>Description</h3>

<p>Lambda_0 MH step, proposal from conditional conjugate posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lambda_0_MH_cp(
  df_hist,
  Y_0,
  I_0,
  X_0 = NULL,
  s,
  beta_0 = NULL,
  mu,
  sigma2,
  lambda,
  lambda_0,
  tau,
  bp_0 = 0,
  J,
  clam,
  a_lam = 0.01,
  b_lam = 0.01,
  lambda_0_count = 0,
  lambda_0_move = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lambda_0_MH_cp_+3A_df_hist">df_hist</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_y_0">Y_0</code></td>
<td>
<p>historical trial data</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_i_0">I_0</code></td>
<td>
<p>historical trial censoring indicator</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_x_0">X_0</code></td>
<td>
<p>historical trial design matrix</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_s">s</code></td>
<td>
<p>split point locations, (J+2)</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_beta_0">beta_0</code></td>
<td>
<p>parameter value for historical covariates</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_mu">mu</code></td>
<td>
<p>prior mean for baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_sigma2">sigma2</code></td>
<td>
<p>prior variance hyperparameter for baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_lambda_0">lambda_0</code></td>
<td>
<p>historical baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_tau">tau</code></td>
<td>
<p>borrowing parameter</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates, length(beta_0)</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_clam">clam</code></td>
<td>
<p>controls neighbor interactions, in range (0, 1)</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_a_lam">a_lam</code></td>
<td>
<p>lambda hyperparameter, default is 0.01</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_b_lam">b_lam</code></td>
<td>
<p>lambda hyperparameter, default is 0.01</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_lambda_0_count">lambda_0_count</code></td>
<td>
<p>number of total moves for lambda_0</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_+3A_lambda_0_move">lambda_0_move</code></td>
<td>
<p>number of accepted moves for lambda_0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of updated (if accepted) lambda_0 and data.frames, as well as the 
number of accepted moves
</p>

<hr>
<h2 id='.lambda_0_MH_cp_NoBorrow'>Lambda_0 MH step, proposal from conditional conjugate posterior</h2><span id='topic+.lambda_0_MH_cp_NoBorrow'></span>

<h3>Description</h3>

<p>Lambda_0 MH step, proposal from conditional conjugate posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lambda_0_MH_cp_NoBorrow(
  df_hist,
  Y_0,
  I_0,
  X_0 = NULL,
  s,
  beta_0 = NULL,
  mu,
  sigma2,
  lambda_0,
  bp_0 = 0,
  J,
  clam,
  a_lam = 0.01,
  b_lam = 0.01,
  lambda_0_count = 0,
  lambda_0_move = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_df_hist">df_hist</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_y_0">Y_0</code></td>
<td>
<p>historical trial data</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_i_0">I_0</code></td>
<td>
<p>historical trial censoring indicator</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_x_0">X_0</code></td>
<td>
<p>historical trial design matrix</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_s">s</code></td>
<td>
<p>split point locations, (J+2)</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_beta_0">beta_0</code></td>
<td>
<p>parameter value for historical covariates</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_mu">mu</code></td>
<td>
<p>prior mean for baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_sigma2">sigma2</code></td>
<td>
<p>prior variance hyperparameter for baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_lambda_0">lambda_0</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates, length(beta_0)</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_clam">clam</code></td>
<td>
<p>controls neighbor interactions, in range (0, 1)</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_a_lam">a_lam</code></td>
<td>
<p>lambda hyperparameter, default is 0.01</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_b_lam">b_lam</code></td>
<td>
<p>lambda hyperparameter, default is 0.01</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_lambda_0_count">lambda_0_count</code></td>
<td>
<p>number of total moves for lambda_0</p>
</td></tr>
<tr><td><code id=".lambda_0_MH_cp_NoBorrow_+3A_lambda_0_move">lambda_0_move</code></td>
<td>
<p>number of accepted moves for lambda_0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of updated (if accepted) lambda_0 and data.frames, as well as the 
number of accepted moves
</p>

<hr>
<h2 id='.lambda_conj_prop'>Propose lambda from a gamma conditional conjugate posterior proposal</h2><span id='topic+.lambda_conj_prop'></span>

<h3>Description</h3>

<p>Propose lambda from a gamma conditional conjugate posterior proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lambda_conj_prop(df, beta, j, bp, alam = 0.01, blam = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lambda_conj_prop_+3A_df">df</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".lambda_conj_prop_+3A_beta">beta</code></td>
<td>
<p>parameter value for beta</p>
</td></tr>
<tr><td><code id=".lambda_conj_prop_+3A_j">j</code></td>
<td>
<p>current split point</p>
</td></tr>
<tr><td><code id=".lambda_conj_prop_+3A_bp">bp</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id=".lambda_conj_prop_+3A_alam">alam</code></td>
<td>
<p>lambda hyperparameter, default set to 0.01</p>
</td></tr>
<tr><td><code id=".lambda_conj_prop_+3A_blam">blam</code></td>
<td>
<p>lambda hyperparameter, default set to 0.01</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing proposed lambda, shape and rate parameters
</p>

<hr>
<h2 id='.lambda_MH_cp'>Lambda MH step, proposal from conditional conjugate posterior</h2><span id='topic+.lambda_MH_cp'></span>

<h3>Description</h3>

<p>Lambda MH step, proposal from conditional conjugate posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lambda_MH_cp(
  df_hist,
  df_curr,
  Y,
  I,
  X,
  s,
  beta,
  beta_0 = NULL,
  mu,
  sigma2,
  lambda,
  lambda_0,
  tau,
  bp,
  bp_0 = 0,
  J,
  a_lam = 0.01,
  b_lam = 0.01,
  lambda_move = 0,
  lambda_count = 0,
  alpha = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lambda_MH_cp_+3A_df_hist">df_hist</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_df_curr">df_curr</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_y">Y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_i">I</code></td>
<td>
<p>censoring indicator</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_s">s</code></td>
<td>
<p>split point locations, J + 2</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_beta">beta</code></td>
<td>
<p>parameter value for covariates</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_beta_0">beta_0</code></td>
<td>
<p>parameter value for historical covariates</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_mu">mu</code></td>
<td>
<p>prior mean for baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_sigma2">sigma2</code></td>
<td>
<p>prior variance hyperparameter for baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_lambda_0">lambda_0</code></td>
<td>
<p>historical baseline hazard</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_tau">tau</code></td>
<td>
<p>borrowing parameter</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_bp">bp</code></td>
<td>
<p>number of covariates, length(beta)</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates, length(beta_0)</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_a_lam">a_lam</code></td>
<td>
<p>lambda hyperparameter</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_b_lam">b_lam</code></td>
<td>
<p>lambda hyperparameter</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_lambda_move">lambda_move</code></td>
<td>
<p>number of accepted lambda moves</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_lambda_count">lambda_count</code></td>
<td>
<p>total number of lambda moves</p>
</td></tr>
<tr><td><code id=".lambda_MH_cp_+3A_alpha">alpha</code></td>
<td>
<p>power parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of updated (if accepted) lambda and data.frames, as well as the 
number of accepted moves
</p>

<hr>
<h2 id='.lgamma_ratio'>Calculate log gamma ratio for two different parameter values</h2><span id='topic+.lgamma_ratio'></span>

<h3>Description</h3>

<p>Calculate log gamma ratio for two different parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lgamma_ratio(x1, x2, shape, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lgamma_ratio_+3A_x1">x1</code></td>
<td>
<p>old parameter value</p>
</td></tr>
<tr><td><code id=".lgamma_ratio_+3A_x2">x2</code></td>
<td>
<p>proposed parameter value</p>
</td></tr>
<tr><td><code id=".lgamma_ratio_+3A_shape">shape</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id=".lgamma_ratio_+3A_rate">rate</code></td>
<td>
<p>rate parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log gamma ratio
</p>

<hr>
<h2 id='.llikelihood_ratio_beta'>Loglikelihood ratio calculation for beta parameters</h2><span id='topic+.llikelihood_ratio_beta'></span>

<h3>Description</h3>

<p>Compute log likelihood for beta update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.llikelihood_ratio_beta(df, beta, beta_new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".llikelihood_ratio_beta_+3A_df">df</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".llikelihood_ratio_beta_+3A_beta">beta</code></td>
<td>
<p>beta values</p>
</td></tr>
<tr><td><code id=".llikelihood_ratio_beta_+3A_beta_new">beta_new</code></td>
<td>
<p>proposed beta values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>likelihood ratio
</p>

<hr>
<h2 id='.llikelihood_ratio_lambda'>Log likelihood for lambda / lambda_0 update</h2><span id='topic+.llikelihood_ratio_lambda'></span>

<h3>Description</h3>

<p>Log likelihood for lambda / lambda_0 update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.llikelihood_ratio_lambda(df, df_prop, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".llikelihood_ratio_lambda_+3A_df">df</code></td>
<td>
<p>data.frame from dataframe_fun()</p>
</td></tr>
<tr><td><code id=".llikelihood_ratio_lambda_+3A_df_prop">df_prop</code></td>
<td>
<p>proposal data.frame</p>
</td></tr>
<tr><td><code id=".llikelihood_ratio_lambda_+3A_beta">beta</code></td>
<td>
<p>parameter value for beta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log likelihood ratio for lambda
</p>

<hr>
<h2 id='.log_likelihood'>Log likelihood function</h2><span id='topic+.log_likelihood'></span>

<h3>Description</h3>

<p>Log likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.log_likelihood(df, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".log_likelihood_+3A_df">df</code></td>
<td>
<p>data.frame containing data, time split points, and lambda</p>
</td></tr>
<tr><td><code id=".log_likelihood_+3A_beta">beta</code></td>
<td>
<p>coefficients for covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log likelihood given lambdas and betas
</p>

<hr>
<h2 id='.logsumexp'>Computes the logarithmic sum of an exponential</h2><span id='topic+.logsumexp'></span>

<h3>Description</h3>

<p>Computes the logarithmic sum of an exponential
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.logsumexp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".logsumexp_+3A_x">x</code></td>
<td>
<p>set of log probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the logarithmic sum of an exponential
</p>

<hr>
<h2 id='.lprop_density_beta'>Log density of proposal for MALA</h2><span id='topic+.lprop_density_beta'></span>

<h3>Description</h3>

<p>Log density of proposal for MALA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lprop_density_beta(beta_prop, mu, cprop_beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lprop_density_beta_+3A_beta_prop">beta_prop</code></td>
<td>
<p>proposal beta</p>
</td></tr>
<tr><td><code id=".lprop_density_beta_+3A_mu">mu</code></td>
<td>
<p>mean of proposal distribution</p>
</td></tr>
<tr><td><code id=".lprop_density_beta_+3A_cprop_beta">cprop_beta</code></td>
<td>
<p>proposal standard dev</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log density
</p>

<hr>
<h2 id='.lprop.dens.beta.NR'>log Gaussian proposal density for Newton Raphson proposal</h2><span id='topic+.lprop.dens.beta.NR'></span>

<h3>Description</h3>

<p>log Gaussian proposal density for Newton Raphson proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lprop.dens.beta.NR(beta.prop, mu_old, var_old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lprop.dens.beta.NR_+3A_beta.prop">beta.prop</code></td>
<td>
<p>beta proposal</p>
</td></tr>
<tr><td><code id=".lprop.dens.beta.NR_+3A_mu_old">mu_old</code></td>
<td>
<p>density mean</p>
</td></tr>
<tr><td><code id=".lprop.dens.beta.NR_+3A_var_old">var_old</code></td>
<td>
<p>density variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log Gaussian density
</p>

<hr>
<h2 id='.ltau_dprior'>Calculate log density tau prior</h2><span id='topic+.ltau_dprior'></span>

<h3>Description</h3>

<p>Calculate log density tau prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ltau_dprior(tau, a_tau, b_tau, c_tau = NULL, d_tau = NULL, p_0 = NULL, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ltau_dprior_+3A_tau">tau</code></td>
<td>
<p>current value(s) of tau</p>
</td></tr>
<tr><td><code id=".ltau_dprior_+3A_a_tau">a_tau</code></td>
<td>
<p>tau hyperparameter</p>
</td></tr>
<tr><td><code id=".ltau_dprior_+3A_b_tau">b_tau</code></td>
<td>
<p>tau hyperparameter</p>
</td></tr>
<tr><td><code id=".ltau_dprior_+3A_c_tau">c_tau</code></td>
<td>
<p>tau hyperparameter</p>
</td></tr>
<tr><td><code id=".ltau_dprior_+3A_d_tau">d_tau</code></td>
<td>
<p>tau hyperparameter</p>
</td></tr>
<tr><td><code id=".ltau_dprior_+3A_p_0">p_0</code></td>
<td>
<p>mixture ratio</p>
</td></tr>
<tr><td><code id=".ltau_dprior_+3A_type">type</code></td>
<td>
<p>choice of borrowing, &quot;mix&quot;, &quot;uni&quot;, or any other string for 
borrowing on every baseline hazard without mixture</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log density of tau
</p>

<hr>
<h2 id='.mu_update'>Calculate mu posterior update</h2><span id='topic+.mu_update'></span>

<h3>Description</h3>

<p>Calculate mu posterior update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.mu_update(Sigma_s, lambda_0, sigma2, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".mu_update_+3A_sigma_s">Sigma_s</code></td>
<td>
<p>VCV matrix (j + 1) x (j + 1).</p>
</td></tr>
<tr><td><code id=".mu_update_+3A_lambda_0">lambda_0</code></td>
<td>
<p>Baseline hazard.</p>
</td></tr>
<tr><td><code id=".mu_update_+3A_sigma2">sigma2</code></td>
<td>
<p>Scale variance.</p>
</td></tr>
<tr><td><code id=".mu_update_+3A_j">J</code></td>
<td>
<p>Number of split point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu update from Normal.
</p>

<hr>
<h2 id='.normalize_prob'>Normalize a set of probability to one, using the the log-sum-exp trick</h2><span id='topic+.normalize_prob'></span>

<h3>Description</h3>

<p>Normalize a set of probability to one, using the the log-sum-exp trick
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.normalize_prob(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".normalize_prob_+3A_x">x</code></td>
<td>
<p>set of log probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized set of log probabilities
</p>

<hr>
<h2 id='.nu_sigma_update'>Calculates nu and sigma2 for the Gaussian Markov random field prior, 
for a given split point j</h2><span id='topic+.nu_sigma_update'></span>

<h3>Description</h3>

<p>Calculates nu and sigma2 for the Gaussian Markov random field prior, 
for a given split point j
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.nu_sigma_update(j, lambda_0, mu, sigma2, W, Q, J)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".nu_sigma_update_+3A_j">j</code></td>
<td>
<p>current split point</p>
</td></tr>
<tr><td><code id=".nu_sigma_update_+3A_lambda_0">lambda_0</code></td>
<td>
<p>historical baseline hazard</p>
</td></tr>
<tr><td><code id=".nu_sigma_update_+3A_mu">mu</code></td>
<td>
<p>prior mean for baseline hazard</p>
</td></tr>
<tr><td><code id=".nu_sigma_update_+3A_sigma2">sigma2</code></td>
<td>
<p>prior variance hyperparameter for baseline hazard</p>
</td></tr>
<tr><td><code id=".nu_sigma_update_+3A_w">W</code></td>
<td>
<p>influence from right and left neighbors</p>
</td></tr>
<tr><td><code id=".nu_sigma_update_+3A_q">Q</code></td>
<td>
<p>individual effect of neighborhood</p>
</td></tr>
<tr><td><code id=".nu_sigma_update_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nu and sigma2
</p>

<hr>
<h2 id='.shuffle_split_point_location'>Metropolis Hastings step: shuffle the split point locations (with 
Bayesian borrowing)</h2><span id='topic+.shuffle_split_point_location'></span>

<h3>Description</h3>

<p>Metropolis Hastings step: shuffle the split point locations (with 
Bayesian borrowing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.shuffle_split_point_location(
  df_hist,
  df_curr,
  Y_0,
  I_0,
  X_0,
  lambda_0,
  beta_0,
  Y,
  I,
  X,
  lambda,
  beta,
  s,
  J,
  bp_0,
  bp,
  clam_smooth,
  maxSj
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".shuffle_split_point_location_+3A_df_hist">df_hist</code></td>
<td>
<p>dataframe containing historical trial data and parmaeters</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_df_curr">df_curr</code></td>
<td>
<p>data.frame containing current trial data and parameters</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_y_0">Y_0</code></td>
<td>
<p>historical trial data</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_i_0">I_0</code></td>
<td>
<p>historical trial censoring indicator</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_x_0">X_0</code></td>
<td>
<p>historical trial design matrix</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_lambda_0">lambda_0</code></td>
<td>
<p>historical baseline hazard</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_beta_0">beta_0</code></td>
<td>
<p>historical parameter vector</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_y">Y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_i">I</code></td>
<td>
<p>censoring indicator</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_beta">beta</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_s">s</code></td>
<td>
<p>split point locations, J + 2</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates in historical trial</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_bp">bp</code></td>
<td>
<p>number of covariates in current trial</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_clam_smooth">clam_smooth</code></td>
<td>
<p>neighbor interactions, in range (0, 1), for ICAR update</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_+3A_maxsj">maxSj</code></td>
<td>
<p>the smallest of the maximal time points, min(max(Y), max(Y_0))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing new split points, updated Sigma_s and data.frames
for historic and current trial data
</p>

<hr>
<h2 id='.shuffle_split_point_location_NoBorrow'>Metropolis Hastings step: shuffle the split point locations (without 
Bayesian borrowing)</h2><span id='topic+.shuffle_split_point_location_NoBorrow'></span>

<h3>Description</h3>

<p>Metropolis Hastings step: shuffle the split point locations (without 
Bayesian borrowing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.shuffle_split_point_location_NoBorrow(
  df,
  Y_0,
  I_0,
  X_0,
  lambda_0,
  beta_0,
  s,
  J,
  bp_0,
  clam_smooth
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_df">df</code></td>
<td>
<p>dataframe containing trial data and parameters</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_y_0">Y_0</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_i_0">I_0</code></td>
<td>
<p>censoring indicator</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_x_0">X_0</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_lambda_0">lambda_0</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_beta_0">beta_0</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_s">s</code></td>
<td>
<p>split point locations, J + 2</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_bp_0">bp_0</code></td>
<td>
<p>number of covariates in historical trial</p>
</td></tr>
<tr><td><code id=".shuffle_split_point_location_NoBorrow_+3A_clam_smooth">clam_smooth</code></td>
<td>
<p>neighbor interactions, in range (0, 1), for ICAR update</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing new split points, updated Sigma_s and data.frames
for historic and current trial data
</p>

<hr>
<h2 id='.sigma2_update'>Calculate sigma2 posterior update</h2><span id='topic+.sigma2_update'></span>

<h3>Description</h3>

<p>Calculate sigma2 posterior update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sigma2_update(mu, lambda_0, Sigma_s, J, a_sigma, b_sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sigma2_update_+3A_mu">mu</code></td>
<td>
<p>mean.</p>
</td></tr>
<tr><td><code id=".sigma2_update_+3A_lambda_0">lambda_0</code></td>
<td>
<p>Baseline hazard.</p>
</td></tr>
<tr><td><code id=".sigma2_update_+3A_sigma_s">Sigma_s</code></td>
<td>
<p>VCV matrix (j + 1) x (j + 1).</p>
</td></tr>
<tr><td><code id=".sigma2_update_+3A_j">J</code></td>
<td>
<p>Number of split point.</p>
</td></tr>
<tr><td><code id=".sigma2_update_+3A_a_sigma">a_sigma</code></td>
<td>
<p>Hyperparameter a.</p>
</td></tr>
<tr><td><code id=".sigma2_update_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Hyperparameter b.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sigma2 draw from IG
</p>

<hr>
<h2 id='.tau_update'>Sample tau from posterior distribution</h2><span id='topic+.tau_update'></span>

<h3>Description</h3>

<p>Sample tau from posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.tau_update(
  lambda_0,
  lambda,
  J,
  s,
  a_tau,
  b_tau,
  c_tau = NULL,
  d_tau = NULL,
  p_0 = NULL,
  type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".tau_update_+3A_lambda_0">lambda_0</code></td>
<td>
<p>historical baseline hazard</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_lambda">lambda</code></td>
<td>
<p>baseline hazard</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_j">J</code></td>
<td>
<p>number of split points</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_s">s</code></td>
<td>
<p>split point locations, J + 2</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_a_tau">a_tau</code></td>
<td>
<p>Inverse Gamma hyperparameter</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_b_tau">b_tau</code></td>
<td>
<p>Inverse Gamma hyperparameter</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_c_tau">c_tau</code></td>
<td>
<p>Inverse Gamma hyperparameter</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_d_tau">d_tau</code></td>
<td>
<p>Inverse Gamma hyperparameter</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_p_0">p_0</code></td>
<td>
<p>mixture ratio</p>
</td></tr>
<tr><td><code id=".tau_update_+3A_type">type</code></td>
<td>
<p>choice of borrowing, &quot;mix&quot;, &quot;uni&quot;, or any other string for 
borrowing on every baseline hazard without mixture</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing tau and new mixture ratio
</p>

<hr>
<h2 id='BayesFBHborrow'>BayesFBHborrow: Run MCMC for a piecewise exponential model</h2><span id='topic+BayesFBHborrow'></span>

<h3>Description</h3>

<p>Main function of the BayesFBHborrow package. This generic function 
calls the correct MCMC sampler for time-to-event Bayesian borrowing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesFBHborrow(
  data,
  data_hist = NULL,
  tuning_parameters,
  initial_values,
  hyperparameters,
  lambda_hyperparameters,
  iter,
  warmup_iter,
  refresh,
  verbose,
  max_grid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesFBHborrow_+3A_data">data</code></td>
<td>
<p>data.frame containing atleast three vectors of &quot;tte&quot; (time-to-event)
and &quot;event&quot; (censoring), and covariates &quot;X_i&quot; (where i should be a number/
indicator of the covariate)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_data_hist">data_hist</code></td>
<td>
<p>data.frame containing atleast three vectors of &quot;tte&quot; 
(time-to-event) and &quot;event&quot; (censoring), with the option of adding covariates
named &quot;X_0_i&quot; (where i should be a number/
indicator of the covariate), for historical
data</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of &quot;cprop_beta&quot;, &quot;cprop_beta_0&quot;, &quot;alpha&quot;, &quot;Jmax&quot;,
and &quot;pi_b&quot;</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_initial_values">initial_values</code></td>
<td>
<p>list containing the initial values of c(&quot;J&quot;, &quot;s_r&quot;,
&quot;mu&quot;, &quot;sigma2&quot;, &quot;tau&quot;, &quot;lambda_0&quot;, &quot;lambda&quot;, &quot;beta_0&quot;, &quot;beta&quot;) (optional)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list containing the hyperparameters c(&quot;a_tau&quot;, &quot;b_tau&quot;,
&quot;c_tau&quot;, &quot;d_tau&quot;,&quot;type&quot;, &quot;p_0&quot;, &quot;a_sigma&quot;, &quot;b_sigma&quot;, &quot;Jmax&quot;, &quot;clam_smooth&quot;,
&quot;cprop_beta&quot;, &quot;phi&quot;, &quot;pi_b&quot;). Default is list(&quot;a_tau&quot; = 1,&quot;b_tau&quot; = 1,&quot;c_tau&quot; = 1,
&quot;d_tau&quot; = 0.001, &quot;type&quot; = &quot;mix&quot;, &quot;p_0&quot; = 0.5, &quot;a_sigma&quot; = 2, &quot;b_sigma&quot; = 2,
&quot;Jmax&quot; = 20, &quot;clam_smooth&quot; = 0.8, &quot;cprop_beta&quot; = 0.3, &quot;phi&quot; = 3, &quot;pi_b&quot; = 0.5)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_lambda_hyperparameters">lambda_hyperparameters</code></td>
<td>
<p>contains two (three) hyperparameters (a, b (,alpha))
used for the update of lambda and lambda_0. alpha is the power parameter when 
sampling for lambda (effects how much is borrowed)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC sampler</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_warmup_iter">warmup_iter</code></td>
<td>
<p>number of warmup iterations (burn-in) for MCMC sampler.</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_refresh">refresh</code></td>
<td>
<p>number of iterations between printed screen updates</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_verbose">verbose</code></td>
<td>
<p>TRUE (default), choice of output, if TRUE will output 
intermittent results into console</p>
</td></tr>
<tr><td><code id="BayesFBHborrow_+3A_max_grid">max_grid</code></td>
<td>
<p>grids size for the smoothed baseline hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of samples for both fixed (can be found in $out_fixed) and 
multidimensional parameters (lambda, lambda_0, s, tau)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Load the example data and write your initial values and hyper parameters
data(piecewise_exp_cc, package = "BayesFBHborrow")
data(piecewise_exp_hist, package = "BayesFBHborrow")

# Set your hyperparameters and tuning parameters
hyper &lt;-  list("a_tau" = 1, 
               "b_tau" = 0.001,
               "c_tau" = 1,
               "d_tau" = 1, 
               "type" = "all",
               "p_0" = 0.5, 
               "a_sigma" = 2,
               "b_sigma" = 2,
               "clam_smooth" = 0.5,
               "phi" = 3)

tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5,
                          "alpha" = 0.4)
                          
# Set initial values to default
out &lt;- BayesFBHborrow(piecewise_exp_cc, piecewise_exp_hist, tuning_parameters,
                      initial_values = NULL, hyper, iter = 5, warmup_iter = 1)

# Create a summary of the output
# summary(out, estimator = "out_fixed")

# Plot some of the estimates
# Do beta (trace), s (hist) and lambda (matrix)
trace &lt;- plot(out, 1:5, estimator = "beta_1", type = "trace")
hist &lt;- plot(out, estimator = "J", type = "hist")
smoothed_baseline_hazard &lt;- plot(out, 1:2000, estimator = "out_slam", 
                                 type = "matrix")
</code></pre>

<hr>
<h2 id='BayesFBHborrow.NoBorrow'>Run the MCMC sampler without Bayesian Borrowing</h2><span id='topic+BayesFBHborrow.NoBorrow'></span>

<h3>Description</h3>

<p>Main function of the BayesFBHborrow package. This generic function 
calls the correct MCMC sampler for time-to-event without Bayesian borrowing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoBorrow'
BayesFBHborrow(
  data,
  data_hist = NULL,
  tuning_parameters,
  initial_values = NULL,
  hyperparameters = list(a_sigma = 1, b_sigma = 1, phi = 3, clam_smooth = 0.8),
  lambda_hyperparameters = list(a_lambda = 0.01, b_lambda = 0.01),
  iter = 150,
  warmup_iter = 10,
  refresh = 0,
  verbose = FALSE,
  max_grid = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_data">data</code></td>
<td>
<p>data.frame containing atleast three vectors of &quot;tte&quot; (time-to-event)
and &quot;event&quot; (event indicator), and covariates &quot;X_i&quot; (where i should be a number/
indicator of the covariate)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_data_hist">data_hist</code></td>
<td>
<p>NULL (not used)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of &quot;cprop_beta&quot;, &quot;Jmax&quot;, and &quot;pi_b&quot;</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_initial_values">initial_values</code></td>
<td>
<p>list containing the initial values of c(&quot;J&quot;, &quot;s_r&quot;,
&quot;mu&quot;, &quot;sigma2&quot;, &quot;lambda&quot;, beta&quot;) (optional)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list containing the hyperparameters c(&quot;a_sigma&quot;,
&quot;b_sigma&quot;, &quot;Jmax&quot;, &quot;clam_smooth&quot;, &quot;cprop_beta&quot;, &quot;phi&quot;). Default is 
list(&quot;a_sigma&quot; = 2, &quot;b_sigma&quot; = 2, &quot;Jmax&quot; = 20, &quot;clam_smooth&quot; = 0.8, 
&quot;cprop_beta&quot; = 0.3, &quot;phi&quot; = 3)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_lambda_hyperparameters">lambda_hyperparameters</code></td>
<td>
<p>contains two hyperparameters (&quot;a&quot; and &quot;b&quot;) used for
the update of lambda, default is c(0.01, 0.01)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC sampler. Default is 2000</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_warmup_iter">warmup_iter</code></td>
<td>
<p>number of warmup iterations (burn-in) for MCMC sampler. 
Default is 2000</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_refresh">refresh</code></td>
<td>
<p>number of iterations between printed console updates. Default
is 0</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_verbose">verbose</code></td>
<td>
<p>TRUE (default), choice of output, if TRUE will output 
intermittent results into console</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.NoBorrow_+3A_max_grid">max_grid</code></td>
<td>
<p>grid size for the smoothed baseline hazard. Default is 2000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of samples for both fixed (can be found in $out_fixed) and 
multidimensional parameters (lambda, s, tau)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Load the example data and write your initial values and hyper parameters
data(piecewise_exp_cc, package = "BayesFBHborrow")

# Set your hyperparameters and tuning parameters
hyper &lt;-  list("a_sigma" = 2,
               "b_sigma" = 2,
               "clam_smooth" = 0.5,
               "phi" = 3)

tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# Set initial values to default
out &lt;- BayesFBHborrow(piecewise_exp_cc, NULL, tuning_parameters,
                      initial_values = NULL, hyper, iter = 5, warmup_iter = 1)
</code></pre>

<hr>
<h2 id='BayesFBHborrow.WBorrow'>Run the MCMC sampler with Bayesian Borrowing</h2><span id='topic+BayesFBHborrow.WBorrow'></span>

<h3>Description</h3>

<p>Main function of the BayesFBHborrow package. This generic function 
calls the correct MCMC sampler for time-to-event Bayesian borrowing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WBorrow'
BayesFBHborrow(
  data,
  data_hist,
  tuning_parameters,
  initial_values = NULL,
  hyperparameters = list(a_tau = 1, b_tau = 0.001, c_tau = 1, d_tau = 1, type = "mix",
    p_0 = 0.8, a_sigma = 1, b_sigma = 1, phi = 3, clam_smooth = 0.8),
  lambda_hyperparameters = list(a_lambda = 0.01, b_lambda = 0.01),
  iter = 150,
  warmup_iter = 10,
  refresh = 0,
  verbose = FALSE,
  max_grid = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_data">data</code></td>
<td>
<p>data.frame containing atleast three vectors called &quot;tte&quot; 
(time-to-event), &quot;event&quot; (censoring), and covariates &quot;X_i&quot; (where i should be a number/
indicator of the covariate)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_data_hist">data_hist</code></td>
<td>
<p>data.frame containing atleast two vectors called &quot;tte&quot; 
(time-to-event) and &quot;event&quot; (censoring), with the option of adding covariates
named &quot;X_0_i&quot; (where i should be a number/
indicator of the covariate), for historical data</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of &quot;cprop_beta&quot;, &quot;cprop_beta_0&quot;, &quot;alpha&quot;, &quot;Jmax&quot;,
and &quot;pi_b&quot;</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_initial_values">initial_values</code></td>
<td>
<p>list containing the initial values of c(&quot;J&quot;, &quot;s_r&quot;,
&quot;mu&quot;, &quot;sigma2&quot;, &quot;tau&quot;, &quot;lambda_0&quot;, &quot;lambda&quot;, &quot;beta_0&quot;, &quot;beta&quot;) (optional)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list containing the hyperparameters c(&quot;a_tau&quot;, &quot;b_tau&quot;,
&quot;c_tau&quot;, &quot;d_tau&quot;,&quot;type&quot;, &quot;p_0&quot;, &quot;a_sigma&quot;, &quot;b_sigma&quot;, &quot;Jmax&quot;, &quot;clam_smooth&quot;,
&quot;cprop_beta&quot;, &quot;phi&quot;, &quot;pi_b&quot;). Default is list(&quot;a_tau&quot; = 1,&quot;b_tau&quot; = 1,&quot;c_tau&quot; = 1,
&quot;d_tau&quot; = 0.001, &quot;type&quot; = &quot;mix&quot;, &quot;p_0&quot; = 0.5, &quot;a_sigma&quot; = 2, &quot;b_sigma&quot; = 2,
&quot;Jmax&quot; = 20, &quot;clam_smooth&quot; = 0.8, &quot;cprop_beta&quot; = 0.3, &quot;phi&quot; = 3, &quot;pi_b&quot; = 0.5)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_lambda_hyperparameters">lambda_hyperparameters</code></td>
<td>
<p>contains two hyperparameters (a_lambda and b_lambda)
used for the update of lambda and lambda_0. Default is c(0.01, 0.01)</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC sampler. Default is 2000</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_warmup_iter">warmup_iter</code></td>
<td>
<p>number of warmup iterations (burn-in) for MCMC sampler. 
Default is 2000</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_refresh">refresh</code></td>
<td>
<p>number of iterations between printed console updates. Default
is 0</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_verbose">verbose</code></td>
<td>
<p>TRUE (default), choice of output, if TRUE will output 
intermittent results into console</p>
</td></tr>
<tr><td><code id="BayesFBHborrow.WBorrow_+3A_max_grid">max_grid</code></td>
<td>
<p>grid size for the smoothed baseline hazard. Default is 2000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of samples for both fixed (can be found in $out_fixed) and 
multidimensional parameters (lambda, lambda_0, s, tau)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Load the example data and write your initial values and hyper parameters
data(piecewise_exp_cc, package = "BayesFBHborrow")
data(piecewise_exp_hist, package = "BayesFBHborrow")

# Set your hyperparameters and tuning parameters
hyper &lt;-  list("a_tau" = 1, 
               "b_tau" = 0.001,
               "c_tau" = 1,
               "d_tau" = 1, 
               "type" = "all",
               "p_0" = 0.5, 
               "a_sigma" = 2,
               "b_sigma" = 2,
               "clam_smooth" = 0.5,
               "phi" = 3)

tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5,
                          "alpha" = 0.4)
                          
# Set initial values to default
out &lt;- BayesFBHborrow(piecewise_exp_cc, piecewise_exp_hist, tuning_parameters,
                      initial_values = NULL, hyper, iter = 5, warmup_iter = 1)

# Create a summary of the output
# summary(out, estimator = "out_fixed")

# Plot some of the estimates
# Do beta (trace), s (hist) and lambda (matrix)
trace &lt;- plot(out, 1:5, estimator = "beta_1", type = "trace")
hist &lt;- plot(out, estimator = "J", type = "hist")
smoothed_baseline_hazard &lt;- plot(out, 1:2000, estimator = "out_slam", 
                                 type = "matrix")
</code></pre>

<hr>
<h2 id='coef.BayesFBHborrow'>Extract mean posterior values</h2><span id='topic+coef.BayesFBHborrow'></span>

<h3>Description</h3>

<p>S3 method for class &quot;BayesFBHborrow&quot;, returns the mean posterior values
for the fixed parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesFBHborrow'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.BayesFBHborrow_+3A_object">object</code></td>
<td>
<p>MCMC sample object from BayesFBHborrow()</p>
</td></tr>
<tr><td><code id="coef.BayesFBHborrow_+3A_...">...</code></td>
<td>
<p>other arguments, see coef.default()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean values of given samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc, package = "BayesFBHborrow")

# Set your tuning parameters
tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# run the MCMC sampler
out &lt;- BayesFBHborrow(weibull_cc, NULL, tuning_parameters, 
                      initial_values = NULL,
                      iter = 10, warmup_iter = 1)

# Plot the posterior mean values of the fixed parameters
coef(out)
</code></pre>

<hr>
<h2 id='GibbsMH'>S3 generic, calls the correct GibbsMH sampler</h2><span id='topic+GibbsMH'></span>

<h3>Description</h3>

<p>An MCMC sampler for Bayesian borrowing with time-to-event data. 
We obtain a flexible baseline hazard function by making the split points 
random within a piecewise exponential model and using a Gaussian Markov 
random field prior to smooth the baseline hazards. Only calls the sampler and
does not run any input checks. Best practice is to call BayesFBHborrow(), if the 
user is not familiar with the model at hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GibbsMH(
  Y,
  I,
  X,
  Y_0 = NULL,
  I_0 = NULL,
  X_0 = NULL,
  tuning_parameters,
  initial_values,
  hyperparameters,
  lambda_hyperparameters,
  iter,
  warmup_iter,
  refresh,
  max_grid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GibbsMH_+3A_y">Y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_i">I</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_y_0">Y_0</code></td>
<td>
<p>historical data, default is NULL</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_i_0">I_0</code></td>
<td>
<p>historical event indicator, default is NULL</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_x_0">X_0</code></td>
<td>
<p>historical design matrix, default is NULL</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of &quot;cprop_beta&quot;, &quot;cprop_beta_0&quot;, &quot;alpha&quot;, &quot;Jmax&quot;,
and &quot;pi_b&quot;</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_initial_values">initial_values</code></td>
<td>
<p>list containing the initial values of c(&quot;J&quot;, &quot;s_r&quot;,
&quot;mu&quot;, &quot;sigma2&quot;, &quot;tau&quot;, &quot;lambda_0&quot;, &quot;lambda&quot;, &quot;beta_0&quot;, &quot;beta&quot;) (optional)</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list containing the hyperparameters c(&quot;a_tau&quot;, &quot;b_tau&quot;,
&quot;c_tau&quot;, &quot;d_tau&quot;,&quot;type&quot;, &quot;p_0&quot;, &quot;a_sigma&quot;, &quot;b_sigma&quot;, &quot;Jmax&quot;, &quot;clam_smooth&quot;,
&quot;cprop_beta&quot;, &quot;phi&quot;, &quot;pi_b&quot;). Default is list(&quot;a_tau&quot; = 1,&quot;b_tau&quot; = 1,&quot;c_tau&quot; = 1,
&quot;d_tau&quot; = 0.001, &quot;type&quot; = &quot;mix&quot;, &quot;p_0&quot; = 0.5, &quot;a_sigma&quot; = 2, &quot;b_sigma&quot; = 2,
&quot;Jmax&quot; = 20, &quot;clam_smooth&quot; = 0.8, &quot;cprop_beta&quot; = 0.3, &quot;phi&quot; = 3, &quot;pi_b&quot; = 0.5)</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_lambda_hyperparameters">lambda_hyperparameters</code></td>
<td>
<p>contains two hyperparameters (a_lambda and b_lambda) used 
for the update of lambda and lambda_0</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC sampler, excluding warmup, 
default is 2000</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_warmup_iter">warmup_iter</code></td>
<td>
<p>number of warmup iterations (burn-in) for MCMC sampler, 
default is 2000</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_refresh">refresh</code></td>
<td>
<p>number of iterations between printed screen updates, 
default is 500</p>
</td></tr>
<tr><td><code id="GibbsMH_+3A_max_grid">max_grid</code></td>
<td>
<p>grid size for the smoothed baseline hazard, default is 2000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on if the user wishes to borrow; returns a list with values
after each iteration for parameters: out_fixed (J, mu, sigma2, beta), lambda,
lambda_0, tau, s, as well as tuning values of the total number of accepts:
lambda_move, lambda_0_move and beta_move. Also included is the out_slam which
contains the shrunk estimate of the baseline hazard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Load example data and set your initial values and hyper parameters
data(weibull_cc, package = "BayesFBHborrow")
data(weibull_hist, package = "BayesFBHborrow")

# The datasets consists of 3 (2) columns named "tte", "event" and "X" 
# (only for concurrent). To explicitly run the sampler, extract the samples as
# following
Y &lt;- weibull_cc$tte
I &lt;- weibull_cc$event
X &lt;- matrix(weibull_cc$X_trt)

Y_0 &lt;- weibull_hist$tte
I_0 &lt;- weibull_hist$event
X_0 &lt;- NULL

# Specify hyperparameters and tuning parameters
hyper &lt;-  list("a_tau" = 1, 
               "b_tau" = 0.001,
               "c_tau" = 1,
               "d_tau" = 1, 
               "type" = "all",
               "p_0" = 0.5, 
               "a_sigma" = 2,
               "b_sigma" = 2,
               "clam_smooth" = 0.5,
               "phi" = 3)

tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5,
                          "alpha" = 0.4)
                          
# Set initial values to 'NULL' for default settings
output &lt;- GibbsMH(Y, I, X, Y_0, I_0, X_0,
                  tuning_parameters, initial_values = NULL, hyper, 
                  iter = 5, warmup_iter = 1)
                  
</code></pre>

<hr>
<h2 id='GibbsMH.NoBorrow'>GibbsMH sampler, without Bayesian Borrowing</h2><span id='topic+GibbsMH.NoBorrow'></span>

<h3>Description</h3>

<p>An MCMC sampler for time-to-event data, without Bayesian Borrowing.
We obtain a flexible baseline hazard function by making the split points 
random within a piecewise exponential model and using a Gaussian Markov 
random field prior to smooth the baseline hazards. Only calls the sampler and
does not run any input checks. Best practice is to call BayesFBHborrow(), if the 
user is not familiar with the model at hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NoBorrow'
GibbsMH(
  Y,
  I,
  X = NULL,
  Y_0 = NULL,
  I_0 = NULL,
  X_0 = NULL,
  tuning_parameters,
  initial_values = NULL,
  hyperparameters = list(a_sigma = 1, b_sigma = 1, phi = 3, clam_smooth = 0.8),
  lambda_hyperparameters = list(a_lambda = 0.01, b_lambda = 0.01),
  iter = 1500L,
  warmup_iter = 10L,
  refresh = 0,
  max_grid = 2000L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GibbsMH.NoBorrow_+3A_y">Y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_i">I</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_y_0">Y_0</code></td>
<td>
<p>historical data, default is NULL</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_i_0">I_0</code></td>
<td>
<p>historical event indicator, default is NULL</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_x_0">X_0</code></td>
<td>
<p>historical design matrix, default is NULL</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of &quot;cprop_beta&quot;, &quot;Jmax&quot;,
and &quot;pi_b&quot;</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_initial_values">initial_values</code></td>
<td>
<p>list containing the initial values of c(&quot;J&quot;, &quot;s_r&quot;,
&quot;mu&quot;, &quot;sigma2&quot;, &quot;lambda&quot;, beta&quot;) (optional)</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list containing the hyperparameters c(&quot;a_sigma&quot;,
&quot;b_sigma&quot;, &quot;Jmax&quot;, &quot;clam_smooth&quot;, &quot;cprop_beta&quot;, &quot;phi&quot;). Default is 
list(&quot;a_sigma&quot; = 2, &quot;b_sigma&quot; = 2, &quot;Jmax&quot; = 20, &quot;clam_smooth&quot; = 0.8, 
&quot;cprop_beta&quot; = 0.3, &quot;phi&quot; = 3)</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_lambda_hyperparameters">lambda_hyperparameters</code></td>
<td>
<p>contains two hyperparameters (&quot;a&quot; and &quot;b&quot;) used for
the update of lambda, default is c(0.01, 0.01)</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC sampler, excluding warmup, 
default is 2000</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_warmup_iter">warmup_iter</code></td>
<td>
<p>number of warmup iterations (burn-in) for MCMC sampler, 
default is 2000</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_refresh">refresh</code></td>
<td>
<p>number of iterations between printed screen updates, 
default is 500</p>
</td></tr>
<tr><td><code id="GibbsMH.NoBorrow_+3A_max_grid">max_grid</code></td>
<td>
<p>grid size for the smoothed baseline hazard, default is 2000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with values after each iteration for parameters: out_fixed (J, 
mu, sigma2, beta), lambda, s, as well as tuning values of the total number 
of accepts: lambda_move and beta_move. Also included is the out_slam which 
contains the shrunk estimate of the baseline hazard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Load example data and set your initial values and hyper parameters
data(weibull_cc, package = "BayesFBHborrow")
data(weibull_hist, package = "BayesFBHborrow")

# The datasets consists of 3 (2) columns named "tte", "event" and "X".
# To explicitly run the sampler, extract the samples as following
Y &lt;- weibull_cc$tte
I &lt;- weibull_cc$event
X &lt;- matrix(weibull_cc$X_trt)

# Specify hyperparameters and tuning parameters
hyper &lt;-  list("a_sigma" = 2,
               "b_sigma" = 2,
               "clam_smooth" = 0.5,
               "phi" = 3)

tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# Set initial values to 'NULL' for default settings
output &lt;- GibbsMH(Y, I, X, NULL, NULL, NULL,
                  tuning_parameters, initial_values = NULL, hyper, 
                  iter = 5, warmup_iter = 1)
</code></pre>

<hr>
<h2 id='GibbsMH.WBorrow'>GibbsMH sampler, with Bayesian Borrowing</h2><span id='topic+GibbsMH.WBorrow'></span>

<h3>Description</h3>

<p>An MCMC sampler for Bayesian borrowing with time-to-event data. 
We obtain a flexible baseline hazard function by making the split points 
random within a piecewise exponential model and using a Gaussian Markov 
random field prior to smooth the baseline hazards. Only calls the sampler and
does not run any input checks. Best practice is to call BayesFBHborrow(), if the 
user is not familiar with the model at hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WBorrow'
GibbsMH(
  Y,
  I,
  X,
  Y_0,
  I_0,
  X_0,
  tuning_parameters,
  initial_values = NULL,
  hyperparameters = list(a_tau = 1, b_tau = 0.001, c_tau = 1, d_tau = 1, type = "mix",
    p_0 = 0.8, a_sigma = 1, b_sigma = 1, phi = 3, clam_smooth = 0.8),
  lambda_hyperparameters = list(a_lambda = 0.01, b_lambda = 0.01),
  iter = 150L,
  warmup_iter = 10L,
  refresh = 0,
  max_grid = 2000L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GibbsMH.WBorrow_+3A_y">Y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_i">I</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_y_0">Y_0</code></td>
<td>
<p>historical data</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_i_0">I_0</code></td>
<td>
<p>historical event indicator</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_x_0">X_0</code></td>
<td>
<p>historical design matrix</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_tuning_parameters">tuning_parameters</code></td>
<td>
<p>list of &quot;cprop_beta&quot;, &quot;cprop_beta_0&quot;, &quot;alpha&quot;, &quot;Jmax&quot;,
and &quot;pi_b&quot;</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_initial_values">initial_values</code></td>
<td>
<p>list containing the initial values of c(&quot;J&quot;, &quot;s_r&quot;,
&quot;mu&quot;, &quot;sigma2&quot;, &quot;tau&quot;, &quot;lambda_0&quot;, &quot;lambda&quot;, &quot;beta_0&quot;, &quot;beta&quot;) (optional)</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_hyperparameters">hyperparameters</code></td>
<td>
<p>list containing the hyperparameters c(&quot;a_tau&quot;, &quot;b_tau&quot;,
&quot;c_tau&quot;, &quot;d_tau&quot;,&quot;type&quot;, &quot;p_0&quot;, &quot;a_sigma&quot;, &quot;b_sigma&quot;, &quot;Jmax&quot;, &quot;clam_smooth&quot;,
&quot;cprop_beta&quot;, &quot;phi&quot;, &quot;pi_b&quot;). Default is list(&quot;a_tau&quot; = 1,&quot;b_tau&quot; = 1,&quot;c_tau&quot; = 1,
&quot;d_tau&quot; = 0.001, &quot;type&quot; = &quot;mix&quot;, &quot;p_0&quot; = 0.5, &quot;a_sigma&quot; = 2, &quot;b_sigma&quot; = 2,
&quot;Jmax&quot; = 20, &quot;clam_smooth&quot; = 0.8, &quot;cprop_beta&quot; = 0.3, &quot;phi&quot; = 3, &quot;pi_b&quot; = 0.5)</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_lambda_hyperparameters">lambda_hyperparameters</code></td>
<td>
<p>contains two hyperparameters (a_lambda and b_lambda)
used for the update of lambda and lambda_0. Default is c(0.01, 0.01)</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_iter">iter</code></td>
<td>
<p>number of iterations for MCMC sampler, excluding warmup, 
default is 2000</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_warmup_iter">warmup_iter</code></td>
<td>
<p>number of warmup iterations (burn-in) for MCMC sampler, 
default is 2000</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_refresh">refresh</code></td>
<td>
<p>number of iterations between printed screen updates, 
default is 500</p>
</td></tr>
<tr><td><code id="GibbsMH.WBorrow_+3A_max_grid">max_grid</code></td>
<td>
<p>grid size for the smoothed baseline hazard, default is 2000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with values after each iteration for parameters: out_fixed (J, 
mu, sigma2, beta), lambda, lambda_0, tau, s, as well as tuning values of the total number 
of accepts: lambda_move, lambda_0_move and beta_move. Also included is the out_slam which 
contains the shrunk estimate of the baseline hazard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Load example data and set your initial values and hyper parameters
data(weibull_cc, package = "BayesFBHborrow")
data(weibull_hist, package = "BayesFBHborrow")

# The datasets consists of 3 (2) columns named "tte", "event" and "X" 
# (only for concurrent). To explicitly run the sampler, extract the samples as
# following
Y &lt;- weibull_cc$tte
I &lt;- weibull_cc$event
X &lt;- matrix(weibull_cc$X_trt)

Y_0 &lt;- weibull_hist$tte
I_0 &lt;- weibull_hist$event
X_0 &lt;- NULL

# Specify hyperparameters and tuning parameters
hyper &lt;-  list("a_tau" = 1, 
               "b_tau" = 0.001,
               "c_tau" = 1,
               "d_tau" = 1, 
               "type" = "all",
               "p_0" = 0.5, 
               "a_sigma" = 2,
               "b_sigma" = 2,
               "clam_smooth" = 0.5,
               "phi" = 3)

tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5,
                          "alpha" = 0.4)
                          
# Set initial values to 'NULL' for default settings
output &lt;- GibbsMH(Y, I, X, Y_0, I_0, X_0,
                  tuning_parameters, initial_values = NULL, hyper, 
                  iter = 5, warmup_iter = 1)
</code></pre>

<hr>
<h2 id='group_summary'>Create group level data</h2><span id='topic+group_summary'></span>

<h3>Description</h3>

<p>Aggregate individual level data into group level data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_summary(Y, I, X, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_summary_+3A_y">Y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="group_summary_+3A_i">I</code></td>
<td>
<p>censoring indicator</p>
</td></tr>
<tr><td><code id="group_summary_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="group_summary_+3A_s">s</code></td>
<td>
<p>split points, J + 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of group level data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
# Load example data and set your initial values and hyper parameters
data(weibull_cc, package = "BayesFBHborrow")
data(weibull_hist, package = "BayesFBHborrow")

Y &lt;- weibull_cc$tte
I &lt;- weibull_cc$event
X &lt;- weibull_cc$X_trt

# Say we want to know the group level data for the following split points
s &lt;- quantile(Y, c(0, 0.45, 0.65, 1), names = FALSE)

group_summary(Y, I, X, s)
</code></pre>

<hr>
<h2 id='init_lambda_hyperparameters'>Initialize lambda hyperparameters</h2><span id='topic+init_lambda_hyperparameters'></span>

<h3>Description</h3>

<p>Propose lambda hyperparameters for the choice of 
initial values for lambda
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_lambda_hyperparameters(group_data, s, w = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_lambda_hyperparameters_+3A_group_data">group_data</code></td>
<td>
<p>group level data</p>
</td></tr>
<tr><td><code id="init_lambda_hyperparameters_+3A_s">s</code></td>
<td>
<p>split points</p>
</td></tr>
<tr><td><code id="init_lambda_hyperparameters_+3A_w">w</code></td>
<td>
<p>weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shape and rate for the estimated lambda distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(111)
# Load example data and set your initial values and hyper parameters
data(weibull_cc, package = "BayesFBHborrow")
data(weibull_hist, package = "BayesFBHborrow")

Y &lt;- weibull_cc$tte
I &lt;- weibull_cc$event
X &lt;- weibull_cc$X_trt

# Say we want to know the group level data for the following split points
s &lt;- quantile(Y, c(0, 0.45, 0.65, 1), names = FALSE)

group_data &lt;- group_summary(Y, I, NULL, s)
init_lambda_hyperparameters(group_data, s)
</code></pre>

<hr>
<h2 id='piecewise_exp_cc'>Example data, simulated from a piecewise exponential model.</h2><span id='topic+piecewise_exp_cc'></span>

<h3>Description</h3>

<p>Data is simulated for a concurrent trial with three columns named &quot;tte&quot; 
(time-to-event), &quot;event&quot; (event indicator), and &quot;X_trt&quot; (treatment indicator).
It was simulated using the following parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(piecewise_exp_cc)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 250 rows and 3 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(piecewise_exp_cc)
survival_model &lt;- survival::survfit(survival::Surv(tte, event) ~ X_trt, data = piecewise_exp_cc)
line_colors &lt;- c("blue", "red")  # Adjust colors as needed
line_types &lt;- 1:length(unique(piecewise_exp_cc$X_trt))
plot(survival_model, col = line_colors, lty = line_types, 
     xlab = "Time (tte)", ylab = "Survival Probability", 
     main = "Kaplan-Meier Survival Curves by Treatment")
</code></pre>

<hr>
<h2 id='piecewise_exp_hist'>Example data, simulated from a piecewise exponential model.</h2><span id='topic+piecewise_exp_hist'></span>

<h3>Description</h3>

<p>Data is simulated for a historical trial with two columns named &quot;tte&quot; 
(time-to-event) and &quot;event&quot; (event indicator).
It was simulated using the following parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(piecewise_exp_hist)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 100 rows and 2 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(piecewise_exp_cc)
data(piecewise_exp_hist)
piecewise_exp_hist$X_trt &lt;- 0
survival_model &lt;- survival::survfit(survival::Surv(tte, event) ~ X_trt, 
                                    data = rbind(piecewise_exp_cc, 
                                    piecewise_exp_hist))
line_colors &lt;- c("blue", "red", "green")  # Adjust colors as needed
line_types &lt;- 1:length(unique(piecewise_exp_cc$X_trt))
plot(survival_model, col = line_colors, lty = line_types, 
     xlab = "Time (tte)", ylab = "Survival Probability", 
     main = "Kaplan-Meier Survival Curves by Treatment")
</code></pre>

<hr>
<h2 id='plot_hist'>Plot histogram from MCMC samples</h2><span id='topic+plot_hist'></span>

<h3>Description</h3>

<p>Plots a histogram of the given discrete MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hist(
  samples,
  title = "",
  xlab = "Values",
  ylab = "Frequency",
  color = "black",
  fill = "blue",
  binwidth = 0.05,
  scale_x = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_hist_+3A_samples">samples</code></td>
<td>
<p>data.frame containing the discrete MCMC samples</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_title">title</code></td>
<td>
<p>title of the plot, default is none</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_xlab">xlab</code></td>
<td>
<p>x-label of the plot, default is &quot;Values&quot;</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_ylab">ylab</code></td>
<td>
<p>y-label of the plot, default is &quot;Frequency&quot;</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_color">color</code></td>
<td>
<p>outline color for the bars, default is &quot;black&quot;</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_fill">fill</code></td>
<td>
<p>fill color, default is &quot;blue&quot;</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_binwidth">binwidth</code></td>
<td>
<p>width of the histogram bins, default is 0.5</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_scale_x">scale_x</code></td>
<td>
<p>option to scale the x-axis, suitable for discrete samples, 
default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc, package = "BayesFBHborrow")

# Set your tuning parameters
tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# run the MCMC sampler
out &lt;- BayesFBHborrow(weibull_cc, NULL, tuning_parameters, 
                      initial_values = NULL,
                      iter = 10, warmup_iter = 1)

# Plot the frequency of the number of split points, J with a histogram
time_grid &lt;- seq(0, max(weibull_cc$tte), length.out = 2000)
gg &lt;- plot_hist(out$out_fixed$J, title = "Example histogram of J",
                scale_x = TRUE)
</code></pre>

<hr>
<h2 id='plot_matrix'>Plot smoothed baseline hazards</h2><span id='topic+plot_matrix'></span>

<h3>Description</h3>

<p>Plot mean and given quantiles of a matrix. Can also be used to 
plot derivatives of the baseline hazard, such as estimated cumulative hazard 
and survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matrix(
  x_lim,
  y,
  percentiles = c(0.05, 0.95),
  title = "",
  xlab = "",
  ylab = "",
  color = "blue",
  fill = "blue",
  linewidth = 1,
  alpha = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_matrix_+3A_x_lim">x_lim</code></td>
<td>
<p>time grid</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_y">y</code></td>
<td>
<p>samples</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_percentiles">percentiles</code></td>
<td>
<p>percentiles to include in plot, default is c(0.025, 0.975)</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_title">title</code></td>
<td>
<p>optional, add title to plot</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_xlab">xlab</code></td>
<td>
<p>optional, add xlabel</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_ylab">ylab</code></td>
<td>
<p>optional, add ylabel</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_color">color</code></td>
<td>
<p>color of the mid line, default is blue</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_fill">fill</code></td>
<td>
<p>color of the percentiles, default is blue</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_linewidth">linewidth</code></td>
<td>
<p>thickness of the plotted line, default is 1</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_alpha">alpha</code></td>
<td>
<p>opacity of the percentiles, default is 0.2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc, package = "BayesFBHborrow")

# Set your tuning parameters
tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# run the MCMC sampler
out &lt;- BayesFBHborrow(weibull_cc, NULL, tuning_parameters, 
                      initial_values = NULL,
                      iter = 10, warmup_iter = 1)

# Visualize the smoothed baseline hazard
time_grid &lt;- seq(0, max(weibull_cc$tte), length.out = 2000)
gg &lt;- plot_matrix(time_grid, out$out_slam, 
                  title = "Example plot of smoothed baseline hazard",
                  xlab = "time", ylab = "baseline hazard")
</code></pre>

<hr>
<h2 id='plot_trace'>Plot MCMC trace</h2><span id='topic+plot_trace'></span>

<h3>Description</h3>

<p>Creates a trace plot of given MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trace(
  x_lim,
  samples,
  title = "",
  xlab = "",
  ylab = "",
  color = "black",
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trace_+3A_x_lim">x_lim</code></td>
<td>
<p>x-axis of the plot</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_samples">samples</code></td>
<td>
<p>samples from MCMC</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_title">title</code></td>
<td>
<p>optional, add title to plot</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_xlab">xlab</code></td>
<td>
<p>optional, add xlabel</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_ylab">ylab</code></td>
<td>
<p>optional, add ylabel</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_color">color</code></td>
<td>
<p>color of the mid line, default is black</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_linewidth">linewidth</code></td>
<td>
<p>thickness of the plotted line, default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc, package = "BayesFBHborrow")

# Set your tuning parameters
tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# run the MCMC sampler
out &lt;- BayesFBHborrow(weibull_cc, NULL, tuning_parameters, 
                      initial_values = NULL,
                      iter = 10, warmup_iter = 1)

# Create a tarce plot of the treatment effect, beta_1
time_grid &lt;- seq(0, max(weibull_cc$tte), length.out = 2000)
gg &lt;- plot_trace(1:10, out$out_fixed$beta_1, 
                  title = "Example trace plot",
                  xlab = "iterations", ylab = "beta_1 (treatment effect)")
</code></pre>

<hr>
<h2 id='plot.BayesFBHborrow'>Plot the MCMC results</h2><span id='topic+plot.BayesFBHborrow'></span>

<h3>Description</h3>

<p>S3 object which produces different plots depending on the 
&quot;type&quot; variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesFBHborrow'
plot(x, x_lim, estimator = NULL, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BayesFBHborrow_+3A_x">x</code></td>
<td>
<p>object of class &quot;BayesFBHborrow&quot; to be visualized</p>
</td></tr>
<tr><td><code id="plot.BayesFBHborrow_+3A_x_lim">x_lim</code></td>
<td>
<p>x-axis to be used for plot</p>
</td></tr>
<tr><td><code id="plot.BayesFBHborrow_+3A_estimator">estimator</code></td>
<td>
<p>which estimate to be visualized</p>
</td></tr>
<tr><td><code id="plot.BayesFBHborrow_+3A_type">type</code></td>
<td>
<p>The type of plot to be produced, 
&quot;trace&quot; will produce a trace plot of the &quot;fixed&quot; parameters, 
&quot;hist&quot; will give a histogram for the &quot;fixed&quot; parameters, 
and &quot;matrix&quot; will plot the mean and quantiles of a given sample.</p>
</td></tr>
<tr><td><code id="plot.BayesFBHborrow_+3A_...">...</code></td>
<td>
<p>other plotting arguments, see plot_trace(), plot_hist(), plot_matrix()
for more information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc, package = "BayesFBHborrow")

# Set your tuning parameters
tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# run the MCMC sampler
out &lt;- BayesFBHborrow(weibull_cc, NULL, tuning_parameters, 
                      initial_values = NULL,
                      iter = 10, warmup_iter = 1)

# Now let's create a variety of plots

# Staring with a histogram of beta_1 (treatment effect)
gg_hist &lt;- plot(out, NULL, estimator = "beta_1", type = "hist",
                title = "Example histogram of beta_1")

# And an accompanied trace plot of the same parameter                 
gg_trace &lt;- plot(out, 1:10, estimator = "beta_1", type = "trace",
                  title = "Example trace plot", xlab = "iterations",
                  ylab = "beta_1 (treatment effect)")
                  
# Lastly. visualize the smoothed baseline hazard
time_grid &lt;- seq(0, max(weibull_cc$tte), length.out = 2000)
gg_matrix &lt;- plot(out, time_grid, estimator = "out_slam", type = "matrix",
                  title = "Example plot of smoothed baseline hazard",
                  xlab = "time", ylab = "baseline hazard")
</code></pre>

<hr>
<h2 id='summary.BayesFBHborrow'>Summarize fixed MCMC results</h2><span id='topic+summary.BayesFBHborrow'></span>

<h3>Description</h3>

<p>S3 method for with borrowing. Returns summary of mean, median and given 
percentiles for the one dimensional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesFBHborrow'
summary(
  object,
  estimator = NULL,
  percentiles = c(0.025, 0.25, 0.75, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BayesFBHborrow_+3A_object">object</code></td>
<td>
<p>MCMC sample object from BayesFBHborrow()</p>
</td></tr>
<tr><td><code id="summary.BayesFBHborrow_+3A_estimator">estimator</code></td>
<td>
<p>The type of estimator to summarize, could be &quot;fixed&quot;, &quot;lambda&quot;,
&quot;lambda_0&quot; or &quot;s&quot;. The default is NULL and will print a summary of the output list.</p>
</td></tr>
<tr><td><code id="summary.BayesFBHborrow_+3A_percentiles">percentiles</code></td>
<td>
<p>Given percentiles to output, default is c(0.025, 0.25, 0.75, 0.975)</p>
</td></tr>
<tr><td><code id="summary.BayesFBHborrow_+3A_...">...</code></td>
<td>
<p>other arguments, see summary.default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary of the given estimator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(piecewise_exp_cc, package = "BayesFBHborrow")

# Set your tuning parameters
tuning_parameters &lt;- list("Jmax" = 5,
                          "pi_b" = 0.5,
                          "cprop_beta" = 0.5)
                          
# run the MCMC sampler
out &lt;- BayesFBHborrow(piecewise_exp_cc, NULL, tuning_parameters, 
                      initial_values = NULL,
                      iter = 10, warmup_iter = 1)

# Create a summary of the output
summary(out, estimator = "out_fixed")
</code></pre>

<hr>
<h2 id='weibull_cc'>Example data, simulated from a Weibull distribution.</h2><span id='topic+weibull_cc'></span>

<h3>Description</h3>

<p>Data is simulated for a concurrent trial with three columns named &quot;tte&quot; 
(time-to-event), &quot;event&quot; (event indicator), and &quot;X_trt&quot; (treatment indicator).
It was simulated by drawing samples from a Weibull with kappa = 1.5 (shape) 
and nu = 0.4 (scale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(weibull_cc)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 250 rows and 3 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc)
survival_model &lt;- survival::survfit(survival::Surv(tte, event) ~ X_trt, data = weibull_cc)
line_colors &lt;- c("blue", "red")  # Adjust colors as needed
line_types &lt;- 1:length(unique(weibull_cc$X_trt))
plot(survival_model, col = line_colors, lty = line_types, 
     xlab = "Time (tte)", ylab = "Survival Probability", 
     main = "Kaplan-Meier Survival Curves by Treatment")
</code></pre>

<hr>
<h2 id='weibull_hist'>Example data, simulated from a Weibull distribution</h2><span id='topic+weibull_hist'></span>

<h3>Description</h3>

<p>Data is simulated for a historical trial with two columns named &quot;tte&quot; 
(time-to-event) and &quot;event&quot; (event indicator).
It was simulated using the following parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(weibull_hist)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 100 rows and 2 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(weibull_cc)
data(weibull_hist)
weibull_hist$X_trt &lt;- 0
survival_model &lt;- survival::survfit(survival::Surv(tte, event) ~ X_trt, 
                                    data = rbind(weibull_cc, 
                                    weibull_hist))
line_colors &lt;- c("blue", "red", "green")  # Adjust colors as needed
line_types &lt;- 1:length(unique(weibull_cc$X_trt))
plot(survival_model, col = line_colors, lty = line_types, 
     xlab = "Time (tte)", ylab = "Survival Probability", 
     main = "Kaplan-Meier Survival Curves by Treatment")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
