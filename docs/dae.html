<!DOCTYPE html><html><head><title>Help for package dae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dae-package'>
<p>Functions Useful in the Design and ANOVA of Experiments</p></a></li>
<li><a href='#ABC.Interact.dat'><p>Randomly generated set of values indexed by three factors</p></a></li>
<li><a href='#as.data.frame.pstructure'><p>Coerces a pstructure.object to a data.frame.</p></a></li>
<li><a href='#as.numfac'><p>Convert a factor to a numeric vector</p></a></li>
<li><a href='#BIBDWheat.dat'><p>Data for a balanced incomplete block experiment</p></a></li>
<li><a href='#blockboundaryPlot'><p>This function plots a block boundary on a plot produced by <code>designPlot</code>.</p></a></li>
<li><a href='#Cabinet1.des'><p>A design for one of the growth cabinets in an experiment with 50 lines and 4 harvests</p></a></li>
<li><a href='#Casuarina.dat'><p>Data for an experiment with rows and columns from Williams (2002)</p></a></li>
<li><a href='#correct.degfree'><p>Check the degrees of freedom in an object of class projector</p></a></li>
<li><a href='#dae-deprecated'><p>Deprecated Functions in Package dae</p></a></li>
<li><a href='#daeTips'><p>The intermittent, randomly-presented, startup tips.</p></a></li>
<li><a href='#decomp.relate'><p>Examines the relationship between the eigenvectors for two decompositions</p></a></li>
<li><a href='#degfree'><p>Degrees of freedom extraction and replacement</p></a></li>
<li><a href='#designAmeasures'><p>Calculates the average variance of pairwise differences from the variance matrix</p>
for predictions</a></li>
<li><a href='#designAnatomy'><p>Given the layout for a design, obtain its anatomy via the canonical analysis</p>
of its projectors to show the confounding and
aliasing inherent in the design.</a></li>
<li><a href='#designBlocksGGPlot'><p>Adds block boundaries to a plot produced by <code>designGGPlot</code>.</p></a></li>
<li><a href='#designGGPlot'><p>Plots labels on two-way grids of coloured cells using <code>ggplot2</code> to represent an experimental design</p></a></li>
<li><a href='#designLatinSqrSys'><p>Generate a systematic plan for a Latin Square design</p></a></li>
<li><a href='#designPlot'><p>A graphical representation of an experimental design using labels stored in a matrix.</p></a></li>
<li><a href='#designPlotlabels'><p>Plots labels on a two-way grid using <code>ggplot2</code></p></a></li>
<li><a href='#designRandomize'><p>Randomize allocated to recipient factors to produce a layout for an experiment</p></a></li>
<li><a href='#designTwophaseAnatomies'><p>Given the layout for a design and three structure formulae, obtain the anatomies for the (i) two-phase, (ii) first-phase, (iii) cross-phase, treatments, and (iv) combined-units designs.</p></a></li>
<li><a href='#detect.diff'><p>Computes the detectable difference for an experiment</p></a></li>
<li><a href='#efficiencies'><p>Extracts the canonical efficiency factors from a <code>pcanon.object</code> or a <code>p2canon.object</code>.</p></a></li>
<li><a href='#efficiency.criteria'><p>Computes efficiency criteria from a set of efficiency factors</p></a></li>
<li><a href='#elements'><p>Extract the elements of an array specified by the subscripts</p></a></li>
<li><a href='#Exp249.munit.des'><p>Systematic, main-unit design for an experiment to be run in a greenhouse</p></a></li>
<li><a href='#extab'><p>Expands the values in table to a vector</p></a></li>
<li><a href='#fac.ar1mat'><p>forms the ar1 correlation matrix for a (generalized) factor</p></a></li>
<li><a href='#fac.combine'><p>Combines several factors into one</p></a></li>
<li><a href='#fac.divide'><p>Divides a factor into several separate factors</p></a></li>
<li><a href='#fac.gen'><p>Generate all combinations of several factors and, optionally, replicate them</p></a></li>
<li><a href='#fac.genfactors'><p>Generate all combinations of the levels of the supplied factors, without replication</p></a></li>
<li><a href='#fac.match'><p>Match, for each combination of a set of columns in <code>x</code>, the row that has the same combination in <code>table</code></p></a></li>
<li><a href='#fac.meanop'><p>computes the projection matrix that produces means</p></a></li>
<li><a href='#fac.multinested'><p>Creates several factors, one for each level of nesting.fac and each of whose values are either generated within those of a level of nesting.fac or using the values of nested.fac within a levels of nesting.fac.</p></a></li>
<li><a href='#fac.nested'><p>creates a factor, the nested factor, whose values are generated within those of the factor</p>
nesting.fac</a></li>
<li><a href='#fac.recast'><p>Recasts a factor by modifying the values in the factor vector and/or the levels attribute, possibly combining some levels into a single level.</p></a></li>
<li><a href='#fac.recode'><p>Recodes factor <code>levels</code> using values in a vector. The values in the vector do</p>
not have to be unique.</a></li>
<li><a href='#fac.split'><p>Splits a factor whose levels consist of several delimited strings into several factors</p></a></li>
<li><a href='#fac.sumop'><p>computes the summation matrix that produces sums corresponding to a (generalized) factor</p></a></li>
<li><a href='#fac.uncombine'><p>Cleaves a single factor, each of whose levels has delimited strings, into several</p>
factors using the separated strings.</a></li>
<li><a href='#fac.uselogical'><p>Forms a two-level <code>factor</code> from a <code>logical</code> object.</p></a></li>
<li><a href='#fac.vcmat'><p>forms the variance matrix for the variance component of a (generalized) factor</p></a></li>
<li><a href='#Fac4Proc.dat'><p>Data for a 2^4 factorial experiment</p></a></li>
<li><a href='#fitted.aovlist'><p>Extract the fitted values for a fitted model from an aovlist object</p></a></li>
<li><a href='#fitted.errors'><p>Extract the fitted values for a fitted model</p></a></li>
<li><a href='#get.daeTolerance'><p>Gets the value of daeTolerance for the package dae</p></a></li>
<li><a href='#harmonic.mean'><p>Calcuates the harmonic mean.</p></a></li>
<li><a href='#interaction.ABC.plot'><p>Plots an interaction plot for three factors</p></a></li>
<li><a href='#is.allzero'><p>Tests whether all elements are approximately zero</p></a></li>
<li><a href='#is.projector'><p>Tests whether an object is a valid object of class projector</p></a></li>
<li><a href='#LatticeSquare_t49.des'><p>A Lattice square design for 49 treatments</p></a></li>
<li><a href='#marginality'><p>Extracts the marginality matrix (matrices) from a <code>pstructure.object</code> or a <code>pcanon.object</code>.</p></a></li>
<li><a href='#mat.ar1'><p>Forms an ar1 correlation matrix</p></a></li>
<li><a href='#mat.ar2'><p>Forms an ar2 correlation matrix</p></a></li>
<li><a href='#mat.ar3'><p>Forms an ar3 correlation matrix</p></a></li>
<li><a href='#mat.arma'><p>Forms an arma correlation matrix</p></a></li>
<li><a href='#mat.banded'><p>Form a banded matrix from a vector of values</p></a></li>
<li><a href='#mat.cor'><p>Forms a correlation matrix in which all correlations have the same value.</p></a></li>
<li><a href='#mat.corg'><p>Forms a general correlation matrix</p></a></li>
<li><a href='#mat.dirprod'><p>Forms the direct product of two matrices</p></a></li>
<li><a href='#mat.dirsum'><p>Forms the direct sum of a list of matrices</p></a></li>
<li><a href='#mat.exp'><p>Forms an exponential correlation matrix</p></a></li>
<li><a href='#mat.gau'><p>Forms an exponential correlation matrix</p></a></li>
<li><a href='#mat.ginv'><p>Computes the generalized inverse of a matrix</p></a></li>
<li><a href='#mat.I'><p>Forms a unit matrix</p></a></li>
<li><a href='#mat.J'><p>Forms a square matrix of ones</p></a></li>
<li><a href='#mat.ma1'><p>Forms an ma1 correlation matrix</p></a></li>
<li><a href='#mat.ma2'><p>Forms an ma2 correlation matrix</p></a></li>
<li><a href='#mat.ncssvar'><p>Calculates the variance matrix of the random effects for a natural</p>
cubic smoothing spline</a></li>
<li><a href='#mat.random'><p>Calculates the variance matrix for the random effects from a mixed model, based  on a supplied formula or a matrix.</p></a></li>
<li><a href='#mat.sar'><p>Forms an sar correlation matrix</p></a></li>
<li><a href='#mat.sar2'><p>Forms an sar2 correlation matrix</p></a></li>
<li><a href='#mat.Vpred'><p>Calculates the variances of a set of predicted effects from a mixed model</p></a></li>
<li><a href='#mat.Vpredicts'><p>Calculates the variances of a set of predicted effects from a mixed model, based  on supplied matrices or formulae.</p></a></li>
<li><a href='#McIntyreTMV.dat'><p>The design and data from McIntyre's (1955) two-phase experiment</p></a></li>
<li><a href='#meanop'><p>computes the projection matrix that produces means</p></a></li>
<li><a href='#mpone'><p>Converts the first two levels of a factor into the numeric values</p>
-1 and +1</a></li>
<li><a href='#no.reps'><p>Computes the number of replicates for an experiment</p></a></li>
<li><a href='#Oats.dat'><p>Data for an experiment to investigate nitrogen response of 3 oats varieties</p></a></li>
<li><a href='#p2canon.object'><p>Description of a p2canon object</p></a></li>
<li><a href='#pcanon.object'><p>Description of a pcanon object</p></a></li>
<li><a href='#porthogonalize.list'><p>Takes a list of <code>projectors</code> and constructs a <code>pstructure.object</code> that includes projectors, each of which has been orthogonalized to all projectors preceding it in the list.</p></a></li>
<li><a href='#power.exp'><p>Computes the power for an experiment</p></a></li>
<li><a href='#print.aliasing'><p>Print an aliasing data.frame</p></a></li>
<li><a href='#print.projector'><p>Print projectors</p></a></li>
<li><a href='#print.pstructure'><p>Prints a pstructure.object</p></a></li>
<li><a href='#print.summary.p2canon'><p>Prints the values in an <code>summary.p2canon</code> object</p></a></li>
<li><a href='#print.summary.pcanon'><p>Prints the values in an <code>summary.pcanon</code> object</p></a></li>
<li><a href='#proj2.combine'><p>Compute the projection and Residual operators for two, possibly</p>
nonorthogonal, projectors</a></li>
<li><a href='#proj2.efficiency'><p>Computes the canonical efficiency factors for the joint decomposition of</p>
two projectors</a></li>
<li><a href='#proj2.eigen'><p>Canonical efficiency factors and eigenvectors in joint decomposition of two projectors</p></a></li>
<li><a href='#projector'><p>Create projectors</p></a></li>
<li><a href='#projector-class'><p>Class projector</p></a></li>
<li><a href='#projs.2canon'><p>A canonical analysis of the relationships between two sets of projectors</p></a></li>
<li><a href='#projs.combine.p2canon'><p>Extract, from a p2canon object, the projectors that give the combined</p>
canonical decomposition</a></li>
<li><a href='#pstructure.formula'><p>Takes a formula and constructs a <code>pstructure.object</code> that includes the orthogonalized projectors for the terms in a formula</p></a></li>
<li><a href='#pstructure.object'><p>Description of a pstructure object</p></a></li>
<li><a href='#qqyeffects'><p>Half or full normal plot of Yates effects</p></a></li>
<li><a href='#rep.data.frame'><p>Replicate the rows of a data.frame by repeating each row consecutively and/or repeating all rows as a group</p></a></li>
<li><a href='#resid.errors'><p>Extract the residuals for a fitted model</p></a></li>
<li><a href='#residuals.aovlist'><p>Extract the residuals from an aovlist object</p></a></li>
<li><a href='#rmvnorm'><p>generates a vector of random values from a multivariate normal distribution</p></a></li>
<li><a href='#Sensory3Phase.dat'><p>Data for the three-phase sensory evaluation experiment in Brien, C.J. and Payne,</p>
R.W. (1999)</a></li>
<li><a href='#set.daeTolerance'><p>Sets the values of daeTolerance for the package dae</p></a></li>
<li><a href='#show-methods'><p>Methods for Function show in Package dae</p></a></li>
<li><a href='#SPLGrass.dat'><p>Data for an experiment to investigate the effects of grazing patterns on</p>
pasture composition</a></li>
<li><a href='#strength'><p>Generate paper strength values</p></a></li>
<li><a href='#summary.p2canon'><p>Summarize a canonical analysis of the relationships between two sets of projectors</p></a></li>
<li><a href='#summary.pcanon'><p>Summarizes the anatomy of a design, being the decomposition of the sample space based on its</p>
canonical analysis, as produced by designAnatomy</a></li>
<li><a href='#tukey.1df'><p>Performs Tukey's one-degree-of-freedom-test-for-nonadditivity</p></a></li>
<li><a href='#yates.effects'><p>Extract Yates effects</p></a></li>
<li><a href='#Zncsspline'><p>Calculates the design matrix for fitting the random component of a natural</p>
cubic smoothing spline</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2.25</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions Useful in the Design and ANOVA of Experiments</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggpubr, graphics, methods, plyr, stats, tryCatchLog</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, vdiffr, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>The content falls into the following groupings: (i) Data, (ii)
    Factor manipulation functions, (iii) Design functions, (iv) ANOVA functions, (v)
    Matrix functions, (vi) Projector and canonical efficiency functions, and (vii)
    Miscellaneous functions. There is a vignette describing how to use the 
    design functions for randomizing and assessing designs available as a 
    vignette called 'DesignNotes'. The ANOVA functions facilitate the extraction of 
    information when the 'Error' function has been used in the call to 'aov'. 
    The package 'dae' can also be installed from 
  <a href="http://chris.brien.name/rpackages/">http://chris.brien.name/rpackages/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://chris.brien.name">http://chris.brien.name</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/briencj/dae/issues">https://github.com/briencj/dae/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-09 11:35:18 UTC; briencj</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Brien <a href="https://orcid.org/0000-0003-0581-1817"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Brien &lt;chris.brien@adelaide.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-09 12:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dae-package'>
Functions Useful in the Design and ANOVA of Experiments
</h2><span id='topic+dae-package'></span><span id='topic+dae'></span>

<h3>Description</h3>

<p>The content falls into the following groupings: (i) Data, (ii)
    Factor manipulation functions, (iii) Design functions, (iv) ANOVA functions, (v)
    Matrix functions, (vi) Projector and canonical efficiency functions, and (vii)
    Miscellaneous functions. There is a vignette describing how to use the 
    design functions for randomizing and assessing designs available as a 
    vignette called 'DesignNotes'. The ANOVA functions facilitate the extraction of 
    information when the 'Error' function has been used in the call to 'aov'. 
    The package 'dae' can also be installed from 
  &lt;http://chris.brien.name/rpackages/&gt;.
</p>
<p><b>Version:</b> 3.2.25
</p>
<p><b>Date:</b> 2024-04-09
</p>


<h3>Index</h3>


<table>
<tr>
 <td style="text-align: left;">
(i) Data</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+ABC.Interact.dat">ABC.Interact.dat</a></code> 
  </td><td style="text-align: left;"> Randomly generated set of values indexed by </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> three factors </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+BIBDWheat.dat">BIBDWheat.dat</a></code> 
  </td><td style="text-align: left;"> Data for a balanced incomplete block experiment </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Casuarina.dat">Casuarina.dat</a></code>
  </td><td style="text-align: left;"> Data for an experiment with rows and columns from </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> Williams (2002) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Exp249.munit.des">Exp249.munit.des</a></code>
 </td><td style="text-align: left;"> Systematic, main-plot design for an experiment to be </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> run in a greenhouse </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Fac4Proc.dat">Fac4Proc.dat</a></code>
  </td><td style="text-align: left;"> Data for a 2^4 factorial experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+LatticeSquare_t49.des">LatticeSquare_t49.des</a></code>
 </td><td style="text-align: left;"> A Lattice square design for 49 treatments </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+McIntyreTMV.dat">McIntyreTMV.dat</a></code>
 </td><td style="text-align: left;"> The design and data from McIntyre (1955) two-phase </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> experiment </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Oats.dat">Oats.dat</a></code>
 </td><td style="text-align: left;"> Data for an experiment to investigate nitrogen response </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> of 3 oats varieties    </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code><a href="#topic+Sensory3Phase.dat">Sensory3Phase.dat</a></code>
 </td><td style="text-align: left;"> Data for the three-phahse sensory evaluation </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> experiment in Brien, C.J. and Payne, R.W. (1999)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Sensory3PhaseShort.dat">Sensory3PhaseShort.dat</a></code>
 </td><td style="text-align: left;"> Data for the three-phase sensory evaluation </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> experiment in Brien, C.J. and Payne, R.W. (1999), </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> but with short factor names </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+SPLGrass.dat">SPLGrass.dat</a></code>
  </td><td style="text-align: left;"> Data for an experiment to investigate the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> effects of grazing patterns on pasture </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> composition </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(ii) Factor manipulation functions </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

Forms a new or revised factor: </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+fac.combine">fac.combine</a></code>
  </td><td style="text-align: left;"> Combines several factors into one </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.multinested">fac.multinested</a></code>
  </td><td style="text-align: left;"> Creates several factors, one for each level of a nesting.fac </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> and each of whose values are either generated within </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> those of the level of nesting.fac or using the values </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> of a nested.fac</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.nested">fac.nested</a></code>
  </td><td style="text-align: left;"> Creates a factor, the nested factor, whose values are </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> generated within those of a nesting factor</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.recast">fac.recast</a></code>
  </td><td style="text-align: left;"> Recasts a factor by modifying the values in the factor vector</td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> and/or the levels attribute, possibly combining </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> some levels into a single level. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.recode">fac.recode</a></code>
  </td><td style="text-align: left;"> Recodes factor 'levels' using possibly nonunique </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> values in a vector. (May be deprecated in future.)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.uselogical">fac.uselogical</a></code>
  </td><td style="text-align: left;"> Forms a two-level factor from a logical object </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mpone">mpone</a></code>
  </td><td style="text-align: left;"> Converts the first two levels of a factor into</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> the numeric values -1 and +1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Forms multiple new factors:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+fac.divide">fac.divide</a></code>
  </td><td style="text-align: left;"> Divides a factor into several separate factors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.gen">fac.gen</a></code>
  </td><td style="text-align: left;"> Generate all combinations of several factors and, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> optionally, replicate them</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.genfactors">fac.genfactors</a></code>
  </td><td style="text-align: left;"> Generate all combinations of the levels of the supplied </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> factors, without replication </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.split">fac.split</a></code>
  </td><td style="text-align: left;"> Splits a factor whose levels consist of several delimited </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> strings into several factors.   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.uncombine">fac.uncombine</a></code>
  </td><td style="text-align: left;"> Cleaves a single factor, each of whose levels has delimited </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> strings, into several factors using the separated strings.  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Operates on factors:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+as.numfac">as.numfac</a></code>             
 </td><td style="text-align: left;"> Convert a factor to a numeric vector </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.match">fac.match</a></code>
  </td><td style="text-align: left;"> Match, for each combination of a set of columns </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> in 'x', the row that has the same combination</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> in 'table'</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(iii) Design functions</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

Designing experiments:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designLatinSqrSys">designLatinSqrSys</a></code>
  </td><td style="text-align: left;"> Generate a systematic plan for a Latin Square design.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designRandomize">designRandomize</a></code>
  </td><td style="text-align: left;"> Randomize allocated to recipient factors to produce  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> a layout for an experiment. It supersedes <code>fac.layout</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+no.reps">no.reps</a></code>
  </td><td style="text-align: left;"> Computes the number of replicates for an experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+detect.diff">detect.diff</a></code>
  </td><td style="text-align: left;"> Computes the detectable difference for an experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+power.exp">power.exp</a></code>
  </td><td style="text-align: left;"> Computes the power for an experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Plotting designs:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+blockboundaryPlot">blockboundaryPlot</a></code>
  </td><td style="text-align: left;"> This function plots a block boundary on a plot </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> produced by 'designPlot'. It supersedes  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> blockboundary.plot. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designBlocksGGPlot">designBlocksGGPlot</a></code>
  </td><td style="text-align: left;"> Adds block boundaries to a plot produced by <code><a href="#topic+designGGPlot">designGGPlot</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designGGPlot">designGGPlot</a></code>
  </td><td style="text-align: left;"> Plots labels on a two-way grid of coloured cells using <code>ggplot2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> to represent an experimental design. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designPlot">designPlot</a></code>
  </td><td style="text-align: left;"> A graphical representation of an experimental design </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> using labels stored in a matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> It superseded design.plot.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designPlotlabels">designPlotlabels</a></code>
  </td><td style="text-align: left;"> Plots labels on a two-way grid using <code>ggplot2</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Assessing designs:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+designAmeasures">designAmeasures</a></code>
  </td><td style="text-align: left;"> Calculates the A-optimality measures from the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> variance matrix for predictions.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designAnatomy">designAnatomy</a></code>
  </td><td style="text-align: left;"> Given the layout for a design, obtain its anatomy via </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> the canonical analysis of its projectors to show the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> confounding and aliasing inherent in the design.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+designTwophaseAnatomies">designTwophaseAnatomies</a></code>
  </td><td style="text-align: left;"> Given the layout for a design and three structure formulae, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> obtain the anatomies for the (i) two-phase,  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> (ii) first-phase, (iii) cross-phase, treatments, and </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> (iv) combined-units designs. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+marginality.pstructure">marginality.pstructure</a></code> 
  </td><td style="text-align: left;"> Extracts the marginality matrix from a </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> <code><a href="#topic+pstructure.object">pstructure.object</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+marginality.pstructure">marginality.pstructure</a></code> 
  </td><td style="text-align: left;"> Extracts a list containing the marginality matrices from </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> a <code><a href="#topic+pcanon.object">pcanon.object</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.aliasing">print.aliasing</a></code> 
  </td><td style="text-align: left;"> Prints an aliasing data.frame </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+summary.pcanon">summary.pcanon</a></code>
  </td><td style="text-align: left;"> Summarizes the anatomy of a design, being the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> decomposition of the sample space based on its </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> canonical analysis. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(iv) ANOVA functions </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+fitted.aovlist">fitted.aovlist</a></code>
  </td><td style="text-align: left;"> Extract the fitted values for a fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> from an aovlist object</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fitted.errors">fitted.errors</a></code>
  </td><td style="text-align: left;"> Extract the fitted values for a fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+interaction.ABC.plot">interaction.ABC.plot</a></code>
  </td><td style="text-align: left;"> Plots an interaction plot for three factors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+qqyeffects">qqyeffects</a></code>
  </td><td style="text-align: left;"> Half or full normal plot of Yates effects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+resid.errors">resid.errors</a></code>
  </td><td style="text-align: left;"> Extract the residuals for a fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+residuals.aovlist">residuals.aovlist</a></code>
  </td><td style="text-align: left;"> Extract the residuals from an aovlist object</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+strength">strength</a></code>
  </td><td style="text-align: left;"> Generate paper strength values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+tukey.1df">tukey.1df</a></code>
  </td><td style="text-align: left;"> Performs Tukey's</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> one-degree-of-freedom-test-for-nonadditivity</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+yates.effects">yates.effects</a></code>
  </td><td style="text-align: left;"> Extract Yates effects</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(v) Matrix functions</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

Operates on matrices:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+elements">elements</a></code>
  </td><td style="text-align: left;"> Extract the elements of an array specified by</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> the subscripts</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.dirprod">mat.dirprod</a></code>
  </td><td style="text-align: left;"> Forms the direct product of two matrices</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.dirsum">mat.dirsum</a></code>
  </td><td style="text-align: left;"> Forms the direct sum of a list of matrices</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ginv">mat.ginv</a></code>
  </td><td style="text-align: left;"> Computes the generalized inverse of a matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Zncsspline">Zncsspline</a></code>
  </td><td style="text-align: left;"> Forms the design matrix for fitting the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> random effects for a natural cubic smoothing </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> spline. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Compute variance matrices for </td>
</tr>
<tr>
 <td style="text-align: left;">
supplied variance component values:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+mat.random">mat.random</a></code>
  </td><td style="text-align: left;"> Calculates the variance matrix for the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> random effects from a mixed model, based  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> on a formula or a supplied matrix  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.Vpred">mat.Vpred</a></code>
  </td><td style="text-align: left;"> Forms the variance matrix of predictions </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> based on supplied matrices </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.Vpredicts">mat.Vpredicts</a></code>
  </td><td style="text-align: left;"> Forms the variance matrix of predictions,</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> based  on supplied matrices or formulae. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Forms matrices using factors </td>
</tr>
<tr>
 <td style="text-align: left;">
stored in a data.frame:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+fac.ar1mat">fac.ar1mat</a></code>
  </td><td style="text-align: left;"> Forms the ar1 correlation matrix for a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> (generalized) factor</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.sumop">fac.sumop</a></code>
  </td><td style="text-align: left;"> Computes the summation matrix that produces</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> sums corresponding to a (generalized) factor</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.vcmat">fac.vcmat</a></code>
  </td><td style="text-align: left;"> Forms the variance matrix for the variance</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> component of a (generalized) factor</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Forms patterned matrices:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+mat.I">mat.I</a></code>
  </td><td style="text-align: left;"> Forms a unit matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.J">mat.J</a></code>
  </td><td style="text-align: left;"> Forms a square matrix of ones</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ncssvar">mat.ncssvar</a></code>
  </td><td style="text-align: left;"> Forms a variance matrix for random cubic </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> smoothing spline effects</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Forms correlation matrices:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+mat.cor">mat.cor</a></code>
  </td><td style="text-align: left;"> Forms a correlation matrix in which all </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> correlations have the same value </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.corg">mat.corg</a></code>
  </td><td style="text-align: left;"> Forms a general correlation matrix in which </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> all correlations have different values </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ar1">mat.ar1</a></code>
  </td><td style="text-align: left;"> Forms an ar1 correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ar2">mat.ar2</a></code>
  </td><td style="text-align: left;"> Forms an ar2 correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ar3">mat.ar3</a></code>
  </td><td style="text-align: left;"> Forms an ar3 correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.arma">mat.arma</a></code>
  </td><td style="text-align: left;"> Forms an arma correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.banded">mat.banded</a></code>
  </td><td style="text-align: left;"> Forms a banded matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.exp">mat.exp</a></code>
  </td><td style="text-align: left;"> Forms an exponential correlation matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.gau">mat.gau</a></code>
  </td><td style="text-align: left;"> Forms a gaussian correlation matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ma1">mat.ma1</a></code>
  </td><td style="text-align: left;"> Forms an ma1 correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.ma2">mat.ma2</a></code>
  </td><td style="text-align: left;"> Forms an ma2 correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.sar">mat.sar</a></code>
  </td><td style="text-align: left;"> Forms an sar correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mat.sar2">mat.sar2</a></code>
  </td><td style="text-align: left;"> Forms an sar2 correlation matrix</td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>
<tr>
 <td style="text-align: left;">
(vi) Projector and canonical efficiency functions</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Projector class:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+projector">projector</a></code>
  </td><td style="text-align: left;"> Create projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+projector-class">projector-class</a></code>
  </td><td style="text-align: left;"> Class projector</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+is.projector">is.projector</a></code>
  </td><td style="text-align: left;"> Tests whether an object is a valid object of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> class projector</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.projector">print.projector</a></code>
  </td><td style="text-align: left;"> Print projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+correct.degfree">correct.degfree</a></code>
  </td><td style="text-align: left;"> Check the degrees of freedom in an object of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> class projector</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+degfree">degfree</a></code>
  </td><td style="text-align: left;"> Degrees of freedom extraction and replacement</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Accepts two or more formulae:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+designAnatomy">designAnatomy</a></code>
  </td><td style="text-align: left;"> An anatomy of a design, obtained from </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> a canonical analysis of the relationships </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> between sets of projectors.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+summary.pcanon">summary.pcanon</a></code>
  </td><td style="text-align: left;"> Summarizes the anatomy of a design, being the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> decomposition of the sample space based on its </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> canonical analysis </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.summary.pcanon">print.summary.pcanon</a></code>
  </td><td style="text-align: left;"> Prints the values in an 'summary.pcanon' object</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+efficiencies.pcanon">efficiencies.pcanon</a></code>
  </td><td style="text-align: left;"> Extracts the canonical efficiency factors from a </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> list of class 'pcanon'</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Accepts exactly two formulae:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+projs.2canon">projs.2canon</a></code>
  </td><td style="text-align: left;"> A canonical analysis of the relationships between</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> two sets of projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+projs.combine.p2canon">projs.combine.p2canon</a></code>
  </td><td style="text-align: left;"> Extract, from a p2canon object, the projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+summary.p2canon">summary.p2canon</a></code>
  </td><td style="text-align: left;"> A summary of the results of an analysis of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> the relationships between two sets of projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.summary.p2canon">print.summary.p2canon</a></code>
  </td><td style="text-align: left;"> Prints the values in an 'summary.p2canon' object</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> that give the combined decomposition</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+efficiencies.p2canon">efficiencies.p2canon</a></code>
  </td><td style="text-align: left;"> Extracts the canonical efficiency factors from</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> a list of class 'p2canon'</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
Accepts a single formula:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+as.data.frame.pstructure">as.data.frame.pstructure</a></code>
  </td><td style="text-align: left;"> Coerces a pstructure.object to a data.frame </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+print.pstructure">print.pstructure</a></code>
  </td><td style="text-align: left;"> Prints a pstructure.object </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+pstructure.formula">pstructure.formula</a></code>
  </td><td style="text-align: left;"> Takes a formula and constructs a pstructure.object </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> that includes the orthogonalized projectors for the </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> terms in a formula</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+porthogonalize.list">porthogonalize.list</a></code>
  </td><td style="text-align: left;"> Takes a list of <code><a href="#topic+projector">projector</a>s</code> and constructs </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> a <code><a href="#topic+pstructure.object">pstructure.object</a></code> that includes projectors, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> each of which has been orthogonalized to all projectors </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> preceding it in the list.       </td>
</tr>
<tr>
 <td style="text-align: left;">

Others:</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+decomp.relate">decomp.relate</a></code>
  </td><td style="text-align: left;"> Examines the relationship between the</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> eigenvectors for two decompositions</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>
  </td><td style="text-align: left;"> Computes efficiency criteria from a set of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> efficiency factors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fac.meanop">fac.meanop</a></code>
  </td><td style="text-align: left;"> Computes the projection matrix that produces means</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+proj2.eigen">proj2.eigen</a></code>
  </td><td style="text-align: left;"> Canonical efficiency factors and eigenvectors</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> in joint decomposition of two projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>
  </td><td style="text-align: left;"> Computes the canonical efficiency factors for</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> the joint decomposition of two projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+proj2.combine">proj2.combine</a></code>
  </td><td style="text-align: left;"> Compute the projection and Residual operators</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> for two, possibly nonorthogonal, projectors</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+show-methods">show-methods</a></code>
  </td><td style="text-align: left;"> Methods for Function 'show' in Package dae</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(vii) Miscellaneous functions</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+extab">extab</a></code>
  </td><td style="text-align: left;"> Expands the values in table to a vector</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+get.daeTolerance">get.daeTolerance</a></code>
  </td><td style="text-align: left;"> Gets the value of daeTolerance for the package dae</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+harmonic.mean">harmonic.mean</a></code>
  </td><td style="text-align: left;"> Calcuates the harmonic mean.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+is.allzero">is.allzero</a></code>
  </td><td style="text-align: left;"> Tests whether all elements are approximately zero</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rep.data.frame">rep.data.frame</a></code>
  </td><td style="text-align: left;"> Replicate the rows of a data.frame by repeating  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> each row consecutively and/or repeating all rows </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> as a group. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rmvnorm">rmvnorm</a></code>
  </td><td style="text-align: left;"> Generates a vector of random values from a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> multivariate normal distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code>
  </td><td style="text-align: left;"> Sets the value of daeTolerance for the package dae</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Chris Brien [aut, cre] (&lt;https://orcid.org/0000-0003-0581-1817&gt;)
</p>
<p>Maintainer: Chris Brien &lt;chris.brien@adelaide.edu.au&gt;
</p>

<hr>
<h2 id='ABC.Interact.dat'>Randomly generated set of values indexed by three factors</h2><span id='topic+ABC.Interact.dat'></span>

<h3>Description</h3>

<p>This data set has randomly generated values of the response variable MOE
(Measure Of Effectiveness) which is indexed by the two-level factors A, B and C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ABC.Interact.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 8 observations of 4 variables.</p>


<h3>Source</h3>

<p>Generated by Chris Brien</p>

<hr>
<h2 id='as.data.frame.pstructure'>Coerces a pstructure.object to a data.frame.</h2><span id='topic+as.data.frame.pstructure'></span>

<h3>Description</h3>

<p>Coerces a <code><a href="#topic+pstructure.object">pstructure.object</a></code>, which is of class <code>pstructure</code>, 
to a <code><a href="base.html#topic+data.frame">data.frame</a></code>. One can choose whether or not to include the <code>marginality</code> 
matrix in the data.frame. The <code>aliasing</code> component is excluded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pstructure'
as.data.frame(x, row.names = NULL, optional = FALSE, ..., 
              omit.marginality = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.pstructure_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+pstructure.object">pstructure.object</a></code>, which is of class <code>pstructure</code> and is to be coerced.</p>
</td></tr>
<tr><td><code id="as.data.frame.pstructure_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a <code><a href="base.html#topic+character">character</a></code> vector giving the row names for 
the data frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.pstructure_+3A_optional">optional</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> passed to <code>as.data.frame</code>. If TRUE, 
setting row names and converting column names (to syntactic names: 
see <code>make.names)</code> is optional. Note that all of R's base 
package <code>as.data.frame()</code> methods use <code>optional</code> only for 
column names treatment, basically with the meaning of 
</p>
<p><code>data.frame(*, check.names = !optional)</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.pstructure_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as.data.frame.pstructure_+3A_omit.marginality">omit.marginality</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>, which, if <code>TRUE</code>, 
results in the <code>marginality</code> matrix being omitted from the 
<code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with as many rows as there are non-aliased terms 
in the <code><a href="#topic+pstructure.object">pstructure.object</a></code>. The columns are <code>df</code>, <code>terms</code>, 
<code>sources</code> and, if <code>omit.marginality</code> is <code>FALSE</code>, the columns of 
the generated <code>levels</code> with columns of the <code>marginality</code> matrix 
that is stored in the <code>marginality</code> component of the object.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a data.frame with 4 factors, each with three levels, in standard order
ABCD.lay &lt;- fac.gen(list(A = 3, B = 3, C = 3, D = 3))

## create a pstructure object based on the formula ((A*B)/C)*D
ABCD.struct &lt;- pstructure.formula(~ ((A*B)/C)*D, data =ABCD.lay)

## print the object either using the Method function or the generic function 
ABCS.dat &lt;- as.data.frame.pstructure(ABCD.struct)
as.data.frame(ABCD.struct)
</code></pre>

<hr>
<h2 id='as.numfac'>Convert a factor to a numeric vector</h2><span id='topic+as.numfac'></span>

<h3>Description</h3>

<p>Converts a <code><a href="base.html#topic+factor">factor</a></code> to a numeric <code>vector</code> with approximately the 
numeric values of its <code>levels</code>. Hence, the <code>levels</code> of the 
<code><a href="base.html#topic+factor">factor</a></code> must be numeric values, stored as characters. It uses the method 
described in <code><a href="base.html#topic+factor">factor</a></code>.  Use <code><a href="base.html#topic+as.numeric">as.numeric</a></code> to convert a 
<code><a href="base.html#topic+factor">factor</a></code> to a numeric <code>vector</code> with integers 1, 2, ... corresponding 
to the positions in the list of levels. You can also use <code><a href="#topic+fac.recast">fac.recast</a></code> to 
recode the levels to numeric values. If a <code>numeric</code> is supplied, it is 
left unchanged.</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.numfac(factor)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numfac_+3A_factor">factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>vector</code>. An <code>NA</code> will be stored for any value of the factor whose 
level is not a number.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.numeric">as.numeric</a></code>, <code><a href="#topic+fac.recast">fac.recast</a></code> in package <span class="pkg">dae</span>, <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a factor and convert it to a numeric vector
a &lt;- factor(rep(1:3, 4))
x &lt;- as.numfac(a)
</code></pre>

<hr>
<h2 id='BIBDWheat.dat'>Data for a balanced incomplete block experiment</h2><span id='topic+BIBDWheat.dat'></span>

<h3>Description</h3>

<p>The data set comes from Joshi (1987) and is the data from an experiment to investigate 
six varieties of wheat that employs a balanced incomplete block design (BIBD) with ten blocks, 
each consisting of three plots. For more details see the vignette accessed via <code>vignette("DesignNotes", package="dae")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BIBDWheat.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 30 observations of 4 variables.</p>


<h3>Source</h3>

<p>Joshi, D. D. (1987) <em>Linear Estimation and Design of Experiments</em>. Wiley Eastern, New Delhi.</p>

<hr>
<h2 id='blockboundaryPlot'>This function plots a block boundary on a plot produced by <code><a href="#topic+designPlot">designPlot</a></code>.</h2><span id='topic+blockboundaryPlot'></span>

<h3>Description</h3>

<p>This function plots a block boundary on a plot produced by <code><a href="#topic+designPlot">designPlot</a></code>.
It allows control of the starting unit, through rstart and cstart, 
and the number of rows (nrows) and columns (ncolumns) from the starting unit 
that the blocks to be plotted are to cover.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockboundaryPlot(blockdefinition = NULL, blocksequence = FALSE, 
                  rstart= 0, cstart = 0, nrows, ncolumns, 
                  blocklinecolour = 1, blocklinewidth = 2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockboundaryPlot_+3A_blockdefinition">blockdefinition</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> of block sizes:
</p>

<ul>
<li><p> if there is only one row, then the first element is interpreted as the no. rows in 
each block and blocks with this number of rows are to be repeated  across the rows of 
the design.
</p>
</li>
<li><p> if there is more than one row, then each row of the matrix specifies a block, 
with the sequence of rows in the matrix specifying a corresponding 
sequence of blocks down the rows of the design.</p>
</li></ul>

<p>Similarly, a single value for a column specifies a repetition of blocks of that size 
across the columns of the design, while several column values specifies a 
sequence of blocks across the columns of the size specified.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_blocksequence">blocksequence</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that determines whether block numbers are repetitions 
or sequences of block numbers.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_rstart">rstart</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> speccifying the row after which the plotting 
of block boundaries is to start.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_cstart">cstart</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> speccifying the column after which the plotting 
of block boundaries is to start.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_nrows">nrows</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> the number of rows (nrows), from the starting unit, 
that the blocks to be plotted are to cover.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_ncolumns">ncolumns</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> the number of columns (ncolumns), from the starting unit, 
that the blocks to be plotted are to cover.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_blocklinecolour">blocklinecolour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the colour of the block boundary.
</p>
<p>See <code>Colour specification</code> under the <code><a href="graphics.html#topic+par">par</a></code> function.</p>
</td></tr>
<tr><td><code id="blockboundaryPlot_+3A_blocklinewidth">blocklinewidth</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the width of the block boundary to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no values are returned, but modifications are made to the currently active plot.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+designPlot">designPlot</a></code>, <code><a href="graphics.html#topic+par">par</a></code>, <code>DiGGer</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    SPL.Lines.mat &lt;- matrix(as.numfac(Lines), ncol=16, byrow=T)
    colnames(SPL.Lines.mat) &lt;- 1:16
    rownames(SPL.Lines.mat) &lt;- 1:10
    SPL.Lines.mat &lt;- SPL.Lines.mat[10:1, 1:16]
    designPlot(SPL.Lines.mat, labels=1:10, new=TRUE,
               rtitle="Rows",ctitle="Columns", 
               chardivisor=3, rcellpropn = 1, ccellpropn=1,
               plotcellboundary = TRUE)
    #Plot Mainplot boundaries
    blockboundaryPlot(blockdefinition = cbind(4,16), rstart = 1, 
                      blocklinewidth = 3, blockcolour = "green", 
                      nrows = 9, ncolumns = 16)
    blockboundaryPlot(blockdefinition = cbind(1,4), 
                      blocklinewidth = 3, blockcolour = "green", 
                      nrows = 1, ncolumns = 16)
    blockboundaryPlot(blockdefinition = cbind(1,4), rstart= 9, nrows = 10, ncolumns = 16, 
                      blocklinewidth = 3, blockcolour = "green")
    #Plot all 4 block boundaries            
    blockboundaryPlot(blockdefinition = cbind(8,5,5,4), blocksequence=T, 
                      cstart = 1, rstart= 1, nrows = 9, ncolumns = 15, 
                      blocklinewidth = 3,blockcolour = "blue")
    blockboundaryPlot(blockdefinition = cbind(10,16), blocklinewidth=3, blockcolour="blue", 
                      nrows=10, ncolumns=16)
    #Plot border and internal block boundaries only
    blockboundaryPlot(blockdefinition = cbind(8,14), cstart = 1, rstart= 1, 
                      nrows = 9, ncolumns =  15,
                      blocklinewidth = 3, blockcolour = "blue")
    blockboundaryPlot(blockdefinition = cbind(10,16), 
                      blocklinewidth = 3, blockcolour = "blue", 
                      nrows = 10, ncolumns = 16)
## End(Not run)</code></pre>

<hr>
<h2 id='Cabinet1.des'>A design for one of the growth cabinets in an experiment with 50 lines and 4 harvests</h2><span id='topic+Cabinet1.des'></span>

<h3>Description</h3>

<p>The systematic design for a lattice square for 49 treatments consisting of four 7 x 7 squares. For more details see the vignette <cite>daeDesignNotes.pdf</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Cabinet1.des)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 160 observations of 15 variables.</p>

<hr>
<h2 id='Casuarina.dat'>Data for an experiment with rows and columns from Williams (2002)</h2><span id='topic+Casuarina.dat'></span>

<h3>Description</h3>

<p>Williams (2002, p.144) provides an example of a resolved, Latinized, row-column design with four rectangles (blocks) each of six rows by ten columns. The experiment investigated differences between 60 provenances of a species of Casuarina tree, these provenances coming from 18 countries; the trees were inoculated prior to planting at two different times, time of inoculation being assigned to the four replicates so that each occurred in two replicates. At 30 months, diameter at breast height (Dbh) was measured. For more details see the vignette accessed via <code>vignette("DesignNotes", package="dae")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Casuarina.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 240 observations of 7 variables.</p>


<h3>Source</h3>

<p>Williams, E. R., Matheson, A. C. and Harwood, C. E. (2002) <em>Experimental design and analysis for tree improvement</em>. 2nd edition. CSIRO, Melbourne, Australia.</p>

<hr>
<h2 id='correct.degfree'>Check the degrees of freedom in an object of class projector</h2><span id='topic+correct.degfree'></span>

<h3>Description</h3>

<p>Check the degrees of freedom in an object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct.degfree(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct.degfree_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; whose degrees of freedom are to be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The degrees of freedom of the projector are obtained as its number of nonzero 
eigenvalues. An eigenvalue is regarded as zero if it is less than 
<code>daeTolerance</code>, which is initially set to.Machine$double.eps ^ 0.5 (about 1.5E-08). 
The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>TRUE or FALSE depending on whether the correct degrees of freedom have been
stored in the object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+degfree">degfree</a></code>, <code><a href="#topic+projector">projector</a></code> in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
m &lt;- matrix(rep(0.5,4), nrow=2)

## create a projector based on the matrix m
proj.m &lt;- new("projector", data=m)

## add its degrees of freedom
degfree(proj.m) &lt;- 1
    
## check degrees of freedom are correct
correct.degfree(proj.m)
</code></pre>

<hr>
<h2 id='dae-deprecated'>Deprecated Functions in Package dae</h2><span id='topic+dae-deprecated'></span><span id='topic+Ameasures'></span><span id='topic+blockboundary.plot'></span><span id='topic+design.plot'></span><span id='topic+proj2.decomp'></span><span id='topic+proj2.ops'></span><span id='topic+projs.canon'></span><span id='topic+projs.structure'></span>

<h3>Description</h3>

<p>These functions have been renamed and deprecated in <code>dae</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ameasures(...)
blockboundary.plot(...)
design.plot(...)
proj2.decomp(...)
proj2.ops(...)
projs.canon(...)
projs.structure(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dae-deprecated_+3A_...">...</code></td>
<td>
<p>absorbs arguments passed from the old functions of the style foo.bar().</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Brien</p>

<hr>
<h2 id='daeTips'>The intermittent, randomly-presented, startup tips.</h2><span id='topic+daeTips'></span>

<h3>Description</h3>

<p>The intermittent, randomly-presented, startup tips.</p>


<h3>Startup tips</h3>

<p>Need help? Enter help(package = 'dae') and click on 'User guides, package vignettes and other docs'.
</p>
<p>Need help? The manual is in the doc subdirectory of the package's install directory.
</p>
<p>Find out what has changed in dae: enter news(package = 'dae').
</p>
<p>Need help to produce randomized designs? Enter vignette('DesignNotes', package = 'dae').
</p>
<p>Need help to do the canonical analysis of a design? Enter vignette('DesignNotes', package = 'dae'). 
Use suppressPackageStartupMessages() to eliminate all package startup messages.
</p>
<p>To see all the intermittent, randomly-presented, startup tips enter ?daeTips.
</p>
<p>For versions between CRAN releases (and more) go to <a href="http://chris.brien.name/rpackages">http://chris.brien.name/rpackages</a>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>

<hr>
<h2 id='decomp.relate'>Examines the relationship between the eigenvectors for two decompositions</h2><span id='topic+decomp.relate'></span>

<h3>Description</h3>

<p>Two decompositions produced by <code><a href="#topic+proj2.eigen">proj2.eigen</a></code> are compared 
by computing all pairs of crossproduct sums of eigenvectors from the 
two decompositions. It is most useful when the calls to 
<code><a href="#topic+proj2.eigen">proj2.eigen</a></code> have the same Q1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp.relate(decomp1, decomp2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp.relate_+3A_decomp1">decomp1</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> containing components efficiencies and eigenvectors such as 
is produced by <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>.</p>
</td></tr>
<tr><td><code id="decomp.relate_+3A_decomp2">decomp2</code></td>
<td>
<p>Another <code><a href="base.html#topic+list">list</a></code> containing components efficiencies and eigenvectors 
such as is produced by <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the r1 x r2 <code><a href="base.html#topic+matrix">matrix</a></code> is the sum of crossproducts of a pair of 
eigenvectors, one from each of the two decompositions. A sum is regarded as zero 
if it is less than <code>daeTolerance</code>, which is initially set to 
.Machine$double.eps ^ 0.5 (about 1.5E-08). The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> 
can be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> that is r1 x r2 where r1 and r2 are the numbers of efficiencies 
of <code>decomp1</code> and <code>decomp2</code>, respectively. The <code>rownames</code> 
and <code>columnnames</code> of the <code><a href="base.html#topic+matrix">matrix</a></code> are the values of the 
efficiency factors from <code>decomp1</code> and <code>decomp2</code>, respectively.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain sets of projectors
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

## obtain intra- and inter-block decompositions
decomp.inter &lt;- proj2.eigen(unit.struct$Q[["Block"]], trt.struct$Q[["trt"]])
decomp.intra &lt;- proj2.eigen(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])

## check that intra- and inter-block decompositions are orthogonal
decomp.relate(decomp.intra, decomp.inter) 
</code></pre>

<hr>
<h2 id='degfree'>Degrees of freedom extraction and replacement</h2><span id='topic+degfree'></span><span id='topic+degfree+3C-'></span>

<h3>Description</h3>

<p>Extracts the degrees of freedom from or replaces them in an object 
of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>degfree(object)

degfree(object) &lt;- value</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degfree_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; 
whose degrees of freedom are to be extracted or replaced.</p>
</td></tr>
<tr><td><code id="degfree_+3A_value">value</code></td>
<td>
<p>An integer to which the degrees of freedom are to be set or 
an object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; or &quot;matrix&quot; from which the degrees 
of freedom are to be calulated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no checking of the correctness of the degrees of freedom, 
either already stored or as a supplied integer value. This can be done using 
<code><a href="#topic+correct.degfree">correct.degfree</a></code>.
</p>
<p>When the degrees of freedom of the projector are to be calculated, they are obtained 
as the number of nonzero eigenvalues. An eigenvalue is regarded as zero if it is 
less than <code>daeTolerance</code>, which is initially set to <code>.Machine$double.eps ^ 0.5</code> 
(about 1.5E-08). The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; that consists 
of a square, summetric, idempotent matrix and degrees of freedom (rank) of the matrix.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+correct.degfree">correct.degfree</a></code>, <code><a href="#topic+projector">projector</a></code> in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
m &lt;- matrix(rep(0.5,4), nrow=2)

## coerce to a projector
proj.m &lt;- projector(m)

## extract its degrees of freedom
degfree(proj.m)

## create a projector based on the matrix m
proj.m &lt;- new("projector", data=m)

## add its degrees of freedom and print the projector
degfree(proj.m) &lt;- proj.m
print(proj.m)
</code></pre>

<hr>
<h2 id='designAmeasures'>Calculates the average variance of pairwise differences from the variance matrix 
for predictions</h2><span id='topic+designAmeasures'></span>

<h3>Description</h3>

<p>Calculates the average variance of pairwise differences between,  or of 
elementary contrasts of, predictions using the variance matrix for the 
predictions. The weighted average variance of pairwise differences can be 
computed from a vector of <code>replications</code>, as described by Williams and 
Piepho (2015). It is possible to compute either 
A-optimality measure for different subgroups of the predictions. If groups 
are specified then the A-optimality measures are calculated for the differences 
between predictions within each group and for those between predictions from 
different groups. If groupsizes are specified, but groups are not, the
predictions will be sequentially broken into groups of the size specified by 
the elements of groupsizes. The groups can be named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designAmeasures(Vpred, replications = NULL, groupsizes = NULL, groups = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designAmeasures_+3A_vpred">Vpred</code></td>
<td>
<p>The variance <code><a href="base.html#topic+matrix">matrix</a></code> of the predictions. It can be obtained 
using <code><a href="#topic+mat.Vpredicts">mat.Vpredicts</a></code>.</p>
</td></tr>
<tr><td><code id="designAmeasures_+3A_replications">replications</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code>  vector whose length is equal to the  
number of rows (columns) in <code>Vpred</code> and whose elements are to be 
used to calculate weights for each pair of differences.</p>
</td></tr>
<tr><td><code id="designAmeasures_+3A_groupsizes">groupsizes</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing group sizes. The sum of the 
elements of <code>groupsizes</code> must be less than or equal to the 
order of <code>Vpred</code>. If <code>groupsizes</code> is a named 
<code>vector</code>, the names are used to label the groups. 
If <code>NULL</code>, either <code>groups</code> is used or 
the average for all pairwise differences is obtained.</p>
</td></tr>
<tr><td><code id="designAmeasures_+3A_groups">groups</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which is a <code><a href="base.html#topic+numeric">numeric</a></code>, 
vector with integers that specify the subroup of the predictions 
over whose pairwise differences the variances are 
to be averaged. If there is more than one group, the variances of 
all between and within group pairwise differences are averaged. 
If the elements of <code>groups</code> are named , the names are used to 
label the groups. If <code>groups</code> is <code>NULL</code>, either 
<code>groupsizes</code> is used or the average for all pairwise differences 
is obtained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance matrix of pairwise differences is calculated as 
<code class="reqn">v_{ii} + v_{jj} - 2 v_{ij}</code>, 
where <code class="reqn">v_{ij}</code> is the element from the ith row and jth column of 
<code>Vpred</code>. if <code>replication</code> is not <code>NULL</code> then weights are computed as 
<code class="reqn">r_{i} * r_{j} / \mathrm{mean}(\mathbf{r})</code>, 
where <code class="reqn">\mathbf{r}</code> is the <code>replication</code> vector and <code class="reqn">r_{i}</code> 
and <code class="reqn">r_{j}</code> are elements of <code class="reqn">\mathbf{r}</code>. The <code class="reqn">(i,j)</code> 
element of the variance matrix of pairwise differences is multiplied by the  
<code class="reqn">(i,j)</code>th weight. Then the mean of the variances of the pairwise 
differences is computed for the nominated <code>groups</code>.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> containing the within and between group A-optimality measures.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Smith, A. B., D. G. Butler, C. R. Cavanagh and B. R. Cullis (2015). 
Multi-phase variety trials using both composite and individual replicate 
samples: a model-based design approach. 
<em>Journal of Agricultural Science</em>, <b>153</b>, 1017-1029.
</p>
<p>Williams, E. R., and Piepho, H.-P. (2015). Optimality and contrasts in 
block designs with unequal treatment replication. 
<em>Australian &amp; New Zealand Journal of Statistics</em>, <b>57</b>, 203-209.</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.Vpred">mat.Vpred</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reduced example from Smith et al. (2015) 
## Generate two-phase design
mill.fac &lt;- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
field.lay &lt;- fac.gen(list(Frep = 2, Fplot = 4))
field.lay$Variety &lt;- factor(c("D","E","Y","W","G","D","E","M"), 
                            levels = c("Y","W","G","M","D","E"))
start.design &lt;- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
rownames(start.design) &lt;- NULL

## Set up matrices
n &lt;- nrow(start.design)
W &lt;- model.matrix(~ -1+ Variety, start.design)
ng &lt;- ncol(W)
Gg&lt;- diag(1, ng)
Vu &lt;- with(start.design, fac.vcmat(Mrep, 0.3) + 
                         fac.vcmat(fac.combine(list(Mrep, Mday)), 0.2) + 
                         fac.vcmat(Frep, 0.1) + 
                         fac.vcmat(fac.combine(list(Frep, Fplot)), 0.2))
R &lt;- diag(1, n)
  
## Calculate the variance matrix of the predicted random Variety effects
Vp &lt;- mat.Vpred(W = W, Gg = Gg, Vu = Vu, R = R)
  
## Calculate A-optimality measure
designAmeasures(Vp)
designAmeasures(Vp, groups=list(fldUndup = c(1:4), fldDup = c(5,6)))
grpsizes &lt;- c(4,2)
names(grpsizes) &lt;- c("fldUndup", "fldDup")
designAmeasures(Vp, groupsizes = grpsizes)
designAmeasures(Vp, groupsizes = c(4))
designAmeasures(Vp, groups=list(c(1,4),c(5,6)))

## Calculate the variance matrix of the predicted fixed Variety effects, elminating the grand mean
Vp.reduc &lt;- mat.Vpred(W = W, Gg = 0, Vu = Vu, R = R, 
                      eliminate = projector(matrix(1, nrow = n, ncol = n)/n))
## Calculate A-optimality measure
designAmeasures(Vp.reduc)


</code></pre>

<hr>
<h2 id='designAnatomy'>Given the layout for a design, obtain its anatomy via the canonical analysis 
of its projectors to show the confounding and 
aliasing inherent in the design.</h2><span id='topic+designAnatomy'></span>

<h3>Description</h3>

<p>Computes the canonical efficiency factors for the joint 
decomposition of two or more structures or sets of mutually orthogonally 
projectors (Brien and Bailey, 2009; Brien, 2017; Brien, 2019), orthogonalizing 
projectors in a set to those earlier in the set of projectors with 
which they are partially aliased. The results can be summarized in the 
form of a decomposition table that shows the confounding between sources 
from different sets. For examples of the function's use also see the vignette
accessed via <code>vignette("DesignNotes", package="dae")</code> and for a 
discussion of its use see Brien, Sermarini and Demetro (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designAnatomy(formulae, data, keep.order = TRUE, grandMean = FALSE, 
              orthogonalize = "hybrid", labels = "sources", 
              marginality = NULL, check.marginality = TRUE, 
              which.criteria = c("aefficiency","eefficiency","order"), 
              aliasing.print = FALSE, 
              omit.projectors = c("pcanon", "combined"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designAnatomy_+3A_formulae">formulae</code></td>
<td>
<p>An object of class <code><a href="base.html#topic+list">list</a></code> whose components are of class 
<code><a href="stats.html#topic+formula">formula</a></code>. 
Usually, the terms in a single formula have the same status in the 
allocation of factors in the design. For example, all involve only 
factors that were allocated, or all involve factors that were 
recipients of allocated factors. The names of the components are 
used to identify the 
sources in the <code><a href="#topic+summary.pcanon">summary.pcanon</a></code> object. They will also 
be used to name the <code>terms</code>, <code>sources</code> and <code>marginality</code> 
lists in the <code><a href="#topic+pcanon.object">pcanon.object</a></code>.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> contains the values of the factors and variables 
that occur in <code>formulae</code>.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_keep.order">keep.order</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the terms should keep 
their position in the expanded <code>formula</code> projector, or 
reordered so that main effects precede two-factor 
interactions, which precede three-factor interactions and 
so on.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_grandmean">grandMean</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the projector for the 
grand mean is to be included for each structure.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_orthogonalize">orthogonalize</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector indicating the method for orthogonalizing a
projector to those for terms that occurred previously 
in a single formula. Three options are available:  
<code>hybrid</code>; <code>differencing</code>; <code>eigenmethods</code>.
The <code>hybrid</code> option is the most general and uses the 
relationships between the projection operators for the 
terms in the <code>formula</code> to decide which projectors to 
substract and which to orthogonalize using eigenmethods. 
The <code>differencing</code> option subtracts, from the current 
projector, those previously orthogonalized projectors for 
terms whose factors are a subset of the  current projector's 
factors. The <code>eigemethods</code> option recursively 
orthogonalizes the projects using an eigenanalysis of 
each projector with previously orthogonalized projectors.
If a single value is given, it is used for all formulae.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_labels">labels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating the type of labels to be used in 
labelling the projectors, and which will be used also 
in the output tables, such the tables of the aliasing 
in the structure. The two alternatives are <code>terms</code> and 
<code>sources</code>. Terms have all factors/variables in it 
separated by colons (<code>:</code>). Sources have factors/variables 
in them that represent interactions separated by hashes 
(<code>#</code>); if some factors are nested within others, the 
nesting factors are surrounded by square brackets 
(<code>[</code> and <code>]</code>) and separated by colons (<code>:</code>). 
If some generalized, or combined, factors have no marginal 
terms, the constituent factors are separated by colons 
(<code>:</code>) and if they interact with other factors in 
the source they will be parenthesized.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_marginality">marginality</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that can be used to supply some or all of the 
marginality matrices when it is desired to overwrite calculated 
marginality matrices or when they are not calculated. 
If the <code><a href="base.html#topic+list">list</a></code> is the same length as the 
<code>formulae</code> <code><a href="base.html#topic+list">list</a></code>, they will be associated in 
parallel with the components of <code>formulae</code>, irrespective of 
the naming of the two <code><a href="base.html#topic+list">list</a></code>s. If the number of 
components in <code>marginlaity</code> is less than the number of 
components in <code>formulae</code> then both <code><a href="base.html#topic+list">list</a></code>s 
must be named so that those in the <code>marginality</code> 
<code><a href="base.html#topic+list">list</a></code> can be matched with those in the 
<code>formulae</code> <code><a href="base.html#topic+list">list</a></code>.
</p>
<p>Each component of the <code>marginality</code> <code><a href="base.html#topic+list">list</a></code> 
must be either <code>NULL</code> or a square 
<code><a href="base.html#topic+matrix">matrix</a></code> consisting of zeroes and ones that 
gives the marginalites of the terms in the formula. It must have 
the row and column names set to the terms from the expanded 
<code>formula</code>, including being in the same order as these terms. 
The entry in the ith row and jth column will be one if the 
ith term is marginal to the jth term i.e. the column space of the 
ith term is a subspace of that for the jth term and so the source 
for the jth term is to be made orthogonal to that for the ith term. 
Otherwise, the entries are zero. A row and column should not be 
included for the grand mean even if <code>grandMean</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_check.marginality">check.marginality</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the marginality matrix, 
when it is supplied, is to be checked against that computed 
by <code><a href="#topic+pstructure.formula">pstructure.formula</a></code>. It is ignored when 
<code>orthogonalize</code> is set to <code>eigenmethods</code>.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector nominating the efficiency 
criteria to be included in the summary of aliasing 
between terms within a structure. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>,
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>. 
If <code>none</code>, no summary is printed.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_aliasing.print">aliasing.print</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the aliasing between sources 
is to be printed.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_omit.projectors">omit.projectors</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector of the types of  projectors to 
omit from the returned <code>pcanon</code> object. If 
<code>pcanon</code> is included in the vector then the 
projectors in these objects will be replaced with a 
<code>numeric</code> containing their degrees of freedom. 
If <code>combined</code> is included in the vector 
then the projectors for the combined decomposition will be 
replaced with a <code>numeric</code> containing their degrees of 
freedom. If <code>none</code> is included in the vector then no 
projectors will be omitted.</p>
</td></tr>
<tr><td><code id="designAnatomy_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>terms</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each formula supplied in <code>formulae</code>, the set of projectors is 
obtained using <code><a href="#topic+pstructure">pstructure</a></code>; there is one projector 
for each term in a formula. Then <code><a href="#topic+projs.2canon">projs.2canon</a></code> is used 
to perform an analysis of the canonical relationships between two sets 
of projectors for the first two formulae. If there are further formulae, 
the relationships between its projectors and the already established 
decomposition is obtained using <code><a href="#topic+projs.2canon">projs.2canon</a></code>. The core 
of the analysis is the determination of eigenvalues of the products of 
pairs of projectors using the results of James and Wilkinson (1971). 
However, if the order of balance between two projection matrices is 
10 or more or the James and Wilkinson (1971) methods fails to produce 
an idempotent matrix, equation 5.3 of Payne and Tobias (1992) is used 
to obtain the projection matrices for their joint decompostion.
</p>
<p>The <code>hybrid</code> method is recommended for general use. However, of the 
three methods, <code>eigenmethods</code> is least likely to fail, but it 
does not establish the marginality between the terms. It is often needed 
when there is nonorthogonality between terms, such as when there are 
several linear covariates. It can also be more efficeint in these 
circumstances.
</p>
<p>The process can be computationally expensive, particularly for a large data set 
(500 or more observations) and/or when many terms are to be orthogonalized. 
</p>
<p>If the error <code>Matrix is not idempotent</code> should occur then, especially 
if there are  many terms, one might try using <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> 
to reduce the tolerance used in determining if values are either the same 
or are zero; it may be necessary to lower the tolerance to as low as 0.001. 
Also, setting <code>orthogonalize</code> to <code>eigenmethods</code> is worth a try.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+pcanon.object">pcanon.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. (2017) Multiphase experiments in practice: A look back. 
<em>Australian &amp; New Zealand Journal of Statistics</em>, <b>59</b>, 327-352.
</p>
<p>Brien, C. J. (2019) Multiphase experiments with at least one later 
laboratory phase . II. Northogonal designs. 
<em>Australian &amp; New Zealand Journal of Statistics</em>, <b>61</b>, 
234-268.
</p>
<p>Brien, C. J. and R. A. Bailey (2009). Decomposition tables for 
multitiered experiments. I. A chain of randomizations.  
<em>The Annals of Statistics</em>, <b>36</b>, 4184-4213.
</p>
<p>Brien, C. J., Sermarini, R. A., &amp; Demetrio, C. G. B. (2023). Exposing the 
confounding in experimental designs to understand and evaluate them, and 
formulating linear mixed models for analyzing the data from a designed 
experiment. <em>Biometrical Journal</em>, accepted for publication. 
</p>
<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the residual 
operator and canonical decomposition of nonorthogonal factors in the 
analysis of variance. <em>Biometrika</em>, <b>58</b>, 279-294.
</p>
<p>Payne, R. W. and R. D. Tobias (1992). General balance, combination of 
information and the analysis of covariance. 
<em>Scandinavian Journal of Statistics</em>, <b>19</b>, 3-23.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designRandomize">designRandomize</a></code>, <code><a href="#topic+designLatinSqrSys">designLatinSqrSys</a></code>, <code><a href="#topic+designPlot">designPlot</a></code>, <br />
<code><a href="#topic+pcanon.object">pcanon.object</a></code>, <code><a href="#topic+p2canon.object">p2canon.object</a></code>, 
<code><a href="#topic+summary.pcanon">summary.pcanon</a></code>, <code><a href="#topic+efficiencies.pcanon">efficiencies.pcanon</a></code>, 
<code><a href="#topic+pstructure">pstructure</a></code> , <br />
<code><a href="#topic+projs.2canon">projs.2canon</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code>, 
<code><a href="#topic+proj2.eigen">proj2.eigen</a></code>,  <code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>, 
in package <span class="pkg">dae</span>, <br /> 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain combined decomposition and summarize
unit.trt.canon &lt;- designAnatomy(formulae = list(unit=~ Block/Unit, trt=~ trt),
                                data = PBIBD2.lay)
summary(unit.trt.canon, which.criteria = c("aeff","eeff","order"))
summary(unit.trt.canon, which.criteria = c("aeff","eeff","order"), labels.swap = TRUE)

## Three-phase sensory example from Brien and Payne (1999)
## Not run: 
data(Sensory3Phase.dat)
Eval.Field.Treat.canon &lt;- designAnatomy(formulae = list(
                              eval= ~ ((Occasions/Intervals/Sittings)*Judges)/Positions, 
                              field= ~ (Rows*(Squares/Columns))/Halfplots,
                              treats= ~ Trellis*Method),
                                        data = Sensory3Phase.dat)
summary(Eval.Field.Treat.canon, which.criteria =c("aefficiency", "order"))

## End(Not run)
</code></pre>

<hr>
<h2 id='designBlocksGGPlot'>Adds block boundaries to a plot produced by <code><a href="#topic+designGGPlot">designGGPlot</a></code>.</h2><span id='topic+designBlocksGGPlot'></span>

<h3>Description</h3>

<p>This function adds block boundaries to a plot produced by <code><a href="#topic+designGGPlot">designGGPlot</a></code>.
It allows control of the starting unit, through originrow and origincolumn, 
and the number of rows (nrows) and columns (ncolumns) from the starting unit 
that the blocks to be plotted are to cover.</p>


<h3>Usage</h3>

<pre><code class='language-R'>designBlocksGGPlot(ggplot.obj, blockdefinition = NULL, blocksequence = FALSE, 
                   originrow= 0, origincolumn = 0, nrows, ncolumns, 
                   blocklinecolour = "blue", blocklinesize = 2, 
                   facetstrips.placement = "inside", 
                   printPlot = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designBlocksGGPlot_+3A_ggplot.obj">ggplot.obj</code></td>
<td>
<p>An object produced by <code>ggplot</code>.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_blockdefinition">blockdefinition</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> of block sizes:
</p>

<ul>
<li><p> if there is only one row, then the first element is interpreted as the no. rows in 
each block and blocks with this number of rows are to be repeated  across the rows of 
the design.
</p>
</li>
<li><p> if there is more than one row, then each row of the matrix specifies a block, 
with the sequence of rows in the matrix specifying a corresponding 
sequence of blocks down the rows of the design.</p>
</li></ul>

<p>Similarly, a single value for a column specifies a repetition of blocks of that size 
across the columns of the design, while several column values specifies a 
sequence of blocks across the columns of the size specified.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_blocksequence">blocksequence</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that determines whether block numbers are 
repetitions or sequences of block numbers.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_originrow">originrow</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> speccifying the row after which the plotting 
of block boundaries is to start.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_origincolumn">origincolumn</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> speccifying the column after which the plotting 
of block boundaries is to start.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_nrows">nrows</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> the number of rows (nrows), from the starting unit, 
that the blocks to be plotted are to cover.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_ncolumns">ncolumns</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> the number of columns (ncolumns), from the starting unit, 
that the blocks to be plotted are to cover.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_blocklinecolour">blocklinecolour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the colour of the block boundary.
</p>
<p>See <code>Colour specification</code> under the <code><a href="graphics.html#topic+par">par</a></code> function.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_blocklinesize">blocklinesize</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the width of the block boundary to be plotted.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_facetstrips.placement">facetstrips.placement</code></td>
<td>
<p>A <code>character</code> nominating where the strip is to be placed 
with respect to axes text and titles, either &quot;inside&quot; both text and titles, 
&quot;outside.text&quot; or &quot;outside.title&quot;. This argument is important only when axes 
and strips are on the same side of the plot. When this occurs, the default is 
to place them inside the axis text. <b>Note:</b> This argument must be specified 
only once in the constructon of the plot and after every other aspect of the plot 
has been finalized. In particular, if <code>designBlocksGGPlot</code> is to called  
after <code>designGGPlot</code> to add block boundaries, then <code>facetstrips.placement</code> 
should be specified in the last call to <code>designBlocksGGPlot</code>, not in the  
call to <code>designGGPlot</code>.</p>
</td></tr>
<tr><td><code id="designBlocksGGPlot_+3A_printplot">printPlot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to print the plot after adding the block 
boundaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>ggplot</code>&quot;, formed by adding to the input <code>ggplot.obj</code> and 
which can be plotted using <code>print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Source</h3>

<p>Brien, C.J., Harch, B.D., Correll, R.L., and Bailey, R.A. (2011) Multiphase experiments with at least one later laboratory phase. I. Orthogonal designs. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, 16:422-450.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designGGPlot">designGGPlot</a></code>, <code><a href="graphics.html#topic+par">par</a></code>, <code>DiGGer</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a randomized layout for the split-unit design described by 
## Brien et al. (2011, Section 5)
split.sys &lt;- cbind(fac.gen(list(Months = 4, Athletes = 3, Tests = 3)),
                   fac.gen(list(Intensities = LETTERS[1:3], Surfaces = 3), 
                           times = 4))
split.lay &lt;- designRandomize(allocated = split.sys[c("Intensities", "Surfaces")],
                             recipient = split.sys[c("Months", "Athletes", "Tests")], 
                             nested.recipients = list(Athletes = "Months", 
                                                      Tests = c("Months", "Athletes")),
                             seed = 2598)
## Plot the design
cell.colours &lt;- c("lightblue","lightcoral","lightgoldenrod","lightgreen","lightgrey",
                  "lightpink","lightsalmon","lightcyan","lightyellow","lightseagreen")

split.lay &lt;- within(split.lay, 
                    Treatments &lt;- fac.combine(list(Intensities, Surfaces), 
                                              combine.levels = TRUE))
plt &lt;- designGGPlot(split.lay, labels = "Treatments", 
                    row.factors = "Tests", column.factors = c("Months", "Athletes"),
                    colour.values = cell.colours[1:9], label.size = 6, 
                    blockdefinition = rbind(c(3,1)), blocklinecolour = "darkgreen",
                    printPlot = FALSE)
#Add Month boundaries
designBlocksGGPlot(plt, nrows = 3, ncolumns = 3, blockdefinition = rbind(c(3,3)))



#### A layout for a growth cabinet experiment that allows for edge effects
data(Cabinet1.des)
plt &lt;- designGGPlot(Cabinet1.des, labels = "Combinations", cellalpha = 0.75,
                    title = "Lines and Harvests allocation for Cabinet 1", 
                    printPlot = FALSE)

## Plot Mainplot boundaries
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(4,16), originrow= 1 , 
                          blocklinecolour = "green", nrows = 9, ncolumns = 16, 
                          printPlot = FALSE)
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(1,4), 
                          blocklinecolour = "green", nrows = 1, ncolumns = 16, 
                          printPlot = FALSE)
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(1,4), originrow= 9, 
                          blocklinecolour = "green", nrows = 10, ncolumns = 16, 
                          printPlot = FALSE)
## Plot all 4 block boundaries            
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(8,5,5,4), blocksequence = TRUE, 
                          origincolumn = 1, originrow= 1, 
                          blocklinecolour = "blue", nrows = 9, ncolumns = 15, 
                          printPlot = FALSE)
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(10,16), 
                          blocklinecolour = "blue", nrows = 10, ncolumns = 16, 
                          printPlot = FALSE)
## Plot border and internal block boundaries only
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(8,14), origincolumn = 1, originrow= 1, 
                          blocklinecolour = "blue", nrows = 9, ncolumns = 15, 
                          printPlot = FALSE)
plt &lt;- designBlocksGGPlot(plt, blockdefinition = cbind(10,16), 
                          blocklinecolour = "blue", nrows = 10, ncolumns = 16)
</code></pre>

<hr>
<h2 id='designGGPlot'>Plots labels on two-way grids of coloured cells using <code>ggplot2</code> to represent an experimental design</h2><span id='topic+designGGPlot'></span>

<h3>Description</h3>

<p>Plots the <code>labels</code> in a grid of cells specified by  
<code>row.factors</code> and <code>column.factors</code>. The cells can be coloured by the values of 
the column specified by <code>column.name</code> and can be divided into facets by 
specifying multiple row and or column factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>designGGPlot(design, labels = NULL, label.size = NULL, 
             row.factors = "Rows", column.factors = "Columns", 
             scales.free = "free", facetstrips.switch = NULL, 
             facetstrips.placement = "inside", 
             cellfillcolour.column = NULL, colour.values = NULL, 
             cellalpha = 1, celllinetype = "solid", celllinesize = 0.5, 
             celllinecolour = "black", cellheight = 1, cellwidth = 1,
             reverse.x = FALSE, reverse.y = TRUE, x.axis.position = "top", 
             xlab, ylab, title, labeller = label_both, 
             title.size = 15, axis.text.size = 15, 
             blocksequence = FALSE, blockdefinition = NULL, 
             blocklinecolour = "blue", blocklinesize = 2, 
             printPlot = TRUE, ggplotFuncs = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designGGPlot_+3A_design">design</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing <code>labels</code>, <code>column.factors</code>, 
<code>row.factors</code> and, if specified, <code>colour.column</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_labels">labels</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> containing the labels to be plotted on the grid. 
If <code>labels</code> is <code>NULL</code>, no labels are added.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_label.size">label.size</code></td>
<td>
<p>A <code>numeric</code> giving the size of the labels.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_row.factors">row.factors</code></td>
<td>
<p>A <code>character</code> giving the names of the <code><a href="base.html#topic+factor">factor</a></code>s 
(or <code><a href="base.html#topic+numeric">numeric</a></code>s) in <code>data</code> that index the rows of the 
plot grid used to represent the design. If there is more than one name, 
then <code>facet_grid</code> is used to <code>facet</code> the plot in the <code>y</code> 
direction, based on all but the last name. The <code><a href="base.html#topic+factor">factor</a></code> 
corresponding to the last name will index the rows in each <code>facet</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_column.factors">column.factors</code></td>
<td>
<p>A <code>character</code> giving the names of the <code><a href="base.html#topic+factor">factor</a></code>s 
(or <code><a href="base.html#topic+numeric">numeric</a></code>s) in <code>data</code> that index the columns of the 
plot grid used to represent the design. If there is more than one name, 
then <code>facet_grid</code> is used to <code>facet</code> the plot in the <code>x</code> 
direction, based on all but the last name. The <code><a href="base.html#topic+factor">factor</a></code> 
corresponding to the last name will index the columns in each <code>facet</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_scales.free">scales.free</code></td>
<td>
<p>When plots are facetted, a <code>character</code> specifying whether scales 
are shared across all facets (<code>fixed</code>), or vary across rows 
(<code>free_x</code>), columns (<code>free_y</code>), or both rows and columns 
(the default, <code>free</code>).  
The <code>free_x</code>, <code>free_y</code> and <code>free</code> options may not work when 
the plot grid is indexed using <code><a href="base.html#topic+numeric">numeric</a></code>s.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_facetstrips.switch">facetstrips.switch</code></td>
<td>
<p>When plots are facetted, the strip text are displayed on the 
top and right of the plot by default.  If <code>facetstrips.switch</code> is &quot;x&quot;, 
the top strip text will be switched to the bottom. If &quot;y&quot;, the right-hand 
side labels will be switched to the left. The argument can also be set to 
&quot;both&quot;. The argument <code>facetstrips.placement</code> can be 
used to change the relationship between the <code>strip text</code> and the 
<code>axis.text</code> and the <code>axis.title</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_facetstrips.placement">facetstrips.placement</code></td>
<td>
<p>A <code>character</code> nominating where the strip is to be placed 
with respect to axes text and titles, either &quot;inside&quot; both text and titles, 
&quot;outside.text&quot; or &quot;outside.title&quot;. This argument is important only when axes 
and strips are on the same side of the plot. When this occurs, the default is 
to place them inside the axis text. <b>Note:</b> This argument must be specified 
only once in the constructon of the plot and after every other aspect of the plot 
has been finalized. In particular, if <code><a href="#topic+designBlocksGGPlot">designBlocksGGPlot</a></code> is to called  
after <code>designGGPlot</code> to add block boundaries, then <code>facetstrips.placement</code> 
should be specified in the call to <code><a href="#topic+designBlocksGGPlot">designBlocksGGPlot</a></code>, not in the 
call to <code>designGGPlot</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_reverse.x">reverse.x</code></td>
<td>
<p>A <code>logical</code> which, if true, causes the order of values on the 
x-axis to be reversed, the natural order being to increase from left to right.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_reverse.y">reverse.y</code></td>
<td>
<p>A <code>logical</code> which, if true, causes the order of values on the 
y-axis to be reversed, the natural order being to increase from bottom to top.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_x.axis.position">x.axis.position</code></td>
<td>
<p>A <code>character</code> giving the position of the x-axis; can be <code>top</code> 
or <code>bottom</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_cellfillcolour.column">cellfillcolour.column</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> that is to be used to vary the colour the used to fill a cell.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_colour.values">colour.values</code></td>
<td>
<p>A <code>character</code> giving the name or names of the colours to be used 
in filling the cell. If cellfillcolour.column is not <code>NULL</code> then the 
number of colours sepcified needs to match the number of unique values in 
the cellfillcolour.column.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_cellalpha">cellalpha</code></td>
<td>
<p>A <code>numeric</code> specifying the degree of transparency to be used in cell fill. 
It is a ratio in which the denominator specifies the number of points (or 
lines) that must be overplotted to give a solid cover.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_celllinetype">celllinetype</code></td>
<td>
<p>A <code>numeric</code> or <code>character</code> giving the type of line for the 
cell border. An integer or name: 0 = blank, 1 = solid, 2 = dashed, 
3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash. For more information 
see <code>vignette("ggplot2-specs")</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_celllinesize">celllinesize</code></td>
<td>
<p>A <code>numeric</code> specifying the size of the line in mm.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_celllinecolour">celllinecolour</code></td>
<td>
<p>A <code>character</code> giving the name of the colour to use for the cell 
outline.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_cellheight">cellheight</code></td>
<td>
<p>A <code>numeric</code> specifying the height of a cell.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_cellwidth">cellwidth</code></td>
<td>
<p>A <code>numeric</code> specifying the width of of a cell.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_xlab">xlab</code></td>
<td>
<p><code>Label</code> for the x-axis. By default it is the last name in the
<code>column.factors</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_ylab">ylab</code></td>
<td>
<p><code>Label</code> for the y-axis. By default it is the last name in the
<code>row.factors</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_title">title</code></td>
<td>
<p>Title for plot window. By default it is &quot;Plot of labels&quot;.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_labeller">labeller</code></td>
<td>
<p>A <code>function</code> for specifying the formatting of the strip labels of 
the facet grids used when there is more than one <code>row.factors</code> or 
<code>column.factors</code>. (See <code><a href="ggplot2.html#topic+labellers">labellers</a></code> for <code>ggplot2</code>.)</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_title.size">title.size</code></td>
<td>
<p>A <code>numeric</code> giving the size for all titles: <code>xlab</code>, 
<code>ylab</code> and <code>title</code>.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>A <code>numeric</code> giving the size for tick labels.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_blocksequence">blocksequence</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that determines whether block numbers 
are repetitions or sequences of block numbers.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_blockdefinition">blockdefinition</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> of block sizes:
</p>

<ul>
<li><p> if there is only one row, then the first element is interpreted as 
the no. rows in each block and blocks with this number of rows are to be 
repeated  across the rows of the design.
</p>
</li>
<li><p> if there is more than one row, then each row of the matrix specifies a block, 
with the sequence of rows in the matrix specifying a corresponding 
sequence of blocks down the rows of the design.</p>
</li></ul>

<p>Similarly, a single value for a column specifies a repetition of blocks of that size 
across the columns of the design, while several column values specifies a 
sequence of blocks across the columns of the size specified.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_blocklinecolour">blocklinecolour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the colour of the 
block boundary.
</p>
<p>See also the <code>scale_colour_*</code> functions or <code>Colour specification</code> under the
<code><a href="graphics.html#topic+par">par</a></code> function.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_blocklinesize">blocklinesize</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the width of the block boundary to be
plotted.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_printplot">printPlot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to print the plot produced.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element.
These functions are applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="designGGPlot_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to the <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> call that plots the <code>labels</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>ggplot</code>&quot;, which can be plotted using <code>print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+designBlocksGGPlot">designBlocksGGPlot</a></code>, <code><a href="#topic+fac.combine">fac.combine</a></code> in package <span class="pkg">dae</span>, 
<code><a href="#topic+designPlot">designPlot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Plot a randomized complete block design
Treatments &lt;- factor(rep(1:6, times = 5))
RCBD.lay &lt;- designRandomize(allocated = Treatments,
                            recipient = list(Blocks = 5, Units = 6),
                            nested.recipients = list(Units = "Blocks"),
                            seed = 74111)
designGGPlot(RCBD.lay, labels = "Treatments", label.size = 5, 
             row.factors = "Blocks", column.factors = "Units", 
             blockdefinition = cbind(1,5))
             
## Plot without labels
designGGPlot(RCBD.lay, cellfillcolour.column = "Treatments", 
             row.factors = "Blocks", column.factors = "Units", 
             colour.values = c("lightblue","lightcoral","lightgoldenrod",
                               "lightgreen","lightgrey", "lightpink"), 
             blockdefinition = cbind(1,6))

             
#### Plot a lattice square design
data(LatticeSquare_t49.des)
designGGPlot(LatticeSquare_t49.des, labels = "Lines", label.size = 5, 
             row.factors = c("Intervals", "Runs"), column.factors = "Times", 
             blockdefinition = cbind(7,7))
</code></pre>

<hr>
<h2 id='designLatinSqrSys'>Generate a systematic plan for a Latin Square design</h2><span id='topic+designLatinSqrSys'></span>

<h3>Description</h3>

<p>Generates a systematic plan for a Latin Square design using the method of cycling the integers 1 to the number of treatments. The start of the cycle for each row, or the first column, can be specified as a vector of integers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>designLatinSqrSys(order, start = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designLatinSqrSys_+3A_order">order</code></td>
<td>
<p>The number of treatments.</p>
</td></tr>
<tr><td><code id="designLatinSqrSys_+3A_start">start</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing <code>order</code> unique values between one and <code>order</code>. These are interpreted as the value for the fist column for each row. If <code>NULL</code>, <code>1:order</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  <code><a href="base.html#topic+numeric">numeric</a></code> containing <code>order</code> x <code>order</code> integers between 1 and <code>order</code> such that, when the <code><a href="base.html#topic+numeric">numeric</a></code> is considered as a square matrix of size <code>order</code>, each integer occurs once and only once in each row and column of the matrix.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designRandomize">designRandomize</a></code>, <code><a href="#topic+designPlot">designPlot</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   matrix(designLatinSqrSys(5, start = c(seq(1, 5, 2), seq(2, 5, 2))), nrow=5)
   designLatinSqrSys(3)
</code></pre>

<hr>
<h2 id='designPlot'>A graphical representation of an experimental design using labels stored in a matrix.</h2><span id='topic+designPlot'></span>

<h3>Description</h3>

<p>This function uses labels, usually derived from treatment and blocking factors from 
an experimental design and stored in a matrix, to build a graphical representation of 
the matrix, highlighting the position of certain labels . 
It is a modified version of the function supplied with DiGGer. 
It includes more control over the labelling of the rows and columns 
of the design and allows for more flexible plotting of designs with 
unequal block size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>designPlot(designMatrix, labels = NULL, altlabels = NULL, plotlabels = TRUE, 
           rtitle = NULL, ctitle = NULL, 
           rlabelsreverse = FALSE, clabelsreverse = FALSE, 
           font = 1, chardivisor = 2, rchardivisor = 1, cchardivisor = 1, 
           cellfillcolour = NA, plotcellboundary = TRUE, 
           rcellpropn = 1, ccellpropn = 1, 
           blocksequence = FALSE, blockdefinition = NULL, 
           blocklinecolour = 1, blocklinewidth = 2, 
           rotate = FALSE, new = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designPlot_+3A_designmatrix">designMatrix</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> containing a set of numerics or characters 
being the labels as they have been assigned to the cells of the grid 
represented by the <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_labels">labels</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code> vector giving the 
cells in <code>designMatrix</code> that are to be plotted in this call to 
<code>designPlot</code>. If <code>NULL</code> then all the cells are plotted.
</p>
<p>What is actually plotted for a cell is controlled jointly by <code>labels</code>, 
<code>plotlabels</code>, <code>altlabels</code>, <code>plotcellboundary</code> and 
<code>cellfillcolour</code>. If <code>plotlabels</code> is TRUE and <code>altlabels</code> 
is <code>NULL</code> then <code>labels</code> are plotted in the cells, unless 
<code>labels</code> is <code>NULL</code> when the labels in <code>designMatrix</code> 
are plotted. 
</p>
<p>Whatever is being plotted, <code>altlabels</code> and 
<code>cellfillcolour</code> must have an appropriate number of values.
See <code><a href="graphics.html#topic+text">text</a></code> for more information on specifying the labels.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_altlabels">altlabels</code></td>
<td>
<p>Either a <code><a href="base.html#topic+character">character</a></code> vector containing an alternative set of 
labels for the <code>labels</code> currently being plotted or a single <code><a href="base.html#topic+integer">integer</a></code> 
specifying an alternative symbol to be used in plotting cells when 
<code>plotlabels</code> is <code>TRUE</code>. The length of <code>altlabels</code> must be one or 
the same length as <code>labels</code>, unless <code>labels</code> is <code>NULL</code> in which case 
it must equal the number of unique labels in <code>designMatrix</code>.  
</p>
<p>If <code>altlabels</code> is <code>NULL</code>, the labels specified in <code>labels</code> are 
plotted when <code>plotlabels</code> is <code>TRUE</code>. If <code>labels</code> is also <code>NULL</code>, 
the labels in <code>designMatrix</code> are plotted. 
See <code><a href="graphics.html#topic+text">text</a></code> for more information on specifying the labels.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_plotlabels">plotlabels</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> to indicate whether labels are to be 
plotted in the cells. If TRUE, print all labels or 
the specific labels listed in <code>labels</code>. If FALSE, no labels are 
printed in the cells.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_rtitle">rtitle</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string to use as a title for rows of the plot.
If <code>rtitle</code> is <code>NULL</code> then no title is plotted.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_ctitle">ctitle</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string to use as a title for columns of the plot. 
If <code>ctitle</code> is <code>NULL</code> then no title is plotted.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_rlabelsreverse">rlabelsreverse</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to reverse the row labels.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_clabelsreverse">clabelsreverse</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to reverse the column labels.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_font">font</code></td>
<td>
<p>An <code><a href="base.html#topic+integer">integer</a></code> specifying the font to be used for row and column labelling. 
See <code><a href="graphics.html#topic+par">par</a></code> for further details.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_chardivisor">chardivisor</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> that changes the size of text and symbols in the cells 
by dividing the default size by it.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_rchardivisor">rchardivisor</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> that changes the size of the labels of the rows of the
design by dividing the default size by it.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_cchardivisor">cchardivisor</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> that changes the size of the labels of the columns of the
design by dividing the default size by it.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_cellfillcolour">cellfillcolour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the colour of the fill for 
the cells to be plotted in this call. If there is only one colour 
then all cells being plotted with that colour. If there is more than one
colour then, unless <code>labels</code> is <code>NULL</code>, the number of colours must 
at least equal the number of labels 
and then the fill colours will be matched, one for one from the first colour,
with the labels. If <code>labels</code> is <code>NULL</code> then the number of colours 
must  at least equal the number of unique labels in <code>designMatrix</code>. 
The default, <code>NA</code>, is to leave ther cells unfilled.
</p>
<p>See also <code>Colour specification</code> under the <code><a href="graphics.html#topic+par">par</a></code> function.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_plotcellboundary">plotcellboundary</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicting whether a boundary is to plotted 
around a cell.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_rcellpropn">rcellpropn</code></td>
<td>
<p>a value between 0 and 1 giving the proportion of the standard row size of 
a cell size to be plotted as a cell.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_ccellpropn">ccellpropn</code></td>
<td>
<p>a value between 0 and 1 giving the proportion of the standard column size of 
a cell size to be plotted as a cell.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_blocksequence">blocksequence</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> that determines whether block numbers are repetitions 
or sequences of block numbers.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_blockdefinition">blockdefinition</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> of block sizes:
</p>

<ul>
<li><p> if there is only one row, then the first element is interpreted as the no. rows in 
each block and blocks with this number of rows are to be repeated  across the rows of the design.
</p>
</li>
<li><p> if there is more than one row, then each row of the matrix specifies a block, 
with the sequence of rows in the matrix specifying a corresponding 
sequence of blocks down the rows of the design.</p>
</li></ul>

<p>Similarly, a single value for a column specifies a repetition of blocks of that size 
across the columns of the design, while several column values specifies a 
sequence of blocks across the columns of the size specified.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_blocklinecolour">blocklinecolour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string specifying the colour of the block boundary.
</p>
<p>See also <code>Colour specification</code> under the <code><a href="graphics.html#topic+par">par</a></code> function.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_blocklinewidth">blocklinewidth</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the width of the block boundary to be plotted.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_rotate">rotate</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> which, if <code>TRUE</code>, results in the matrix being rotated 
90 degrees for plotting.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_new">new</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating if a new plot is to be produced or the current 
plot is added to.</p>
</td></tr>
<tr><td><code id="designPlot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code> in plotting the cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no values are returned, but a plot is produced.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Coombes, N. E. (2009). <em>DiGGer design search tool in R</em>. 
<a href="http://nswdpibiom.org/austatgen/software/">http://nswdpibiom.org/austatgen/software/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+blockboundaryPlot">blockboundaryPlot</a></code>, <code><a href="#topic+designPlotlabels">designPlotlabels</a></code>, <code><a href="#topic+designLatinSqrSys">designLatinSqrSys</a></code>, <code><a href="#topic+designRandomize">designRandomize</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code>  
in package <span class="pkg">dae</span>.  <br />
Also, <code><a href="graphics.html#topic+par">par</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>, 
<code>DiGGer</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  designPlot(des.mat, labels=1:4, cellfillcolour="lightblue", new=TRUE, 
             plotcellboundary = TRUE, chardivisor=3, 
             rtitle="Lanes", ctitle="Positions", 
             rcellpropn = 1, ccellpropn=1)
  designPlot(des.mat, labels=5:87, plotlabels=TRUE, cellfillcolour="grey", new=FALSE,
             plotcellboundary = TRUE, chardivisor=3)
  designPlot(des.mat, labels=88:434, plotlabels=TRUE, cellfillcolour="lightgreen", 
             new=FALSE, plotcellboundary = TRUE, chardivisor=3, 
             blocksequence=TRUE, blockdefinition=cbind(4,10,12), 
             blocklinewidth=3, blockcolour="blue")
## End(Not run)</code></pre>

<hr>
<h2 id='designPlotlabels'>Plots labels on a two-way grid using <code>ggplot2</code></h2><span id='topic+designPlotlabels'></span>

<h3>Description</h3>

<p>Plots the <code>labels</code> in a grid specified by  
<code>grid.x</code>and <code>grid.y</code>. The labels can be coloured by the values of 
the column specified by <code>column.name</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>designPlotlabels(data, labels, grid.x = "Columns", grid.y = "Rows", 
                 colour.column=NULL, colour.values=NULL, 
                 reverse.x = FALSE, reverse.y = TRUE, 
                 xlab, ylab, title, printPlot = TRUE, ggplotFuncs = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designPlotlabels_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing <code>labels</code>, <code>grid.x</code>, 
<code>grid.y</code> and, if specified, <code>colour.column</code>.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_labels">labels</code></td>
<td>
<p>A <code>character</code> giving the name of the column in 
<code>data</code> containing the labels to be plotted on the grid.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_grid.x">grid.x</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>data</code> that 
specifies the x-coordinates of the plot grid.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_grid.y">grid.y</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>data</code> that 
specifies the y-coordinates of the plot grid.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_reverse.x">reverse.x</code></td>
<td>
<p>A <code>logical</code> which, if true, causes the order of values on the 
x-axis to be reversed.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_reverse.y">reverse.y</code></td>
<td>
<p>A <code>logical</code> which, if true, causes the order of values on the 
y-axis to be reversed.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_colour.column">colour.column</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>data</code> that 
is to be used to colour the values plotted on the grid.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_colour.values">colour.values</code></td>
<td>
<p>A <code>character</code> giving the name of the column in <code>data</code> that 
is to be used to colour the values plotted on the grid.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_xlab">xlab</code></td>
<td>
<p><code>Label</code> for the x-axis. By default it is the name of the
<code>grid.x</code>.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_ylab">ylab</code></td>
<td>
<p><code>Label</code> for the y-axis. By default it is the name of the
<code>grid.y</code>.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_title">title</code></td>
<td>
<p>Title for plot window. By default it is &quot;Plot of labels&quot;.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_printplot">printPlot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to print the plot.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element.
These functions are applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="designPlotlabels_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to the <code><a href="ggplot2.html#topic+geom_text">geom_text</a></code> call that plots the <code>labels</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>ggplot</code>&quot;, which can be plotted using <code>print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.combine">fac.combine</a></code> in package <span class="pkg">dae</span>, <code><a href="#topic+designPlot">designPlot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Treatments &lt;- factor(rep(1:6, times = 5))
RCBD.lay &lt;- designRandomize(allocated = Treatments,
                            recipient = list(Blocks = 5, Units = 6),
                            nested.recipients = list(Units = "Blocks"),
                            seed = 74111)
designPlotlabels(RCBD.lay, labels = "Treatments", 
                 grid.x = "Units", grid.y = "Blocks",
                 colour.column = "Treatments", size = 5)
</code></pre>

<hr>
<h2 id='designRandomize'>Randomize allocated to recipient factors to produce a layout for an experiment</h2><span id='topic+designRandomize'></span>

<h3>Description</h3>

<p>A systematic design is specified by a set of 
<code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> that have been assigned to a set of 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code>. In textbook designs the 
<code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> are the treatment factors and the 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> are the <code><a href="base.html#topic+factor">factor</a>s</code> 
indexing the units. To obtain a randomized layout for a systematic design 
it is necessary to provide (i) the systematic arrangement of the 
<code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code>, (ii) a <code><a href="base.html#topic+list">list</a></code> of the 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> or a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 
their values, and (iii) the nesting of the 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> for the design being randomized. 
Given this information, the <code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> 
will be randomized to the <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code>, 
taking into account the nesting between the <code>recipient</code> factors 
for the design.
However, <code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> that 
have different values associated with those <code>recipient</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> that are in the <code>except</code> vector will remain 
unchanged from the systematic design.
</p>
<p>Also, if <code>allocated</code> is <code>NULL</code> then a random permutation 
of the <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> is produced 
that is consistent with their nesting as specified by 
<code>nested.recipients</code>.
</p>
<p>For examples of its use also see the vignette accessed via 
<code>vignette("DesignNotes", package="dae")</code> and for a discussion of 
its use see Brien, Sermarini and Demetro (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designRandomize(allocated = NULL, recipient, nested.recipients = NULL, 
                except = NULL, seed = NULL, unit.permutation = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designRandomize_+3A_allocated">allocated</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> or a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
containing the systematically allocated values of the 
<code><a href="base.html#topic+factor">factor</a>(s)</code>. If <code>NULL</code>, a random permutation 
of the <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> is produced 
that is consistent with their nesting as specified by 
<code>nested.recipients</code>.</p>
</td></tr>
<tr><td><code id="designRandomize_+3A_recipient">recipient</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a <code><a href="base.html#topic+list">list</a></code> of 
<code><a href="base.html#topic+factor">factor</a>s</code>, along with their <code>levels</code> that 
specify the set of <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> 
that are allocated levels of the 
<code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code>. 
</p>
<p>If a <code><a href="base.html#topic+list">list</a></code>, the name of each component of the 
<code><a href="base.html#topic+list">list</a></code> is a <code><a href="base.html#topic+factor">factor</a></code> name and the 
component is either (i) a single <code>numeric</code> value that 
is the number of <code>levels</code>, (ii) a numeric <code>vector</code> 
that contains the <code>levels</code> of the <code><a href="base.html#topic+factor">factor</a></code>,  
(iii) or a <code><a href="base.html#topic+character">character</a></code> <code>vector</code> 
that contains the <code>labels</code> of the <code>levels</code> of the 
<code><a href="base.html#topic+factor">factor</a></code>. The values of <code><a href="base.html#topic+factor">factor</a>s</code> 
will be generated in standard order using 
<code><a href="#topic+fac.gen">fac.gen</a></code> and so the values in <code>allocated</code> 
must match this.</p>
</td></tr>
<tr><td><code id="designRandomize_+3A_nested.recipients">nested.recipients</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of the <code>recipient</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> 
that are nested in other <code><a href="base.html#topic+factor">factor</a>s</code> in 
<code>recipient</code>. The name of each component is the 
name of a <code><a href="base.html#topic+factor">factor</a></code> that is nested and the 
component is a character <code>vector</code> containing the 
<code><a href="base.html#topic+factor">factor</a>s</code> within which it is nested. 
The randomization is controlled by <code>nested.recipients</code>: 
nested recipient factors are permuted within those 
factors that nest them. Only the nesting is specified: 
it is assumed that if two factors are not nested then 
they must be crossed.
It is emphasized that the nesting is a property of the 
design that is being employed (it is only partly based 
on the intrinsic or physical crossing and nesting).</p>
</td></tr>
<tr><td><code id="designRandomize_+3A_except">except</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a> vector</code> containing the names of 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> that are to be excepted 
from the permutation; any <code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> 
whose values differ between the levels 
of the <code><a href="base.html#topic+factor">factor</a>s</code> in this vector will not have those 
values randomized.</p>
</td></tr>
<tr><td><code id="designRandomize_+3A_seed">seed</code></td>
<td>
<p>A single <code><a href="base.html#topic+numeric">numeric</a></code> value, interpreted as an integer, 
that specifies the starting value of the random number generator.</p>
</td></tr>
<tr><td><code id="designRandomize_+3A_unit.permutation">unit.permutation</code></td>
<td>
<p>A <code>logical</code> indicating whether to include the 
<code>.Unit</code> and <code>.Permutation</code> columns in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="designRandomize_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Unused at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A systematic design is specified by the 
matching of the supplied <code>allocated</code> and <code>recipient</code> 
<code><a href="base.html#topic+factor">factor</a>s</code>. If <code>recipient</code> is a <code><a href="base.html#topic+list">list</a></code> 
then <code><a href="#topic+fac.gen">fac.gen</a></code> is used to generate a <code><a href="base.html#topic+data.frame">data.frame</a></code> 
with the combinations of the levels of the <code>recipient</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> in standard order. Although, the <code><a href="base.html#topic+data.frame">data.frame</a>s</code> 
are not combined at this stage, the systematic design is 
the combination, by columns, of the values of the <code>allocated</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> with the values of <code>recipient</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> in the <code>recipient</code> <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>
<p>The method of randomization described by Bailey (1981) is used to 
randomize the <code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> to the 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code>. That is, a permutation of the 
<code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> is obtained that respects the 
nesting for the design, but does not permute any of the factors in 
the <code>except</code> vector. A permutation is generated for all 
combinations of the <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code>, except 
that a nested <code><a href="base.html#topic+factor">factor</a></code>, specifed using the 
<code>nested.recipients</code> argument, cannot occur in a combination 
without its nesting <code><a href="base.html#topic+factor">factor</a>(s)</code>. These permutations are 
combined into a single, units permutation that is 
applied to the <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code>. Then the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> containing the permuted <code>recipient</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> and that containng the unpermuted <code>allocated</code> 
<code><a href="base.html#topic+factor">factor</a>s</code> are combined columnwise, as in <code>cbind</code>. To produce the 
randomized layout, the rows of the combined <code><a href="base.html#topic+data.frame">data.frame</a></code> are 
reordered so that its <code>recipient</code> <code><a href="base.html#topic+factor">factor</a>s</code> are in either 
standard order or, if a <code><a href="base.html#topic+data.frame">data.frame</a></code> was suppled to 
<code>recipient</code>, the same order as for the supplied <code><a href="base.html#topic+data.frame">data.frame</a></code>. 
</p>
<p>The <code>.Units</code> and <code>.Permutation</code> <code>vectors</code> enable one to 
swap between this combined, units permutation and the randomized layout. 
The <em>i</em>th value in <code>.Permutation</code> gives the unit to which 
unit <em>i</em> was assigned in the randomization. 
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with the values for the <code>recipient</code> and 
<code>allocated</code> <code><a href="base.html#topic+factor">factor</a>s</code> that specify the layout for the 
experiment and, if <code>unit.permutation</code> is <code>TRUE</code>, the values 
for <code>.Units</code> and <code>.Permutation</code> <code>vectors</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Bailey, R.A. (1981) A unified approach to design of experiments. 
<em>Journal of the Royal Statistical Society, Series A</em>, 
<b>144</b>, 214&ndash;223.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.gen">fac.gen</a></code>, <code><a href="#topic+designLatinSqrSys">designLatinSqrSys</a></code>, <code><a href="#topic+designPlot">designPlot</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a randomized layout for a 4 x 4 Latin square
## (the nested.recipients argument is not needed here as none of the 
## factors are nested)
## Firstly, generate a systematic layout
LS.sys &lt;- cbind(fac.gen(list(row = c("I","II","III","IV"), 
                             col = c(0,2,4,6))),
                treat = factor(designLatinSqrSys(4), label = LETTERS[1:4]))
## obtain randomized layout
LS.lay &lt;- designRandomize(allocated = LS.sys["treat"], 
                          recipient = LS.sys[c("row","col")], 
                          seed = 7197132, unit.permutation = TRUE) 
LS.lay[LS.lay$.Permutation,]

## Generate a randomized layout for a replicated randomized complete 
## block design, with the block factors arranged in standard order for 
## rep then plot and then block
## Firstly, generate a systematic order such that levels of the 
## treatment factor coincide with plot
RCBD.sys &lt;- cbind(fac.gen(list(rep = 2, plot=1:3, block = c("I","II"))),
                  tr = factor(rep(1:3, each=2, times=2)))
## obtain randomized layout
RCBD.lay &lt;- designRandomize(allocated = RCBD.sys["tr"], 
                            recipient = RCBD.sys[c("rep", "block", "plot")], 
                            nested.recipients = list(plot = c("block","rep"), 
                                                     block="rep"), 
                            seed = 9719532, 
                            unit.permutation = TRUE)
#sort into the original standard order
RCBD.perm &lt;- RCBD.lay[RCBD.lay$.Permutation,]
#resort into randomized order
RCBD.lay &lt;- RCBD.perm[order(RCBD.perm$.Units),]

## Generate a layout for a split-unit experiment in which: 
## - the main-unit factor is A with 4 levels arranged in 
##   a randomized complete block design with 2 blocks;
## - the split-unit factor is B with 3 levels.
## Firstly, generate a systematic layout
SPL.sys &lt;- cbind(fac.gen(list(block = 2, main.unit = 4, split.unit = 3)),
                 fac.gen(list(A = 4, B = 3), times = 2))
## obtain randomized layout
SPL.lay &lt;- designRandomize(allocated = SPL.sys[c("A","B")], 
                           recipient = SPL.sys[c("block", "main.unit", "split.unit")], 
                           nested.recipients = list(main.unit = "block", 
                                                    split.unit = c("block", "main.unit")), 
                           seed=155251978)

## Generate a permutation of Seedlings within Species
seed.permute &lt;- designRandomize(recipient = list(Species = 3, Seedlings = 4),
                                nested.recipients = list(Seedlings = "Species"),
                                seed = 75724, except = "Species", 
                                unit.permutation = TRUE)
</code></pre>

<hr>
<h2 id='designTwophaseAnatomies'>Given the layout for a design and three structure formulae, obtain the anatomies for the (i) two-phase, (ii) first-phase, (iii) cross-phase, treatments, and (iv) combined-units designs.</h2><span id='topic+designTwophaseAnatomies'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+designAnatomy">designAnatomy</a></code> to obtain the four species of designs, described by Brien (2019), that are associated with a standard two-phase design: the anatomies for the (i) two-phase, (ii) first-phase, (iii) cross-phase, treatments, and (iv) combined-units designs. (The names of the last two designs in  Brien (2019) were cross-phase and second-phase designs.) For the standard two-phase design, the first-phase design is the design that allocates first-phase treatments to first-phase units. The cross-phase, treatments design allocates the first-phase treatments to the second-phase units and the combined-units design allocates the the first-phase units to the second-phase units. The two-phase design combines the other three species of designs. However, it is not mandatory that the three formula correspond to second-phase units, first-phase units and first-phase treatments, respectively, as is implied above; this is just the correspondence for a standard two-phase design. The essential requirement is that three structure formulae are supplied. For example, if there are both first- and second-phase treatments in a two-phase design, the third formula might involve the treatment factors from both phases. In this case, the default anatomy titles when printing occurs will not be correct, but can be modifed using the <code>titles</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designTwophaseAnatomies(formulae, data, which.designs = "all", 
                        printAnatomies = TRUE, titles,
                        orthogonalize = "hybrid", 
                        marginality = NULL, 
                        which.criteria = c("aefficiency", "eefficiency", 
                                           "order"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designTwophaseAnatomies_+3A_formulae">formulae</code></td>
<td>
<p>An object of class <code><a href="base.html#topic+list">list</a></code> with three components of class 
<code><a href="stats.html#topic+formula">formula</a></code>. 
Usually, the terms in a single formula have the same status in the 
allocation of factors in the design. For example, all involve only 
factors that were allocated, or all involve factors that were 
recipients of allocated factors. The names of the components are 
used to identify the 
sources in the <code><a href="#topic+summary.pcanon">summary.pcanon</a></code> object. They will also 
be used to name the <code>terms</code>, <code>sources</code> and <code>marginality</code> 
lists in the <code><a href="#topic+pcanon.object">pcanon.object</a></code>.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> contains the values of the factors and variables 
that occur in <code>formulae</code>.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_which.designs">which.designs</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector indicating the species of 
designs that are to be obtained. It should include one or more of
<code>two-phase</code>, <code>first-phase</code>, <code>cross-phase</code> and 
<code>combined-units</code>; <code>all</code>, the default, results in all 
four being obtained.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_printanatomies">printAnatomies</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not the anatomies 
are to be printed.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_titles">titles</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector of length four providing titles for 
the printed anatomies. It should have the titles, in the following 
order, for the antomies based on : (i) all three <code>formulae</code>, 
(ii) the second and third <code>formulae</code>, (iii) the first and 
third <code>formulae</code>, and (iv) the first and second <code>formulae</code>. 
If any element of <code>titles</code> is <code>NA</code> then that element is 
replaced with the corresponding default element of <code>titles</code>, 
these being, in order: 
<code>Anatomy for the full two-phase design</code>;  
<code>Anatomy for the first-phase design</code>; 
<code>Anatomy for the cross-phase, treatments design</code>; and  
<code>Anatomy for the combined-units design</code>. The titles generated will 
be saved as an attribute of the returned <code>list</code>.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_orthogonalize">orthogonalize</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector indicating the method for orthogonalizing a
projector to those for terms that occurred previously 
in a single formula. Three options are available:  
<code>hybrid</code>; <code>differencing</code>; <code>eigenmethods</code>.
The <code>hybrid</code> option is the most general and uses the 
relationships between the projection operators for the 
terms in the <code>formula</code> to decide which projectors to 
substract and which to orthogonalize using eigenmethods. 
The <code>differencing</code> option subtracts, from the current 
projector, those previously orthogonalized projectors for 
terms whose factors are a subset of the  current projector's 
factors. The <code>eigemethods</code> option recursively 
orthogonalizes the projects using an eigenanalysis of 
each projector with previously orthogonalized projectors.
If a single value is given, it is used for all formulae.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_marginality">marginality</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> that can be used to supply some or all of the 
marginality matrices when it is desired to overwrite calculated 
marginality matrices or when they are not calculated. 
If the <code><a href="base.html#topic+list">list</a></code> is the same length as the 
<code>formulae</code> <code><a href="base.html#topic+list">list</a></code>, they will be associated in 
parallel with the components of <code>formulae</code>, irrespective of 
the naming of the two <code><a href="base.html#topic+list">list</a></code>s. If the number of 
components in <code>marginlaity</code> is less than the number of 
components in <code>formulae</code> then both <code><a href="base.html#topic+list">list</a></code>s 
must be named so that those in the <code>marginality</code> 
<code><a href="base.html#topic+list">list</a></code> can be matched with those in the 
<code>formulae</code> <code><a href="base.html#topic+list">list</a></code>.
</p>
<p>Each component of the <code>marginality</code> <code><a href="base.html#topic+list">list</a></code> 
must be either <code>NULL</code> or a square 
<code><a href="base.html#topic+matrix">matrix</a></code> consisting of zeroes and ones that 
gives the marginalites of the terms in the formula. It must have 
the row and column names set to the terms from the expanded 
<code>formula</code>, including being in the same order as these terms. 
The entry in the ith row and jth column will be one if the 
ith term is marginal to the jth term i.e. the column space of the 
ith term is a subspace of that for the jth term and so the source 
for the jth term is to be made orthogonal to that for the ith term. 
Otherwise, the entries are zero. A row and column should not be 
included for the grand mean even if <code>grandMean</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector nominating the efficiency 
criteria to be included in the summary of aliasing 
between terms within a structure. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>,
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>. 
If <code>none</code>, no summary is printed.</p>
</td></tr>
<tr><td><code id="designTwophaseAnatomies_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>designAnatomy</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To produce the anatomies, <code><a href="#topic+designAnatomy">designAnatomy</a></code> is called. The 
two-phase anatomy is based on the three <code>formulae</code> supplied in <code>formulae</code>, 
the first-phase anatomy uses the second and third <code>formulae</code>, the cross-phase, 
treatments anatomy derives from the first and third <code>formulae</code> and the combined-units 
anatomy is obtained with the first and second <code>formulae</code>.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> containing the components <code>twophase</code>, <code>first</code>, 
<code>cross</code> and <code>combined</code>.Each contains the <code><a href="#topic+pcanon.object">pcanon.object</a></code> 
for one of the four designs produced by <code>designTwophaseAnatomies</code>, unless it is 
<code>NULL</code> because the design was omitted from the <code>which.designs</code> 
argument. The returned <code>list</code> has an attribute <code>titles</code>, being a 
<code>character</code> vector of length four and containing the titles used in 
printing the anatomies.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. (2017) Multiphase experiments in practice: A look back. 
<em>Australian &amp; New Zealand Journal of Statistics</em>, <b>59</b>, 327-352.
</p>
<p>Brien, C. J. (2019) Multiphase experiments with at least one later 
laboratory phase . II. Northogonal designs. 
<em>Australian &amp; New Zealand Journal of Statistics</em><b>61</b>, 
234-268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+designAnatomy">designAnatomy</a></code>, 
<code><a href="#topic+pcanon.object">pcanon.object</a></code>, <code><a href="#topic+p2canon.object">p2canon.object</a></code>, 
<code><a href="#topic+summary.pcanon">summary.pcanon</a></code>, <code><a href="#topic+efficiencies.pcanon">efficiencies.pcanon</a></code>, <br />
<code><a href="#topic+pstructure">pstructure</a></code> , 
<code><a href="#topic+projs.2canon">projs.2canon</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code>, 
<code><a href="#topic+proj2.eigen">proj2.eigen</a></code>,  <br /> 
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>, in package <span class="pkg">dae</span>,  
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #'## Microarray example from Jarrett &amp; Ruggiero (2008) - see Brien (2019)
  jr.lay &lt;- fac.gen(list(Set = 7, Dye = 2, Array = 3))
  jr.lay &lt;- within(jr.lay, 
                   { 
                     Block &lt;- factor(rep(1:7, each=6))
                     Plant &lt;- factor(rep(c(1,2,3,2,3,1), times=7))
                     Sample &lt;- factor(c(rep(c(2,1,2,2,1,1, 1,2,1,1,2,2), times=3), 
                                        2,1,2,2,1,1))
                     Treat &lt;- factor(c(1,2,4,2,4,1, 2,3,5,3,5,2, 3,4,6,4,6,3, 
                                       4,5,7,5,7,4, 5,6,1,6,1,5, 6,7,2,7,2,6, 
                                       7,1,3,1,3,7),
                                     labels=c("A","B","C","D","E","F","G"))
                   })
  
  jr.anat &lt;- designTwophaseAnatomies(formulae = list(array = ~ (Set:Array)*Dye,
                                                     plot = ~ Block/Plant/Sample,
                                                     trt = ~ Treat),
                                     which.designs = c("first","cross"), 
                                     data = jr.lay)  

## Three-phase sensory example from Brien and Payne (1999)
## Not run: 
data(Sensory3Phase.dat)
Sensory.canon &lt;- designTwophaseAnatomies(formulae = list(
                              eval= ~ ((Occasions/Intervals/Sittings)*Judges)/Positions, 
                              field= ~ (Rows*(Squares/Columns))/Halfplots,
                              treats= ~ Trellis*Method),
                                        data = Sensory3Phase.dat)

## End(Not run)
</code></pre>

<hr>
<h2 id='detect.diff'>Computes the detectable difference for an experiment</h2><span id='topic+detect.diff'></span>

<h3>Description</h3>

<p>Computes the delta that is detectable for specified replication, power, alpha.</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.diff(rm=5, df.num=1, df.denom=10, sigma=1, alpha=0.05, power=0.8, 
            tol = 0.001, print=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect.diff_+3A_rm">rm</code></td>
<td>
<p>The number of observations used in computing a mean.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_df.num">df.num</code></td>
<td>
<p>The degrees of freedom of the numerator of the F for testing
the term involving the means.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_df.denom">df.denom</code></td>
<td>
<p>The degrees of freedom of the denominator of the F for
testing the term involving the means.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_sigma">sigma</code></td>
<td>
<p>The population standard deviation.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to be used.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_power">power</code></td>
<td>
<p>The minimum power to be achieved.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_tol">tol</code></td>
<td>
<p>The maximum difference tolerated between the power required and
the power computed in determining the detectable difference.</p>
</td></tr>
<tr><td><code id="detect.diff_+3A_print">print</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to have or not have a table of power 
calculation details printed out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>numeric</code> value containing the computed detectable difference.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.exp">power.exp</a></code>, <code><a href="#topic+no.reps">no.reps</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute the detectable difference for a randomized complete block design 
## with four treatments given power is 0.8 and alpha is 0.05. 
rm &lt;- 5
detect.diff(rm = rm, df.num = 3, df.denom = 3 * (rm - 1),sigma = sqrt(20))
</code></pre>

<hr>
<h2 id='efficiencies'>Extracts the canonical efficiency factors from a <code><a href="#topic+pcanon.object">pcanon.object</a></code> or a <code><a href="#topic+p2canon.object">p2canon.object</a></code>.</h2><span id='topic+efficiencies'></span><span id='topic+efficiencies.pcanon'></span><span id='topic+efficiencies.p2canon'></span>

<h3>Description</h3>

<p>Produces a <code>list</code> containing the canonical efficiency factors 
for the joint decomposition of two or more sets of projectors 
(Brien and Bailey, 2009) obtained using <code><a href="#topic+designAnatomy">designAnatomy</a></code> or 
<code><a href="#topic+projs.2canon">projs.2canon</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcanon'
efficiencies(object, which = "adjusted", ...)
## S3 method for class 'p2canon'
efficiencies(object, which = "adjusted", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencies_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+pcanon.object">pcanon.object</a></code> or an object of class <code>p2canon</code> produced by <code><a href="#topic+projs.2canon">projs.2canon</a></code>.</p>
</td></tr>
<tr><td><code id="efficiencies_+3A_which">which</code></td>
<td>
<p>A character string, either <code>adjusted</code> or <code>pairwise</code>. For 
<code>adjusted</code>, the canonical efficiency factor are adjusted for other 
projectors from from the same set. For <code>pairwise</code>, they are the unadjusted 
canonical efficiency factors between pairs of projectors consisting of one 
projector from each of two sets.</p>
</td></tr>
<tr><td><code id="efficiencies_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Unused at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a <code>pcanon.object</code>, a <code>list</code> with a component for each component of 
<code>object</code>, except for the last component &ndash; for more information about the components 
see <code><a href="#topic+pcanon.object">pcanon.object</a></code> .
</p>
<p>For a <code>p2canon</code> object, a <code>list</code> with a component for each element of the <code>Q1</code> 
argument from <code><a href="#topic+projs.2canon">projs.2canon</a></code>. Each component is <code>list</code>, each its components 
corresponding to an element of the <code>Q2</code> argument from <code><a href="#topic+projs.2canon">projs.2canon</a></code></p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. and R. A. Bailey (2009). Decomposition tables for 
multitiered experiments. I. A chain of randomizations.  
<em>The Annals of Statistics</em>, <b>36</b>, 4184 - 4213.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designAnatomy">designAnatomy</a></code>, <code><a href="#topic+summary.pcanon">summary.pcanon</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>,  <br /> 
<code><a href="#topic+pstructure">pstructure</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain combined decomposition using designAnatomy and get the efficiencies
unit.trt.canon &lt;- designAnatomy(list(unit=~ Block/Unit, trt=~ trt), data = PBIBD2.lay)
efficiencies.pcanon(unit.trt.canon)

##obtain the projectors for each formula using pstructure
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

##obtain combined decomposition projs.2canon and get the efficiencies
unit.trt.p2canon &lt;- projs.2canon(unit.struct$Q, trt.struct$Q)
efficiencies.p2canon(unit.trt.p2canon)
</code></pre>

<hr>
<h2 id='efficiency.criteria'>Computes efficiency criteria from a set of efficiency factors</h2><span id='topic+efficiency.criteria'></span>

<h3>Description</h3>

<p>Computes efficiency criteria from a set of efficiency factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency.criteria(efficiencies)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiency.criteria_+3A_efficiencies">efficiencies</code></td>
<td>
<p>A <code>numeric</code> containing a set of efficiency factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aefficiency</code> criterion is the harmonic mean of the nonzero 
efficiency factors. The <code>mefficiency</code> criterion is the  mean of 
the nonzero efficiency factors. The <code>eefficiency</code> criterion is the 
minimum of the nonzero efficiency factors. The <code>sefficiency</code> 
criterion is the variance of the nonzero efficiency factors. The 
<code>xefficiency</code> is the maximum of the efficiency factors. The 
<code>order</code> is the order of balance and is the number of unique 
nonzero efficiency factors. The <code>dforthog</code> is the number of 
efficiency factors that are equal to one.</p>


<h3>Value</h3>

<p>A <code>list</code> whose components are <code>aefficiency</code>, 
<code>mefficiency</code>, <code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

## obtain sets of projectors
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

## save intrablock efficiencies
eff.inter &lt;- proj2.efficiency(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])

## calculate efficiency criteria
efficiency.criteria(eff.inter)
</code></pre>

<hr>
<h2 id='elements'>Extract the elements of an array specified by the subscripts</h2><span id='topic+elements'></span>

<h3>Description</h3>

<p>Elements of the <code>array</code> <code>x</code> corresponding to the rows of the two dimensional 
object <code>subscripts</code> are extracted. The number of columns of <code>subscripts</code> 
corresponds to the number of dimensions of <code>x</code>. 
The effect of supplying less columns in <code>subscripts</code> than the 
number of dimensions in <code>x</code> is the same as for <code>"["</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>elements(x, subscripts)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elements_+3A_x">x</code></td>
<td>
<p>An <code>array</code> with at least two dimensions whose elements are to be extracted.</p>
</td></tr>
<tr><td><code id="elements_+3A_subscripts">subscripts</code></td>
<td>
<p>A two dimensional object interpreted as elements by dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the extracted elements and whose length equals the 
number of rows in the <code>subscripts</code> object.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>Extract</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Form a table of the means for all combinations of Row and Line.
## Then obtain the values corresponding to the combinations in the data frame x,
## excluding Row 3.
x &lt;- fac.gen(list(Row = 2, Line = 4), each =2)
x$y &lt;- rnorm(16)
RowLine.tab &lt;- tapply(x$y, list(x$Row, x$Line), mean)
xs &lt;- elements(RowLine.tab, subscripts=x[x$"Line" != 3, c("Row", "Line")])
</code></pre>

<hr>
<h2 id='Exp249.munit.des'>Systematic, main-unit design for an experiment to be run in a greenhouse</h2><span id='topic+Exp249.munit.des'></span>

<h3>Description</h3>

<p>In this main-unit design, there are 24 lanes by 11 Positions, the lanes being blocked into 6 Zones of 4 lanes. The design for the main units is for assigning 75 wheat lines, of which 73 are Nested Association Mapping (NAM) wheat lines and the other two are two check lines, Scout and Gladius. A row and column design was generated with <code>DiGGer</code> (Coombes, 2009). For more details see the vignette accessed via <code>vignette("DesignNotes", package="dae")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Exp249.munit.des)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 264 observations of 3 variables.</p>


<h3>Source</h3>

<p>Coombes, N. E. (2009) <code>Digger</code><em>: design search tool in R</em>. URL: <a href="http://nswdpibiom.org/austatgen/software/">http://nswdpibiom.org/austatgen/software/</a>,
(accessed June 3, 2015).</p>

<hr>
<h2 id='extab'>Expands the values in table to a vector</h2><span id='topic+extab'></span>

<h3>Description</h3>

<p>Expands the values in <code>table</code> to a <code>vector</code>
according to the <code>index.factors</code> that are considered to index 
the <code>table</code>, either in standard or Yates order.  The order 
of the values in the <code>vector</code> is determined by the order of 
the values of the <code>index.factors</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extab(table, index.factors, order="standard")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extab_+3A_table">table</code></td>
<td>
<p>A numeric <code>vector</code> containing the values to be expanded. Its length
must equal the product of the number of used levels for the <code><a href="base.html#topic+factor">factor</a>s</code> in 
<code>index.factors</code> and the values in it correspond to all levels combinations 
of these <code><a href="base.html#topic+factor">factor</a>s</code>. That is, the values of the <code>index.factors</code> are 
irrelevant to <code>table</code>.</p>
</td></tr>
<tr><td><code id="extab_+3A_index.factors">index.factors</code></td>
<td>
<p>A list of <code><a href="base.html#topic+factor">factor</a>s</code> that index the <code>table</code>. 
All the <code><a href="base.html#topic+factor">factor</a>s</code> must be the same length.</p>
</td></tr>
<tr><td><code id="extab_+3A_order">order</code></td>
<td>
<p>The order in which the levels combinations of the <code>index.factors</code> 
are to be considered as numbered in indexing <code>table</code>; <code>standard</code> numbers them as 
if they are arranged in standard order, that is with the first factor moving 
slowest and the last factor moving fastest; <code>yates</code> numbers them as if they are 
arranged in Yates order, that is with the first factor moving fastest and 
last factor moving slowest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length equal to the <code><a href="base.html#topic+factor">factor</a>s</code> in 
<code>index.factor</code> whose values are  taken from <code>table</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a small completely randomized design with the two-level 
## factors A and B 
n &lt;- 12
CRD.unit &lt;- list(Unit = n)
CRD.treat &lt;- fac.gen(list(A = 2, B = 2), each = 3)
CRD.lay &lt;- designRandomize(allocated = CRD.treat, recipient = CRD.unit, 
                           seed = 956)

## set up a 2 x 2 table of A x B effects	
AB.tab &lt;- c(12, -12, -12, 12)

## add a unit-length vector of expanded effects to CRD.lay
attach(CRD.lay)
CRD.lay$AB.effects &lt;- extab(table=AB.tab, index.factors=list(A, B))
</code></pre>

<hr>
<h2 id='fac.ar1mat'>forms the ar1 correlation matrix for a (generalized) factor</h2><span id='topic+fac.ar1mat'></span>

<h3>Description</h3>

<p>Form the correlation matrix for a (generalized) factor where the 
correlation between the levels follows an autocorrelation of order 1 (ar1) 
pattern.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.ar1mat(factor, rho)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.ar1mat_+3A_factor">factor</code></td>
<td>
<p>The (generalized) <code><a href="base.html#topic+factor">factor</a></code> for which the correlation between 
its levels displays an ar1 pattern.</p>
</td></tr>
<tr><td><code id="fac.ar1mat_+3A_rho">rho</code></td>
<td>
<p>The correlation parameter for the ar1 process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is:
a) form an <code>n x n</code> matrix of all pairwise differences in the numeric values 
corresponding to the observed levels of the factor by taking the 
difference between the following two n x n matrices are equal: 1) each row 
contains the numeric values corresponding to the observed levels of the 
factor, and 2) each column contains the numeric values corresponding to 
the observed levels of the factor, 
b) replace each element of the pairwise difference matrix with rho raised to 
the absolute value of the difference.
</p>


<h3>Value</h3>

<p>An n x n <code><a href="base.html#topic+matrix">matrix</a></code>, where n is the length of the 
<code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.vcmat">fac.vcmat</a></code>, <code><a href="#topic+fac.meanop">fac.meanop</a></code>, 
<code><a href="#topic+fac.sumop">fac.sumop</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a two-level factor and a three-level factor, both of length 12
A &lt;- factor(rep(1:2, each=6))
B &lt;- factor(rep(1:3, each=2, times=2))

## create a 12 x 12 ar1 matrix corrresponding to B
ar1.B &lt;- fac.ar1mat(B, 0.6)
</code></pre>

<hr>
<h2 id='fac.combine'>Combines several factors into one</h2><span id='topic+fac.combine'></span>

<h3>Description</h3>

<p>Combines several <code><a href="base.html#topic+factor">factor</a>s</code> into one whose <code>levels</code> are the 
combinations of the used <code>levels</code> of the individual <code><a href="base.html#topic+factor">factor</a>s</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.combine(factors, order="standard", combine.levels=FALSE, sep=",", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.combine_+3A_factors">factors</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+factor">factor</a>s</code> all of the same length.</p>
</td></tr>
<tr><td><code id="fac.combine_+3A_order">order</code></td>
<td>
<p>Either <code>standard</code> or <code>yates</code>. The order in which the 
<code>levels</code> combinations of the <code><a href="base.html#topic+factor">factor</a>s</code> are to be considered as 
numbered when forming the <code>levels</code> of the combined <code><a href="base.html#topic+factor">factor</a></code>; 
<code>standard</code> numbers them as if they are arranged in 
standard order, that is with the levels of the first factor moving slowest and 
those of the last factor moving fastest; <code>yates</code> numbers them as if they 
are arranged in Yates order, that is with the levels of the first factor moving 
fastest and those of the last factor moving slowest.</p>
</td></tr>
<tr><td><code id="fac.combine_+3A_combine.levels">combine.levels</code></td>
<td>
<p>A <code>logical</code> specifying whether the <code>levels</code> 
labels of the new <code><a href="base.html#topic+factor">factor</a></code> are to be combined from those of the 
<code><a href="base.html#topic+factor">factor</a>s</code> being combined. The default is to 
use the integers from 1 to the product of the numbers of combinations 
of used <code>levels</code> of the individual <code><a href="base.html#topic+factor">factor</a>s</code>, numbering the levels 
according to <code>order</code>.</p>
</td></tr>
<tr><td><code id="fac.combine_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> string to separate the levels when 
<code>combine.levels = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fac.combine_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating 
the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code> whose <code>levels</code> are formed form the observed 
combinations of the <code>levels</code> of the individual <code><a href="base.html#topic+factor">factor</a>s</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.uncombine">fac.uncombine</a></code>, <code><a href="#topic+fac.split">fac.split</a></code>, <code><a href="#topic+fac.divide">fac.divide</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up two factors
A &lt;- factor(rep(1:2, each=6))
B &lt;- factor(rep(1:3, each=2, times=2))

## obtain six-level factor corresponding to the combinations of A and B
AB &lt;- fac.combine(list(A,B))
</code></pre>

<hr>
<h2 id='fac.divide'>Divides a factor into several separate factors</h2><span id='topic+fac.divide'></span>

<h3>Description</h3>

<p>Takes a <code><a href="base.html#topic+factor">factor</a></code> and divides it into several separate 
<code><a href="base.html#topic+factor">factor</a>s</code> as if the <code>levels</code> in the original <code>combined.factor</code> are numbered from one to its number of levels and correspond 
to the numbering of the <code>levels</code> combinations of the new 
<code><a href="base.html#topic+factor">factor</a>s</code> when these are arranged in standard or Yates order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.divide(combined.factor, factor.names, order="standard")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.divide_+3A_combined.factor">combined.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> that is to be divided into the individual 
<code><a href="base.html#topic+factor">factor</a>s</code> listed in <code>factor.names</code>.</p>
</td></tr>
<tr><td><code id="fac.divide_+3A_factor.names">factor.names</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+factor">factor</a>s</code> to be formed. The names in 
the <code><a href="base.html#topic+list">list</a></code> are the names of the <code><a href="base.html#topic+factor">factor</a>s</code> and the component of 
a name is either a) a single <code>numeric</code> value that is the number of 
<code>levels</code>, b) a numeric <code>vector</code> that contains the <code>levels</code> 
of the <code><a href="base.html#topic+factor">factor</a></code>, or c) a character <code>vector</code> that contains the 
<code>labels</code> of the <code>levels</code> of the <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="fac.divide_+3A_order">order</code></td>
<td>
<p>Either <code>standard</code> or <code>yates</code>. The order in which the 
<code>levels</code> combinations of the 
<code><a href="base.html#topic+factor">factor</a>s</code> in <code>factor.names</code> are to be considered as numbered; 
<code>standard</code> numbers them as if they are arranged in standard order, 
that is with the first factor moving slowest and the last factor 
moving fastest; <code>yates</code> numbers them 
as if they are arranged in Yates order, that is with the first factor 
moving fastest and last factor moving slowest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns consist of the <code><a href="base.html#topic+factor">factor</a>s</code> listed in 
<code>factor.names</code> and whose values have been computed from the combined 
<code><a href="base.html#topic+factor">factor</a></code>. All the <code><a href="base.html#topic+factor">factor</a>s</code> will be of the same length.</p>


<h3>Note</h3>

<p>A single <code><a href="base.html#topic+factor">factor</a></code> name may be supplied in the <code><a href="base.html#topic+list">list</a></code> in which case 
a <code><a href="base.html#topic+data.frame">data.frame</a></code> is produced that contains the single <code><a href="base.html#topic+factor">factor</a></code> 
computed from the numeric <code>vector</code>. This may be useful when calling 
this <code>function</code> from others.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.split">fac.split</a></code>, <code><a href="#topic+fac.uncombine">fac.uncombine</a></code>, <code><a href="#topic+fac.combine">fac.combine</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a small completely randomized design for 6 treatments 
n &lt;- 12
CRD.unit &lt;- list(Unit = n)
treat &lt;- factor(rep(1:4, each = 3))
CRD.lay &lt;- designRandomize(allocated = treat, recipient = CRD.unit, seed=956)

## divide the treatments into two two-level factors A and B
CRD.facs &lt;- fac.divide(CRD.lay$treat, factor.names = list(A = 2, B = 2))
</code></pre>

<hr>
<h2 id='fac.gen'>Generate all combinations of several factors and, optionally, replicate them</h2><span id='topic+fac.gen'></span>

<h3>Description</h3>

<p>Generate all combinations of several factors and, optionally, replicate them.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.gen(generate, each=1, times=1, order="standard")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.gen_+3A_generate">generate</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of named objects and numbers that specify the 
<code><a href="base.html#topic+factor">factor</a>s</code> whose <code>levels</code> are to be generated and 
the pattern in these <code>levels</code>.If a component of the 
<code><a href="base.html#topic+list">list</a></code> is named, then the component 
should be either a) a single <code>numeric</code> value that is the 
number of <code>levels</code>, b) a numeric <code>vector</code> that contains the 
<code>levels</code> of the <code><a href="base.html#topic+factor">factor</a></code>, or c) a character <code>vector</code> that 
contains the <code>labels</code> of the <code>levels</code> of the <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="fac.gen_+3A_each">each</code></td>
<td>
<p>The number of times to replicate consecutively the elements of the 
<code>levels</code> generated according to pattern specified by the 
<code>generate</code> argument.</p>
</td></tr>
<tr><td><code id="fac.gen_+3A_times">times</code></td>
<td>
<p>The number of times to repeat the whole generated pattern of 
<code>levels</code> generated according to pattern specified by the 
<code>generate</code> argument.</p>
</td></tr>
<tr><td><code id="fac.gen_+3A_order">order</code></td>
<td>
<p>Either <code>standard</code> or <code>yates</code>. The order in which the 
speed of cycling through the <code>levels</code> is to move;
combinations of the <code><a href="base.html#topic+factor">factor</a>s</code> are to be considered as numbered; 
<code>standard</code> cycles through the levels of the first 
factor slowest and the last factor moving fastest; 
<code>yates</code> cycles through the levels of the first factor 
fastest and last factor moving slowest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>levels</code> of each <code><a href="base.html#topic+factor">factor</a></code> are generated in a hierarchical 
pattern, such as <code>standard</code> <code>order</code>, where the <code>levels</code> of one 
<code><a href="base.html#topic+factor">factor</a></code> are held constant while those of the adjacent <code><a href="base.html#topic+factor">factor</a></code> 
are cycled through the complete set once. If a number is supplied instead of a name, 
the pattern is generated as if a <code><a href="base.html#topic+factor">factor</a></code> with that number of <code>levels</code> 
had been supplied in the same position as the number. However, no <code>levels</code> are 
stored for this unamed <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> of <code><a href="base.html#topic+factor">factor</a>s</code> whose generated <code>levels</code> 
are those supplied in the <code>generate</code> list. The number of rows in the 
<code><a href="base.html#topic+data.frame">data.frame</a></code> will equal the product of the numbers of levels of the 
supplied <code><a href="base.html#topic+factor">factor</a>s</code> and the values of the <code>each</code> and <code>times</code> 
arguments.</p>


<h3>Warning</h3>

<p>Avoid using factor names F and T as these might be confused
with FALSE and TRUE.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.genfactors">fac.genfactors</a></code> , <code><a href="#topic+fac.combine">fac.combine</a></code> in package <span class="pkg">dae</span></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a 2^3 factorial experiment with levels - and +, and 
## in Yates order
mp &lt;- c("-", "+")
fnames &lt;- list(Catal = mp, Temp = mp, Press = mp, Conc = mp)
Fac4Proc.Treats &lt;- fac.gen(generate = fnames, order="yates")

## Generate the factors A, B and D. The basic pattern has 4 repetitions
## of the levels of D for each A and B combination and 3 repetitions of 
## the pattern of the B and D combinations for each level of A. This basic 
## pattern has each combination repeated twice, and the whole of this 
## is repeated twice. It generates 864 A, B and D combinations.
gen &lt;- list(A = 3, 3, B = c(0,100,200), 4, D = c("0","1"))
fac.gen(gen, times=2, each=2)
</code></pre>

<hr>
<h2 id='fac.genfactors'>Generate all combinations of the levels of the supplied factors, without replication</h2><span id='topic+fac.genfactors'></span>

<h3>Description</h3>

<p>Generate all combinations of the levels of the supplied <code>factors</code>, without replication. 
This function extracts the <code>levels</code> from the supplied <code>factors</code> and uses them to 
generate the new factors. On the other hand, the levels must supplied in the <code>generate</code> 
argument of the function <code><a href="#topic+fac.gen">fac.gen</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.genfactors(factors, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.genfactors_+3A_factors">factors</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+factor">factor</a>s</code>, or an object of <code><a href="base.html#topic+factor">factor</a>s</code> 
that is coercible to a <code><a href="base.html#topic+list">list</a></code>.</p>
</td></tr>
<tr><td><code id="fac.genfactors_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="#topic+fac.gen">fac.gen</a></code> in creating 
the <code><a href="base.html#topic+data.frame">data.frame</a></code> of new <code><a href="base.html#topic+factor">factor</a>s</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>levels</code> of each <code><a href="base.html#topic+factor">factor</a></code> are generated in standard order,
unless <code>order</code> is supplied to <code><a href="#topic+fac.gen">fac.gen</a></code> via the &lsquo;...&rsquo; argument. 
The <code>levels</code> of the new <code><a href="base.html#topic+factor">factor</a>s</code> will be in the same order as 
in the supplied <code>factors</code>.</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns correspond to <code><a href="base.html#topic+factor">factor</a>s</code> in the 
<code>factors</code> <code><a href="base.html#topic+list">list</a></code>. The values in a column are the generated <code>levels</code> 
of the <code><a href="base.html#topic+factor">factor</a></code>. The number of rows in the <code><a href="base.html#topic+data.frame">data.frame</a></code> will equal 
the product of the numbers of levels of the supplied <code><a href="base.html#topic+factor">factor</a>s</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.gen">fac.gen</a></code> in package <span class="pkg">dae</span></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a treatments key for the Variety and Nitrogen treatments factors in Oats.dat
data(Oats.dat)
trts.key &lt;- fac.genfactors(factors = Oats.dat[c("Variety", "Nitrogen")])
trts.key$Treatment &lt;- factor(1:nrow(trts.key))
</code></pre>

<hr>
<h2 id='fac.match'>Match, for each combination of a set of columns in <code>x</code>, the row that has the same combination in <code>table</code></h2><span id='topic+fac.match'></span>

<h3>Description</h3>

<p>Match, for each combination of a set of columns in <code>x</code>, 
the rows that has the same combination in <code>table</code>. 
The argument <code>multiples.allow</code> controls what happens when there are 
multple matches in <code>table</code> of a combination in <code>x</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.match(x, table, col.names, nomatch = NA_integer_, multiples.allow = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.match_+3A_x">x</code></td>
<td>
<p>an R object, normally a <code>data.frame</code>, possibly a 
<code>matrix</code>.</p>
</td></tr>
<tr><td><code id="fac.match_+3A_table">table</code></td>
<td>
<p>an R object, normally a <code>data.frame</code>, possibly a 
<code>matrix</code>.</p>
</td></tr>
<tr><td><code id="fac.match_+3A_col.names">col.names</code></td>
<td>
<p>A <code>character vector</code> giving the columns in <code>x</code> 
and <code>table</code> that are to be matched.</p>
</td></tr>
<tr><td><code id="fac.match_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned in the case when no match is found. 
Note that it is coerced to integer.</p>
</td></tr>
<tr><td><code id="fac.match_+3A_multiples.allow">multiples.allow</code></td>
<td>
<p>A <code>logical</code> indicating whether multiple matches of a 
combination in <code>x</code> to those in <code>table</code>  is allowed. 
If <code>multiples.allow</code> is <code>FALSE</code>, an error is generated. 
If <code>multiples.allow</code> is <code>TRUE</code>, the first occuence in 
<code>table</code> is matched. This function can be viewed as a 
generalization to multiple vectors of the <code><a href="base.html#topic+match">match</a></code> 
function that applies to single vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+vector">vector</a></code> of length equal to <code>x</code> that gives the 
rows in <code>table</code> that match the combinations of 
<code>col.names</code> in <code>x</code>. The order of the rows is the same as 
the order of the combintions in <code>x</code>. The value returned if a combination is
unmatched is specified in the <code>nomatch</code> argument.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#A single unmatched combination
kdata &lt;- data.frame(Expt="D197-5", 
                    Row=8, 
                    Column=20, stringsAsFactors=FALSE)
index &lt;- fac.match(kdata, D197.dat, c("Expt", "Row", "Column"))

# A matched and an unmatched combination
kdata &lt;- data.frame(Expt=c("D197-5", "D197-4"), 
                    Row=c(8, 10), 
                    Column=c(20, 8), stringsAsFactors=FALSE)
index &lt;- fac.match(kdata, D197.dat, c("Expt", "Row", "Column"))

## End(Not run)</code></pre>

<hr>
<h2 id='fac.meanop'>computes the projection matrix that produces means</h2><span id='topic+fac.meanop'></span>

<h3>Description</h3>

<p>Computes the symmetric projection matrix that produces the means 
corresponding to a (generalized) <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.meanop(factor)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.meanop_+3A_factor">factor</code></td>
<td>
<p>The (generalized) <code><a href="base.html#topic+factor">factor</a></code> whose means the projection matrix
computes from an observation-length vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design matrix <b>X</b> for a (generalized) <code><a href="base.html#topic+factor">factor</a></code> is formed with a 
column for each <code>level</code> of the (generalized) <code><a href="base.html#topic+factor">factor</a></code>, this column 
being its indicator variable. The projection matrix is formed as 
<code>X %*% (1/diag(r) %*% t(X)</code>, where <code>r</code> is the <code>vector</code> of 
<code>levels</code> replications.
</p>
<p>A generalized <code><a href="base.html#topic+factor">factor</a></code> is a <code><a href="base.html#topic+factor">factor</a></code> formed from the 
combinations of the <code>levels</code> of several original <code><a href="base.html#topic+factor">factor</a>s</code>. 
Generalized <code><a href="base.html#topic+factor">factor</a>s</code> can be formed using <code><a href="#topic+fac.combine">fac.combine</a></code>.</p>


<h3>Value</h3>

<p>A <code><a href="#topic+projector">projector</a></code> containing the symmetric, projection matrix 
and its degrees of freedom.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.combine">fac.combine</a></code>, <code><a href="#topic+projector">projector</a></code>, <code><a href="#topic+degfree">degfree</a></code>, 
<code><a href="#topic+correct.degfree">correct.degfree</a></code>, <code><a href="#topic+fac.sumop">fac.sumop</a></code> in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a two-level factor and a three-level factor, both of length 12
A &lt;- factor(rep(1:2, each=6))
B &lt;- factor(rep(1:3, each=2, times=2))

## create a generalized factor whose levels are the combinations of A and B
AB &lt;- fac.combine(list(A,B))

## obtain the operator that computes the AB means from a vector of length 12
M.AB &lt;- fac.meanop(AB)
</code></pre>

<hr>
<h2 id='fac.multinested'>Creates several factors, one for each level of nesting.fac and each of whose values are either generated within those of a level of nesting.fac or using the values of nested.fac within a levels of nesting.fac.</h2><span id='topic+fac.multinested'></span>

<h3>Description</h3>

<p>Creates several <code><a href="base.html#topic+factor">factor</a></code>s, one for each level of <code>nesting.fac</code> and each of whose values are either (i) generated within those of the level of <code>nesting.fac</code> or (ii) using the values of <code>nested.fac</code> within the levels of the <code>nesting.fac</code>. For (i), all elements having the same level of <code>nesting.fac</code> are numbered from 1 to the number of different elements having that level. For (ii), the values of <code>nested.fac</code> for a level of <code>nesting.fac</code> are copied. In both cases, for the values of <code>nested.fac</code> not equal to the level of the values of <code>nested.fac</code> for which a nested <code><a href="base.html#topic+factor">factor</a></code> is being created, the levels are set to <code>outlevel</code> and labelled using <code>outlabel</code>. A <code><a href="base.html#topic+factor">factor</a></code> is not created for a level of <code>nesting.fac</code> with label equal to <code>outlabel</code>. The names of the <code><a href="base.html#topic+factor">factor</a></code>s are equal to the levels of <code>nesting.fac</code>; optionally <code>fac.prefix</code> is added to the beginning of the names of the <code><a href="base.html#topic+factor">factor</a></code>s. The function is used to split up a nested term into separate terms for each level of <code>nesting.fac</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.multinested(nesting.fac, nested.fac = NULL, fac.prefix = NULL, 
                nested.levs = NA, nested.labs = NA, 
                outlevel = 0, outlabel = "rest", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.multinested_+3A_nesting.fac">nesting.fac</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> for each of whose <code>levels</code> a nested facor                      is to be generated, except one is not generated for the <code>outlabel</code> level.</p>
</td></tr>
<tr><td><code id="fac.multinested_+3A_nested.fac">nested.fac</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> whose values for a level are to be used for the 
<code><a href="base.html#topic+factor">factor</a></code> being created for that level. If <code>nested.fac</code> 
is <code>NULL</code>, then the values of the <code>levels</code> is the the list of 
numbers from 1 to the replication of the level of <code>nesting.fac</code>, 
represented as characters.</p>
</td></tr>
<tr><td><code id="fac.multinested_+3A_fac.prefix">fac.prefix</code></td>
<td>
<p>The prefix to be added to a level in naming a nested <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="fac.multinested_+3A_nested.levs">nested.levs</code></td>
<td>
<p>Optional <code>vector</code> of levels for the nested <code><a href="base.html#topic+factor">factor</a></code>s. Any data 
value that does not match a value in <code>nested.levs</code> will be <code>NA</code> in 
the nested <code><a href="base.html#topic+factor">factor</a></code> being generated. The default value of <code>nested.levs</code> is 
the list of numbers from 1 to the replication of the <code>levels</code> of 
<code>nesting.fac</code>, represented as characters. When <code>nested.fac</code> is not 
<code>NULL</code>, <code>nested.levs</code> is not used.</p>
</td></tr>
<tr><td><code id="fac.multinested_+3A_nested.labs">nested.labs</code></td>
<td>
<p>Optional <code>vector</code> of values to use as <code>labels</code> for the 
<code>levels</code> of the new nested <code><a href="base.html#topic+factor">factor</a></code>s; they are combined with <code>outlabel</code>. 
The default is <code>as.character(levels)</code>.</p>
</td></tr> 
<tr><td><code id="fac.multinested_+3A_outlevel">outlevel</code></td>
<td>
<p>The level to use in the new <code><a href="base.html#topic+factor">factor</a></code> for all values of old <code><a href="base.html#topic+factor">factor</a></code> that do not correspond to the level of the <code>nesting.fac</code> to which the new <code><a href="base.html#topic+factor">factor</a></code> corresponds.</p>
</td></tr>
<tr><td><code id="fac.multinested_+3A_outlabel">outlabel</code></td>
<td>
<p>The label to use the <code>outlevel</code> level.</p>
</td></tr> 
<tr><td><code id="fac.multinested_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating a new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing a <code><a href="methods.html#topic+factor-class">factor</a></code>  
for each level of <code>nesting.fac</code>.</p>


<h3>Note</h3>

<p>The levels of <code>nesting.fac</code> do not have to be equally replicated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.gen">fac.gen</a></code>, <code><a href="#topic+fac.nested">fac.nested</a></code> in package <span class="pkg">dae</span>, <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  lay &lt;- data.frame(A = factor(rep(c(1:3), c(3,6,4)), labels = letters[1:3]))
  lay$B &lt;-fac.nested(lay$A)

  #Add factors for B within each level of A
  lay2 &lt;- cbind(lay, fac.multinested(lay$A))
  canon2 &lt;- designAnatomy(list(~A/(a+b+c)), data = lay2)
  summary(canon2)

  #Add factors for B within each level of A, but with levels and outlabel given
  lay2 &lt;- cbind(lay, fac.multinested(lay$A, nested.levs = seq(10,60,10), outlabel = "other"))
  
  canon2 &lt;- designAnatomy(list(~A/(a+b+c)), data = lay2)
  summary(canon2)
  

  #Replicate the combinations of A and B three times and index them with the factor sample
  lay3 &lt;- rbind(lay,lay,lay)
  lay3$sample &lt;- with(lay3, fac.nested(fac.combine(list(A,B))))
  
  #Add factors for B within each level of A
  lay4 &lt;- cbind(lay3, fac.multinested(nesting.fac = lay$A, nested.fac = lay$B))
  
  canon4 &lt;- designAnatomy(list(~(A/(a+b+c))/sample), data = lay4)
  summary(canon4)
  

  #Add factors for sample within each combination of A and B
  lay5 &lt;- with(lay4, cbind(lay4, 
                           fac.multinested(nesting.fac = a, fac.prefix = "a"),
                           fac.multinested(nesting.fac = b, fac.prefix = "b"),
                           fac.multinested(nesting.fac = c, fac.prefix = "c")))
  
  canon5 &lt;- designAnatomy(list(~A/(a/(a1+a2+a3)+b/(b1+b2+b3+b4+b5+b6)+c/(c1+c2+c3))), data = lay5)
  summary(canon5)

  #Add factors for sample within each level of A
  lay6 &lt;- cbind(lay4, 
                fac.multinested(nesting.fac = lay4$A, nested.fac = lay$sample, fac.prefix = "samp"))
  canon6 &lt;- designAnatomy(list(~A/(a/sampa+b/sampb+c/sampc)), data = lay6)
  summary(canon6)
</code></pre>

<hr>
<h2 id='fac.nested'>creates a factor, the nested factor, whose values are generated within those of the factor 
nesting.fac</h2><span id='topic+fac.nested'></span>

<h3>Description</h3>

<p>Creates a nested <code><a href="base.html#topic+factor">factor</a></code> whose <code>levels</code> are generated 
within those of the factor <code>nesting.fac</code>. All elements of <code>nesting.fac</code> 
having the same level are numbered from 1 to the number of different elements 
having that level.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.nested(nesting.fac, nested.levs=NA, nested.labs=NA, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.nested_+3A_nesting.fac">nesting.fac</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> within each of whose <code>levels</code> the 
created <code><a href="base.html#topic+factor">factor</a></code> is to be generated.</p>
</td></tr>
<tr><td><code id="fac.nested_+3A_nested.levs">nested.levs</code></td>
<td>
<p>Optional <code>vector</code> of levels for the <code><a href="base.html#topic+factor">factor</a></code>. Any data 
value that does not match a value in <code>levels</code> will be <code>NA</code> in 
the <code><a href="base.html#topic+factor">factor</a></code>. The default value of <code>nested.levs</code> is the  list of 
numbers from 1 to the maximum replication of the <code>levels</code> of 
<code>nesting.fac</code>, represented as characters.</p>
</td></tr>
<tr><td><code id="fac.nested_+3A_nested.labs">nested.labs</code></td>
<td>
<p>Optional <code>vector</code> of values to use as <code>labels</code> for the 
<code>levels</code> of the <code><a href="base.html#topic+factor">factor</a></code>. The default is <code>as.character(nested.levs)</code>.</p>
</td></tr> 
<tr><td><code id="fac.nested_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code> that is a character <code>vector</code> with class attribute 
&quot;<code><a href="methods.html#topic+factor-class">factor</a></code>&quot; and a <code>levels</code> attribute which 
determines what character strings may be included in the <code>vector</code>. It has 
a different level for of the values of the nesting.fac with the same level.</p>


<h3>Note</h3>

<p>The levels of <code>nesting.fac</code> do not have to be equally replicated.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.gen">fac.gen</a></code>, <code><a href="#topic+fac.multinested">fac.multinested</a></code> in package <span class="pkg">dae</span>, <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up factor A
A &lt;- factor(c(1, 1, 1, 2, 2))

## create nested factor
B &lt;- fac.nested(A)
</code></pre>

<hr>
<h2 id='fac.recast'>Recasts a factor by modifying the values in the factor vector and/or the levels attribute, possibly combining some levels into a single level.</h2><span id='topic+fac.recast'></span>

<h3>Description</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code> is comprised of a vector of values and a <code><a href="base.html#topic+levels">levels</a></code> attribute. 
This function can modify these separately or jointly. The <code>newlevels</code> argument recasts 
both the values of a <code><a href="base.html#topic+factor">factor</a></code> vector and the <code><a href="base.html#topic+levels">levels</a></code> attribute, using each 
value in the <code>newlevels</code> vector to replace the corresponding value in both <code><a href="base.html#topic+factor">factor</a></code> 
vector and the <code><a href="base.html#topic+levels">levels</a></code> attribute. The <code><a href="base.html#topic+factor">factor</a></code>, possibly 
with the new levels, can have its <code>levels</code> attribute reordered and/or new 
<code>labels</code> associated with the <code>levels</code> using the <code>levels.order</code> and <code>newlabels</code> 
arguments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.recast(factor, newlevels = NULL, levels.order = NULL, newlabels = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.recast_+3A_factor">factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> to be recast.</p>
</td></tr>
<tr><td><code id="fac.recast_+3A_newlevels">newlevels</code></td>
<td>
<p>A <code>vector </code>of length <code>levels(factor)</code> that changes both the values in the 
<code>factor</code> vector and its <code><a href="base.html#topic+levels">levels</a></code> attribute. The values in the 
<code>newlevels</code> vector need not be unique, but there must be as many values as 
there are levels in the supplied <code>factor</code>. The levels in the vector of the 
supplied <code>factor</code> that have the same value in <code>newlevels</code> will be combined 
in the recast <code><a href="base.html#topic+factor">factor</a></code>. The values in the new <code><a href="base.html#topic+levels">levels</a></code> 
attribute can be re-oredered using <code>levels.order</code>.</p>
</td></tr>
<tr><td><code id="fac.recast_+3A_levels.order">levels.order</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> that specifies the order of the levels in the 
<code><a href="base.html#topic+levels">levels</a></code> attribute of the recast <code><a href="base.html#topic+factor">factor</a></code>. 
If <code>newlevels</code> is <code>NULL</code>, must be of 
length <code>levels(factor)</code> and contain the old levels in the new order for 
the recast <code><a href="base.html#topic+factor">factor</a></code>. If <code>newlevels</code> is not <code>NULL</code>, the vector 
must be of <code>length(unique(newlevels))</code> and contain the unique values in 
<code>newlevels</code> in the new order for the recast <code><a href="base.html#topic+factor">factor</a></code>. 
The values in the <code><a href="base.html#topic+factor">factor</a></code> vector whose <code><a href="base.html#topic+levels">levels</a></code> are being 
re-ordered will be unchanged. If <code>levels.order</code> is <code>NULL</code>, then the 
current <code><a href="base.html#topic+levels">levels</a></code> attribute of <code>factor</code> is used.</p>
</td></tr>
<tr><td><code id="fac.recast_+3A_newlabels">newlabels</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> of length <code>levels(factor)</code> if <code>newlevels</code> is 
<code>NULL</code>, and of length <br /><code>unique(newlevels)</code> if it is not <code>NULL</code>. 
It should contain the values to be used as <code>labels</code> in the recast <code><a href="base.html#topic+factor">factor</a></code>. 
Effectively, this changes the values in the <code><a href="base.html#topic+factor">factor</a></code> vector to those 
given in <code>newlabels</code> and the <code>levels</code> attribute to <code>newlabels</code>.</p>
</td></tr>
<tr><td><code id="fac.recast_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.uselogical">fac.uselogical</a>, <a href="#topic+as.numfac">as.numfac</a></code> and <code><a href="#topic+mpone">mpone</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+factor">factor</a></code>, <code><a href="stats.html#topic+relevel">relevel</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a factor with labels
Treats &lt;- factor(rep(1:4, 4), labels=letters[1:4])
 
## recast to reduce the levels: "a" and "d" to 1 and "b" and "c" to 2, i.e. from 4 to 2 levels
A &lt;- fac.recast(Treats, newlevels = c(1,2,2,1), labels = letters[1:2])
A &lt;- fac.recast(Treats, newlevels = letters[c(1,2,2,1)])

#reduce the levels from 4 to 2, with re-ordering the levels vector without changing the values 
#of the new recast factor vector
A &lt;- fac.recast(Treats, newlevels = letters[c(1,2,2,1)], levels.order = letters[2:1])  

#reassign the values in the factor vector without re-ordering the levels attribute
A &lt;- fac.recast(Treats, newlevels = letters[4:1])  

#reassign the values in the factor vector, with re-ordering the levels attribute
A &lt;- fac.recast(Treats, newlabels = letters[4:1])

#reorder the levels attribute with changing the values in the factor vector
A &lt;- fac.recast(Treats, levels.order = letters[4:1])  

#reorder the values in the factor vector without changing the levels attribute
A &lt;- fac.recast(Treats, newlevels = 4:1, newlabels = levels(Treats))

</code></pre>

<hr>
<h2 id='fac.recode'>Recodes factor <code>levels</code> using values in a vector. The values in the vector do 
not have to be unique.</h2><span id='topic+fac.recode'></span>

<h3>Description</h3>

<p>Recodes the <code>levels</code> and values of a factor using each value in the 
<code>newlevels</code> vector  to replace the corresponding value in the vector of 
<code>levels</code> of the <code><a href="base.html#topic+factor">factor</a></code>. 
</p>
<p>This function has been superseded by <code>fac.recast</code>, which has extended functionality. 
Calls to <code>fac.recast</code> that use only the <code>factor</code> and <code>newlevels</code> argument will 
produce the same results as a call to <code>fa.recode</code>. 
<code>fac.recode</code> may be deprecated in future versions of <code>dae</code> and is being retained 
for now to maintain backwards compatibility.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.recode(factor, newlevels, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.recode_+3A_factor">factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> to be recoded.</p>
</td></tr>
<tr><td><code id="fac.recode_+3A_newlevels">newlevels</code></td>
<td>
<p>A <code>vector </code>of length <code>levels(factor)</code> containing values to use in 
the recoding.</p>
</td></tr>
<tr><td><code id="fac.recode_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.recast">fac.recast</a></code>, <code><a href="#topic+fac.uselogical">fac.uselogical</a>, <a href="#topic+as.numfac">as.numfac</a></code> and <code><a href="#topic+mpone">mpone</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+factor">factor</a></code>, <code><a href="stats.html#topic+relevel">relevel</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a factor with labels
Treats &lt;- factor(rep(1:4, 4), labels=c("A","B","C","D"))
 
## recode "A" and "D" to 1 and "B" and "C" to 2
B &lt;- fac.recode(Treats, c(1,2,2,1), labels = c("a","b"))
</code></pre>

<hr>
<h2 id='fac.split'>Splits a factor whose levels consist of several delimited strings into several factors</h2><span id='topic+fac.split'></span>

<h3>Description</h3>

<p>Splits a <code><a href="base.html#topic+factor">factor</a></code>, whose <code>levels</code> consist of strings delimited by a 
separator character, into several <code><a href="base.html#topic+factor">factor</a>s</code>. It uses the function 
<code><a href="base.html#topic+strsplit">strsplit</a></code>, with <code>fixed = TRUE</code> to split the <code>levels</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.split(combined.factor, factor.names, sep=",", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.split_+3A_combined.factor">combined.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> to be split into several <code><a href="base.html#topic+factor">factor</a>s</code>.</p>
</td></tr>
<tr><td><code id="fac.split_+3A_factor.names">factor.names</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of names for factors and associated <code>levels</code>, if required.
The names of the components of the <code><a href="base.html#topic+list">list</a></code> are used for the names of the new factors. 
Each component of the <code><a href="base.html#topic+list">list</a></code> should either be <code>NULL</code> or a vector of levels for 
the new <code><a href="base.html#topic+factor">factor</a></code>. If a component is <code>NULL</code> then the unique values  for the 
supplied factor are used as the <code>levels</code>, which are sorted into alphabetical order. 
If a either a <code><a href="base.html#topic+numeric">numeric</a></code> or a <code><a href="base.html#topic+character">character</a></code> vector is supplied for a 
component, then these are supplied as the <code>levels</code> of the new factor.</p>
</td></tr>
<tr><td><code id="fac.split_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> string that separates the levels in the <code>combined.factor</code>.</p>
</td></tr>
<tr><td><code id="fac.split_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating 
the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the new <code><a href="base.html#topic+factor">factor</a>s</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.divide">fac.divide</a></code>, <code><a href="#topic+fac.uncombine">fac.uncombine</a></code>, <code><a href="#topic+fac.combine">fac.combine</a></code> in package <span class="pkg">dae</span> and 
<code><a href="base.html#topic+strsplit">strsplit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Form a combined factor to split
data(Oats.dat)
tmp &lt;- within(Oats.dat, Trts &lt;- fac.combine(list(Variety, Nitrogen), combine.levels = TRUE))

##Variety levels sorted into alphabetical order
trts.dat &lt;- fac.split(combined.factor = tmp$Trts, 
                      factor.names = list(Variety = NULL, Nitrogen = NULL))

##Variety levels order from Oats.dat retained
trts.dat &lt;- fac.split(combined.factor = tmp$Trts, 
                      factor.names = list(Variety = levels(tmp$Variety), Nitrogen = NULL))
</code></pre>

<hr>
<h2 id='fac.sumop'>computes the summation matrix that produces sums corresponding to a (generalized) factor</h2><span id='topic+fac.sumop'></span>

<h3>Description</h3>

<p>Computes the matrix that produces the sums 
corresponding to a (generalized) <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.sumop(factor)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.sumop_+3A_factor">factor</code></td>
<td>
<p>The (generalized) <code><a href="base.html#topic+factor">factor</a></code> whose sums the summation matrix
computes from an observation-length vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design matrix <b>X</b> for a (generalized) <code><a href="base.html#topic+factor">factor</a></code> is formed with a 
column for each <code>level</code> of the (generalized) <code><a href="base.html#topic+factor">factor</a></code>, this column 
being its indicator variable. The summation matrix is formed as 
<code>X %*% t(X)</code>.
</p>
<p>A generalized <code><a href="base.html#topic+factor">factor</a></code> is a <code><a href="base.html#topic+factor">factor</a></code> formed from the combinations of 
the <code>levels</code> of several original <code><a href="base.html#topic+factor">factor</a>s</code>. Generalized <code><a href="base.html#topic+factor">factor</a>s</code> 
can be formed using <code><a href="#topic+fac.combine">fac.combine</a></code>.</p>


<h3>Value</h3>

<p>A symmetric matrix.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.combine">fac.combine</a></code>, <code><a href="#topic+fac.meanop">fac.meanop</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a two-level factoir and a three-level factor, both of length 12
A &lt;- factor(rep(1:2, each=6))
B &lt;- factor(rep(1:3, each=2, times=2))

## create a generlaized factor whose levels are the combinations of A and B
AB &lt;- fac.combine(list(A,B))

## obtain the operator that computes the AB means from a vector of length 12
S.AB &lt;- fac.sumop(AB)
</code></pre>

<hr>
<h2 id='fac.uncombine'>Cleaves a single factor, each of whose levels has delimited strings, into several 
factors using the separated strings.</h2><span id='topic+fac.uncombine'></span>

<h3>Description</h3>

<p>Cleaves a single <code><a href="base.html#topic+factor">factor</a></code> into several factors whose <code>levels</code>,  
the levels of the original <code><a href="base.html#topic+factor">factor</a></code> consisting of several delimited strings that 
can be separated to form the levels of the <code>new.factors</code>. That is, it reverses the process 
of combining factors that <code><a href="#topic+fac.combine">fac.combine</a></code> performs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.uncombine(factor, new.factors, sep=",", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.uncombine_+3A_factor">factor</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> or <code><a href="base.html#topic+character">character</a></code> that has values that are strings 
deleimited by the delimiter specified by <code>sep</code>.</p>
</td></tr>
<tr><td><code id="fac.uncombine_+3A_new.factors">new.factors</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, whose component names are the names of the 
new <code><a href="base.html#topic+factor">factor</a>s</code> to be formed. If a component is not <code>NULL</code>, 
then they are used as the levels of the corresponding <code>factor</code>.</p>
</td></tr>
<tr><td><code id="fac.uncombine_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> string that separates the levels of the <code>new.factors</code> in the 
levels <code>factor</code>.</p>
</td></tr>
<tr><td><code id="fac.uncombine_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating 
the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns consist of the <code><a href="base.html#topic+factor">factor</a>s</code> listed in 
<code>new.factors</code> and whose values have been computed from the values of the combined 
<code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.split">fac.split</a></code>, <code><a href="#topic+fac.combine">fac.combine</a></code>, <code><a href="#topic+fac.divide">fac.divide</a></code> in package <span class="pkg">dae</span> and 
<code><a href="base.html#topic+strsplit">strsplit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up two factors and combine them
facs &lt;- fac.gen(list(A = letters[1:3], B = 1:2), each = 4)
facs$AB &lt;- with(facs, fac.combine(list(A, B), combine.levels = TRUE))

## now reverse the proces and uncombine the two factors
new.facs &lt;- fac.uncombine(factor = facs$AB, 
                          new.factors = list(A = letters[1:3], B = NULL), 
                          sep = ",")
new.facs &lt;- fac.uncombine(factor = facs$AB, 
                          new.factors = list(A = NULL, B = NULL), 
                          sep = ",")
</code></pre>

<hr>
<h2 id='fac.uselogical'>Forms a two-level <code><a href="base.html#topic+factor">factor</a></code> from a <code><a href="base.html#topic+logical">logical</a></code> object.</h2><span id='topic+fac.uselogical'></span>

<h3>Description</h3>

<p>Forms a two-level <code><a href="base.html#topic+factor">factor</a></code> from a <code><a href="base.html#topic+logical">logical</a></code> object. 
It can be used to recode a <code><a href="base.html#topic+factor">factor</a></code> when the resulting <code><a href="base.html#topic+factor">factor</a></code> 
is to have only two <code>levels</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.uselogical(x, levels = c(TRUE, FALSE), labels = c("yes", "no"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.uselogical_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> vector with values <code>TRUE</code> or <code>FALSE</code>. If the vector is 
not a <code>logical</code>, <code><a href="base.html#topic+as.logical">as.logical</a></code> will be used in an attempt to 
coerce it to <code>logical</code>.</p>
</td></tr>
<tr><td><code id="fac.uselogical_+3A_levels">levels</code></td>
<td>
<p>A <code>vector</code> of length two with values <code>TRUE</code> or <code>T</code> and 
<code>FALSE</code> or <code>F</code>, in either order depending on which of <code>TRUE</code> 
or <code>FALSE</code> is to be the first level.</p>
</td></tr>
<tr><td><code id="fac.uselogical_+3A_labels">labels</code></td>
<td>
<p>A <code>vector</code> of length two with values to be used as labels for the first 
and second levels, respectively.</p>
</td></tr>
<tr><td><code id="fac.uselogical_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+factor">factor</a></code> call creating the new <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.recast">fac.recast</a></code>, <code><a href="#topic+as.numfac">as.numfac</a></code> and <code><a href="#topic+mpone">mpone</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+factor">factor</a></code>, <code><a href="stats.html#topic+relevel">relevel</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a factor with labels
Treats &lt;- factor(rep(1:4, 4), labels=c("A","B","C","D"))
 
## recode "A" and "D" to "a" and "B" and "C" to "b"
B &lt;- fac.uselogical(Treats %in% c("A", "D"), labels = c("a","b"))
B &lt;- fac.uselogical(Treats %in% c("A", "D"), labels = c(-1,1))

## suppose level A in factor a is a control treatment
## set up a factor Control to discriminate between control and treated
Control &lt;- fac.uselogical(Treats == "A")
</code></pre>

<hr>
<h2 id='fac.vcmat'>forms the variance matrix for the variance component of a (generalized) factor</h2><span id='topic+fac.vcmat'></span>

<h3>Description</h3>

<p>Form the variance matrix for a (generalized) factor whose effects 
for its different levels are independently and identically distributed, with 
their variance given by the variance component; elements of the matrix will 
equal either zero or sigma2 and displays compound symmetry.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac.vcmat(factor, sigma2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac.vcmat_+3A_factor">factor</code></td>
<td>
<p>The (generalized) <code><a href="base.html#topic+factor">factor</a></code> for which the variance 
matrix is required.</p>
</td></tr>
<tr><td><code id="fac.vcmat_+3A_sigma2">sigma2</code></td>
<td>
<p>The variance component, being the of the random effects for the 
factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is:
a) form the n x n summation or relationship matrix whose elements are equal 
to zero except for those elements whose corresponding elements in the 
following two n x n matrices are equal: 1) each row contains the numeric 
values corresponding to the observed levels of the factor, and 2) each 
column contains the numeric values corresponding to the observed levels 
of the factor, 
b) multiply the summation matrix by sigma2.
</p>


<h3>Value</h3>

<p>An n x n <code><a href="base.html#topic+matrix">matrix</a></code>, where n is the length of the 
<code><a href="base.html#topic+factor">factor</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.ar1mat">fac.ar1mat</a></code>,  <code><a href="#topic+fac.meanop">fac.meanop</a></code>, 
<code><a href="#topic+fac.sumop">fac.sumop</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a two-level factor and a three-level factor, both of length 12
A &lt;- factor(rep(1:2, each=6))
B &lt;- factor(rep(1:3, each=2, times=2))

## create a 12 x 12 ar1 matrix corrresponding to B
vc.B &lt;- fac.vcmat(B, 2)
</code></pre>

<hr>
<h2 id='Fac4Proc.dat'>Data for a 2^4 factorial experiment</h2><span id='topic+Fac4Proc.dat'></span>

<h3>Description</h3>

<p>The data set come from an unreplicated <code class="reqn">2^4</code> factorial experiment to 
investigate a chemical process. The response variable is the Conversion 
percentage (Conv) and this is indexed by the 4 two-level factors Catal, Temp, 
Press and Conc, with levels &ldquo;-&rdquo; and &ldquo;+&rdquo;. The data is aranged in 
Yates order. Also included is the 16-level factor Runs which gives the order 
in which the combinations of the two-level factors were run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Fac4Proc.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 16 observations of 6 variables.</p>


<h3>Source</h3>

<p>Table 10.6 of Box, Hunter and Hunter (1978) <em>Statistics for Experimenters</em>. 
New York, Wiley.</p>

<hr>
<h2 id='fitted.aovlist'>Extract the fitted values for a fitted model from an aovlist object</h2><span id='topic+fitted.aovlist'></span><span id='topic+fitted'></span>

<h3>Description</h3>

<p>Extracts the fitted values as the sum of the effects 
for all the fitted terms in the model, stopping at <code>error.term</code> 
if this is specified. It is a method for the generic function 
<code><a href="#topic+fitted">fitted</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aovlist'
fitted(object, error.term=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.aovlist_+3A_object">object</code></td>
<td>
<p>An <code>aovlist</code> object created from a call to <code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.aovlist_+3A_error.term">error.term</code></td>
<td>
<p>The term from the <code>Error</code> function down to which effects 
are extracted for adding to the fitted values. The order of terms is as 
given in the ANOVA table. If <code>error.term</code> is <code>NULL</code> effects are 
extracted from all <code>Error</code> terms.</p>
</td></tr>
<tr><td><code id="fitted.aovlist_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>vector</code> of fitted values.</p>


<h3>Note</h3>

<p>Fitted values will be the sum of effects for terms from the model, but only 
for terms external to any <code>Error</code> function. If you want effects for 
terms in the <code>Error</code> function to be included, put them both inside 
and outside the <code>Error</code> function so they are occur twice.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.errors">fitted.errors</a></code>, <code><a href="#topic+resid.errors">resid.errors</a></code>, <code><a href="#topic+tukey.1df">tukey.1df</a></code> 
in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up data frame for randomized complete block design in Table 4.4 from 
## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
## New York, Wiley.
RCBDPen.dat &lt;- fac.gen(list(Blend=5, Flask=4))
RCBDPen.dat$Treat &lt;- factor(rep(c("A","B","C","D"), times=5))
RCBDPen.dat$Yield &lt;- c(89,88,97,94,84,77,92,79,81,87,87,
                       85,87,92,89,84,79,81,80,88)

## perform the analysis of variance
RCBDPen.aov &lt;- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
summary(RCBDPen.aov)

## two equivalent ways of extracting the fitted values
fit  &lt;- fitted.aovlist(RCBDPen.aov)
fit &lt;- fitted(RCBDPen.aov, error.term = "Blend:Flask")
</code></pre>

<hr>
<h2 id='fitted.errors'>Extract the fitted values for a fitted model</h2><span id='topic+fitted.errors'></span>

<h3>Description</h3>

<p>An alias for the generic function <code><a href="#topic+fitted">fitted</a></code>. When it is 
available, the method <code><a href="#topic+fitted.aovlist">fitted.aovlist</a></code> extracts the fitted values, which is provided 
in the <span class="pkg">dae</span> package to cover <code>aovlist</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'errors'
fitted(object, error.term=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.errors_+3A_object">object</code></td>
<td>
<p>An <code>aovlist</code> object created from a call to <code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.errors_+3A_error.term">error.term</code></td>
<td>
<p>The term from the <code>Error</code> function down to which effects 
are extracted for adding to the fitted values. The order of terms is as 
given in the ANOVA table. If <code>error.term</code> is <code>NULL</code> effects are 
extracted from all <code>Error</code> terms.</p>
</td></tr>
<tr><td><code id="fitted.errors_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of fitted values.</p>


<h3>Warning</h3>

<p>See <code><a href="#topic+fitted.aovlist">fitted.aovlist</a></code> for specific information about fitted 
values when an <code>Error</code> function is used in the call to the 
<code><a href="stats.html#topic+aov">aov</a></code> function.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.aovlist">fitted.aovlist</a></code>, <code><a href="#topic+resid.errors">resid.errors</a></code>, <code><a href="#topic+tukey.1df">tukey.1df</a></code> 
in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up data frame for randomized complete block design in Table 4.4 from 
## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
## New York, Wiley.
RCBDPen.dat &lt;- fac.gen(list(Blend=5, Flask=4))
RCBDPen.dat$Treat &lt;- factor(rep(c("A","B","C","D"), times=5))
RCBDPen.dat$Yield &lt;- c(89,88,97,94,84,77,92,79,81,87,87,
                       85,87,92,89,84,79,81,80,88)

## perform the analysis of variance
RCBDPen.aov &lt;- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
summary(RCBDPen.aov)

## three equivalent ways of extracting the fitted values
fit  &lt;- fitted.aovlist(RCBDPen.aov)
fit &lt;- fitted(RCBDPen.aov, error.term = "Blend:Flask")
fit &lt;- fitted.errors(RCBDPen.aov, error.term = "Blend:Flask")
</code></pre>

<hr>
<h2 id='get.daeTolerance'>Gets the value of daeTolerance for the package dae</h2><span id='topic+get.daeTolerance'></span>

<h3>Description</h3>

<p>A function that gets the <code>vector</code> of values such that, in <span class="pkg">dae</span> 
functions, values less than it are considered to be zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.daeTolerance()</code></pre>


<h3>Value</h3>

<p>The <code>vector</code> of two values for <code>daeTolerance</code>, one named <code>element.tol</code> 
that is used for elements of matrices and a second named <code>element.eigen</code> 
that is used for eigenvalues and quantities based on them, such as efficiency 
factors.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get daeTolerance.
get.daeTolerance()
</code></pre>

<hr>
<h2 id='harmonic.mean'>Calcuates the harmonic mean.</h2><span id='topic+harmonic.mean'></span>

<h3>Description</h3>

<p>A function to calcuate the harmonic mean of a set of nonzero numbers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic.mean(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic.mean_+3A_x">x</code></td>
<td>
<p>An object from whose elements the harmonic mean is to be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the elements of <code>x</code> are tested as being less than <code>daeTolerance</code>, 
which is initially set to <code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>A numeric. Returns <code>Inf</code> if <code>x</code> contains a value close to zero</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(seq(0.1,1,0.2))
harmonic.mean(y)
</code></pre>

<hr>
<h2 id='interaction.ABC.plot'>Plots an interaction plot for three factors</h2><span id='topic+interaction.ABC.plot'></span>

<h3>Description</h3>

<p>Plots a <code>function</code> (the mean by default) of the <code>response</code> for
the combinations of the three <code><a href="base.html#topic+factor">factor</a>s</code> specified as the <code>x.factor</code>
(plotted on the x axis of each plot), the <code>groups.factor</code> (plotted
as separate lines in each plot) and the <code>trace.factor</code> (its <code>levels</code>
are plotted in different plots). Interaction plots for more than three
<code><a href="base.html#topic+factor">factor</a>s</code> can be produced by using <code><a href="#topic+fac.combine">fac.combine</a></code> to combine all but
two of them into a single <code><a href="base.html#topic+factor">factor</a></code> that is specified as the
<code>trace.factor</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction.ABC.plot(response, x.factor, groups.factor, 
       trace.factor,data, fun="mean", title="A:B:C Interaction Plot", 
       xlab, ylab, key.title, lwd=4, columns=2, ggplotFuncs = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interaction.ABC.plot_+3A_response">response</code></td>
<td>
<p>A numeric <code>vector</code> containing the response variable from 
which a function (the mean by
default) is computed for plotting on the y-axis.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_x.factor">x.factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> to be plotted on the x-axis of each plot. 
If the levels are numeric values stored as characters, they will be 
converted to numeric values for plotting. If they are actually numeric 
codes for nonnumeric categories and you want them plotted on a 
discrete scale then you should employ nonumeric codings, 
such as &lsquo;-&rsquo; and &lsquo;+&rsquo; or &lsquo;N&rsquo; and &lsquo;Y&rsquo; or something similar.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_groups.factor">groups.factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> plotted as separate lines in each plot.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_trace.factor">trace.factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> for whose <code>levels</code> there are separate plots.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the three <code>factors</code> and the 
<code>response</code>.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_fun">fun</code></td>
<td>
<p>The <code>function</code> to be computed from the <code>response</code> for each
combination of the three factors <code>x.factor</code>,
<code>groups.factor</code> and <code>trace.factor</code>. By default, the mean
is computed for each combination.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_title">title</code></td>
<td>
<p>Title for plot window. By default it is &quot;A:B:C Interaction Plot&quot;.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_xlab">xlab</code></td>
<td>
<p><code>Label</code> for the x-axis. By default it is the name of the
<code>x.factor</code>.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_ylab">ylab</code></td>
<td>
<p><code>Label</code> for the y-axis. By default it is the name of the
<code>response</code>.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_key.title">key.title</code></td>
<td>
<p><code>Label</code> for the key (legend) to the lines in each plot. By default it
is the name of the <code>groups.factor</code>.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_lwd">lwd</code></td>
<td>
<p>The width of the <code>lines</code>. By default it is 4.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_columns">columns</code></td>
<td>
<p>The number of columns for arranging the several plots for the
levels of the <code>groups.factor</code>. By default it is 2.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element.
These functions are applied in creating the <code>ggplot</code> object.</p>
</td></tr>
<tr><td><code id="interaction.ABC.plot_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed down to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>ggplot</code>&quot;, which can be plotted using <code>print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.combine">fac.combine</a></code> in package <span class="pkg">dae</span>, <code><a href="stats.html#topic+interaction.plot">interaction.plot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## plot for Example 14.1 from Mead, R. (1990). The Design of Experiments: 
## Statistical Principles for Practical Application. Cambridge, 
## Cambridge University Press.  
## use ?SPLGrass.dat for details
data(SPLGrass.dat)
interaction.ABC.plot(Main.Grass, x.factor=Period,
                     groups.factor=Spring, trace.factor=Summer,
                     data=SPLGrass.dat,
                     title="Effect of Period, Spring and Summer on Main Grass")

## plot for generated data
## use ?ABC.Interact.dat for data set details
data(ABC.Interact.dat)
## Add standard errors for plotting 
## - here data contains a single value for each combintion of A, B and C
## - need to supply name for data twice 
ABC.Interact.dat$se &lt;- rep(c(0.5,1), each=4)
interaction.ABC.plot(MOE, A, B, C, data=ABC.Interact.dat,
                     ggplotFunc=list(geom_errorbar(data=ABC.Interact.dat, 
                                                   aes(ymax=MOE+se, ymin=MOE-se), 
                                                   width=0.2)))

## End(Not run)</code></pre>

<hr>
<h2 id='is.allzero'>Tests whether all elements are approximately zero</h2><span id='topic+is.allzero'></span>

<h3>Description</h3>

<p>A single-line <code>function</code> that tests whether all elements are zero 
(approximately).</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.allzero(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.allzero_+3A_x">x</code></td>
<td>
<p>An <code>object</code> whose elements are to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of the absolute values of the elements of <code>x</code> is tested to determine if it is less than <code>daeTolerance</code>, which is initially set to <code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>A <code>logical</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a vector of 9 zeroes and a one
y &lt;- c(rep(0,9), 1)

## check that vector is only zeroes is FALSE 
is.allzero(y)
</code></pre>

<hr>
<h2 id='is.projector'>Tests whether an object is a valid object of class projector</h2><span id='topic+is.projector'></span>

<h3>Description</h3>

<p>Tests whether an  <code>object</code> is a valid object of class 
&quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.projector(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.projector_+3A_object">object</code></td>
<td>
<p>The <code><a href="base.html#topic+matrix">matrix</a></code> to be made into a projector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>is.projector</code> tests whether the object consists of a 
<code><a href="base.html#topic+matrix">matrix</a></code> that is square, symmetric and idempotent. In checking 
symmetry and idempotency, the equality of the matrix with either its 
transpose or square is tested. In this, a difference in elements is 
considered to be zero if it is less than <code>daeTolerance</code>, which is 
initially set to <code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). 
The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can 
be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> depending on whether the object is a valid object of class 
&quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>


<h3>Warning</h3>

<p>The degrees of freedom are not checked. <code><a href="#topic+correct.degfree">correct.degfree</a></code> 
can be used to check them.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+projector">projector</a></code>, <code><a href="#topic+correct.degfree">correct.degfree</a></code> in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
m &lt;- matrix(rep(0.5,4), nrow=2)

## create an object of class projector
proj.m &lt;- projector(m)

## check that it is a valid projector
is.projector(proj.m)
</code></pre>

<hr>
<h2 id='LatticeSquare_t49.des'>A Lattice square design for 49 treatments</h2><span id='topic+LatticeSquare_t49.des'></span>

<h3>Description</h3>

<p>The systematic design for a lattice square for 49 treatments consisting of four 7 x 7 squares. For more details see the vignette accessed via <code>vignette("DesignNotes", package="dae")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LatticeSquare_t49.des)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 196 observations of 4 variables.</p>


<h3>Source</h3>

<p>Cochran and Cox (1957) <em>Experimental Designs</em>. 2nd edn Wiley, New York.</p>

<hr>
<h2 id='marginality'>Extracts the marginality matrix (matrices) from a <code><a href="#topic+pstructure.object">pstructure.object</a></code> or a <code><a href="#topic+pcanon.object">pcanon.object</a></code>.</h2><span id='topic+marginality.pcanon'></span><span id='topic+marginality.pstructure'></span><span id='topic+marginality'></span>

<h3>Description</h3>

<p>Produces (i) a marginality <code><a href="base.html#topic+matrix">matrix</a></code> for the <code>formula</code> in a call to 
<code><a href="#topic+pstructure.formula">pstructure.formula</a></code> or (ii) a <code>list</code> containing the marginlity matrices, one for each 
<code>formula</code> in the <code>formulae</code> argument of a call to 
<code><a href="#topic+designAnatomy">designAnatomy</a></code>.
</p>
<p>A marginality matrix for a set of terms is a square <code><a href="base.html#topic+matrix">matrix</a></code> with 
a row and a column for each ternon-aliased term. Its elements are zeroes and ones, 
the entry in the ith row and jth column indicates whether or not the ith term is 
marginal to the jth term i.e. the column space of the ith term is a subspace of 
that for the jth term and so the source for the jth term will be orthogonal to 
that for the ith term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pstructure'
marginality(object, ...)
## S3 method for class 'pcanon'
marginality(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginality_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+pstructure.object">pstructure.object</a></code> produced by <code><a href="#topic+pstructure.formula">pstructure.formula</a></code> or  
<code><a href="#topic+pcanon.object">pcanon.object</a></code> produced by <code><a href="#topic+designAnatomy">designAnatomy</a></code>.</p>
</td></tr>
<tr><td><code id="marginality_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Unused at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>object</code> is a <code><a href="#topic+pstructure.object">pstructure.object</a></code> then a <code>matrix</code> containing 
the marginality matrix for the terms obtained from the <code>formuula</code> in the call to 
<code><a href="#topic+pstructure.formula">pstructure.formula</a></code>. 
</p>
<p>If <code>object</code> is a <code><a href="#topic+pcanon.object">pcanon.object</a></code> then a <code>list</code> with a 
component for each <code>formula</code>, each component having a marginality matrix that 
corresponds to one of the formulae in the call to <code><a href="#topic+designAnatomy">designAnatomy</a></code>. The
components of the <code>list</code> will have the same names as the componeents of the 
<code>formulae</code> <code>list</code> and so will be unnamed if the components of the latter 
<code>list</code> are unnamed.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+pstructure.formula">pstructure.formula</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code>, <code><a href="#topic+summary.pcanon">summary.pcanon</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>,  <br /> 
<code><a href="#topic+pstructure">pstructure</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain pstructure.object and extract marginality matrix
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
unit.marg &lt;- marginality(unit.struct)

##obtain combined decomposition and extract marginality matrices
unit.trt.canon &lt;- designAnatomy(list(unit=~ Block/Unit, trt=~ trt), data = PBIBD2.lay)
marg &lt;- marginality(unit.trt.canon)
</code></pre>

<hr>
<h2 id='mat.ar1'>Forms an ar1 correlation matrix</h2><span id='topic+mat.ar1'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the ar1 pattern. The <code><a href="base.html#topic+matrix">matrix</a></code> is banded and 
has diagonal elements equal to one and the off-diagonal element in the ith row 
and jth column equal to <code class="reqn">\rho^k</code> where 
<code class="reqn">k = |i- j|</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ar1(rho, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ar1_+3A_rho">rho</code></td>
<td>
<p>The correlation on the first off-diagonal.</p>
</td></tr>
<tr><td><code id="mat.ar1_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an ar1 pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.ar1(rho=0.4, order=4)
</code></pre>

<hr>
<h2 id='mat.ar2'>Forms an ar2 correlation matrix</h2><span id='topic+mat.ar2'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the ar2 pattern. The resulting <code><a href="base.html#topic+matrix">matrix</a></code> 
is banded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ar2(ARparameters, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ar2_+3A_arparameters">ARparameters</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the two autoregressive parameter values 
of the process, being the weights given to the lag 1 and lag 2 response values.</p>
</td></tr>
<tr><td><code id="mat.ar2_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlations in the correlation matrix, <code>corr</code> say, are calculated 
from the autoregressive parameters, <code>ARparameters</code>.
The values in 
</p>

<ul>
<li><p> the diagonal (<code>k = 1</code>) of <code>corr</code> are one; 
</p>
</li>
<li><p> the first subdiagonal band (<code>k = 2</code>) of <code>corr</code> 
are equal to <br /> 
<code>ARparameters[1]/(1-ARparameters[2])</code>; 
</p>
</li>
<li><p> in subsequent disgonal bands, (<code>k = 3:order</code>), 
of <code>corr</code> are <br /> 
<code>ARparameters[1]*corr[k-1] + ARparameters[2]*corr[k-2]</code>.</p>
</li></ul>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an ar2 pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.ar2(ARparameters = c(0.4, 0.2), order = 4)
</code></pre>

<hr>
<h2 id='mat.ar3'>Forms an ar3 correlation matrix</h2><span id='topic+mat.ar3'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the ar3 pattern. The resulting <code><a href="base.html#topic+matrix">matrix</a></code> 
is banded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ar3(ARparameters, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ar3_+3A_arparameters">ARparameters</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the three autoregressive parameter values 
of the process, being the weights given to the lag 1, lag 2 and lag 3 
response values.</p>
</td></tr>
<tr><td><code id="mat.ar3_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlations in the correlation matrix, <code>corr</code> say, are calculated 
from the autoregressive parameters, <code>ARparameters</code>. <br />
Let <code>omega = 1 - ARparameters[2] - ARparameters[3] * (ARparameters[1] + ARparameters[3])</code>. 
Then the values in 
</p>

<ul>
<li><p> the diagonal of <code>corr</code> (<code>k = 1</code>) are one; 
</p>
</li>
<li><p> the first subdiagonal band (<code>k = 2</code>) of <code>corr</code> are equal to <br /> 
<code>(ARparameters[1] + ARparameters[2]*ARparameters[3]) / omega</code>; 
</p>
</li>
<li><p> the second subdiagonal band (<code>k = 3</code>) of <code>corr</code> are equal to <br />
<code>(ARparameters[1] * (ARparameters[1] + ARparameters[3]) + </code> <br /> 
<code>ARparameters[2] * (1 - ARparameters[2])) / omega</code>; 
</p>
</li>
<li><p> the subsequent subdiagonal bands, (<code>k = 4:order</code>), of <code>corr</code> are equal to <br />
<code>ARparameters[1]*corr[k-1] + ARparameters[2]*corr[k-2] + ARparameters[3]*corr[k-3]</code>.</p>
</li></ul>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an ar3 pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, <code><a href="#topic+mat.banded">mat.banded</a></code>, 
<code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.ar3(ARparameters = c(0.4, 0.2, 0.1), order = 4)
</code></pre>

<hr>
<h2 id='mat.arma'>Forms an arma correlation matrix</h2><span id='topic+mat.arma'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the arma pattern. The resulting <code><a href="base.html#topic+matrix">matrix</a></code> 
is banded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.arma(ARparameter, MAparameter, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.arma_+3A_arparameter">ARparameter</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value for the autoregressive parameter
of the process, being the weight given to the lag 1 response values.</p>
</td></tr>
<tr><td><code id="mat.arma_+3A_maparameter">MAparameter</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> value for the moving average parameter
of the process, being the weight given to the lag 1 random variable.</p>
</td></tr>
<tr><td><code id="mat.arma_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlations in the correlation matrix, <code>corr</code> say, are calculated 
from the correlation parameters, <code>ARparameters</code>.
The values in 
</p>

<ul>
<li><p> the diagonal (<code>k = 1</code>) of <code>corr</code> are one; 
</p>
</li>
<li><p> the first subdiagonal band (<code>k = 2</code>) of <code>corr</code> 
are equal to <br /> 
<code>ARparameters[1]/(1-ARparameters[2])</code>; 
</p>
</li>
<li><p> in subsequent disgonal bands, (<code>k = 3:order</code>), 
of <code>corr</code> are <br /> 
<code>ARparameters[1]*corr[k-1] + ARparameters[2]*corr[k-2]</code>.</p>
</li></ul>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an arma pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.arma(ARparameter = 0.4, MAparameter = -0.2, order = 4)
</code></pre>

<hr>
<h2 id='mat.banded'>Form a banded matrix from a vector of values</h2><span id='topic+mat.banded'></span>

<h3>Description</h3>

<p>Takes the first value in <code>x</code>  and places it down the diagonal of the 
<code><a href="base.html#topic+matrix">matrix</a></code>. Takes the second value in <code>x</code>  and places it 
down the first subdiagonal, both below and above the diagonal of the 
<code><a href="base.html#topic+matrix">matrix</a></code>.  The third value is placed in the second subdiagonal 
and so on, until the bands for which there are elements in <code>x</code> have 
been filled. All other elements in the <code><a href="base.html#topic+matrix">matrix</a></code> will be zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.banded(x, nrow, ncol)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.banded_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the values for each band from 1 to the 
length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="mat.banded_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows in the banded <code><a href="base.html#topic+matrix">matrix</a></code> being formed.</p>
</td></tr>
<tr><td><code id="mat.banded_+3A_ncol">ncol</code></td>
<td>
<p>The number of columns in the banded <code><a href="base.html#topic+matrix">matrix</a></code> being formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">nrow \times ncol</code> <code><a href="base.html#topic+matrix">matrix</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, 
<code><a href="#topic+mat.sar2">mat.sar2</a></code>, <code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code>
<code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>      m &lt;- mat.banded(c(1,0.6,0.5), 5,5)
      m &lt;- mat.banded(c(1,0.6,0.5), 3,4)
      m &lt;- mat.banded(c(1,0.6,0.5), 4,3)

</code></pre>

<hr>
<h2 id='mat.cor'>Forms a correlation matrix in which all correlations have the same value.</h2><span id='topic+mat.cor'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> in which  
all correlations have the same value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.cor(rho, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.cor_+3A_rho">rho</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the single correlation value.</p>
</td></tr>
<tr><td><code id="mat.cor_+3A_order">order</code></td>
<td>
<p>The order of the correlation <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation <code><a href="base.html#topic+matrix">matrix</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, <code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.cor(rho = 0.4, order = 3)
</code></pre>

<hr>
<h2 id='mat.corg'>Forms a general correlation matrix</h2><span id='topic+mat.corg'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> for which  
all correlations potentially differ.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.corg(rhos, order, byrow = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.corg_+3A_rhos">rhos</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the <code>p(p -1)/2</code> correlation values ordered 
either by columns (if <code>byrow</code> is FALSE) or by rows (if <code>byrow</code> is TRUE).</p>
</td></tr>
<tr><td><code id="mat.corg_+3A_order">order</code></td>
<td>
<p>The order of the correlation <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
<tr><td><code id="mat.corg_+3A_byrow">byrow</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>. If <code>FALSE</code> the lower-traingle of the matrix is filled 
by columns, otherwise the the ower triangle is filled by rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation <code><a href="base.html#topic+matrix">matrix</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>,  <code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.corg(rhos = c(0.4, 0.2, 0.1), order = 3)
</code></pre>

<hr>
<h2 id='mat.dirprod'>Forms the direct product of two matrices</h2><span id='topic+mat.dirprod'></span>

<h3>Description</h3>

<p>Form the direct product of the <code class="reqn">m \times n</code> <code><a href="base.html#topic+matrix">matrix</a></code> 
<b>A</b> and the <code class="reqn">p \times q</code> <code><a href="base.html#topic+matrix">matrix</a></code> <b>B</b>. 
It is also called the Kroneker product and the right direct product. 
It is defined to be the result of replacing each element of 
<b>A</b>, <code class="reqn">a_{ij}</code>, with <code class="reqn">a_{ij}\bold{B}</code>. 
The result <code><a href="base.html#topic+matrix">matrix</a></code> is  <code class="reqn">mp \times nq</code>.
</p>
<p>The method employed uses the <code>rep</code> function to form two 
<code class="reqn">mp \times nq</code> matrices: (i) the direct 
product of <b>A</b> and <b>J</b>, and (ii) the direct product of 
<b>J</b> and <b>B</b>, where each <b>J</b> is a matrix of ones 
whose dimensions are those required to produce an 
<code class="reqn">mp \times nq</code> matrix. Then the 
elementwise product of these two matrices is taken to yield the result.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.dirprod(A, B)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.dirprod_+3A_a">A</code></td>
<td>
<p>The left-hand <code><a href="base.html#topic+matrix">matrix</a></code> in the product.</p>
</td></tr>
<tr><td><code id="mat.dirprod_+3A_b">B</code></td>
<td>
<p>The right-hand <code><a href="base.html#topic+matrix">matrix</a></code> in the product.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">mp \times nq</code> <code><a href="base.html#topic+matrix">matrix</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code>matmult</code>, <code><a href="#topic+mat.dirprod">mat.dirprod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    col.I &lt;- mat.I(order=4)
    row.I &lt;- mat.I(order=28)
    V &lt;- mat.dirprod(col.I, row.I)
</code></pre>

<hr>
<h2 id='mat.dirsum'>Forms the direct sum of a list of matrices</h2><span id='topic+mat.dirsum'></span>

<h3>Description</h3>

<p>The direct sum is the partitioned matrices whose diagonal submatrices are 
the matrices from which the direct sum is to be formed and whose off-diagonal 
submatrices are conformable matrices of zeroes. The resulting 
<code><a href="base.html#topic+matrix">matrix</a></code> is <code class="reqn">m \times n</code>, where <code class="reqn">m</code> is the sum of
the numbers of rows of the contributing matrices and <code class="reqn">n</code> is the sum of
their numbers of columns.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.dirsum(matrices)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.dirsum_+3A_matrices">matrices</code></td>
<td>
<p>A list, each of whose component is a <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">m \times n</code> <code><a href="base.html#topic+matrix">matrix</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.dirprod">mat.dirprod</a></code>, <code>matmult</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>       m1 &lt;- matrix(1:4, nrow=2)
       m2 &lt;- matrix(11:16, nrow=3)
       m3 &lt;- diag(1, nrow=2, ncol=2)
       dsum &lt;- mat.dirsum(list(m1, m2, m3))
</code></pre>

<hr>
<h2 id='mat.exp'>Forms an exponential correlation matrix</h2><span id='topic+mat.exp'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order equal to the length of 
<code>coordinates</code>. The <code><a href="base.html#topic+matrix">matrix</a></code> has diagonal 
elements equal to one and the off-diagonal element in the ith row 
and jth column equal to <code class="reqn">\rho^k</code> where 
<code class="reqn">k = |coordinate[i]- coordinate[j]|</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.exp(rho, coordinates)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.exp_+3A_rho">rho</code></td>
<td>
<p>The correlation for points a distance of one apart.</p>
</td></tr>
<tr><td><code id="mat.exp_+3A_coordinates">coordinates</code></td>
<td>
<p>The coordinates of points whose correlation <code><a href="base.html#topic+matrix">matrix</a></code> 
is to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements depend on the power of the 
absolute distance apart.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, 
<code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code>, 
<code><a href="#topic+mat.gau">mat.gau</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.exp(coordinates=c(3:6, 9:12, 15:18), rho=0.1)
</code></pre>

<hr>
<h2 id='mat.gau'>Forms an exponential correlation matrix</h2><span id='topic+mat.gau'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order equal to the length of 
<code>coordinates</code>. The <code><a href="base.html#topic+matrix">matrix</a></code> has diagonal 
elements equal to one and the off-diagonal element in the ith row 
and jth column equal to <code class="reqn">\rho^k</code> where 
<code class="reqn">k = (coordinate[i]- coordinate[j])^2</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.gau(rho, coordinates)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.gau_+3A_rho">rho</code></td>
<td>
<p>The correlation for points a distance of one apart.</p>
</td></tr>
<tr><td><code id="mat.gau_+3A_coordinates">coordinates</code></td>
<td>
<p>The coordinates of points whose correlation <code><a href="base.html#topic+matrix">matrix</a></code> 
is to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements depend on the power of the 
absolute distance apart.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, 
<code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code>,
<code><a href="#topic+mat.exp">mat.exp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.gau(coordinates=c(3:6, 9:12, 15:18), rho=0.1)
</code></pre>

<hr>
<h2 id='mat.ginv'>Computes the generalized inverse of a matrix</h2><span id='topic+mat.ginv'></span>

<h3>Description</h3>

<p>Computes the Moore-Penrose generalized inverse of a matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ginv(x, tol = .Machine$double.eps ^ 0.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ginv_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> whose generalized inversed is to be computed.</p>
</td></tr>
<tr><td><code id="mat.ginv_+3A_tol">tol</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the relative tolerance to 
determine whether an eigenvalue of <code>x</code> is nonzero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code>. An <code>NA</code> is returned if <code><a href="base.html#topic+svd">svd</a></code> fails 
during the compution of the generalized inverse.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)
## Compute the projector for a linear trend across Blocks
PBIBD2.lay &lt;- within(PBIBD2.lay,
                     {
                       cBlock &lt;- as.numfac(Block)
                       cBlock &lt;- cBlock - mean(unique(cBlock))
                     })
X &lt;- model.matrix(~ cBlock, data = PBIBD2.lay)
Q.cB &lt;- projector((X %*% mat.ginv(t(X) %*% X) %*% t(X)))
</code></pre>

<hr>
<h2 id='mat.I'>Forms a unit matrix</h2><span id='topic+mat.I'></span>

<h3>Description</h3>

<p>Form the unit or identity <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.I(order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.I_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square <code><a href="base.html#topic+matrix">matrix</a></code> whose diagonal elements are one and its off-diagonal 
are zero.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    col.I &lt;- mat.I(order=4)
</code></pre>

<hr>
<h2 id='mat.J'>Forms a square matrix of ones</h2><span id='topic+mat.J'></span>

<h3>Description</h3>

<p>Form the square <code><a href="base.html#topic+matrix">matrix</a></code> of ones of order <code>order</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.J(order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.J_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square <code><a href="base.html#topic+matrix">matrix</a></code> all of whose elements are one.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    col.J &lt;- mat.J(order=4)
</code></pre>

<hr>
<h2 id='mat.ma1'>Forms an ma1 correlation matrix</h2><span id='topic+mat.ma1'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the ma1 pattern. The <code><a href="base.html#topic+matrix">matrix</a></code> is banded and 
has diagonal elements equal to one and subdiagonal element equal to <br /> 
<code>-MAparameter / (1 + MAparameter*MAparameter)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ma1(MAparameter, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ma1_+3A_maparameter">MAparameter</code></td>
<td>
<p>The moving average parameter, being the weight applied to the lag 1 random 
pertubation.</p>
</td></tr>
<tr><td><code id="mat.ma1_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an ma1 pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, 
<code><a href="#topic+mat.sar2">mat.sar2</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.ma1(MAparameter=0.4, order=4)
</code></pre>

<hr>
<h2 id='mat.ma2'>Forms an ma2 correlation matrix</h2><span id='topic+mat.ma2'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the ma2 pattern. The resulting <code><a href="base.html#topic+matrix">matrix</a></code> 
is banded.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ma2(MAparameters, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ma2_+3A_maparameters">MAparameters</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the two moving average parameter values 
of the process, being the weights given to the lag 1 and lag 2 random pertubations.</p>
</td></tr>
<tr><td><code id="mat.ma2_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlations in the correlation matrix, <code>corr</code> say, are calculated 
from the moving average parameters, <code>MAparameters</code>.
The values in 
</p>

<ul>
<li><p> the diagonal (<code>k = 1</code>) of <code>corr</code> are one; 
</p>
</li>
<li><p> the first subdiagonal band (<code>k = 2</code>) of <code>corr</code> 
are equal to <br /> 
<code>-MAparameters[1]*(1 - MAparameters[2]) / div</code>; 
</p>
</li>
<li><p> the second subdiagonal bande (<code>k = 3</code>) of <code>corr</code> 
are equal to <code>-MAparameters[2] / div</code>; 
</p>
</li>
<li><p> in subsequent disgonal bands, (<code>k = 4:order</code>), 
of <code>corr</code> are zero,</p>
</li></ul>

<p>where <code>div = 1 + MMAparameters[1]*MAparameter[1] + MAparameters[2]*MAparameters[2]</code>.</p>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an ma2 pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.exp">mat.exp</a></code>, <code><a href="#topic+mat.gau">mat.gau</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar2">mat.sar2</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.ma2(MAparameters = c(0.4, -0.2), order = 4)
</code></pre>

<hr>
<h2 id='mat.ncssvar'>Calculates the variance matrix of the random effects for a natural 
cubic smoothing spline</h2><span id='topic+mat.ncssvar'></span>

<h3>Description</h3>

<p>Calculates the variance matrix of the random effects for a 
natural cubic smoothing spline. It is the tri-diagonal matrix 
<code class="reqn">\bold{G}_s</code> given by Verbyla et al., (1999) multiplied by 
the variance component for the random spline effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.ncssvar(sigma2s = 1, knot.points, print = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.ncssvar_+3A_sigma2s">sigma2s</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the variance component
for the random spline effects. The smoothing parameter is then the inverse 
of the ratio of this component to the residual variance.</p>
</td></tr>
<tr><td><code id="mat.ncssvar_+3A_knot.points">knot.points</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the values of the knots point 
used in fitting the spline. These must be orderd in increasing order.</p>
</td></tr>
<tr><td><code id="mat.ncssvar_+3A_print">print</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to print the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> containing the variances and covariances of the 
random spline effects.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Verbyla, A. P., Cullis, B. R., Kenward, M. G., and Welham, S. J. (1999). 
The analysis of designed experiments and longitudinal data by using 
smoothing splines (with discussion). <em>Journal of the Royal 
Statistical Society, Series C (Applied Statistics)</em>, <b>48</b>, 269-311.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zncsspline">Zncsspline</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gs &lt;- mat.ncssvar(knot.points = 1:10)
</code></pre>

<hr>
<h2 id='mat.random'>Calculates the variance matrix for the random effects from a mixed model, based  on a supplied formula or a matrix.</h2><span id='topic+mat.random'></span>

<h3>Description</h3>

<p>For <code>n</code> observations, compute the variance matrix of the random effects. 
The <code><a href="base.html#topic+matrix">matrix</a></code> can be specified using a <code><a href="stats.html#topic+formula">formula</a></code> 
for the <code>random</code> effects and a <code><a href="base.html#topic+list">list</a></code> of values of the  
variance components for the terms specified in the <code>random</code> <code><a href="stats.html#topic+formula">formula</a></code>. 
If a  <code><a href="base.html#topic+matrix">matrix</a></code> specifying the variances of 
the nuisance random effects is supplied then it is returned as the value 
from the function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.random(random, G, design, keep.order = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.random_+3A_random">random</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code>. If a 
<code><a href="stats.html#topic+formula">formula</a></code>, it specifies the random effects from which 
the <code><a href="base.html#topic+matrix">matrix</a></code> for the contribution of the random effects 
to the variance matrix can be generated. If it is a <code><a href="base.html#topic+matrix">matrix</a></code>, 
it must be an <code>n x n</code> <code><a href="base.html#topic+matrix">matrix</a></code> and will be passed 
through as the required variance matrix for the random effects. 
The default is 0, which implies that there are no random effects.</p>
</td></tr>
<tr><td><code id="mat.random_+3A_g">G</code></td>
<td>
<p>This term only needs to be set if <code>random</code> is a 
<code><a href="stats.html#topic+formula">formula</a></code>. Then it is set to a <code><a href="base.html#topic+list">list</a></code>, in which 
each component is either a single value or a <code><a href="base.html#topic+matrix">matrix</a></code>; 
there needs to be a component for each term in the expanded 
<code><a href="stats.html#topic+formula">formula</a></code>, with the order of the terms and components 
matching. If it is a single value, a diagonal matrix of dimension 
equal to the product of the numbers of levels of the factors in 
its term. If it is a matrix, its dimension must be equal to the 
product of the numbers of levels of the factors in its term.</p>
</td></tr>
<tr><td><code id="mat.random_+3A_design">design</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the design to be used in an 
experiment and for which the variane matrix is required. It is not required  
when the only <code><a href="stats.html#topic+formula">formula</a></code> specified is an intercept-only 
<code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="mat.random_+3A_keep.order">keep.order</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the terms should keep 
their position in the expanded <code>formula</code> projector, or 
reordered so that main effects precede two-factor 
interactions, which precede three-factor interactions and 
so on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\bold{Z}_i</code> is the is incidence matrix for the <code>random</code> nuisance effects 
in  <code class="reqn">\bold{u}_i</code> for a term in <code>random</code> and <code class="reqn">\bold{u}_i</code> has 
variance matrix  <code class="reqn">\bold{G}_i</code> so that the contribution of the random effectst to 
the variance matrix for <code class="reqn">\bold{Y}</code> is  
<code class="reqn">\bold{V}_u =  \Sigma (\bold{Z}_i\bold{G}_i(\bold{Z}_i)^T)</code>.   
</p>


<h3>Value</h3>

<p>A <code>n x n</code> <code><a href="base.html#topic+matrix">matrix</a></code> containing the variance matrix for the random effects.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.Vpredicts">mat.Vpredicts</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reduced example from Smith et al. (2015)
## Generate two-phase design
mill.fac &lt;- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
field.lay &lt;- fac.gen(list(Frep = 2, Fplot = 4))
field.lay$Variety &lt;- factor(c("D","E","Y","W","G","D","E","M"), 
                            levels = c("Y","W","G","M","D","E"))
start.design &lt;- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
rownames(start.design) &lt;- NULL

## Set gammas
terms &lt;- c("Variety", "Frep", "Frep:Fplot", "Mrep", "Mrep:Mday", "Mrep:Mday:Mord")
gammas &lt;- c(1, 0.1, 0.2, 0.3, 0.2, 1)
names(gammas) &lt;- terms

## Specify matrices to calculate the variance matrix of the predicted fixed Variety effects 
Vu &lt;- with(start.design, fac.vcmat(Mrep, gammas["Mrep"]) + 
                         fac.vcmat(fac.combine(list(Mrep,Mday)), gammas["Mrep:Mday"]) + 
                         fac.vcmat(Frep, gammas["Frep"]) + 
                         fac.vcmat(fac.combine(list(Frep,Fplot)), gammas["Frep:Fplot"]))

## Calculate the variance matrix of the predicted random Variety effects using formulae
Vu &lt;- mat.random(random = ~ -1 + Mrep/Mday + Frep/Fplot, 
                 G = as.list(gammas[c(4,5,2,3)]), 
                 design = start.design)
</code></pre>

<hr>
<h2 id='mat.sar'>Forms an sar correlation matrix</h2><span id='topic+mat.sar'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the sar pattern. The resulting <code><a href="base.html#topic+matrix">matrix</a></code>
is banded. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.sar(SARparameter, order)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.sar_+3A_sarparameter">SARparameter</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the single value of the 
parameter from which the correlations are calculated.</p>
</td></tr>
<tr><td><code id="mat.sar_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the correlations in the correlation matrix, <code>corr</code> say, are calculated 
from the SARparameter, gamma as follows. The values in 
</p>

<ul>
<li><p> the diagonal of <code>corr</code> (<code>k = 1</code>) are one; 
</p>
</li>
<li><p> the first subdiagonal band (<code>k = 2</code>) of <code>corr</code> are equal to 
<code>gamma/(1 + (gamma * gamma / 4))</code>; 
</p>
</li>
<li><p> the subsequent subdiagonal bands, (<code>k = 3:order</code>), of <code>corr</code> are equal to <br />
<code>gamma * corr[k-1] - (gamma * gamma/4) * corr[k-2].</code></p>
</li></ul>



<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an sar pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.exp">mat.exp</a></code>, 
<code><a href="#topic+mat.gau">mat.gau</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, 
<code><a href="#topic+mat.sar2">mat.sar2</a></code>, <code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.sar(SARparameter = -0.4, order = 4)
</code></pre>

<hr>
<h2 id='mat.sar2'>Forms an sar2 correlation matrix</h2><span id='topic+mat.sar2'></span>

<h3>Description</h3>

<p>Form the correlation <code><a href="base.html#topic+matrix">matrix</a></code> of order <code>order</code> whose 
correlations follow the sar2 pattern, a pattern used in crop competition 
models. The resulting <code><a href="base.html#topic+matrix">matrix</a></code>
is banded and is a constrained AR3 matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.sar2(gamma, order, print = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.sar2_+3A_gamma">gamma</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the two values of <code>gamma</code>, being 
parameters linked with spatial dependence and competition.</p>
</td></tr>
<tr><td><code id="mat.sar2_+3A_order">order</code></td>
<td>
<p>The order of the <code><a href="base.html#topic+matrix">matrix</a></code> to be formed.</p>
</td></tr>
<tr><td><code id="mat.sar2_+3A_print">print</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the object to be printed. Currently, 
only the claculated values of the <code>ar3parameters</code> can be printed. 
If NULL, nothing is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the AR3 parameters, phi, are calculated from the gammas as follows: <br />
<code>phi[1] = gamma[1] + 2 * gamma[2]</code>; <code>phi[2] = -gamma[2] * (2*gamma[2] + gamma[1])</code>; <br />
<code>phi[3] = gamma[1] * gamma[2] * gamma[2]</code>.
</p>
<p>Then the correlations in the correlation matrix, <code>corr</code> say, are calculated 
from the correlation parameters, phi.
Let <code>omega = 1 - phi[2] - phi[3] * (phi[1] + phi[3])</code>. 
Then the values in 
</p>

<ul>
<li><p> the diagonal of <code>corr</code> (<code>k = 1</code>) are one; 
</p>
</li>
<li><p> the first subdiagonal band (<code>k = 2</code>) of <code>corr</code> are equal to 
<code>(phi[1] + phi[2]*phi[3]) / omega</code>; 
</p>
</li>
<li><p> the second subdiagonal band (<code>k = 3</code>) of <code>corr</code> are equal to <br />
<code>(phi[1] * (phi[1] + phi[3]) + phi[2] * (1 - phi[2])) / omega</code>; 
</p>
</li>
<li><p> the subsequent subdiagonal bands, (<code>k = 4:order</code>), of <code>corr</code> are equal to <br />
<code>phi[1]*corr[k-1] + phi[2]*corr[k-2] + phi[3]*corr[k-3]</code>.</p>
</li></ul>


<h3>Value</h3>

<p>A banded correlation <code><a href="base.html#topic+matrix">matrix</a></code> whose elements follow an sar2 pattern.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.I">mat.I</a></code>, <code><a href="#topic+mat.J">mat.J</a></code>, <code><a href="#topic+mat.cor">mat.cor</a></code>, <code><a href="#topic+mat.corg">mat.corg</a></code>, 
<code><a href="#topic+mat.banded">mat.banded</a></code>, <code><a href="#topic+mat.exp">mat.exp</a></code>, 
<code><a href="#topic+mat.gau">mat.gau</a></code>, <code><a href="#topic+mat.ar1">mat.ar1</a></code>, <code><a href="#topic+mat.ar2">mat.ar2</a></code>, <code><a href="#topic+mat.ar3">mat.ar3</a></code>, <code><a href="#topic+mat.sar">mat.sar</a></code>, 
<code><a href="#topic+mat.ma1">mat.ma1</a></code>, <code><a href="#topic+mat.ma2">mat.ma2</a></code>, <code><a href="#topic+mat.arma">mat.arma</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    corr &lt;- mat.sar2(gamma = c(-0.4, 0.2), order = 4)
    corr &lt;- mat.sar2(gamma = c(-0.4, 0.2), order = 4, print = "ar3")
</code></pre>

<hr>
<h2 id='mat.Vpred'>Calculates the variances of a set of predicted effects from a mixed model</h2><span id='topic+mat.Vpred'></span>

<h3>Description</h3>

<p>For <code>n</code> observations, <code>w</code> effects to be predicted, 
<code>f</code> nuiscance fixed effects and <code>r</code> nuisance random effects, 
the variances of a set of predicted effects is calculated using  
the incidence matrix for the effects to be predicted and, optionally, 
a variance matrix of the effects, an incidence matrix for the 
nuisance fixed factors and covariates, the variance matrix of the nuisance 
random effects in the mixed model and the residual variance matrix.
</p>
<p>This function has been superseded by <code><a href="#topic+mat.Vpredicts">mat.Vpredicts</a></code>, which 
allows the use of both matrices and <code><a href="stats.html#topic+formula">formula</a></code>e.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.Vpred(W, Gg = 0, X = matrix(1, nrow = nrow(W), ncol = 1), Vu = 0, R, eliminate)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.Vpred_+3A_w">W</code></td>
<td>
<p>The <code>n x w</code> incidence <code><a href="base.html#topic+matrix">matrix</a></code> for the <code>w</code> effects 
to be predicted.</p>
</td></tr>
<tr><td><code id="mat.Vpred_+3A_gg">Gg</code></td>
<td>
<p>The <code>w x w</code> variance <code><a href="base.html#topic+matrix">matrix</a></code> of the <code>w</code> effects 
to be predicted. 
If the effects to be predicted are fixed, set to 0.</p>
</td></tr>
<tr><td><code id="mat.Vpred_+3A_x">X</code></td>
<td>
<p>The <code>n x f</code> incidence <code><a href="base.html#topic+matrix">matrix</a></code> for the <code>f</code> nuisance 
fixed factors and covariates. The default is a column vector of ones.</p>
</td></tr>
<tr><td><code id="mat.Vpred_+3A_vu">Vu</code></td>
<td>
<p>The <code>n x r</code> variance <code><a href="base.html#topic+matrix">matrix</a></code> of the <code>r</code> nuisance 
random effects. If there are none, set to zero.</p>
</td></tr>
<tr><td><code id="mat.Vpred_+3A_r">R</code></td>
<td>
<p>The residual variance <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="mat.Vpred_+3A_eliminate">eliminate</code></td>
<td>
<p>The <code>n x n</code> <code><a href="#topic+projector">projector</a></code> onto the subspace 
corresponding to the effects to be eliminated from the information matrix 
prior to inverting it to form the variance <code><a href="base.html#topic+matrix">matrix</a></code> of the 
predicted effects. It is only appropriate to use this option when the 
effects to be predicted are fixed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly the information matrix is calculated as <br />
<code>A &lt;- t(W) %*% Vinv %*% W + ginv(Gg) - A%*%ginv(t(X)%*%Vinv%*%X)%*%t(A)</code>, 
where <code>Vinv &lt;- ginv(Vu + R)</code>, <code>A = t(W) %*% Vinv %*% X</code> and ginv(B) is the unique Moore-Penrose inverse of B formed using the eigendecomposition of B.
</p>
<p>If <code>eliminate</code> is set and the effects to be predicted are fixed then the reduced information matrix is calculated as <code>A &lt;- (I - eliminate) Vinv (I - eliminate)</code>.
</p>
<p>Finally, the variance of the predicted effects is calculated: <code>Vpred &lt;- ginv(A)</code>.</p>


<h3>Value</h3>

<p>A <code>w x w</code> <code><a href="base.html#topic+matrix">matrix</a></code> containing the variances and covariances of the 
predicted effects.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Smith, A. B., D. G. Butler, C. R. Cavanagh and B. R. Cullis (2015). 
Multi-phase variety trials using both composite and individual replicate 
samples: a model-based design approach. 
<em>Journal of Agricultural Science</em>, <b>153</b>, 1017-1029.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designAmeasures">designAmeasures</a></code>, <code><a href="#topic+mat.Vpredicts">mat.Vpredicts</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reduced example from Smith et al. (2015)
## Generate two-phase design
mill.fac &lt;- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
field.lay &lt;- fac.gen(list(Frep = 2, Fplot = 4))
field.lay$Variety &lt;- factor(c("D","E","Y","W","G","D","E","M"), 
                            levels = c("Y","W","G","M","D","E"))
start.design &lt;- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
rownames(start.design) &lt;- NULL

## Set up matrices
n &lt;- nrow(start.design)
W &lt;- model.matrix(~ -1+ Variety, start.design)
ng &lt;- ncol(W)
Gg&lt;- diag(1, ng)
Vu &lt;- with(start.design, fac.vcmat(Mrep, 0.3) + 
                         fac.vcmat(fac.combine(list(Mrep, Mday)), 0.2) + 
                         fac.vcmat(Frep, 0.1) + 
                         fac.vcmat(fac.combine(list(Frep, Fplot)), 0.2))
R &lt;- diag(1, n)
  
## Calculate the variance matrix of the predicted random Variety effects
Vp &lt;- mat.Vpred(W = W, Gg = Gg, Vu = Vu, R = R)
designAmeasures(Vp)

## Calculate the variance matrix of the predicted fixed Variety effects, 
## elminating the grand mean
Vp.reduc &lt;- mat.Vpred(W = W, Gg = 0, Vu = Vu, R = R, 
                      eliminate = projector(matrix(1, nrow = n, ncol = n)/n))
designAmeasures(Vp.reduc)
</code></pre>

<hr>
<h2 id='mat.Vpredicts'>Calculates the variances of a set of predicted effects from a mixed model, based  on supplied matrices or formulae.</h2><span id='topic+mat.Vpredicts'></span>

<h3>Description</h3>

<p>For <code>n</code> observations, <code>w</code> effects to be predicted, 
<code>f</code> nuiscance fixed effects, <code>r</code> nuisance random effects and 
<code>n</code> residuals, 
the variances of a set of predicted effects is calculated using the   
incidence matrix for the effects to be predicted and, optionally, 
a variance matrix of these effects, an incidence matrix for the 
nuisance fixed factors and covariates, the variance matrix of the 
nuisance random effects and the residual variance matrix. 
The <code><a href="base.html#topic+matrix">matrices</a></code> can be supplied directly or 
using <code><a href="stats.html#topic+formula">formula</a></code>e 
and a  <code><a href="base.html#topic+matrix">matrix</a></code> specifying the variances of 
the nuisance random effects. The difference between 
<code>mat.Vpredicts</code> and <code><a href="#topic+mat.Vpred">mat.Vpred</a></code> is that the 
former has different names for equivalent arguments and the latter 
does not allow for the use of <code><a href="stats.html#topic+formula">formula</a></code>e.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.Vpredicts(target, Gt = 0, fixed = ~ 1, random, G, R, design, 
              eliminate, keep.order = TRUE, result = "variance.matrix")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.Vpredicts_+3A_target">target</code></td>
<td>
<p>The <code>n x w</code> incidence <code><a href="base.html#topic+matrix">matrix</a></code> for the <code>w</code> 
effects targetted for prediction, or a <code><a href="stats.html#topic+formula">formula</a></code> from which 
the <code><a href="base.html#topic+matrix">matrix</a></code> can be generated.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_gt">Gt</code></td>
<td>
<p>The value of the variance component for the targetted effects or the 
<code>w x w</code> variance <code><a href="base.html#topic+matrix">matrix</a></code> of the <code>w</code> targetted 
effects. If the targetted effects are fixed, set <code>Gt</code> to 0.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_fixed">fixed</code></td>
<td>
<p>The <code>n x f</code> incidence <code><a href="base.html#topic+matrix">matrix</a></code> for the <code>f</code> 
nuisance fixed effects and covariates, or a <code><a href="stats.html#topic+formula">formula</a></code> from 
which the <code><a href="base.html#topic+matrix">matrix</a></code> can be generated. The default is a 
<code><a href="stats.html#topic+formula">formula</a></code> for an intercept-only model.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_random">random</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> or a <code><a href="base.html#topic+matrix">matrix</a></code>. If a 
<code><a href="stats.html#topic+formula">formula</a></code>, it specifies the random effects from which 
the <code><a href="base.html#topic+matrix">matrix</a></code> for the contribution of the random effects 
to the variance matrix can be generated. If it is a matrix, it must be an 
<code>n x n</code> <code><a href="base.html#topic+matrix">matrix</a></code> and will be passed on to form the variance 
matrix of the observations. The default is 0, which 
implies that there are no random effects.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_g">G</code></td>
<td>
<p>This term only needs to be set if <code>random</code> is a 
<code><a href="stats.html#topic+formula">formula</a></code>. Then it is set to a <code><a href="base.html#topic+list">list</a></code>, in which 
each component is either a single value or a <code><a href="base.html#topic+matrix">matrix</a></code>; 
there needs to be a component for each term in the expanded 
<code><a href="stats.html#topic+formula">formula</a></code>, with the order of the terms and components 
matching. If it is a single value, a diagonal matrix of dimension 
equal to the product of the numbers of levels of the factors in 
its term. If it is a matrix, its dimension must be equal to the 
product of the numbers of levels of the factors in its term.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_r">R</code></td>
<td>
<p>The <code>n x n</code> residual variance <code><a href="base.html#topic+matrix">matrix</a></code>. If <code>R</code> is 
not set in the call, then it is set to the identity <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_design">design</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the design to be used in an 
experiment from which predictions are to be obtained. It is not required  
when the only <code><a href="stats.html#topic+formula">formula</a></code> specified is an intercept-only 
<code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_eliminate">eliminate</code></td>
<td>
<p>The <code>n x n</code> <code><a href="#topic+projector">projector</a></code> onto the subspace 
corresponding to the effects to be eliminated from the information matrix 
prior to inverting it to form the variance <code><a href="base.html#topic+matrix">matrix</a></code> of the 
predicted effects. It is only appropriate to use this option when the 
effects to be predicted are fixed.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_keep.order">keep.order</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the terms should keep 
their position in the expanded <code>formula</code> projector, or 
reordered so that main effects precede two-factor 
interactions, which precede three-factor interactions and 
so on.</p>
</td></tr>
<tr><td><code id="mat.Vpredicts_+3A_result">result</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> indicating which matrix is to be returned: <code>variance.matrix</code> or <code>information.matrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixed model for which the predictions are to be obtained is of the form 
<code class="reqn">\bold{Y} = \bold{X\beta} + \bold{Ww} + \bold{Zu} + \bold{e}</code>, 
where   <code class="reqn">\bold{W}</code> is the incidence matrix for the <code>target</code> predicted 
effects  <code class="reqn">\bold{w}</code>,  <code class="reqn">\bold{X}</code> is the is incidence matrix for the 
<code>fixed</code> nuisance effects <code class="reqn">\bold{\beta}</code>,  <code class="reqn">\bold{Z}</code> is the 
is incidence matrix for the <code>random</code> nuisance effects  <code class="reqn">\bold{u}</code>, 
<code class="reqn">\bold{e}</code> are the residuals; the  <code class="reqn">\bold{u}</code> are assumed 
to have variance matrix  <code class="reqn">\bold{G}</code> so that their contribution to the 
variance matrix for <code class="reqn">\bold{Y}</code> is  
<code class="reqn">\bold{Vu} = \bold{ZGZ}^T</code> and <code class="reqn">\bold{e}</code> 
is assumed to have variance matrix <code class="reqn">\bold{R}</code>. 
If the <code>target</code> effects are random then the variance matrix for 
<code class="reqn">\bold{w}</code> is <code class="reqn">\bold{G}_t</code> so that their 
contribution to the variance matrix for <code class="reqn">\bold{Y}</code> is 
<code class="reqn">\bold{WG}_t\bold{W}^T</code>.   
</p>
<p>As described in Hooks et al. (2009, Equation 19), the information matrix is 
calculated as <br />
<code>A &lt;- t(W) %*% Vinv %*% W + ginv(Gg) - A%*%ginv(t(X)%*%Vinv%*%X)%*%t(A)</code>, 
where <code>Vinv &lt;- ginv(Vu + R)</code>, <code>A = t(W) %*% Vinv %*% X</code> 
and ginv(B) is the unique Moore-Penrose inverse of B formed using the 
eigendecomposition of B.
</p>
<p>Then, if <code>eliminate</code> is set and the effects to be predicted are 
fixed then the reduced information matrix is calculated as 
<code>A &lt;- (I - eliminate) Vinv (I - eliminate)</code>.
</p>
<p>Finally, if <code>result</code> is set to <code>variance.matrix</code>,  the variance of the predicted effects is calculated: 
<code>Vpred &lt;- ginv(A)</code> and returned; otherwise the information matrix A is returned. The rank of the matrix to be returned is obtain via a singular value decomposition of the information matrix, it being the number of nonzero eigenvalues. An eigenvalue is regarded as zero if it is less than 
<code>daeTolerance</code>, which is initially set to.Machine$double.eps ^ 0.5 (about 1.5E-08). The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>A <code>w x w</code> <code><a href="base.html#topic+matrix">matrix</a></code> containing the variances and covariances of the 
predicted effects or the information matrix for the effects, depending on the setting of <code>result</code>. The matrix has its rank as an attribute.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Hooks, T., Marx, D., Kachman, S., and Pedersen, J. (2009). Optimality 
criteria for models with random effects. <em>Revista Colombiana de 
Estadistica</em>, <b>32</b>, 17-31. 
</p>
<p>Smith, A. B., D. G. Butler, C. R. Cavanagh and B. R. Cullis (2015). 
Multi-phase variety trials using both composite and individual replicate 
samples: a model-based design approach. 
<em>Journal of Agricultural Science</em>, <b>153</b>, 1017-1029.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designAmeasures">designAmeasures</a></code>, <code><a href="#topic+mat.random">mat.random</a></code>, <code><a href="#topic+mat.Vpred">mat.Vpred</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reduced example from Smith et al. (2015)
## Generate two-phase design
mill.fac &lt;- fac.gen(list(Mrep = 2, Mday = 2, Mord = 3))
field.lay &lt;- fac.gen(list(Frep = 2, Fplot = 4))
field.lay$Variety &lt;- factor(c("D","E","Y","W","G","D","E","M"), 
                            levels = c("Y","W","G","M","D","E"))
start.design &lt;- cbind(mill.fac, field.lay[c(3,4,5,8,1,7,3,4,5,8,6,2),])
rownames(start.design) &lt;- NULL

## Set gammas
terms &lt;- c("Variety", "Frep", "Frep:Fplot", "Mrep", "Mrep:Mday", "Mrep:Mday:Mord")
gammas &lt;- c(1, 0.1, 0.2, 0.3, 0.2, 1)
names(gammas) &lt;- terms

## Specify matrices to calculate the variance matrix of the predicted fixed Variety effects 
W &lt;- model.matrix(~ -1 + Variety, start.design)
Vu &lt;- with(start.design, fac.vcmat(Mrep, gammas["Mrep"]) + 
                         fac.vcmat(fac.combine(list(Mrep,Mday)), gammas["Mrep:Mday"]) + 
                         fac.vcmat(Frep, gammas["Frep"]) + 
                         fac.vcmat(fac.combine(list(Frep,Fplot)), gammas["Frep:Fplot"]))
R &lt;- diag(1, nrow(start.design))
  
## Calculate variance matrix
Vp &lt;- mat.Vpredicts(target = W, random=Vu, R=R, design = start.design)

## Calculate the variance matrix of the predicted random Variety effects using formulae
Vp &lt;- mat.Vpredicts(target = ~ -1 + Variety, Gt = 1, 
                    fixed = ~ 1, 
                    random = ~ -1 + Mrep/Mday + Frep/Fplot, 
                    G = as.list(gammas[c(4,5,2,3)]), 
                    R = R, design = start.design)
designAmeasures(Vp)

## Calculate the variance matrix of the predicted fixed Variety effects, 
## elminating the grand mean
n &lt;- nrow(start.design)
Vp.reduc &lt;- mat.Vpredicts(target = ~ -1 + Variety, 
                          random = ~ -1 + Mrep/Mday + Frep/Fplot, 
                          G = as.list(gammas[c(4,5,2,3)]), 
                          eliminate = projector(matrix(1, nrow = n, ncol = n)/n), 
                          design = start.design)
designAmeasures(Vp.reduc)
</code></pre>

<hr>
<h2 id='McIntyreTMV.dat'>The design and data from McIntyre's (1955) two-phase experiment</h2><span id='topic+McIntyreTMV.dat'></span>

<h3>Description</h3>

<p>McIntyre (1955) reports an investigation of the effect of four light intensities on the synthesis of tobacco mosaic virus in leaves of tobacco <em>Nicotiana tabacum</em> var. Hickory Pryor. It is a two-phase experiment: the first phase is a treatment phase, in which the four light treatments are randomized to the tobacco leaves, and the second phase is an assay phase, in which the tobacco leaves are randomized to the half-leaves of assay plants. For more details see the vignette accessed via <code>vignette("DesignNotes", package="dae")</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(McIntyreTMV.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 196 observations of 4 variables.</p>


<h3>Source</h3>

<p>McIntyre, G. A. (1955) Design and Analysis of Two Phase Experiments. <em>Biometrics</em>, <b>11</b>, 324&ndash;334.</p>

<hr>
<h2 id='meanop'>computes the projection matrix that produces means</h2><span id='topic+meanop'></span>

<h3>Description</h3>

<p>Replaced by <code><a href="#topic+fac.meanop">fac.meanop</a></code>.</p>

<hr>
<h2 id='mpone'>Converts the first two levels of a factor into the numeric values
-1 and +1</h2><span id='topic+mpone'></span>

<h3>Description</h3>

<p>Converts the first two <code>levels</code> of a <code><a href="base.html#topic+factor">factor</a></code> into the numeric
values -1 and +1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpone(factor)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpone_+3A_factor">factor</code></td>
<td>
<p>The <code><a href="base.html#topic+factor">factor</a></code> to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>vector</code>.</p>


<h3>Warning</h3>

<p>If the <code><a href="base.html#topic+factor">factor</a></code> has more than two <code>levels</code> they will 
be coerced to numeric values.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpone">mpone</a></code> in package <span class="pkg">dae</span>, <code><a href="base.html#topic+factor">factor</a></code>, 
<code><a href="stats.html#topic+relevel">relevel</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate all combinations of two two-level factors
mp &lt;- c("-", "+")
Frf3.trt &lt;- fac.gen(list(A = mp, B = mp))

## add factor C, whose levels are the products of the levles of A and B
Frf3.trt$C &lt;- factor(mpone(Frf3.trt$A)*mpone(Frf3.trt$B), labels = mp)
</code></pre>

<hr>
<h2 id='no.reps'>Computes the number of replicates for an experiment</h2><span id='topic+no.reps'></span>

<h3>Description</h3>

<p>Computes the number of pure replicates required in an experiment
to achieve a specified power.</p>


<h3>Usage</h3>

<pre><code class='language-R'>no.reps(multiple=1., df.num=1.,
        df.denom=expression((df.num + 1.) * (r - 1.)), delta=1.,
        sigma=1., alpha=0.05, power=0.8, tol=0.1, print=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no.reps_+3A_multiple">multiple</code></td>
<td>
<p>The multiplier, m, which when multiplied by the number of
pure replicates of a treatment, r, gives the number of
observations rm used in computing means for some, not
necessarily proper, subset of the treatment factors;
m is the replication arising from other treatment factors.
However, for single treatment factor experiments the
subset can only be the treatment factor and m = 1.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_df.num">df.num</code></td>
<td>
<p>The degrees of freedom of the numerator of the F for testing
the term involving the treatment factor subset.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_df.denom">df.denom</code></td>
<td>
<p>The degrees of freedom of the denominator of the F for
testing the term involving the treatment factor subset.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_delta">delta</code></td>
<td>
<p>The true difference between a pair of means for some, not
necessarily proper, subset of the treatment factors.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_sigma">sigma</code></td>
<td>
<p>The population standard deviation.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to be used.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_power">power</code></td>
<td>
<p>The minimum power to be achieved.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_tol">tol</code></td>
<td>
<p>The maximum difference tolerated between the power required and
the power computed in determining the number of replicates.</p>
</td></tr>
<tr><td><code id="no.reps_+3A_print">print</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to have or not have a table of power 
calculation details printed out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code>nreps</code>, a single <code>numeric</code> value containing the computed number of pure replicates, and <code>power</code>, a single <code>numeric</code> value containing the power for the computed number of pure replicates.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.exp">power.exp</a></code>, <code><a href="#topic+detect.diff">detect.diff</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute the number of replicates (blocks) required for a randomized 
## complete block design with four treatments. 
no.reps(multiple = 1, df.num = 3,
        df.denom = expression(df.num * (r - 1)), delta = 5,
	        sigma = sqrt(20), print = TRUE)
</code></pre>

<hr>
<h2 id='Oats.dat'>Data for an experiment to investigate nitrogen response of 3 oats varieties</h2><span id='topic+Oats.dat'></span>

<h3>Description</h3>

<p>Yates (1937) describes a split-plot experiment that investigates the effects of three varieties of oats and four levels of Nitrogen fertilizer. The varieties are assigned to the main plots using a randomized complete block design with 6 blocks and the nitrogen levels are randomly assigned  to the subplots in each main plot.
</p>
<p>The columns in the data frame are: Blocks, Wplots, Subplots, Variety, Nitrogen, xNitrogen, Yield. The column xNitrogen is a numeric version of the factor Nitrogen.
The response variable is Yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Oats.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 72 observations of 7 variables.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Source</h3>

<p>Yates, F. (1937). The Design and Analysis of Factorial Experiments. <em>Imperial Bureau of Soil Science, Technical Communication</em>, <b>35</b>, 1-95. 
</p>

<hr>
<h2 id='p2canon.object'>Description of a p2canon object</h2><span id='topic+p2canon.object'></span>

<h3>Description</h3>

<p>An object of class <code>p2canon</code> that contains information derived from two 
<code>formulae</code> using <code><a href="#topic+projs.2canon">projs.2canon</a></code>.</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>p2canon</code>. It has two components: <code>decomp</code> and 
<code>aliasing</code>. The <code>decomp</code> component iscomposed as follows:
</p>

<ul>
<li><p> It has a component for each component of <code>Q1</code>. 
</p>
</li>
<li><p> Each of the components for <code>Q1</code> is a <code>list</code>; 
each of these <code>lists</code> has one component for each of 
<code>Q2</code> and a component <code>Pres</code>. 
</p>
</li>
<li><p> Each of the <code>Q2</code> components is a <code>list</code> of three 
components: <code>pairwise</code>, <code>adjusted</code> and <code>Qproj</code>. 
These components are  based on an eigenalysis of the 
relationship between the projectors for the parent <code>Q1</code> 
and <code>Q2</code> components. 
</p>

<ol>
<li><p> Each <code>pairwise</code> component is based on the nonzero 
canonical efficiency factors for the joint decomposition of 
the two parent projectors (see <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>). 
</p>
</li>
<li><p> An <code>adjusted</code> component is based on the nonzero 
canonical efficiency factors for the joint decomposition of 
the <code>Q1</code> component and the <code>Q2</code> component, 
the latter adjusted for all <code>Q2</code> projectors that have 
occured previously in the <code>list</code>. 
</p>
</li>
<li><p> The <code>Qproj</code> component is the adjusted projector for the 
parent <code>Q2</code> component.
</p>
</li></ol>
 
</li>
<li><p> The <code>pairwise</code> and <code>adjusted</code> components have the 
following components: <code>efficiencies</code>, <code>aefficiency</code>, 
<code>mefficiency</code>, <code>sefficiency</code>, <code>eefficiency</code>, 
<code>xefficiency</code>, <code>order</code> and <code>dforthog</code> 
&ndash; for details see <code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>.
</p>
</li></ul>

<p>The <code>aliasing</code> component is a data.frame decribing the aliasing between 
terms corresponding to two <code>Q2</code> projectors when estimated in subspaces 
corresponding to a <code>Q1</code> projector.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+projs.2canon">projs.2canon</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code>, <code><a href="#topic+pcanon.object">pcanon.object</a></code>.</p>

<hr>
<h2 id='pcanon.object'>Description of a pcanon object</h2><span id='topic+pcanon.object'></span>

<h3>Description</h3>

<p>An object of class <code>pcanon</code> that contains information derived from several 
<code>formulae</code> using <code><a href="#topic+designAnatomy">designAnatomy</a></code>.</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>pcanon</code> that has four components: (i) <code>Q</code>, 
(ii) <code>terms</code>, (iii) <code>sources</code>, (iv) <code>marginality</code>, and (v) <code>aliasing</code>. 
Each component is a <code>list</code> with as many components as there 
are  formulae in the <code>formulae</code> <code>list</code> supplied to <code><a href="#topic+designAnatomy">designAnatomy</a></code>.
</p>
<p>The <code>Q</code> <code>list</code> is made up of the following components:
</p>

<ol>
<li><p> The first component is the joint decomposition of two 
structures derived from the first two formulae, being the 
<code><a href="#topic+p2canon.object">p2canon.object</a></code> produced by <code><a href="#topic+projs.2canon">projs.2canon</a></code>. 
</p>
</li>
<li><p> Then there is a component for each further formulae; it contains 
the <code><a href="#topic+p2canon.object">p2canon.object</a></code> obtained by applying 
<code><a href="#topic+projs.2canon">projs.2canon</a></code> to the structure for a formula and 
the already established joint decomposition of the structures 
for the previous formulae in the <code>formulae</code>. 
</p>
</li>
<li><p> The last component contains the the <code>list</code> of the 
projectors that give the combined canonical decomposition derived from 
all of the <code>formulae</code>. 
</p>
</li></ol>

<p>The <code>terms</code>, <code>sources</code>, <code>marginalty</code> and <code>aliasing</code> 
<code><a href="base.html#topic+list">list</a></code>s  have a component for each <code><a href="stats.html#topic+formula">formula</a></code> in the  
<code>formulae</code> argument to <code><a href="#topic+designAnatomy">designAnatomy</a></code>, 
Each component of the <code>terms</code> and <code>sources</code> <code><a href="base.html#topic+list">list</a></code>s  has 
a <code><a href="base.html#topic+character">character</a></code> vector containing the terms or sources derived from its 
<code><a href="stats.html#topic+formula">formula</a></code>. For the <code>marginality</code> component, each component is the 
marginality <code><a href="base.html#topic+matrix">matrix</a></code> for the <code>terms</code> derived from its 
<code><a href="stats.html#topic+formula">formula</a></code>. For the <code>aliasing</code> component, each component is the 
aliasing <code><a href="base.html#topic+data.frame">data.frame</a></code> for the <code>source</code> derived from its 
<code><a href="stats.html#topic+formula">formula</a></code>. The components of these four <code><a href="base.html#topic+list">list</a></code>s  are 
produced by <code><a href="#topic+pstructure.formula">pstructure.formula</a></code> and are copied from the 
<code><a href="#topic+pstructure.object">pstructure.object</a></code> for the <code><a href="stats.html#topic+formula">formula</a></code>.
The names of the components of these four lists will be the names of the components 
in the <code>formulae</code> list.
</p>
<p>The object has the attribute <code>labels</code>, which is set to <code>"terms"</code> or 
<code>"sources"</code> according to which of these were used to label the projectors 
when the object was created.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+designAnatomy">designAnatomy</a></code>, <code><a href="#topic+p2canon.object">p2canon.object</a></code>.</p>

<hr>
<h2 id='porthogonalize.list'>Takes a list of <code><a href="#topic+projector">projector</a>s</code> and constructs a <code><a href="#topic+pstructure.object">pstructure.object</a></code> that includes projectors, each of which has been orthogonalized to all projectors preceding it in the list.</h2><span id='topic+porthogonalize.list'></span><span id='topic+porthogonalize'></span>

<h3>Description</h3>

<p>Constructs a <code><a href="#topic+pstructure.object">pstructure.object</a></code> that includes a 
set of mutually orthogonal projectors, one for each of the 
<code><a href="#topic+projector">projector</a>s</code> in the <code><a href="base.html#topic+list">list</a></code>. 
These specify a structure, or an orthogonal decomposition of the 
data space. This function externalizes the process previously performed 
within <code><a href="#topic+pstructure.formula">pstructure.formula</a></code> to orthogonalize 
<code><a href="#topic+projector">projector</a></code>s. There are three methods 
available for carrying out orthogonalization: <code>differencing</code>, 
<code>eigenmethods</code> or the default <code>hybrid</code> method. 
</p>
<p>It is possible to use this function to find out what sources 
are associated with the terms in a model and to determine the 
marginality between terms in the model. The marginality matrix 
can be saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
porthogonalize(projectors, formula = NULL, keep.order = TRUE, 
               grandMean = FALSE, orthogonalize = "hybrid", labels = "sources", 
               marginality = NULL, check.marginality = TRUE, 
               omit.projectors = FALSE, 
               which.criteria = c("aefficiency","eefficiency","order"), 
               aliasing.print = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="porthogonalize.list_+3A_projectors">projectors</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> each of whose components is a <code><a href="#topic+projector">projector</a></code>.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code> from which the 
<code><a href="#topic+projector">projector</a>s</code> have been obtained. If <code>NULL</code>, then 
the <code>differencing</code> option of <code>orthogonalize</code> is not available.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_keep.order">keep.order</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the terms should keep 
their position in the expanded <code>formula</code> projector, or 
reordered so that main effects precede two-factor 
interactions, which precede three-factor interactions and 
so on.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_grandmean">grandMean</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the projector for the 
grand mean is to be included in the set produced.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_orthogonalize">orthogonalize</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector indicating the method for orthogonalizing a 
projector to those for terms that occurred previously 
in the formula. Three options are available:  
<code>hybrid</code>; <code>differencing</code>; <code>eigenmethods</code>, 
unless <code>formula</code> is <code>NULL</code> in which case 
<code>differencing</code> is not available.
The <code>hybrid</code> option is the most general and uses the 
relationships between the projection operators for the 
terms in the <code>formula</code> to decide which 
<code><a href="#topic+projector">projector</a></code>s to substract and which to 
orthogonalize using eigenmethods. The <code>differencing</code> 
option subtracts, from the current <code><a href="#topic+projector">projector</a></code>, 
those previously orthogonalized <code><a href="#topic+projector">projector</a></code>s for 
terms whose factors are a subset of the current 
<code><a href="#topic+projector">projector</a></code>'s factors. The <code>eigenmethods</code> 
option recursively orthogonalizes the <code><a href="#topic+projector">projector</a></code>s 
using an eigenanalysis of each <code><a href="#topic+projector">projector</a></code> 
with previously orthogonalized <code><a href="#topic+projector">projector</a></code>s.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_labels">labels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating the type of labels to be used in 
labelling the projectors, and which will be used also 
in the output tables, such the tables of the aliasing 
in the structure. The two alternatives are <code>terms</code> and 
<code>sources</code>. Terms have all factors/variables in it 
separated by colons (<code>:</code>). Sources have factors/variables 
in them that represent interactions separated by hashes 
(<code>#</code>); if some factors are nested within others, the 
nesting factors are surrounded by square brackets 
(<code>[</code> and <code>]</code>) and separated by colons (<code>:</code>). 
If some generalized, or combined, factors have no marginal 
terms, the constituent factors are separated by colons 
(<code>:</code>) and if they interact with other factors in 
the source they will be parenthesized.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_marginality">marginality</code></td>
<td>
<p>A square <code><a href="base.html#topic+matrix">matrix</a></code> that can be used to supply the 
marginality <code><a href="base.html#topic+matrix">matrix</a></code> when it is desired to overwrite 
the calculated marginality <code><a href="base.html#topic+matrix">matrix</a></code> or when it is not 
being calculated. It should consist of zeroes and ones that 
gives the marginalites of the terms in the formula. It must have 
the row and column names set to the terms from the expanded 
<code>formula</code>, including being in the same order as these terms. 
</p>
<p>The entry in the ith row and jth column will be one if the 
ith term is marginal to the jth term i.e. the column space of the 
ith term is a subspace of that for the jth term and so the source 
for the jth term is to be made orthogonal to that for the ith term. 
Otherwise, the entries are zero. A row and column should not be 
included for the grand mean even if <code>grandMean</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_check.marginality">check.marginality</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the marginality matrix, 
when it is supplied, is to be checked against that computed 
by <code><a href="#topic+porthogonalize.list">porthogonalize.list</a></code>. It is ignored when 
<code>orthogonalize</code> is set to <code>eigenmethods</code>.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_omit.projectors">omit.projectors</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>, which, if <code>TRUE</code>, 
results in the <code><a href="#topic+projector">projector</a></code>s in the <code>Q</code> of the 
<code>pstructure.object</code> being replaced by their degrees of freedom. 
These will be the degrees of freedom of the sources. 
This option is included a device for saving storage when the 
<code><a href="#topic+projector">projector</a></code>s are not required for further analysis.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A character <code>vector</code> nominating the efficiency 
criteria to be included in the summary of aliasing 
between terms. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>, 
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>. 
If <code>none</code>, no summary is printed.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_aliasing.print">aliasing.print</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the aliasing between sources 
within the structure is to be printed.</p>
</td></tr>
<tr><td><code id="porthogonalize.list_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>terms</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is envisaged that the <code><a href="#topic+projector">projector</a>s</code> in the <code><a href="base.html#topic+list">list</a></code> 
supplied to the <code>projectors</code> argument correspond to the terms in a 
linear model. One way to generate them is to obtain the design matrix <b>X</b> 
for a term and then calculate its projector as 
<code class="reqn">\mathbf{X(X'X)^-X'}</code>, There are three methods available for 
orhtogonalizing the supplied projectors: <code>differencing</code>, 
<code>eigenmethods</code> or the default <code>hybrid</code> method. 
</p>
<p><code>Differencing</code> relies on 
comparing the factors involved in two terms, one previous to the 
other, to identify whether to subtract the orthogonalized projector 
for the  previous term from the primary projector of the other. It 
does so if factors/variables for the previous term are a subset of 
the factors/variablesfor for the other term. This relies on ensuring that all 
projectors whose factors/variables are a subset of the current 
projector occur before it in the expanded formula. It is checked that 
the set of matrices are mutually orthogonal. If they are not then 
a warning is given. It may happen that differencing does not produce 
a projector, in which case <code>eigenmethods</code> must be used.
</p>
<p><code>Eigenmethods</code> forces each projector to be orthogonal 
to all terms previous to it in the expanded formula. It uses 
equation 4.10 of James and Wilkinson (1971), which involves 
calculating the canonical efficiency factors for pairs of primary 
projectors. It produces a 
table of efficiency criteria for partially aliased terms. Again,
the order of terms is crucial. This method has the disadvantage that 
the marginality of terms is not determined and so sources names are set 
to be the same as the term names, unless a <code>marginality</code> matrix 
is supplied.
</p>
<p>The <code>hybrid</code> method is the most general and uses the relationships 
between the projection operators for the terms in the <code>formula</code> 
to decide which projectors to subtract and which to orthogonalize using 
eigenmethods. If <code class="reqn">\mathbf{Q}_i</code> and <code class="reqn">\mathbf{Q}_j</code> are 
two projectors for two different terms, with <code class="reqn">i &lt; j</code>, then
</p>

<ol>
<li><p> if <code class="reqn">\mathbf{Q}_j\mathbf{Q}_i \neq \mathbf{0}</code> then 
have to orthogonalize <code class="reqn">\mathbf{Q}_j</code> to <code class="reqn">\mathbf{Q}_i</code>.
</p>
</li>
<li><p> if <code class="reqn">\mathbf{Q}_j\mathbf{Q}_i = \mathbf{Q}_j</code>  
then,  if <code class="reqn">\mathbf{Q}_i = \mathbf{Q}_j</code>, they are equal 
and <code class="reqn">\mathbf{Q}_j</code> will be removed from the list of terms; 
otherwise they are marginal and <code class="reqn">\mathbf{Q}_i</code> is subtracted 
from <code class="reqn">\mathbf{Q}_j</code>.
</p>
</li>
<li><p> if have to orthogonalize and 
<code class="reqn">\mathbf{Q}_j\mathbf{Q}_i = \mathbf{Q}_i</code> then 
<code class="reqn">\mathbf{Q}_j</code> is aliased with previous terms and will be 
removed from the list of terms; otherwise <code class="reqn">\mathbf{Q}_i</code> is 
partially aliased with <code class="reqn">\mathbf{Q}_j</code> and 
<code class="reqn">\mathbf{Q}_j</code> is orthogonalized to <code class="reqn">\mathbf{Q}_i</code> 
using eigenmethods.
</p>
</li></ol>

<p>The order of projections matrices in the <code><a href="base.html#topic+list">list</a></code> is crucial in this process.
</p>
<p>Of the three methods, <code>eigenmethods</code> is least likely to fail, but it 
does not establish the marginality between the terms. It is often needed 
when there is nonorthogonality between terms, such as when there are several 
linear covariates. It can also be more efficeint in these circumstances.
</p>
<p>The process can be computationally expensive, particularly for a large data set 
(500 or more observations) and/or when many terms are to be orthogonalized. 
</p>
<p>If the error <code>Matrix is not idempotent</code> should occur then, especially 
if there are  many terms, one might try using <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> 
to reduce the tolerance used in determining if values are either the same 
or are zero; it may be necessary to lower the tolerance to as low as 0.001. 
Also, setting <code>orthogonalize</code> to <code>eigenmethods</code> is worth a try.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+pstructure.object">pstructure.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the 
residual operator and canonical decomposition of nonorthogonal 
factors in the analysis of variance. <em>Biometrika</em>, <b>58</b>, 279-294.</p>


<h3>See Also</h3>

<p><code><a href="#topic+pstructure.formula">pstructure.formula</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, 
<code><a href="#topic+proj2.combine">proj2.combine</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <br />
<code><a href="#topic+projs.2canon">projs.2canon</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)
## manually obtain projectors for units
Q.G &lt;- projector(matrix(1, nrow=24, ncol=24)/24)                         
Q.B &lt;- projector(fac.meanop(PBIBD2.lay$Block))
Q.BU &lt;- projector(diag(1, nrow=24))

## manually obtain projector for trt
Q.T &lt;- projector(fac.meanop(PBIBD2.lay$trt) - Q.G)

##Orthogonalize the projectors using porthogonalize.list
Qs &lt;- list(Mean = Q.G, Block = Q.B, "Block:Unit" = Q.BU)
struct &lt;- porthogonalize(Qs, grandMean = TRUE)
Qs &lt;- struct$Q
(lapply(Qs, degfree))

#Add a linear covariate
PBIBD2.lay &lt;- within(PBIBD2.lay,
                     {
                       cBlock &lt;- as.numfac(Block)
                       cBlock &lt;- cBlock - mean(unique(cBlock))
                     })
X &lt;- model.matrix(~ cBlock, data = PBIBD2.lay)
Q.cB &lt;- projector(X %*% mat.ginv(t(X) %*% X) %*% t(X))
Qs &lt;- list(cBlock = Q.cB, Block = Q.B, "Block:Unit" = Q.BU)
struct &lt;- porthogonalize(Qs, grandMean = FALSE)
Qs &lt;- struct$Q
(lapply(Qs, degfree))
</code></pre>

<hr>
<h2 id='power.exp'>Computes the power for an experiment</h2><span id='topic+power.exp'></span>

<h3>Description</h3>

<p>Computes the power for an experiment.</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.exp(rm=5., df.num=1., df.denom=10., delta=1., sigma=1.,
          alpha=0.05, print=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.exp_+3A_rm">rm</code></td>
<td>
<p>The number of observations used in computing a mean.</p>
</td></tr>
<tr><td><code id="power.exp_+3A_df.num">df.num</code></td>
<td>
<p>The degrees of freedom of the numerator of the F for testing
the term involving the means.</p>
</td></tr>
<tr><td><code id="power.exp_+3A_df.denom">df.denom</code></td>
<td>
<p>The degrees of freedom of the denominator of the F for
testing the term involving the means.</p>
</td></tr>
<tr><td><code id="power.exp_+3A_delta">delta</code></td>
<td>
<p>The true difference between a pair of means.</p>
</td></tr>
<tr><td><code id="power.exp_+3A_sigma">sigma</code></td>
<td>
<p>The population standard deviation.</p>
</td></tr>
<tr><td><code id="power.exp_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to be used.</p>
</td></tr>
<tr><td><code id="power.exp_+3A_print">print</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to have or not have a table of power 
calculation details printed out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>numeric</code> value containing the computed power.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+no.reps">no.reps</a></code>, <code><a href="#topic+detect.diff">detect.diff</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute power for a randomized complete block design with four treatments 
## and five blocks. 
rm &lt;- 5
power.exp(rm = rm, df.num = 3, df.denom = 3 * (rm - 1), delta = 5,
          sigma = sqrt(20),print = TRUE)
</code></pre>

<hr>
<h2 id='print.aliasing'>Print an aliasing data.frame</h2><span id='topic+print.aliasing'></span>

<h3>Description</h3>

<p>Prints an aliasing <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aliasing'
print(x, which.criteria = c("aefficiency","eefficiency","order"),  ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.aliasing_+3A_x">x</code></td>
<td>
<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> that is also of class <code>aliasing</code> and is to be printed.</p>
</td></tr>
<tr><td><code id="print.aliasing_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A character <code>vector</code> nominating the efficiency 
criteria to be included in the summary of aliasing 
between terms. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>, 
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>. 
If <code>none</code>, no criteria are printed.</p>
</td></tr>
<tr><td><code id="print.aliasing_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>print</code> method for <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+print.default">print.default</a></code>, <code><a href="methods.html#topic+show">show</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a data.frame with 3 factors length 12
pseudo.lay &lt;- data.frame(pl = factor(1:12),
                         ab = factor(rep(1:4, times=3)),
                         a = factor(rep(1:2, times=6)))


## create a pstructure object
trt.struct &lt;- pstructure(~ ab+a, data = pseudo.lay)

## print the object either using the Method function, the generic function or show
print.aliasing(trt.struct$aliasing)
print(trt.struct$aliasing, which.criteria = "none")
trt.struct$aliasing
</code></pre>

<hr>
<h2 id='print.projector'>Print projectors</h2><span id='topic+print.projector'></span><span id='topic+print+2Cprojector-method'></span>

<h3>Description</h3>

<p>Print an object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;, 
displaying the matrix and its degrees of freedom (rank).</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projector'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.projector_+3A_x">x</code></td>
<td>
<p>The object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; to be printed.</p>
</td></tr>
<tr><td><code id="print.projector_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+print.default">print.default</a></code>, <code><a href="methods.html#topic+show">show</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
m &lt;- matrix(rep(0.5,4), nrow=2)

## create an object of class projector
proj.m &lt;- projector(m)

## print the object either using the Method function, the generic function or show
print.projector(proj.m)
print(proj.m)
proj.m
</code></pre>

<hr>
<h2 id='print.pstructure'>Prints a pstructure.object</h2><span id='topic+print.pstructure'></span>

<h3>Description</h3>

<p>Prints a <code><a href="#topic+pstructure.object">pstructure.object</a></code>, which is of class <code>pstructure</code>. 
The df, terms and sources are coerced into a <code>data.frame</code> and printed; 
the marginality matrix is printed separately.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pstructure'
print(x, which = "all", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pstructure_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+pstructure.object">pstructure.object</a></code>, which is of class <code>pstructure</code> and is to be printed.</p>
</td></tr>
<tr><td><code id="print.pstructure_+3A_which">which</code></td>
<td>
<p>A character <code>vector</code> nominating the components of the 
<code><a href="#topic+pstructure.object">pstructure.object</a></code> to print. Must be <code>all</code> 
or some combination of <code>projectors</code>, <code>marginality</code>, 
and <code>aliasing</code>.</p>
</td></tr>
<tr><td><code id="print.pstructure_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+print.aliasing">print.aliasing</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+print.default">print.default</a></code>, <code><a href="methods.html#topic+show">show</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a data.frame with 4 factors, each with three levels, in standard order
ABCD.lay &lt;- fac.gen(list(A = 3, B = 3, C = 3, D = 3))

## create a pstructure object based on the formula ((A*B)/C)*D
ABCD.struct &lt;- pstructure.formula(~ ((A*B)/C)*D, data =ABCD.lay)

## print the object either using the Method function, the generic function or show
print.pstructure(ABCD.struct)
print(ABCD.struct)
ABCD.struct
</code></pre>

<hr>
<h2 id='print.summary.p2canon'>Prints the values in an <code><a href="#topic+summary.p2canon">summary.p2canon</a></code> object</h2><span id='topic+print.summary.p2canon'></span>

<h3>Description</h3>

<p>Prints a <code>summary.p2canon</code> object, which is also a 
<code>data.frame</code>, in a pretty format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.p2canon'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.p2canon_+3A_x">x</code></td>
<td>
<p>A <code>summary.p2canon</code> object.</p>
</td></tr>
<tr><td><code id="print.summary.p2canon_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.p2canon">summary.p2canon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain projectors using pstructure
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

##obtain combined decomposition and print summary
unit.trt.p2canon &lt;- projs.2canon(unit.struct$Q, trt.struct$Q)
summ &lt;- summary(unit.trt.p2canon)
print(summ)
</code></pre>

<hr>
<h2 id='print.summary.pcanon'>Prints the values in an <code><a href="#topic+summary.pcanon">summary.pcanon</a></code> object</h2><span id='topic+print.summary.pcanon'></span>

<h3>Description</h3>

<p>Prints a <code>summary.pcanon</code> object, which is also a 
<code>data.frame</code>, in a pretty format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pcanon'
print(x, aliasing.print = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pcanon_+3A_x">x</code></td>
<td>
<p>A <code>summary.pcanon</code> object.</p>
</td></tr>
<tr><td><code id="print.summary.pcanon_+3A_aliasing.print">aliasing.print</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the aliasing between sources 
is to be printed. Ignored for legacy <code>summary.pcanon</code> objects 
resulting from versions prior to 3.0-0 and so using <code>projs.canon</code></p>
</td></tr>
<tr><td><code id="print.summary.pcanon_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.pcanon">summary.pcanon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain combined decomposition and summarize
unit.trt.canon &lt;- designAnatomy(list(unit=~ Block/Unit, trt=~ trt),
                                data = PBIBD2.lay)
summ &lt;- summary(unit.trt.canon, which = c("aeff","eeff","order"))
print(summ)
</code></pre>

<hr>
<h2 id='proj2.combine'>Compute the projection and Residual operators for two, possibly 
nonorthogonal, projectors</h2><span id='topic+proj2.combine'></span>

<h3>Description</h3>

<p>The canonical relationship between a pair of projectors 
is established by decomposing the range of Q1 into a part that 
pertains to Q2 and a part that is orthogonal to Q2. It also 
produces the nonzero canonical efficiency factors for the joint 
decomposition of Q1 and Q and the corresponding eigenvectors of 
Q1 (James and Wilkinson, 1971). Q1 and Q2 may be nonorthogonal.</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj2.combine(Q1, Q2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj2.combine_+3A_q1">Q1</code></td>
<td>
<p>A symmetric <code>projector</code> whose range is to be decomposed.</p>
</td></tr>
<tr><td><code id="proj2.combine_+3A_q2">Q2</code></td>
<td>
<p>A symmetric <code>projector</code> whose range in Q1 is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nonzero canonical efficiency factors are the nonzero eigenvalues of 
<code>Q1 %*% Q2 %*% Q1</code> (James and Wilkinson, 1971). An eigenvalue is regarded 
as zero if it is less than <code>daeTolerance</code>, which is initially set to 
<code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). 
The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.
</p>
<p>The eigenvectors are the eigenvectors of Q1 corresponding to the nonzero canonical 
efficiency factors. The eigenvectors for Q2 can be obtained by premultiplying 
those for Q1 by Q2.
</p>
<p>Qres is computed using equation 4.10 from James and Wilkinson (1971), if the number of distinct
canonical efficiency factors is less than 10. If this fails to produce a projector or the number of distinct canonical efficiency factors is 10 or more, equation 5.3 of Payne and Tobias (1992) is used to obtain Qres. In this latter case, <code>Qres = Q1 - Q1 %*% ginv(Q2 %*% Q1 %*% Q2) %*% Q1</code>. Qconf is obtained by subtracting Qres from Q1.</p>


<h3>Value</h3>

<p>A <code>list</code> with the following components:
</p>

<ol>
<li><p><b>efficiencies:</b> a <code>vector</code> containing the nonzero canonical efficiency factors;
</p>
</li>
<li><p><b>eigenvectors:</b> an n x r <code><a href="base.html#topic+matrix">matrix</a></code>, where n is the order of the projectors and 
r is the number of nonzero canonical efficiency factors; it contains 
the eigenvectors of Q1 corresponding to the nonzero canonical 
efficiency factors. 
</p>
</li>
<li><p><b>Qconf:</b> a <code>projector</code> onto the part of the range of Q1 with 
which Q2 is confounded;
</p>
</li>
<li><p><b>Qres:</b> a <code>projector</code> onto the part of the range of Q1 that is 
orthogonal to the range of Q2.</p>
</li></ol>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the 
residual operator and canonical decomposition of nonorthogonal 
factors in the analysis of variance. <em>Biometrika</em>, <b>58</b>, 279&ndash;294.
</p>
<p>Payne, R. W. and R. D. Tobias (1992). General balance, combination of 
information and the analysis of covariance. 
<em>Scandinavian Journal of Statistics</em>, <b>19</b>, 3&ndash;23.</p>


<h3>See Also</h3>

<p><code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+decomp.relate">decomp.relate</a></code> 
in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

## obtain sets of projectors
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

## obtain the projection operators for the interblock analysis
PBIBD2.Bops &lt;- proj2.combine(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])
Q.B.T &lt;- PBIBD2.Bops$Qconf
Q.B.res &lt;- PBIBD2.Bops$Qres

## demonstrate their orthogonality
is.allzero(Q.B.T %*% Q.B.res)
</code></pre>

<hr>
<h2 id='proj2.efficiency'>Computes the canonical efficiency factors for the joint decomposition of 
two projectors</h2><span id='topic+proj2.efficiency'></span>

<h3>Description</h3>

<p>Computes the canonical efficiency factors for the joint    
decomposition of two projectors (James and Wilkinson, 1971).</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj2.efficiency(Q1, Q2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj2.efficiency_+3A_q1">Q1</code></td>
<td>
<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="proj2.efficiency_+3A_q2">Q2</code></td>
<td>
<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nonzero canonical efficiency factors are the nonzero eigenvalues of 
Q1 %*% Q2 %*% Q1 (James and Wilkinson, 1971). An eigenvalue is regarded as 
zero if it is less than <code>daeTolerance</code>, which is initially set to 
<code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). 
The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change 
<code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>A <code>vector</code> containing the nonzero canonical efficiency factors.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the 
residual operator and canonical decomposition of nonorthogonal 
factors in the analysis of variance. <em>Biometrika</em>, <b>58</b>, 279-294.</p>


<h3>See Also</h3>

<p><code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

## obtain sets of projectors
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

## save intrablock efficiencies
eff.intra &lt;- proj2.efficiency(unit.struct$Q[["Block"]], trt.struct$Q[["trt"]])
</code></pre>

<hr>
<h2 id='proj2.eigen'>Canonical efficiency factors and eigenvectors in joint decomposition of two projectors</h2><span id='topic+proj2.eigen'></span>

<h3>Description</h3>

<p>Computes the canonical efficiency factors for the joint 
decomposition of two projectors and the eigenvectors corresponding 
to the first projector (James and Wilkinson, 1971).</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj2.eigen(Q1, Q2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj2.eigen_+3A_q1">Q1</code></td>
<td>
<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="proj2.eigen_+3A_q2">Q2</code></td>
<td>
<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The component efficiencies is a <code>vector</code> containing the nonzero canonical 
efficiency factors for the joint decomposition of the two projectors. 
The nonzero canonical efficiency factors are the nonzero eigenvalues of 
Q1 %*% Q2 %*% Q1 (James and Wilkinson, 1971). An eigenvalue is regarded 
as zero if it is less than <code>daeTolerance</code>, which is initially set to 
<code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). 
The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change <code>daeTolerance</code>.
</p>
<p>The component eigenvectors is an n x r <code><a href="base.html#topic+matrix">matrix</a></code>, where n is the order of the 
projectors and r is the number of nonzero canonical efficiency factors; 
it contains the eigenvectors of Q1 corresponding to the nonzero canonical 
efficiency factors. The eigenvectors for Q2 can be obtained by premultiplying 
those for Q1 by Q2.</p>


<h3>Value</h3>

<p>A <code>list</code> with components efficiencies and eigenvectors. </p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the 
residual operator and canonical decomposition of nonorthogonal 
factors in the analysis of variance. <em>Biometrika</em>, <b>58</b>, 279-294.</p>


<h3>See Also</h3>

<p><code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code> in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

## obtain sets of projectors
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

## obtain intra- and inter-block decompositions
decomp.inter &lt;- proj2.eigen(unit.struct$Q[["Block"]], trt.struct$Q[["trt"]])
decomp.intra &lt;- proj2.eigen(unit.struct$Q[["Unit[Block]"]], trt.struct$Q[["trt"]])

#extract intrablock efficiencies
decomp.intra$efficiencies
</code></pre>

<hr>
<h2 id='projector'>Create projectors</h2><span id='topic+projector'></span>

<h3>Description</h3>

<p>The class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; is the 
subclass of the class &quot;<code><a href="methods.html#topic+matrix-class">matrix</a></code>&quot; 
in which matrices are square, symmetric and idempotent. 
</p>
<p>The function <code>projector</code> tests whether a <code><a href="base.html#topic+matrix">matrix</a></code> 
satisfies these criteria and if it does creates a 
&quot;<code><a href="#topic+projector-class">projector</a></code>&quot; object, computing the 
projector's degrees of freedom and adding them to the object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>projector(Q)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projector_+3A_q">Q</code></td>
<td>
<p>The <code><a href="base.html#topic+matrix">matrix</a></code> to be made into a projector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In checking that the <code><a href="base.html#topic+matrix">matrix</a></code> is square, symmetric and 
idempotent, the equality of the <code><a href="base.html#topic+matrix">matrix</a></code> with either its 
transpose or square is tested. In this, a difference in elements is 
considered to be zero if it is less than <code>daeTolerance</code>, which is 
initially set to <code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). 
The function <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can 
be used to change <code>daeTolerance</code>.</p>


<h3>Value</h3>

<p>An object of Class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; that 
consists of a square, summetric,  idempotent <code><a href="base.html#topic+matrix">matrix</a></code> and 
degrees of freedom (rank) of the <code>matrix.</code></p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+degfree">degfree</a></code>, <code><a href="#topic+correct.degfree">correct.degfree</a></code> in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
m &lt;- matrix(rep(0.5,4), nrow=2)

## create an object of class projector
proj.m &lt;- projector(m)

## check that it is a valid projector
is.projector(proj.m)
</code></pre>

<hr>
<h2 id='projector-class'>Class projector</h2><span id='topic+projector-class'></span><span id='topic+coerce+2Cprojector+2Cmatrix-method'></span><span id='topic+coerce+3C-+2Cprojector+2Cmatrix-method'></span>

<h3>Description</h3>

<p>The class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; is the 
subclass of matrices that are square, symmetric and idempotent.
</p>
<p><code><a href="#topic+is.projector">is.projector</a></code> is the membership function for this class.
</p>
<p><code><a href="#topic+degfree">degfree</a></code> is the extractor function for the degrees of freedom and 
<code><a href="#topic+degfree">degfree&lt;-</a></code> is the replacement function.
</p>
<p><code><a href="#topic+correct.degfree">correct.degfree</a></code> checks whether the stored degrees of freedom are correct.</p>


<h3>Objects from the Class</h3>

<p>An object of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot; consists of a 
square, symmetric, idempotent matrix along with its degrees of freedom (rank).
</p>
<p>Objects can be created by calls of the form <code>new("projector", data, nrow, ncol, byrow, dimnames, ...)</code>.
However, this does not add the degrees of freedom to the object. These can be 
added using the replacement function <code><a href="#topic+degfree">degfree&lt;-</a></code>.  
Alternatively, the function <code><a href="#topic+projector">projector</a></code> creates the new object 
from a <code><a href="base.html#topic+matrix">matrix</a></code>, adding its degrees of freedom at the same time.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"matrix"</code></p>
</dd>
<dt><code>degfree</code>:</dt><dd><p>Object of class <code>"integer"</code></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class &quot;<code><a href="methods.html#topic+matrix-class">matrix</a></code>&quot;, from data part.
Class &quot;<code><a href="methods.html#topic+array-class">array</a></code>&quot;, by class &quot;matrix&quot;, distance 2.
Class &quot;<code><a href="methods.html#topic+structure-class">structure</a></code>&quot;, by class &quot;matrix&quot;, distance 3.
Class &quot;<code><a href="methods.html#topic+vector-class">vector</a></code>&quot;, by class &quot;matrix&quot;, distance 4, with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "projector", to = "matrix")</code> </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "projector")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "projector")</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+projector">projector</a></code>, <code><a href="#topic+degfree">degfree</a></code>, <code><a href="#topic+correct.degfree">correct.degfree</a></code> 
in package <span class="pkg">dae</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("projector")

## set up a 2 x 2 mean operator that takes the mean of a vector of 2 values
m &lt;- matrix(rep(0.5,4), nrow=2)

## create an object of class projector
proj.m &lt;- projector(m)

## check that it is a valid projector
is.projector(proj.m)

## create a projector based on the matrix m
proj.m &lt;- new("projector", data=m)

## add its degrees of freedom and print the projector
degfree(proj.m) &lt;- proj.m
</code></pre>

<hr>
<h2 id='projs.2canon'>A canonical analysis of the relationships between two sets of projectors</h2><span id='topic+projs.2canon'></span>

<h3>Description</h3>

<p>Computes the canonical efficiency factors for the joint 
decomposition of two structures or sets of mutually orthogonally 
projectors (Brien and Bailey, 2009), orthogonalizing projectors in the 
Q2 <code>list</code> to those earlier in the <code>list</code> of projectors with 
which they are partially aliased. The results can be summarized in the 
form of a skeleton ANOVA table.</p>


<h3>Usage</h3>

<pre><code class='language-R'>projs.2canon(Q1, Q2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projs.2canon_+3A_q1">Q1</code></td>
<td>
<p>A <code>list</code> whose components are objects of class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="projs.2canon_+3A_q2">Q2</code></td>
<td>
<p>A <code>list</code> whose components are objectsof class &quot;<code><a href="#topic+projector-class">projector</a></code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two loops, one nested within the other, are performed. The first cycles 
over the components of <code>Q1</code> and the nested loop cycles over the 
components of <code>Q2</code>. The joint decomposition of the two projectors 
in each cycle, one from <code>Q1</code> (say <code>Q1[[i]]</code>) and the other 
from <code>Q2</code> (say <code>Q2[[j]]</code>) is obtained using 
<code><a href="#topic+proj2.combine">proj2.combine</a></code>. 
In particular, the nonzero canonical efficiency factors for the joint 
decomposition of the two projectors is obtained. The nonzero canonical 
efficiency factors are the nonzero eigenvalues of 
<code>Q1[[i]] %*% Q2[[j]] %*% Q1[[i]]</code> (James and Wilkinson, 1971). 
An eigenvalue is regarded as zero if it is less than 
<code>daeTolerance</code>, which is initially set to 
<code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). The function 
<code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> can be used to change 
<code>daeTolerance</code>.
</p>
<p>However, a warning occurs if any pair of Q2 projectors (say 
<code>Q2[[j]]</code> and <code>Q2[[k]]</code>) do not have adjusted orthgonality 
with respect to any Q1 projector (say <code>Q1[[i]]</code>), because they are 
partially aliased. That is, if <code>Q2[[j]] %*% Q1[[i]] %*% Q2[[k]]</code> 
is nonzero for any pair of different Q2 projectors and any 
Q1 projector. When it is nonzero, the projector for the later term in 
the list of projectors is orthogonalized to the projector that is 
earlier in the list. A list of such projectors is returned in the 
<code>aliasing</code> component of the <code><a href="#topic+p2canon.object">p2canon.object</a></code>. The
entries in the <code>aliasing</code> component gives the amount of information 
that is aliased with previous terms.</p>


<h3>Value</h3>

<p>A <code><a href="#topic+p2canon.object">p2canon.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. and R. A. Bailey (2009). Decomposition tables for 
multitiered experiments. I. A chain of randomizations.  
<em>The Annals of Statistics</em>, <b>36</b>, 4184 - 4213.
</p>
<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the residual 
operator and canonical decomposition of nonorthogonal factors in the 
analysis of variance. <em>Biometrika</em>, <b>58</b>, 279-294.</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.p2canon">summary.p2canon</a></code>, <code><a href="#topic+efficiencies.p2canon">efficiencies.p2canon</a></code>, 
<code><a href="#topic+projs.combine.p2canon">projs.combine.p2canon</a></code>, <code><a href="#topic+pstructure">pstructure</a></code> , <br />
<code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code>, 
<code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code> 
in package <span class="pkg">dae</span>, <code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain projectors using pstructure
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

##obtain combined decomposition and summarize
unit.trt.p2canon &lt;- projs.2canon(unit.struct$Q, trt.struct$Q)
summary(unit.trt.p2canon)
</code></pre>

<hr>
<h2 id='projs.combine.p2canon'>Extract, from a p2canon object, the projectors that give the combined 
canonical decomposition</h2><span id='topic+projs.combine.p2canon'></span>

<h3>Description</h3>

<p>Extracts, from a p2canon object obtained using 
<code><a href="#topic+projs.2canon">projs.2canon</a></code>, the projectors that give the combined 
canonical decomposition of two sets of projectors 
(Brien and Bailey, 2009).</p>


<h3>Usage</h3>

<pre><code class='language-R'>projs.combine.p2canon(object)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projs.combine.p2canon_+3A_object">object</code></td>
<td>
<p>A <code>list</code> of class <code>p2canon</code> produced by <code>projs.2canon</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code>, each of whose components is a projector in the decomposition.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. and R. A. Bailey (2009). Decomposition tables for 
multitiered experiments. I. A chain of randomizations.  
<em>The Annals of Statistics</em>, <b>36</b>, 4184 - 4213.</p>


<h3>See Also</h3>

<p><code><a href="#topic+projs.2canon">projs.2canon</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code> in package <span class="pkg">dae</span>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

## obtain sets of projectors
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

##obtain combined decomposition
unit.trt.p2canon &lt;- projs.2canon(unit.struct$Q, trt.struct$Q)
UcombineT &lt;- projs.combine.p2canon(unit.trt.p2canon)
</code></pre>

<hr>
<h2 id='pstructure.formula'>Takes a formula and constructs a <code><a href="#topic+pstructure.object">pstructure.object</a></code> that includes the orthogonalized projectors for the terms in a formula</h2><span id='topic+pstructure.formula'></span><span id='topic+pstructure'></span>

<h3>Description</h3>

<p>Constructs a <code><a href="#topic+pstructure.object">pstructure.object</a></code> that includes a 
set of mutually orthogonal projectors, one for each 
term in the formula. These are used to specify a structure, 
or an orthogonal decomposition of the data space. 
There are three methods available for 
orthogonalizing the projectors corresponding to the terms 
in the <code>formula</code>: <code>differencing</code>, <code>eigenmethods</code> 
or the default <code>hybrid</code> method.  
</p>
<p>It is possible to use this function to find out what sources 
are associated with the terms in a model and to determine the 
marginality between terms in the model. The marginality matrix 
can be saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
pstructure(formula, keep.order = TRUE, grandMean = FALSE, 
           orthogonalize = "hybrid", labels = "sources", 
           marginality = NULL, check.marginality = TRUE, 
           omit.projectors = FALSE, 
           which.criteria = c("aefficiency","eefficiency","order"), 
           aliasing.print = TRUE, data = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pstructure.formula_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code> from which the terms will be 
obtained.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_keep.order">keep.order</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the terms should keep 
their position in the expanded <code>formula</code> projector, or 
reordered so that main effects precede two-factor 
interactions, which precede three-factor interactions and 
so on.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_grandmean">grandMean</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the projector for the 
grand mean is to be included in the set produced.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_orthogonalize">orthogonalize</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector indicating the method for orthogonalizing a 
projector to those for terms that occurred previously 
in the formula. Three options are available:  
<code>hybrid</code>; <code>differencing</code>; <code>eigenmethods</code>.
The <code>hybrid</code> option is the most general and uses the 
relationships between the projection operators for the 
terms in the <code>formula</code> to decide which 
<code><a href="#topic+projector">projector</a></code>s to substract and which to 
orthogonalize using eigenmethods. The <code>differencing</code> 
option subtracts, from the current <code><a href="#topic+projector">projector</a></code>, 
those previously orthogonalized <code><a href="#topic+projector">projector</a></code>s for 
terms whose factors are a subset of the current 
<code><a href="#topic+projector">projector</a></code>'s factors. The <code>eigenmethods</code> 
option recursively orthogonalizes the <code><a href="#topic+projector">projector</a></code>s 
using an eigenanalysis of each <code><a href="#topic+projector">projector</a></code> 
with previously orthogonalized <code><a href="#topic+projector">projector</a></code>s.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_labels">labels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> nominating the type of labels to be used in 
labelling the projectors, and which will be used also 
in the output tables, such the tables of the aliasing 
in the structure. The two alternatives are <code>terms</code> and 
<code>sources</code>. Terms have all factors/variables in it 
separated by colons (<code>:</code>). Sources have factors/variables 
in them that represent interactions separated by hashes 
(<code>#</code>); if some factors are nested within others, the 
nesting factors are surrounded by square brackets 
(<code>[</code> and <code>]</code>) and separated by colons (<code>:</code>). 
If some generalized, or combined, factors have no marginal 
terms, the constituent factors are separated by colons 
(<code>:</code>) and if they interact with other factors in 
the source they will be parenthesized.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_marginality">marginality</code></td>
<td>
<p>A square <code><a href="base.html#topic+matrix">matrix</a></code> that can be used to supply the 
marginality <code><a href="base.html#topic+matrix">matrix</a></code> when it is desired to overwrite 
the calculated marginality <code><a href="base.html#topic+matrix">matrix</a></code> or when it is not 
being calculated. It should consist of zeroes and ones that 
gives the marginalites of the terms in the formula. It must have 
the row and column names set to the terms from the expanded 
<code>formula</code>, including being in the same order as these terms. 
</p>
<p>The entry in the ith row and jth column will be one if the 
ith term is marginal to the jth term i.e. the column space of the 
ith term is a subspace of that for the jth term and so the source 
for the jth term is to be made orthogonal to that for the ith term. 
Otherwise, the entries are zero. A row and column should not be 
included for the grand mean even if <code>grandMean</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_check.marginality">check.marginality</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the marginality matrix, 
when it is supplied, is to be checked against that computed 
by <code><a href="#topic+pstructure.formula">pstructure.formula</a></code>. It is ignored when 
<code>orthogonalize</code> is set to <code>eigenmethods</code>.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_omit.projectors">omit.projectors</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>, which, if <code>TRUE</code>, 
results in the <code><a href="#topic+projector">projector</a></code>s in the <code>Q</code> of the 
<code>pstructure.object</code> being replaced by their degrees of freedom. 
These will be the degrees of freedom of the sources. 
This option is included a device for saving storage when the 
<code><a href="#topic+projector">projector</a></code>s are not required for further analysis.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A character <code>vector</code> nominating the efficiency 
criteria to be included in the summary of aliasing 
between terms. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>, 
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>. 
If <code>none</code>, no summary is printed.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_aliasing.print">aliasing.print</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the aliasing between sources 
within the structure is to be printed.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_data">data</code></td>
<td>
<p>A data frame contains the values of the factors and variables 
that occur in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="pstructure.formula_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>terms</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, the primary projector <code class="reqn">\mathbf{X(X'X)^-X'}</code>, 
where X is the design matrix for the term, is calculated for each term. 
Then each projector is made orthogonal to terms aliased with it using 
<code><a href="#topic+porthogonalize.list">porthogonalize.list</a></code>, either by <code>differencing</code>, 
<code>eigenmethods</code> or the default <code>hybrid</code> method. 
</p>
<p><code>Differencing</code> relies on 
comparing the factors involved in two terms, one previous to the 
other, to identify whether to subtract the orthogonalized projector 
for the  previous term from the primary projector of the other. It 
does so if factors/variables for the previous term are a subset of 
the factors/variablesfor for the other term. This relies on ensuring that all 
projectors whose factors/variables are a subset of the current 
projector occur before it in the expanded formula. It is checked that 
the set of matrices are mutually orthogonal. If they are not then 
a warning is given. It may happen that differencing does not produce 
a projector, in which case <code>eigenmethods</code> must be used.
</p>
<p><code>Eigenmethods</code> forces each projector to be orthogonal 
to all terms previous to it in the expanded formula. It uses 
equation 4.10 of James and Wilkinson (1971), which involves 
calculating the canonical efficiency factors for pairs of primary 
projectors. It produces a 
table of efficiency criteria for partially aliased terms. Again,
the order of terms is crucial. This method has the disadvantage that 
the marginality of terms is not determined and so sources names are set 
to be the same as the term names, unless a <code>marginality</code> matrix 
is supplied.
</p>
<p>The <code>hybrid</code> method is the most general and uses the relationships 
between the projection operators for the terms in the <code>formula</code> 
to decide which projectors to subtract and which to orthogonalize using 
eigenmethods. If <code class="reqn">\mathbf{Q}_i</code> and <code class="reqn">\mathbf{Q}_j</code> are 
two projectors for two different terms, with <code class="reqn">i &lt; j</code>, then
</p>

<ol>
<li><p> if <code class="reqn">\mathbf{Q}_j\mathbf{Q}_i \neq \mathbf{0}</code> then 
have to orthogonalize <code class="reqn">\mathbf{Q}_j</code> to <code class="reqn">\mathbf{Q}_i</code>.
</p>
</li>
<li><p> if <code class="reqn">\mathbf{Q}_j\mathbf{Q}_i = \mathbf{Q}_j</code>  
then,  if <code class="reqn">\mathbf{Q}_i = \mathbf{Q}_j</code>, they are equal 
and <code class="reqn">\mathbf{Q}_j</code> will be removed from the list of terms; 
otherwise they are marginal and <code class="reqn">\mathbf{Q}_i</code> is subtracted 
from <code class="reqn">\mathbf{Q}_j</code>.
</p>
</li>
<li><p> if have to orthogonalize and 
<code class="reqn">\mathbf{Q}_j\mathbf{Q}_i = \mathbf{Q}_i</code> then 
<code class="reqn">\mathbf{Q}_j</code> is aliased with previous terms and will be 
removed from the list of terms; otherwise <code class="reqn">\mathbf{Q}_i</code> is 
partially aliased with <code class="reqn">\mathbf{Q}_j</code> and 
<code class="reqn">\mathbf{Q}_j</code> is orthogonalized to <code class="reqn">\mathbf{Q}_i</code> 
using eigenmethods.
</p>
</li></ol>

<p>The order of terms is crucial in this process.
</p>
<p>Of the three methods, <code>eigenmethods</code> is least likely to fail, but it 
does not establish the marginality between the terms. It is often needed 
when there is nonorthogonality between terms, such as when there are several 
linear covariates. It can also be more efficeint in these circumstances.
</p>
<p>The process can be computationally expensive, particularly for a large data set 
(500 or more observations) and/or when many terms are to be orthogonalized. 
</p>
<p>If the error <code>Matrix is not idempotent</code> should occur then, especially 
if there are  many terms, one might try using <code><a href="#topic+set.daeTolerance">set.daeTolerance</a></code> 
to reduce the tolerance used in determining if values are either the same 
or are zero; it may be necessary to lower the tolerance to as low as 0.001. 
Also, setting <code>orthogonalize</code> to <code>eigenmethods</code> is worth a try.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+pstructure.object">pstructure.object</a></code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>James, A. T. and Wilkinson, G. N. (1971) Factorization of the 
residual operator and canonical decomposition of nonorthogonal 
factors in the analysis of variance. <em>Biometrika</em>, <b>58</b>, 279-294.</p>


<h3>See Also</h3>

<p><code><a href="#topic+porthogonalize.list">porthogonalize.list</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, 
<code><a href="#topic+proj2.combine">proj2.combine</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <br />
<code><a href="#topic+projs.2canon">projs.2canon</a></code> in package <span class="pkg">dae</span>, <code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)
## manually obtain projectors for units
Q.G &lt;- projector(matrix(1, nrow=24, ncol=24)/24)                         
Q.B &lt;- projector(fac.meanop(PBIBD2.lay$Block) - Q.G)
Q.BP &lt;- projector(diag(1, nrow=24) - Q.B - Q.G)

## manually obtain projector for trt
Q.T &lt;- projector(fac.meanop(PBIBD2.lay$trt) - Q.G)

##compute intrablock efficiency criteria
effic &lt;- proj2.efficiency(Q.BP, Q.T)
effic
efficiency.criteria(effic)

##obtain projectors using pstructure.formula
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

##obtain combined decomposition and summarize
unit.trt.p2canon &lt;- projs.2canon(unit.struct$Q, trt.struct$Q)
summary(unit.trt.p2canon, which = c("aeff","eeff","order"))
</code></pre>

<hr>
<h2 id='pstructure.object'>Description of a pstructure object</h2><span id='topic+pstructure.object'></span>

<h3>Description</h3>

<p>An object of class <code>pstructure</code> that contains information derived from a 
<code><a href="stats.html#topic+formula">formula</a></code> using <code><a href="#topic+pstructure.formula">pstructure.formula</a></code>. It also inherits from class <code>list</code>.</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>pstructure</code>  with the following components: 
</p>

<ol>
<li><p> Q: a list with a component of class <code>projector</code>, being  
the orthogonalized projectors for each non-aliased term/source 
in the <code>formula</code>; if <code>grandMean</code> is <code>TRUE</code> in 
the call to <code><a href="#topic+pstructure.formula">pstructure.formula</a></code> then it also 
includes the <code>projector</code> for it;
</p>
</li>
<li><p> terms: a <code><a href="base.html#topic+character">character</a></code> vector with the non-aliased 
term names; if <code>grandMean</code> is <code>TRUE</code> in 
the call to <code><a href="#topic+pstructure.formula">pstructure.formula</a></code> then the first 
term will be &quot;<code>Mean</code>&quot;; 
</p>
</li>
<li><p> sources: a <code><a href="base.html#topic+character">character</a></code> vector with the non-aliased
source names;
</p>
</li>
<li><p> marginality: a <code><a href="base.html#topic+matrix">matrix</a></code> of zeroes and ones with the same 
number of rows and columns as number of non-aliased terms, excluding the term for the grand mean 
even when <code>grandMean</code> is <code>TRUE</code>; the row names and column names 
are the elements <code>terms</code>, excluding &quot;<code>Mean</code>&quot;; 
</p>
<p>the entry in the ith row and jth column will be one if the 
ith term is marginal to the jth term i.e. the column space of the 
ith term is a subspace of that for the jth term and so the source for 
the jth term will have been made orthogonal to that for the ith term; 
otherwise, the entries are zero. 
</p>
</li>
<li><p> aliasing: a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the information about the 
(partial) aliasing between the sources in the <code>formula</code>. 
The columns are:
</p>

<ul>
<li><p> Source: the source names, or associated term name, for those that are 
(partially) aliased with previous sources;
</p>
</li>
<li><p> df: the remaining degrees of freedom for the source;
</p>
</li>
<li><p> Alias: the source with which the current entry is (partially) aliased;
</p>
</li>
<li><p> efficiency criteria: a set of columns for the complete set of criteria 
calculated by <code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>; the criteria reflect 
the amount of information that is aliased with previous sources and a 
line is included in the component that reports the informaton remaining 
after adjustment for previous sources.
</p>
</li></ul>

<p>The information provided depends on the setting of <code>orthogonalize</code>. 
All the information is provided for the <code>"hybrid"</code> option. For the 
option <code>"differencing"</code>, no efficiency criteria are included and either 
the terms/sources of the <code>Alias</code> are set to <code>"unknown"</code> and the 
<code>df</code> are set to <code>NA</code> 
when these are unknown. For the option <code>"eigenmethods"</code>, the previous 
terms/sources cannot be identified and so all values of <code>Alias</code> are set 
to <code>NA</code>. If there is no (partial) aliasing then the component is set to 
<code>NULL</code>.
</p>
</li></ol>

<p>The object has the attribute <code>labels</code>, which is set to <code>"terms"</code> or 
<code>"sources"</code> according to which of these label the projectors.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+pstructure.formula">pstructure.formula</a></code> and, for further information about the projector classs, 
<code><a href="#topic+projector-class">projector</a></code>.</p>

<hr>
<h2 id='qqyeffects'>Half or full normal plot of Yates effects</h2><span id='topic+qqyeffects'></span>

<h3>Description</h3>

<p>Produces a half or full normal plot of the Yates effects from a
<code class="reqn">2^k</code> factorial experiment.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqyeffects(aov.obj, error.term="Within", data=NULL, pch=16, 
           full=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqyeffects_+3A_aov.obj">aov.obj</code></td>
<td>
<p>An <code>aov</code> object or <code>aovlist</code>object created from a call to 
<code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
<tr><td><code id="qqyeffects_+3A_error.term">error.term</code></td>
<td>
<p>The term from the <code>Error</code> function from which the Yates 
effects are estimated. Only required when <code>Error</code> used 
in call to <code>aov</code>.</p>
</td></tr>
<tr><td><code id="qqyeffects_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which the variables specified in the <code>aov.obj</code>
will be found. If missing, the variables are searched for in
the standard way.</p>
</td></tr>
<tr><td><code id="qqyeffects_+3A_pch">pch</code></td>
<td>
<p>The number of a plotting symbol to be drawn when plotting points
(use <code>help(points)</code> for details).</p>
</td></tr>
<tr><td><code id="qqyeffects_+3A_full">full</code></td>
<td>
<p>whether a full or half normal plot is to be produced. The
default is for a half-normal plot; <code>full=TRUE</code> produces a full normal
plot.</p>
</td></tr>
<tr><td><code id="qqyeffects_+3A_...">...</code></td>
<td>
<p>Further graphical parameters may be specified (use
<code>help(par)</code> for possibilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A half or full normal plot of the Yates effects is produced.
You will be able to interactively select effects to be labelled (click 
reasonably close to the point and on the side where you want the label placed).
<b>Right click on the graph and select Stop when you have finished
labelling effects.</b> A regression line fitted to the unselected effects
and constrained to go through the origin is plotted. Also, a list of the
labelled effects, if any, are printed to standard ouptut.</p>


<h3>Value</h3>

<p>Returns, invisibly, a list with components x and y, giving coordinates
of the plotted points.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+yates.effects">yates.effects</a></code> in package <span class="pkg">dae</span>, <code><a href="stats.html#topic+qqnorm">qqnorm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## analysis of 2^4 factorial experiment from Table 10.6 of Box, Hunter and 
## Hunter (1978) Statistics for Experimenters. New York, Wiley.
## use ?Fac4Proc.dat for data set details
data(Fac4Proc.dat)
Fac4Proc.aov &lt;- aov(Conv ~ Catal * Temp * Press * Conc + Error(Runs),
                                                            Fac4Proc.dat)
qqyeffects(Fac4Proc.aov, error.term="Runs", data=Fac4Proc.dat)
</code></pre>

<hr>
<h2 id='rep.data.frame'>Replicate the rows of a data.frame by repeating each row consecutively and/or repeating all rows as a group</h2><span id='topic+rep.data.frame'></span>

<h3>Description</h3>

<p>Replicate the rows of a <code>data.frame</code> by repeating each row consecutively and/or repeating all rows as a group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
rep(x, times=1, each=1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep.data.frame_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> whose rows are to be repeated.</p>
</td></tr>
<tr><td><code id="rep.data.frame_+3A_times">times</code></td>
<td>
<p>The number of times to repeat the whole set of rows, after the rows have been 
replicated consecutively <code>each</code> times.</p>
</td></tr>
<tr><td><code id="rep.data.frame_+3A_each">each</code></td>
<td>
<p>The number of times to replicate consecutively each row in the <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="rep.data.frame_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Unused at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with replicated rows.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.gen">fac.gen</a></code> in package <span class="pkg">dae</span> and <code>rep</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rep(fac.gen(list(a = 2, b = 2)), times=2, each=2)
</code></pre>

<hr>
<h2 id='resid.errors'>Extract the residuals for a fitted model</h2><span id='topic+resid.errors'></span>

<h3>Description</h3>

<p>An alias for the generic function <code><a href="#topic+residuals">residuals</a></code>. When it is 
available, the method <code><a href="#topic+residuals.aovlist">residuals.aovlist</a></code> extracts residuals, which is provided 
in the package <span class="pkg">dae</span> to cover <code>aovlist</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid.errors(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.errors_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+residuals.aovlist">residuals.aovlist</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>vector</code> containing the residuals.</p>


<h3>Note</h3>

<p>See <code><a href="#topic+residuals.aovlist">residuals.aovlist</a></code> for specific information about the 
residuals when an <code>Error</code> function is used in the call to the 
<code><a href="stats.html#topic+aov">aov</a></code> function.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.errors">fitted.errors</a></code>, <code><a href="#topic+residuals.aovlist">residuals.aovlist</a></code>, 
<code><a href="#topic+tukey.1df">tukey.1df</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up data frame for randomized complete block design in Table 4.4 from 
## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
## New York, Wiley.
RCBDPen.dat &lt;- fac.gen(list(Blend=5, Flask=4))
RCBDPen.dat$Treat &lt;- factor(rep(c("A","B","C","D"), times=5))
RCBDPen.dat$Yield &lt;- c(89,88,97,94,84,77,92,79,81,87,87,
                       85,87,92,89,84,79,81,80,88)

## perform the analysis of variance
RCBDPen.aov &lt;- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
summary(RCBDPen.aov)

## two equivalent ways of extracting the residuals
res  &lt;- residuals.aovlist(RCBDPen.aov)
res &lt;- residuals(RCBDPen.aov, error.term = "Blend:Flask")
res &lt;- resid.errors(RCBDPen.aov)
</code></pre>

<hr>
<h2 id='residuals.aovlist'>Extract the residuals from an aovlist object</h2><span id='topic+residuals.aovlist'></span><span id='topic+residuals'></span>

<h3>Description</h3>

<p>Extracts the residuals from <code>error.term</code> or, if <code>error.term</code> 
is not specified, the last <code>error.term</code> in the analysis. It is a 
method for the generic function <code><a href="#topic+residuals">residuals</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aovlist'
residuals(object, error.term=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.aovlist_+3A_object">object</code></td>
<td>
<p>An <code>aovlist</code> object created from a call to <code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.aovlist_+3A_error.term">error.term</code></td>
<td>
<p>The term from the <code>Error</code> function for which the 
residuals are to be extracted. If <code>error.term</code> is 
<code>NULL</code> the residuals are extracted from the last 
<code>Error</code> term.</p>
</td></tr>
<tr><td><code id="residuals.aovlist_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>vector</code> containing the residuals.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.errors">fitted.errors</a></code>, <code><a href="#topic+resid.errors">resid.errors</a></code>, 
<code><a href="#topic+tukey.1df">tukey.1df</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up data frame for randomized complete block design in Table 4.4 from 
## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
## New York, Wiley.
RCBDPen.dat &lt;- fac.gen(list(Blend=5, Flask=4))
RCBDPen.dat$Treat &lt;- factor(rep(c("A","B","C","D"), times=5))
RCBDPen.dat$Yield &lt;- c(89,88,97,94,84,77,92,79,81,87,87,
                       85,87,92,89,84,79,81,80,88)

## perform the analysis of variance
RCBDPen.aov &lt;- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
summary(RCBDPen.aov)

## two equivalent ways of extracting the residuals
res  &lt;- residuals.aovlist(RCBDPen.aov)
res &lt;- residuals(RCBDPen.aov, error.term = "Blend:Flask")
</code></pre>

<hr>
<h2 id='rmvnorm'>generates a vector of random values from a multivariate normal distribution</h2><span id='topic+rmvnorm'></span>

<h3>Description</h3>

<p>Generates a vector of random values from an n-dimensional 
multivariate normal distribution whose mean is given by the 
n-vector <code>mean</code> and variance by the 
n x n symmetric matrix <code>V</code>. It uses the method described by 
Ripley (1987, p.98)</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm(mean, V, method = 'eigenanalysis')</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm_+3A_mean">mean</code></td>
<td>
<p>The mean vector of the multivariate normal distribution from which 
the random values are to be generated.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_v">V</code></td>
<td>
<p>The variance matrix of the multivariate normal distribution from which 
the random values are to be generated.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_method">method</code></td>
<td>
<p>The method used to decompose the variance matrix in producing a 
a matrix to transform the iid standard normal values. The two 
methods available are <code>'eigenanalysis'</code> and <code>'choleski'</code>, 
where only the first letter of each option is obligatory. 
The default <code>method</code> is eigenanalysis, which is slower but 
is likely to be more stable than Choleski decomposition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is:
a) uses either the eigenvalue or Choleski decomposition of the variance matrix, 
<code>V</code>, to form the matrix that transforms an iid vector of values to a 
vector with variance <code>V</code>;
b) generate a vector of length equal to <code>mean</code> of standard normal values;
c) premultiply the vector of standard normal values by the transpose of the 
upper triangular factor and, to the result, add <code>mean</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+vector">vector</a></code> of length n, equal to the length of <code>mean</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Ripley, B. D. (1987) <em>Stochastic simulation</em>. Wiley, New York.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fac.ar1mat">fac.ar1mat</a></code>,  <code><a href="#topic+fac.vcmat">fac.vcmat</a></code>, 
in package <span class="pkg">dae</span>, <code><a href="stats.html#topic+rnorm">rnorm</a></code>, and <code><a href="Matrix.html#topic+chol">chol</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up a two-level factor and a three-level factor, both of length 12
A &lt;- factor(rep(1:2, each=6))
B &lt;- factor(rep(1:3, each=2, times=2))

## generate random values from a multivariate normal for which 
#the mean is 20 for all variables and 
#the variance matrix has random effects for factor A, ar1 pattern for B and 
#residual random variation
mean &lt;- rep(20, 12)
V &lt;- fac.vcmat(A, 5) + fac.ar1mat(B, 0.6) + 2*mat.I(12)
y &lt;- rmvnorm(mean, V)
</code></pre>

<hr>
<h2 id='Sensory3Phase.dat'>Data for the three-phase sensory evaluation experiment in Brien, C.J. and Payne,
R.W. (1999)</h2><span id='topic+Sensory3Phase.dat'></span><span id='topic+Sensory3PhaseShort.dat'></span>

<h3>Description</h3>

<p>The data is from an experiment involved two phases.  In the field phase 
a viticultural
experiment was conducted to investigate the differences between 4
types of trellising and 2 methods of pruning.  The design was a
split-plot design in which the trellis types were assigned to the main
plots using two adjacent Youden squares of 3 rows and 4 columns.  Each
main plot was split into two subplots (or halfplots) and the methods
of pruning assigned at random independently to the two halfplots in
each main plot.  The produce of each halfplot was made into a wine so
that there were 24 wines altogether.
</p>
<p>The second phase was an evaluation phase in which the produce from the
halplots was evaluated by 6 judges all of whom took part in 24
sittings.  In the first 12 sittings the judges evaluated the wines
made from the halfplots of one square; the final 12 sittings were to
evaluate the wines from the other square.  At each sitting, each judge
assessed two glasses of wine from each of the halplots of one of the
main plots.  The main plots allocated to the judges at each sitting
were determined as follows.  For the allocation of rows, each occasion
was subdivided into 3 intervals of 4 consecutive sittings.  During
each interval, each judge examined plots from one particular row,
these being determined using two 3x3 Latin squares for each occasion,
one for judges 1-3 and the other for judges 4-6.  At each sitting
judges 1-3 examined wines from one particular column and judges 4-6
examined wines from another column.  The columns were randomized to
the 2 sets of judges x 3 intervals x 4 sittings using duplicates of a
balanced incomplete block design for v=4 and k=2 that were latinized.
This balanced incomplete block design consists of three sets of 2
blocks, each set containing the 4 &quot;treatments&quot;.  For each interval, a
different set of 2 blocks was taken and each block assigned to two
sittings, but with the columns within the block placed in reverse
order in one sitting compared to the other sitting.  Thus, in each
interval, a judge would evaluate a wine from each of the 4 columns.
</p>
<p>The <code>data.frame</code> contains the following factors, in  the order give: 
Occasion, Judges, Interval, Sittings, Position, Squares, Rows, Columns, 
Halfplot, Trellis, Method. They are followed by the simulated response 
variable Score.
</p>
<p>The scores are ordered so that the factors Occasion, Judges, Interval,
Sittings and Position are in standard order; the remaining factors are
in randomized order.
</p>
<p>See also the vignette accessed via <code>vignette("DesignNotes", package="dae")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sensory3Phase.dat)
data(Sensory3PhaseShort.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 576 observations of 12 variables. 
There are two versions, one with shorter factor names than the other.
</p>


<h3>References</h3>

<p>Brien, C.J. and Payne, R.W. (1999) Tiers, structure formulae 
and the analysis of complicated experiments. <em>The Statistician</em>, <b>48</b>, 41-52.
</p>

<hr>
<h2 id='set.daeTolerance'>Sets the values of daeTolerance for the package dae</h2><span id='topic+set.daeTolerance'></span>

<h3>Description</h3>

<p>A function that sets the values such that, in <span class="pkg">dae</span> functions, 
values less than it are considered to be zero. The values are stored 
in a <code>vector</code> named <code>daeTolerance</code> in the <code>daeEnv</code> 
environment. The <code>vector</code> is of length two and, initially, both 
values are set to <code>.Machine$double.eps ^ 0.5</code> (about 1.5E-08). 
One value is named <code>element.tol</code> and is used for elements of 
matrices; the second is named <code>element.eigen</code> and is used for 
eigenvalues and quantities based on them, such as efficiency factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.daeTolerance(element.tol=NULL, eigen.tol=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.daeTolerance_+3A_element.tol">element.tol</code></td>
<td>
<p>The value to to which the first element of the <code>daeTolerance</code> 
<code>vector</code> is to be set. If more than one value is 
supplied, only the first value is used. </p>
</td></tr>
<tr><td><code id="set.daeTolerance_+3A_eigen.tol">eigen.tol</code></td>
<td>
<p>The value to to which the second element of the <code>daeTolerance</code> 
<code>vector</code> is to be set. If more than one value is 
supplied, only the first value is used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>vector</code> <code>daeTolerance</code> is returned invisibly.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.daeTolerance">get.daeTolerance</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set daeTolerance.
set.daeTolerance(1E-04, 1E-08)
</code></pre>

<hr>
<h2 id='show-methods'>Methods for Function show in Package dae</h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2CclassRepresentation-method'></span><span id='topic+show+2CgenericFunction-method'></span><span id='topic+show+2CMethodDefinition-method'></span><span id='topic+show+2CMethodSelectionReport-method'></span><span id='topic+show+2CMethodWithNext-method'></span><span id='topic+show+2CObjectsWithPackage-method'></span><span id='topic+show+2ColdClass-method'></span><span id='topic+show+2Cprojector-method'></span><span id='topic+show+2Csignature-method'></span><span id='topic+show+2Ctraceable-method'></span>

<h3>Description</h3>

<p>Methods for function <code>show</code> in Package <span class="pkg">dae</span></p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "projector")</code></dt><dd><p>Prints the <code><a href="base.html#topic+matrix">matrix</a></code> and its degrees of freedom.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>

<hr>
<h2 id='SPLGrass.dat'>Data for an experiment to investigate the effects of grazing patterns on
pasture composition</h2><span id='topic+SPLGrass.dat'></span>

<h3>Description</h3>

<p>The response variable is the percentage area covered by the principal grass 
(Main.Grass). The design for the experiment is a split-unit design. The main units 
are arranged in 3 Rows x 3 Columns. Each main unit is split into 
2 SubRows x 2 SubColumns.
</p>
<p>The factor Period, with levels 3, 9 and 18 days, is assigned to the main units 
using a 3 x 3 Latin square. The two-level factors Spring and Summer are 
assigned to split-units using a criss-cross design within each main unit. 
The levels of each of Spring and Summer are two different grazing patterns in its season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SPLGrass.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 36 observations of 8 variables.</p>


<h3>Source</h3>

<p>Example 14.1 from Mead, R. (1990). <em>The Design of Experiments: 
Statistical Principles for Practical Application.</em> Cambridge, 
Cambridge University Press.</p>

<hr>
<h2 id='strength'>Generate paper strength values</h2><span id='topic+strength'></span>

<h3>Description</h3>

<p>Generates paper strength values for an experiment with different
temperatures.</p>


<h3>Usage</h3>

<pre><code class='language-R'>strength(nodays, noruns, temperature, ident)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strength_+3A_nodays">nodays</code></td>
<td>
<p>The number of days over which the experiment is to be run.</p>
</td></tr>
<tr><td><code id="strength_+3A_noruns">noruns</code></td>
<td>
<p>The number of runs to be performed on each day of the experiment.</p>
</td></tr>
<tr><td><code id="strength_+3A_temperature">temperature</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> that encapsulates the layout by giving the
temperature to be investigated for each run on each day.
These must be ordered so that the temperatures for the
first day are given in the order in which they are to be
investigated on that day. These must be followed by the
noruns temperatures for the second day and so on.
Consequently, the factor temperature will have nodays*noruns
values.</p>
</td></tr>
<tr><td><code id="strength_+3A_ident">ident</code></td>
<td>
<p>The digits of your student identity number. That is, leave out
any letters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> object containing the <code>factors</code> day, run and 
temperature and a <code>vector</code> of the generated strengths.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Here temperature is a factor with 4*3 = 12 values whose
## first 3 values specify the temperatures to be applied in
## the 3 runs on the first day, values 4 to 6 specify the
## temperatures for the 3 runs on day 2, and so on.
temperature &lt;- factor(rep(c(80,85,90), 4))
exp.strength &lt;- strength(nodays = 4, noruns = 3,
                         temperature = temperature, ident = 0123456)

## In this second example, a completely randomized design is generated 
## for the same 3 temperatures replicated 4 times. The layout is stored 
## in the data.frame called Design.
Design &lt;- designRandomize(allocated = temperature, 
                          recipient = list(runs = 12), 
                          seed = 5847123)
## eradicate the unrandomized version of temperature
remove("temperature")

## The 12 temperatures in Design are to be regarded as being assigned to 
## days and runs in the same manner as for the first example.
exp.strength &lt;- strength(nodays = 4, noruns = 3,
                         temperature = Design$temperature, ident = 0123456)
</code></pre>

<hr>
<h2 id='summary.p2canon'>Summarize a canonical analysis of the relationships between two sets of projectors</h2><span id='topic+summary.p2canon'></span><span id='topic+summary+2Cp2canon-method'></span>

<h3>Description</h3>

<p>Produces a summary of the efficiency criteria computed from the 
canonical efficiency factors for the joint decomposition of two 
sets of projectors (Brien and Bailey, 2009) obtained using 
<code><a href="#topic+projs.2canon">projs.2canon</a></code>. It takes the form of a decomposition or skeleton 
ANOVA table.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'p2canon'
summary(object, which.criteria = c("aefficiency", "eefficiency", "order"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.p2canon_+3A_object">object</code></td>
<td>
<p>A <code>list</code> of class <code>p2canon</code> produced by 
<code>projs.2canon</code>.</p>
</td></tr>
<tr><td><code id="summary.p2canon_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A character <code>vector</code> nominating the efficiency 
criteria to be included in the summary. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>,
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>.</p>
</td></tr>
<tr><td><code id="summary.p2canon_+3A_...">...</code></td>
<td>
<p>further arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of classes <code>summary.p2canon</code> and <code>data.frame</code>, whose 
rows correspond to the pairs of projectors, one from the 
<code>Q1</code> argument and the other from the <code>Q2</code> argument from 
<code><a href="#topic+projs.2canon">projs.2canon</a></code>; only pairs with non-zero efficiency factors  
are included. In addition, a line is included for each nonzero Residual 
<code>Q1</code> projector.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. and R. A. Bailey (2009). Decomposition tables for 
multitiered experiments. I. A chain of randomizations.  
<em>The Annals of Statistics</em>, <b>36</b>, 4184 - 4213.</p>


<h3>See Also</h3>

<p><code><a href="#topic+projs.2canon">projs.2canon</a></code>, <code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, 
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>, <code><a href="#topic+proj2.combine">proj2.combine</a></code>,  
<code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, <code><a href="#topic+pstructure">pstructure</a></code>, <br /> 
<code><a href="#topic+print.summary.p2canon">print.summary.p2canon</a></code>in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain projectors using pstructure
unit.struct &lt;- pstructure(~ Block/Unit, data = PBIBD2.lay)
trt.struct &lt;- pstructure(~ trt, data = PBIBD2.lay)

##obtain combined decomposition and summarize
unit.trt.p2canon &lt;- projs.2canon(unit.struct$Q, trt.struct$Q)
summary(unit.trt.p2canon)
</code></pre>

<hr>
<h2 id='summary.pcanon'>Summarizes the anatomy of a design, being the decomposition of the sample space based on its 
canonical analysis, as produced by designAnatomy</h2><span id='topic+summary.pcanon'></span><span id='topic+summary+2Cpcanon-method'></span>

<h3>Description</h3>

<p>Gives the anatomy of a design in a table; it summarizes the joint decomposition of two or 
more sets of projectors (Brien and Bailey, 2009) obtained using 
<code><a href="#topic+designAnatomy">designAnatomy</a></code>. It includes the efficiency criteria computed 
from the canonical efficiency factors for the joint decomposition. The labels in 
the table may be Terms or Sources. The terms are those that would be included in a 
mixed model for an experiment based on the design. The sources are the orthogonal 
subspaces, derived from the terms, that make up the decomposition and the degrees 
of freedom and efficiency factors relate to these subspaces. The table displays 
how the information for the different sources allowed for in the design are related. 
For more information about the notation used for sources see the <code>labels</code> argument of 
<code><a href="#topic+designAnatomy">designAnatomy</a></code>.
</p>
<p>It is possible to supply an <code>object</code> that is a <code><a href="#topic+pcanon.object">pcanon.object</a></code> produced in 
versions prior to 3.0-0 using <code>projs.canon</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcanon'
summary(object, labels.swap = FALSE, 
        which.criteria = c("aefficiency", "eefficiency", "order"), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pcanon_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+pcanon.object">pcanon.object</a></code>.</p>
</td></tr>
<tr><td><code id="summary.pcanon_+3A_labels.swap">labels.swap</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to swap between &quot;sources&quot; and 
&lsquo;terms&rsquo; in the output. The default is established by the <code>labels</code> 
argument of <code><a href="#topic+designAnatomy">designAnatomy</a></code> and <code><a href="#topic+projs.canon">projs.canon</a></code>.</p>
</td></tr>
<tr><td><code id="summary.pcanon_+3A_which.criteria">which.criteria</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> <code>vector</code> nominating the efficiency 
criteria to be included in the summary. It can be 
<code>none</code>, <code>all</code> or some combination of 
<code>aefficiency</code>, <code>mefficiency</code>,
<code>sefficiency</code>, <code>eefficiency</code>, <code>xefficiency</code>, 
<code>order</code> and <code>dforthog</code> &ndash; for details see 
<code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>. 
If there is only one formula, this 
argument is ignored.</p>
</td></tr>
<tr><td><code id="summary.pcanon_+3A_...">...</code></td>
<td>
<p>further arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.pcanon</code> that is a <code><a href="base.html#topic+list">list</a></code> with the two
components <code>decomp</code> and <code>aliasing</code>. 
</p>
<p>The component <code>decomp</code> is a <code>data.frame</code> whose rows correspond to subspaces 
in the decomposition for a design. It has the following <code>attribute</code>s: 
(i) <code>title</code> that is the title for printing with the decomposition table; 
(ii) <code>ntiers</code> that is equal to the number of tiers; (iii) <code>orthogonal</code> that is 
<code>TRUE</code> if the design is orthogonal; (iv) <code>labels</code> that is either &quot;terms&quot; or 
&quot;sources&quot; depending on the <code>labels</code> that have resulted from the setting 
of <code>label.swap</code>.
</p>
<p>The component <code>aliasing</code> is a <code>data.frame</code> that is also of <code>class</code> 
<code>aliasing</code>. It contains information about the aliasing between terms that are 
derived from the same formula and has the attribute <code>title</code> that is the title 
to be printed with the aliasing table.
</p>
<p>However, if the <code>object</code> supplied is a <code><a href="#topic+pcanon.object">pcanon.object</a></code> produced with  
versions prior to 3.0-0 using <code>projs.canon</code>, the value is a <code>data.frame</code>, 
instead of a <code>list</code>, that has the same <code>attribute</code>s as the <code>decomp</code> 
component of the <code>summary.pcanon</code> object now produced, except that <code>labels</code> 
is always set to &quot;terms&quot;.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Brien, C. J. and R. A. Bailey (2009). Decomposition tables for 
multitiered experiments. I. A chain of randomizations.  
<em>The Annals of Statistics</em>, <b>36</b>, 4184 - 4213.</p>


<h3>See Also</h3>

<p><code><a href="#topic+designAnatomy">designAnatomy</a></code>, <code><a href="#topic+designAnatomy">designAnatomy</a></code>, ,
<code><a href="#topic+pstructure">pstructure</a></code>, <code><a href="#topic+efficiency.criteria">efficiency.criteria</a></code>, 
<code><a href="#topic+proj2.combine">proj2.combine</a></code>, <br /> 
<code><a href="#topic+proj2.efficiency">proj2.efficiency</a></code>, <code><a href="#topic+proj2.eigen">proj2.eigen</a></code>, 
<code><a href="#topic+print.summary.pcanon">print.summary.pcanon</a></code>in package <span class="pkg">dae</span>, 
<code><a href="base.html#topic+eigen">eigen</a></code>.
</p>
<p><code><a href="#topic+projector-class">projector</a></code> for further information about this class.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## PBIBD(2) from p. 379 of Cochran and Cox (1957) Experimental Designs. 
## 2nd edn Wiley, New York
PBIBD2.unit &lt;- list(Block = 6, Unit = 4)
PBIBD2.nest &lt;- list(Unit = "Block")
trt &lt;- factor(c(1,4,2,5, 2,5,3,6, 3,6,1,4, 4,1,5,2, 5,2,6,3, 6,3,4,1))
PBIBD2.lay &lt;- designRandomize(allocated = trt, 
                              recipient = PBIBD2.unit, 
                              nested.recipients = PBIBD2.nest)

##obtain combined decomposition and summarize
unit.trt.canon &lt;- designAnatomy(list(unit=~ Block/Unit, trt=~ trt), 
                                data = PBIBD2.lay)
summary(unit.trt.canon, which = c("aeff","eeff","order"))
summary(unit.trt.canon, which = c("aeff","eeff","order"), labels.swap = TRUE)
</code></pre>

<hr>
<h2 id='tukey.1df'>Performs Tukey's one-degree-of-freedom-test-for-nonadditivity</h2><span id='topic+tukey.1df'></span>

<h3>Description</h3>

<p>Performs Tukey's one-degree-of-freedom-test-for-nonadditivity 
on a set of residuals from an analysis of variance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukey.1df(aov.obj, data, error.term="Within")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukey.1df_+3A_aov.obj">aov.obj</code></td>
<td>
<p>An <code>aov</code> object or <code>aovlist</code> object created from a call to 
<code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
<tr><td><code id="tukey.1df_+3A_error.term">error.term</code></td>
<td>
<p>The term from the <code>Error</code> function whose residuals are 
to be tested for nonadditivity. Only required when the <code>Error</code> 
function used in call to <code>aov</code>, so that an  <code>aovlist</code> object 
is created.</p>
</td></tr>
<tr><td><code id="tukey.1df_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the original response variable and 
factors used in the call to <code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing Tukey.SS, Tukey.F, Tukey.p, Devn.SSq being the SSq 
for the 1df test, F value for test and the p-value for the test.</p>


<h3>Note</h3>

<p>In computing the test quantities fitted values must be obtained. 
If <code>error.term</code> is specified, fitted values will be the sum of 
effects extracted from terms from the <code>Error</code> function, but only down 
to that specified by <code>error.term</code>.The order of terms is as given in the 
ANOVA table. If <code>error.term</code> is unspecified, all effects for terms 
external to any <code>Error</code> terms are extracted and summed.
</p>
<p>Extracted effects will only be for terms external to any <code>Error</code> function. 
If you want effects for terms in the <code>Error</code> function to be included, 
put them both inside and outside the <code>Error</code> function so they are 
occur twice.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.errors">fitted.errors</a></code>, <code><a href="#topic+resid.errors">resid.errors</a></code> in package <span class="pkg">dae</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set up data frame for randomized complete block design in Table 4.4 from 
## Box, Hunter and Hunter (2005) Statistics for Experimenters. 2nd edn 
## New York, Wiley.
RCBDPen.dat &lt;- fac.gen(list(Blend=5, Flask=4))
RCBDPen.dat$Treat &lt;- factor(rep(c("A","B","C","D"), times=5))
RCBDPen.dat$Yield &lt;- c(89,88,97,94,84,77,92,79,81,87,87,
                       85,87,92,89,84,79,81,80,88)

## perform the analysis of variance
RCBDPen.aov &lt;- aov(Yield ~ Blend + Treat + Error(Blend/Flask), RCBDPen.dat)
summary(RCBDPen.aov)

## Obtain the quantities for Tukey's test
tukey.1df(RCBDPen.aov, RCBDPen.dat, error.term = "Blend:Flask")
</code></pre>

<hr>
<h2 id='yates.effects'>Extract Yates effects</h2><span id='topic+yates.effects'></span>

<h3>Description</h3>

<p>Extracts Yates effects from an <code>aov</code> object or <code>aovlist</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>yates.effects(aov.obj, error.term="Within", data=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yates.effects_+3A_aov.obj">aov.obj</code></td>
<td>
<p>An <code>aov</code> object or <code>aovlist</code> object created from a call to 
<code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
<tr><td><code id="yates.effects_+3A_error.term">error.term</code></td>
<td>
<p>The term from the <code>Error</code> function from which the Yates 
effects are estimated. Only required when <code>Error</code> used 
in call to <code>aov</code>.</p>
</td></tr>
<tr><td><code id="yates.effects_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which the variables specified in the <code>aov.obj</code>
will be found. If missing, the variables are searched for in
the standard way.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Yates effects are specific to <code class="reqn">2^k</code> experiments, where Yates
effects are conventionally defined as the difference between the upper
and lower levels of a factor. We follow the convention used in
Box, Hunter and Hunter (1978) for scaling of higher order interactions:
all the Yates effects are on the same scale, and represent the average
difference due to the interaction between two different levels.
Effects are estimated only from the error term supplied to the
<code>error.term</code> argument.</p>


<h3>Value</h3>

<p>A <code>vector</code> of the Yates effects.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqyeffects">qqyeffects</a></code> in package <span class="pkg">dae</span>, <code><a href="stats.html#topic+aov">aov</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## analysis of 2^4 factorial experiment from Table 10.6 of Box, Hunter and 
## Hunter (1978) Statistics for Experimenters. New York, Wiley.
## use ?Fac4Proc.dat for data set details
data(Fac4Proc.dat)
Fac4Proc.aov &lt;- aov(Conv ~ Catal * Temp * Press * Conc + Error(Runs),
                                                            Fac4Proc.dat)
round(yates.effects(Fac4Proc.aov, error.term="Runs", data=Fac4Proc.dat), 2)
</code></pre>

<hr>
<h2 id='Zncsspline'>Calculates the design matrix for fitting the random component of a natural 
cubic smoothing spline</h2><span id='topic+Zncsspline'></span>

<h3>Description</h3>

<p>Calculates the design matrix, <b>Z</b>, of the random effects for a 
natural cubic smoothing spline as described by Verbyla et al., (1999). 
An initial design matrix, 
<code class="reqn">\bold{\Delta} \bold{\Delta}^{-1} \bold{\Delta}</code>, 
based on the knot points is computed. It can 
then be post multiplied by the power of the tri-diagonal matrix 
<code class="reqn">\bold{G}_s</code> that is proportional to the variance matrix of the 
random spline effects. If the power is set to 0.5 then the random 
spline effects based on the resulting Z matrix will be independent 
with variance <code class="reqn">\sigma_s^2</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zncsspline(knot.points, Gpower = 0, print = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zncsspline_+3A_knot.points">knot.points</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the values of the knot points 
to be used in fitting the spline. These must be orderd in increasing order.</p>
</td></tr>
<tr><td><code id="Zncsspline_+3A_gpower">Gpower</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the power of the tri-diagonal matrix 
<code class="reqn">\bold{G}_s</code> from which the variance matrix of the random spline 
effects is caluclated. that the initial design matrix is to be 
the value of the variance component for the random spline effects. 
The smoothing parameter is then the inverse of the ratio of this 
component to the residual variance.</p>
</td></tr>
<tr><td><code id="Zncsspline_+3A_print">print</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to print the 
<code class="reqn">\bold{\Delta}</code> and <code class="reqn">\bold{G}_s</code> matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> containing the design matrix.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Verbyla, A. P., Cullis, B. R., Kenward, M. G., and Welham, S. J. (1999). 
The analysis of designed experiments and longitudinal data by using 
smoothing splines (with discussion). <em>Journal of the Royal 
Statistical Society, Series C (Applied Statistics)</em>, <b>48</b>, 269-311.</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat.ncssvar">mat.ncssvar</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- Zncsspline(knot.points = 1:10, Gpower = 0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
