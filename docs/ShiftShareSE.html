<!DOCTYPE html><html lang="en-US"><head><title>Help for package ShiftShareSE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ShiftShareSE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ADH'><p>Dataset from Autor, Dorn and Hanson (2013)</p></a></li>
<li><a href='#ivreg_ss'><p>Inference in an IV regression with a shift-share instrument</p></a></li>
<li><a href='#ivreg_ss.fit'><p>Inference in an IV regression with a shift-share instrument</p></a></li>
<li><a href='#reg_ss'><p>Inference in linear regression with a shift-share regressor</p></a></li>
<li><a href='#reg_ss.fit'><p>Inference in a shift-share regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Inference in Regressions with Shift-Share Structure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides confidence intervals in least-squares regressions when the
  variable of interest has a shift-share structure, and in instrumental
  variables regressions when the instrument has a shift-share structure. The
  confidence intervals implement the AKM and AKM0 methods developed in Adão,
  Kolesár, and Morales (2019) &lt;<a href="https://doi.org/10.1093%2Fqje%2Fqjz025">doi:10.1093/qje/qjz025</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, AER, spelling, formatR</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kolesarm/ShiftShareSE">https://github.com/kolesarm/ShiftShareSE</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kolesarm/ShiftShareSE/issues">https://github.com/kolesarm/ShiftShareSE/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-24 02:12:09 UTC; kolesarm</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Kolesár <a href="https://orcid.org/0000-0002-2482-7796"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Eduardo Morales [ctb],
  Rodrigo Adão [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Kolesár &lt;kolesarmi@googlemail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-24 03:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='ADH'>Dataset from Autor, Dorn and Hanson (2013)</h2><span id='topic+ADH'></span>

<h3>Description</h3>

<p>Subset of data from Autor, Dorn and Hanson (2013, ADH) that is used to
illustrate the confidence intervals implemented in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADH
</code></pre>


<h3>Format</h3>

<p>A list, consisting of a data frame, a vector, and a matrix. The first
data frame, <code>ADH$reg</code>, has 1,444 rows and 16 variables. The rows
correspond to 722 commuting zones (CZ) over 2 time periods (1990-1999 and
2000-2007), and the variables are as follows:
</p>

<dl>
<dt>d_sh_empl</dt><dd><p>Change in the share of working-age population</p>
</dd>
<dt>d_sh_empl_mfg</dt><dd><p>Change in the share of working-age population employed
in manufacturing.</p>
</dd>
<dt>d_sh_empl_nmfg</dt><dd><p>Change in the share of working-age population employed
in non-manufacturing.</p>
</dd>
<dt>shock</dt><dd><p>Change in sectoral U.S. imports from China normalized by U.S.
total employment in the corresponding sector, aggregated to regional level.
This is the variable of interest in ADH.</p>
</dd>
<dt>IV</dt><dd><p>Change in sectoral imports from China by rest of the world,
aggregated to regional level. This is the variable used to instrument for
<code>shock</code>, called <code>d_tradeotch_pw_lag</code> in ADH.</p>
</dd>
<dt>weights</dt><dd><p>Regression weights corresponding to start of period CZ share
of national populations</p>
</dd>
<dt>statefip</dt><dd><p>State FIPS code</p>
</dd>
<dt>czone</dt><dd><p>CZ number</p>
</dd>
<dt>t2</dt><dd><p>Indicator for 2000-2007</p>
</dd>
<dt>l_shind_manuf_cbp</dt><dd><p>Employment share of manufacturing</p>
</dd>
<dt>l_sh_popedu_c</dt><dd><p>percent population college-educated</p>
</dd>
<dt>l_sh_popfborn</dt><dd><p>percent population foreign-born</p>
</dd>
<dt>l_sh_empl_f</dt><dd><p>percent employment among women</p>
</dd>
<dt>l_sh_routine33</dt><dd><p>percent employment in routine occupations</p>
</dd>
<dt>l_task_outsource</dt><dd><p>Offshorability index of occupations in CZ</p>
</dd>
<dt>division</dt><dd><p>US Census division of CZ</p>
</dd>
</dl>

<p>The second list component, the vector <code>ADH$sic</code> is a vector of length
770 that gives 4-digit SIC industry codes for the sectors used to construct
the shift-share IV <code>ADH$reg$IV</code>. Finally, <code>ADH$W</code> is a 1444-by-700
matrix of shares that correspond to the CZ employment shares in 4-digit SIC
sectors.
</p>


<h3>Source</h3>

<p>We thank David Dorn for helping us with the construction of the share
matrix. The remaining data was obtained from David Dorn's website,
<a href="http://ddorn.net/data.htm">http://ddorn.net/data.htm</a>.
</p>


<h3>References</h3>


<p><cite>Autor, David H., David Dorn, and Gordon H. Hanson, &quot;The China syndrome:
Local labor market effects of import competition in the United States,&quot;
American Economic Review, 2013, 103 (6), 2121–2168.
doi: <a href="https://doi.org/10.1257/aer.103.6.2121">10.1257/aer.103.6.2121</a>.</cite>
</p>
<p><cite>Adão, Rodrigo, Kolesár, Michal, and Morales, Eduardo,
&quot;Shift-Share Designs: Theory and Inference&quot;, Quarterly Journal of Economics
2019, 134 (4), 1949-2010. doi: <a href="https://doi.org/10.1093/qje/qjz025">10.1093/qje/qjz025</a>.</cite>
</p>


<hr>
<h2 id='ivreg_ss'>Inference in an IV regression with a shift-share instrument</h2><span id='topic+ivreg_ss'></span>

<h3>Description</h3>

<p>Computes confidence intervals and p-values in an instrumental variables
regression in which the instrument has a shift-share structure, as in Bartik
(1991). Several different inference methods can computed, as specified by
<code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivreg_ss(
  formula,
  X,
  data,
  W,
  subset,
  weights,
  method,
  beta0 = 0,
  alpha = 0.05,
  region_cvar = NULL,
  sector_cvar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ivreg_ss_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"formula"</code> (or one that can be
coerced to that class) of the form <code>outcome ~ controls |
endogenous_regressor</code>. For a regression with no controls (only an
intercept), it takes the form <code>outcome ~ 1 | endogenous_regressor</code></p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_x">X</code></td>
<td>
<p>Shift-share vector with length <code>N</code> of sectoral shocks,
aggregated to regional level using the share matrix <code>W</code>. That is,
each element of <code>X</code> corresponds to a region.</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment (or object coercible
by <code>as.data.frame</code> to a data frame) containing the outcome and
running variables in the model. If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>, typically the
environment from which the function is called. Each row in the data frame
corresponds to a region.</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_w">W</code></td>
<td>
<p>A matrix of sector shares, so that <code>W[i, s]</code> corresponds to
share of sector <code>s</code> in region <code>i</code>. The ordering of the regions
must coincide with that in the other inputs, such as <code>X</code>. The
ordering of the sectors in the columns of <code>W</code> is irrelevant but the
identity of the sectors in must coincide with those used to construct
<code>X</code>.</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights to be used in the fitting
process. Should be <code>NULL</code> or a numeric vector, with each row
corresponding to a region. If non-<code>NULL</code>, for computing the first
stage and the reduced form, weighted least squares is used with weights
<code>weights</code> (that is, we minimize <code>sum(weights*residuals^2)</code>);
otherwise ordinary least squares is used.</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_method">method</code></td>
<td>
<p>Vector specifying which inference methods to use. The vector
elements have to be one or more of the following strings:
</p>

<dl>
<dt><code>"homosk"</code></dt><dd><p>Assume i.i.d. homoskedastic errors</p>
</dd>
<dt><code>"ehw"</code></dt><dd><p>Eicker-Huber-White standard errors</p>
</dd>
<dt><code>"region_cluster"</code></dt><dd><p>Standard errors clustered at regional level</p>
</dd>
<dt><code>"akm"</code></dt><dd><p>Adão-Kolesár-Morales</p>
</dd>
<dt><code>"akm0"</code></dt><dd><p>Adão-Kolesár-Morales with null imposed. Note the
reported standard error for this method corresponds to the normalized
standard error, given by the length of the confidence interval divided by
<code class="reqn">2z_{1-\alpha/2}</code></p>
</dd>
<dt><code>"all"</code></dt><dd><p>All of the methods above</p>
</dd></dl>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_beta0">beta0</code></td>
<td>
<p>null that is tested (only affects reported p-values)</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_alpha">alpha</code></td>
<td>
<p>Determines confidence level of reported confidence intervals,
which will have coverage <code>1-alpha</code>.</p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_region_cvar">region_cvar</code></td>
<td>
<p>A vector with length <code>N</code> of cluster variables, for
method <code>"cluster_region"</code>. If the vector <code>1:N</code> is used,
clustering is effectively equivalent to <code>ehw</code></p>
</td></tr>
<tr><td><code id="ivreg_ss_+3A_sector_cvar">sector_cvar</code></td>
<td>
<p>A vector with length <code>S</code> of cluster variables, if
sectors are to be clustered, for methods <code>"akm"</code> and <code>"akm0"</code>.
If the vector <code>1:S</code> is used, this is equivalent to not clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"SSResults"</code> containing the
estimation and inference results. The <code>print</code> function can be used
to print a summary of the results. The object is a list with at least the
following components: </p>

<dl>
<dt>beta</dt><dd><p>Point estimate of the effect of interest <code class="reqn">\beta</code></p>
</dd>
<dt>se, p</dt><dd><p>A vector of standard errors and a vector of p-values of the null
<code class="reqn">H_{0}\colon \beta = \beta_{0}</code> for the inference
methods in <code>method</code>, with <code class="reqn">\beta_{0}</code> specified by the
argument <code>beta0</code>. For the method <code>"akm0"</code>, the standard error
corresponds to the effective standard error (length of the confidence
interval divided by <code>2*stats::qnorm(1-alpha/2)</code>)</p>
</dd>
<dt>ci.l, ci.r</dt><dd><p>Upper and lower endpoints of the confidence interval for
the effect of interest <code class="reqn">\beta</code>, for each of the methods in
<code>method</code></p>
</dd>
</dl>



<h3>Note</h3>

<p><code>subset</code> is evaluated in the same way as variables in
<code>formula</code>, that is first in <code>data</code> and then in the environment
of <code>formula</code>.
</p>


<h3>References</h3>


<p><cite>Bartik, Timothy J., Who Benefits from State and Local Economic
Development Policies?, Kalamazoo, MI: W.E. Upjohn Institute for Employment
Research, 1991.</cite>
</p>
<p><cite>Adão, Rodrigo, Kolesár, Michal, and Morales, Eduardo,
&quot;Shift-Share Designs: Theory and Inference&quot;, Quarterly Journal of Economics
2019, 134 (4), 1949-2010. doi: <a href="https://doi.org/10.1093/qje/qjz025">10.1093/qje/qjz025</a>.</cite>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## Use ADH data from Autor, Dorn, and Hanson (2013)
ivreg_ss(d_sh_empl ~ 1 | shock, X=IV, data=ADH$reg, W=ADH$W,
         method=c("ehw", "akm", "akm0"))
</code></pre>

<hr>
<h2 id='ivreg_ss.fit'>Inference in an IV regression with a shift-share instrument</h2><span id='topic+ivreg_ss.fit'></span>

<h3>Description</h3>

<p>Basic computing engine to calculate confidence intervals and p-values in an
instrumental variables regression with a shift-share instrument, using
different inference methods, as specified by <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivreg_ss.fit(
  y1,
  y2,
  X,
  W,
  Z,
  w = NULL,
  method = c("akm", "akm0"),
  beta0 = 0,
  alpha = 0.05,
  region_cvar = NULL,
  sector_cvar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ivreg_ss.fit_+3A_y1">y1</code></td>
<td>
<p>Outcome variable. A vector of length <code>N</code>, with each row
corresponding to a region.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_y2">y2</code></td>
<td>
<p>Endogenous variable, vector of length <code>N</code>, with each row
corresponding to a region.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_x">X</code></td>
<td>
<p>Shift-share vector with length <code>N</code> of sectoral shocks,
aggregated to regional level using the share matrix <code>W</code>. That is,
each element of <code>X</code> corresponds to a region.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_w">W</code></td>
<td>
<p>A matrix of sector shares, so that <code>W[i, s]</code> corresponds to
share of sector <code>s</code> in region <code>i</code>. The ordering of the regions
must coincide with that in the other inputs, such as <code>X</code>. The
ordering of the sectors in the columns of <code>W</code> is irrelevant but the
identity of the sectors in must coincide with those used to construct
<code>X</code>.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_z">Z</code></td>
<td>
<p>Matrix of regional controls, matrix with <code>N</code> rows corresponding
to regions.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_w">w</code></td>
<td>
<p>vector of weights (length <code>N</code>) to be used in the fitting
process. If not <code>NULL</code>, weighted least squares is used with weights
<code>w</code>, i.e., <code>sum(w * residuals^2)</code> is minimized.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_method">method</code></td>
<td>
<p>Vector specifying which inference methods to use. The vector
elements have to be one or more of the following strings:
</p>

<dl>
<dt><code>"homosk"</code></dt><dd><p>Assume i.i.d. homoskedastic errors</p>
</dd>
<dt><code>"ehw"</code></dt><dd><p>Eicker-Huber-White standard errors</p>
</dd>
<dt><code>"region_cluster"</code></dt><dd><p>Standard errors clustered at regional level</p>
</dd>
<dt><code>"akm"</code></dt><dd><p>Adão-Kolesár-Morales</p>
</dd>
<dt><code>"akm0"</code></dt><dd><p>Adão-Kolesár-Morales with null imposed. Note the
reported standard error for this method corresponds to the normalized
standard error, given by the length of the confidence interval divided by
<code class="reqn">2z_{1-\alpha/2}</code></p>
</dd>
<dt><code>"all"</code></dt><dd><p>All of the methods above</p>
</dd></dl>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_beta0">beta0</code></td>
<td>
<p>null that is tested (only affects reported p-values)</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_alpha">alpha</code></td>
<td>
<p>Determines confidence level of reported confidence intervals,
which will have coverage <code>1-alpha</code>.</p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_region_cvar">region_cvar</code></td>
<td>
<p>A vector with length <code>N</code> of cluster variables, for
method <code>"cluster_region"</code>. If the vector <code>1:N</code> is used,
clustering is effectively equivalent to <code>ehw</code></p>
</td></tr>
<tr><td><code id="ivreg_ss.fit_+3A_sector_cvar">sector_cvar</code></td>
<td>
<p>A vector with length <code>S</code> of cluster variables, if
sectors are to be clustered, for methods <code>"akm"</code> and <code>"akm0"</code>.
If the vector <code>1:S</code> is used, this is equivalent to not clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"SSResults"</code> containing the
estimation and inference results. The <code>print</code> function can be used
to print a summary of the results. The object is a list with at least the
following components: </p>

<dl>
<dt>beta</dt><dd><p>Point estimate of the effect of interest <code class="reqn">\beta</code></p>
</dd>
<dt>se, p</dt><dd><p>A vector of standard errors and a vector of p-values of the null
<code class="reqn">H_{0}\colon \beta = \beta_{0}</code> for the inference
methods in <code>method</code>, with <code class="reqn">\beta_{0}</code> specified by the
argument <code>beta0</code>. For the method <code>"akm0"</code>, the standard error
corresponds to the effective standard error (length of the confidence
interval divided by <code>2*stats::qnorm(1-alpha/2)</code>)</p>
</dd>
<dt>ci.l, ci.r</dt><dd><p>Upper and lower endpoints of the confidence interval for
the effect of interest <code class="reqn">\beta</code>, for each of the methods in
<code>method</code></p>
</dd>
</dl>


<hr>
<h2 id='reg_ss'>Inference in linear regression with a shift-share regressor</h2><span id='topic+reg_ss'></span>

<h3>Description</h3>

<p>Computes confidence intervals and p-values in a linear regression in which
the regressor of interest has a shift-share structure, as the instrument in
Bartik (1991). Several different inference methods can computed, as specified
by <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_ss(
  formula,
  X,
  data,
  W,
  subset,
  weights,
  method,
  beta0 = 0,
  alpha = 0.05,
  region_cvar = NULL,
  sector_cvar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg_ss_+3A_formula">formula</code></td>
<td>
<p>object of class <code>"formula"</code> (or one that can be coerced
to that class) of the form <code>outcome ~ controls</code>. For a regression
with no controls (only an intercept), it takes the form <code>outcome ~
1</code></p>
</td></tr>
<tr><td><code id="reg_ss_+3A_x">X</code></td>
<td>
<p>Shift-share vector with length <code>N</code> of sectoral shocks,
aggregated to regional level using the share matrix <code>W</code>. That is,
each element of <code>X</code> corresponds to a region.</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_data">data</code></td>
<td>
<p>optional data frame, list or environment (or object coercible by
<code>as.data.frame</code> to a data frame) containing the variables in the
model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which the
function is called. Each row in the data frame corresponds to a region.</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_w">W</code></td>
<td>
<p>A matrix of sector shares, so that <code>W[i, s]</code> corresponds to
share of sector <code>s</code> in region <code>i</code>. The ordering of the regions
must coincide with that in the other inputs, such as <code>X</code>. The
ordering of the sectors in the columns of <code>W</code> is irrelevant but the
identity of the sectors in must coincide with those used to construct
<code>X</code>.</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_subset">subset</code></td>
<td>
<p>optional vector specifying a subset of observations to be used
in the fitting process.</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process. Should be <code>NULL</code> or a numeric vector, with each row
corresponding to a region. If non-<code>NULL</code>, weighted least squares is
used with weights <code>weights</code> (that is, we minimize
<code>sum(weights*residuals^2)</code>); otherwise ordinary least squares is
used.</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_method">method</code></td>
<td>
<p>Vector specifying which inference methods to use. The vector
elements have to be one or more of the following strings:
</p>

<dl>
<dt><code>"homosk"</code></dt><dd><p>Assume i.i.d. homoskedastic errors</p>
</dd>
<dt><code>"ehw"</code></dt><dd><p>Eicker-Huber-White standard errors</p>
</dd>
<dt><code>"region_cluster"</code></dt><dd><p>Standard errors clustered at regional level</p>
</dd>
<dt><code>"akm"</code></dt><dd><p>Adão-Kolesár-Morales</p>
</dd>
<dt><code>"akm0"</code></dt><dd><p>Adão-Kolesár-Morales with null imposed. Note the
reported standard error for this method corresponds to the normalized
standard error, given by the length of the confidence interval divided by
<code class="reqn">2z_{1-\alpha/2}</code></p>
</dd>
<dt><code>"all"</code></dt><dd><p>All of the methods above</p>
</dd></dl>
</td></tr>
<tr><td><code id="reg_ss_+3A_beta0">beta0</code></td>
<td>
<p>null that is tested (only affects reported p-values)</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_alpha">alpha</code></td>
<td>
<p>Determines confidence level of reported confidence intervals,
which will have coverage <code>1-alpha</code>.</p>
</td></tr>
<tr><td><code id="reg_ss_+3A_region_cvar">region_cvar</code></td>
<td>
<p>A vector with length <code>N</code> of cluster variables, for
method <code>"cluster_region"</code>. If the vector <code>1:N</code> is used,
clustering is effectively equivalent to <code>ehw</code></p>
</td></tr>
<tr><td><code id="reg_ss_+3A_sector_cvar">sector_cvar</code></td>
<td>
<p>A vector with length <code>S</code> of cluster variables, if
sectors are to be clustered, for methods <code>"akm"</code> and <code>"akm0"</code>.
If the vector <code>1:S</code> is used, this is equivalent to not clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"SSResults"</code> containing the
estimation and inference results. The <code>print</code> function can be used
to print a summary of the results. The object is a list with at least the
following components: </p>

<dl>
<dt>beta</dt><dd><p>Point estimate of the effect of interest <code class="reqn">\beta</code></p>
</dd>
<dt>se, p</dt><dd><p>A vector of standard errors and a vector of p-values of the null
<code class="reqn">H_{0}\colon \beta = \beta_{0}</code> for the inference
methods in <code>method</code>, with <code class="reqn">\beta_{0}</code> specified by the
argument <code>beta0</code>. For the method <code>"akm0"</code>, the standard error
corresponds to the effective standard error (length of the confidence
interval divided by <code>2*stats::qnorm(1-alpha/2)</code>)</p>
</dd>
<dt>ci.l, ci.r</dt><dd><p>Upper and lower endpoints of the confidence interval for
the effect of interest <code class="reqn">\beta</code>, for each of the methods in
<code>method</code></p>
</dd>
</dl>



<h3>Note</h3>

<p><code>subset</code> is evaluated in the same way as variables in
<code>formula</code>, that is first in <code>data</code> and then in the environment
of <code>formula</code>.
</p>


<h3>References</h3>


<p><cite>Bartik, Timothy J., Who Benefits from State and Local Economic
Development Policies?, Kalamazoo, MI: W.E. Upjohn Institute for Employment
Research, 1991.</cite>
</p>
<p><cite>Adão, Rodrigo, Kolesár, Michal, and Morales, Eduardo,
&quot;Shift-Share Designs: Theory and Inference&quot;, Quarterly Journal of Economics
2019, 134 (4), 1949-2010. doi: <a href="https://doi.org/10.1093/qje/qjz025">10.1093/qje/qjz025</a>.</cite>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## Use ADH data from Autor, Dorn, and Hanson (2013)
reg_ss(d_sh_empl ~ 1, X=IV, data=ADH$reg, W=ADH$W,
         method=c("ehw", "akm", "akm0"))
</code></pre>

<hr>
<h2 id='reg_ss.fit'>Inference in a shift-share regression</h2><span id='topic+reg_ss.fit'></span>

<h3>Description</h3>

<p>Basic computing engine to calculate confidence intervals and p-values in
shift-share designs using different inference methods, as specified by
<code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_ss.fit(
  y,
  X,
  W,
  Z,
  w = NULL,
  method = c("akm", "akm0"),
  beta0 = 0,
  alpha = 0.05,
  region_cvar = NULL,
  sector_cvar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reg_ss.fit_+3A_y">y</code></td>
<td>
<p>Outcome variable, vector of length <code>N</code>, with each row
corresponding to a region.</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_x">X</code></td>
<td>
<p>Shift-share vector with length <code>N</code> of sectoral shocks,
aggregated to regional level using the share matrix <code>W</code>. That is,
each element of <code>X</code> corresponds to a region.</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_w">W</code></td>
<td>
<p>A matrix of sector shares, so that <code>W[i, s]</code> corresponds to
share of sector <code>s</code> in region <code>i</code>. The ordering of the regions
must coincide with that in the other inputs, such as <code>X</code>. The
ordering of the sectors in the columns of <code>W</code> is irrelevant but the
identity of the sectors in must coincide with those used to construct
<code>X</code>.</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_z">Z</code></td>
<td>
<p>Matrix of regional controls, matrix with <code>N</code> rows corresponding
to regions.</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_w">w</code></td>
<td>
<p>vector of weights (length <code>N</code>) to be used in the fitting
process. If not <code>NULL</code>, weighted least squares is used with weights
<code>w</code>, i.e., <code>sum(w * residuals^2)</code> is minimized.</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_method">method</code></td>
<td>
<p>Vector specifying which inference methods to use. The vector
elements have to be one or more of the following strings:
</p>

<dl>
<dt><code>"homosk"</code></dt><dd><p>Assume i.i.d. homoskedastic errors</p>
</dd>
<dt><code>"ehw"</code></dt><dd><p>Eicker-Huber-White standard errors</p>
</dd>
<dt><code>"region_cluster"</code></dt><dd><p>Standard errors clustered at regional level</p>
</dd>
<dt><code>"akm"</code></dt><dd><p>Adão-Kolesár-Morales</p>
</dd>
<dt><code>"akm0"</code></dt><dd><p>Adão-Kolesár-Morales with null imposed. Note the
reported standard error for this method corresponds to the normalized
standard error, given by the length of the confidence interval divided by
<code class="reqn">2z_{1-\alpha/2}</code></p>
</dd>
<dt><code>"all"</code></dt><dd><p>All of the methods above</p>
</dd></dl>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_beta0">beta0</code></td>
<td>
<p>null that is tested (only affects reported p-values)</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_alpha">alpha</code></td>
<td>
<p>Determines confidence level of reported confidence intervals,
which will have coverage <code>1-alpha</code>.</p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_region_cvar">region_cvar</code></td>
<td>
<p>A vector with length <code>N</code> of cluster variables, for
method <code>"cluster_region"</code>. If the vector <code>1:N</code> is used,
clustering is effectively equivalent to <code>ehw</code></p>
</td></tr>
<tr><td><code id="reg_ss.fit_+3A_sector_cvar">sector_cvar</code></td>
<td>
<p>A vector with length <code>S</code> of cluster variables, if
sectors are to be clustered, for methods <code>"akm"</code> and <code>"akm0"</code>.
If the vector <code>1:S</code> is used, this is equivalent to not clustering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"SSResults"</code> containing the
estimation and inference results. The <code>print</code> function can be used
to print a summary of the results. The object is a list with at least the
following components: </p>

<dl>
<dt>beta</dt><dd><p>Point estimate of the effect of interest <code class="reqn">\beta</code></p>
</dd>
<dt>se, p</dt><dd><p>A vector of standard errors and a vector of p-values of the null
<code class="reqn">H_{0}\colon \beta = \beta_{0}</code> for the inference
methods in <code>method</code>, with <code class="reqn">\beta_{0}</code> specified by the
argument <code>beta0</code>. For the method <code>"akm0"</code>, the standard error
corresponds to the effective standard error (length of the confidence
interval divided by <code>2*stats::qnorm(1-alpha/2)</code>)</p>
</dd>
<dt>ci.l, ci.r</dt><dd><p>Upper and lower endpoints of the confidence interval for
the effect of interest <code class="reqn">\beta</code>, for each of the methods in
<code>method</code></p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
