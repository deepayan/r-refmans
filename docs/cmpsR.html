<!DOCTYPE html><html><head><title>Help for package cmpsR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cmpsR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bullets'><p>Information of two example bullets</p></a></li>
<li><a href='#cmps_na_trim'><p>Remove the leading and trailing missing values in a numeric vector</p></a></li>
<li><a href='#cmps_segment_plot'><p>Plot the selected basis segment and its cross-correlation curve at all scales based on the</p>
results of CMPS algorithm</a></li>
<li><a href='#cmps_signature_plot'><p>Plot reference signature and comparison signature based on the results of CMPS algorithm</p></a></li>
<li><a href='#compute_cross_corr'><p>Wrapper function for compute_cross_corr</p></a></li>
<li><a href='#compute_diff_phase'><p>Compute a Statistic for the Foreground Phase and the Background Phases</p></a></li>
<li><a href='#compute_score_metrics'><p>Compute Different Metrics Based on Scores</p></a></li>
<li><a href='#compute_ss_ratio'><p>#' Compute the Sum of Squares Ratio</p></a></li>
<li><a href='#extract_feature_cmps'><p>Computes the CMPS score of a comparison between two bullet profiles/signatures</p></a></li>
<li><a href='#get_all_phases'><p>Obtain a list of all phases of a bullet-by-bullet comparison</p></a></li>
<li><a href='#get_ccf4'><p>Function to calculate the cross-correlation between two sequences</p></a></li>
<li><a href='#get_ccp'><p>Identify at most one consistent correlation peak (ccp)</p></a></li>
<li><a href='#get_ccr_peaks'><p>Identify peaks of a cross correlation curve</p></a></li>
<li><a href='#get_CMPS'><p>Compute the CMPS score</p></a></li>
<li><a href='#get_seg_scale'><p>Change the sacle of a segment</p></a></li>
<li><a href='#get_segs'><p>Divide a bullet signature/profile into basis segments of desired length</p></a></li>
<li><a href='#local_max_cmps'><p>find local maximums</p></a></li>
<li><a href='#metric_plot_helper'><p>Helper Function for Plotting the Distribution of a Metric</p></a></li>
<li><a href='#na_trim_cmps'><p>Wrapper function for na_trim</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>R Implementation of Congruent Matching Profile Segments Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>This is an open-source implementation of the Congruent Matching Profile 
    Segments (CMPS) method (Chen et al. 2019)&lt;<a href="https://doi.org/10.1016%2Fj.forsciint.2019.109964">doi:10.1016/j.forsciint.2019.109964</a>&gt;. 
    In general, it can be used for objective comparison of striated tool marks, and in our 
    examples, we specifically use it for bullet signatures comparisons. The CMPS score is 
    expected to be large if two signatures are similar. So it can also be considered as a 
    feature that measures the similarity of two bullet signatures.</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat (&ge; 0.2.0), dplyr (&ge; 1.0.5), rlang (&ge; 0.4.5),
ggplot2 (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>purrr, tidyverse, ggpubr, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-18 04:13:12 UTC; willju</td>
</tr>
<tr>
<td>Author:</td>
<td>Wangqian Ju <a href="https://orcid.org/0000-0002-9977-377X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Heike Hofmann <a href="https://orcid.org/0000-0001-6216-5183"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wangqian Ju &lt;wju@iastate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-18 08:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bullets'>Information of two example bullets</h2><span id='topic+bullets'></span>

<h3>Description</h3>

<p>A dataset containing pre-processed information of two bullets. They are used
as examples in Chapter 3.5 of Open Forensic Science in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bullets
</code></pre>


<h3>Format</h3>

<p>A data frame/tbl/tbl_df with 12 rows and 3 variables:
</p>

<dl>
<dt>source</dt><dd><p>source of the bullet data</p>
</dd>
<dt>sigs</dt><dd><p>bullet signatures, detailed information about how to get the signatures can be found at https://sctyner.github.io/OpenForSciR/bullets.html</p>
</dd>
<dt>bulletland</dt><dd><p>label of the signatures</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://sctyner.github.io/OpenForSciR/bullets.html">https://sctyner.github.io/OpenForSciR/bullets.html</a>
</p>

<hr>
<h2 id='cmps_na_trim'>Remove the leading and trailing missing values in a numeric vector</h2><span id='topic+cmps_na_trim'></span>

<h3>Description</h3>

<p>Remove the leading and trailing missing values in a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmps_na_trim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmps_na_trim_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector; only the leading and trailing missing values are removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, 1, 2, 3, 4, NA)
cmps_na_trim(x)
</code></pre>

<hr>
<h2 id='cmps_segment_plot'>Plot the selected basis segment and its cross-correlation curve at all scales based on the
results of CMPS algorithm</h2><span id='topic+cmps_segment_plot'></span>

<h3>Description</h3>

<p>This function plots the selected basis segment with the comparison signature. One can visualize the
scaled segment and its corresponding cross-correlation curve. The number of marked correlation peaks
at each segment scale is determined by <code>npeaks_set</code> of <code>extract_feature_cmps</code>. The red vertical dashed
line indicates the congruent registration position for all segments; the green vertical dashed line
indicates the position of the consistent correlation peak (if any); the blue vertical dashed line
indicates the tolerance zone (determined by <code>Tx</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmps_segment_plot(cmps_result, seg_idx = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmps_segment_plot_+3A_cmps_result">cmps_result</code></td>
<td>
<p>a list generated by <code>extract_feature_cmps</code>. <code>cmps_result</code> is required to have
the following names: <code>parameters</code>, <code>congruent_pos</code>, <code>segments</code>, <code>nseg</code>, i.e. one should at least have
<code>include = c("parameters", "congruent_pos", "segments", "nseg")</code> when computing <code>cmps_result</code>.
However, <code style="white-space: pre;">&#8288;include = "full_result&#8288;</code> is still recommended.</p>
</td></tr>
<tr><td><code id="cmps_segment_plot_+3A_seg_idx">seg_idx</code></td>
<td>
<p>an integer. The index of a basis segment that we want to plot for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of n elements, where n is the length of <code>npeaks_set</code>, i.e. the number of scales for
each basis segment. And each one of these n elements is also a list, a list of two plots:
</p>

<ul>
<li> <p><code>segment_plot</code>: The basis segment of current scale is plotted at different positions where the
segment obtains correlation peak. The comparison signature is also plotted.
</p>
</li>
<li> <p><code>scale_ccf_plot</code>: This is the plot of the cross-correlation curve between the comparison signature
and the segment of the current scale.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(cmpsR)
library(ggpubr)

data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]

# compute cmps

# algorithm with multi-peak insepction at three different segment scales
cmps_with_multi_scale &lt;- extract_feature_cmps(land2_3$sig, land1_2$sig, include = "full_result" )

# generate plots using cmps_signature_plot
seg_plot &lt;- cmps_segment_plot(cmps_with_multi_scale, seg_idx = 3)

pp &lt;- ggarrange(plotlist = unlist(seg_plot, recursive = FALSE), nrow = 3, ncol = 2)

</code></pre>

<hr>
<h2 id='cmps_signature_plot'>Plot reference signature and comparison signature based on the results of CMPS algorithm</h2><span id='topic+cmps_signature_plot'></span>

<h3>Description</h3>

<p>This function aligns two signatures and shows which basis segments find the congruent
registration position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmps_signature_plot(cmps_result, add_background = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmps_signature_plot_+3A_cmps_result">cmps_result</code></td>
<td>
<p>a list generated by <code>extract_feature_cmps</code>. <code>cmps_result</code> is required to have
the following names: <code>parameters</code>, <code>congruent_seg</code>, <code>congruent_pos</code>, <code>segments</code>, <code>ccp_list</code>. So
<code>include = "full_result"</code> is recommended when computing <code>cmps_result</code></p>
</td></tr>
<tr><td><code id="cmps_signature_plot_+3A_add_background">add_background</code></td>
<td>
<p>boolean; whether or not to add zebra-striped background under each basis
segment; default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<ul>
<li> <p><code>segment_shift_plot</code>: a plot object generated by ggplot2. In this plot only basis segments that are
congruent matching profile segments (CMPS) are plotted along with the comparison profile; each basis
segment is shifted to the position where it obtains either a consistent correlation peak or a
cross-correlation peak closest to the congruent registration position
</p>
</li>
<li> <p><code>signature_shift_plot</code>:  a plot object generated by ggplot2. In this plot both the reference
signature and the comparison signature are plotted, and CMPS are highlighted. The alignment of the
two signatures is achieved by shifting the reference signature to the congruent registration position.
</p>
</li>
<li> <p><code>seg_shift</code>: a data.frame. This data frame shows which basis segments are plotted (are CMPS) and
the units by which each segment shifted when plotting <code>segment_shift_plot</code>
</p>
</li>
<li> <p><code>sig_shift</code>: a numeric value. The number of units by which the reference signature shifted
when plotting <code>signature_shift_plot</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(cmpsR)

data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]

# compute cmps

# algorithm with multi-peak insepction at three different segment scales
cmps_with_multi_scale &lt;- extract_feature_cmps(land2_3$sig, land1_2$sig, include = "full_result" )

# generate plots using cmps_signature_plot
sig_plot &lt;- cmps_signature_plot(cmps_with_multi_scale)
</code></pre>

<hr>
<h2 id='compute_cross_corr'>Wrapper function for compute_cross_corr</h2><span id='topic+compute_cross_corr'></span>

<h3>Description</h3>

<p>Wrapper function for compute_cross_corr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_cross_corr(x, y, min.overlap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_cross_corr_+3A_x">x</code></td>
<td>
<p>numeric vector, the longer sequence</p>
</td></tr>
<tr><td><code id="compute_cross_corr_+3A_y">y</code></td>
<td>
<p>numeric vector, the shorter sequence</p>
</td></tr>
<tr><td><code id="compute_cross_corr_+3A_min.overlap">min.overlap</code></td>
<td>
<p>numeric scalor, set the length of the minimum overlapping part</p>
</td></tr>
</table>

<hr>
<h2 id='compute_diff_phase'>Compute a Statistic for the Foreground Phase and the Background Phases</h2><span id='topic+compute_diff_phase'></span>

<h3>Description</h3>

<p>Compute a statistic (for example, a mean) based on all matching comparisons (foreground phase) and the same statistic
based on all non-matching comparisons (background phases)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_diff_phase(scores_list, FUNC = mean, na.rm = TRUE, both = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_diff_phase_+3A_scores_list">scores_list</code></td>
<td>
<p>a list of all phases</p>
</td></tr>
<tr><td><code id="compute_diff_phase_+3A_func">FUNC</code></td>
<td>
<p>a function to be applied to both the foreground phase and the background phases</p>
</td></tr>
<tr><td><code id="compute_diff_phase_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds</p>
</td></tr>
<tr><td><code id="compute_diff_phase_+3A_both">both</code></td>
<td>
<p>logical value. If <code>TRUE</code>, return the values of the <code>FUNC</code> for both the foreground phase and the background phases;
if <code>FALSE</code>, return their difference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>both = TRUE</code>, return the values of the statistic (calculated by <code>FUNC</code>) for both the foreground phase and the
background phases; if <code>both = FALSE</code>, return the difference
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)

data("bullets")

lands &lt;- unique(bullets$bulletland)

comparisons &lt;- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]),
                          stringsAsFactors = FALSE)

comparisons &lt;- comparisons %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig1=sigs),
            by = c("land1" = "bulletland")) %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig2=sigs),
            by = c("land2" = "bulletland"))

comparisons &lt;- comparisons %&gt;% mutate(
  cmps = purrr::map2(sig1, sig2, .f = function(x, y) {
    extract_feature_cmps(x$sig, y$sig, include = "full_result")
  })
)

comparisons &lt;- comparisons %&gt;%
  mutate(
    cmps_score = sapply(comparisons$cmps, function(x) x$CMPS_score),
    cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
  )
  
cp1 &lt;- comparisons %&gt;% select(land1, land2, cmps_score, cmps_nseg)
cp1 &lt;- cp1 %&gt;% mutate(
  land1idx = land1 %&gt;% str_sub(-1, -1) %&gt;% as.numeric(),
  land2idx = land2 %&gt;% str_sub(-1, -1) %&gt;% as.numeric()
)

phases &lt;- with(cp1, {
  get_all_phases(land1idx, land2idx, cmps_score, addNA = TRUE)
})

compute_diff_phase(phases)
</code></pre>

<hr>
<h2 id='compute_score_metrics'>Compute Different Metrics Based on Scores</h2><span id='topic+compute_score_metrics'></span>

<h3>Description</h3>

<p>Compute Different Metrics Based on Scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_score_metrics(
  land1,
  land2,
  score,
  addNA = TRUE,
  na.rm = TRUE,
  include = NULL,
  out_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_score_metrics_+3A_land1">land1</code></td>
<td>
<p>(numeric) vector with land ids of bullet 1</p>
</td></tr>
<tr><td><code id="compute_score_metrics_+3A_land2">land2</code></td>
<td>
<p>(numeric) vector with land ids of bullet 2</p>
</td></tr>
<tr><td><code id="compute_score_metrics_+3A_score">score</code></td>
<td>
<p>numeric vector of scores to be summarized into a single number</p>
</td></tr>
<tr><td><code id="compute_score_metrics_+3A_addna">addNA</code></td>
<td>
<p>logical value. In case of missing lands, are scores set to 0 (addNA = FALSE) or set to NA (addNA = TRUE)</p>
</td></tr>
<tr><td><code id="compute_score_metrics_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds</p>
</td></tr>
<tr><td><code id="compute_score_metrics_+3A_include">include</code></td>
<td>
<p>a character vector specifying which metrics to be included in the result; if <code>include = NULL</code>, including
all metrics</p>
</td></tr>
<tr><td><code id="compute_score_metrics_+3A_out_names">out_names</code></td>
<td>
<p>a character vector specifying the variable names of each metric; if <code>out_names = NULL</code>, using the default names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this helper function computes four metrics.
</p>
<p><code>diff</code>: the difference between the mean score of the foreground phase and the mean score of the background phases
<code>diff.med</code>: the difference between the median score of the foreground phase and the median score of the background phases
<code>max</code>: the max score
<code>maxbar</code>: the mean score of the foreground phase
</p>


<h3>Value</h3>

<p>a data frame containing values of the metrics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)

data("bullets")

lands &lt;- unique(bullets$bulletland)

comparisons &lt;- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]),
                          stringsAsFactors = FALSE)

comparisons &lt;- comparisons %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig1=sigs),
            by = c("land1" = "bulletland")) %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig2=sigs),
            by = c("land2" = "bulletland"))

comparisons &lt;- comparisons %&gt;% mutate(
  cmps = purrr::map2(sig1, sig2, .f = function(x, y) {
    extract_feature_cmps(x$sig, y$sig, include = "full_result")
  })
)

comparisons &lt;- comparisons %&gt;%
  mutate(
    cmps_score = sapply(comparisons$cmps, function(x) x$CMPS_score),
    cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
  )
  
cp1 &lt;- comparisons %&gt;% select(land1, land2, cmps_score, cmps_nseg)
cp1 &lt;- cp1 %&gt;% mutate(
  land1idx = land1 %&gt;% str_sub(-1, -1) %&gt;% as.numeric(),
  land2idx = land2 %&gt;% str_sub(-1, -1) %&gt;% as.numeric()
)

with(cp1, {
  compute_score_metrics(land1idx, land2idx, cmps_score)
})
</code></pre>

<hr>
<h2 id='compute_ss_ratio'>#' Compute the Sum of Squares Ratio</h2><span id='topic+compute_ss_ratio'></span>

<h3>Description</h3>

<p>#' Compute the Sum of Squares Ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_ss_ratio(score, label, MS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_ss_ratio_+3A_score">score</code></td>
<td>
<p>a numeric vector, scores</p>
</td></tr>
<tr><td><code id="compute_ss_ratio_+3A_label">label</code></td>
<td>
<p>a character vector, the label of each score</p>
</td></tr>
<tr><td><code id="compute_ss_ratio_+3A_ms">MS</code></td>
<td>
<p>boolean, whether to compute the mean squares instead of the sum of squares. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sum of squares ratio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>score &lt;- c(rnorm(100), rnorm(100, mean = 5))
label &lt;- c(rep("a", 100), rep("b", 100))
compute_ss_ratio(score, label)
</code></pre>

<hr>
<h2 id='extract_feature_cmps'>Computes the CMPS score of a comparison between two bullet profiles/signatures</h2><span id='topic+extract_feature_cmps'></span>

<h3>Description</h3>

<p>Compute the Congruent Matching Profile Segments (CMPS) score based on two bullet profiles/signatures.
The reference profile will be divided into consecutive, non-overlapping, basis segments of the same length.
Then the number of segments that are congruent matching will be found as the CMPS score.
By default, <code>extract_feature_cmps</code> implements the algorithm with multi-peak inspection at three
different segment scale levels. By setting <code>npeaks_set</code> as a single-length vector, users can switch to the algorithm
with multi-peak inspection at the basis scale level only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_feature_cmps(
  x,
  y,
  seg_length = 50,
  Tx = 25,
  npeaks_set = c(5, 3, 1),
  include = NULL,
  outlength = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_feature_cmps_+3A_x">x</code></td>
<td>
<p>a numeric vector, vector of the reference bullet signature/profile that will be divided into basis segments</p>
</td></tr>
<tr><td><code id="extract_feature_cmps_+3A_y">y</code></td>
<td>
<p>a numeric vector, vector of the comparison bullet signature/profile</p>
</td></tr>
<tr><td><code id="extract_feature_cmps_+3A_seg_length">seg_length</code></td>
<td>
<p>a positive integer, the length of a basis segment</p>
</td></tr>
<tr><td><code id="extract_feature_cmps_+3A_tx">Tx</code></td>
<td>
<p>a positive integer, the tolerance zone is <code style="white-space: pre;">&#8288;+/- Tx&#8288;</code></p>
</td></tr>
<tr><td><code id="extract_feature_cmps_+3A_npeaks_set">npeaks_set</code></td>
<td>
<p>a numeric vector, specify the number of peaks to be found at each segment scale level
</p>

<ul>
<li><p> If <code>length(npeaks_set) == 1</code>, the algorithm uses multi-peak inspection only at the basis scale level;
</p>
</li>
<li><p> If <code>length(npeaks_set) &gt; 1</code>, the algorithm uses multi-peak inspection at
different segment scale levels.
</p>
</li>
<li><p> By default, <code>npeaks_set = c(5,3,1)</code>. Including more segment scale levels will reduce the number of false positive results
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract_feature_cmps_+3A_include">include</code></td>
<td>
<p><code>NULL</code> or a vector of character strings indicating what additional information should be included in
the output of <code>extract_feature_cmps</code>. All possible options are: &quot;nseg&quot;, &quot;congruent_pos&quot;, &quot;congruent_seg&quot;,
&quot;congruent_seg_idx&quot;, &quot;pos_df&quot;, &quot;ccp_list&quot;,&quot;segments&quot;, and &quot;parameters&quot;. If one wants to include them all, one can use
<code>include = "full_result"</code>. By default, <code>include = NULL</code> and only the CMPS score is returned</p>
</td></tr>
<tr><td><code id="extract_feature_cmps_+3A_outlength">outlength</code></td>
<td>
<p><code>NULL</code> or a numeric vector, specify the segment length of each level of the basis segment when the
multi-segment lengths strategy is being used. If <code>outlength = NULL</code>, then the length of a basis segment will be doubled
at each segment level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value or a list
</p>

<ul>
<li><p> if <code>include = NULL</code>, returns the CMPS score (a numeric value) only
</p>
</li>
<li><p> if <code style="white-space: pre;">&#8288;include = &#8288;</code> one or a vector of strings listed above:
</p>

<ul>
<li> <p><code>nseg</code>: number of basis segments
</p>
</li>
<li> <p><code>congruent_seg</code>: a vector of boolean values. <code>TRUE</code> means this basis segment is a congruent matching profile segment (CMPS)
</p>
</li>
<li> <p><code>congruent_seg_idx</code>: the indices of all CMPS
</p>
</li>
<li> <p><code>pos_df</code>: a dataframe that includes positions of correlation peaks and the CMPS score of these positions
</p>
</li>
<li> <p><code>ccp_list</code>: a list of consistent correlation peaks of each basis segment.
</p>
</li>
<li> <p><code>segments</code>: a list of all basis segments
</p>
</li>
<li> <p><code>parameters</code>: a list that stores all parameters used in the function call
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Chen, Zhe, Wei Chu, Johannes A Soons, Robert M Thompson, John Song,
and Xuezeng Zhao. 2019. “Fired Bullet Signature Correlation Using the
Congruent Matching Profile Segments (CMPS) Method.” Forensic Science
International, December, #109964. https://doi.org/10.1016/j.forsciint.2019.109964.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(cmpsR)

data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]

# compute cmps

# algorithm with multi-peak insepction at three different segment scale levels
cmps_with_multi_scale &lt;- extract_feature_cmps(land2_3$sig, land1_2$sig, include = "full_result" )

# algorithm with multi-peak inspection at the basis scale level only
cmps_without_multi_scale &lt;- extract_feature_cmps(land2_3$sig, land1_2$sig, 
                                                 npeaks_set = 5, include = "full_result" )

# Another example
library(tidyverse)

data("bullets")

lands &lt;- unique(bullets$bulletland)

comparisons &lt;- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]),
                          stringsAsFactors = FALSE)

comparisons &lt;- comparisons %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig1=sigs),
            by = c("land1" = "bulletland")) %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig2=sigs),
            by = c("land2" = "bulletland"))

comparisons &lt;- comparisons %&gt;% mutate(
  cmps = purrr::map2(sig1, sig2, .f = function(x, y) {
    extract_feature_cmps(x$sig, y$sig, include = "full_result")
  })
)

comparisons &lt;- comparisons %&gt;%
  mutate(
    cmps_score = sapply(comparisons$cmps, function(x) x$CMPS_score),
    cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
  )
  
cp1 &lt;- comparisons %&gt;% select(land1, land2, cmps_score, cmps_nseg)
cp1  

</code></pre>

<hr>
<h2 id='get_all_phases'>Obtain a list of all phases of a bullet-by-bullet comparison</h2><span id='topic+get_all_phases'></span>

<h3>Description</h3>

<p>Obtain a list of all phases of a bullet-by-bullet comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_phases(land1, land2, score, addNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_phases_+3A_land1">land1</code></td>
<td>
<p>(numeric) vector with land ids of bullet 1</p>
</td></tr>
<tr><td><code id="get_all_phases_+3A_land2">land2</code></td>
<td>
<p>(numeric) vector with land ids of bullet 2</p>
</td></tr>
<tr><td><code id="get_all_phases_+3A_score">score</code></td>
<td>
<p>numeric vector of scores to be summarized into a single number</p>
</td></tr>
<tr><td><code id="get_all_phases_+3A_addna">addNA</code></td>
<td>
<p>logical value. In case of missing lands, are scores set to 0 (addNA = FALSE) or set to NA (addNA = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all phases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)

data("bullets")

lands &lt;- unique(bullets$bulletland)

comparisons &lt;- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]),
                          stringsAsFactors = FALSE)

comparisons &lt;- comparisons %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig1=sigs),
            by = c("land1" = "bulletland")) %&gt;%
  left_join(bullets %&gt;% select(bulletland, sig2=sigs),
            by = c("land2" = "bulletland"))

comparisons &lt;- comparisons %&gt;% mutate(
  cmps = purrr::map2(sig1, sig2, .f = function(x, y) {
    extract_feature_cmps(x$sig, y$sig, include = "full_result")
  })
)

comparisons &lt;- comparisons %&gt;%
  mutate(
    cmps_score = sapply(comparisons$cmps, function(x) x$CMPS_score),
    cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
  )
  
cp1 &lt;- comparisons %&gt;% select(land1, land2, cmps_score, cmps_nseg)
cp1 &lt;- cp1 %&gt;% mutate(
  land1idx = land1 %&gt;% str_sub(-1, -1) %&gt;% as.numeric(),
  land2idx = land2 %&gt;% str_sub(-1, -1) %&gt;% as.numeric()
)

with(cp1, {
  get_all_phases(land1idx, land2idx, cmps_score, addNA = TRUE)
})
</code></pre>

<hr>
<h2 id='get_ccf4'>Function to calculate the cross-correlation between two sequences</h2><span id='topic+get_ccf4'></span>

<h3>Description</h3>

<p>This function is used for CMPS algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ccf4(x, y, min.overlap = round(0.1 * max(length(x), length(y))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ccf4_+3A_x">x</code></td>
<td>
<p>numeric sequence of values</p>
</td></tr>
<tr><td><code id="get_ccf4_+3A_y">y</code></td>
<td>
<p>numeric sequence of values</p>
</td></tr>
<tr><td><code id="get_ccf4_+3A_min.overlap">min.overlap</code></td>
<td>
<p>integer, minimal number of values in the overlap between sequences x and y to calculate a correlation value. Set to 10 percent of the maximum length of either sequence (HH: this might be problematic for CMPS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list consisting of the lag where the maximum correlation is achieved, and the maximum correlation value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]
x &lt;- land2_3$sig
y &lt;- land1_2$sig

segments &lt;- get_segs(x, len = 50)

ccr &lt;- get_ccf4(y, segments$segs[[7]], 
                min.overlap = length(segments$segs[[7]]))
</code></pre>

<hr>
<h2 id='get_ccp'>Identify at most one consistent correlation peak (ccp)</h2><span id='topic+get_ccp'></span>

<h3>Description</h3>

<p>If multi segment lengths strategy is being used, at most one consistent correlation
peak (ccp) will be found for the corresponding basis segment. If the ccp cannot be identified,
return <code>NULL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ccp(ccr_list, Tx = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ccp_+3A_ccr_list">ccr_list</code></td>
<td>
<p>list, obtained by <code>get_ccr_peaks</code></p>
</td></tr>
<tr><td><code id="get_ccp_+3A_tx">Tx</code></td>
<td>
<p>integer, the tolerance zone is <code style="white-space: pre;">&#8288;+/- Tx&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the position of the ccp if it is identified; <code>NULL</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]
x &lt;- land2_3$sig
y &lt;- land1_2$sig

segments &lt;- get_segs(x, len = 50)

# identify the consistent correlation peak when ccf curves are computed
# based on y and segment 7 in 3 different scales;
# the number of peaks identified in each scale are 5, 3, and 1, respectively.
seg_scale_max &lt;- 3
npeaks_set &lt;- c(5,3,1)
outlength &lt;- c(50, 100, 200)

ccr_list &lt;- lapply(1:seg_scale_max, function(seg_scale) {
  get_ccr_peaks(y, segments, seg_outlength = outlength[seg_scale], nseg = 7, 
  npeaks = npeaks_set[seg_scale])
})

get_ccp(ccr_list, Tx = 25)
</code></pre>

<hr>
<h2 id='get_ccr_peaks'>Identify peaks of a cross correlation curve</h2><span id='topic+get_ccr_peaks'></span>

<h3>Description</h3>

<p>Given a comparison profile and a segment, <code>get_ccr_peaks</code> computes the
cross correlation curve and finds peaks of the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ccr_peaks(comp, segments, seg_outlength, nseg = 1, npeaks = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ccr_peaks_+3A_comp">comp</code></td>
<td>
<p>a nueric vector, vector of the bullet comparison profile</p>
</td></tr>
<tr><td><code id="get_ccr_peaks_+3A_segments">segments</code></td>
<td>
<p>list with basis segments and their corresponding indices in the original profile, obtianed by <code>get_segs()</code></p>
</td></tr>
<tr><td><code id="get_ccr_peaks_+3A_seg_outlength">seg_outlength</code></td>
<td>
<p>length of the enlarged segment</p>
</td></tr>
<tr><td><code id="get_ccr_peaks_+3A_nseg">nseg</code></td>
<td>
<p>integer. <code>nseg</code> = 3: the third segment in <code>segments</code></p>
</td></tr>
<tr><td><code id="get_ccr_peaks_+3A_npeaks">npeaks</code></td>
<td>
<p>integer. the number of peaks to be identified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list consisting of:
</p>

<ul>
<li> <p><code>ccr</code>: the cross correlation curve
</p>
</li>
<li> <p><code>adj_pos</code>: indices of the curve
</p>
</li>
<li> <p><code>peaks_pos</code>: position of the identified peaks
</p>
</li>
<li> <p><code>peaks_heights</code>: the cross correlation value (height of the curve) of the peaks
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]
x &lt;- land2_3$sig
y &lt;- land1_2$sig

segments &lt;- get_segs(x, len = 50)

# compute ccf based on y and segment 7 with scale 1, then identify 5 highest peaks
ccrpeaks &lt;- get_ccr_peaks(y, segments = segments, seg_outlength = 50,
                          nseg = 7, npeaks = 5)
</code></pre>

<hr>
<h2 id='get_CMPS'>Compute the CMPS score</h2><span id='topic+get_CMPS'></span>

<h3>Description</h3>

<p>Compute the CMPS score from a list of positions of (consistent) correlation peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_CMPS(input_ccp, Tx = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_CMPS_+3A_input_ccp">input_ccp</code></td>
<td>
<p>a list of positions for (consistent) correlation peaks</p>
</td></tr>
<tr><td><code id="get_CMPS_+3A_tx">Tx</code></td>
<td>
<p>integer, the tolerance zone is <code style="white-space: pre;">&#8288;+/- Tx&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of six components:
</p>

<ul>
<li> <p><code>CMPS_score</code>: computed CMPS score
</p>
</li>
<li> <p><code>nseg</code>: the number of basis segments
</p>
</li>
<li> <p><code>congruent_pos</code>: the congruent position that results in the CMPS score
</p>
</li>
<li> <p><code>congruent_seg</code>: a boolean vector of the congruent matching profile segments
</p>
</li>
<li> <p><code>congruent_seg_idx</code>: the index of the congruent matching profile segments
</p>
</li>
<li> <p><code>pos_df</code>: a dataframe that includes all positions and their corresponding CMPS score
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
land1_2 &lt;- bullets$sigs[bullets$bulletland == "1-2"][[1]]
x &lt;- land2_3$sig
y &lt;- land1_2$sig
segments &lt;- get_segs(x, len = 50)
nseg &lt;- length(segments$segs)
seg_scale_max &lt;- 3
npeaks_set &lt;- c(5,3,1)
outlength &lt;- c(50, 100, 200)

ccp_list &lt;- lapply(1:nseg, function(nseg) {
 ccr_list &lt;- lapply(1:seg_scale_max, function(seg_scale) {
   get_ccr_peaks(y, segments, seg_outlength = outlength[seg_scale], 
   nseg = nseg, npeaks = npeaks_set[seg_scale])
 })

 get_ccp(ccr_list, Tx = 25)
})
cmps &lt;- get_CMPS(ccp_list, Tx = 25)
</code></pre>

<hr>
<h2 id='get_seg_scale'>Change the sacle of a segment</h2><span id='topic+get_seg_scale'></span>

<h3>Description</h3>

<p>In order to identify the congruent registration position of a basis segment,
the length of the basis segment will be doubled to compute the correlation curve.
<code>get_seg_scale</code> computes the increased segment, which has the same center
as the basis segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_seg_scale(segments, nseg, out_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_seg_scale_+3A_segments">segments</code></td>
<td>
<p>list with basis segments and their corresponding indices in the original profile, obtianed by <code>get_segs()</code></p>
</td></tr>
<tr><td><code id="get_seg_scale_+3A_nseg">nseg</code></td>
<td>
<p>integer. <code>nseg</code> = 3: increase the length of the third basis segment.</p>
</td></tr>
<tr><td><code id="get_seg_scale_+3A_out_length">out_length</code></td>
<td>
<p>integer. The length of the enlarged segment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list consisting of
</p>

<ul>
<li> <p><code>aug_seg</code>: the increased segment
</p>
</li>
<li> <p><code>aug_idx</code>: the corresponding indices in the profile
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
x &lt;- land2_3$sig

segments &lt;- get_segs(x, len = 50)
seg5_scale3 &lt;- get_seg_scale(segments, nseg = 5, out_length = 50)
</code></pre>

<hr>
<h2 id='get_segs'>Divide a bullet signature/profile into basis segments of desired length</h2><span id='topic+get_segs'></span>

<h3>Description</h3>

<p><code>get_segs</code> divides a bullet signature/profile (a numeric vector) into consecutive,
non-overlapping, basis segments of the same desired length. If the profile
starts or ends with a sequence of <code>NA</code> (missing values), the <code>NA</code>s will be trimmed.
If the very last segment does not have the desired length, it will be dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_segs(x, len = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_segs_+3A_x">x</code></td>
<td>
<p>a numeric vector, vector of the bullet signature/profile</p>
</td></tr>
<tr><td><code id="get_segs_+3A_len">len</code></td>
<td>
<p>integer: the desired length of a basis segment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with basis segments and their corresponding indices in the profile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bullets")
land2_3 &lt;- bullets$sigs[bullets$bulletland == "2-3"][[1]]
x &lt;- land2_3$sig

segments &lt;- get_segs(x, len = 50)
</code></pre>

<hr>
<h2 id='local_max_cmps'>find local maximums</h2><span id='topic+local_max_cmps'></span>

<h3>Description</h3>

<p>find local maximums
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_max_cmps(x, find_max = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_max_cmps_+3A_x">x</code></td>
<td>
<p>numeric vector, the input sequence</p>
</td></tr>
<tr><td><code id="local_max_cmps_+3A_find_max">find_max</code></td>
<td>
<p>a numeric scalor, the function finds maximums if <code>find_max = 0</code>
finds minimums if overwise.</p>
</td></tr>
</table>

<hr>
<h2 id='metric_plot_helper'>Helper Function for Plotting the Distribution of a Metric</h2><span id='topic+metric_plot_helper'></span>

<h3>Description</h3>

<p>Helper Function for Plotting the Distribution of a Metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metric_plot_helper(
  cmps_metric,
  metric,
  scaled = FALSE,
  SSratio = TRUE,
  plot_density = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metric_plot_helper_+3A_cmps_metric">cmps_metric</code></td>
<td>
<p>a data frame containing values of the metric and the labels</p>
</td></tr>
<tr><td><code id="metric_plot_helper_+3A_metric">metric</code></td>
<td>
<p>string. Which metric to be plotted</p>
</td></tr>
<tr><td><code id="metric_plot_helper_+3A_scaled">scaled</code></td>
<td>
<p>logical value. If <code>scaled = TRUE</code>, the values should be within the interval of <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code></p>
</td></tr>
<tr><td><code id="metric_plot_helper_+3A_ssratio">SSratio</code></td>
<td>
<p>logical value. Whether to show the sum of squares ratio value</p>
</td></tr>
<tr><td><code id="metric_plot_helper_+3A_plot_density">plot_density</code></td>
<td>
<p>logical value. If <code>plot_density = TRUE</code>, the function plots
group density on the y-axis; if <code>plot_density = FALSE</code>, it plots the count of a certain bin.</p>
</td></tr>
<tr><td><code id="metric_plot_helper_+3A_...">...</code></td>
<td>
<p>other arguments for plotting: <code>breaks</code>, <code>binwidth</code>, and <code>subtitle</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='na_trim_cmps'>Wrapper function for na_trim</h2><span id='topic+na_trim_cmps'></span>

<h3>Description</h3>

<p>Wrapper function for na_trim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_trim_cmps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_trim_cmps_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
