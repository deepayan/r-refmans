<!DOCTYPE html><html><head><title>Help for package genlasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genlasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genlasso-package'>
<p>Package to compute the solution path of generalized lasso problems</p></a></li>
<li><a href='#coef.genlasso'>
<p>Extract cefficients from a genlasso object</p></a></li>
<li><a href='#cv.trendfilter'>
<p>Perform k-fold cross-validation to choose a trend filtering model</p></a></li>
<li><a href='#fusedlasso'>
<p>Compute the fused lasso solution path for a general graph, or a 1d</p>
or 2d grid</a></li>
<li><a href='#genlasso'>
<p>Compute the generalized lasso solution path for arbitrary penalty matrix</p></a></li>
<li><a href='#getDxx'>
<p>Helper functions for constructing generalized lasso penalty matrices</p></a></li>
<li><a href='#iterate'>
<p>Iterate a genlasso object</p></a></li>
<li><a href='#plot.genlasso'>
<p>Plotting methods for generalized lasso objects</p></a></li>
<li><a href='#predict.genlasso'>
<p>Make predictions given a genlasso object</p></a></li>
<li><a href='#softthresh'>
<p>Fit a sparse variant of the fused lasso</p></a></li>
<li><a href='#trendfilter'>
<p>Compute the trend filtering solution path for any polynomial order</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Path Algorithm for Generalized Lasso Problems</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Taylor B. Arnold [aut, cre],
  Ryan J. Tibshirani [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Taylor B. Arnold &lt;tarnold2@richmond.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the solution path for generalized lasso problems. Important use cases are the fused lasso over an arbitrary graph, and trend fitting of any given polynomial order. Specialized implementations for the latter two subproblems are given to improve stability and speed. See Taylor Arnold and Ryan Tibshirani (2016) &lt;<a href="https://doi.org/10.1080%2F10618600.2015.1008638">doi:10.1080/10618600.2015.1008638</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, igraph, R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/glmgen/genlasso">https://github.com/glmgen/genlasso</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 17:55:50 UTC; admin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 08:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='genlasso-package'>
Package to compute the solution path of generalized lasso problems
</h2><span id='topic+genlasso-package'></span>

<h3>Description</h3>

<p>This package is centered around computing the solution path of the
generalized lasso problem, which minimizes the criterion
</p>
<p style="text-align: center;"><code class="reqn">
    1/2 \|y - X \beta\|_2^2 + \lambda \|D \beta\|_1.
  </code>
</p>

<p>The solution path is computed by solving the equivalent Lagrange
dual problem. The dimension of the dual variable u is the number of
rows of the penalty matrix D, and the primal (original) and dual
solutions are related by
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\beta} = y - D^T \hat{u}
  </code>
</p>

<p>when the predictor matrix X is the identity, and
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\beta} = (X^T X)^{-1} (X^T y - D^T \hat{u})
  </code>
</p>

<p>for a full column rank predictor matrix X. For column rank deficient
matrices X, the solution path is not unique and not computed by this
package. However, one can add a small ridge penalty to the above
criterion, which can be re-expressed as a generalized lasso problem
with full column rank predictor matrix X and hence yields a unique
solution path.
</p>
<p>Important use cases include the fused lasso, where D is the oriented
incidence matrix of some underlying graph (the orientations being
arbitrary), and trend filtering, where D is the discrete difference
operator of any given order k.
</p>
<p>The general function <code><a href="#topic+genlasso">genlasso</a></code> computes a solution path
for any penalty matrix D and full column rank predictor matrix X
(adding a ridge penalty when X is rank deficient). For the fused lasso
and trend filtering problems, the specialty functions
<code><a href="#topic+fusedlasso">fusedlasso</a></code> and <code><a href="#topic+trendfilter">trendfilter</a></code> should be used 
as they deliver a significant increase in speed and numerical
stability.
</p>
<p>For a walk-through of using the package for statistical modelling see
the included package vignette; for the appropriate background material
see the generalized lasso paper referenced below. 
</p>


<h3>Author(s)</h3>

<p>Taylor B. Arnold and Ryan J. Tibshirani
</p>


<h3>References</h3>

<p>Tibshirani, R. J. and Taylor, J. (2011), &quot;The solution path of the
generalized lasso&quot;, Annals of Statistics 39 (3) 1335&ndash;1371.
</p>
<p>Arnold, T. B. and Tibshirani, R. J. (2014), &quot;Efficient implementations
of the generalized lasso dual path algorithm&quot;, arXiv: 1405.3222.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genlasso">genlasso</a></code>, <code><a href="#topic+fusedlasso">fusedlasso</a></code>,
<code><a href="#topic+trendfilter">trendfilter</a></code> 
</p>

<hr>
<h2 id='coef.genlasso'>
Extract cefficients from a genlasso object
</h2><span id='topic+coef.genlasso'></span>

<h3>Description</h3>

<p>This function extracts coefficients from a generalized lasso solution
path object, for any set of tuning parameter values along the path. It
can return dual coefficients. The requested coefficients can also be
parametrized by degrees of freedom value instead of tuning parameter
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genlasso'
coef(object, lambda, nlam, df, 
     type = c("primal", "dual", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.genlasso_+3A_object">object</code></td>
<td>

<p>an object of class &quot;genlasso&quot;, or an object which inherits this
class (i.e., &quot;fusedlasso&quot;, &quot;trendfilter&quot;). 
</p>
</td></tr>
<tr><td><code id="coef.genlasso_+3A_lambda">lambda</code></td>
<td>

<p>a numeric vector of tuning parameter values at which coefficients
should be calculated. The user can choose to specify one of
<code>lambda</code>, <code>nlam</code>, or <code>df</code>; if none are specified,
then coefficients are returned at every knot in the solution path. 
</p>
</td></tr>
<tr><td><code id="coef.genlasso_+3A_nlam">nlam</code></td>
<td>

<p>an integer indicating a number of tuning parameters values at which
coefficients should be calculated. The tuning parameter values are
then chosen to be equally spaced on the log scale over the first
half of the solution path (this is if the full solution path has
been computed; if only a partial path has been computed, the tuning 
parameter values are spaced over the entirety of the computed path).  
</p>
</td></tr>
<tr><td><code id="coef.genlasso_+3A_df">df</code></td>
<td>

<p>an integer vector of degrees of freedom values at which coefficients
should be calculated. In the case that a single degrees of freedom
value appears multiple times throughout the solution path, the least 
regularized solution (corresponding to the smallest value
of lambda) is chosen. If a degrees of freedom value does not appear
at all in the solution path, this function chooses the solution whose 
degrees of freedom is largest, subject to being less than or equal to 
the specified value.
</p>
</td></tr>
<tr><td><code id="coef.genlasso_+3A_type">type</code></td>
<td>

<p>a character string, one of &quot;primal&quot;, &quot;dual&quot;, or &quot;both&quot;, indicating
whether primal coefficients, dual coefficients, or both, should be
returned. Default is &quot;primal&quot;, which corresponds to the solution of
the original problem.
</p>
</td></tr>
<tr><td><code id="coef.genlasso_+3A_...">...</code></td>
<td>

<p>additional arguments passed to coef.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>if the type is &quot;primal&quot; or &quot;both&quot;, a matrix containing the primal
coefficients, each column corresponding to a value of lambda.
</p>
</td></tr>
<tr><td><code>u</code></td>
<td>

<p>if the type is &quot;dual&quot; or &quot;both&quot;, a matrix containing the dual
coefficients, each column corresponding to a value of lambda.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>a numeric vector containing the sequence of tuning parameter values,
corresponding to the columns of <code>beta</code> and <code>u</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>an integer vector containing the sequence of degrees of freedom 
values corresponding to the columns of <code>beta</code> and <code>u</code>. 
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+genlasso">genlasso</a></code>, <code><a href="#topic+predict.genlasso">predict.genlasso</a></code>,
<code><a href="#topic+plot.genlasso">plot.genlasso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constant trend filtering (the 1d fused lasso)
set.seed(0)
n = 20
beta0 = rep(sample(1:10,5),each=n/5)
y = beta0 + rnorm(n,sd=0.5)
a = fusedlasso1d(y)

# Get the coefficients that use 3, 4, and 5 degrees
# of freedom 
coef(a,df=3:5)
</code></pre>

<hr>
<h2 id='cv.trendfilter'>
Perform k-fold cross-validation to choose a trend filtering model
</h2><span id='topic+cv.trendfilter'></span>

<h3>Description</h3>

<p>This function performs k-fold cross-validation to choose the value of
the regularization parameter lambda for a trend filtering problem,
given the computed solution path. This function only applies to trend
filtering objects with identity predictor matrix (no <code>X</code> passed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.trendfilter(object, k = 5, mode = c("lambda", "df"),
               approx = FALSE, rtol = 1e-07, btol = 1e-07,
               verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.trendfilter_+3A_object">object</code></td>
<td>

<p>the solution path object, of class &quot;trendfilter&quot;, as returned by the
<code><a href="#topic+trendfilter">trendfilter</a></code> function.
</p>
</td></tr>
<tr><td><code id="cv.trendfilter_+3A_k">k</code></td>
<td>

<p>an integer indicating the number of folds to split the data
into. Must be between 2 and n-2 (n being the number of
observations), default is 5. It is generally not a good idea to
pass a value of k much larger than 10 (say, on the scale of n); see
&quot;Details&quot; below. 
</p>
</td></tr>
<tr><td><code id="cv.trendfilter_+3A_mode">mode</code></td>
<td>

<p>a character string, either &quot;lambda&quot; or &quot;df&quot;. Specifying &quot;lambda&quot;
means that the cross-validation error will be computed and reported
at each value of lambda that appears as a knot in the solution
path. Specifying &quot;df&quot; means that the cross-validation error will be 
computed and reported for every of degrees of freedom value
(actually, estimate) incurred along the solution path. In the case
that the same degrees of freedom value is visited multiple times,
the model with the most regularization (smallest value of lambda) is
considered. Default is &quot;lambda&quot;. 
</p>
</td></tr>
<tr><td><code id="cv.trendfilter_+3A_approx">approx</code></td>
<td>

<p>a logical variable indicating if the approximate solution path
should be used (with no dual coordinates leaving the boundary).
Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="cv.trendfilter_+3A_rtol">rtol</code></td>
<td>

<p>a numeric variable giving the relative tolerance used in the
calculation of the hitting and leaving times. A larger value
is more conservative, and may cause the algorithm to miss some
hitting or leaving events (do not change unless you know what
you're getting into!). Defaultis 1e-7. 
</p>
</td></tr>
<tr><td><code id="cv.trendfilter_+3A_btol">btol</code></td>
<td>

<p>similar to <code>rtol</code> but in absolute terms. If numerical
instability is detected, first change rtol; then adjust btol
if problems persist.
</p>
</td></tr>
<tr><td><code id="cv.trendfilter_+3A_verbose">verbose</code></td>
<td>

<p>a logical variable indicating if progress should be reported after
each knot in the path.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For trend filtering (with an identity predictor matrix), the folds 
for k-fold cross-validation are chosen by placing every kth point into
the same fold. (Here the points are implicitly ordered according to their 
underlying positions&mdash;either assumed to be evenly spaced, or explicitly 
passed through the <code>pos</code> argument.) 
The first and last points are not included in any fold and are always
included in building the predictive model. As an example, 
with n=15 data points and k=4 folds, the points are assigned to folds 
in the following way:
</p>
<p style="text-align: center;"><code class="reqn">
    x \; 1 \; 2 \; 3 \; 4 \; 1 \; 2 \; 3 \;  4 \; 1 \; 2 \; 3 \; 4 \; 1
    \; x
  </code>
</p>

<p>where <code class="reqn">x</code> indicates no assignment. Therefore, the folds are not
random and running <code>cv.trendfilter</code> twice will give the same
result. In the calculation of the cross-validated error, the
predicted value at a point is given by the average of the fits at this 
point's two neighbors (guaranteed to be in a different fold). 
</p>
<p>Running cross-validation in modes &quot;lambda&quot; and &quot;df&quot; often yields very
similar results. The mode &quot;df&quot; simply gives an alternative
parametrization for the sequence of cross-validated models and can be
more convenient for some applications; if you are confused about its
function, simply leave the mode equal to &quot;lambda&quot;.
</p>


<h3>Value</h3>

<p>Returns and object of class &quot;cv.trendfilter&quot;, a list with the
following components:
</p>
<table>
<tr><td><code>err</code></td>
<td>

<p>a numeric vector of cross-validated errors.
</p>
</td></tr>
<tr><td><code>se</code></td>
<td>

<p>a numeric vector of standard errors (standard deviations of the
cross-validation error estimates).
</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>

<p>a character string indicating the mode, either &quot;lambda&quot; or &quot;df&quot;.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>if <code>mode="lambda"</code>, the values of lambda at which the
cross-validation errors in <code>err</code> were computed. 
</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>

<p>if <code>mode="lambda"</code>, the value of lambda at which the
cross-validation error is minimized.
</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>

<p>if <code>mode="lambda"</code>, the value of lambda chosen by the one
standard error rule (the largest value of lambda such that the
cross-validation error is within one standard error of the minimum).  
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>if <code>mode="df"</code>, the degrees of freedom values at which the
cross-validation errors in <code>err</code> were computed.
</p>
</td></tr>
<tr><td><code>df.min</code></td>
<td>

<p>if <code>mode="df"</code>, the degrees of freedom value at which the
cross-validation error is minimized.
</p>
</td></tr>
<tr><td><code>df.1se</code></td>
<td>

<p>if <code>mode="df"</code>, the degrees of freedom value chosen by the 
one standard error rule (the smallest degrees of freedom value such 
that cross-validation error is within one standard error of the
minimum).   
</p>
</td></tr>
<tr><td><code>i.min</code></td>
<td>

<p>the index of the model minimizing the cross-validation error.
</p>
</td></tr>
<tr><td><code>i.1se</code></td>
<td>

<p>the index of the model chosen by the one standard error rule.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+trendfilter">trendfilter</a></code>, <code><a href="#topic+plot.cv.trendfilter">plot.cv.trendfilter</a></code>,
<code><a href="#topic+plot.trendfilter">plot.trendfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constant trend filtering (the 1d fused lasso)
set.seed(0)
n = 50
beta0 = rep(sample(1:10,5),each=n/5)
y = beta0 + rnorm(n,sd=0.8)
a = fusedlasso1d(y)
plot(a)

# Choose lambda by 5-fold cross-validation
cv = cv.trendfilter(a)
plot(cv)
plot(a,lambda=cv$lambda.min,main="Minimal CV error")
plot(a,lambda=cv$lambda.1se,main="One standard error rule")


# Cubic trend filtering
set.seed(0)
n = 100
beta0 = numeric(100)
beta0[1:40] = (1:40-20)^3
beta0[40:50] = -60*(40:50-50)^2 + 60*100+20^3
beta0[50:70] = -20*(50:70-50)^2 + 60*100+20^3
beta0[70:100] = -1/6*(70:100-110)^3 + -1/6*40^3 + 6000
beta0 = -beta0
beta0 = (beta0-min(beta0))*10/diff(range(beta0))
y = beta0 + rnorm(n)
a = trendfilter(y,ord=3,maxsteps=150)
plot(a,nlam=5)

# Choose lambda by 5-fold cross-validation
cv = cv.trendfilter(a)
plot(cv)
plot(a,lambda=cv$lambda.min,main="Minimal CV error")
plot(a,lambda=cv$lambda.1se,main="One standard error rule")

</code></pre>

<hr>
<h2 id='fusedlasso'>
Compute the fused lasso solution path for a general graph, or a 1d
or 2d grid</h2><span id='topic+fusedlasso'></span><span id='topic+fusedlasso1d'></span><span id='topic+fusedlasso2d'></span>

<h3>Description</h3>

<p>These functions produce the solution path for a general fused lasso
problem. The <code>fusedlasso</code> function takes either a penalty matrix
or a graph object from the <code>igraph</code> package. The
<code>fusedlasso1d</code> and <code>fusedlasso2d</code> functions are convenience
functions that construct the penalty matrix over a 1d or 2d grid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fusedlasso(y, X, D, graph, gamma = 0, approx = FALSE, maxsteps = 2000,
           minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-4, 
	   verbose = FALSE)
fusedlasso1d(y, pos, X, gamma = 0, approx = FALSE, maxsteps = 2000,
             minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-4, 
	     verbose = FALSE)
fusedlasso2d(y, X, dim1, dim2, gamma = 0, approx = FALSE, maxsteps = 2000,
	     minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-4, 
	     verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fusedlasso_+3A_y">y</code></td>
<td>

<p>a numeric response vector. Alternatively, for <code>fusedlasso2d</code>
with no matrix <code>X</code> passed, <code>y</code> can be a matrix
(its dimensions corresponding to the underlying 2d grid). Note that
when <code>y</code> is given as a vector in <code>fusedlasso2d</code>, with no
<code>X</code> passed, it should be in column major order.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_pos">pos</code></td>
<td>

<p>only for <code>fusedlasso1d</code>, these are the optional positions of
the positions in the 1d grid. If missing, the 1d grid is assumed to
have unit spacing.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_x">X</code></td>
<td>

<p>an optional matrix of predictor variables, with observations along
the rows, and variables along the columns. If the passed <code>X</code> 
has more columns than rows, then a warning is given, and a small ridge
penalty is added to the generalized lasso criterion before the path
is computed. If <code>X</code> has less columns than rows, then its rank is
not checked for efficiency, and (unlike the <code>genasso</code> function) a 
ridge penalty is not automatically added if it is rank deficient. 
Therefore, a tall, rank deficient <code>X</code> may cause errors. 
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_d">D</code></td>
<td>

<p>only for <code>fusedlasso</code>, this is the penalty matrix, i.e., the
oriented incidence matrix over the underlying graph (the orientation
of each edge being arbitrary). Only one of <code>D</code> or <code>graph</code>
needs to be specified.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_graph">graph</code></td>
<td>

<p>only for <code>fusedlasso</code>, this is the underlying graph as an
<code>igraph</code> object from the <code>igraph</code> package. Only one of
<code>D</code> or <code>graph</code> needs to be specified.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_dim1">dim1</code></td>
<td>

<p>only for <code>fusedlasso2d</code>, this is the number of rows in the
underlying 2d grid. If missing and <code>y</code> is given as a matrix, it
is assumed to be the number of rows of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_dim2">dim2</code></td>
<td>

<p>only for <code>fusedlasso2d</code>, this is the number of columns in the
underlying 2d grid. If missing and <code>y</code> is given as a matrix, it
is assumed to be the number of columns of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_gamma">gamma</code></td>
<td>

<p>a numeric variable greater than or equal to 0, indicating the ratio
of the two tuning parameters, one for the fusion penalty, and the
other for the pure <code class="reqn">\ell_1</code> penalty. Default is 0. See
&quot;Details&quot; for more information.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_approx">approx</code></td>
<td>

<p>a logical variable indicating if the approximate solution path
should be used (with no dual coordinates leaving the boundary).
Default is <code>FALSE</code>. Note
that for the 1d fused lasso, with identity predicor matrix,
this approximate path is the same as the exact solution path.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_maxsteps">maxsteps</code></td>
<td>

<p>an integer specifying the maximum number of steps for the algorithm
to take before termination. Default is 2000.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_minlam">minlam</code></td>
<td>

<p>a numeric variable indicating the value of lambda at which the path
should terminate. Default is 0.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_rtol">rtol</code></td>
<td>

<p>a numeric variable giving the tolerance for determining the rank of
a matrix: if a diagonal value in the R factor of a QR decomposition
is less than R, in absolute value, then it is considered zero. Hence
making rtol larger means being less stringent with determination of
matrix rank. In general, do not change this unless you know what you
are getting into! Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_btol">btol</code></td>
<td>

<p>a numeric variable giving the tolerance for accepting &quot;late&quot; hitting
and leaving times: future hitting times and leaving times should always 
be less than the current knot in the path, but sometimes for numerical
reasons they are larger; any computed hitting or leaving time larger 
than the current knot + btol is thrown away. Hence making btol larger
means being less stringent withthe determination of hitting and leaving 
times. Again, in general, do not change this unless you know what you 
are getting into! Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_eps">eps</code></td>
<td>

<p>a numeric variable indicating the multiplier for the ridge penalty,
in the case that <code>X</code> is wide (more columns than rows). If numeric
problems occur, make <code>eps</code> larger. Default is 1e-4. 
</p>
</td></tr>
<tr><td><code id="fusedlasso_+3A_verbose">verbose</code></td>
<td>

<p>a logical variable indicating if progress should be reported after
each knot in the path.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fused lasso estimate minimizes the criterion
</p>
<p style="text-align: center;"><code class="reqn">
    1/2 \sum_{i=1}^n (y_i - x_i^T \beta_i)^2 + \lambda \sum_{(i,j) \in E}
    |\beta_i - \beta_j| + \gamma \cdot \lambda \sum_{i=1}^p |\beta_i|,
  </code>
</p>

<p>where <code class="reqn">x_i</code> is the ith row of the predictor matrix and <code class="reqn">E</code> is
the edge set of the underlying graph. The solution <code class="reqn">\hat{\beta}</code> is
computed as a function of the regularization parameter <code class="reqn">\lambda</code>,
for a fixed value of <code class="reqn">\gamma</code>. The default is to set
<code class="reqn">\gamma=0</code>, which corresponds to pure fusion of the coefficient
vector <code class="reqn">\beta</code>. A choice <code class="reqn">\gamma&gt;0</code> introduces both sparsity
and fusion in the coefficient vector, with a higher value placing more
priority on sparsity.
</p>
<p>If the predictor matrix is the identity, and the primal solution path
<code class="reqn">\beta</code> is desired at several levels of the ratio parameter
<code class="reqn">\gamma</code>, it is much more efficient to compute the solution path
once with <code class="reqn">\gamma=0</code>, and then use soft-thresholding via the
<code><a href="#topic+softthresh">softthresh</a></code> function.
</p>
<p>Finally, for the image denoising problem, i.e., the fused lasso over a 2d
grid with identity predictor matrix, it is easy to specify a huge graph
with a seemingly small amount of data. For instance, running the 2d
fused lasso (with identity predictor matrix) on an image at standard
1080p HD resolution yields a graph with over 2 million
edges. Moreover, in image denoising problems&mdash;somewhat unlike most
other applications of the fused lasso (and generalized lasso)&mdash;a
solution is often desired near the dense end of the path
(<code class="reqn">\lambda=0</code>) as opposed to the regularized end
(<code class="reqn">\lambda=\infty</code>). The dual path algorithm implemented by the
<code>fusedlasso2d</code> function begins at the fully regularized end
and works its way down to the dense end. For a problem with many
edges (dual variables), if a solution at the dense is desired, then it
must usually pass through a huge number knots in the path. Hence it is
not advisable to run <code>fusedlasso2d</code> on image denoising problems of
large scale, as the dual solution path is computationally
infeasible. It should be noted that a faster algorithm for the 2d
fused lasso solution path (when the predictor matrix is the identity),
which begins at the dense end of the path, is available in the
<code>flsa</code> package.
</p>


<h3>Value</h3>

<p>The function returns an object of class &quot;fusedlasso&quot;, and subclass
&quot;genlasso&quot;. This is a list with at least following components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>

<p>values of lambda at which the solution path changes slope,
i.e., kinks or knots.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>a matrix of primal coefficients, each column corresponding to a knot
in the solution path.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>a matrix of fitted values, each column corresponding to a knot in
the solution path.
</p>
</td></tr>
<tr><td><code>u</code></td>
<td>

<p>a matrix of dual coefficients, each column corresponding to a knot
in the solution path.
</p>
</td></tr>
<tr><td><code>hit</code></td>
<td>

<p>a vector of logical values indicating if a new variable in the dual
solution hit the box contraint boundary. A value of <code>FALSE</code>
indicates a variable leaving the boundary.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a vector giving an unbiased estimate of the degrees of freedom of
the fit at each knot in the solution path.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>the observed response vector. Useful for plotting and other
methods.
</p>
</td></tr>
<tr><td><code>completepath</code></td>
<td>

<p>a logical variable indicating whether the complete path was
computed (terminating the path early with the <code>maxsteps</code> or
<code>minlam</code> options results in a value of <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>bls</code></td>
<td>

<p>the least squares solution, i.e., the solution at lambda = 0. This
can be <code>NULL</code> when <code>completepath</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>

<p>the value of the lambda ratio.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Taylor B. Arnold and Ryan J. Tibshirani
</p>


<h3>References</h3>

<p>Tibshirani, R. J. and Taylor, J. (2011), &quot;The solution path of the
generalized lasso&quot;, Annals of Statistics 39 (3) 1335&ndash;1371.
</p>
<p>Arnold, T. B. and Tibshirani, R. J. (2014), &quot;Efficient implementations
of the generalized lasso dual path algorithm&quot;, arXiv: 1405.3222.
</p>
<p>Tibshirani, R., Saunders, M., Rosset, S., Zhu, J. and Knight,
K. (2005), &quot;Sparsity and smoothness via the fused lasso&quot;, Journal of
the Royal Statistics Society: Series B 67(1), 91&ndash;108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+softthresh">softthresh</a></code>, <code><a href="#topic+genlasso">genlasso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fused lasso on a custom graph
set.seed(0)
edges = c(1,2,1,3,1,5,2,4,2,5,3,6,3,7,3,8,6,7,6,8)
gr = graph(edges=edges,directed=FALSE)
plot(gr)
y = c(1,1,0,1,1,0,0,0) + rnorm(8,0.1)

# Can either pass the graph object directly, or
# first construct the penalty matrix, and then
# pass this
a1 = fusedlasso(y,graph=gr)
D = getDgSparse(gr)
a2 = fusedlasso(y,D=D)

plot(a1,numbers=TRUE)


# The 2d fused lasso with a predictor matrix X
set.seed(0)
dim1 = dim2 = 16
p = dim1*dim2
n = 300
X = matrix(rnorm(n*p),nrow=n)
beta0 = matrix(0,dim1,dim2)
beta0[(row(beta0)-dim1/2)^2 + (col(beta0)-dim2/2)^2 &lt;=
(min(dim1,dim2)/3)^2] = 1
y = X %*% as.numeric(beta0) + rnorm(n)

# Takes about 30 seconds for the full solution path
out = fusedlasso2d(y,X,dim1=dim1,dim2=dim2)

# Grab the solution at 8 values of lambda over the path
a = coef(out,nlam=8)

# Plot these against the true coefficients
oldpar &lt;- par(no.readonly = TRUE)
on.exit(par(oldpar))
par(mar=c(1,1,2,1),mfrow=c(3,3))

cols = terrain.colors(30)
zlim = range(c(range(beta0),range(a$beta)))
image(beta0,col=cols,zlim=zlim,axes=FALSE)

for (i in 1:8) {
  image(matrix(a$beta[,i],nrow=dim1),col=cols,zlim=zlim,
  axes=FALSE)
  mtext(bquote(lambda==.(sprintf("%.3f",a$lambda[i]))))
}

</code></pre>

<hr>
<h2 id='genlasso'>
Compute the generalized lasso solution path for arbitrary penalty matrix
</h2><span id='topic+genlasso'></span><span id='topic+print.genlasso'></span><span id='topic+print.summary.genlasso'></span><span id='topic+summary.genlasso'></span>

<h3>Description</h3>

<p>This function computes the solution path of the generalized lasso
problem for an arbitrary penalty matrix. Speciality functions exist
for the trend filtering and fused lasso problems; see
<code><a href="#topic+trendfilter">trendfilter</a></code> and <code><a href="#topic+fusedlasso">fusedlasso</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genlasso(y, X, D, approx = FALSE, maxsteps = 2000, minlam = 0,
         rtol = 1e-07, btol = 1e-07, eps = 1e-4, verbose = FALSE,
         svd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genlasso_+3A_y">y</code></td>
<td>

<p>a numeric response vector.
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_x">X</code></td>
<td>

<p>an optional matrix of predictor variables, with observations along
the rows, and variables along the columns. If missing, <code>X</code> is
assumed to be the identity matrix. If the passed <code>X</code> does not
have full column rank, then a warning is given, and a small ridge
penalty is added to the generalized lasso criterion before the path
is computed.
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_d">D</code></td>
<td>

<p>a penalty matrix. Its number of columns must be equal to the number
of columns of <code>X</code>, or if no <code>X</code> is given, the length of 
<code>y</code>. This can be a sparse matrix from <code>Matrix</code> package,
but this will be ignored (converted to a dense matrix) if <code>D</code>
is row rank deficient or if <code>X</code> is specified. See &quot;Details&quot;
below. 
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_approx">approx</code></td>
<td>

<p>a logical variable indicating if the approximate solution path
should be used (with no dual coordinates leaving the boundary).
Default is <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_maxsteps">maxsteps</code></td>
<td>

<p>an integer specifying the maximum number of steps for the algorithm
to take before termination. Default is 2000. 
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_minlam">minlam</code></td>
<td>

<p>a numeric variable indicating the value of lambda at which the path
should terminate. Default is 0.
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_rtol">rtol</code></td>
<td>

<p>a numeric variable giving the tolerance for determining the rank of
a matrix: if a diagonal value in the R factor of a QR decomposition
is less than R, in absolute value, then it is considered zero. Hence
making rtol larger means being less stringent with determination of
matrix rank. In general, do not change this unless you know what you
are getting into! Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_btol">btol</code></td>
<td>

<p>a numeric variable giving the tolerance for accepting &quot;late&quot; hitting
and leaving times: future hitting times and leaving times should always 
be less than the current knot in the path, but sometimes for numerical
reasons they are larger; any computed hitting or leaving time larger 
than the current knot + btol is thrown away. Hence making btol larger
means being less stringent withthe determination of hitting and leaving 
times. Again, in general, do not change this unless you know what you 
are getting into! Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_eps">eps</code></td>
<td>

<p>a numeric variable indicating the multiplier for the ridge penalty,
in the case that <code>X</code> is column rank deficient. Default is
1e-4. 
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_verbose">verbose</code></td>
<td>

<p>a logical variable indicating if progress should be reported after
each knot in the path. 
</p>
</td></tr>
<tr><td><code id="genlasso_+3A_svd">svd</code></td>
<td>

<p>a logical variable indicating if the genlasso function should use 
singular value decomposition to solve least squares problems at each
path step, which is slower, but should be more stable.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized lasso estimate minimizes the criterion
</p>
<p style="text-align: center;"><code class="reqn">
    1/2 \|y - X \beta\|_2^2 + \lambda \|D \beta\|_1.
  </code>
</p>

<p>The solution <code class="reqn">\hat{\beta}</code> is computed as a function of
the regularization parameter <code class="reqn">\lambda</code>. The advantage of the
<code>genlasso</code> function lies in its flexibility, i.e., the user can
specify any penalty matrix <code>D</code> of their choosing. However, for a
trend filtering problem or a fused lasso problem, it is strongly
recommended to use one of the speciality functions,
<code><a href="#topic+trendfilter">trendfilter</a></code> or <code><a href="#topic+fusedlasso">fusedlasso</a></code>. When compared
to these functions, <code>genlasso</code> is not as numerically stable and
much less efficient.
</p>
<p>Note that, when <code>D</code> is passed as a sparse matrix, the linear 
systems that arise at each step of the path algorithm are solved
separately via a sparse solver. The usual strategy (when <code>D</code> is 
simply a matrix) is to maintain a matrix factorization of <code>D</code>,
and solve these systems by (or downdating) this factorization, as
these linear systems are highly related. Therefore,
when <code>D</code> is sufficiently sparse and structured, it can be
advantageous to pass it as a sparse matrix; but if <code>D</code> is truly
dense, passing it as a sparse matrix will be highly inefficient. 
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;genlasso&quot;, a list with at least following
components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>

<p>values of lambda at which the solution path changes slope,
i.e., kinks or knots.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>a matrix of primal coefficients, each column corresponding to a knot
in the solution path.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>a matrix of fitted values, each column corresponding to a knot in
the solution path.
</p>
</td></tr>
<tr><td><code>u</code></td>
<td>

<p>a matrix of dual coefficients, each column corresponding to a knot
in the solution path.
</p>
</td></tr>
<tr><td><code>hit</code></td>
<td>

<p>a vector of logical values indicating if a new variable in the dual
solution hit the box contraint boundary. A value of <code>FALSE</code>
indicates a variable leaving the boundary. 
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a vector giving an unbiased estimate of the degrees of freedom of
the fit at each knot in the solution path.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>the observed response vector. Useful for plotting and other
methods.
</p>
</td></tr>
<tr><td><code>completepath</code></td>
<td>

<p>a logical variable indicating whether the complete path was
computed (terminating the path early with the <code>maxsteps</code> or
<code>minlam</code> options results in a value of <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>bls</code></td>
<td>

<p>the least squares solution, i.e., the solution at lambda = 0. 
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Taylor B. Arnold and Ryan J. Tibshirani
</p>


<h3>References</h3>

<p>Tibshirani, R. J. and Taylor, J. (2011), &quot;The solution path of the
generalized lasso&quot;, Annals of Statistics 39 (3) 1335&ndash;1371.
</p>
<p>Arnold, T. B. and Tibshirani, R. J. (2014), &quot;Efficient implementations
of the generalized lasso dual path algorithm&quot;, arXiv: 1405.3222.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trendfilter">trendfilter</a></code>, <code><a href="#topic+fusedlasso">fusedlasso</a></code>,
<code><a href="#topic+coef.genlasso">coef.genlasso</a></code>, <code><a href="#topic+predict.genlasso">predict.genlasso</a></code>,
<code><a href="#topic+plot.genlasso">plot.genlasso</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the generalized lasso to run a standard lasso regression
# (for example purposes only! for pure lasso problems, use LARS
# instead)
set.seed(1)
n = 100
p = 10
X = matrix(rnorm(n*p),nrow=n)
y = 3*X[,1] + rnorm(n)
D = diag(1,p)
out = genlasso(y,X,D)
coef(out, lambda=sqrt(n*log(p)))
</code></pre>

<hr>
<h2 id='getDxx'>
Helper functions for constructing generalized lasso penalty matrices 
</h2><span id='topic+getD1dSparse'></span><span id='topic+getD2dSparse'></span><span id='topic+getDgSparse'></span><span id='topic+getDtfSparse'></span><span id='topic+getDtfPosSparse'></span><span id='topic+getD1d'></span><span id='topic+getD2d'></span><span id='topic+getDg'></span><span id='topic+getDtf'></span><span id='topic+getDtfPos'></span><span id='topic+getGraph'></span>

<h3>Description</h3>

	
<p>These are utility functions for creating penalty matrices for the
fused lasso and trend filtering problems. Most users will not need to
explicitly construct these as they are created internally by the
<code>fusedlasso</code> or <code>trendfilter</code> functions. The sparse
variants output sparse matrices, which should be used whenever
possible because of a significant savings in both construction speed
and memory usage.
</p>
<p>The function getGraph is an inverse function for fused lasso problems,
returning an <code>igraph</code> object (from the <code>igraph</code> package), the
graph corresponding to the passed penalty matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getD1d(n)
getD1dSparse(n)
getD2d(dim1, dim2)
getD2dSparse(dim1, dim2)
getDg(graph)
getDgSparse(graph)
getDtf(n, ord)
getDtfSparse(n, ord) 
getDtfPos(n, ord, pos)
getDtfPosSparse(n, ord, pos)
getGraph(D)
</code></pre>


<h3>Arguments</h3>

<p>The arguments for the sparse variants are identical to those for the
regular variants, which are described below.
</p>
<table>
<tr><td><code id="getDxx_+3A_n">n</code></td>
<td>

<p>for <code>getD1d</code>, <code>getDtf</code>, and <code>getDtfPos</code>, 
the number of points in the 1d sequence.
</p>
</td></tr>
<tr><td><code id="getDxx_+3A_dim1">dim1</code>, <code id="getDxx_+3A_dim2">dim2</code></td>
<td>

<p>for <code>getD2d</code>, the number of rows and columns in the 2d grid,
respectively. 
</p>
</td></tr>
<tr><td><code id="getDxx_+3A_graph">graph</code></td>
<td>

<p>for <code>getDg</code>, an <code>igraph</code> object from the <code>igraph</code>
package, upon which the penalty matrix should be based (the penalty
matrix is the oriented incidence matrix of the graph, with arbitrary
orientations assigned to each edge).
</p>
</td></tr>
<tr><td><code id="getDxx_+3A_ord">ord</code></td>
<td>

<p>for <code>getDtf</code>, and <code>getDtfPos</code>, the order of the
polynomial. E.g., ord=0 is the 1d fused lasso and ord=1 is linear 
trend filtering. Hence the returned matrix is the discrete (ord+1)st
derivative operator. 
</p>
</td></tr>
<tr><td><code id="getDxx_+3A_pos">pos</code></td>
<td>

<p>for <code>getDtfPos</code>, a numeric vector giving the positions of
points in the 1d sequence. Must have length <code>n</code>. 
</p>
</td></tr>
<tr><td><code id="getDxx_+3A_d">D</code></td>
<td>

<p>for <code>getGraph</code>, a fused lasso penalty matrix, the incidence
matrix of an undirected graph, with arbitrary edge orientations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions except <code>getGraph</code> return a penalty matrix, either
in standard R matrix format or as a sparse matrix of class
<code>dgCMatrix</code> via the <code>Matrix</code> package. The function
<code>getGraph</code> returns an <code>igraph</code> object from the <code>igraph</code>
package. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fusedlasso">fusedlasso</a></code>, <code><a href="#topic+trendfilter">trendfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getD1d(9)
getDtfSparse(10,2)

graph = getGraph(getD2dSparse(4,4))
plot(graph)
</code></pre>

<hr>
<h2 id='iterate'>
Iterate a genlasso object
</h2><span id='topic+iterate'></span>

<h3>Description</h3>

<p>Given an incomplete <code>genlasso</code> path object, this function continues 
the path computation from the last computed knot, either until 
the complete path has been computed or the step limit specified by
<code>moresteps</code> has been reached. All options are assumed
to be the same as those in the initial call to a genlasso function (as in
<code><a href="#topic+genlasso">genlasso</a></code>, <code><a href="#topic+fusedlasso">fusedlasso</a></code>, or <code><a href="#topic+trendfilter">trendfilter</a></code>), 
with the exception of <code>minlam</code> and <code>verbose</code>, which can be changed 
with a call to iterate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate(object, moresteps=200, minlam=0, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_+3A_object">object</code></td>
<td>

<p>a genlasso object with an incomplete path.
</p>
</td></tr>
<tr><td><code id="iterate_+3A_moresteps">moresteps</code></td>
<td>

<p>an integer specifying the number of additional steps to take, starting
from termination point of the passed (incomplete) path object.
</p>
</td></tr>
<tr><td><code id="iterate_+3A_minlam">minlam</code></td>
<td>

<p>a numeric variable indicating the value of lambda at which the path
should terminate. Default is 0.
</p>
</td></tr>
<tr><td><code id="iterate_+3A_verbose">verbose</code></td>
<td>

<p>a logical variable indicating if progress should be reported after
each knot in the path.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an list of the same class typing and same structure as the passed
<code>object</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+genlasso">genlasso</a>,
<a href="#topic+trendfilter">trendfilter</a>, <a href="#topic+fusedlasso">fusedlasso</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Sparse 2d fused lasso
  library(genlasso)
  set.seed(1)
  dim1 = dim2 = 10
  n = 100
  y = as.numeric(row(diag(dim1)) &gt; 5 &amp; col(diag(dim2)) &gt; 5) * 3 + rnorm(n)

  a10 = fusedlasso2d(y, dim1=dim1, dim2=dim2, gamma=0.5, maxsteps=10)
  a20 = fusedlasso2d(y, dim1=dim1, dim2=dim2, gamma=0.5, maxsteps=20)
  a30 = fusedlasso2d(y, dim1=dim1, dim2=dim2, gamma=0.5, maxsteps=30)
  b20 = iterate(a10, moresteps=10)
  b30 = iterate(b20, moresteps=10)

  # Check for equality; should match on all but 'call'
  b20$call = a20$call
  b30$call = a30$call
  all.equal(target=a20, current=b20)
  all.equal(target=a30, current=b30)
</code></pre>

<hr>
<h2 id='plot.genlasso'>
Plotting methods for generalized lasso objects
</h2><span id='topic+plot.genlasso'></span><span id='topic+plot.trendfilter'></span><span id='topic+plot.cv.trendfilter'></span>

<h3>Description</h3>

<p>The function <code>plot.genlasso</code> produces a plot of the coordinate 
paths for objects of class &quot;genlasso&quot;. This can be helpful for
visualizing the full solution path for small problems; however, for
moderate or large problems, the plot produced can be quite dense and
difficult to interpret. The function <code>plot.trendfilter</code> applies
to objects of class &quot;trendfilter&quot;, and plots trend filtering
coefficients at a single value of lambda (or multiple 
values, as specified by the user) as a function of the input positions
(which, recall, are assumed to be evenly spaced if not specified).
The function <code>plot.cv.trendfilter</code> plots the output of
<code>cv.trendfilter</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genlasso'
plot(x, type = c("primal", "dual", "both"), numbers = FALSE,
     vlines = TRUE, xlab, ylab, ...)  
## S3 method for class 'trendfilter'
plot(x, style = c("trend", "path"), lambda, nlam, df, xlab,
     ylab, ...)
## S3 method for class 'cv.trendfilter'
plot(x, legendpos = "top", xlab, ylab, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.genlasso_+3A_x">x</code></td>
<td>

<p>an object of the appropriate class (&quot;genlasso&quot; or anything class
inherits this for <code>plot.genlasso</code>, &quot;trendfilter&quot; for
<code>plot.trendfilter</code>, and &quot;cv.trendfilter&quot; for
<code>plot.cv.trendfilter</code>). 
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_type">type</code></td>
<td>

<p>for <code>plot.genlasso</code>, a character string, one of &quot;primal&quot;,
&quot;dual&quot;, or &quot;both&quot;, indicating which solution path system(s) should
be plotted. Default is &quot;primal&quot;. 
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_numbers">numbers</code></td>
<td>

<p>for <code>plot.genlasso</code>,
a logical variable indicating if coordinate paths should be labeled
by their numbers. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_vlines">vlines</code></td>
<td>

<p>for <code>plot.genlasso</code>,
a logical variable indicating if dashed lines should be drawn at
knots in the path, with black lines for hitting events, and red
lines for leaving events. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_style">style</code></td>
<td>

<p>for <code>plot.trendfilter</code>,
a character string, either &quot;trend&quot; or &quot;path&quot;. If &quot;trend&quot;, then trend
filtering coefficients are plotted according to their underlying 
positions. If
&quot;path&quot;, then a plot of the coordinate paths is produced with the
function <code>plot.genlasso</code>. Default is &quot;trend&quot;.
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_lambda">lambda</code>, <code id="plot.genlasso_+3A_nlam">nlam</code>, <code id="plot.genlasso_+3A_df">df</code></td>
<td>

<p>for <code>plot.trendfilter</code>,
these arguments work exactly as they do in
<code><a href="#topic+coef.genlasso">coef.genlasso</a></code>, and they are used to specify which
solutions should be extracted and plotted from the computed solution
path stored in <code>x</code>. The only difference is, if all three
are missing, then <code>nlam</code> is set to 10 (whereas in
<code>coef.genlasso</code>, the default is to set <code>lambda</code> equal to
the full set of knots along the solution path).
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_legendpos">legendpos</code></td>
<td>

<p>for <code>plot.cv.trendfilter</code>, a character string indicating the
position of the legend. Default is &quot;top&quot;. 
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_xlab">xlab</code></td>
<td>

<p>an optional character string label for the x-axis. 
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_ylab">ylab</code></td>
<td>

<p>an optional character string label for the y-axis.
</p>
</td></tr>
<tr><td><code id="plot.genlasso_+3A_...">...</code></td>
<td>

<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>plot.trendfilter</code>, with <code>style</code> set to &quot;trend&quot;, a
coefficient object is silently returned as specified by <code>lambda</code>,
<code>nlam</code>, or <code>df</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genlasso">genlasso</a></code>, <code><a href="#topic+trendfilter">trendfilter</a></code>,
<code><a href="#topic+cv.trendfilter">cv.trendfilter</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constant trend filtering (the 1d fused lasso)
set.seed(0)
n = 100
beta0 = rep(sample(1:10,5),each=n/5)
y = beta0 + rnorm(n,sd=0.8)
a = fusedlasso1d(y)
cv = cv.trendfilter(a)

plot(a,style="path")
plot(cv)
plot(a,lambda=cv$lambda.1se)
</code></pre>

<hr>
<h2 id='predict.genlasso'>
Make predictions given a genlasso object
</h2><span id='topic+predict.genlasso'></span>

<h3>Description</h3>

<p>This predict method for the genlasso class makes a prediction for the
fitted values at new predictor measurements. Hence it is really only
useful when the generalized lasso model has been fit with a
nonidentity predictor matrix. In the case that the predictor matrix 
is the identity, it does the same thing as <code><a href="#topic+coef.genlasso">coef.genlasso</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genlasso'
predict(object, lambda, nlam, df, Xnew, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.genlasso_+3A_object">object</code></td>
<td>

<p>object of class &quot;genlasso&quot;, or an object which inherits this class 
(i.e., &quot;fusedlasso&quot;, &quot;trendfilter&quot;).
</p>
</td></tr>
<tr><td><code id="predict.genlasso_+3A_lambda">lambda</code></td>
<td>

<p>a numeric vector of tuning parameter values at which coefficients
should be calculated. The user can choose to specify one of
<code>lambda</code>, <code>nlam</code>, or <code>df</code>; if none are specified,
then coefficients are returned at every knot in the solution path. 
</p>
</td></tr>
<tr><td><code id="predict.genlasso_+3A_nlam">nlam</code></td>
<td>

<p>an integer indicating a number of tuning parameters values at which
coefficients should be calculated. The tuning parameter values are
then chosen to be equally spaced on the log scale over the first
half of the solution path (this is if the full solution path has
been computed; if only a partial path has been computed, the tuning 
parameter values are spaced over the entirety of the computed path).  
</p>
</td></tr>
<tr><td><code id="predict.genlasso_+3A_df">df</code></td>
<td>

<p>an integer vector of degrees of freedom values at which coefficients
should be calculated. In the case that a single degrees of freedom
value appears multiple times throughout the solution path, the least 
regularized solution (corresponding to the smallest value
of lambda) is chosen. If a degrees of freedom value does not appear
at all in the solution path, the least regularized solution at which
this degrees of freedom value is not exceeded is chosen. 
</p>
</td></tr>
<tr><td><code id="predict.genlasso_+3A_xnew">Xnew</code></td>
<td>

<p>a numeric matrix X, containing new predictor measurements at which
predictions should be made. If missing, it is assumed to be
the same as the existing predictor measurements in <code>object</code>.
</p>
</td></tr>
<tr><td><code id="predict.genlasso_+3A_...">...</code></td>
<td>

<p>additional arguments passed to predict.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>

<p>a numeric matrix of predictor values, one column for each value of
lambda.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>a numeric vector containing the sequence of tuning parameter values,
corresponding to the columns of <code>fit</code>.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>if <code>df</code> was specified, an integer vector containing the
sequence of degrees of freedom values corresponding to the columns
of <code>fit</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+coef.genlasso">coef.genlasso</a></code>
</p>

<hr>
<h2 id='softthresh'>
Fit a sparse variant of the fused lasso
</h2><span id='topic+softthresh'></span>

<h3>Description</h3>

<p>This function computes solution path to a fused lasso problem of the
form
</p>
<p style="text-align: center;"><code class="reqn">
    1/2 \sum_{i=1}^n (y_i - \beta_i)^2 + \lambda \sum_{(i,j) \in E}
    |\beta_i - \beta_j| + \gamma \cdot \lambda \sum_{i=1}^p |\beta_i|, 
  </code>
</p>

<p>given the solution path corresponding to <code class="reqn">\gamma=0</code>. Note that the 
predictor matrix here is the identity, and in this case the new
solution path is given by a simple soft-thresholding operation
(Friedman et al. 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  softthresh(object, lambda, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softthresh_+3A_object">object</code></td>
<td>

<p>an object of class &quot;fusedlasso&quot;, fit with no predictor matrix
<code>X</code> (taken to mean that the predictor matrix is the identity)
and with <code>gamma</code> set to 0. Other objects will issue a warning
that soft-thresholding does not give the exact primal solution path
to a sparsified generalized lasso problem.
</p>
</td></tr>
<tr><td><code id="softthresh_+3A_lambda">lambda</code></td>
<td>

<p>a numeric vector giving the values of lambda at which the solution
should be computed and returned; if missing, defaults to the knots
in the solution path stored in <code>object</code>.
</p>
</td></tr>
<tr><td><code id="softthresh_+3A_gamma">gamma</code></td>
<td>

<p>a numeric variable giving the ratio of the fusion and sparsity
tuning parameters, must be greater than or equal to 0. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix of primal solutions, one column for each
value of lambda.
</p>


<h3>References</h3>

<p>Friedman J., Hastie T., Hoefling H. and Tibshirani, R. (2007),
&quot;Pathwise coordinate optimization&quot;, Annals of Applied Statistics 
1 (2) 302&ndash;332.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fusedlasso">fusedlasso</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The 1d fused lasso
set.seed(0)
n = 100
beta0 = rep(sample(1:10,5),each=n/5)
beta0 = beta0-mean(beta0)
y = beta0 + rnorm(n,sd=0.8)
a = fusedlasso1d(y)

lambda = 4
b1 = coef(a,lambda=lambda)$beta

gamma = 0.5
b2 = softthresh(a,lambda=lambda,gamma=gamma)

plot(1:n,y)
lines(1:n,b1)
lines(1:n,b2,col="red")
legend("topright",lty=1,col=c("black","red"),
       legend=c(expression(gamma==0),expression(gamma==0.5)))
</code></pre>

<hr>
<h2 id='trendfilter'>
Compute the trend filtering solution path for any polynomial order
</h2><span id='topic+trendfilter'></span>

<h3>Description</h3>

<p>This function computes the solution path for the trend filtering
problem of an arbitrary polynomial order. When the order is set to
zero, trend filtering is equivalent to the 1d fused lasso, see
<code><a href="#topic+fusedlasso1d">fusedlasso1d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trendfilter(y, pos, X, ord = 1, approx = FALSE, maxsteps = 2000,
            minlam = 0, rtol = 1e-07, btol = 1e-07, eps = 1e-04,
            verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trendfilter_+3A_y">y</code></td>
<td>

<p>a numeric response vector.
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_pos">pos</code></td>
<td>

<p>an optional numeric vector specifying the positions of the
observations, and missing <code>pos</code> is assumed to mean unit spacing.
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_x">X</code></td>
<td>

<p>an optional matrix of predictor variables, with observations along
the rows, and variables along the columns. If the passed <code>X</code> 
has more columns than rows, then a warning is given, and a small ridge
penalty is added to the generalized lasso criterion before the path
is computed. If <code>X</code> has less columns than rows, then its rank is
not checked for efficiency, and (unlike the <code>genasso</code> function) a 
ridge penalty is not automatically added if it is rank deficient. 
Therefore, a tall, rank deficient <code>X</code> may cause errors. 
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_ord">ord</code></td>
<td>

<p>an integer specifying the desired order of the piecewise polyomial
produced by the solution of the trend filtering problem. Must be
non-negative, and the default to 1 (linear trend filtering).
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_approx">approx</code></td>
<td>

<p>a logical variable indicating if the approximate solution path
should be used (with no dual coordinates leaving the boundary).
Default is <code>FALSE</code>. Note 
that for the 1d fused lasso (zeroth order trend filtering), with
identity predictor matrix, this approximate path is the same as 
the exact solution path. 
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_maxsteps">maxsteps</code></td>
<td>

<p>an integer specifying the maximum number of steps for the algorithm
to take before termination. Default is 2000. 
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_minlam">minlam</code></td>
<td>

<p>a numeric variable indicating the value of lambda at which the path
should terminate. Default is 0.
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_rtol">rtol</code></td>
<td>

<p>a numeric variable giving the tolerance for determining the rank of
a matrix: if a diagonal value in the R factor of a QR decomposition
is less than R, in absolute value, then it is considered zero. Hence
making rtol larger means being less stringent with determination of
matrix rank. In general, do not change this unless you know what you
are getting into! Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_btol">btol</code></td>
<td>

<p>a numeric variable giving the tolerance for accepting &quot;late&quot; hitting
and leaving times: future hitting times and leaving times should always 
be less than the current knot in the path, but sometimes for numerical
reasons they are larger; any computed hitting or leaving time larger 
than the current knot + btol is thrown away. Hence making btol larger
means being less stringent withthe determination of hitting and leaving 
times. Again, in general, do not change this unless you know what you 
are getting into! Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_eps">eps</code></td>
<td>

<p>a numeric variable indicating the multiplier for the ridge penalty,
in the case that <code>X</code> is wide (more columns than rows). If numeric
problems occur, make <code>eps</code> larger. Default is 1e-4.
</p>
</td></tr>
<tr><td><code id="trendfilter_+3A_verbose">verbose</code></td>
<td>

<p>a logical variable indicating if progress should be reported after
each knot in the path.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the predictor matrix is the identity, trend filtering fits a
piecewise polynomial to linearly ordered observations. The result is 
similar to that of a polynomial regression spline or a smoothing
spline, except the knots in the piecewise polynomial (changes in the 
(k+1)st derivative, if the polynomial order is k) are chosen
adaptively based on the observations. This is in contrast to
regression splines, where the knots are prespecified, and smoothing
splines, which place a knot at every data point. 
</p>
<p>With a nonidentity predictor matrix, the trend filtering problem
enforces piecewise polynomial smoothness along successive components
of the coefficient vector. This can be used to fit a kind of varying
coefficient model.
</p>
<p>We note that, in the signal approximator (identity predictor matrix) 
case, fitting trend filtering estimate with arbitrary positions <code>pos</code> 
is theoretically no harder than doing so on an evenly spaced grid. However
in practice, with differing gaps between points, the algorithm can 
become numerically unstable even for large (or moderately large) problems. 
This is especially true as the polynomial order increases. Hence, use the
positions argument <code>pos</code> with caution. 
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;trendfilter&quot;, a subclass of
&quot;genlasso&quot;. This is a list with at least following components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>

<p>values of lambda at which the solution path changes slope,
i.e., kinks or knots.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>a matrix of primal coefficients, each column corresponding to a knot
in the solution path.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>a matrix of fitted values, each column corresponding to a knot in
the solution path.
</p>
</td></tr>
<tr><td><code>u</code></td>
<td>

<p>a matrix of dual coefficients, each column corresponding to a knot
in the solution path.
</p>
</td></tr>
<tr><td><code>hit</code></td>
<td>

<p>a vector of logical values indicating if a new variable in the dual
solution hit the box contraint boundary. A value of <code>FALSE</code>
indicates a variable leaving the boundary. 
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a vector giving an unbiased estimate of the degrees of freedom of
the fit at each knot in the solution path.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>the observed response vector. Useful for plotting and other
methods.
</p>
</td></tr>
<tr><td><code>completepath</code></td>
<td>

<p>a logical variable indicating whether the complete path was
computed (terminating the path early with the <code>maxsteps</code> or
<code>minlam</code> options results in a value of <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>bls</code></td>
<td>

<p>the least squares solution, i.e., the solution at lambda = 0. This
can be <code>NULL</code> when <code>completepath</code> is <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>

<p>the order of the piecewise polyomial that has been fit.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the matched call.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Taylor B. Arnold and Ryan J. Tibshirani
</p>


<h3>References</h3>

<p>Tibshirani, R. J. and Taylor, J. (2011), &quot;The solution path of the
generalized lasso&quot;, Annals of Statistics 39 (3) 1335&ndash;1371.
</p>
<p>Tibshirani, R. J. (2014), &quot;Adaptive piecewise polynomial estimation
via trend filtering&quot;, Annals of Statistics 42 (1): 285&ndash;323.
</p>
<p>Arnold, T. B. and Tibshirani, R. J. (2014), &quot;Efficient implementations
of the generalized lasso dual path algorithm&quot;, arXiv: 1405.3222.
</p>
<p>Kim, S.-J., Koh, K., Boyd, S. and Gorinevsky, D. (2009), &quot;l1 trend
filtering&quot;, SIAM Review 51 (2), 339&ndash;360.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fusedlasso1d">fusedlasso1d</a></code>, <code><a href="#topic+genlasso">genlasso</a></code>,
<code><a href="#topic+cv.trendfilter">cv.trendfilter</a></code>, <code><a href="#topic+plot.trendfilter">plot.trendfilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constant trend filtering (the 1d fused lasso)
set.seed(0)
n = 100
beta0 = rep(sample(1:10,5),each=n/5)
y = beta0 + rnorm(n,sd=0.8)
a = fusedlasso1d(y)
plot(a)

# Linear trend filtering
set.seed(0)
n = 100
beta0 = numeric(n)
beta0[1:20] = (0:19)*4/19+2
beta0[20:45] = (25:0)*3/25+3
beta0[45:80] = (0:35)*9/35+3
beta0[80:100] = (20:0)*4/20+8
y = beta0 + rnorm(n)
a = trendfilter(y,ord=1)
plot(a,df=c(2,3,4,10))

# Cubic trend filtering
set.seed(0)
n = 100
beta0 = numeric(100)
beta0[1:40] = (1:40-20)^3
beta0[40:50] = -60*(40:50-50)^2 + 60*100+20^3
beta0[50:70] = -20*(50:70-50)^2 + 60*100+20^3
beta0[70:100] = -1/6*(70:100-110)^3 + -1/6*40^3 + 6000
beta0 = -beta0
beta0 = (beta0-min(beta0))*10/diff(range(beta0))
y = beta0 + rnorm(n)
a = trendfilter(y,ord=3)
plot(a,nlam=5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
