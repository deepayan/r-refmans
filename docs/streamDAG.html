<!DOCTYPE html><html lang="en"><head><title>Help for package streamDAG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {streamDAG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A'>
<p>Arcs of a directed graph</p></a></li>
<li><a href='#A.mult'>
<p>Raise an adjacency matrix to some power</p></a></li>
<li><a href='#AIMS.node.coords'>
<p>Nodal coordinates for graphs in the AIMS project</p></a></li>
<li><a href='#arc.pa.from.nodes'>
<p>Obtain arc stream activity outcomes based on bounding nodes</p></a></li>
<li><a href='#assort'>
<p>Assortativity</p></a></li>
<li><a href='#bern.length'>
<p>Botter and Durighetto Bernoulli stream length</p></a></li>
<li><a href='#beta.posterior'>
<p>Posterior Beta and Inverse-beta summaries</p></a></li>
<li><a href='#biv.bern'>
<p>Bivariate Bernoulli Distribution</p></a></li>
<li><a href='#dc_arc_pres_abs'>
<p>Stream segment presence absence data for Dry Cr. Idaho</p></a></li>
<li><a href='#dc_lengths'>
<p>Lengths of Dry Creek stream (arc) segments</p></a></li>
<li><a href='#dc_node_pres_abs'>
<p>Stream node presence absence data for Dry Cr. Idaho</p></a></li>
<li><a href='#degree.dists'>
<p>Potential degree distributions</p></a></li>
<li><a href='#delete.arcs.pa'>
<p>Delete arcs based on presence absence data</p></a></li>
<li><a href='#delete.nodes.pa'>
<p>Delete nodes based on presence absence data</p></a></li>
<li><a href='#dinvbeta'>
<p>Inverse Beta Distribution</p></a></li>
<li><a href='#efficiency'><p>Local and global efficiency</p></a></li>
<li><a href='#get.AIMS.data'>
<p>Loads AIMS dataset associated with a particular AIMS graph</p></a></li>
<li><a href='#gj_coords16'>
<p>Coordinates of nodes at Gibson Jack Creek, Idaho for a 2016 survey</p></a></li>
<li><a href='#gj_lengths'>
<p>Lengths of Gibson Jack stream (arc) segments</p></a></li>
<li><a href='#gj_node_pres_abs'>
<p>Stream node presence absence data for Gibson Jack Idaho</p></a></li>
<li><a href='#gj_node_pres_abs16'>
<p>Stream node presence absence data for Gibson Jack Cr. Idaho, for a 2016 survey</p></a></li>
<li><a href='#global.summary'>
<p>Global Summary</p></a></li>
<li><a href='#harary'>
<p>Harary Index</p></a></li>
<li><a href='#I.D'>
<p>Generalized DAG indices</p></a></li>
<li><a href='#ICSL'>
<p>Integral connectivity scale length (ICSL)</p></a></li>
<li><a href='#imp.closeness'>
<p>Improved Closeness Centrality</p></a></li>
<li><a href='#isle'>
<p>Detects and defines islands in a streamDAG</p></a></li>
<li><a href='#jd_lengths'>
<p>Lengths of Johnson Draw stream (arc) segments</p></a></li>
<li><a href='#jd_node_pres_abs'>
<p>Stream node presence absence data for Johnson Draw Idaho</p></a></li>
<li><a href='#kon_coords'>
<p>Coordinates of nodes in the Konza Praire dataset</p></a></li>
<li><a href='#kon_lengths'>
<p>Lengths of Murphy Cr. stream (arc) segments</p></a></li>
<li><a href='#local.summary'>
<p>local (nodal) summaries of a DAG</p></a></li>
<li><a href='#mur_arc_pres_abs'>
<p>Stream segment presence absence data for Murphy Cr. Idaho</p></a></li>
<li><a href='#mur_coords'>
<p>Coordinates of nodes at Murphy Ck. Idaho</p></a></li>
<li><a href='#mur_lengths'>
<p>Lengths of Murphy Cr. stream (arc) segments</p></a></li>
<li><a href='#mur_node_pres_abs'>
<p>Stream node presence absence data for Murphy Cr. Idaho</p></a></li>
<li><a href='#mur_seasons_arc_pa'>
<p>Simulated seasonal arc presence absence data for Murphy Cr</p></a></li>
<li><a href='#n.sources'>
<p>Identify source and sink nodes</p></a></li>
<li><a href='#path.lengths.sink'>
<p>Path Lengths</p></a></li>
<li><a href='#path.visibility'>
<p>Path Visibilities</p></a></li>
<li><a href='#plot_degree.dist'>
<p>Plot degree distributions</p></a></li>
<li><a href='#R.bounds'><p>Bounds for the correlation of two (or more) Benrnoulli random variables</p></a></li>
<li><a href='#size.intact.to.arc'>
<p>Size of the intact network above an arc</p></a></li>
<li><a href='#size.intact.to.sink'>
<p>Size of intact network that feeds into the sink or a particular node</p></a></li>
<li><a href='#spath.lengths'>
<p>Shortest path lengths and number of paths</p></a></li>
<li><a href='#spatial.plot'>
<p>Spatial plot of an igraph object or stream shapefile</p></a></li>
<li><a href='#STIC.RFimpute'>
<p>A wrapper for missForest for random forest STIC imputation</p></a></li>
<li><a href='#stream.order'>
<p>Strahler or Shreve stream order of a stream DAG</p></a></li>
<li><a href='#streamDAGs'>
<p>Stream DAG datasets</p></a></li>
<li><a href='#vector_segments'>
<p>Functions for overlaying networks on shapefiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.5-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-1-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Analytical Methods for Stream DAGs</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ken Aho &lt;ahoken@isu.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>asbio, graphics, stats, plotrix, missForest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, sf, knitr, rmarkdown, bookdown, RColorBrewer,
devtools, ggrepel</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides indices and tools for directed acyclic graphs (DAGs), particularly DAG representations of intermittent streams.  A detailed introduction to the package can be found in the publication: "Non-perennial stream networks as directed acyclic graphs: The R-package streamDAG" (Aho et al., 2023) &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2023.105775">doi:10.1016/j.envsoft.2023.105775</a>&gt;, and in the introductory package vignette.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-14 21:27:12 UTC; ahoken</td>
</tr>
<tr>
<td>Author:</td>
<td>Ken Aho [aut, cre],
  Arya Legg [dtc, ctb],
  Rob Ramos [dtc],
  Maggi Kraft [dtc],
  Charles T. Bond [dtc],
  Rebecca L. Hale [dtc]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-14 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='A'>
Arcs of a directed graph
</h2><span id='topic+A'></span>

<h3>Description</h3>

<p>This function and its documentation have been lifted from the <em>igraph</em> function <code><a href="igraph.html#topic+E">E</a></code> with arguments according to DAG conventions. An arc sequence is a vector containing numeric arc ids, with a special class attribute that allows custom operations: selecting subsets of arcs based on attributes, or graph structure, creating the intersection, union of arcs, etc.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A(G, P, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A_+3A_g">G</code></td>
<td>

<p>Graph object of class <code>igraph</code>. See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="A_+3A_p">P</code></td>
<td>

<p>A list of node to select arcs via pairs of nodes. The first and second nodes select the first arc, the third and fourth node select the second arc, etc.
</p>
</td></tr>
<tr><td><code id="A_+3A_path">path</code></td>
<td>

<p>A list of nodes, to select arcs along a path. Note that this only works reliably for simple graphs. If the graph has multiple arcs, one of them will be chosen arbitrarily to be included in the arc sequence.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arc sequences are usually used as function arguments that refer to arcs of a graph.
</p>
<p>An arc sequence is tied to the graph it refers to: it really denoted the specific arcs of that graph, and cannot be used together with another graph.
</p>
<p>An arc sequence is most often created by the <code>A()</code> function. The result includes arcs in increasing arc id order by default (if none of the <code>P</code> and <code>path</code> arguments are used). An arc sequence can be indexed by a numeric vector, just like a regular R vector. 
</p>


<h3>Value</h3>

<p>An arc sequence of the graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi
</p>


<h3>See Also</h3>

<p>See <code><a href="igraph.html#topic+E">E</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> G &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, e --+ j, j --+ m, f --+ g, g --+ i, 
 h --+ i, i --+ k, k --+ l, l --+ m, m --+ n,  n --+ o)
 
A(G)

</code></pre>

<hr>
<h2 id='A.mult'>
Raise an adjacency matrix to some power
</h2><span id='topic+A.mult'></span>

<h3>Description</h3>

<p>When applying the definition of matrix multiplication to an adjacency matrix 
<code class="reqn">\mathbf{A}</code>, the <code class="reqn">i,j</code> entry in <code class="reqn">\mathbf{A}^k</code> will give the number of paths in the graph from node <code class="reqn">i</code> to node <code class="reqn">j</code> of length <code class="reqn">k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A.mult(G, power, text.summary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A.mult_+3A_g">G</code></td>
<td>

<p>Graph object of class <code>igraph</code>. See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="A.mult_+3A_power">power</code></td>
<td>

<p>The power to rise the adjacency matrix to.
</p>
</td></tr>
<tr><td><code id="A.mult_+3A_text.summary">text.summary</code></td>
<td>

<p>Logical.  If <code>TRUE</code> the function returns a summary of the paths of length <code>power</code>.  If <code>FALSE</code>.  The adjacency matrix raised to <code>power</code> is returned. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a character vector of paths of a specified length or, if <code>text.summary = TRUE</code>, the adjacency matrix raised to a specified power.</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kon_full &lt;- streamDAGs("konza_full")
A.mult(kon_full, power = 6)
</code></pre>

<hr>
<h2 id='AIMS.node.coords'>
Nodal coordinates for graphs in the AIMS project 
</h2><span id='topic+AIMS.node.coords'></span>

<h3>Description</h3>

<p>Contains spatial coordinates for graph nodes for stream networks in the Aquatic Intermittency effects on Microbiomes in Streams (AIMS) project 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("AIMS.node.coords")</code></pre>


<h3>Format</h3>

<p>A data frame with 307 observations on the following 7 variables.
</p>

<dl>
<dt><code>Object.ID</code></dt><dd><p>Nodal identifier</p>
</dd>
<dt><code>lat</code></dt><dd><p>Latitude</p>
</dd>
<dt><code>long</code></dt><dd><p>Longitude</p>
</dd>
<dt><code>site</code></dt><dd><p>Stream network name, currently includes: <code>"KZ"</code> = Konza Prairie, <code>"TD"</code> = Talladega, <code>"WH"</code> = Weyerhauser, <code>"PR"</code> = Painted Rock, <code>"JD"</code> = Johnson Draw, <code>"DC"</code> = Dry Creek, and <code>"GJ"</code> = Johnson Draw.</p>
</dd>
<dt><code>piezo</code></dt><dd><p>Logical, indicating whether the location contains a peizometer.</p>
</dd>
<dt><code>microbial_seasonal_network</code></dt><dd><p>Logical, whether the location was sampled as part of AIMS seasonal microbial sampling.</p>
</dd>
<dt><code>STIC_inferred_PA</code></dt><dd><p>Logical, whether surface water presence/absence data were obtained from STIC  (Stream Temperature, Intermittency, and Conductivity) sensors at the location.</p>
</dd>
<dt><code>New_in_2023</code></dt><dd><p>Logical, referring to sites at Johnson Draw added in 2023.</p>
</dd>
</dl>


<hr>
<h2 id='arc.pa.from.nodes'>
Obtain arc stream activity outcomes based on bounding nodes
</h2><span id='topic+arc.pa.from.nodes'></span>

<h3>Description</h3>

<p>Given nodal water presence absence data <code class="reqn">\in \{0,1\}</code> for a graph, <em>G</em>, the function calculates arc water presence probabilities using particular rules (see approaches in Details). </p>


<h3>Usage</h3>

<pre><code class='language-R'>arc.pa.from.nodes(G, node.pa, approach = "aho", na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arc.pa.from.nodes_+3A_g">G</code></td>
<td>

<p>Graph object of class <code>igraph</code>. See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.</p>
</td></tr>
<tr><td><code id="arc.pa.from.nodes_+3A_node.pa">node.pa</code></td>
<td>
<p>A data frame or matrix of nodal presence absence data with column names corresponding to node names in <code>G</code>. 
</p>
</td></tr>
<tr><td><code id="arc.pa.from.nodes_+3A_approach">approach</code></td>
<td>
<p>One of <code>"aho"</code>, <code>"dstream"</code>, or <code>"ustream"</code> (see Details).</p>
</td></tr>
<tr><td><code id="arc.pa.from.nodes_+3A_na.rm">na.rm</code></td>
<td>
<p>For <code>approach = "aho"</code>, one of <code>TRUE</code> or <code>FALSE</code> indicating whether <code>NA</code> values should be stripped before calculating means.  Ignored for other appraches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>approach</code> argument currently supports three alternatives <code>"aho"</code>, <code>"dstream"</code> and <code>"ustream"</code>. Let <code class="reqn">x_{k}</code> represent the <code class="reqn">k</code>th arc with bounding nodes <code class="reqn">u</code> and <code class="reqn">v</code>.  
</p>
<p>Under <code>approach = "aho"</code> there are three possibilities: 
<code class="reqn">x_{k} = 1.0</code> if both <code class="reqn">u</code> and <code class="reqn">v</code> are wet, 
<code class="reqn">x_{k} = 0</code> if both <code class="reqn">u</code> and <code class="reqn">v</code> are dry, and 
<code class="reqn">x_{k} = 0.5</code> if only one of <code class="reqn">u</code> or <code class="reqn">v</code> is wet.
</p>
<p>Under <code>approach = "dstream"</code>, <code class="reqn">x_{k} = 1.0</code> if <code class="reqn">v</code> is wet, and <code class="reqn">x_{k} = 0</code> if <code class="reqn">v</code> is dry. 
</p>
<p>Conversely, if <code>approach = "ustream"</code>, <code class="reqn">x_{k} = 1.0</code> if <em>u</em> is wet, and <code class="reqn">x_{k} = 0</code> if <em>u</em> is dry.   
</p>


<h3>Value</h3>

<p>Returns a matrix whose entries are estimated probabilities of success (e.g. surface water presence) based on the rules given in Aho et al. (2023).  Matrix columns specify arcs and rows typically represent time series observations.</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>References</h3>

<p>Aho, K., Derryberry, D., Godsey, S. E., Ramos, R., Warix, S., Zipper, S. (2023) The communication distance of non-perennial streams. EarthArXiv <a href="https://eartharxiv.org/repository/view/4907/">https://eartharxiv.org/repository/view/4907/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>murphy_spring &lt;- graph_from_literal(IN_N --+ M1984 --+ M1909, IN_S --+ M1993,  
M1993 --+ M1951 --+ M1909 --+ M1799 --+ M1719 --+ M1653 --+ M1572 --+ M1452, 
M1452 --+ M1377 --+ M1254 --+ M1166 --+ M1121 --+ M1036 --+ M918 --+ M823, 
M823 --+ M759 --+ M716 --+ M624 --+ M523 --+ M454 --+ M380 --+ M233 --+ M153, 
M153 --+ M91 --+ OUT)

data(mur_node_pres_abs)
pa &lt;- mur_node_pres_abs[400:405,][,-1]
arc.pa.from.nodes(murphy_spring, pa)
arc.pa.from.nodes(murphy_spring, pa, "dstream")
</code></pre>

<hr>
<h2 id='assort'>
Assortativity
</h2><span id='topic+assort'></span>

<h3>Description</h3>

<p>Calculates graph assortativity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assort(G, mode = "in.out")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assort_+3A_g">G</code></td>
<td>

<p>Graph object of class <code>igraph</code>. See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="assort_+3A_mode">mode</code></td>
<td>
<p>One of <code>"in.in"</code>, <code>"in.out"</code>, <code>"out.out"</code>, <code>"out.in"</code>, or <code>"all"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definitive measure of graph assortativity is the Pearson correlation coefficient of the degree of pairs of adjacent nodes (Newman, 2002). Let <code class="reqn">\overrightarrow{u_iv_i}</code> define nodes and directionality of the ith arc, <code class="reqn">i=1,2,3,\ldots,m</code>, let <code class="reqn">\gamma,\tau\in{-,+}</code> index the degree type: <code class="reqn">-=in, +=out</code>, and let <code class="reqn">\left(u_i^\gamma,v_i^\tau\right)</code>, be the <code class="reqn">\gamma-</code> and <code class="reqn">\tau-</code>degree of the <em>i</em>th arc. Then, the general form of assortativity index is:
</p>
<p style="text-align: center;"><code class="reqn">r\left(\gamma,\tau\right)=m^{-1}\frac{\sum_{i= 1}^m (u_i^\gamma-\bar{u}^\gamma)(v^\tau_i-\bar{v}^\tau)}{s^\gamma s^\tau}
</code>
</p>

<p>where <code class="reqn">\bar{u}^\gamma</code> and <code class="reqn">\bar{v}^\gamma</code> are the arithmetic means of the <code class="reqn">u_i^\gamma</code>s and <code class="reqn">v_i^\tau</code>s, and <code class="reqn">s^\gamma</code> and <code class="reqn">s^\tau</code> are the population standard deviations of the <code class="reqn">u_i^\gamma</code>s and <code class="reqn">v_i^\tau</code>s. Under this framework, there are four possible forms to <code class="reqn">r\left(\gamma,\tau\right)</code> (Foster et al., 2010). These are: <code class="reqn">r\left(+,-\right), r\left(-,+\right), r\left(-,-\right)</code>, and <code class="reqn">r\left(+,+\right)</code>.
</p>


<h3>Value</h3>

<p>Assortativity coefficeint outcome(s)
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+degree">degree</a></code> 
</p>


<h3>References</h3>

<p>Newman, M. E. (2002). Assortative mixing in networks. <em>Physical Review Letters, 89</em>(20), 208701.
</p>
<p>Foster, J. G., Foster, D. V., Grassberger, P., &amp; Paczuski, M. (2010). Edge direction and the structure of networks. <em>Proceedings of the National Academy of Sciences, 107</em>(24), 10815-10820.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_a &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, e --+ j, 
j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, l --+ m, m --+ n,  
n --+ o)
assort(network_a)
</code></pre>

<hr>
<h2 id='bern.length'>
Botter and Durighetto Bernoulli stream length
</h2><span id='topic+bern.length'></span>

<h3>Description</h3>

<p>A simple function for calculating the dot product of a vector of stream arc lengths and a corresponding vector of either binary (stream presence or absence) outcomes, probabilities of stream presence or inverse probabilites of stream presence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bern.length(lengths, pa, mode = "local")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bern.length_+3A_lengths">lengths</code></td>
<td>

<p>A numeric vector of stream arc lengths
</p>
</td></tr>
<tr><td><code id="bern.length_+3A_pa">pa</code></td>
<td>

<p>A numeric vector of either binary (stream presence or absence) outcomes, probabilities of stream presence or inverse probabilites of stream presence.  A vector outcome in <code>lengths</code> should correspond to an outcome for the same arc in <code>pa</code>.
</p>
</td></tr>
<tr><td><code id="bern.length_+3A_mode">mode</code></td>
<td>

<p>One of <code>"local"</code> of <code>"global"</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>pa</code> is a vector of binary (stream presence or absence) data, the function provides a measure of instantaneous stream length (in the units used in <code>lengths</code>). When <code>pa</code> is a vector of probabilities of stream presence, the function provides average stream length (in units used in <code>lengths</code>). When <code>pa</code> is a vector of inverse probabilites of stream presence, the function provides average communication distance (in units used in <code>lengths</code>).
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>References</h3>

<p>Botter, G., &amp; Durighetto, N. (2020). The stream length duration curve: A tool for characterizing the time variability of the flowing stream length. <em>Water Resources Research, 56</em>(8), e2020WR027282.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lengths &lt;- rexp(10, 10)
pa &lt;- rbinom(10, 11, 0.4)
bern.length(lengths, pa)
</code></pre>

<hr>
<h2 id='beta.posterior'>
Posterior Beta and Inverse-beta summaries
</h2><span id='topic+beta.posterior'></span>

<h3>Description</h3>

<p>Calculates summaries for beta and inverse-beta posteriors given prior probabilities for success, binary data and prior weight specification. Summaries include beta and inverse beta posterior means and variances and stream length and communication distance summaries given that stream <code>length</code> is provided for intermittent stream segments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
beta.posterior(p.prior, dat, length = NULL, w = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta.posterior_+3A_p.prior">p.prior</code></td>
<td>

<p>Prior probability for success for the beta prior.  The beta prior for the probability of success (e.g., stream presence) for <em>k</em>th outcome (e.g., stream segment) is defined as: <code class="reqn"> \theta_k \sim BETA(\alpha, \beta = t \alpha)</code>, where <code class="reqn">\frac{1}{1+t} = p_{prior}</code>.  This results in: <code class="reqn">E(\theta_k) = p_{prior}</code>.
</p>
</td></tr>
<tr><td><code id="beta.posterior_+3A_dat">dat</code></td>
<td>
<p>An <code class="reqn">n \times s</code> matrix of binary outcomes, where <em>n</em> is the number of observations (e.g., stream observations over time) and <em>s</em> is the number experimental units observed, (e.g., stream segments).   
</p>
</td></tr>
<tr><td><code id="beta.posterior_+3A_length">length</code></td>
<td>

<p>An optional <code class="reqn">n \times 1</code> vector containing stream segement lengths to allow calculation of mean stream Bernoulli stream length and mean communication distance. 
</p>
</td></tr>
<tr><td><code id="beta.posterior_+3A_w">w</code></td>
<td>

<p>Weight for the prior distribution compared to the actual data (generally a proportion).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As our Bayesian framework we assume a conjugate beta prior <code class="reqn"> \theta_k \sim BETA(\alpha, \beta)</code> and binomial likelihood <code class="reqn"> \boldsymbol{x}_k \mid \theta_k \sim BIN(n, \theta_k)</code> resulting in the posterior <code class="reqn">\theta_k \mid \boldsymbol{x}_k \sim BETA(\alpha + \sum \boldsymbol{x}_k, \beta + n - \sum \boldsymbol{x}_k)</code>. 
</p>


<h3>Value</h3>

<p>Returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>The <code class="reqn">\alpha</code> shape parameters for the beta and inverse beta posteriors.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The <code class="reqn">\beta</code> shape parameters for the beta and inverse beta posteriors.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The means of the beta posteriors.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The variances of the beta posteriors.</p>
</td></tr>
<tr><td><code>mean.inv</code></td>
<td>
<p>The means of the inverse-beta posteriors.</p>
</td></tr>
<tr><td><code>var.inv</code></td>
<td>
<p>The variances of the inverse-beta posteriors.</p>
</td></tr>
<tr><td><code>Com.dist</code></td>
<td>
<p>If <code>length</code> is supplied, the mean communication distances of the network.</p>
</td></tr>
<tr><td><code>Length</code></td>
<td>
<p>If <code>length</code> is supplied, the mean stream length of the network.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The observed number of Bernoulli successes over <em>n</em> trials observed in <code>dat</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dinvbeta">dinvbeta</a></code>.
</p>

<hr>
<h2 id='biv.bern'>
Bivariate Bernoulli Distribution
</h2><span id='topic+biv.bern'></span>

<h3>Description</h3>

<p>Densities (probabilities) of a bivariate Bernoulli distribution, <code class="reqn">Y_1,Y_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biv.bern(p11, p10, p01, p00, y1, y2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biv.bern_+3A_p11">p11</code></td>
<td>

<p>The probability that <code class="reqn">y_1,y_2 = 1,1</code>.
</p>
</td></tr>
<tr><td><code id="biv.bern_+3A_p10">p10</code></td>
<td>

<p>The probability that <code class="reqn">y_1,y_2 = 1,0</code>.
</p>
</td></tr>
<tr><td><code id="biv.bern_+3A_p01">p01</code></td>
<td>

<p>The probability that <code class="reqn">y_1,y_2 = 0,1</code>.
</p>
</td></tr>
<tr><td><code id="biv.bern_+3A_p00">p00</code></td>
<td>

<p>The probability that <code class="reqn">y_1,y_2 = 0,0</code>.
</p>
</td></tr>
<tr><td><code id="biv.bern_+3A_y1">y1</code></td>
<td>

<p>Outcome for <code class="reqn">Y_1</code>.
</p>
</td></tr>
<tr><td><code id="biv.bern_+3A_y2">y2</code></td>
<td>

<p>Outcome for <code class="reqn">Y_2</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Densities (probability) of the joint Bernoulli distribution.
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biv.bern(0.25,0.25,0.25,0.25,1,0)
biv.bern(0.1,0.4,0.3,0.2,1,0)
</code></pre>

<hr>
<h2 id='dc_arc_pres_abs'>
Stream segment presence absence data for Dry Cr. Idaho 
</h2><span id='topic+dc_arc_pres_abs'></span>

<h3>Description</h3>

<p>Stream segment presence absence data for Dry Cr. Idaho (outlet coordinates: 43.71839<code class="reqn">^\circ</code>N, 116.13747<code class="reqn">^\circ</code>W).  Arc outcomes determined from STIC (Stream Temperature, Intermittency, and Conductivity) sensors at bounding nodes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dc_arc_pres_abs")</code></pre>


<h3>Format</h3>

<p>A data frame with 46187 observations on the following 29 variables.
</p>

<dl>
<dt><code>datetime</code></dt><dd><p>a POSIXlt</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC10--&gt;C1&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C1--&gt;DC12&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC11--&gt;C1&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC12--&gt;C2&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C2--&gt;DC15&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC13--&gt;C2&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC15--&gt;C3&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C3--&gt;DC16&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC14--&gt;C3&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC16--&gt;C4&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C4--&gt;DC19&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC17--&gt;C5&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C5--&gt;C4&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC18--&gt;C5&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC19--&gt;C6&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C6--&gt;DC4&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC20--&gt;C6&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC4--&gt;C7&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C7--&gt;DC5&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC1--&gt;DC2&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC2--&gt;DC3&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC3--&gt;C7&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC5--&gt;C8&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C8--&gt;DC6&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC9--&gt;C9&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;C9--&gt;DC7&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC8--&gt;C9&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;DC7--&gt;C8&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Maggie Kraft
</p>

<hr>
<h2 id='dc_lengths'>
Lengths of Dry Creek stream (arc) segments
</h2><span id='topic+dc_lengths'></span>

<h3>Description</h3>

<p>Lengths of stream (arc) segments from Dry Creek Idaho (outlet coordinates: 43.71839<code class="reqn">^\circ</code>N, 116.13747<code class="reqn">^\circ</code>W).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dc_lengths")</code></pre>


<h3>Format</h3>

<p>A data frame with 28 observations on the following 2 variables.
</p>

<dl>
<dt><code>Arcs</code></dt><dd><p>Arc names, arrows directionally connect nodes.</p>
</dd>
<dt><code>Lengths</code></dt><dd><p>Stream segment (arc) length in kilometers.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Maggie Kraft
</p>

<hr>
<h2 id='dc_node_pres_abs'>
Stream node presence absence data for Dry Cr. Idaho 
</h2><span id='topic+dc_node_pres_abs'></span>

<h3>Description</h3>

<p>Stream node surface water presence absence at Dry Creek ID (outlet coordinates: 43.71839<code class="reqn">^\circ</code>N, 116.13747<code class="reqn">^\circ</code>W). Outcomes based on STIC (Stream Temperature, Intermittency, and Conductivity) sensor and piezometer responses, resulting in binary observations for 36 nodes at 15 minutes intervals, over four years.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dc_node_pres_abs")</code></pre>


<h3>Format</h3>

<p>A data frame with 86958 observations on the following 37 variables.
</p>

<dl>
<dt><code>datetime</code></dt><dd><p>a POSIXlt object</p>
</dd>
<dt><code>DC10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DPZ07</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DPZ06</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DPZ05</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC19</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC20</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DPZ02</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DPZ04</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DPZ03</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DC6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>DSS01</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Maggie Kraft
</p>

<hr>
<h2 id='degree.dists'>
Potential degree distributions
</h2><span id='topic+degree.dists'></span>

<h3>Description</h3>

<p>Calculates degree distribution probability density.  By default calculates an uncorrelated (random) density for a given degree.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
degree.dists(d, exp.lambda = 3/2, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="degree.dists_+3A_d">d</code></td>
<td>

<p>degree
</p>
</td></tr>
<tr><td><code id="degree.dists_+3A_exp.lambda">exp.lambda</code></td>
<td>

<p>if not NULL, allows specification of chaotic <code>exp.lambda &lt; 3/2</code> and correlated stochastic processes <code>exp.lambda &lt; 3/2</code>.  
</p>
</td></tr>
<tr><td><code id="degree.dists_+3A_normalize">normalize</code></td>
<td>

<p>ensures that sum of demsities = 1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general <code class="reqn">f(d) = \exp(-\lambda d)</code> where <code class="reqn">d</code> is the degree. For random degree distributions, <code class="reqn">\lambda = \log(3/2)</code>.
</p>


<h3>Value</h3>

<p>Returns a density plot for a degree.
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+degree.distribution">degree.distribution</a></code>, <code><a href="#topic+plot_degree.dist">plot_degree.dist</a></code>.
</p>

<hr>
<h2 id='delete.arcs.pa'>
Delete arcs based on presence absence data 
</h2><span id='topic+delete.arcs.pa'></span>

<h3>Description</h3>

<p>Create a new graph after deleting stream graph arcs based on presence/absence data, e.g., data based on outcomes from STIC (Stream Temperature, Intermittency, and Conductivity) loggers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
delete.arcs.pa(G, pa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete.arcs.pa_+3A_g">G</code></td>
<td>
<p>A graph object of class &quot;igraph&quot;, see <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="delete.arcs.pa_+3A_pa">pa</code></td>
<td>

<p>A vector of binary = 0,1 values indicating the absence or presence of arcs from <code>E(G)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <em>igraph</em> graph object missing the arcs indicated with 0 in <code>pa</code>.</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+delete.edges">delete.edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- graph_from_literal(a--+b--+c--+d--+e)
delete.arcs.pa(G, c(0,0,1,1)) 
</code></pre>

<hr>
<h2 id='delete.nodes.pa'>
Delete nodes based on presence absence data 
</h2><span id='topic+delete.nodes.pa'></span>

<h3>Description</h3>

<p>Create a new graph after deleting stream graph nodes based on presence/absence data, e.g., data based on outcomes from STIC (Stream Temperature, Intermittency, and Conductivity) loggers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
delete.nodes.pa(G, pa, na.response = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete.nodes.pa_+3A_g">G</code></td>
<td>
<p>A graph object of class &quot;igraph&quot;, see <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="delete.nodes.pa_+3A_pa">pa</code></td>
<td>

<p>A vector of binary = 0,1 values indicating the absence or presence of nodes from <code>V(G)</code>. Adding a names attribute to <code>pa</code> allows checking of the correspondence of the order of node names in <code>G</code> and <code>pa</code>.  
</p>
</td></tr>
<tr><td><code id="delete.nodes.pa_+3A_na.response">na.response</code></td>
<td>

<p>One of <code>"none"</code>, <code>"treat.as.0"</code>, or <code>"treat.as.1"</code> (see Details).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A perennial problem with STIC (Stream Temperature, Intermittency, and Conductivity) sensors is the presence of missing data.  If <code>na.response = "none"</code> and NAs exist then the waring message <code>"NAs in data need to be addressed. NAs converted 0."</code> is printed.  One can also choose <code>na.response = "treat.as.0"</code> or <code>na.response = "treat.as.1"</code> which converts NAs to zeroes or ones.  Clearly, none of these draconian approaches is optimal.  Thus, if NAs occur, an attribute is added to the output graph object returned by the function, which lists the nodes with missing data. This attribute can be obtained with <code>out$NA.vertices</code> where <code>out &lt;- delete.nodes.pa(...)</code>, see Examples below.  An alternative is to use a classification algorithm for imputation e.g., <code><a href="#topic+STIC.RFimpute">STIC.RFimpute</a></code>, which uses <code>missForest::missForest</code>. 
</p>


<h3>Value</h3>

<p>Returns a <em>igraph</em> graph object, missing the nodes indicated with 0 in <code>pa</code>.</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+delete.vertices">delete.vertices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- graph_from_literal(a--+b--+c--+d--+e)
delete.nodes.pa(G, c(0,0,1,1,1)) 
# delete.nodes.pa(G, c(0,0,NA,1,1)) # gives warning and converts NA to 0 
d &lt;- delete.nodes.pa(G, c(0,0,NA,1,1), "treat.as.0")
d
d$NA.vertices

</code></pre>

<hr>
<h2 id='dinvbeta'>
Inverse Beta Distribution
</h2><span id='topic+dinvbeta'></span><span id='topic+pinvbeta'></span><span id='topic+rinvbeta'></span>

<h3>Description</h3>

<p>Calculates density (<code>dinvbeta</code>), lower-tailed probability (<code>pinvbeta</code>) and obtains random outcomes (<code>rinvbeta</code>) for an inverse beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvbeta(x, alpha, beta)
pinvbeta(x, alpha, beta)
rinvbeta(n, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dinvbeta_+3A_x">x</code></td>
<td>

<p>Quantile vector or scalar at which to evaluate density or probability.
</p>
</td></tr>
<tr><td><code id="dinvbeta_+3A_alpha">alpha</code></td>
<td>

<p>Alpha parameter
</p>
</td></tr>
<tr><td><code id="dinvbeta_+3A_beta">beta</code></td>
<td>

<p>Beta parameter
</p>
</td></tr>
<tr><td><code id="dinvbeta_+3A_n">n</code></td>
<td>

<p>Number of random outcomes to be generated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns density, probability, and random outcomes for an inverse beta distribution.
</p>


<h3>Author(s)</h3>

<p>Ken Aho and Dwayne Derryberry
</p>


<h3>See Also</h3>

<p>See Also <code><a href="stats.html#topic+dbeta">dbeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dinvbeta(1,1,1)
pinvbeta(1,1,1)
rinvbeta(1,1,1)
</code></pre>

<hr>
<h2 id='efficiency'>Local and global efficiency
</h2><span id='topic+efficiency.matrix'></span><span id='topic+avg.efficiency'></span><span id='topic+global.efficiency'></span>

<h3>Description</h3>

<p>Efficiency is the reciprocal of internodal distance.  Thus, the efficiency beween nodes <em>i</em> and <em>j</em> is defined as <code class="reqn">e_{i,j} = \frac{1}{d_{i,j}}</code> where <code class="reqn">d_{i,j}</code> denotes the distance between nodes <em>i</em> and <em>j</em> for all <code class="reqn">i \neq j</code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency.matrix(G, mode = "in")

avg.efficiency(G, mode = "in")

global.efficiency(G, mode = "in")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efficiency_+3A_g">G</code></td>
<td>

<p>Graph object of class &quot;igraph&quot;.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="efficiency_+3A_mode">mode</code></td>
<td>

<p>One of <code>"in"</code> or <code>"out"</code>.  The former considers in-path efficiencies, whereas the latter considers out-paths.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>efficiency.matrix</code> calculates an efficiency matrix whose elements correspond to elements in the graph distance matrix. The function <code>avg.efficiency</code> calculates average efficiencies of nodes to all other nodes, thus providing a local measure of graph connectedness. The function <code>global.efficiency</code> calculates the mean of the of all pairwise efficiencies, thus providing a global measure of graph connectedness. For all three functions, reciprocals of infinite distances are taken to be zero.   
</p>


<h3>Value</h3>

<p>The function <code>efficiency.matrix</code> returns a reciprocal distance matrix for nodes in <code>G</code>. The function <code>avg.efficiency</code> treats efficiency as a local measure, and thus returns a vector whose entries are average efficiencies for each node.  The function <code>global.efficiency</code> returns a scalar (the mean of the reciprocal distance matrix).</p>


<h3>Author(s)</h3>

<p>Ken Aho.  Gabor Csardi wrote the function <code><a href="igraph.html#topic+distances">distances</a></code> in <em>igraph</em>.
</p>


<h3>References</h3>

<p>Ek, B., VerSchneider, C., &amp; Narayan, D. A. (2015). Global efficiency of graphs. <em>AKCE International Journal of Graphs and Combinatorics, 12</em>(1), 1-13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kon_full &lt;- streamDAGs("konza_full")
efficiency.matrix(kon_full)
avg.efficiency(kon_full)
global.efficiency(kon_full)
</code></pre>

<hr>
<h2 id='get.AIMS.data'>
Loads AIMS dataset associated with a particular AIMS graph
</h2><span id='topic+get.AIMS.data'></span>

<h3>Description</h3>

<p>The function creates a list of associated dataframes for particular AIMS graph objects. Currently these include one of more of <code>$coords</code> <code>$arc.length</code>
<code>$node.pa</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.AIMS.data(graph = "mur_full", supress.message = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.AIMS.data_+3A_graph">graph</code></td>
<td>

<p>A character string defining one of the AIMS graphs codified in <code><a href="#topic+streamDAGs">streamDAGs</a>.</code>
</p>
</td></tr>
<tr><td><code id="get.AIMS.data_+3A_supress.message">supress.message</code></td>
<td>

<p>Logical. Supress message detailing objects created by function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function radically simplifies code gymnastics required to obtain datasets associated AIMS graphs (see, for instance, Detaails in <code><a href="#topic+streamDAGs">streamDAGs</a></code>).</p>


<h3>Value</h3>

<p>Returns a list containg up to three dataframes: 
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>Spatial coordinates and other information from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code>.</p>
</td></tr>
<tr><td><code>arc.length</code></td>
<td>
<p>Lengths of network, generally in km.</p>
</td></tr>
<tr><td><code>node.pa</code></td>
<td>
<p>Presence(1)/absence(0) of surface water at the node.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+streamDAGs">streamDAGs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jd &lt;- get.AIMS.data("jd_full", TRUE)
head(jd$coords)
head(jd$arc.length)
head(jd$node.pa)
</code></pre>

<hr>
<h2 id='gj_coords16'>
Coordinates of nodes at Gibson Jack Creek, Idaho for a 2016 survey
</h2><span id='topic+gj_coords16'></span>

<h3>Description</h3>

<p>Latitudes and Longitudes of nodes established at Gibson Jack in 2016.  Datum: WGS 84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("gj_coords16")</code></pre>


<h3>Format</h3>

<p>A data frame with 124 observations on the following 3 variables.
</p>

<dl>
<dt><code>Object.ID</code></dt><dd><p>Node name</p>
</dd>
<dt><code>lat</code></dt><dd><p>Latitude</p>
</dd>
<dt><code>long</code></dt><dd><p>Longitude</p>
</dd>
</dl>


<hr>
<h2 id='gj_lengths'>
Lengths of Gibson Jack stream (arc) segments
</h2><span id='topic+gj_lengths'></span><span id='topic+gj_lengths_piezo_full'></span>

<h3>Description</h3>

<p>Lengths of stream (arc) segments from the Gibson Jack watershed in southeast Idaho (outlet coordinates: 42.767180<code class="reqn">^\circ</code>N, 112.480240<code class="reqn">^\circ</code>W).  The dataframe <code>gj_lengths</code> contains arc lengths for a network including STICs, but excluding piezometers. The dataframe <code>gj_lengths_piezo_full</code> contains arc lengths for a network that includes both STICs and piezometers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("gj_lengths")</code></pre>


<h3>Format</h3>

<p>A data frame with 28 observations <code>jd_lengths</code> or 35 observations <code>jd_lengths_piezo_full</code> on the following 2 variables.
</p>

<dl>
<dt><code>Arcs</code></dt><dd><p>Arc names, arrows directionally connect nodes.</p>
</dd>
<dt><code>Lengths</code></dt><dd><p>Stream segment (arc) length in kilometers.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Maggie Kraft
</p>

<hr>
<h2 id='gj_node_pres_abs'>
Stream node presence absence data for Gibson Jack Idaho 
</h2><span id='topic+gj_node_pres_abs'></span>

<h3>Description</h3>

<p>Stream node surface water presence absence data from Gibson Jack, Idaho (outlet coordinates: 42.767180<code class="reqn">^\circ</code>N, 112.480240<code class="reqn">^\circ</code>W).  Outcomes based on STIC (Stream Temperature, Intermittency, and Conductivity) sensors, resulting in binary observations for 29 nodes at 15 minutes intervals over three years.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("gj_node_pres_abs")</code></pre>


<h3>Format</h3>

<p>A data frame with 55109 observations on the following 36 variables.
</p>

<dl>
<dt><code>datetime</code></dt><dd><p>a POSIXlt vector</p>
</dd>
<dt><code>GJ16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ19</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ20</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ23</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ22</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ25</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ21</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GPZ02</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GPZ03</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GPZ04</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GPZ05</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GPZ06</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GPZ07</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GSS01</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Maggie Kraft
</p>

<hr>
<h2 id='gj_node_pres_abs16'>
Stream node presence absence data for Gibson Jack Cr. Idaho, for a 2016 survey 
</h2><span id='topic+gj_node_pres_abs16'></span>

<h3>Description</h3>

<p>Streamflow presence and absence data for each node location collected by manual observation November 6, 2016, May 6, 2017, and August 14, 2017.  Note, a longer dataset 2021-2023, gathered by the AIMS team at fewer points, is available for Gibson Jack under the name <code>gj_node_pres_abs</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("gj_node_pres_abs16")</code></pre>


<h3>Format</h3>

<p>A data frame with 3 observations on the following 125 variables.
</p>

<dl>
<dt><code>Date</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>GJ_ST1_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_ST1_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_ST1_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_ST1_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_2800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_2600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_2400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_2200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_2000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_1800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_1600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_1400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_1200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_SF_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_WF_FH</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_WF_000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT1_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_1600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_1400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_1200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT2_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT3_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT3_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT4_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT4_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT4_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NT4_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3750</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3000_CU</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_3000_CD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2800_CU</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2800_CD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2400_CU</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2400_CD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_2000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1060_CU</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1060_CD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_NF_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT2_0900</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT2_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT2_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT2_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT2_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT2_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1650</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1550</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1450</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1350</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1300</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1250</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1150</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1100</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1050</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0950</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0900</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0850</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0750</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0700</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0650</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0550</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0500</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0450</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0350</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0300</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0250</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0150</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0100</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0050</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MT1_0000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_3000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_2800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_2600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_2400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_2200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_2000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_1800_CU</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_1800_CD</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_1600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_1400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_1200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_1000</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_0800</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_0600</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_0400</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_0200</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>GJ_MS_0000</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>


<hr>
<h2 id='global.summary'>
Global Summary
</h2><span id='topic+global.summary'></span>

<h3>Description</h3>

<p>This function calculates useful DAG global summaries including size, diameter, number of paths to sink, mean path length, mean alpha centrality, mean PageRank centrality, graph centralization, Strahler order, Shreve order, the Randic index, the first Zagreb Index, the second Zagreb index, atom-bond connectivity, the geometric-arithmatic index, the harmonic index, the Harary index, global efficiency, the assortativity correlation (+, -), and the assortativity correlation (+, +).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global.summary(G, which = "all", sink, mode = "in", inf.paths = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global.summary_+3A_g">G</code></td>
<td>
<p>graph object of class &quot;igraph&quot;.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>. </p>
</td></tr>
<tr><td><code id="global.summary_+3A_which">which</code></td>
<td>
<p>Which metric to use.  Currently one of <code>"all"</code>, <code>"size"</code>, <code>"diameter"</code>, <code>"graph.order"</code>, <code>"n.sources"</code>, <code>"n.paths.to.sink"</code>, <code>"sink.path.len.summary"</code>, <code>"deg.summary"</code>, <code>"avg.alpha.cent"</code>, <code>"shreve.num"</code>, <code>"strahler.num"</code>, <code>"fst.zagreb"</code>, <code>"scd.zagreb"</code>,
<code>"ABC"</code>, <code>"harary"</code>, <code>"global.efficiency"</code>, <code>"assort.in.out"</code>, <code>"assort.in.in"</code>.</p>
</td></tr> 
<tr><td><code id="global.summary_+3A_sink">sink</code></td>
<td>
<p>sink node from graph object <code>G</code>.</p>
</td></tr>
<tr><td><code id="global.summary_+3A_mode">mode</code></td>
<td>
<p>Type of degree used.  One of <code>"in"</code> or <code>"out"</code>.</p>
</td></tr>
<tr><td><code id="global.summary_+3A_inf.paths">inf.paths</code></td>
<td>
<p>logical, consider infinite paths?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple global graph measures of complexivity and/or connectivity of a stream DAG include <em>size</em>, <em>diameter</em>, and number of paths to a sink. The <em>size</em> is equal to the number of arcs in the stream network. The <em>diameter</em> equals the length of the longest path, i.e., the <em>height</em> of the sink, and <em>in eccentricity</em> of the sink. The number of paths to the sink is equivalent to the number of nodes from which the sink node is reachable, which will be <code class="reqn">n-1</code> for a fully active stream. For more information on <code class="reqn">I(D)</code> metrics see <code><a href="#topic+I.D">I.D</a></code>.  Links describing other metrics are provided below.
</p>


<h3>Value</h3>

<p>Returns a vector of global graph measures for <code>G</code>.</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+alpha_centrality">alpha_centrality</a></code> and other underlying functions.
</p>


<h3>References</h3>

<p>Kunkler, S. J., LaMar, M. D., Kincaid, R. K., &amp; Phillips, D. (2013). Algorithm and complexity for a network assortativity measure. arXiv Preprint <em>arXiv:1307.0905</em>.
</p>
<p>Das, K. C., Gutman, I., &amp; Furtula, B. (2011). On atom-bond connectivity index. <em>Chemical Physics Letters, 511</em>(4-6), 452-454.
</p>
<p>Li, X., &amp; Shi, Y. (2008). A survey on the randic index. <em>MATCH Commun. Math. Comput. Chem, 59</em>(1), 127-156.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+alpha_centrality">alpha_centrality</a></code>, 
<code><a href="#topic+I.D">I.D</a></code>, <code><a href="#topic+spath.lengths">spath.lengths</a></code>, <code><a href="#topic+n.sources">n.sources</a></code>, <code><a href="#topic+stream.order">stream.order</a></code>, <code><a href="#topic+harary">harary</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_a &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, 
e --+ j, j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, 
l --+ m, m --+ n,  n --+ o)

global.summary(network_a, sink ="o")
</code></pre>

<hr>
<h2 id='harary'>
Harary Index
</h2><span id='topic+harary'></span>

<h3>Description</h3>

<p>Computes the Harary global metric for a stream DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harary(G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harary_+3A_g">G</code></td>
<td>
<p>Graph object of class <code>igraph</code>. See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Harary index is computed as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}\sum_i^m\sum_j^m (RD)_{ij}</code>
</p>

<p>where <code class="reqn">(RD)_{ij}</code> is the reciprocal of the <code class="reqn">ij</code>th element of the graph distance matrix.  Reciprocals of infinite values in the distance matrix are taken to be zero.  Users should be aware that the graph object <code>G</code> is assumed to be DAG, and that distances are based on in-paths.   
</p>


<h3>Value</h3>

<p>Returns a scalar: the global Harary index.</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wote <code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>References</h3>

<p>Plavsic, D., Nikolic, S., Trinajstic, N., &amp; Mihalic, Z. (1993). On the Harary index for the characterization of chemical graphs. Journal of Mathematical Chemistry, 12(1), 235-250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>harary(streamDAGs("konza_full"))
</code></pre>

<hr>
<h2 id='I.D'>
Generalized DAG indices
</h2><span id='topic+I.D'></span>

<h3>Description</h3>

<p>Calculates global generalized topopological indices for a digraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
I.D(G, mode = "gen.rand", alpha = -1/2, mult = FALSE, degrees = "out.in")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="I.D_+3A_g">G</code></td>
<td>

<p>Graph object of class.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="I.D_+3A_mode">mode</code></td>
<td>

<p>One of <code>"gen.rand"</code>,<code>"gen.sum.con"</code>, <code>"ABC"</code>, <code>"GA"</code>, <code>"harm"</code>, <code>"aug.rand"</code>.
</p>
</td></tr>
<tr><td><code id="I.D_+3A_alpha">alpha</code></td>
<td>

<p>Exponent value for forms of omega with alpha exponent.
</p>
</td></tr>
<tr><td><code id="I.D_+3A_mult">mult</code></td>
<td>

<p>Logical if <code>TRUE</code> use experimental multiplicative measures. 
</p>
</td></tr>
<tr><td><code id="I.D_+3A_degrees">degrees</code></td>
<td>

<p>Degree designations for the arc <code class="reqn">\vec{uv}</code>.  One of <code>"out.in"</code>, <code>"out.out"</code>, <code>"in.out"</code>, <code>"in.in"</code>. See Details below. The default designation, <code>"out.in"</code>, is strongly reccomended for stream DAGs.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an arc <code class="reqn">a={\overrightarrow{uv}}</code>, <code class="reqn">a \in A</code>, we denote the out degree of <code class="reqn">u</code> as <code class="reqn">d_u^+</code>, and the in degree of <code class="reqn">v</code> as <code class="reqn">d_v^-</code>. Now let <code class="reqn">I(D)</code> represent a generalized topopological index for a digraph, <code class="reqn">D</code> (cf. Deng et al., 2021) that depends on <code class="reqn">d_u^+</code> and <code class="reqn">d_v^-</code>:
</p>
<p style="text-align: center;"><code class="reqn">I(D)=1/2 \sum_{uv \in A}\omega(d_u^+,d_v^-)</code>
</p>

<p>Six basic configurations for <code class="reqn">I(D)</code> can be recognized:
</p>
<p>1.	If <code class="reqn">\omega(x,y)=(xy)^\alpha</code>, for <code class="reqn">\alpha \neq 0</code>, then <code class="reqn">I(D)</code> is the <em>general directed Randic index</em> (Kincaid et al., 2016) for <code class="reqn">D</code>. Specific variants include the <em>Randic index</em> <code class="reqn">(\alpha =-1/2)</code>, the <em>second Zagreb index</em> <code class="reqn">(\alpha =1)</code> and the <em>second modified Zagreb index</em> <code class="reqn">(\alpha =-1)</code> (Anthony &amp; Marr, 2021).
</p>
<p>2.	If <code class="reqn">\omega(x,y)=(x+y)^\alpha</code>, then <code class="reqn">I(D)</code> is the <em>general sum-connectivity index</em> for <em>D</em> (Deng et al., 2021). Further, if <code class="reqn">\omega(x,y)=2(x+y)^\alpha</code>, then <code class="reqn">I(D)</code> is the <em>sum connectivity</em> (Zhou &amp; Trinajstic, 2009), and the directed <em>first Zagreb index</em> (Anthony &amp; Marr, 2021) for <code class="reqn">\alpha =-1/2</code> and <code class="reqn">\alpha=1</code>, respectively .
</p>
<p>3.	If <code class="reqn">\omega(x,y)=\sqrt{((x+y-2)/xy)}</code>, then <code class="reqn">I(D)</code> is the <em>atom bond connectivity</em> of <em>D</em> (Estrada et al., 1998).
</p>
<p>4.	If <code class="reqn">\omega(x,y)=\sqrt{xy}/(1/2(x+y))</code>, then <code class="reqn">I(D)</code> is the <em>geometric-arithmetic index</em> for <code class="reqn">D</code> (Vukicevic &amp; Furtula, 2009).
</p>
<p>5. If <code class="reqn">\omega(x,y)=2/(x+y)</code>, then <code class="reqn">I(D)</code> is the <em>harmonic index</em> of <code class="reqn">D</code> (Favaron et al., 1993).
</p>
<p>6. If <code class="reqn">\omega(x,y)=\left(\frac{xy}{x+y-2}\right)^3</code>, then <code class="reqn">I(D)</code> is the <em>augmented Randic index</em> of <code class="reqn">D</code> (Furtula et al. 2010).  This index is not reccomended for stream DAGs as it will contained undefined terms for any network with unbranched paths.
</p>
<p>More options are possible under the generalization of Kincaid (1996).  Specifically, for an arc <code class="reqn">a=\vec{uv},a\in A</code>, let <code class="reqn">\gamma,\tau\in-,+</code> index the degree type: <code class="reqn">-= in, +=out</code>.  Then, four combinations of <code class="reqn">d_u^\gamma, d_v^\tau</code> can occur, resulting in four different versions of each <code class="reqn">I(D)</code> metric described above.  These combinations are: <code class="reqn">d_u^+,d_v^- </code> (as shown above), <code class="reqn">d_u^+,d_v^+</code>,  <code class="reqn">d_u^-,d_v^-</code>, and <code class="reqn">d_u^-,d_v^+</code>.  The default <code class="reqn">d_u^+,d_v^-</code> is strongly reccomended for stream DAGs over other variants.
</p>


<h3>Value</h3>

<p>Index values for a DAG
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+degree">degree</a></code>
</p>


<h3>References</h3>

<p>Anthony, B. M., &amp; Marr, A. M. (2021). Directed zagreb indices. <em>Graphs and Combinatorial Optimization: From Theory to Applications: CTW 2020 Proceedings</em>, 181-193.
</p>
<p>Deng, H., Yang, J., Tang, Z., Yang, J., &amp; You, M. (2021). On the vertex-degree based invariants of digraphs. arXiv Preprint <em>arXiv:2104.14742</em>.
</p>
<p>Estrada, E., Torres, L., Rodriguez, L., &amp; Gutman, I. (1998). <em>An atom-bond connectivity index: Modelling the enthalpy of formation of alkanes</em>. NISCAIR-CSIR, India.
</p>
<p>Favaron, O., Maheo, M., &amp; Sacle, J.-F. (1993). Some eigenvalue properties in graphs (conjectures of graffitii). <em>Discrete Mathematics, 111</em>(1-3), 197-220.
</p>
<p>Furtula, B., Graovac, A., &amp; Vukicevic, D. (2010). Augmented Zagreb index. <em>Journal of Mathematical Chemistry, 48</em>(2), 370-380.
</p>
<p>Kincaid, R. K., Kunkler, S. J., Lamar, M. D., &amp; Phillips, D. J. (2016). Algorithms and complexity results for finding graphs with extremal Randic index. Networks, 67(4), 338-347.
</p>
<p>Vukicevic, D., &amp; Furtula, B. (2009). Topological index based on the ratios of geometrical and arithmetical means of end-vertex degrees of edges. <em>Journal of Mathematical Chemistry, 46</em>(4), 1369-1376.
</p>
<p>Zhou, B., &amp; Trinajstic, N. (2009). On a novel connectivity index. <em>Journal of Mathematical Chemistry</em>, 46(4), 1252-1270.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+degree">degree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_a &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, 
e --+ j, j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, 
l --+ m, m --+ n,  n --+ o)
I.D(network_a)
</code></pre>

<hr>
<h2 id='ICSL'>
Integral connectivity scale length (ICSL)
</h2><span id='topic+ICSL'></span>

<h3>Description</h3>

<p>Integral connectivity scale lengths (ICSL, Western et al. 2013) is the average distance between wet locations using either (1) Euclidean distance or (2) topographically-defined hydrologic distance, e.g., instream hydrologic distance, subsurface distance (Ali and Roy 2009) and outlet distance, in which connected saturated paths must reach the catchment outlet. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSL(G, coords = NULL, names = NULL, lengths = NULL, 
dist.matrix = NULL, show.dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICSL_+3A_g">G</code></td>
<td>

<p>A graph object of class &quot;igraph&quot;, see <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code> 
</p>
</td></tr>
<tr><td><code id="ICSL_+3A_coords">coords</code></td>
<td>

<p>Spatial coordinates to allow computation of nodal Euclidean distances
</p>
</td></tr>
<tr><td><code id="ICSL_+3A_names">names</code></td>
<td>

<p>Nodal names
</p>
</td></tr>
<tr><td><code id="ICSL_+3A_lengths">lengths</code></td>
<td>

<p>Stream arc lengths or hydrologic arc lengths 
</p>
</td></tr>
<tr><td><code id="ICSL_+3A_show.dist">show.dist</code></td>
<td>

<p>Logical.  Show distance matrix?
</p>
</td></tr>
<tr><td><code id="ICSL_+3A_dist.matrix">dist.matrix</code></td>
<td>

<p>An optional distance matrix, potentially providing non-Euclidean node distances (e.g., node subsurface distance, etc.). Distance matrix <code>Labels</code> in <code>dist.matrix</code> must be analogous to those used in <code>G</code>. Note that dimensions in <code>dist.matrix</code> can be larger than the number of nodes in <code>G</code> if, for instance, <code>dist.matrix</code> represents distances of the complete wetted network and <code>G</code> is a subgraph of the complete wetted network after drying.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes either: 
1) the average Euclidean distance of connected nodal locations as defined in <code>G</code>, if <code>coords</code> are provided, 2) if <code>dist.matrix</code> is provided, the average nodal distances of a distance matrix provided in <code>dist.matrix</code> for nodes that remain in <code>G</code>, or 3) the instream distances of connected nodal locations if stream lenghts are provided in <code>lengths</code>.  For 3), the <code>length</code> vector will need to be trimmed as arcs disappear within intermittent streams (see Examples).
</p>


<h3>Value</h3>

<p>Returns a global distance scalar.  See <b>Details</b>.</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote underlying functions <code><a href="igraph.html#topic+distances">distances</a></code> and <code><a href="igraph.html#topic+E">E</a></code> 
</p>


<h3>References</h3>

<p>Ali, G. A., &amp; Roy, A. G. (2010). Shopping for hydrologically representative connectivity metrics in a humid temperate forested catchment. <em>Water Resources Research, 46</em>(12).
</p>
<p>Western, A. W., Bloschl, G., &amp; Grayson, R. B. (2001). Toward capturing hydrologically significant connectivity in spatial patterns. <em>Water Resources Research, 37</em>(1), 83-97.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>murphy_spring &lt;- graph_from_literal(IN_N --+ M1984 --+ M1909, IN_S --+ M1993,  
M1993 --+ M1951 --+ M1909 --+ M1799 --+ M1719 --+ M1653 --+ M1572 --+ M1452, 
M1452 --+ M1377 --+ M1254 --+ M1166 --+ M1121 --+ M1036 --+ M918 --+ M823, 
M823 --+ M759 --+ M716 --+ M624 --+ M523 --+ M454 --+ M380 --+ M233 --+ M153, 
M153 --+ M91 --+ OUT)

#---- ICSL based on nodal Euclidean distances ----#
data(mur_coords)
ICSL(murphy_spring, coords = mur_coords[,2:3], names = mur_coords[,1])

#---- ICSL based on in-stream length data ----#
data(mur_lengths)
ICSL(murphy_spring, lengths = mur_lengths[,2], names = mur_coords[,1])

# or, simply
ms &lt;- murphy_spring
E(ms)$weight &lt;- mur_lengths[,2]
ICSL(ms)

# Arcs 1 and 3 dry
B &lt;- graph_from_literal(IN_N, M1984, IN_S --+ M1993 --+ M1951 --+ M1909, 
M1909 --+ M1799 --+ M1719 --+ M1653 --+ M1572 --+ M1452 --+ M1377 --+ M1254,
M1254 --+ M1166 --+ M1121 --+ M1036 --+ M918 --+ M823 --+ M759 --+ M716, 
M716 --+ M624 --+ M523 --+ M454 --+ M380 --+ M233 --+ M153 --+ M91 --+ OUT)
ICSL(B, lengths = mur_lengths[,2][-c(1,3)], show.dist = TRUE)
</code></pre>

<hr>
<h2 id='imp.closeness'>
Improved Closeness Centrality
</h2><span id='topic+imp.closeness'></span>

<h3>Description</h3>

<p>Calculates improved closeness centrality of individual nodes in a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp.closeness(G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imp.closeness_+3A_g">G</code></td>
<td>

<p>Graph object of class &quot;igraph&quot;, see See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Improved closeness centrality</em> (Beauchamp, 1965) was developed for weakly connected or disconnected digraphs.   The measure is based on the reciprocal of nodal shortest path distances from the <em>j</em>th node to the <em>k</em>th node, <code class="reqn">1/\delta_{j,k}</code>.  For the <em>j</em>th node this is:
</p>
<p style="text-align: center;"><code class="reqn">H_j=(n-1) \sum_{j \neq k} 1/\delta_{j,k}</code>
</p>

<p>where, for disconnected nodes, the reciprocal distance <code class="reqn">1/\infty</code> is taken to be zero.
</p>


<h3>Value</h3>

<p>Improved closeness centrality of a node
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>References</h3>

<p>Beauchamp, M. A. (1965). An improved index of centrality. <em>Behavioral Science, 10</em>(2), 161-163.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_a &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, 
e --+ j, j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, 
l --+ m, m --+ n,  n --+ o)
imp.closeness(network_a)

</code></pre>

<hr>
<h2 id='isle'>
Detects and defines islands in a streamDAG
</h2><span id='topic+isle'></span>

<h3>Description</h3>

<p>The function was written primarilly to recognize DAG islands to allow correct implementation of the function <code><a href="#topic+stream.order">stream.order</a></code> and is still early in its development.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
isle(G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isle_+3A_g">G</code></td>
<td>

<p>Graph object of class <code>igraph</code>. See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently allows detection of simple island structures (those that don't contain sub-islands).  One of the output objects from the function is a new graph object with island nodes into a single node(s). 
</p>


<h3>Value</h3>

<p>Output consists of the following:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>Logical indicating whether or not <code>G</code> contains islands.</p>
</td></tr>
<tr><td><code>island</code></td>
<td>
<p>List of islands with their nodal components</p>
</td></tr>
<tr><td><code>input.id</code></td>
<td>
<p>Neighboring node(s) directly upstream from island(s).</p>
</td></tr>
<tr><td><code>output.id</code></td>
<td>
<p>Neighboring node(s) directly downstream from island(s).</p>
</td></tr>
<tr><td><code>new.graph</code></td>
<td>
<p>New graph object created from <code>G</code> in which nodes constituing islands a combined into a single node</p>
</td></tr>
<tr><td><code>island.names</code></td>
<td>
<p>Names of island nodes created in new output graph (that combines nodes constituing islands into a single node).  Follows the naming system <code>"i-1"</code>, <code>"i-2"</code>, etc.</p>
</td></tr>
<tr><td><code>splits</code></td>
<td>
<p>The number of islands detected.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stream.order">stream.order</a></code>, <code><a href="igraph.html#topic+delete.vertices">delete.vertices</a></code>, <code><a href="igraph.html#topic+add.vertices">add.vertices</a></code>, <code><a href="igraph.html#topic+add.edges">add.edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- graph_from_literal(a --+ c --+ e, b --+ d --+ e --+ f --+ p, g --+ i --+ j --+ m, 
i --+ k --+ m, m --+ n --+ o --+ p, h --+ l --+ n, p --+ q --+ r)
plot(G)
isle(G)
</code></pre>

<hr>
<h2 id='jd_lengths'>
Lengths of Johnson Draw stream (arc) segments
</h2><span id='topic+jd_lengths'></span><span id='topic+jd_lengths_full'></span><span id='topic+jd_lengths_2023'></span>

<h3>Description</h3>

<p>Lengths of stream (arc) segments from Johnson Draw in southwest Idaho (outlet coordinates: 43.12256<code class="reqn">^\circ</code>N, 116.77630<code class="reqn">^\circ</code>W). The dataframe <code>jd_lengths</code> contains segment lengths in the absence of piezos [nodes are currently defined by STIC (Stream Temperature, Intermittency, and Conductivity) locations only] and thus correspond to the network in <code>streamDAGs("jd_full")</code>. The dataframe <code>jd_lengths_full</code> contains segment lengths for node designated by both STICs and piezos. A corresponding network that includes piezos is depicted by <code>streamDAGs("jd_piezo_full")</code>. The dataframe <code>jd_lengths_2023</code> contains segment lengths for node designated by both STICs, piezos <em>and</em> additional STC sites established in 2023. A correspding network can be obtained with <code>streamDAGs("jd_piezo_full_2023")</code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("jd_lengths")</code></pre>


<h3>Format</h3>

<p>A data frame with observations on the following 2 variables.
</p>

<dl>
<dt><code>Arcs</code></dt><dd><p>Arc names, arrows directionally connect nodes.</p>
</dd>
<dt><code>Lengths</code></dt><dd><p>Lengths in in km.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Arya Legg, Maggie Kraft
</p>

<hr>
<h2 id='jd_node_pres_abs'>
Stream node presence absence data for Johnson Draw Idaho 
</h2><span id='topic+jd_node_pres_abs'></span>

<h3>Description</h3>

<p>Stream node surface water presence absence data from 2022-2023 for the Johnson Draw watershed in southwest Idaho (outlet coordinates: 43.12256<code class="reqn">^\circ</code>N, 116.77630<code class="reqn">^\circ</code>W).  Outcomes are based on STIC sensors and piezometers, resulting in binary observations for 35 nodes (28 STICs and 7 piezometers) at 15 minutes intervals over three years. JD21, JD22, JD23, JD25, JD26, JD27, JD28 were added in 2023 for the AIMS experiment.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("jd_node_pres_abs")</code></pre>


<h3>Format</h3>

<p>A data frame with 51653 observations on the following 36 variables.
</p>

<dl>
<dt><code>datetime</code></dt><dd><p>a POSIXlt</p>
</dd>
<dt><code>JD5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>C2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD19</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD20</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JSS01</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JPZ02</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JPZ03</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JPZ04</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JPZ05</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JPZ06</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JPZ07</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD21</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD22</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD23</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD25</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD26</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD27</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>JD28</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Maggie Kraft
</p>

<hr>
<h2 id='kon_coords'>
Coordinates of nodes in the Konza Praire dataset
</h2><span id='topic+kon_coords'></span>

<h3>Description</h3>

<p>Coordinates (in Lat/Long) of nodes established at the Konza Prairie stream network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("kon_coords")</code></pre>


<h3>Format</h3>

<p>A data frame with 46 observations on the following 3 variables.
</p>

<dl>
<dt><code>Object.ID</code></dt><dd><p>Node name</p>
</dd>
<dt><code>lat</code></dt><dd><p>Latitude</p>
</dd>
<dt><code>long</code></dt><dd><p>Longitude</p>
</dd>
</dl>


<hr>
<h2 id='kon_lengths'>
Lengths of Murphy Cr. stream (arc) segments
</h2><span id='topic+kon_lengths'></span>

<h3>Description</h3>

<p>Lengths of Murphy Cr. stream (arc) segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("kon_lengths")</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 2 variables.
</p>

<dl>
<dt><code>Arcs</code></dt><dd><p>Arc names, arrows directionally connect nodes.</p>
</dd>
<dt><code>Lengths</code></dt><dd><p>Lengths in meters</p>
</dd>
</dl>



<h3>Source</h3>

<p>Rob Ramos
</p>

<hr>
<h2 id='local.summary'>
local (nodal) summaries of a DAG
</h2><span id='topic+local.summary'></span>

<h3>Description</h3>

<p>Obtains local (nodal) summaries from a DAG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
local.summary(G, metric = "all", mode = "in")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local.summary_+3A_g">G</code></td>
<td>

<p>Graph of class &quot;igraph&quot;.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="local.summary_+3A_metric">metric</code></td>
<td>
<p>One of <code>"all"</code>, <code>"alpha.cent"</code>, <code>"imp.closeness"</code>, <code>"n.paths"</code>, <code>"n.nodes"</code>, <code>"page.rank"</code>, <code>"path.len.summary"</code>, <code>"path.deg.summary"</code>, <code>"size.intact.in"</code>.  Partial matches allowed. 
</p>
</td></tr>
<tr><td><code id="local.summary_+3A_mode">mode</code></td>
<td>
<p>One of <code>"in"</code> or <code>"out"</code></p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Nodes are returned with values measuring the indegree, alpha centrality, PageRank centrality, improved closeness centrality, betweenness centrality, upstream network length, and upstream in-path length mean, variance, max (i.e., in-eccentricity), skew, kurtosis, and mean efficiency. 
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+degree">degree</a></code>, <code><a href="igraph.html#topic+page_rank">page_rank</a></code> and <code><a href="igraph.html#topic+alpha_centrality">alpha_centrality</a></code> functions.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+degree">degree</a></code>, <code><a href="igraph.html#topic+alpha_centrality">alpha_centrality</a></code>, <code><a href="igraph.html#topic+page_rank">page_rank</a></code>, <code><a href="igraph.html#topic+betweenness">betweenness</a></code>, 
<code><a href="#topic+imp.closeness">imp.closeness</a></code>,
<code><a href="asbio.html#topic+skew">skew</a></code>, <code><a href="asbio.html#topic+kurt">kurt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_a &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, 
e --+ j, j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, 
l --+ m, m --+ n,  n --+ o)
local.summary(network_a)
</code></pre>

<hr>
<h2 id='mur_arc_pres_abs'>
Stream segment presence absence data for Murphy Cr. Idaho 
</h2><span id='topic+mur_arc_pres_abs'></span>

<h3>Description</h3>

<p>Simulated multivariate Benroulli outcomes for 27 stream segments, based on their observed marginal probabilities for steam presence and covariance structures. &quot;M&quot;-labelling for nodes indicates &quot;meters above outlet&quot;.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mur_arc_pres_abs")</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 27 variables.
</p>

<dl>
<dt>&lsquo;<span class="samp">&#8288;IN_N--&gt;M1984&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1984--&gt;M1909&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1909--&gt;M1799&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;IN_S--&gt;M1993&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1993--&gt;M1951&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1951--&gt;M1909&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1799--&gt;M1719&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1719--&gt;M1653&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1653--&gt;M1572&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1572--&gt;M1452&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1452--&gt;M1377&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1377--&gt;M1254&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1254--&gt;M1166&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1166--&gt;M1121&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1121--&gt;M1036&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1036--&gt;M918&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M918--&gt;M823&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M823--&gt;M759&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M759--&gt;M716&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M716--&gt;M624&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M624--&gt;M523&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M523--&gt;M454&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M454--&gt;M380&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M380--&gt;M233&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M233--&gt;M153&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M153--&gt;M91&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M91--&gt;OUT&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
</dl>


<hr>
<h2 id='mur_coords'>
Coordinates of nodes at Murphy Ck. Idaho 
</h2><span id='topic+mur_coords'></span>

<h3>Description</h3>

<p>UTM coordinates (Zone 11T) and Latitudes and Longitudes of nodes established at Murphy Cr. Idaho.  Datum: WGS 84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mur_coords")</code></pre>


<h3>Format</h3>

<p>A data frame with 28 observations on the following 5 variables.
</p>

<dl>
<dt><code>Object.ID</code></dt><dd><p>Node name</p>
</dd>
<dt><code>E</code></dt><dd><p>UTM Easting</p>
</dd>
<dt><code>N</code></dt><dd><p>UTM Northing</p>
</dd>
<dt><code>lat</code></dt><dd><p>Latitude</p>
</dd>
<dt><code>long</code></dt><dd><p>Longitude</p>
</dd>
</dl>


<hr>
<h2 id='mur_lengths'>
Lengths of Murphy Cr. stream (arc) segments
</h2><span id='topic+mur_lengths'></span>

<h3>Description</h3>

<p>Lengths of Murphy Cr. stream (arc) segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mur_lengths")</code></pre>


<h3>Format</h3>

<p>A data frame with 27 observations on the following 2 variables.
</p>

<dl>
<dt><code>Arcs</code></dt><dd><p>Arc names, arrows directionally connect nodes.</p>
</dd>
<dt><code>Lengths</code></dt><dd><p>Stream segment (arc) length in meters. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Warix, S. R., Godsey, S. E., Lohse, K. A., &amp; Hale, R. L. (2021). Influence of groundwater and topography on stream drying in semi-arid headwater streams. Hydrological Processes, 35(5), e14185.
</p>

<hr>
<h2 id='mur_node_pres_abs'>
Stream node presence absence data for Murphy Cr. Idaho 
</h2><span id='topic+mur_node_pres_abs'></span>

<h3>Description</h3>

<p>A subset of stream node presence absence data from Warix et al. (2019) resulting in binary observations for 28 nodes at 2.5 hr intervals.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mur_node_pres_abs")</code></pre>


<h3>Format</h3>

<p>A data frame with 1163 observations on the following 29 variables.
</p>

<dl>
<dt><code>Datetime</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>IN_N</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1984</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1909</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>IN_S</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1993</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1951</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1799</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1719</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1653</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1572</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1452</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1377</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1254</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1166</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1121</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M1036</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M918</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M823</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M759</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M716</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M624</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M523</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M454</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M380</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M233</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M153</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>M91</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>OUT</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Warix, S. R., Godsey, S. E., Lohse, K. A., &amp; Hale, R. L. (2021). Influence of groundwater and topography on stream drying in semi-arid headwater streams. <em>Hydrological Processes, 35</em>(5), e14185.
</p>

<hr>
<h2 id='mur_seasons_arc_pa'>
Simulated seasonal arc presence absence data for Murphy Cr 
</h2><span id='topic+mur_seasons_arc_pa'></span>

<h3>Description</h3>

<p>A data frame with one hundred multivariate Bernoulli simulated outcomes representing spring, summer and fall.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mur_seasons_arc_pa")</code></pre>


<h3>Format</h3>

<p>A data frame with 300 observations on the following 28 variables.
</p>

<dl>
<dt>&lsquo;<span class="samp">&#8288;IN_N -&gt; M1984&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1984 -&gt; M1909&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1909 -&gt; M1799&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;IN_S -&gt; M1993&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1993 -&gt; M1951&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1951 -&gt; M1909&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1799 -&gt; M1719&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1719 -&gt; M1653&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1653 -&gt; M1572&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1572 -&gt; M1452&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1452 -&gt; M1377&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1377 -&gt; M1254&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1254 -&gt; M1166&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1166 -&gt; M1121&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1121 -&gt; M1036&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M1036 -&gt; M918&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M918 -&gt; M823&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M823 -&gt; M759&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M759 -&gt; M716&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M716 -&gt; M624&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M624 -&gt; M523&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M523 -&gt; M454&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M454 -&gt; M380&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M380 -&gt; M233&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M233 -&gt; M153&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M153 -&gt; M91&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt>&lsquo;<span class="samp">&#8288;M91 -&gt; OUT&#8288;</span>&rsquo;</dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Season</code></dt><dd><p>A categorical variable with three levels: <code>"spring"</code> (6/3/2019 - 7/13/2019), <code>"summer"</code> (7/13/2019 - 8/23/2019) and <code>"fall"</code> (8/23/2019 - 10/2/2019) </p>
</dd>
</dl>


<hr>
<h2 id='n.sources'>
Identify source and sink nodes
</h2><span id='topic+n.sources'></span><span id='topic+sources'></span>

<h3>Description</h3>

<p>Identify the number of sources and the source nodes.  Sources are assumed to be linked to the sink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.sources(G, sink = NULL)
sources(G, sink = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n.sources_+3A_g">G</code></td>
<td>

<p>A graph object of class &quot;igraph&quot;, see <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="n.sources_+3A_sink">sink</code></td>
<td>

<p>The name of the sink node.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector listing streamDAG source nodes (those linked to the sink with indegree 0).</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+degree">degree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sources(streamDAGs("konza_full"), sink = "SFM01_1")
</code></pre>

<hr>
<h2 id='path.lengths.sink'>
Path Lengths
</h2><span id='topic+path.lengths.sink'></span>

<h3>Description</h3>

<p>Obtains all shortest in paths to a sink
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.lengths.sink(G, sink = NULL, inf.paths = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path.lengths.sink_+3A_g">G</code></td>
<td>

<p>Graph object of class &quot;igraph&quot;, see: <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="path.lengths.sink_+3A_sink">sink</code></td>
<td>

<p>sink node from <code>G</code>.
</p>
</td></tr>
<tr><td><code id="path.lengths.sink_+3A_inf.paths">inf.paths</code></td>
<td>

<p>Logical, consider infinite paths?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Length of path to a sink
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>murphy_spring &lt;- graph_from_literal(IN_N --+ M1984 --+ M1909, IN_S --+ M1993, 
M1993 --+ M1951 --+ M1909 --+ M1799 --+ M1719 --+ M1653 --+ M1572 --+ M1452,
M1452--+ M1377 --+ M1254 --+ M1166 --+ M1121 --+ M1036 --+ M918 --+ M823, 
M823 --+ M759 --+ M716 --+ M624 --+ M523 --+ M454 --+ M380 --+ M233 --+ M153,
M153 --+ M91 --+ OUT)

path.lengths.sink(murphy_spring, sink = "OUT")

# with stream lengths as weights
data(mur_lengths)

E(murphy_spring)$weights &lt;- mur_lengths[,2]
path.lengths.sink(murphy_spring, "OUT")
</code></pre>

<hr>
<h2 id='path.visibility'> 
Path Visibilities
</h2><span id='topic+visibility'></span><span id='topic+path.visibility'></span><span id='topic+multi.path.visibility'></span>

<h3>Description</h3>

<p>Functions detect and summarize visibilities of path nodes from one or several source nodes to an sink.  Specifically, the function The function <code>path.visibility</code> determines path visibilities from single source node to a single sink. <code>multi.path.visibility</code> Generates tables of path visibilities and visibility summaries for multiple source nodes to a single sink. 
</p>
<p>Ordering of nodes, vitally important to the calculation of visibility is currently obtained by identifying paths from each source node to the sink.  The sum of node distances in each path are then sorted decreasingly to define an initial order for calculating visibilities. It is currently assumed that the user will manually handle disconnected paths via the <code>source</code> argument of visibility functions.  Use of source nodes disconnected to the sink will result in the message: <code>"only use source nodes connected to sink"</code>. Because of this situation disconnected graphs will be handled by a function in development <code>single.node.visibility</code>.       
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
path.visibility(G, degree = "in", source = NULL, sink = NULL, weights = NULL)

multi.path.visibility(G, degree = "in", source = NULL, sink = NULL, 
weights = NULL, autoprint = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path.visibility_+3A_g">G</code></td>
<td>

<p>Graph of class &quot;igraph&quot;.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="path.visibility_+3A_degree">degree</code></td>
<td>

<p>One of <code>"out"</code> for outdegree, <code>"in"</code> for indegree or <code>"all"</code> for the sum of the two.
</p>
</td></tr>
<tr><td><code id="path.visibility_+3A_source">source</code></td>
<td>

<p>A starting node for a path.  The function <code>multi.path.visibility</code> allows multiple starting nodes.
</p>
</td></tr>
<tr><td><code id="path.visibility_+3A_sink">sink</code></td>
<td>

<p>An ending node for a path.
</p>
</td></tr>
<tr><td><code id="path.visibility_+3A_weights">weights</code></td>
<td>
<p>If <code>!null</code>, refers to a <code class="reqn">1 \times n</code> <code>data.frame</code> of weights, with the <code>data.frame</code> <code><a href="base.html#topic+name">name</a></code> attribute in <code>weights</code> corresponding to node names in <code>G</code>.
</p>
</td></tr>
<tr><td><code id="path.visibility_+3A_autoprint">autoprint</code></td>
<td>
<p>Logical.  Should table summary of nodal visibilities be automatically printed or made ?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Lacasa et al. (2008), let <code class="reqn">t_a</code> represent the occurrance number of the <code class="reqn">a</code>th node in a time series or stream path, and let <code class="reqn">y_a</code> represent a data outcome from the <code class="reqn">a</code>th node. Nodes <code class="reqn">a</code> and <code class="reqn">b</code> will have visibility if all other data, <code class="reqn">y_c</code>, between <code class="reqn">a</code> and <code class="reqn">b</code> fufill:
</p>
<p style="text-align: center;"><code class="reqn">y_c &lt; y_b + (y_a - y_b)\frac{t_b - t_c}{t_b - t_a}.</code>
</p>



<h3>Value</h3>

<p>The function <code>path.visibility</code> returns a symmetric matrix whose upper triangle denotes nodal co-visibilities.  The lower triangle is left empty for efficiency.  Reading down a column in the upper triangle shows upstream visibilites to and from a node, while reading across rows shows downstream visibilities. 
</p>
<p>The function <code>multi.path.visibility</code> returns a list containing the three objects.  The first is printed and the latter two are <code><a href="base.html#topic+invisible">invisible</a></code> by default.   
</p>
<table role = "presentation">
<tr><td><code>visibility.summary</code></td>
<td>
<p>The printed result is a matrix of path visibity counts for a node, with respect to upstream (to), downstream (from), and combined directions (both).</p>
</td></tr>
<tr><td><code>complete.matrix</code></td>
<td>
<p>Analogous, to <code>path.visibility</code>, this result attempts to synthesize visibilities within source-to-sink paths for all requested sources into a single matrix. </p>
</td></tr>
<tr><td><code>all.matrices</code></td>
<td>
<p>A list containing <code>path.visibility</code> summary matrices for each source-to-sink path.</p>
</td></tr>
</table>
<p>Output is summarized based on a deduced ordering of nodes from sources to sin.  The ordering is based on nodal path lengths.
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+degree">degree</a></code> and <code><a href="igraph.html#topic+shortest_paths">shortest_paths</a></code>.
</p>


<h3>References</h3>

<p>Lacasa, L., Luque, B., Ballesteros, F., Luque, J., &amp; Nuno, J. C. (2008). From time series to complex networks: The visibility graph. <em>Proceedings of the National Academy of Sciences</em>, 105(13), 4972-4975.
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+degree">degree</a></code>, <code><a href="igraph.html#topic+shortest_paths">shortest_paths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, 
e --+ j, j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, 
l --+ m, m --+ n,  n --+ o)

path.visibility(A, source = "a", sink = "o")
  
multi.path.visibility(A, source = c("a","c","f","h"), 
sink = "o")

# From Lacasa et al. (2008)

B &lt;- graph_from_literal(a --+ b --+ c --+ d --+ e --+ f --+ g)
weights &lt;- data.frame(matrix(nrow = 1, data = c(0.87, 0.49, 0.36, 0.83, 0.87, 0.49, 0.36))) 
names(weights) = letters[1:7]
path.visibility(B, source = "a", sink = "g", weights = weights) 
</code></pre>

<hr>
<h2 id='plot_degree.dist'>
Plot degree distributions
</h2><span id='topic+plot_degree.dist'></span>

<h3>Description</h3>

<p>Plots bserved degree distribution against models for uncorrelated random, chaotic and correlated random processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
plot_degree.dist(G, mode = "all", exp.lambda = c(1.1, 3/2, 2), leg.loc = "topright")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_degree.dist_+3A_g">G</code></td>
<td>

<p>Graph object of class &quot;igraph&quot;.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="plot_degree.dist_+3A_mode">mode</code></td>
<td>

<p>Character string, one of <code>"out"</code> for out-degree, <code>"in"</code> for in-degree or <code>"all"</code> for the sum of the two. For undirected graphs this argument is ignored.
</p>
</td></tr>
<tr><td><code id="plot_degree.dist_+3A_exp.lambda">exp.lambda</code></td>
<td>

<p>log.lamda = if not NULL, allows specification of chaotic <code>exp.lambda &lt; 3/2</code> and correlated stochastic processes <code>exp.lambda &lt; 3/2</code>
</p>
</td></tr>
<tr><td><code id="plot_degree.dist_+3A_leg.loc">leg.loc</code></td>
<td>

<p>placement of <code><a href="graphics.html#topic+legend">legend</a></code>,
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots processes for observed versus distributions under random or chaotic degrees.
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degree.dists">degree.dists</a></code>, <code><a href="igraph.html#topic+degree.distribution">degree.distribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network_a &lt;- graph_from_literal(a --+ b, c --+ d, d --+ e, b --+ e, 
e --+ j, j --+ m, f --+ g, g --+ i, h --+ i, i --+ k, k --+ l, 
l --+ m, m --+ n,  n --+ o)
plot_degree.dist(network_a)
</code></pre>

<hr>
<h2 id='R.bounds'>Bounds for the correlation of two (or more) Benrnoulli random variables
</h2><span id='topic+R.bounds'></span><span id='topic+max_r'></span><span id='topic+min_r'></span>

<h3>Description</h3>

<p>Replaces impossible correlations (values too small or too large) with minimum and maximum correlations, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_r(p1, p2)
max_r(p1, p2)
R.bounds(p, R, pad = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R.bounds_+3A_p1">p1</code></td>
<td>

<p>Probability of success for first random variable
</p>
</td></tr>
<tr><td><code id="R.bounds_+3A_p2">p2</code></td>
<td>

<p>Probability of success for second random variable
</p>
</td></tr>
<tr><td><code id="R.bounds_+3A_p">p</code></td>
<td>

<p>Vector of marginal probabilities for multivariate Bernoulli random variables, for <code>R.bounds</code>.
</p>
</td></tr>
<tr><td><code id="R.bounds_+3A_r">R</code></td>
<td>

<p>Raw correlation matrix for random variables
</p>
</td></tr>
<tr><td><code id="R.bounds_+3A_pad">pad</code></td>
<td>

<p>Padding (in correlation units) to adjust the returned correlation matrix with respect extremal values. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>r.min</code> and <code>r.max</code> define minimum and maximimum possible correlations. The function <code>R.bounds</code> replaces impossibly large or small values with maximally large or small values repectively.    
</p>


<h3>Value</h3>

<p>Functions return a scalar defining minimum or maximimum possible correlations.  See Aho et al. (2023).</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>References</h3>

<p>Aho, K., Derryberry, D., Godsey, S. E., Ramos, R., Warix, S., Zipper, S. (2023) The communication distance of non-perennial streams. EarthArXiv <a href="https://eartharxiv.org/repository/view/4907/">https://eartharxiv.org/repository/view/4907/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>min_r(0.6, 0.9)
max_r(0.1, 0.2)

x1 &lt;- rep(c(1,0),5)
x2 &lt;- c(rep(1,7), rep(0,3))
x3 &lt;- c(rep(1,3), rep(0,7))
R &lt;- cor(cbind(x1, x2, x3))
R.bounds(c(0.5, 0.7, 1), R)
</code></pre>

<hr>
<h2 id='size.intact.to.arc'>
Size of the intact network above an arc
</h2><span id='topic+size.intact.to.arc'></span>

<h3>Description</h3>

<p>The function measures the &ldquo;size&rdquo; of the intact network or sub-network (either number of upstream nodes, or user defined defined length, e.g., m, km) with respect to network arcs.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size.intact.to.arc(G, arc.node = "in")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="size.intact.to.arc_+3A_g">G</code></td>
<td>

<p>Graph object of class &quot;igraph&quot;, see: <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="size.intact.to.arc_+3A_arc.node">arc.node</code></td>
<td>

<p>One of <code>"in"</code> or <code>"out"</code>, indicating whether the upstream network or sub-network will be defined with respect to input nodes of directional arcs (<code>arc.node = "in"</code>) or output (end) nodes of arcs (<code>arc.node = "out"</code>).  The former (default) option is reccomended (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an unweighted graph, the upstream network &ldquo;size&rdquo; equates to the number of nodes in the intact network or sub-network upstream of an arc.  For a graph whose arcs are weighted with actual stream segment lengths (see Examples), this will be the length (in measured units of length given in the weights) of the intact network or sub-network upstream of the arc. The argument <code>arc.node</code> allows upstream network size to be calculated with respect to either the upstream (<code>"in"</code>) nodes of arcs or the downstream (<code>"out"</code>) nodes of arcs. This designation will be applied to define the end (outlet) of the network or sub-network.  Thus, option <code>"out"</code> may produce unexpectedly large results when these downstream <code>"out"</code> nodes of arcs occur at confluences.   
</p>


<h3>Value</h3>

<p>Output is a numeric vector whose length will be equal to the number of arcs in <code>G</code>. 
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote <code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+local.summary">local.summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mur &lt;- streamDAGs("mur_full")
data(mur_lengths)
E(mur)$weight &lt;- mur_lengths[,2]
size.intact.to.arc(mur) # upstream network sizes are in meters
</code></pre>

<hr>
<h2 id='size.intact.to.sink'>
Size of intact network that feeds into the sink or a particular node
</h2><span id='topic+size.intact.to.sink'></span><span id='topic+size.intact.to.node'></span>

<h3>Description</h3>

<p>The length of the subgraph network that ends (feeds into) a particular node, e.g., the sink.  For a weighted graph, the sum of the weights of the subgraph are given. Thus, if weights are stream lengths the function will give the stream length of the portion of the intact stream network that feeds into a particular node. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size.intact.to.sink(G, sink = NULL)

size.intact.to.node(G, node = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="size.intact.to.sink_+3A_g">G</code></td>
<td>

<p>A graph object of class &quot;igraph&quot;, see <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>  
</p>
</td></tr>
<tr><td><code id="size.intact.to.sink_+3A_sink">sink</code></td>
<td>

<p>The sink node of <code>G</code>.
</p>
</td></tr>
<tr><td><code id="size.intact.to.sink_+3A_node">node</code></td>
<td>

<p>A node of interest.  If <code>node = "all"</code>, the index will be computed for all nodes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the size of the graph or subgraph whose downstream end (outlet) is a <code>node</code> of interest.
</p>


<h3>Author(s)</h3>

<p>Ken Aho, Gabor Csardi wrote several important function components including <code><a href="igraph.html#topic+subgraph">subgraph</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Murphy Cr. disconnected network, no arc from M1799 to M1719!

G &lt;- graph_from_literal(IN_N --+ M1984 --+ M1909, IN_S --+ M1993 --+ M1951, 
M1951 --+ M1909 --+ M1799, M1719 --+ M1653 --+ M1572 --+ M1452 --+ M1377, 
M1377 --+ M1254 --+ M1166 --+ M1121 --+ M1036 --+ M918 --+ M823 --+ M759, 
M759 --+ M716 --+ M624 --+ M523 --+ M454 --+ M380 --+ M233 --+ M153 --+ M91, 
M91 --+ OUT)

data(mur_coords) # coordinate data
spatial.plot(G, mur_coords[,2], mur_coords[,3], names =  mur_coords[,1])

data(mur_lengths) # segment length data 

lengths_new &lt;- mur_lengths[-7,] # Drop M1799 -&gt; M1719 arc length
E(G)$weight &lt;- lengths_new[,2] # units are in meters
size.intact.to.node(G, node = "all") 
size.intact.to.sink(G, sink = "OUT") # same as output below:
size.intact.to.node(G, node = "OUT")
</code></pre>

<hr>
<h2 id='spath.lengths'>
Shortest path lengths and number of paths 
</h2><span id='topic+spath.lengths'></span><span id='topic+n.tot.paths'></span>

<h3>Description</h3>

<p>The function <code>spath.lengths</code> calculates path lengths from all possible nodes to or from a designated node, i.e., the shortest in-paths and out-paths repsectively.  Weighted path length are possible, including weighted path lengths based on field-observed instream arc lengths (see Examples).  This results in &quot;actual&quot; path lengths in observed units. The function <code>n.tot.paths</code> calculates the total number of paths beginning or ending at all nodes in a graph, based on exponention of the the adjacency matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spath.lengths(G, node = NULL, mode = "in", ignore.inf = TRUE)

n.tot.paths(G, mode = "in", sink = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spath.lengths_+3A_g">G</code></td>
<td>

<p>Graph of class &quot;igraph&quot;.  See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>
</p>
</td></tr>
<tr><td><code id="spath.lengths_+3A_node">node</code></td>
<td>

<p>Designated node. 
</p>
</td></tr>
<tr><td><code id="spath.lengths_+3A_mode">mode</code></td>
<td>

<p>One of <code>"in"</code> or <code>"out"</code>.  The former gives in-paths, whereas the latter gives out-paths.  
</p>
</td></tr>
<tr><td><code id="spath.lengths_+3A_ignore.inf">ignore.inf</code></td>
<td>

<p>Logical.  Whether infinite distances are to be ignored.  By default <code>ignore.inf = TRUE</code>, allowing impossible upstream distances to be ignored in stream DAGs.  
</p>
</td></tr>
<tr><td><code id="spath.lengths_+3A_sink">sink</code></td>
<td>

<p>Name of sink node. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lengths of paths to a node of interest.  
</p>


<h3>Author(s)</h3>

<p>Ken Aho , Gabor Csardi wrote <code><a href="igraph.html#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mur_lengths)
mur &lt;- streamDAGs("mur_full")
n.tot.paths(mur)

spath.lengths(mur, "M1653")
E(mur)$weight &lt;- mur_lengths[,2] # weighted (actual in-stream lengths in meters)
spath.lengths(mur, "M1653")
</code></pre>

<hr>
<h2 id='spatial.plot'>
Spatial plot of an igraph object or stream shapefile
</h2><span id='topic+spatial.plot'></span><span id='topic+spatial.plot.sf'></span>

<h3>Description</h3>

<p>Makes a spatial plot of a igraph object or stream shapefile, given nodal coordinates and node IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
spatial.plot(G, x, y, names = NULL, 
                         plot = TRUE,
                         col = "lightblue", 
                         cex.text = .4, cex = 1,
                         arrow.col = "lightblue", arrow.lwd = 1, 
                         plot.bg = "white", pch = 21, 
                         pt.bg = "orange", grid.lwd = 2, 
                         plot.dry = FALSE,
                         col.dry = gray(.7),
                         cex.dry = 1, pch.dry = 19, 
                         arrow.col.dry = gray(.7), arrow.lwd.dry = 1,
                         cnw = NULL, xlim = NULL, ylim = NULL, 
                         arrow.warn = TRUE, ...)


spatial.plot.sf(x, y, names, shapefile = NULL, cex = 1, arrow.col = "lightblue", 
                arrow.lwd = 1, pch = 21, pt.bg = "orange")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.plot_+3A_g">G</code></td>
<td>

<p>Graph object, see <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_x">x</code></td>
<td>

<p>X-coordinates of nodes.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_y">y</code></td>
<td>

<p>Y-coordinates of nodes.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_names">names</code></td>
<td>
<p>Names of nodes, must use the same names as <code>G</code> and correspond to the order of coordinates in <code>x</code> and <code>y</code>.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_plot">plot</code></td>
<td>
<p>Logical. Create plot?  
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_shapefile">shapefile</code></td>
<td>

<p>Shapefile object brought in using library <em>sf</em>
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_col">col</code></td>
<td>

<p>point symbol color.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cex.text">cex.text</code></td>
<td>

<p>Character expansion for node labels in plot; <code>cex.text = 0</code> suppresses labels.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cex">cex</code></td>
<td>

<p>Chahracter expnansion of point symbols.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_arrow.col">arrow.col</code></td>
<td>

<p>Color of plot arrows.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_arrow.lwd">arrow.lwd</code></td>
<td>

<p>Arrow line width.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_plot.bg">plot.bg</code></td>
<td>

<p>Background color of plot.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_pch">pch</code></td>
<td>

<p>Plotting character.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_pt.bg">pt.bg</code></td>
<td>

<p>Background color for plotting character.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_grid.lwd">grid.lwd</code></td>
<td>

<p>Grid line width; <code>grid.lwd = 0</code> suppresses grid.
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_plot.dry">plot.dry</code></td>
<td>

<p>Logical.  Should &ldquo;dry&rdquo; nodes, i.e., nodes in <code>names</code> (and <code>x</code> and <code>y</code>) that are not also in <code>G</code> be plotted?  
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_col.dry">col.dry</code></td>
<td>

<p>Color of &ldquo;dry&rdquo; nodes in plot.     
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cex.dry">cex.dry</code></td>
<td>

<p>Symbol sizer of &ldquo;dry&rdquo; nodes in plot.     
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_pch.dry">pch.dry</code></td>
<td>

<p>Plotting character (symbol) of &ldquo;dry&rdquo; nodes in plot.  
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_arrow.col.dry">arrow.col.dry</code></td>
<td>

<p>Arrow color for &quot;dry&quot; arcs. Dry arrow rendering requires <code>cnw</code> designation (see Examples). 
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_arrow.lwd.dry">arrow.lwd.dry</code></td>
<td>

<p>Arrow line width for &quot;dry&quot; arcs. Dry arrow rendering requires <code>cnw</code> designation (see Examples). 
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_cnw">cnw</code></td>
<td>

<p>Complete network <code>spatial.plot</code> object. 
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_xlim">xlim</code></td>
<td>

<p>A numeric vector of length 2, giving the lower and upper <em>y</em>-axis limits. 
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_ylim">ylim</code></td>
<td>

<p>A numeric vector of length 2, giving the lower and upper <em>x</em>-axis limits. 
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_arrow.warn">arrow.warn</code></td>
<td>
<p>Logical.  The function <code><a href="graphics.html#topic+arrows">arrows</a></code> omits arrowheads (with a warning) for any arrow of length less than 1/1000 inch. To elimiate this warning (which may occur for nearby nodes) specify <code>arrow.warn = FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_...">...</code></td>
<td>

<p>Other arguments to <code><a href="base.html#topic+plot">plot</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The function <code>spatial.plot</code> makes a plot of a stream DAG, showing arc flow directions to and from spatial node locations. The function can also be used to identify node and arc arrow coordinates for plotting (see Examples). The function <code>spatial.plot.sf</code> can create a spatially explicit graph from a stream shapefile with the stream outlay under a ggplot framework (see Examples). The function <code>spatial.plot</code> can be used to distinguish dry and wet nodes and arcs) (see Examples). 
</p>


<h3>Value</h3>

<p>A plot and an <code>invisible</code> list containing the <code>x</code> and <code>y</code> coordinates of nodes: the objects <code>$x</code> and <code>$y</code>, respectively, and the <code>x</code> and <code>y</code> coordinates of start and end points of arc arrows:the objects <code>$x0</code>, <code>$y0</code>, <code>$x1</code>, and <code>$y1</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- graph_from_literal(IN_N --+ M1984 --+ M1909, IN_S --+ M1993, 
M1993 --+ M1951 --+ M1909 --+ M1799 --+ M1719 --+ M1653 --+ M1572 --+ M1452,
M1452--+ M1377 --+ M1254 --+ M1166 --+ M1121 --+ M1036 --+ M918 --+ M823, 
M823 --+ M759 --+ M716 --+ M624 --+ M523 --+ M454 --+ M380 --+ M233 --+ M153,
M153 --+ M91 --+ OUT)

data(mur_coords)

x &lt;- mur_coords[,2]
y &lt;- mur_coords[,3]
names &lt;- mur_coords[,1]
spatial.plot(G, x, y, names)

# using shapefiles


library(ggplot2); library(sf); library(ggrepel)
mur_sf &lt;- st_read(system.file("shape/Murphy_Creek.shp", package="streamDAG"))
g1 &lt;- spatial.plot.sf(x, y, names, shapefile = mur_sf)

# modify ggplot
g1 + theme_classic()


#-- Distinguishing wet and dry arcs and nodes --#

data(mur_node_pres_abs) # STIC H2O presence/absence
npa &lt;- mur_node_pres_abs[650,][,-1] # STC data from 8/9/2019 22:30 
G1 &lt;- delete.nodes.pa(G, npa) # delete nodes based STIC data

# Example 1 (only show wet nodes and arcs with associated wet nodes)
spatial.plot(G1, x, y, names)

# Example 2 (show wet nodes and arcs with associated wet nodes, and dry nodes)
spatial.plot(G1, x, y, names, plot.dry = TRUE)

# Example 3 (show wet nodes and arcs wet node arcs, and underlying network)
entire &lt;- spatial.plot(G, x, y, names, plot = FALSE)
spatial.plot(G1, x, y, names, plot.dry = TRUE, cnw = entire)


#-- Animation: drying of Johnson Draw drainage --#

jd_graph &lt;- streamDAGs("jd_full")
data(AIMS.node.coords)
jd_coords &lt;- AIMS.node.coords[AIMS.node.coords$site == "JD",]
jd_coords &lt;- jd_coords[jd_coords$STIC_inferred_PA,] 
data(jd_node_pres_abs)

# Drop 2023 sites 
jd_pa &lt;- jd_node_pres_abs[,-c( 22, 23, 24, 25, 26, 27, 
28, 31, 32, 33, 34, 35, 36, 37)]

pb = txtProgressBar(min = 1, max = 250, initial = 1, style = 3) 
times &lt;- round(seq(1,50322, length = 250),0)

for(i in 1:250){
  dev.flush()
  jd_sub &lt;- delete.nodes.pa(jd_graph, 
                            jd_pa[times[i],][-1],
                            na.response = "treat.as.1")
  spatial.plot(jd_sub, 
               x = jd_coords[,3], 
               y = jd_coords[,2], 
               names = jd_coords[,1], 
               ylim = c(43.122, 43.129), 
               xlim = c(-116.8, -116.775), 
               plot.dry = TRUE, main = jd_node_pres_abs[,1][times[i]], 
               xlab = "Longitude", ylab = "Latitude")
  dev.hold()
  Sys.sleep(.05)
  setTxtProgressBar(pb, i)
  }

</code></pre>

<hr>
<h2 id='STIC.RFimpute'>
A wrapper for missForest for random forest STIC imputation 
</h2><span id='topic+STIC.RFimpute'></span>

<h3>Description</h3>

<p>A simple wrapper for the <code><a href="missForest.html#topic+missForest">missForest</a></code> random forest imputation algorithm. <code>STIC.RFimpute</code> first converts STIC (Stream Temperature, Intermittency, and Conductivity) presence/absence data to categorical outcomes to avoid regression fitting.  One should consult <code><a href="missForest.html#topic+missForest">missForest</a></code> for specifics on the underlying algorithm.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STIC.RFimpute(p.a, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STIC.RFimpute_+3A_p.a">p.a</code></td>
<td>

<p>Optimally, a dataframe containing presence absence data at sites (columns) over time (rows).
</p>
</td></tr>
<tr><td><code id="STIC.RFimpute_+3A_...">...</code></td>
<td>

<p>Additional arguments from <code><a href="missForest.html#topic+missForest">missForest</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provides the conventional unaltered <code><a href="missForest.html#topic+missForest">missForest</a></code> output.
</p>


<h3>Author(s)</h3>

<p>Daniel J. Stekhoven, &lt;stekhoven@stat.math.ethz.ch&gt;
</p>


<h3>References</h3>

<p>Stekhoven, D.J. and Buehlmann, P. (2012), 'MissForest - nonparametric missing value imputation for mixed-type data', Bioinformatics, 28(1) 2012, 112-118, doi: 10.1093/bioinformatics/btr597
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arc.pa &lt;- data.frame(matrix(ncol = 3, data = c(1,1,1, 0,1,1, 1,1,1, 0,NA,1), byrow = TRUE))
names(arc.pa) &lt;- c("n1 --&gt; n2", "n2 --&gt; n3", "n3 --&gt; n4")

STIC.RFimpute(arc.pa)
</code></pre>

<hr>
<h2 id='stream.order'>
Strahler or Shreve stream order of a stream DAG
</h2><span id='topic+stream.order'></span><span id='topic+sink.G'></span>

<h3>Description</h3>

<p>The function <code>stream.order</code> calculates Strahler or Shreve number for each each in a stream DAG.  The function <code>sink.G</code> is a utility algorithm that subsets the graph if the sink node is part of a sub-graph that is disconnected from other nodes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sink.G(G, sink = NULL)

stream.order(G, sink = NULL, method = "strahler")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stream.order_+3A_g">G</code></td>
<td>

<p>Graph object of class &quot;igraph&quot;, see: See <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.
</p>
</td></tr>
<tr><td><code id="stream.order_+3A_sink">sink</code></td>
<td>

<p>Sink node from <code>G</code>.
</p>
</td></tr>
<tr><td><code id="stream.order_+3A_method">method</code></td>
<td>

<p>One of <code>"strahler"</code> or <code>"shreve"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strahler stream order (Strahler 1957) is a &quot;top down&quot; system in which first order stream sections occur at the outermost tributaries.  A stream section resulting from the merging of tributaries of the same order will have a Strahler number one unit greater than the order of those tributaries. A stream section resulting from the merging of tributaries of different order will have the Strahler stream order of the tributary with the larger Strahler number.   Under Shreve stream order, (Shreve 1966) a stream section resulting from the merging of tributaries will have an order that is the sum of the order of those tributaries.  
</p>
<p>The function can currently only handle graphs with confluences (which, as noted above, serve to define the stream order) and simple islands (those without sub-islands and those whose downstream endpoint does not occur at a join). Under the current version, islands will not change the order of a reach.   
</p>


<h3>Value</h3>

<p>Returns Stahler or Shreve numbers for each stream DAG node.
</p>


<h3>Note</h3>

<p>May be slow for extremely large and complex streams due to a reliance on loops.
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>References</h3>

<p>Shreve, R. L. (1966). Statistical law of stream numbers. <em>The Journal of Geology, 74</em>(1), 17-37.
</p>
<p>Strahler, A. N. (1952). Hypsometric (area-altitude) analysis of erosional topology. <em>Geological Society of America Bulletin, 63</em> (11): 1117-1142
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
stream.order(G = streamDAGs("konza_full"), sink = "SFM01_1", method = "strahler")

stream.order(G = streamDAGs("konza_full"), sink = "SFM01_1", method = "shreve")

</code></pre>

<hr>
<h2 id='streamDAGs'>
Stream DAG datasets
</h2><span id='topic+streamDAGs'></span>

<h3>Description</h3>

<p>The function contains a number of stream direct acyclic graph datasets written in <em>igraph</em> format. See: <code><a href="igraph.html#topic+graph_from_literal">graph_from_literal</a></code>.  Many of the graphs were based on sampling regimes for the National Science Foundation Aquatic Intermittency Effects on Microbiomes in Streams (AIMS) project. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streamDAGs(graph = c("dc_piezo_full", "dc_full", "gj_full16", "gj_synoptic_2023", 
"gj_full", "gj_piezo_full", "jd_piezo_full", "jd_piezo_full_2023","jd_full", 
"konza_full", "KD0521", "KD0528", "KD0604", "mur_full", "td_full", "wh_full", 
"pr_full"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streamDAGs_+3A_graph">graph</code></td>
<td>

<p>Currently, one of  <code>"dc_piezo_full"</code>, <code>"dc_full"</code>, <code>"gj_full16"</code>, <code>"gj_full16"</code>, <code>"gj_synoptic_2023"</code>, <code>"gj_full"</code>, <code>"gj_piezo_full"</code>, <code>"jd_piezo_full"</code>, <code>"jd_piezo_full_2023"</code>, <code>"jd_full"</code>, <code>"konza_full"</code>, <code>"KD0521"</code>, <code>"KD0528"</code>, <code>"KD0604"</code>, <code>"mur_full"</code>, <code>"pr_full"</code>,  <code>"td_full"</code>, or <code>"wh_full"</code> (see Details below).   
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Currently, the following <code>graph</code> options exist.  Note that many of the graphs have associated datasets. Obtaining these datasets is now greatly simplified through the use of <code><a href="#topic+get.AIMS.data">get.AIMS.data</a></code> (code steps shown below are unnecessary).
</p>

<ol>
<li><p><code>"dc_piezo_full"</code> codifies the Dry Creek stream network in southwestern Idaho for STIC (Stream Temperature, Intermittency, and Conductivity) sensors, confluences, and piezometer locations (outlet coordinates: 43.71839<code class="reqn">^\circ</code>N, 116.13747<code class="reqn">^\circ</code>W).
</p>
<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "DC"</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained directly from <code><a href="#topic+dc_node_pres_abs">dc_node_pres_abs</a></code>.
</p>
</li>
<li><p>Arc lengths for this graph can be obtained directly from <code><a href="#topic+dc_lengths">dc_lengths</a></code>.
</p>
</li></ul>

</li>
<li><p><code>"dc_full"</code> codifies the Dry Creek stream network in southwestern Idaho but only for STICs and confluences, not piezometer locations (outlet coordinates: 43.71839<code class="reqn">^\circ</code>N, 116.13747<code class="reqn">^\circ</code>W). 
</p>

<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "DC" &amp; AIMS.node.coords$STIC_inferred_PA</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained using <code>dc &lt;- streamDAGs("dc_full")</code> followed by <code>dc_node_pres_abs[attributes(V(dc))$names]</code>.
</p>
</li></ul>

</li>
<li><p><code>"gj_full16"</code> codifies nodes established at the Gibson Jack drainage in southeast Idaho, as defined in 2016 (outlet coordinates: 42.767180<code class="reqn">^\circ</code>N, 112.480240<code class="reqn">^\circ</code>W).
</p>
</li>
<li><p><code>"gj_full"</code> codifies nodes established at the Gibson Jack drainage in southeast Idaho for STIC sensors in 2022-2023, along with confluence locations. Piezometer locations not included (outlet coordinates: 42.767180<code class="reqn">^\circ</code>N, 112.480240<code class="reqn">^\circ</code>W). 
</p>
<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "GJ" &amp; AIMS.node.coords$STIC_inferred_PA</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained from: <code><a href="#topic+gj_node_pres_abs">gj_node_pres_abs</a></code> using <code>gj &lt;- streamDAGs("gj_full"); vnames &lt;- attributes(V(gj))$names; w &lt;- which(names(gj_node_pres_abs)[-1] %in% vnames) + 1; node.pa &lt;- gj_node_pres_abs[,c(1,w)]</code>.
</p>
</li>
<li><p>Arc lengths for this graph can be obtained from <code><a href="#topic+gj_lengths_piezo_full">gj_lengths_piezo_full</a></code> using <code>gj &lt;- streamDAGs("gj_full"); anames &lt;- attributes(E(gj))$vnames; enames &lt;- gsub("\|", " -&gt; ", anames); m &lt;- match(enames, gj_lengths_piezo_full[,1])
    gj_lengths_piezo_full[m,]</code>.</p>
</li></ul>

</li>
<li><p><code>"gj_piezo_full"</code> codifies nodes established at the Gibson Jack drainage in southeast Idaho, by the the AIMS team which include longterm STICs and piezometers, along with confluence locations (outlet coordinates: 42.767180<code class="reqn">^\circ</code>N, 112.480240<code class="reqn">^\circ</code>W). 
</p>
<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "GJ" &amp; (AIMS.node.coords$STIC_inferred_PA | AIMS.node.coords$piezo)</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained using <code>gj &lt;- streamDAGs("gj_piezo_full")</code> followed by <code>gj_node_pres_abs[attributes(V(gj))$names]</code>.
</p>
</li>
<li><p>Arc lengths for this graph can be obtained from <code><a href="#topic+gj_lengths_piezo_full">gj_lengths_piezo_full</a></code> using <code>gj &lt;- streamDAGs("gj_piezo_full"); anames &lt;- attributes(E(gj))$vnames; enames &lt;- gsub("\|", " -&gt; ", anames); m &lt;- match(enames, gj_lengths_piezo_full[,1]); gj_lengths_piezo_full[m,]</code>.
</p>
</li></ul>

</li>
<li><p><code>"gj_synoptic_2023"</code> codifies nodes established at the Gibson Jack drainage in southeast Idaho by the AIMS team during synoptic sampling in 2023, includes piezometers and additional sites to those sampled in <code>"gj_full"</code> (outlet coordinates: 42.767180<code class="reqn">^\circ</code>N, 112.480240<code class="reqn">^\circ</code>W).
</p>
</li>
<li><p><code>"jd_piezo_full"</code> codifies the Johnson Draw stream network in southwestern Idaho for both STIC and and piezometer locations (outlet coordinates: 43.12256<code class="reqn">^\circ</code>N, 116.77630<code class="reqn">^\circ</code>W).
</p>
<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "JD" &amp; AIMS.node.coords$New_in_2023 == FALSE</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained from <code><a href="#topic+jd_node_pres_abs">jd_node_pres_abs</a></code> using <code>jd &lt;- streamDAGs("jd_piezo_full")</code> followed by <code>jd_node_pres_abs[attributes(V(jd))$names]</code>.
</p>
</li>
<li><p>Arc lengths can be subset from <code><a href="#topic+jd_lengths_2023">jd_lengths_2023</a></code> using something like: <code>jd &lt;- streamDAGs("jd_piezo_full"); anames &lt;- attributes(E(jd))$vnames; nnames &lt;- gsub("\\|", " -&gt; ", anames); jd_lengths_2023[which(jd_lengths_2023[,1] %in% nnames ),]</code>.
</p>
</li></ul>


</li>
<li><p><code>"jd_piezo_full_2023"</code> codifies the Johnson Draw stream network in southwestern Idaho for both STIC and and piezometer locations, along with new STIC locations added in 2023 (outlet coordinates: 43.12256<code class="reqn">^\circ</code>N, 116.77630<code class="reqn">^\circ</code>W).
</p>

<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "JD"</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained from <code><a href="#topic+jd_node_pres_abs">jd_node_pres_abs</a></code> using <code>jd &lt;- streamDAGs("jd_piezo_full_2023")</code> followed by <code>jd_node_pres_abs[attributes(V(jd))$names]</code>.
</p>
</li>
<li><p>Arc lengths can be subset from <code><a href="#topic+jd_lengths_2023">jd_lengths_2023</a></code> using something like: <code>jd &lt;- streamDAGs("jd_piezo_full_2023"); anames &lt;- attributes(E(jd))$vnames; nnames &lt;- gsub("\\|", " -&gt; ", anames); jd_lengths_2023[which(jd_lengths_2023[,1] %in% nnames ),]</code>.</p>
</li></ul>

</li>
<li><p><code>"jd_full"</code> codifies the Johnson Draw stream network in southwestern Idaho, but only for STICs, not piezometers (outlet coordinates: 43.12256<code class="reqn">^\circ</code>N, 116.77630<code class="reqn">^\circ</code>W).  
</p>

<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "JD" &amp; AIMS.node.coords$STIC_inferred_PA</code>.
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained using <code>jd &lt;- streamDAGs("jd_full")</code> followed by <code>jd_node_pres_abs[attributes(V(jd))$names]</code>.
</p>
</li>
<li><p>Arc lengths can be obtained from <code><a href="#topic+jd_lengths">jd_lengths</a></code>.</p>
</li></ul>

</li>
<li><p><code>"konza_full"</code> provides codification of a complete intermittent stream network of Konza Prairie in the northern Flint Hills region of Kansas (outlet coordinates: 39.11394<code class="reqn">^\circ</code>N, 96.61153<code class="reqn">^\circ</code>W).  </p>
<ul>
<li><p>Network spatial coordinates for this graph can be obtained directly from <code><a href="#topic+kon_coords">kon_coords</a></code>
</p>
</li>
<li><p>Arc lengths can be obtained from <code><a href="#topic+kon_lengths">kon_lengths</a></code>.</p>
</li></ul>

</li>
<li><p>Options <code>"KD0521"</code>,<code>"KD0528"</code>, and <code>"KD0604"</code> provide networks for Konza Prairie at 05/21/2021 (before spring snow melt), 05/28/2021 (during spring snow melt) and 06/04/2021 (drying following snow melt), respectively. 
</p>
</li>
<li><p><code>"mur_full"</code> is an <em>igraph</em> codification of the complete Murphy Creek dataset from the Owyhee Mountains in SW Idaho (outlet coordinates: 43.256<code class="reqn">^\circ</code>N, 116.817<code class="reqn">^\circ</code>W) established in 2019 by Warix et al. (2021), also see Aho et al. (2023).  
</p>
<ul>
<li><p>Network spatial coordinates for the graph can be obtained directly from <code><a href="#topic+mur_coords">mur_coords</a></code>
</p>
</li>
<li><p>Nodal surface water presence/absence data for this graph can be obtained from <code><a href="#topic+mur_node_pres_abs">mur_node_pres_abs</a></code>
</p>
</li>
<li><p>Arc lengths can be obrtained from <code><a href="#topic+mur_lengths">mur_lengths</a></code>.</p>
</li></ul>

</li>
<li><p><code>"pr_full"</code> codifies the Painted Rock stream network in northern Alabama (outlet coordinates: 34.96867<code class="reqn">^\circ</code>N, 86.16544<code class="reqn">^\circ</code>W). 
</p>

<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "PR"</code>.</p>
</li></ul>

</li>
<li><p><code>"td_full"</code> codifies the Talladega stream network in central Alabama (outlet coordinates: 33.76218<code class="reqn">^\circ</code>N, 85.59552<code class="reqn">^\circ</code>W).  
</p>
<ul>
<li><p>Network spatial coordinates for this graph can be subset from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "TD"</code>.
</p>
</li></ul>

</li>
<li><p><code>"wh_full"</code> codifies the Weyerhauser stream network in western Alabama (outlet coordinates: 32.98463<code class="reqn">^\circ</code>N, 88.01227<code class="reqn">^\circ</code>W). 
</p>
<ul>
<li><p>Network spatial coordinates for this graph can be obtained from <code><a href="#topic+AIMS.node.coords">AIMS.node.coords</a></code> using: <code>AIMS.node.coords$site == "WH"</code>.</p>
</li></ul>

</li></ol>


<h3>Value</h3>

<p>Returns a graph object of class <em>igraph</em>.</p>


<h3>Author(s)</h3>

<p>Ken Aho, Maggie Kraft, Rob Ramos, Rebecca L. Hale, Charles T. Bond, Arya Legg 
</p>


<h3>References</h3>

<p>Aho, K., Derryberry, D., Godsey, S. E., Ramos, R., Warix, S., &amp; Zipper, S. (2023). The communication distance of non-perennial streams.  <em>EarthArvix</em> doi: 10.31223/X5Q367
</p>
<p>Warix, S. R., Godsey, S. E., Lohse, K. A., &amp; Hale, R. L. (2021), Influence of groundwater and topography on stream drying in semi-arid headwater streams. <em>Hydrological Processes, 35</em>(5), e14185.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streamDAGs("mur_full")
</code></pre>

<hr>
<h2 id='vector_segments'>
Functions for overlaying networks on shapefiles
</h2><span id='topic+vector_segments'></span><span id='topic+assign_pa_to_segments'></span><span id='topic+print.network_to_sf'></span>

<h3>Description</h3>

<p>The function <code>vector_segments</code> and <code>assign_pa_to_segments</code> were written to facilitate the generation of plots (including ggplots) that overlay user defined digraphs (based on arc designations) on GIS shapefiles or other tightly packed cartesian coordinate structures. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_segments(sf.coords, node.coords, realign = TRUE, arcs, arc.symbol = " --&gt; ", 
nneighbors = 40, remove.duplicates = FALSE)

assign_pa_to_segments(input, n, arc.pa, datetime = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector_segments_+3A_sf.coords">sf.coords</code></td>
<td>
<p>A two column dataframe containing shapefile Cartesian coordinates (or other tightly packed Cartesian coordinates, see Examples). The first column should define <code>x</code> locations and the second column define <code>y</code> locations.
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_node.coords">node.coords</code></td>
<td>

<p>A two column dataframe containing network node Cartesian coordinates, with the first column defining <code>x</code> location and the second column defining <code>y</code> location.  The coordinates should use the same coordinate system as <code>sf.coords</code>, e.g., UTM easting and northing, longitude and latitude, etc. The <code>row.names</code> attribute should contain the correct node names (i.e., they should correspond to names used in the argument <code>arcs</code>.
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_realign">realign</code></td>
<td>

<p>Logical.  If <code>node.coords</code> do not exist in <code>sf.coords</code> should they be assigned to the closest location in <code>sf.coords</code>?  The default option <code>realign = TRUE</code> is strongly reccomended, and may be set permenantly in later versions of <code>vector_segments</code>.
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_arcs">arcs</code></td>
<td>

<p>A character vector of arc names in the network.  In particular, designations of nodes which serve arcs bounds, seperated by a user-defined <code>arc.symbol</code>.  For example, to designate the arc <code class="reqn">\overrightarrow{uv}</code> using the <code>arc.symbol</code> <code> --&gt; </code>, I would use: <code>u --&gt; v</code>. Node names used to define arcs in the character vector should correspond to those in <code>row.names(node.coords)</code>. 
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_arc.symbol">arc.symbol</code></td>
<td>
<p>A symbol indicating the directional arc connecting two nodes. For example, to designate the arc <code class="reqn">\overrightarrow{uv}</code>, the package <em>igraph</em> uses <code>u|v</code>, while <em>streamDAG</em> generally uses <code>u --&gt; v</code>. 
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_nneighbors">nneighbors</code></td>
<td>

<p>Number of nearest neighbor points to potentially consider as the next point in an evolving arc path.  
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_remove.duplicates">remove.duplicates</code></td>
<td>

<p>Logical.  For duplicate coordinates, should the second point be removed?
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_input">input</code></td>
<td>

<p>The first argument for <code>assign_pa_to_segments</code>. Ideally, the output from <code>vector_segments</code>.  For example, let <code>output &lt;- vector_segments(...)</code>, then <code>input = output</code>.
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_n">n</code></td>
<td>

<p>The number of repeated presence/absence timeframe observations for surface water contained in <code>arc.pa</code>.  
</p>
</td></tr>
<tr><td><code id="vector_segments_+3A_arc.pa">arc.pa</code></td>
<td>

<p>An <code class="reqn">n \times m</code> matrix or dataframe of stream arc surface water presence/absence = <code class="reqn">\{0, 1\}</code> outcomes, where <code class="reqn">n</code> denotes the number of observed timeframes in which arcs were observed, and <code class="reqn">m</code> is the number of arcs.  The <code>names</code> of the dataframe should correspond to those given in the <code>arcs</code> argument from <code>vector_segments</code>.</p>
</td></tr> 
<tr><td><code id="vector_segments_+3A_datetime">datetime</code></td>
<td>
<p>Optional <code>unique()</code> time classes corresping to rows in <code>arc.pa</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>vector_segments</code> assigns network arc designations (from the argument <code>arcs</code>) to shape
file coordinates.  The function <code>assign_pa_to_segments</code> presence/absence surface water designations to these arcs based on information from <code>arc.pa</code>.
</p>


<h3>Value</h3>

<p>The function <code>vector_segments</code> creates an object of class <code>network_to_sf</code>. It also returns a list with two components, with only the first being <code>visible</code>. 
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>Is a dataframe with four columns: 1) <code>point</code> (referring an original <code>sf.coord</code> location), 2) <code>arc.label</code>, an assigned arc name for the location, 3) <code>x</code> the <em>x</em> coordinates,  and 4) <code>y</code> the <em>x</em> coordinates.</p>
</td></tr>
<tr><td><code>node.coords</code></td>
<td>
<p>Is dataframe with the <code>node.coords</code> for stream arcs.  These will have been potentially shifted, if <code>realign = TRUE</code>, hence their inclusion as function output.</p>
</td></tr>
</table>
<p>The function <code>assign_pa_to_segments</code> returns a dataframe that adds a stream/presence absence column to the to the <code>df</code> dataframe output from <code>vector_segments</code>, based on the argument <code>arc.pa</code> 
</p>


<h3>Note</h3>

<p>The <code>assign_pa_to_segments</code> function will return a <code>warning</code> (but will try to run anyway)  if <code>input</code> is not the output from <code>vector_segments</code>.  
</p>


<h3>Author(s)</h3>

<p>Ken Aho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatial.plot">spatial.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data

sfx &lt;- c(-3,0,1.5,2,2.9,4,5,6)
sfy &lt;- c(5,2,1.7,1.6,1.5,1.4,1.2,1)
sf.coords &lt;- data.frame(x = sfx, y = sfy) 
node.coords &lt;- data.frame(x = c(-2.1,2,4,6), y = c(3.75,1.6,1.4,1))
row.names(node.coords) &lt;- c("n1","n2","n3","n4") # must be consistent with arc names
arc.pa &lt;- data.frame(matrix(ncol = 3, data = c(1,1,1, 0,1,1, 1,1,1, 0,0,1), byrow = TRUE))
names(arc.pa) &lt;- c("n1 --&gt; n2", "n2 --&gt; n3", "n3 --&gt; n4")

# Use of vector_segments
vs &lt;- vector_segments(sf.coords, node.coords, realign = TRUE, names(arc.pa))
vs

# Plotting example
plot(sf.coords, pch = 19, col = c(rep(1,4),rep(2,2),rep(3,2)))

vsd &lt;- vs$df
fal &lt;- as.factor(vsd$arc.label)
lvls &lt;- levels(fal)

for(i in 1:nlevels(fal)){
  temp &lt;- vsd[fal == lvls[i],]
  lines(temp$x, temp$y, col = i) 
}

vs4 &lt;- assign_pa_to_segments(vs, 4, arc.pa)
head(vs4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
