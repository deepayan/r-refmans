<!DOCTYPE html><html><head><title>Help for package silicate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {silicate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#silicate'><p>silicate</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#ARC'><p>ARC model</p></a></li>
<li><a href='#dplyr-methods'><p>Dplyr methods for silicate objects</p></a></li>
<li><a href='#ear_gc'><p>Geometry collection of triangles</p></a></li>
<li><a href='#flight_tracks'><p>Flight tracks</p></a></li>
<li><a href='#inlandwaters'><p>Inland waters, for parts of Australia, and New Caledonia.</p></a></li>
<li><a href='#minimal_mesh'><p>Minimal mesh.</p></a></li>
<li><a href='#mmesh'><p>Deprecated data set.</p></a></li>
<li><a href='#PATH'><p>PATH model.</p></a></li>
<li><a href='#PATH0'><p>Path model in structural form</p></a></li>
<li><a href='#plot.SC'><p>Plot silicate</p></a></li>
<li><a href='#polymesh'><p>Polygonal mesh</p></a></li>
<li><a href='#print.sc'><p>Methods for silicate</p></a></li>
<li><a href='#routes'><p>Transport routes</p></a></li>
<li><a href='#SC'><p>The universal model</p></a></li>
<li><a href='#sc_arc'><p>Arc-node topology.</p></a></li>
<li><a href='#sc_colours'><p>Silicate colours</p></a></li>
<li><a href='#sc_coord'><p>Coordinate decomposition</p></a></li>
<li><a href='#sc_edge'><p>Edges.</p></a></li>
<li><a href='#sc_node'><p>Nodes for arc-node topology.</p></a></li>
<li><a href='#sc_object'><p>Objects, features</p></a></li>
<li><a href='#sc_path'><p>Path decomposition</p></a></li>
<li><a href='#sc_segment'><p>Given a 'PATH&ldquo; model decompose to 1-dimensional primitives (or 0-dimensional).</p></a></li>
<li><a href='#sc_uid'><p>Unique labels</p></a></li>
<li><a href='#sc_vertex'><p>Extract unique vertices</p></a></li>
<li><a href='#SC0'><p>Pure edge model, structural form</p></a></li>
<li><a href='#sfzoo'><p>Simple features zoo.</p></a></li>
<li><a href='#TRI'><p>TRI model, triangulations</p></a></li>
<li><a href='#tri_area'><p>Area of triangles</p></a></li>
<li><a href='#TRI0'><p>TRI0 model, structural triangulations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Common Forms for Complex Hierarchical and Relational Data
Structures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate common data forms for complex data suitable for conversions and
 transmission by decomposition as paths or primitives. Paths are sequentially-linked records, 
 primitives are basic atomic elements and both can model many forms and be grouped into hierarchical 
 structures.  The universal models 'SC0' (structural) and 'SC' (labelled, relational) are composed of 
 edges and can represent any hierarchical form. Specialist models 'PATH', 'ARC' and 'TRI' provide the 
 most common intermediate forms used for converting from one form to another. The methods are
 inspired by the simplicial complex <a href="https://en.wikipedia.org/wiki/Simplicial_complex">https://en.wikipedia.org/wiki/Simplicial_complex</a> and 
 provide intermediate forms that relate spatial data structures to this mathematical construct. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, sp, testthat (&ge; 2.1.0), trip, vdiffr</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, gibble (&ge; 0.4.0), methods, purrr, rlang, decido,
tibble, unjoin (&ge; 0.1.0), grDevices, graphics, stats,
magrittr, gridBase, crsmeta (&ge; 0.3.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hypertidy/silicate">https://github.com/hypertidy/silicate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hypertidy/silicate/issues">https://github.com/hypertidy/silicate/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-03 10:57:19 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre],
  John Corbett [ctb] (the original inspiration),
  Simon Wotherspoon [ctb],
  Kent Johnson [dtc],
  Mark Padgham [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 18:50:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='silicate'>silicate</h2><span id='topic+silicate'></span><span id='topic+silicate-package'></span>

<h3>Description</h3>

<p>Decomposes spatial data (of various formats) into simpler forms, including
paths, triangles or segments. A development tool for exploring the underlying
structures of spatial data, and for converting it to something else. The models
<code><a href="#topic+PATH">PATH()</a></code>, <code><a href="#topic+TRI">TRI()</a></code>, <code><a href="#topic+SC">SC()</a></code> and <code><a href="#topic+ARC">ARC()</a></code> provide relational tables of all underlying
entities, and more specialist versions <code><a href="#topic+PATH0">PATH0()</a></code>, <code><a href="#topic+TRI0">TRI0()</a></code> and <code><a href="#topic+SC0">SC0()</a></code> provide more
efficient topological representations of polygons or lines.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='ARC'>ARC model</h2><span id='topic+ARC'></span><span id='topic+ARC.default'></span><span id='topic+ARC.PATH'></span>

<h3>Description</h3>

<p>Arcs are unique paths that connect nodes. In a polygon layer with shared boundaries, the
arcs are the linear features that have no branches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARC(x, ...)

## Default S3 method:
ARC(x, ...)

## S3 method for class 'PATH'
ARC(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARC_+3A_x">x</code></td>
<td>
<p>input model</p>
</td></tr>
<tr><td><code id="ARC_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nodes are the vertices where three or more arcs meet. An arc can exist without including
any nodes, a path that has no neighbouring relationship with another path.
</p>
<p>This is <em>not</em> the same terminology as used by other systems, such as &quot;arc-node&quot;. The
<code>arc_link_vertex</code> mapping is inherently ordered, but we don't consider order of arcs.
Duplicated arcs (i.e. complementary turns around neighbouring polygons) are not kept.
The <code>object_link_arc</code> mapping records which arc belongs to the objects, so feature polygons
can in theory be reconstructed within objects by tracing <code>arc_link_vertex</code> start and end point
identity.
</p>


<h3>Value</h3>

<p>ARC model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- ARC(minimal_mesh)
sc_arc(a)
sc_arc(minimal_mesh)
</code></pre>

<hr>
<h2 id='dplyr-methods'>Dplyr methods for silicate objects</h2><span id='topic+dplyr-methods'></span><span id='topic+filter.SC'></span><span id='topic+filter'></span>

<h3>Description</h3>

<p>Filter an SC model, currently only <code>dplyr::filter</code> for <code>SC</code> is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SC'
filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr-methods_+3A_.data">.data</code></td>
<td>
<p>data object of class SC</p>
</td></tr>
<tr><td><code id="dplyr-methods_+3A_...">...</code></td>
<td>
<p>passed to <code>dplyr::filter</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply expressions as if used on the <code>object</code> table. See <code>sc_object(x)</code> for that form.
</p>
<p>Currently all the vertices are still kept, so the model (and any plots) include the filtered edges as well
as undifferentiated points. This is likely to change ...
</p>


<h3>Value</h3>

<p>an <code><a href="#topic+SC">SC()</a></code> model, with some parts filtered out
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
sc &lt;- SC(inlandwaters)
plot(filter(sc, Province == "Tasmania"))
plot(filter(sc, Province %in% c("Victoria", "South Australia", "New South Wales")))

plot(filter(SC(minimal_mesh), a == 1))
</code></pre>

<hr>
<h2 id='ear_gc'>Geometry collection of triangles</h2><span id='topic+ear_gc'></span>

<h3>Description</h3>

<p>A 'sfc_GEOMETRYCOLLECTION' of four-cornered triangles ('POLYGON')
created by ear cutting the North Carolina polygon from sf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRI0(ear_gc)
</code></pre>

<hr>
<h2 id='flight_tracks'>Flight tracks</h2><span id='topic+flight_tracks'></span>

<h3>Description</h3>

<p>A data set flight tracks in XYZM form, a form of 4D tracks. Primarily to
explore the use of <code>silicate</code> as able to represent this topologically,  and to experiment with
auto-time-based plotting in <code>anglr</code>.
</p>


<h3>Details</h3>

<p>Provided by  Kent Johnson (kent37) in a
<a href="https://github.com/r-spatial/mapview/issues/99#issuecomment-328711275">github discusion</a>
where the data was attached in a zip file.
</p>
<p>Original form (in extdata/flight_tracks) is a XYZM LINESTRING shapefile
containing 144 flight tracks of aircraft departing runway 33L at Boston Logan
airport on January 27, 2017. Data is from an ADS-B recorder. Each point includes
lat, lon, altitude in feet and time in North American Eastern Standard Time
(EST).
</p>
<p>Converted via <code>sf</code> into <code>silicate::PATH</code> normal form, see (data-raw/flight_tracks.R).
</p>

<hr>
<h2 id='inlandwaters'>Inland waters, for parts of Australia, and New Caledonia.</h2><span id='topic+inlandwaters'></span>

<h3>Description</h3>

<p>The inland waters are lakes and inland waters presenting as holes
within the bounded regions of Australian (and New Caledonian) provinces.
</p>


<h3>Details</h3>

<p>This is an extract from the old Manifold DVD. It is in <code>sf</code> format<code style="white-space: pre;">&#8288;. The features have variables &#8288;</code>ID<code>and</code>Province' they are (in order):
</p>

<ul>
<li><p>&quot;103841&quot;Australian Capital Territory
</p>
</li>
<li><p>&quot;103842&quot;New Caledonia
</p>
</li>
<li><p>&quot;103843&quot;New South Wales
</p>
</li>
<li><p>&quot;103846&quot;South Australia
</p>
</li>
<li><p>&quot;103847&quot;Tasmania
</p>
</li>
<li><p>&quot;103848&quot;Victoria
</p>
</li></ul>

<p>There's no good reason that New Caledonia is included and not Queensland (for example)
it's just what happened doing a quick crop and extract with the mouse. Lord Howe Island and
Macquarie Island are both present, as part of New South Wales and Tasmania respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- PATH(inlandwaters)
plot(path)
obj &lt;- split(path$path_link_vertex, path$path_link_vertex$path_)
cl &lt;- grDevices::colors()[-1L]
cols &lt;- sample(cl, length(obj), replace = length(obj) &gt; length(cl))
op &lt;- par(mfrow = grDevices::n2mfrow(length(obj)), mar = rep(0, 4))
funplot &lt;- function(ob, vert, col) {
vx &lt;- c("x_", "y_")
  plot(dplyr::inner_join(ob, vert, "vertex_")[vx], col = col, type = "l", axes = FALSE)
  }
junk &lt;- lapply(seq_along(obj),
function(a) {
  funplot(obj[[a]], path$vertex, cols[a])
  invisible(NULL)
  })
  par(op)
 
</code></pre>

<hr>
<h2 id='minimal_mesh'>Minimal mesh.</h2><span id='topic+minimal_mesh'></span>

<h3>Description</h3>

<p>The simplest pairing of two polygons with one shared edge. One polygon
contains a hole and a concavity, the other is a simply convex. This is
composed of four &quot;arcs&quot;, one around each polygon, one for the shared edge, and
one for the isolated hole. There are two nodes, the endpoints of the single shared edge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arc &lt;- ARC(minimal_mesh)
plot(arc)
sc_arc(arc)
sc_node(arc)
</code></pre>

<hr>
<h2 id='mmesh'>Deprecated data set.</h2><span id='topic+mmesh'></span>

<h3>Description</h3>

<p>This data set is in legacy format and will be removed.
A couple of polygons with a single shared edge between them, in
PRIMITIVE form.
</p>

<hr>
<h2 id='PATH'>PATH model.</h2><span id='topic+PATH'></span><span id='topic+PATH.SC'></span><span id='topic+PATH.TRI'></span><span id='topic+PATH.default'></span>

<h3>Description</h3>

<p>A PATH model is a direct translation of a simple features-alike
object to normal form. This is four tables with the three kinds of entities,
&quot;objects&quot; (or &quot;features&quot;), &quot;paths&quot; (or &quot;parts&quot;) and &quot;vertices&quot;, and a table
to link the one-to-many relation between paths and vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PATH(x, ...)

## S3 method for class 'SC'
PATH(x, ...)

## S3 method for class 'TRI'
PATH(x, ...)

## Default S3 method:
PATH(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PATH_+3A_x">x</code></td>
<td>
<p>input model</p>
</td></tr>
<tr><td><code id="PATH_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a data set with no parts touching their  neighbours, the only normalization of the vertices
will be the removal of the duplicated closing coordinate on any polygon ring, and on
any self-intersecting case within a single path.
</p>
<p><code>PATH()$path</code> should always have columns <code style="white-space: pre;">&#8288;object_ path_ subobject ncoords_&#8288;</code>
</p>


<h3>Value</h3>

<p>a PATH model, with tables 'object', 'path', 'path_link_vertex' and 'vertex'
</p>


<h3>See Also</h3>

<p><code>sc_path</code>, <code>sc_coord</code>
</p>

<hr>
<h2 id='PATH0'>Path model in structural form</h2><span id='topic+PATH0'></span><span id='topic+PATH0.default'></span><span id='topic+PATH0.PATH0'></span><span id='topic+PATH0_from_df'></span>

<h3>Description</h3>

<p>Structural form requires only tables 'object' and 'vertex'.
</p>
<p>Minimal columns is x,y but can be grouped by path_ for separate paths, then subobject_ and object_ for full polygon support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PATH0(x, ...)

## Default S3 method:
PATH0(x, ...)

## S3 method for class 'PATH0'
PATH0(x, ...)

PATH0_from_df(
  x,
  ...,
  path_ = "path_",
  object_ = "object_",
  subobject_ = "subobject_",
  x_ = "x",
  y_ = "y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PATH0_+3A_x">x</code></td>
<td>
<p>data frame with at least x, y columns</p>
</td></tr>
<tr><td><code id="PATH0_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="PATH0_+3A_path_">path_</code></td>
<td>
<p>path identifier, these should identify individual paths</p>
</td></tr>
<tr><td><code id="PATH0_+3A_object_">object_</code></td>
<td>
<p>object identifier (like group in ggplot)</p>
</td></tr>
<tr><td><code id="PATH0_+3A_subobject_">subobject_</code></td>
<td>
<p>subobject identifier (like polygon_id with multipolygons in sfheaders)</p>
</td></tr>
<tr><td><code id="PATH0_+3A_x_">x_</code></td>
<td>
<p>optional name for x column (assumed to be x)</p>
</td></tr>
<tr><td><code id="PATH0_+3A_y_">y_</code></td>
<td>
<p>optional name for x column (assumed to be y)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists as a special-case for non-format input for <code><a href="#topic+PATH0">PATH0()</a></code>. It's expected there
are columns x, y, and optionally object_, subobject_, and path_. These correspond to
names in sfheaders, multipolygon_id, polygon_id, and linestring_id. (subobject is optional if
not multipolygon).
</p>


<h3>Value</h3>

<p>PATH0 model with tables 'object' and 'vertex'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(p &lt;- PATH0(minimal_mesh))

p$object$topology_
PATH0_from_df(data.frame(x = runif(10), y = runif(10)))
</code></pre>

<hr>
<h2 id='plot.SC'>Plot silicate</h2><span id='topic+plot.SC'></span><span id='topic+plot.SC0'></span>

<h3>Description</h3>

<p>Basic edge plot, all the standard base graphics facilities for line segments are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SC'
plot(x, ..., add = FALSE)

## S3 method for class 'SC0'
plot(x, ..., add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SC_+3A_x">x</code></td>
<td>
<p>sc object</p>
</td></tr>
<tr><td><code id="plot.SC_+3A_...">...</code></td>
<td>
<p>arguments passed to lower level plotting functions</p>
</td></tr>
<tr><td><code id="plot.SC_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code> add to current plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'col' argument is passed directly to <code><a href="graphics.html#topic+segments">segments()</a></code>  or <code><a href="graphics.html#topic+polypath">polypath()</a></code> as needed, in the usual
one-to-one or recycling way.
</p>
<p>Graphical parameters are not able to be passed to the initial plot setup, but a plot
can be set up and then added to with this method.
</p>

<hr>
<h2 id='polymesh'>Polygonal mesh</h2><span id='topic+polymesh'></span>

<h3>Description</h3>

<p>A simple set of <code>sf</code> neighbouring polygons, with redundant vertices created
from polygonizing a raster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arc &lt;- ARC(polymesh)
plot(arc)
sc &lt;- SC(polymesh)
plot(sc)
</code></pre>

<hr>
<h2 id='print.sc'>Methods for silicate</h2><span id='topic+print.sc'></span>

<h3>Description</h3>

<p>Print a silicate model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sc_+3A_x">x</code></td>
<td>
<p>object inheriting from 'sc' class</p>
</td></tr>
<tr><td><code id="print.sc_+3A_...">...</code></td>
<td>
<p>ignore currently</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple summary of type and content of a silicate model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(TRI(minimal_mesh))
print(SC(minimal_mesh))
print(PATH(minimal_mesh))
print(SC(TRI(minimal_mesh)))
print(ARC(minimal_mesh))
print(SC0(minimal_mesh))
</code></pre>

<hr>
<h2 id='routes'>Transport routes</h2><span id='topic+routes'></span>

<h3>Description</h3>

<p>Routing data set stolen from stplanr
see data-raw/routes.R
</p>

<hr>
<h2 id='SC'>The universal model</h2><span id='topic+SC'></span><span id='topic+SC.default'></span><span id='topic+SC.TRI'></span><span id='topic+SC.pslg'></span>

<h3>Description</h3>

<p>The universal model <code>SC</code> is coordinates and binary relations between
pairs of coordinates. This is purely an edge (or segment) model, with all
higher level structures recorded as groupings of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SC(x, ...)

## Default S3 method:
SC(x, ...)

## S3 method for class 'TRI'
SC(x, ...)

## S3 method for class 'pslg'
SC(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SC_+3A_x">x</code></td>
<td>
<p>input model</p>
</td></tr>
<tr><td><code id="SC_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SC model with tables 'object', 'object_link_edge', 'edge', and 'vertex'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## we can produce a high quality triangulation from a low quality one
## see how the TRI edges are maintained (we can't yet filter out holes from DEL)
tri &lt;- TRI(minimal_mesh)
plot(tri)
plot(SC(tri))
</code></pre>

<hr>
<h2 id='sc_arc'>Arc-node topology.</h2><span id='topic+sc_arc'></span><span id='topic+sc_arc.default'></span><span id='topic+sc_arc.ARC'></span>

<h3>Description</h3>

<p>Return a label and vertex count of each arc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_arc(x, ...)

## Default S3 method:
sc_arc(x, ...)

## S3 method for class 'ARC'
sc_arc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_arc_+3A_x">x</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="sc_arc_+3A_...">...</code></td>
<td>
<p>arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arcs are unbranched paths within the line segment graph. Nodes are the vertices where three or more arcs meet.
</p>
<p>As with the <code>PATH</code> and <code>SC</code> models the arc id values will only be relevant when
those entities are identified and labelled. Running <code>sc_arc</code> on a simple features model (for example) will
identify them and return a summary, but without having any record of what they refer to. Use <code>ARC(x)</code> first to
work with models that don't included labels.
</p>


<h3>Value</h3>

<p>a data frame with only the identities of the shared boundaries (arcs)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_arc(minimal_mesh)
ARC(minimal_mesh)[["arc"]]

arc &lt;- ARC(minimal_mesh)
plot(arc)
points(arc$vertex[match(sc_node(arc)$vertex_, arc$vertex$vertex_), c("x_", "y_")])

arc &lt;- ARC(polymesh)
plot(arc)
title("arcs and nodes")
points(arc$vertex[match(sc_node(arc)$vertex_, arc$vertex$vertex_), c("x_", "y_")])
</code></pre>

<hr>
<h2 id='sc_colours'>Silicate colours</h2><span id='topic+sc_colours'></span>

<h3>Description</h3>

<p>Simple set of colours for discrete palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_colours(x = 16, ..., viridis = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_colours_+3A_x">x</code></td>
<td>
<p>number of colours to generate</p>
</td></tr>
<tr><td><code id="sc_colours_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="sc_colours_+3A_viridis">viridis</code></td>
<td>
<p>use viridis, TRUE or FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of colours
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_colours(10)
</code></pre>

<hr>
<h2 id='sc_coord'>Coordinate decomposition</h2><span id='topic+sc_coord'></span><span id='topic+sc_coord.list'></span><span id='topic+sc_coord.default'></span><span id='topic+sc_coord.matrix'></span><span id='topic+sc_coord.ARC'></span><span id='topic+sc_coord.PATH'></span><span id='topic+sc_coord.TRI'></span><span id='topic+sc_coord.PATH0'></span><span id='topic+sc_coord.SC0'></span><span id='topic+sc_coord.SC'></span><span id='topic+sc_coord.sf'></span><span id='topic+sc_coord.sfc'></span><span id='topic+sc_coord.pslg'></span><span id='topic+sc_coord.MULTIPOLYGON'></span><span id='topic+sc_coord.POLYGON'></span><span id='topic+sc_coord.MULTILINESTRING'></span><span id='topic+sc_coord.LINESTRING'></span><span id='topic+sc_coord.MULTIPOINT'></span><span id='topic+sc_coord.POINT'></span><span id='topic+sc_coord.Spatial'></span><span id='topic+sc_coord.Polygons'></span><span id='topic+sc_coord.Lines'></span>

<h3>Description</h3>

<p>Collect all instances of all coordinates in one table. This complementary to the <code>sc_path</code> of
an object, since the number of coordinates per path gives a structural mapping into this set.
</p>
<p>Collect all coordinates in one table, the path_link_vertex table
has the information about the original grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_coord(x, ...)

## S3 method for class 'list'
sc_coord(x, ...)

## Default S3 method:
sc_coord(x, ...)

## S3 method for class 'matrix'
sc_coord(x, ...)

## S3 method for class 'ARC'
sc_coord(x, ...)

## S3 method for class 'PATH'
sc_coord(x, ...)

## S3 method for class 'TRI'
sc_coord(x, ...)

## S3 method for class 'PATH0'
sc_coord(x, ...)

## S3 method for class 'SC0'
sc_coord(x, ...)

## S3 method for class 'SC'
sc_coord(x, ...)

## S3 method for class 'sf'
sc_coord(x, ...)

## S3 method for class 'sfc'
sc_coord(x, ...)

## S3 method for class 'pslg'
sc_coord(x, ...)

## S3 method for class 'MULTIPOLYGON'
sc_coord(x, ...)

## S3 method for class 'POLYGON'
sc_coord(x, ...)

## S3 method for class 'MULTILINESTRING'
sc_coord(x, ...)

## S3 method for class 'LINESTRING'
sc_coord(x, ...)

## S3 method for class 'MULTIPOINT'
sc_coord(x, ...)

## S3 method for class 'POINT'
sc_coord(x, ...)

## S3 method for class 'Spatial'
sc_coord(x, ...)

## S3 method for class 'Polygons'
sc_coord(x, ...)

## S3 method for class 'Lines'
sc_coord(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_coord_+3A_x">x</code></td>
<td>
<p>input model</p>
</td></tr>
<tr><td><code id="sc_coord_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of all the coordinates in the order they occur
</p>


<h3>See Also</h3>

<p><code>sc_path</code> for the central part of the model, <code>sc_object</code> for
the features, and <code>PATH</code> for the full model.
</p>
<p><code>sc_path</code> for the central part of the model, <code>sc_object</code> for
the features, and <code>PATH</code> for the full model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_coord(minimal_mesh)
sc_coord(SC(minimal_mesh))
</code></pre>

<hr>
<h2 id='sc_edge'>Edges.</h2><span id='topic+sc_edge'></span><span id='topic+sc_start'></span><span id='topic+sc_end'></span><span id='topic+sc_edge.default'></span><span id='topic+sc_edge.PATH'></span><span id='topic+sc_start.SC'></span><span id='topic+sc_start.SC0'></span><span id='topic+sc_start.PATH'></span><span id='topic+sc_end.PATH'></span><span id='topic+sc_start.PATH0'></span><span id='topic+sc_end.PATH0'></span><span id='topic+sc_start.ARC'></span><span id='topic+sc_start.TRI'></span><span id='topic+sc_end.SC'></span><span id='topic+sc_end.SC0'></span><span id='topic+sc_end.ARC'></span><span id='topic+sc_end.TRI'></span>

<h3>Description</h3>

<p>Simple binary relationships, a primitive composed of two vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_edge(x, ...)

## Default S3 method:
sc_edge(x, ...)

## S3 method for class 'PATH'
sc_edge(x, ...)

sc_start(x, ...)

## S3 method for class 'SC'
sc_start(x, ...)

## S3 method for class 'SC0'
sc_start(x, ...)

## S3 method for class 'PATH'
sc_start(x, ...)

## S3 method for class 'PATH'
sc_end(x, ...)

## S3 method for class 'PATH0'
sc_start(x, ...)

## S3 method for class 'PATH0'
sc_end(x, ...)

## S3 method for class 'ARC'
sc_start(x, ...)

## S3 method for class 'TRI'
sc_start(x, ...)

sc_end(x, ...)

## S3 method for class 'SC'
sc_end(x, ...)

## S3 method for class 'SC0'
sc_end(x, ...)

## S3 method for class 'ARC'
sc_end(x, ...)

## S3 method for class 'TRI'
sc_end(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_edge_+3A_x">x</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="sc_edge_+3A_...">...</code></td>
<td>
<p>arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edges are unique, undirected line segments. Compare to <code>sc_segment</code> which refers to all
instances of edges.
</p>
<p><code>sc_start</code> and <code>sc_end</code> are convenience functions that provide the obvious
start and end coordinates by joining on the appropriate edge vertex label, <code>.vx0</code>
or <code>.vx1</code>. Currently this returns the ordered segments, along with their unique (unordered) <code>edge_</code>, as
well as unique <code>segment</code>, a <code>object_</code> labels.
</p>


<h3>Value</h3>

<p>data frame of edge identity, or start/end coordinates
</p>

<hr>
<h2 id='sc_node'>Nodes for arc-node topology.</h2><span id='topic+sc_node'></span><span id='topic+sc_node.SC'></span><span id='topic+sc_node.SC0'></span><span id='topic+sc_node.default'></span><span id='topic+sc_node.PATH'></span><span id='topic+sc_node.ARC'></span>

<h3>Description</h3>

<p>Nodes are the vertices in the graph that are shared by &quot;arcs&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_node(x, ...)

## S3 method for class 'SC'
sc_node(x, ...)

## S3 method for class 'SC0'
sc_node(x, ...)

## Default S3 method:
sc_node(x, ...)

## S3 method for class 'PATH'
sc_node(x, ...)

## S3 method for class 'ARC'
sc_node(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_node_+3A_x">x</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="sc_node_+3A_...">...</code></td>
<td>
<p>arguments for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of the nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_node(ARC(minimal_mesh))
sc &lt;- SC(routes)
library(dplyr)
plot(sc)
sc_node(sc) %&gt;% inner_join(sc$vertex) %&gt;% select(x_, y_) %&gt;% points()
</code></pre>

<hr>
<h2 id='sc_object'>Objects, features</h2><span id='topic+sc_object'></span><span id='topic+sc_object.default'></span><span id='topic+sc_object.sf'></span><span id='topic+sc_object.sfc'></span><span id='topic+sc_object.TRI'></span>

<h3>Description</h3>

<p>The objects are the front end entities, the usual &quot;GIS contract&quot; objects,
or features.
</p>
<p>The objects are the front end entities, the usual &quot;GIS contract&quot; objects,
the features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_object(x, ...)

## Default S3 method:
sc_object(x, ...)

## S3 method for class 'sf'
sc_object(x, ...)

## S3 method for class 'sfc'
sc_object(x, ...)

## S3 method for class 'TRI'
sc_object(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_object_+3A_x">x</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="sc_object_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of the object values
</p>


<h3>See Also</h3>

<p><code>sc_coord</code> for the coordinates part of the model, <code>sc_path</code> for
the central part of the model, and <code>PATH</code> for the full model.
</p>
<p><code>sc_coord</code> for the coordinates part of the model, <code>sc_path</code> for
the central part of the model, and <code>PATH</code> for the full model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_object(minimal_mesh)
sc_object(SC0(minimal_mesh))
</code></pre>

<hr>
<h2 id='sc_path'>Path decomposition</h2><span id='topic+sc_path'></span><span id='topic+sc_path.list'></span><span id='topic+sc_path.default'></span><span id='topic+sc_path.PATH'></span><span id='topic+sc_path.sfc_TIN'></span><span id='topic+sc_path.PATH0'></span><span id='topic+sc_path.ARC'></span><span id='topic+sc_path.SC'></span><span id='topic+sc_path.SC0'></span><span id='topic+sc_path.matrix'></span><span id='topic+sc_path.sf'></span><span id='topic+sc_path.sfc'></span><span id='topic+sc_path.MULTIPOLYGON'></span><span id='topic+sc_path.POLYGON'></span><span id='topic+sc_path.LINESTRING'></span><span id='topic+sc_path.MULTILINESTRING'></span><span id='topic+sc_path.POINT'></span><span id='topic+sc_path.MULTIPOINT'></span><span id='topic+sc_path.GEOMETRYCOLLECTION'></span><span id='topic+sc_path.Spatial'></span>

<h3>Description</h3>

<p>Start in the middle, and build the 'path-link-vertex' table.
</p>
<p>Paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_path(x, ...)

## S3 method for class 'list'
sc_path(x, ids = NULL, ...)

## Default S3 method:
sc_path(x, ...)

## S3 method for class 'PATH'
sc_path(x, ...)

## S3 method for class 'sfc_TIN'
sc_path(x, ...)

## S3 method for class 'PATH0'
sc_path(x, ...)

## S3 method for class 'ARC'
sc_path(x, ...)

## S3 method for class 'SC'
sc_path(x, ...)

## S3 method for class 'SC0'
sc_path(x, ...)

## S3 method for class 'matrix'
sc_path(x, ...)

## S3 method for class 'sf'
sc_path(x, ids = NULL, ...)

## S3 method for class 'sfc'
sc_path(x, ids = NULL, ...)

## S3 method for class 'MULTIPOLYGON'
sc_path(x, ...)

## S3 method for class 'POLYGON'
sc_path(x, ...)

## S3 method for class 'LINESTRING'
sc_path(x, ...)

## S3 method for class 'MULTILINESTRING'
sc_path(x, ...)

## S3 method for class 'POINT'
sc_path(x, ...)

## S3 method for class 'MULTIPOINT'
sc_path(x, ...)

## S3 method for class 'GEOMETRYCOLLECTION'
sc_path(x, ...)

## S3 method for class 'Spatial'
sc_path(x, ids = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_path_+3A_x">x</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="sc_path_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="sc_path_+3A_ids">ids</code></td>
<td>
<p>object id, one for each object in the <code>sfc</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Paths have properties of their type, their number of vertices, their geometric
dimension and which object they occur in.
</p>


<h3>Value</h3>

<p>data frame of path identity and properties
</p>


<h3>See Also</h3>

<p><code>sc_coord</code> for the coordinates part of the model, <code>sc_object</code> for
the features, and <code>PATH</code> for the full model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_path(minimal_mesh)
sc_path(PATH(minimal_mesh))
sc_path(sfzoo$multipolygon)
sc_path(sfzoo$polygon)
sc_path(sfzoo$linestring)
sc_path(sfzoo$multilinestring)
sc_path(sfzoo$point)
sc_path(sfzoo$multipoint)
sc_path(sfzoo$multipoint)
</code></pre>

<hr>
<h2 id='sc_segment'>Given a 'PATH&ldquo; model decompose to 1-dimensional primitives (or 0-dimensional).</h2><span id='topic+sc_segment'></span><span id='topic+sc_segment.default'></span><span id='topic+sc_segment.PATH'></span>

<h3>Description</h3>

<p>Given a 'PATH&ldquo; model decompose to 1-dimensional primitives (or 0-dimensional).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_segment(x, ...)

## Default S3 method:
sc_segment(x, ...)

## S3 method for class 'PATH'
sc_segment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_segment_+3A_x">x</code></td>
<td>
<p>input object</p>
</td></tr>
<tr><td><code id="sc_segment_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of the segments, each occurence of an edge and its order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_segment(SC(minimal_mesh))
</code></pre>

<hr>
<h2 id='sc_uid'>Unique labels</h2><span id='topic+sc_uid'></span>

<h3>Description</h3>

<p>Find unique labels for entities, or create them
if not present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_uid(x, ..., uid_nchar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_uid_+3A_x">x</code></td>
<td>
<p>number of unique IDs to generate</p>
</td></tr>
<tr><td><code id="sc_uid_+3A_...">...</code></td>
<td>
<p>reserved for future use</p>
</td></tr>
<tr><td><code id="sc_uid_+3A_uid_nchar">uid_nchar</code></td>
<td>
<p>number of raw characters to paste as a uuid, default is 6 (only if silicate.uid.type is &quot;uuid&quot;, see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'integers' default we generate sequential integers, it's assumed that all IDs are created
at one time, we are not adding to an existing set. Code that adds IDs should find
the largest existing ID and offset these by that value.
</p>
<p>Using 'silicate.uid.type=&quot;uuid&quot;' is the default. Using 'silicate.uid.type=&quot;integer&quot;' is considered experimental.
By default UIDs are a mix of letters, LETTERS and digits of length <code>getOption("silicate.uid.size")</code> which defaults to 6.
</p>
<p>See <code>ids</code> package for <code>random_id</code> used if option 'silicate.uid.type=&quot;uuid&quot;'.
</p>


<h3>Value</h3>

<p>vector of unique id values for elements in the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_uid(data.frame(1:10))
</code></pre>

<hr>
<h2 id='sc_vertex'>Extract unique vertices</h2><span id='topic+sc_vertex'></span><span id='topic+sc_vertex.default'></span><span id='topic+sc_vertex.SC'></span><span id='topic+sc_vertex.SC0'></span><span id='topic+sc_vertex.ARC'></span><span id='topic+sc_vertex.TRI'></span><span id='topic+sc_vertex.TRI0'></span><span id='topic+sc_vertex.PATH'></span><span id='topic+sc_vertex.PATH0'></span><span id='topic+sc_vertex.pslg'></span>

<h3>Description</h3>

<p>Extract unique vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_vertex(x, ...)

## Default S3 method:
sc_vertex(x, ...)

## S3 method for class 'SC'
sc_vertex(x, ...)

## S3 method for class 'SC0'
sc_vertex(x, ...)

## S3 method for class 'ARC'
sc_vertex(x, ...)

## S3 method for class 'TRI'
sc_vertex(x, ...)

## S3 method for class 'TRI0'
sc_vertex(x, ...)

## S3 method for class 'PATH'
sc_vertex(x, ...)

## S3 method for class 'PATH0'
sc_vertex(x, ...)

## S3 method for class 'pslg'
sc_vertex(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_vertex_+3A_x">x</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="sc_vertex_+3A_...">...</code></td>
<td>
<p>passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of only the unique coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sc_vertex(minimal_mesh)
sc_vertex(SC0(minimal_mesh))
</code></pre>

<hr>
<h2 id='SC0'>Pure edge model, structural form</h2><span id='topic+SC0'></span><span id='topic+SC0.default'></span><span id='topic+SC0.pslg'></span>

<h3>Description</h3>

<p><code>SC0</code> is the simplest and most general of all silicate models. Composed of
an <code>object</code> and <code>vertex</code> table linked by nested vertex-index pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SC0(x, ...)

## Default S3 method:
SC0(x, ...)

## S3 method for class 'pslg'
SC0(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SC0_+3A_x">x</code></td>
<td>
<p>an object understood by silicate</p>
</td></tr>
<tr><td><code id="SC0_+3A_...">...</code></td>
<td>
<p>reserved for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SC0 model with tables 'object' and 'vertex'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SC0(minimal_mesh)
SC0(minimal_mesh)
</code></pre>

<hr>
<h2 id='sfzoo'>Simple features zoo.</h2><span id='topic+sfzoo'></span><span id='topic+sfgc'></span>

<h3>Description</h3>

<p>Basic examples of each type of simple feature geometry. <code>sfzoo</code> is a list
with each of <em>point</em>, <em>multipoin</em>, <em>linestring</em>, <em>multilinestring</em>, <em>polygon</em> and
<em>multipolygon</em>. <code>sfgc</code> is a <em>GEOMETRYCOLLECTION</em> of all the types in <code>sfzoo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lapply(sfzoo, sc_coord)
lapply(sfzoo, sc_path)

## unsure how useful this is ...
sc_path(sfgc)
</code></pre>

<hr>
<h2 id='TRI'>TRI model, triangulations</h2><span id='topic+TRI'></span><span id='topic+TRI.sfc_GEOMETRYCOLLECTION'></span><span id='topic+plot.TRI'></span>

<h3>Description</h3>

<p>TRI creates a constrained triangulation using 'ear-cutting', or 'ear-clipping' of
polygons. The model is a 'relational' form in that the underlying tables are
linked implicitly by unique identifiers.
Ear-cutting is inherently path-based, so this model is only available for
path-based structures, like simple features, <code><a href="#topic+PATH">PATH()</a></code>, <code><a href="#topic+PATH0">PATH0()</a></code> and <code><a href="#topic+ARC">ARC()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRI(x, ...)

## S3 method for class 'sfc_GEOMETRYCOLLECTION'
TRI(x, ...)

## S3 method for class 'TRI'
plot(x, ..., add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRI_+3A_x">x</code></td>
<td>
<p>object understood by silicate (sf, sp, a silicate model, etc.)</p>
</td></tr>
<tr><td><code id="TRI_+3A_...">...</code></td>
<td>
<p>current unused</p>
</td></tr>
<tr><td><code id="TRI_+3A_add">add</code></td>
<td>
<p>logical create  new plot (default), or add to existing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRI model with tables 'object', 'triangle', 'vertex'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tri &lt;- TRI(minimal_mesh)
plot(tri)
</code></pre>

<hr>
<h2 id='tri_area'>Area of triangles</h2><span id='topic+tri_area'></span>

<h3>Description</h3>

<p>Input is x,y matrix in triplets, with 3 rows per triangle vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri_area(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri_area_+3A_x">x</code></td>
<td>
<p>matrix of triangle coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, area of triangles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pts &lt;- structure(c(5L, 3L, 1L, 4L, 4L, 8L, 6L, 9L), .Dim = c(4L, 2L))
tri &lt;- c(2, 1, 3, 2, 4, 1)
(a &lt;- tri_area(pts[tri, ]))
plot(pts)
polygon(pts[head(as.vector(rbind(matrix(tri, nrow = 3), NA)), -1), ])
text(tapply(pts[tri,1], rep(1:2, each = 3), mean),
     tapply(pts[tri,2], rep(1:2, each = 3), mean), labels = sprintf("area: %0.1f", a))
</code></pre>

<hr>
<h2 id='TRI0'>TRI0 model, structural triangulations</h2><span id='topic+TRI0'></span><span id='topic+TRI0.default'></span><span id='topic+TRI0.mesh3d'></span><span id='topic+TRI0.TRI0'></span><span id='topic+TRI0.sfc_TIN'></span><span id='topic+TRI0.TRI'></span><span id='topic+TRI0.PATH0'></span><span id='topic+TRI0.PATH'></span><span id='topic+TRI0.sf'></span><span id='topic+TRI0.sfc_GEOMETRYCOLLECTION'></span>

<h3>Description</h3>

<p>TRI0 creates a constrained triangulation using 'ear-cutting', or 'ear-clipping' of
polygons. It is a 'structural' form, a denser storage mode than 'relational'
as used by <code><a href="#topic+TRI">TRI()</a></code>, we trade some generality for size and speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRI0(x, ...)

## Default S3 method:
TRI0(x, ...)

## S3 method for class 'mesh3d'
TRI0(x, ...)

## S3 method for class 'TRI0'
TRI0(x, ...)

## S3 method for class 'sfc_TIN'
TRI0(x, ...)

## S3 method for class 'TRI'
TRI0(x, ...)

## S3 method for class 'PATH0'
TRI0(x, ...)

## S3 method for class 'PATH'
TRI0(x, ...)

## S3 method for class 'sf'
TRI0(x, ...)

## S3 method for class 'sfc_GEOMETRYCOLLECTION'
TRI0(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRI0_+3A_x">x</code></td>
<td>
<p>object understood by silicate (sf, sp, a silicate model, etc.)</p>
</td></tr>
<tr><td><code id="TRI0_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TRI0 is suitable for simple conversion to other mesh forms. See
the examples for plotting and (in commented code) conversion to
rgl's 'mesh3d'.
</p>
<p>'Structural' means that the model does not store relational
IDs between tables, the vertex indexing is stored as a nested
list of data frames in the 'object' table. Unlike <code><a href="#topic+TRI">TRI()</a></code> we
cannot arbitrarily rearrange the order or remove content
of the underlying tables, without updating the vertex indexes
stored for each object.
</p>
<p>Ear-cutting is inherently path-based, so this model is only available for
path-based structures, like simple features, <code><a href="#topic+PATH">PATH()</a></code>, <code><a href="#topic+PATH0">PATH0()</a></code> and <code><a href="#topic+ARC">ARC()</a></code>.
</p>
<p>There is limited support for simple features GEOMETRYCOLLECTION, in short if
the GC is composed purely of POLYGON type with 4 coordinates each this is
assumed to be a collection of triangles and is converted directly without
any triangulation performed. GEOMETRYCOLLECTION of any other form is not
supported.
</p>


<h3>Value</h3>

<p>TRI0 model with tables 'object', 'vertex'
</p>


<h3>See Also</h3>

<p>TRI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tri &lt;- TRI0(minimal_mesh)
print(tri)
plot(tri)

# obtain the vertices and indices in raw form

## idx is the triplets of row numbers in tri$vertex
idx &lt;- do.call(rbind, sc_object(tri)$topology_)
idx &lt;- as.matrix(idx[c(".vx0", ".vx1", ".vx2")])

## vert is the vertices x_, y_, ...
vert &lt;- as.matrix(sc_vertex(tri))

## now we can plot with generic tools
plot(vert)
polygon(vert[t(cbind(idx, NA)), ])

## or create other structures like rgl's mesh3d
## (see hypertidy/anglr for in-dev helpers)
## rgl::tmesh3d(t(cbind(vert, 1, 1)), t(idx),
##   material = list(color = c("firebrick", "black", "grey", "blue")),
##   meshColor = "faces")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
