<!DOCTYPE html><html><head><title>Help for package fabricatr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fabricatr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ALL'><p>Magic number constant to allow users to specify <code>ALL</code> for passthrough</p>
resampling</a></li>
<li><a href='#correlate'><p>Perform generation of a correlated random variable.</p></a></li>
<li><a href='#cross_levels'><p>Creates panel or cross-classified data</p></a></li>
<li><a href='#draw_binary_icc'><p>Draw binary data with fixed intra-cluster correlation.</p></a></li>
<li><a href='#draw_discrete'><p>Draw discrete variables including binary, binomial count, poisson count,</p>
ordered, and categorical</a></li>
<li><a href='#draw_likert'><p>Recode a latent variable into a Likert response variable</p></a></li>
<li><a href='#draw_multivariate'><p>Draw multivariate random variables</p></a></li>
<li><a href='#draw_normal_icc'><p>Draw normal data with fixed intra-cluster correlation.</p></a></li>
<li><a href='#fabricate'><p>Fabricate data</p></a></li>
<li><a href='#fabricatr'><p>fabricatr package</p></a></li>
<li><a href='#get_unique_variables_by_level'><p>Find which variables are unique at a given level in hierarchical data</p></a></li>
<li><a href='#join_using'><p>Helper function handling specification of which variables to join a</p>
cross-classified data on, and what kind of correlation structure needed.
Correlation structures can only be provided if the underlying call is
a <code>link_levels()</code> call.</a></li>
<li><a href='#potential_outcomes'><p>Build potential outcomes variables</p></a></li>
<li><a href='#recycle'><p>Expands data to a given length through recycling.</p></a></li>
<li><a href='#resample_data'><p>Resample data, including hierarchical data</p></a></li>
<li><a href='#reveal_outcomes'><p>Reveal outcomes</p></a></li>
<li><a href='#split_quantile'><p>Split data into quantile buckets (e.g. terciles, quartiles, quantiles,</p>
deciles).</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imagine Your Data Before You Collect It</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Helps you imagine your data before you collect it. Hierarchical data structures
   and correlated data can be easily simulated, either from random number generators or
   by resampling from existing data sources. This package is faster with 'data.table' and
   'mvnfast' installed.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://declaredesign.org/r/fabricatr/">https://declaredesign.org/r/fabricatr/</a>,
<a href="https://github.com/DeclareDesign/fabricatr">https://github.com/DeclareDesign/fabricatr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DeclareDesign/fabricatr/issues">https://github.com/DeclareDesign/fabricatr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 1.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, data.table, mvnfast, MASS, extraDistr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 06:05:18 UTC; gblair</td>
</tr>
<tr>
<td>Author:</td>
<td>Graeme Blair <a href="https://orcid.org/0000-0001-9164-2102"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jasper Cooper <a href="https://orcid.org/0000-0002-8639-3188"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alexander Coppock <a href="https://orcid.org/0000-0002-5733-2386"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Macartan Humphreys
    <a href="https://orcid.org/0000-0001-7029-2326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Aaron Rudkin [aut],
  Neal Fultz [aut],
  David C. Hall <a href="https://orcid.org/0000-0002-2193-0480"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Graeme Blair &lt;graeme.blair@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-16 14:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ALL'>Magic number constant to allow users to specify <code>ALL</code> for passthrough
resampling</h2><span id='topic+ALL'></span>

<h3>Description</h3>

<p>Magic number constant to allow users to specify <code>ALL</code> for passthrough
resampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>integer</code> of length 1.
</p>

<hr>
<h2 id='correlate'>Perform generation of a correlated random variable.</h2><span id='topic+correlate'></span>

<h3>Description</h3>

<p>This function is EXPERIMENTAL, and we cannot guarantee its properties for
all data structures. Be sure to diagnose your design and assess the
distribution of your variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlate(draw_handler, ..., given, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlate_+3A_draw_handler">draw_handler</code></td>
<td>
<p>The unquoted name of a function to generate data.
Currently, <code>draw_binary</code>, <code>draw_binomial</code>, and <code>draw_count</code> are supported.</p>
</td></tr>
<tr><td><code id="correlate_+3A_...">...</code></td>
<td>
<p>The arguments to draw_handler (e.g. <code>prob</code>, <code>mean</code>, etc.)</p>
</td></tr>
<tr><td><code id="correlate_+3A_given">given</code></td>
<td>
<p>A vector that can be ordered; the reference distribution X that
Y will be correlated with.</p>
</td></tr>
<tr><td><code id="correlate_+3A_rho">rho</code></td>
<td>
<p>A rank correlation coefficient between -1 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to generate a random variable of a specific distribution based on
another variable of any distribution and a correlation coefficient <code>rho</code>,
we map the first, known variable into the standard normal space via affine
transformation, generate the conditional distribution of the resulting
variable as a standard normal, and then map that standard normal back to
the target distribution. The result should ensure, in expectation, a rank-order
correlation of <code>rho</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a variable of interest
exam_score &lt;- pmin(100, rnorm(n = 100, mean = 80, sd = 10))

# Generate a correlated variable using fabricatr variable generation
scholarship_offers &lt;- correlate(given = exam_score, rho = 0.7,
                                draw_count, mean = 3)

# Generate a correlated variable using base R distributions
final_grade &lt;- pmax(100, correlate(given = exam_score, rho = 0.7,
                                   rnorm, mean = 80, sd = 10))

</code></pre>

<hr>
<h2 id='cross_levels'>Creates panel or cross-classified data</h2><span id='topic+cross_levels'></span><span id='topic+link_levels'></span>

<h3>Description</h3>

<p>This function allows the user to create data structures that are paneled or
cross-classified: where one level of observation draws simultaneously from
two or many source levels. Common examples of panels include country-year
data which have country-level and year-level characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_levels(by = NULL, ...)

link_levels(N = NULL, by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_levels_+3A_by">by</code></td>
<td>
<p>The result of a call to <code>join_using()</code> which specifies how
the cross-classified data will be created</p>
</td></tr>
<tr><td><code id="cross_levels_+3A_...">...</code></td>
<td>
<p>A variable or series of variables to add to the resulting data
frame after the cross-classified data is created.</p>
</td></tr>
<tr><td><code id="cross_levels_+3A_n">N</code></td>
<td>
<p>The number of observations in the resulting data frame.
If <code>N</code> is NULL or not provided, the join_using will be an &quot;outer product&quot; &ndash;
merging each row of each provided data frame with each other data frame to
make a full panel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By specifying the appropriate arguments in <code>join_using()</code> within the
function call, it is possible to induce correlation in cross-classified data.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate full panel data
panel &lt;- fabricate(
 countries = add_level(N = 20, country_shock = runif(N, 1, 10)),
 years = add_level(N = 20, year_shock = runif(N, 1, 10), nest=FALSE),
 obs = cross_levels(by = join_using(countries, years), GDP_it = country_shock + year_shock)
)

# Include an "N" argument to allow for cross-classified
# data.
students &lt;- fabricate(
 primary_school = add_level(N = 20, ps_quality = runif(N, 1, 10)),
 secondary_school = add_level(N = 15, ss_quality = runif(N, 1, 10), nest=FALSE),
 students = link_levels(N = 500, by = join_using(primary_school, secondary_school))
)
head(students)

# Induce a correlation structure in cross-classified data by providing
# rho.
students &lt;- fabricate(
 primary_school = add_level(N = 20, ps_quality = runif(N, 1, 10)),
 secondary_school = add_level(N = 15, ss_quality = runif(N, 1, 10), nest=FALSE),
 students = link_levels(N = 500, by = join_using(ps_quality, ss_quality, rho = 0.5))
)
cor(students$ps_quality, students$ss_quality)

</code></pre>

<hr>
<h2 id='draw_binary_icc'>Draw binary data with fixed intra-cluster correlation.</h2><span id='topic+draw_binary_icc'></span>

<h3>Description</h3>

<p>Data is generated to ensure inter-cluster correlation 0, intra-cluster
correlation in expectation ICC. Algorithm taken from Hossein,
Akhtar. &quot;ICCbin: An R Package Facilitating Clustered Binary Data
Generation, and Estimation of Intracluster Correlation Coefficient (ICC)
for Binary Data&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_binary_icc(prob = 0.5, N = NULL, clusters, ICC = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_binary_icc_+3A_prob">prob</code></td>
<td>
<p>A number or vector of numbers, one probability per cluster. If none
is provided, will default to 0.5.</p>
</td></tr>
<tr><td><code id="draw_binary_icc_+3A_n">N</code></td>
<td>
<p>(Optional) A number indicating the number of observations to be
generated. Must be equal to length(clusters) if provided.</p>
</td></tr>
<tr><td><code id="draw_binary_icc_+3A_clusters">clusters</code></td>
<td>
<p>A vector of factors or items that can be coerced to
clusters; the length will determine the length of the generated data.</p>
</td></tr>
<tr><td><code id="draw_binary_icc_+3A_icc">ICC</code></td>
<td>
<p>A number indicating the desired <code>ICC</code>, if none is provided
the default ICC will be 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of binary numbers corresponding to the observations from
the supplied cluster IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Divide units into clusters
clusters = rep(1:5, 10)

# Default probability 0.5, default ICC 0
draw_binary_icc(clusters = clusters)

# Specify probability or ICC
corr_draw = draw_binary_icc(prob = 0.5, clusters = clusters, ICC = 0.5)

# Verify ICC of data.
summary(lm(corr_draw ~ as.factor(clusters)))$r.squared

</code></pre>

<hr>
<h2 id='draw_discrete'>Draw discrete variables including binary, binomial count, poisson count,
ordered, and categorical</h2><span id='topic+draw_discrete'></span><span id='topic+draw_binomial'></span><span id='topic+draw_categorical'></span><span id='topic+draw_ordered'></span><span id='topic+draw_count'></span><span id='topic+draw_binary'></span><span id='topic+draw_quantile'></span>

<h3>Description</h3>

<p>Drawing discrete data based on probabilities or latent traits is a common
task that can be cumbersome. Each function in our discrete drawing set creates
a different type of discrete data: <code>draw_binary</code> creates binary 0/1 data,
<code>draw_binomial</code> creates binomial data (repeated trial binary data),
<code>draw_categorical</code> creates categorical data, <code>draw_ordered</code>
transforms latent data into observed ordered categories, <code>draw_count</code>
creates count data (poisson-distributed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_binomial(
  prob = link(latent),
  trials = 1,
  N = length(prob),
  latent = NULL,
  link = "identity",
  quantile_y = NULL
)

draw_categorical(
  prob = link(latent),
  N = NULL,
  latent = NULL,
  link = "identity",
  category_labels = NULL
)

draw_ordered(
  x = link(latent),
  breaks = c(-1, 0, 1),
  break_labels = NULL,
  N = length(x),
  latent = NULL,
  strict = FALSE,
  link = "identity"
)

draw_count(
  mean = link(latent),
  N = length(mean),
  latent = NULL,
  link = "identity",
  quantile_y = NULL
)

draw_binary(
  prob = link(latent),
  N = length(prob),
  link = "identity",
  latent = NULL,
  quantile_y = NULL
)

draw_quantile(type, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_discrete_+3A_prob">prob</code></td>
<td>
<p>A number or vector of numbers representing the probability for
binary or binomial outcomes; or a number, vector, or matrix of numbers
representing probabilities for categorical outcomes. If you supply a link
function, these underlying probabilities will be transformed.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_trials">trials</code></td>
<td>
<p>for <code>draw_binomial</code>, the number of trials for each observation</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_n">N</code></td>
<td>
<p>number of units to draw. Defaults to the length of the vector of
probabilities or latent data you provided.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_latent">latent</code></td>
<td>
<p>If the user provides a link argument other than identity, they
should provide the variable <code>latent</code> rather than <code>prob</code> or <code>mean</code></p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_link">link</code></td>
<td>
<p>link function between the latent variable and the probability of
a positive outcome, e.g. &quot;logit&quot;, &quot;probit&quot;, or &quot;identity&quot;. For the &quot;identity&quot;
link, the latent variable must be a probability.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_quantile_y">quantile_y</code></td>
<td>
<p>A vector of quantiles; if provided, rather than drawing
stochastically from the distribution of interest, data will be drawn at
exactly those quantiles.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_category_labels">category_labels</code></td>
<td>
<p>vector of labels for the categories produced by
<code>draw_categorical</code>. If provided, must be equal to the number of categories
provided in the <code>prob</code> argument.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_x">x</code></td>
<td>
<p>for <code>draw_ordered</code>, the latent data for each
observation.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_breaks">breaks</code></td>
<td>
<p>vector of breaks to cut a latent outcome into ordered
categories with <code>draw_ordered</code></p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_break_labels">break_labels</code></td>
<td>
<p>vector of labels for the breaks to cut a latent outcome
into ordered categories with <code>draw_ordered</code>. (Optional)</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_strict">strict</code></td>
<td>
<p>Logical indicating whether values outside the provided breaks should be coded as NA. Defaults to <code>FALSE</code>, in which case effectively additional breaks are added between -Inf and the lowest break and between the highest break and Inf.</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_mean">mean</code></td>
<td>
<p>for <code>draw_count</code>, the mean number of count units for each observation</p>
</td></tr>
<tr><td><code id="draw_discrete_+3A_type">type</code></td>
<td>
<p>The number of buckets to split data into. For a median split,
enter 2; for terciles, enter 3; for quartiles, enter 4; for quintiles, 5;
for deciles, 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For variables with intra-cluster correlations, see
<code><a href="#topic+draw_binary_icc">draw_binary_icc</a></code> and <code><a href="#topic+draw_normal_icc">draw_normal_icc</a></code>
</p>


<h3>Value</h3>

<p>A vector of data in accordance with the specification; generally
numeric but for some functions, including <code>draw_ordered</code> and
<code>draw_categorical</code>, may be factor if labels are provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Drawing binary values (success or failure, treatment assignment)
fabricate(N = 3,
   p = c(0, .5, 1),
   binary = draw_binary(prob = p))

# Drawing binary values with probit link (transforming continuous data
# into a probability range).
fabricate(N = 3,
   x = 10 * rnorm(N),
   binary = draw_binary(latent = x, link = "probit"))

# Repeated trials: `draw_binomial`
fabricate(N = 3,
   p = c(0, .5, 1),
   binomial = draw_binomial(prob = p, trials = 10))

# Ordered data: transforming latent data into observed, ordinal data.
# useful for survey responses.
fabricate(N = 3,
   x = 5 * rnorm(N),
   ordered = draw_ordered(x = x,
                          breaks = c(-Inf, -1, 1, Inf)))

# Providing break labels for latent data.
fabricate(N = 3,
   x = 5 * rnorm(N),
   ordered = draw_ordered(x = x,
                          breaks = c(-Inf, -1, 1, Inf),
                          break_labels = c("Not at all concerned",
                                           "Somewhat concerned",
                                           "Very concerned")))


# Count data: useful for rates of occurrences over time.
fabricate(N = 5,
   x = c(0, 5, 25, 50, 100),
   theft_rate = draw_count(mean=x))

# Categorical data: useful for demographic data.
fabricate(N = 6, p1 = runif(N), p2 = runif(N), p3 = runif(N),
          cat = draw_categorical(cbind(p1, p2, p3)))

</code></pre>

<hr>
<h2 id='draw_likert'>Recode a latent variable into a Likert response variable</h2><span id='topic+draw_likert'></span>

<h3>Description</h3>

<p>Recode a latent variable into a Likert response variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_likert(
  x,
  min = NULL,
  max = NULL,
  bins = NULL,
  breaks = NULL,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_likert_+3A_x">x</code></td>
<td>
<p>a numeric variable considered to be &quot;latent&quot;</p>
</td></tr>
<tr><td><code id="draw_likert_+3A_min">min</code></td>
<td>
<p>the minimum value of the latent variable</p>
</td></tr>
<tr><td><code id="draw_likert_+3A_max">max</code></td>
<td>
<p>the maximum value of the latent variable</p>
</td></tr>
<tr><td><code id="draw_likert_+3A_bins">bins</code></td>
<td>
<p>the number of Likert scale values. The latent variable will be cut into equally sized bins as in seq(min, max, length.out = bins + 1)</p>
</td></tr>
<tr><td><code id="draw_likert_+3A_breaks">breaks</code></td>
<td>
<p>A vector of breaks. This option is useful for settings in which equally-sized breaks are inappropriate</p>
</td></tr>
<tr><td><code id="draw_likert_+3A_labels">labels</code></td>
<td>
<p>An optional vector of labels. If labels are provided, the resulting output will be a factor.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:100

draw_likert(x, min = 0, max = 100, bins = 7)
draw_likert(x, breaks = c(-1, 10, 100))


</code></pre>

<hr>
<h2 id='draw_multivariate'>Draw multivariate random variables</h2><span id='topic+draw_multivariate'></span>

<h3>Description</h3>

<p>Draw multivariate random variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_multivariate(formula, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_multivariate_+3A_formula">formula</code></td>
<td>
<p>Formula describing the multivariate draw. The lefthand side is the names or prefix and the right-hand side is the multivariate draw function call, such as mvrnorm from the MASS library or rmnom from the extraDistr library.</p>
</td></tr>
<tr><td><code id="draw_multivariate_+3A_sep">sep</code></td>
<td>
<p>Separator string between prefix and variable number. Only used when a single character string is provided and multiple variables created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)

# draw from multivariate normal distribution
dat &lt;-
  draw_multivariate(c(Y_1, Y_2) ~ mvrnorm(
    n = 500,
    mu = c(0, 0),
    Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)
  ))


cor(dat)


# equivalently, you can provide a prefix for the variable names
# (easier if you have many variables)
draw_multivariate(Y ~ mvrnorm(
  n = 5,
  mu = c(0, 0),
  Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)
))

# within fabricate
fabricate(
  N = 100,
  draw_multivariate(c(Y_1, Y_2) ~ mvrnorm(
    n = N,
    mu = c(0, 0),
    Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)
  ))
)

# You can also write the following, which works but gives less control over the names
fabricate(N = 100,
Y = mvrnorm(
  n = N,
  mu = c(0, 0),
  Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)
))

</code></pre>

<hr>
<h2 id='draw_normal_icc'>Draw normal data with fixed intra-cluster correlation.</h2><span id='topic+draw_normal_icc'></span>

<h3>Description</h3>

<p>Data is generated to ensure inter-cluster correlation 0, intra-cluster
correlation in expectation ICC. The data generating process
used in this function is specified at the following URL:
<a href="https://stats.stackexchange.com/questions/263451/create-synthetic-data-with-a-given-intraclass-correlation-coefficient-icc">https://stats.stackexchange.com/questions/263451/create-synthetic-data-with-a-given-intraclass-correlation-coefficient-icc</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_normal_icc(
  mean = 0,
  N = NULL,
  clusters,
  sd = NULL,
  sd_between = NULL,
  total_sd = NULL,
  ICC = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_normal_icc_+3A_mean">mean</code></td>
<td>
<p>A number or vector of numbers, one mean per cluster. If none is
provided, will default to 0.</p>
</td></tr>
<tr><td><code id="draw_normal_icc_+3A_n">N</code></td>
<td>
<p>(Optional) A number indicating the number of observations to be
generated. Must be equal to length(clusters) if provided.</p>
</td></tr>
<tr><td><code id="draw_normal_icc_+3A_clusters">clusters</code></td>
<td>
<p>A vector of factors or items that can be coerced to
clusters; the length will determine the length of the generated data.</p>
</td></tr>
<tr><td><code id="draw_normal_icc_+3A_sd">sd</code></td>
<td>
<p>A number or vector of numbers, indicating the standard deviation of
each cluster's error terms &ndash; standard deviation within a cluster (default 1)</p>
</td></tr>
<tr><td><code id="draw_normal_icc_+3A_sd_between">sd_between</code></td>
<td>
<p>A number or vector of numbers, indicating the standard deviation
between clusters.</p>
</td></tr>
<tr><td><code id="draw_normal_icc_+3A_total_sd">total_sd</code></td>
<td>
<p>A number indicating the total sd of the resulting variable.
May only be specified if ICC is specified and <code>sd</code> and <code>sd_between</code> are not.</p>
</td></tr>
<tr><td><code id="draw_normal_icc_+3A_icc">ICC</code></td>
<td>
<p>A number indicating the desired ICC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The typical use for this function is for a user to provide an <code>ICC</code> and,
optionally, a set of within-cluster standard deviations, <code>sd</code>. If the
user does not provide <code>sd</code>, the default value is 1. These arguments
imply a fixed between-cluster standard deviation.
</p>
<p>An alternate mode for the function is to provide between-cluster standard
deviations, <code>sd_between</code>, and an <code>ICC</code>. These arguments imply
a fixed within-cluster standard deviation.
</p>
<p>If users provide all three of <code>ICC</code>, <code>sd_between</code>, and
<code>sd</code>, the function will warn the user and use the provided standard
deviations for generating the data.
</p>


<h3>Value</h3>

<p>A vector of numbers corresponding to the observations from
the supplied cluster IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Divide observations into clusters
clusters = rep(1:5, 10)

# Default: unit variance within each cluster
draw_normal_icc(clusters = clusters, ICC = 0.5)

# Alternatively, you can specify characteristics:
draw_normal_icc(mean = 10, clusters = clusters, sd = 3, ICC = 0.3)

# Can specify between-cluster standard deviation instead:
draw_normal_icc(clusters = clusters, sd_between = 4, ICC = 0.2)

# Can specify total SD instead:
total_sd_draw = draw_normal_icc(clusters = clusters, ICC = 0.5, total_sd = 3)
sd(total_sd_draw)

# Verify that ICC generated is accurate
corr_draw = draw_normal_icc(clusters = clusters, ICC = 0.4)
summary(lm(corr_draw ~ as.factor(clusters)))$r.squared

</code></pre>

<hr>
<h2 id='fabricate'>Fabricate data</h2><span id='topic+fabricate'></span><span id='topic+add_level'></span><span id='topic+modify_level'></span><span id='topic+nest_level'></span>

<h3>Description</h3>

<p><code>fabricate</code> helps you simulate a dataset before you collect it. You can
either start with your own data and add simulated variables to it (by passing
<code>data</code> to <code>fabricate()</code>) or start from scratch by defining
<code>N</code>. Create hierarchical data with multiple levels of data such as
citizens within cities within states using <code>add_level()</code> or modify
existing hierarchical data using <code>modify_level()</code>. You can use any R
function to create each variable. Use <code>cross_levels()</code> and
<code>link_levels()</code> to make more complex designs such as panel or
cross-classified data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fabricate(..., data = NULL, N = NULL, ID_label = NULL)

add_level(N = NULL, ..., nest = TRUE)

modify_level(..., by = NULL)

nest_level(N = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fabricate_+3A_...">...</code></td>
<td>
<p>Variable or level-generating arguments, such as
<code>my_var = rnorm(N)</code>. For <code>fabricate</code>, you may also pass
<code>add_level()</code> or <code>modify_level()</code> arguments, which define a level
of a multi-level dataset. See examples.</p>
</td></tr>
<tr><td><code id="fabricate_+3A_data">data</code></td>
<td>
<p>(optional) user-provided data that forms the basis of the
fabrication, e.g. you can add variables to existing data. Provide either
<code>N</code> or <code>data</code> (<code>N</code> is the number of rows of the data if
<code>data</code> is provided). If <code>data</code> and <code>N</code> are not provided,
fabricatr will try to interpret the first un-named argument as either <code>data</code>
or <code>N</code> based on type.</p>
</td></tr>
<tr><td><code id="fabricate_+3A_n">N</code></td>
<td>
<p>(optional) number of units to draw. If provided as
<code>fabricate(N = 5)</code>, this determines the number of units in the
single-level data. If provided in <code>add_level</code>, e.g.
<code>fabricate(cities = add_level(N = 5))</code>, <code>N</code> determines the number
of units in a specific level of a hierarchical dataset.</p>
</td></tr>
<tr><td><code id="fabricate_+3A_id_label">ID_label</code></td>
<td>
<p>(optional) variable name for ID variable, e.g. citizen_ID. Set to NA to suppress the creation of an ID variable.</p>
</td></tr>
<tr><td><code id="fabricate_+3A_nest">nest</code></td>
<td>
<p>(Default TRUE) Boolean determining whether data in an
<code>add_level()</code> call will be nested under the current working data frame
or create a separate hierarchy of levels. See our vignette for
cross-classified, non-nested data for details.</p>
</td></tr>
<tr><td><code id="fabricate_+3A_by">by</code></td>
<td>
<p>(optional) quoted name of variable <code>modify_level</code> uses to split-modify-combine data by.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We also provide several built-in options to easily create variables, including
<code><a href="#topic+draw_binary">draw_binary</a></code>, <code><a href="#topic+draw_count">draw_count</a></code>, <code><a href="#topic+draw_likert">draw_likert</a></code>,
and intra-cluster correlated variables <code><a href="#topic+draw_binary_icc">draw_binary_icc</a></code> and
<code><a href="#topic+draw_normal_icc">draw_normal_icc</a></code>
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+link_levels">link_levels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Draw a single-level dataset with a covariate
building_df &lt;- fabricate(
  N = 100,
  height_ft = runif(N, 300, 800)
)
head(building_df)

# Start with existing data instead
building_modified &lt;- fabricate(
  data = building_df,
  rent = rnorm(N, mean = height_ft * 100, sd = height_ft * 30)
)

# Draw a two-level hierarchical dataset
# containing cities within regions
multi_level_df &lt;- fabricate(
 regions = add_level(N = 5),
 cities = add_level(N = 2, pollution = rnorm(N, mean = 5)))
head(multi_level_df)

# Start with existing data and add a nested level:
company_df &lt;- fabricate(
 data = building_df,
 company_id = add_level(N=10, is_headquarters = sample(c(0, 1), N, replace=TRUE))
)

# Start with existing data and add variables to hierarchical data
# at levels which are already present in the existing data.
# Note: do not provide N when adding variables to an existing level
fabricate(
  data = multi_level_df,
  regions = modify_level(watershed = sample(c(0, 1), N, replace = TRUE)),
  cities = modify_level(runoff = rnorm(N))
)

# fabricatr can add variables that are higher-level summaries of lower-level
# variables via a split-modify-combine logic and the \code{by} argument

multi_level_df &lt;-
 fabricate(
   regions = add_level(N = 5, elevation = rnorm(N)),
   cities = add_level(N = 2, pollution = rnorm(N, mean = 5)),
   cities = modify_level(by = "regions", regional_pollution = mean(pollution))
 )

# fabricatr can also make panel or cross-classified data. For more
# information about syntax for this functionality please read our vignette
# or check documentation for \code{link_levels}:
cross_classified &lt;- fabricate(
  primary_schools = add_level(N = 50, ps_quality = runif(N, 0, 10)),
  secondary_schools = add_level(N = 100, ss_quality = runif(N, 0, 10), nest=FALSE),
  students = link_levels(N = 2000,
                          by = join_using(ps_quality, ss_quality, rho = 0.5),
                          student_quality = ps_quality + 3*ss_quality + rnorm(N)))
</code></pre>

<hr>
<h2 id='fabricatr'>fabricatr package</h2><span id='topic+fabricatr'></span><span id='topic+fabricatr-package'></span>

<h3>Description</h3>

<p>fabricatr helps you imagine your data before you collect it. Hierarchical
data structures and correlated data can be easily simulated, either from
random number generators or by resampling from existing data sources.
</p>

<hr>
<h2 id='get_unique_variables_by_level'>Find which variables are unique at a given level in hierarchical data</h2><span id='topic+get_unique_variables_by_level'></span>

<h3>Description</h3>

<p>Find which variables are unique at a given level in hierarchical data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unique_variables_by_level(data, ID_label, superset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_unique_variables_by_level_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="get_unique_variables_by_level_+3A_id_label">ID_label</code></td>
<td>
<p>the ID label to split upon</p>
</td></tr>
<tr><td><code id="get_unique_variables_by_level_+3A_superset">superset</code></td>
<td>
<p>Superset contains a vector of character strings that contain variables
the modify level call is going to write. Some of these may be columns
in the data frame, others might not be. If superset is specified,
then we definitely only want to check those variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector enumerating the unique variables
</p>

<hr>
<h2 id='join_using'>Helper function handling specification of which variables to join a
cross-classified data on, and what kind of correlation structure needed.
Correlation structures can only be provided if the underlying call is
a <code>link_levels()</code> call.</h2><span id='topic+join_using'></span>

<h3>Description</h3>

<p>Helper function handling specification of which variables to join a
cross-classified data on, and what kind of correlation structure needed.
Correlation structures can only be provided if the underlying call is
a <code>link_levels()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_using(..., rho = 0, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_using_+3A_...">...</code></td>
<td>
<p>A series of two or more variable names, unquoted, to join on in
order to create cross-classified data.</p>
</td></tr>
<tr><td><code id="join_using_+3A_rho">rho</code></td>
<td>
<p>A fixed (Spearman's rank) correlation coefficient between the
variables being joined on: note that if it is not possible to make a
correlation matrix from this coefficient (e.g. if you are joining on three
or more variables and rho is negative) then the <code>cross_levels()</code> call
will fail. Do not provide <code>rho</code> if making panel data.</p>
</td></tr>
<tr><td><code id="join_using_+3A_sigma">sigma</code></td>
<td>
<p>A matrix with dimensions equal to the number of variables you
are joining on, specifying the correlation for the resulting joined data.
Only one of rho and sigma should be provided. Do not provide <code>sigma</code> if
making panel data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
panels &lt;- fabricate(
  countries = add_level(N = 150, country_fe = runif(N, 1, 10)),
  years = add_level(N = 25, year_shock = runif(N, 1, 10), nest = FALSE),
  obs = cross_levels(
    by = join_using(countries, years),
    new_variable = country_fe + year_shock + rnorm(N, 0, 2)
  )
)

schools_data &lt;- fabricate(
  primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),
  secondary_schools = add_level(
    N = 15,
    ss_quality = runif(N, 1, 10),
    nest = FALSE),
  students = link_levels(
    N = 1500,
    by = join_using(primary_schools, secondary_schools),
    SAT_score = 800 + 13 * ps_quality + 26 * ss_quality + rnorm(N, 0, 50)
  )
)

</code></pre>

<hr>
<h2 id='potential_outcomes'>Build potential outcomes variables</h2><span id='topic+potential_outcomes'></span>

<h3>Description</h3>

<p>Function to draw multiple potential outcomes, one for each condition that an assignment variable can be set to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potential_outcomes(x, conditions = list(Z = c(0, 1)), sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="potential_outcomes_+3A_x">x</code></td>
<td>
<p>Formula describing the potential outcomes with the outcome name on the left hand side and the expression describing the potential outcomes on the right hand side, e.g. <code>Y ~ 0.1 * Z + rnorm(N)</code> (this would draw two potential outcomes columns by default, named Y_Z_0 and Y_Z_1).</p>
</td></tr>
<tr><td><code id="potential_outcomes_+3A_conditions">conditions</code></td>
<td>
<p>A list of conditions for each assignment variable. Defaults to <code>list(Z = c(0, 1))</code>.</p>
</td></tr>
<tr><td><code id="potential_outcomes_+3A_sep">sep</code></td>
<td>
<p>Separator inserted between the outcome name and the assignment variable name used to construct the potential outcome variable names, defaults to &quot;_&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
fabricate(
  N = 10,
  U = rnorm(N),
  potential_outcomes(Y ~ 0.1 * Z + U)
)

# equivalently,

fabricate(
  N = 10,
  U = rnorm(N),
  potential_outcomes(Y ~ 0.1 * Z + U,
                     conditions = list(Z = c(0, 1)))
)

fabricate(
  N = 10,
  U = rnorm(N),
  potential_outcomes(Y ~ 0.1 * Z + U,
                     conditions = list(Z = c(1, 2, 3)))
)

fabricate(
  N = 10,
  U = rnorm(N),
  potential_outcomes(Y ~ 0.1 * Z1 + 0.3 * Z2 + 0.5 * Z1 * Z2 + U,
                     conditions = list(Z1 = c(0, 1),
                                       Z2 = c(0, 1)))
)


</code></pre>

<hr>
<h2 id='recycle'>Expands data to a given length through recycling.</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p>This function is a helper function designed call <code>rep_len</code> to expand the
length of a data vector, but which can dynamically retrieve N from the
surrounding level call for use in fabricatr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(x, .N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recycle_+3A_x">x</code></td>
<td>
<p>Data to recycle into length <code>N</code></p>
</td></tr>
<tr><td><code id="recycle_+3A_.n">.N</code></td>
<td>
<p>the length to recycle the data to, typically provided implicitly by
a or fabricate call wrapped around the function call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of data padded to length <code>N</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fabricate(
  N = 15,
  month = recycle(month.abb)
)
</code></pre>

<hr>
<h2 id='resample_data'>Resample data, including hierarchical data</h2><span id='topic+resample_data'></span>

<h3>Description</h3>

<p>This function allows you to resample any data frame. The default mode
performs a single resample of size <code>N</code> with replacement. Users can
also specify more complex resampling strategies to resample hierarchical
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_data(data, N, ID_labels = NULL, unique_labels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_data_+3A_data">data</code></td>
<td>
<p>A data.frame, usually provided by the user.</p>
</td></tr>
<tr><td><code id="resample_data_+3A_n">N</code></td>
<td>
<p>The number of sample observations to return. If <code>N</code> is a single
scalar and no labels are provided, <code>N</code> will specify the number of unit
observations to resample. If <code>N</code> is named, or if the <code>ID_labels</code>
argument is specified (in which case, both <code>N</code> and <code>ID_labels</code>
should be the same length), then the units resampled will be values of the
levels resampled (this is useful for, e.g., cluster resampling). If <code>N</code>
is the constant <code>ALL</code> for any level, all units of this level will be
transparently passed through to the next level of resampling.</p>
</td></tr>
<tr><td><code id="resample_data_+3A_id_labels">ID_labels</code></td>
<td>
<p>A character vector of the variables that indicate the data
hierarchy, from highest to lowest (i.e., from cities to citizens).</p>
</td></tr>
<tr><td><code id="resample_data_+3A_unique_labels">unique_labels</code></td>
<td>
<p>A boolean, defaulting to FALSE. If TRUE, fabricatr will
created an extra data frame column depicting a unique version of the ID_label
variable resampled on, called &lt;ID_label&gt;_unique.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Resample a dataset of size N without any hierarchy
baseline_survey &lt;- fabricate(N = 50, Y_pre = rnorm(N))
bootstrapped_data &lt;- resample_data(baseline_survey)

# Specify a fixed number of observations to return
baseline_survey &lt;- fabricate(N = 50, Y_pre = rnorm(N))
bootstrapped_data &lt;- resample_data(baseline_survey, N = 100)

# Resample by a single level of a hierarchical dataset (e.g. resampling
# clusters of observations): N specifies a number of clusters to return

clustered_survey &lt;- fabricate(
  clusters = add_level(N=25),
  cities = add_level(N=round(runif(25, 1, 5)),
                     population=runif(n = N, min=50000, max=1000000))
)

cluster_resample &lt;- resample_data(clustered_survey, N = 5, ID_labels = "clusters")

# Alternatively, pass the level to resample as a name:
cluster_resample_2 &lt;- resample_data(clustered_survey, N=c(clusters = 5))

# Resample a hierarchical dataset on multiple levels
my_data &lt;-
fabricate(
  cities = add_level(N = 20, elevation = runif(n = N, min = 1000, max = 2000)),
  citizens = add_level(N = 30, age = runif(n = N, min = 18, max = 85))
)

# Specify the levels you wish to resample:
my_data_2 &lt;- resample_data(my_data, N = c(3, 5),
                           ID_labels = c("cities", "citizens"))

# To resample every unit at a given level, use the ALL constant
# This example will resample 10 citizens at each of the cities:

passthrough_resample_data &lt;- resample_data(my_data, N = c(cities=ALL, citizens=10))

# To ensure a column with unique labels (for example, to calculate block-level
# statistics irrespective of sample choices), use the unique_labels=TRUE
# argument -- this will produce new columns with unique labels.

unique_resample &lt;- resample_data(my_data, N = c(cities=5), unique_labels = TRUE)

</code></pre>

<hr>
<h2 id='reveal_outcomes'>Reveal outcomes</h2><span id='topic+reveal_outcomes'></span>

<h3>Description</h3>

<p>Implements a generalized switching equation. Reveals observed outcomes from multiple potential outcomes variables and an assignment variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_outcomes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_outcomes_+3A_x">x</code></td>
<td>
<p>A formula with the outcome name on the left hand side and assignment variables on the right hand side (e.g., <code>Y ~ Z</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- fabricate(
  N = 10,
  U = rnorm(N),
  potential_outcomes(Y ~ 0.1 * Z + U)
)

fabricate(
  data = dat,
  Z = rbinom(N, 1, prob = 0.5),
  Y = reveal_outcomes(Y ~ Z)
)

fabricate(
  N = 10,
  U = rnorm(N),
  potential_outcomes(Y ~ 0.1 * Z1 + 0.3 * Z2 + 0.5 * Z1 * Z2 + U,
                     conditions = list(Z1 = c(0, 1),
                                       Z2 = c(0, 1))),
  Z1 = rbinom(N, 1, prob = 0.5),
  Z2 = rbinom(N, 1, prob = 0.5),
  Y = reveal_outcomes(Y ~ Z1 + Z2)
)


</code></pre>

<hr>
<h2 id='split_quantile'>Split data into quantile buckets (e.g. terciles, quartiles, quantiles,
deciles).</h2><span id='topic+split_quantile'></span>

<h3>Description</h3>

<p>Survey data is often presented in aggregated, depersonalized form, which
can involve binning underlying data into quantile buckets; for example,
rather than reporting underlying income, a survey might report income by
decile. <code>split_quantile</code> can automatically produce this split using any
data <code>x</code> and any number of splits 'type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_quantile(x = NULL, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_quantile_+3A_x">x</code></td>
<td>
<p>A vector of any type that can be ordered &ndash; i.e. numeric or factor
where factor levels are ordered.</p>
</td></tr>
<tr><td><code id="split_quantile_+3A_type">type</code></td>
<td>
<p>The number of buckets to split data into. For a median split,
enter 2; for terciles, enter 3; for quartiles, enter 4; for quintiles, 5;
for deciles, 10.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Divide this arbitrary data set in 3.
data_input &lt;- rnorm(n = 100)
split_quantile(x = data_input, type = 3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
