<!DOCTYPE html><html><head><title>Help for package dglars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dglars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dglars-package'><p>Differential Geometric Least Angle Regression</p></a></li>
<li><a href='#AIC.dglars'><p>Akaike's An Information Criterion</p></a></li>
<li><a href='#alon'>
<p>Data from the microarray experiment done by Alon et al. (1999)</p></a></li>
<li><a href='#breast'>
<p>Breast Cancer microarray experiment</p></a></li>
<li><a href='#coef.cvdglars'><p>Extract the Coefficients Estimated by <code>cvdglars</code></p></a></li>
<li><a href='#coef.dglars'><p>Extract the dgLARS Coefficient Path</p></a></li>
<li><a href='#cvdglars'><p>Cross-Validation Method for dgLARS</p></a></li>
<li><a href='#dglars'><p>dgLARS Solution Curve for GLM</p></a></li>
<li><a href='#dglars-internal'><p>Internal dglars Functions</p></a></li>
<li><a href='#duke'>
<p>Duke breast cancer microarray experiment</p></a></li>
<li><a href='#gdf'>
<p>Estimate the Generalized Degrees-of-Freedom</p></a></li>
<li><a href='#grcv'>
<p>General Refitted Cross-Validation Estimator</p></a></li>
<li><a href='#logLik.dglars'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#phihat'><p>Estimate the Dispersion Parameter</p></a></li>
<li><a href='#plot.cvdglars'><p>Plot from a cvdglars Object</p></a></li>
<li><a href='#plot.dglars'><p>Plot from a dglars Object</p></a></li>
<li><a href='#predict.dglars'><p>Predict Method for dgLARS Fits.</p></a></li>
<li><a href='#print.cvdglars'><p>Print a cvdglars Object</p></a></li>
<li><a href='#print.dglars'>
<p>Printing a dgLARS Object</p></a></li>
<li><a href='#summary.dglars'><p>Summaryzing dgLARS Fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Differential Geometric Least Angle Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Luigi Augugliaro [aut, cre],
  Angelo Mineo [aut],
  Ernst Wit [aut],
  Hassan Pazira [aut],
  Michael Wichura [ctb, cph],
  John Burkardt [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luigi Augugliaro &lt;luigi.augugliaro@unipa.it&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Differential geometric least angle regression method for fitting sparse generalized linear models. In this version of the package, the user can fit models specifying Gaussian, Poisson, Binomial, Gamma and Inverse Gaussian family. Furthermore, several link functions can be used to model the relationship between the conditional expected value of the response variable and the linear predictor. The solution curve can be computed using an efficient predictor-corrector or a cyclic coordinate descent algorithm, as described in the paper linked to via the URL below.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.jstatsoft.org/v59/i08/.">https://www.jstatsoft.org/v59/i08/.</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, R (&ge; 3.2)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 17:10:50 UTC; francesca</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dglars-package'>Differential Geometric Least Angle Regression</h2><span id='topic+dglars-package'></span>

<h3>Description</h3>

<p>Differential geometric least angle regression method for fitting sparse generalized linear models. In this version of the package, the user can fit models specifying Gaussian, Poisson, Binomial, Gamma and Inverse Gaussian family. Furthermore, several link functions can be used to model the relationship between the conditional expected value of the response variable and the linear predictor. The solution curve can be computed using an efficient predictor-corrector or a cyclic coordinate descent algorithm, as described in the paper linked to via the URL below.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dglars</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Luigi Augugliaro<br />
Maintainer: Luigi Augugliaro  &lt;luigi.augugliaro@unipa.it&gt;
</p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2016) &lt;doi:10.1093/biomet/asw023&gt;
<em>A differential-geometric approach to generalized linear models with grouped predictors</em>, Vol 103(3), 563-577.
</p>
<p>Augugliaro L., Mineo A.M. and Wit E.C. (2014) &lt;doi:10.18637/jss.v059.i08&gt;
<em>dglars: An R Package to Estimate Sparse Generalized Linear Models</em>, <em>Journal of Statistical Software</em>, Vol 59(8), 1-40. <a href="https://www.jstatsoft.org/v59/i08/">https://www.jstatsoft.org/v59/i08/</a>.
</p>
<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013) &lt;doi:10.1111/rssb.12000&gt;
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>,
<em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>
<p>Efron B., Hastie T., Johnstone I. and Tibshirani R. (2004) &lt;doi:10.1214/009053604000000067&gt;
<em>Least Angle Regression</em>, <em>The Annals of Statistics</em>, Vol. 32(2), 407-499.
</p>
<p>Pazira H., Augugliaro L. and Wit E.C. (2018) &lt;doi:10.1007/s11222-017-9761-7&gt;
<em>Extended differential-geometric LARS for high-dimensional GLMs with general dispersion parameter</em>,
<em>Statistics and Computing</em>, Vol 28(4), 753-774.
</p>

<hr>
<h2 id='AIC.dglars'>Akaike's An Information Criterion</h2><span id='topic+AIC'></span><span id='topic+AIC.dglars'></span><span id='topic+BIC'></span><span id='topic+BIC.dglars'></span>

<h3>Description</h3>

<p><code>AIC.dglars</code> is used to compute the Akaike's &lsquo;An Information Criterion&rsquo; for the sequence of models estimated by &ldquo;<code>dglars</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
AIC(object, phi = c("pearson", "deviance", "mle", "grcv"),
k = 2, complexity = c("df", "gdf"), g = NULL, ...)

## S3 method for class 'dglars'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.dglars_+3A_object">object</code></td>
<td>
<p>a fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="AIC.dglars_+3A_phi">phi</code></td>
<td>
<p>a description of the estimator of the dispersion parameter (see below for more details).</p>
</td></tr>
<tr><td><code id="AIC.dglars_+3A_k">k</code></td>
<td>
<p>non negative value used to weight the complexity of the fitted dglars model (see below for more details).</p>
</td></tr>
<tr><td><code id="AIC.dglars_+3A_complexity">complexity</code></td>
<td>
<p>argument used to specify the method to measure the complexity of a fitted dglars model, i.e. the number of non-zero estimates (<code>complexity = "df"</code>) of the generalized degrees-of-freedom (<code>complexity = "gdf"</code>); see below for more details.</p>
</td></tr>
<tr><td><code id="AIC.dglars_+3A_g">g</code></td>
<td>
<p>vector of values of the tuning parameter.</p>
</td></tr>
<tr><td><code id="AIC.dglars_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function <code>link{grcv}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values returned by <code>AIC.dglars</code> are computed according to the following formula of a generic measure of Goodness-of-Fit (GoF): </p>
<p style="text-align: center;"><code class="reqn">-2 \mbox{log-likelihood} + k \mbox{comp},</code>
</p>
<p> where &ldquo;comp&rdquo; represents the term used to measure the complexity of the fitted model, and <code class="reqn">k</code> is the &lsquo;weight&rsquo; of the complexity in the previous formula.
</p>
<p>For binomial and Poisson family, the log-likelihood function is evaluated assuming that the dispersione parameter is known and equal to one while for the remaining families the dispersion parameter is estimated by the method specified by <code>phi</code> (see <code><a href="#topic+phihat">phihat</a></code> for more details).
</p>
<p>According to the results given in Augugliaro et. al. (2013), the complexity of a model fitted by dglars method can be measured by the classical notion of &lsquo;Degrees-of-Freedom&rsquo; (<code>complexity = "df"</code>), i.e., the number of non-zero estimated, or by the notion of &lsquo;Generalized Degrees-of-Freedom&rsquo; (<code>complexity = "gdf"</code>).
</p>
<p>By the previous formula, it is easy to see that the standard AIC-values are obtained setting <code>k = 2</code> and <code>complexity = "df"</code> (default values for the function <code>AIC.dglars</code>) while the so-called BIC-values (Schwarz's Bayesian criterion) are obtained setting <code>k = log(n)</code>, where <code class="reqn">n</code> denotes the sample size, and <code>complexity = "df"</code> (default values for the function <code>BIC.dglars</code>).
</p>
<p>The optional argument <code>g</code> is used to specify the values of the tuning parameter; if not specified (default), the values of the measure of goodness-of-fit are computed for the sequence of models storage in <code>object</code> otherwise <code><a href="#topic+predict.dglars">predict.dglars</a></code> is used to compute the estimate of the parameters needed to evaluate the log-likelihood function (see the example below).
</p>


<h3>Value</h3>

<p><code>AIC.dglars</code> and <code>BIC.dglars</code> return a named list with class &ldquo;<code>gof_dglars</code>&rdquo; and components:
</p>
<table>
<tr><td><code>val</code></td>
<td>
<p>the sequence of AIC/BIC-values;</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the sequence of <code class="reqn">\gamma</code>-values;</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the sequence of log-likelihood values used to compute the AIC or BIC;</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the non negative value used to weight the complexity of the fitted dglars model;</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>the measures of model complexity used to compute the measure of goodness-of-fit. It is equal to <code>npar</code> when codecomplexity = &quot;df&quot;;</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>the seqeunce of the number of non-zero estimates</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a description of the estimator used to estimate the dispersion pamater;</p>
</td></tr>
<tr><td><code>phih</code></td>
<td>
<p>the vector of penalized estimate of the dispersion parameter used to evaluate the log-likelihood function;</p>
</td></tr>
<tr><td><code>complexity</code></td>
<td>
<p>character specifying the method to measure the complexity of a fitted dglars model;</p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>the fitted <code>dglars</code> object;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>character specifying the type of used measure-of-goodness of fit, i.e., AIC, BIC or GoF.</p>
</td></tr>
</table>
<p>In order to summarize the information about the AIC-valuse, a <code>print</code> method is available for an object with class &ldquo;<code>gof_dglars</code>&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a>
</p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013) &lt;doi:10.1111/rssb.12000&gt;
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>, 
<em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>
<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986, ISBN:978-90-277-2253-9)
<em>Akaike Information Criterion Statistics</em>.
KTK Scientific Publishers, 1986.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.dglars">logLik.dglars</a></code>, <code><a href="#topic+predict.dglars">predict.dglars</a></code>, <code><a href="#topic+dglars">dglars</a></code> and <code><a href="#topic+summary.dglars">summary.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################
# y ~ Pois

library("dglars")
set.seed(123)
n &lt;- 100
p &lt;- 5
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + X[, 1]  + X[, 2]
mu &lt;- poisson()$linkinv(eta)
y &lt;- rpois(n, mu)
out &lt;- dglars(y ~ X, poisson)
out
AIC(out)
AIC(out, g = seq(2, 1, by = -0.1))
AIC(out, complexity = "gdf")
AIC(out, k = log(n)) #BIC-values
BIC(out)

#################################
# y ~ Gamma

n &lt;- 100
p &lt;- 50
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + 2 * X[, 1L]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
out &lt;- dglars(y ~ X, Gamma("log"))

AIC(out, phi = "pearson")
AIC(out, phi = "deviance")
AIC(out, phi = "mle")
AIC(out, phi = "grcv")
</code></pre>

<hr>
<h2 id='alon'>
Data from the microarray experiment done by Alon et al. (1999)
</h2><span id='topic+alon'></span>

<h3>Description</h3>

<p>The data set contains the gene expression data origianlly analized in Alon et al. (1999). 62 samples (40 tumor samples, 22 normal samples) from colon-cancer patients were analyzed with an Affymetrix oligonucleotide Hum6000 array. The binary variable <code>y</code> is used to indicate a normal sample (<code>y = 0</code>) or a tumor sample (<code>y = 1</code>).
</p>
<p>Two thousand out of around 6500 genes were selected based on the confidence in the measured expression levels (for details refer to publication).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(alon)</code></pre>


<h3>References</h3>

<p>Alon U., Barkai N., Notterman D.A., Gish K., Ybarra S., Mack D. and Levine A.J. (1999) &lt;doi:10.1073/pnas.96.12.6745&gt;
<em>Broad patterns of gene expression revealed by clustering analysis of tumor and normal colon tissue probed by oligonucleotide arrays.</em> <em>Proc. Natl. Acad. Sci. USA</em> <b>96</b>, 6745-6750
</p>

<hr>
<h2 id='breast'>
Breast Cancer microarray experiment
</h2><span id='topic+breast'></span>

<h3>Description</h3>

<p>This data set details microarray experiment for 52 breast cancer patients. The binary variable <code>status</code> is used to indicate whether or not the patient has died of breast cancer (<code>status = 0</code> = did not die of breast cancer, <code>status = 1</code> = died of breast cancer). The other variables contain the amplification or deletion of the considered genes.
</p>
<p>Rather than measuring gene expression, this experiment aims to measure gene amplification or deletion, which refers to the number of copies of a particular DNA sequence within the genome. The aim of the experiment is to find out the key genomic factors involved in agressive and non-agressive forms of breast cancer.
</p>
<p>The experiment was conducted by the Dr.\ John Bartlett and Dr.\ Caroline Witton in the Division of Cancer Sciences and Molecular Pathology of the University of Glasgow at the city's Royal Infirmary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breast)</code></pre>


<h3>Source</h3>

<p>Dr. John Bartlett and Dr. Caroline Witton, Division of Cancer Sciences and Molecular Pathology, University of Glasgow, Glasgow Royal Infirmary.
</p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013) &lt;doi:10.1111/rssb.12000&gt;
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>, <em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>
<p>Wit E.C. and McClure J. (2004, ISBN:978-0-470-84993-4)
&quot;Statistics for Microarrays: Design, Analysis and Inference&quot;
Chichester: Wiley.
</p>

<hr>
<h2 id='coef.cvdglars'>Extract the Coefficients Estimated by <code>cvdglars</code></h2><span id='topic+coef.cvdglars'></span>

<h3>Description</h3>

<p><code>coef.cvdglars</code> is used to extract the coefficients estimated by <code class="reqn">k</code>-fold cross-validation deviance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvdglars'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cvdglars_+3A_object">object</code></td>
<td>
<p>fitted <code>cvdglars</code> object</p>
</td></tr>
<tr><td><code id="coef.cvdglars_+3A_...">...</code></td>
<td>
<p>additional argument used to ensure the compatibility with the generic method function &ldquo;<code><a href="stats.html#topic+coef">coef</a></code>&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef.cvdglars</code> returns a named list with components <code>beta</code>, i.e., the estimate of the coefficient vector, and <code>phi</code> the estimate of the dispersion parameter.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cvdglars">cvdglars</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
# Logistic regression model
set.seed(123)
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n * p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[,1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- cvdglars.fit(X, y, family = binomial)
coef(fit)
</code></pre>

<hr>
<h2 id='coef.dglars'>Extract the dgLARS Coefficient Path</h2><span id='topic+coef.dglars'></span>

<h3>Description</h3>

<p><code>coef.dglars</code> is used to extract the coefficient path computed by dgLARS method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
coef(object, type = c("pearson", "deviance", "mle", "grcv"),
g = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.dglars_+3A_object">object</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="coef.dglars_+3A_type">type</code></td>
<td>
<p>a description of the estimator used for the dispersion parameter.</p>
</td></tr>
<tr><td><code id="coef.dglars_+3A_g">g</code></td>
<td>
<p>vector of values of the tuning parameter.</p>
</td></tr>
<tr><td><code id="coef.dglars_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function <code>link{grcv}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coef.dglars</code> is a wrapper function calling &ldquo;<code><a href="#topic+predict.dglars">predict.dglars</a></code>&rdquo; and &ldquo;<code><a href="#topic+phihat">phihat</a></code>&rdquo;. By default, this function returns the sequence of the penalized coefficients and the sequence of the penalized estimate of the dispersion parameter <code class="reqn">\phi</code>. The user can specify the argumnets of the function <code><a href="#topic+grcv">grcv</a></code> by the argument <code>...</code>).
</p>


<h3>Value</h3>

<p><code>coef.dglars</code> returns a named list with component:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>the sequence of the penalized estimates of the regression coefficients;</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the penalized estimates of the dispersion parameter;</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the vector of the values of the tuning parameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.dglars">predict.dglars</a></code>, <code><a href="#topic+phihat">phihat</a></code> and <code><a href="#topic+grcv">grcv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
# Logistic regression model
set.seed(123)
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n * p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[, 1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars(y ~ X, family = binomial)
coef(fit)
coef(fit, g = seq(4, 0.5, length = 10))

###########################
# Gamma family
n &lt;- 100
p &lt;- 10
X &lt;- matrix(abs(rnorm(n * p)), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[, 1] * b[2]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
fit &lt;- dglars(y ~ X, Gamma("log"))
coef(fit, type = "pearson")
coef(fit, type = "deviance")
coef(fit, type = "mle")
</code></pre>

<hr>
<h2 id='cvdglars'>Cross-Validation Method for dgLARS</h2><span id='topic+cvdglars'></span><span id='topic+cvdglars.fit'></span>

<h3>Description</h3>

<p>Uses the <code class="reqn">k</code>-fold cross-validation deviance to estimate the solution point of the dgLARS solution curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvdglars(formula, family = gaussian, g, unpenalized, 
b_wght, data, subset, contrasts = NULL, control = list())

cvdglars.fit(X, y, family = gaussian, g, unpenalized,
b_wght, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvdglars_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo;:
a symbolic description of the model to be fitted. When the
<code>binomial</code> family is used, the responce can be a vector
with entries 0/1 (failure/success) or, alternatively, a
matrix where the first column is the number of &ldquo;successes&rdquo;
and the second column is the number of &ldquo;failures&rdquo;.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function used to specify the model. This can be a character string
naming a family function or the result of a call to a family function
(see <code><a href="stats.html#topic+family">family</a></code> for details). By default the gaussian family
with identity link function is used.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_g">g</code></td>
<td>
<p>argument available only for <code>ccd</code> algorithm. When the <code>ccd</code>
algorithm is used to fit the dgLARS model, this argument can be used to specify
the values of the tuning parameter.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_unpenalized">unpenalized</code></td>
<td>
<p>a vector used to specify the unpenalized estimators;
<code>unpenalized</code> can be a vector of integers or characters specifying
the names of the predictors with unpenalized estimators.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_b_wght">b_wght</code></td>
<td>
<p>a vector, with length equal to the number of columns of
the matrix <code>X</code>, used to compute the weights used in the
adaptive dgLARS method. <code>b_wght</code> is used to specify the
initial estimates of the parameter vector.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by &lsquo;as.data.frame&rsquo; to a data frame) containing the
variables in the model. If not found in &lsquo;data&rsquo;, the
variables are taken from &lsquo;environment(formula)&rsquo;.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the &lsquo;contrasts.arg&rsquo; of
&lsquo;model.matrix.default&rsquo;.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_x">X</code></td>
<td>
<p>design matrix of dimension <code class="reqn">n\times p</code>.</p>
</td></tr>
<tr><td><code id="cvdglars_+3A_y">y</code></td>
<td>
<p>response vector. When the <code>binomial</code> family is used,
this argument can be a vector with entries 0 (failure) or 1
(success). Alternatively, the response can be a matrix where
the first column is the number of &ldquo;successes&rdquo; and the second
column is the number of &ldquo;failures&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cvdglars</code> function runs <code>dglars</code> <code>nfold</code>+1 times. 
The deviance is stored, and the average and its standard deviation 
over the folds are computed.
</p>
<p><code>cvdglars.fit</code> is the workhorse function: it is more efficient 
when the design matrix have already been calculated. For this reason 
we suggest to use this function when the dgLARS method is applied in 
a high-dimensional setting, i.e. when <code>p&gt;n</code>.
</p>
<p>The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>algorithm</code>:</dt><dd><p>a string specifying the algorithm used to
compute the solution curve. The predictor-corrector algorithm is used
when <code>algorithm = ''pc''</code> (default), while the cyclic coordinate d
escent method is used setting <code>algorithm = ''ccd''</code>;</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a string by means of to specify the kind of solution curve.
If <code>method = ''dgLASSO''</code> (default) the algorithm computes the solution
curve defined by the differential geometric generalization of the LASSO
estimator; otherwise, if <code>method = ''dgLARS''</code>, the differential geometric
generalization of the least angle regression method is used;</p>
</dd>
<dt><code>nfold</code>:</dt><dd><p>a non negative integer used to specify the number of folds. 
Although <code>nfolds</code> can be as large as the sample size (leave-one-out CV), it 
is not recommended for large datasets. Default is <code>nfold = 10</code>;</p>
</dd>
<dt><code>foldid</code></dt><dd><p>a <code class="reqn">n</code>-dimensional vector of integers, between 1 and <code class="reqn">n</code>, 
used to define the folds for the cross-validation. By default <code>foldid</code> is 
randomly generated;</p>
</dd>
<dt><code>ng</code>:</dt><dd><p>number of values of the tuning parameter used to compute the 
cross-validation deviance. Default is <code>ng = 100</code>;</p>
</dd>
<dt><code>nv</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. An integer value 
belonging to the interval <code class="reqn">[1;min(n,p)]</code> (default is <code>nv = min(n-1,p)</code>) 
used to specify the maximum number of variables included in the final model;</p>
</dd>
<dt><code>np</code>:</dt><dd><p>control parameter for the <code>pc/ccd</code> algorithm. A non negative 
integer used to define the maximum number of points of the solution curve. For the
predictor-corrector algorithm <code>np</code> is set to <code class="reqn">50 \cdot min(n-1,p)</code> (default), 
while for the cyclic coordinate descent method is set to 100 (default), i.e. the number 
of values of the tuning parameter <code class="reqn">\gamma</code>;</p>
</dd>
<dt><code>g0</code>:</dt><dd><p>control parameter for the <code>pc/ccd</code> algorithm. Set the smallest 
value for the tuning parameter <code class="reqn">\gamma</code>. Default is <code>g0 = ifelse(p&lt;n, 1.0e-06, 0.05)</code>;</p>
</dd>
<dt><code>dg_max</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. A non negative value 
used to specify the maximum length of the step size. Setting <code>dg_max = 0</code> (default) 
the predictor-corrector algorithm uses the optimal step size (see Augugliaro et al. (2013) 
for more details) to approximate the value of the tuning parameter corresponding to the 
inclusion/exclusion of a variable from the model;</p>
</dd>
<dt><code>nNR</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. A non negative integer 
used to specify the maximum number of iterations of the Newton-Raphson algorithm 
used in the corrector step. Default is <code>nNR = 200</code>;</p>
</dd>
<dt><code>NReps</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. A non negative 
value used to define the convergence criterion of the Newton-Raphson algorithm. 
Default is <code>NReps = 1.0e-06</code>;</p>
</dd>
<dt><code>ncrct</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. When the Newton-Raphson 
algorithm does not converge, the step size (<code class="reqn">d\gamma</code>) is reduced by 
<code class="reqn">d\gamma = cf \cdot d\gamma</code> and the corrector step is repeated. <code>ncrct</code> 
is a non negative integer used to specify the maximum number of trials for the corrector step. 
Default is <code>ncrct = 50</code>;</p>
</dd>
<dt><code>cf</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. The contractor factor 
is a real value belonging to the interval <code class="reqn">[0,1]</code> used to reduce the step size 
as previously described. Default is <code>cf = 0.5</code>;</p>
</dd>
<dt><code>nccd</code>:</dt><dd><p>control parameter for the <code>ccd</code> algorithm. A non negative integer 
used to specify the maximum number for steps of the cyclic coordinate descent algorithm.
Default is <code>1.0e+05</code>.</p>
</dd>
<dt><code>eps</code></dt><dd><p>control parameter for the <code>pc/ccd</code> algorithm. The meaning of 
this parameter is related to the algorithm used to estimate the solution curve:
</p>
			
<dl>
<dt><code>i.</code></dt><dd><p>if <code>algorithm = ''pc''</code> then <code>eps</code> is used
</p>

<dl>
<dt><code>a.</code></dt><dd><p>to identify a variable that will be included in the active 
set (absolute value of the corresponding Rao's score test 
statistic belongs to 
<code class="reqn">[\gamma - \code{eps}, \gamma + \code{eps}]</code>);</p>
</dd>
<dt><code>b.</code></dt><dd><p>to establish if the corrector step must be repeated;</p>
</dd>
<dt><code>c.</code></dt><dd><p>to define the convergence of the algorithm, i.e., the 
actual value of the tuning parameter belongs to the interval 
<code class="reqn">[\code{g0 - eps},\code{g0 + eps}]</code>;</p>
</dd>
</dl>
</dd>
<dt><code>ii.</code></dt><dd><p>if <code>algorithm = ''ccd''</code> then <code>eps</code> is used to define the 
convergence for a single solution point, i.e., each inner coordinate-descent loop 
continues until the maximum change in the Rao's score test statistic, after any 
coefficient update, is less than <code>eps</code>.</p>
</dd></dl>

<p>Default is <code>eps = 1.0e-05.</code></p>
</dd></dl>



<h3>Value</h3>

<p><code>cvdglars</code> returns an object with S3 class &ldquo;<code>cvdglars</code>&rdquo;, i.e. a list 
containing the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object;</p>
</td></tr>
<tr><td><code>formula_cv</code></td>
<td>
<p>if the model is fitted by <code>cvdglars</code>, the used formula is returned;</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>a description of the error distribution used in the model;</p>
</td></tr>
<tr><td><code>var_cv</code></td>
<td>
<p>a character vector with the name of variables selected by cross-validation;</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the vector of the coefficients estimated by cross-validation;</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the cross-validation estimate of the disperion parameter;</p>
</td></tr>
<tr><td><code>dev_m</code></td>
<td>
<p>a vector of length <code>ng</code> used to store the mean cross-validation 
deviance;</p>
</td></tr>
<tr><td><code>dev_v</code></td>
<td>
<p>a vector of length <code>ng</code> used to store the variance of the mean 
cross-validation deviance;</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the value of the tuning parameter corresponding to the minimum of 
the cross-validation deviance;</p>
</td></tr>
<tr><td><code>g0</code></td>
<td>
<p>the smallest value for the tuning parameter;</p>
</td></tr>
<tr><td><code>g_max</code></td>
<td>
<p>the value of the tuning parameter corresponding to the starting 
point of the dgLARS solution curve;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the used design matrix;</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the used response vector;</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the vector of weights used to compute the adaptive dglars method;</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>an integer value used to encode the warnings and the errors 
related to the algorithm used to fit the dgLARS solution curve. The values returned are:
</p>

<dl>
<dt><code>0</code></dt><dd><p>convergence of the algorithm has been achieved,</p>
</dd>
<dt><code>1</code></dt><dd><p>problems related with the predictor-corrector method: error in predictor step,</p>
</dd>
<dt><code>2</code></dt><dd><p>problems related with the predictor-corrector method: error in corrector step,</p>
</dd>
<dt><code>3</code></dt><dd><p>maximum number of iterations has been reached,</p>
</dd>
<dt><code>4</code></dt><dd><p>error in dynamic allocation memory;</p>
</dd>
</dl>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the list of control parameters used to compute the cross-validation deviance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2014) &lt;doi:10.18637/jss.v059.i08&gt;
<em>dglars: An R Package to Estimate Sparse Generalized Linear Models</em>, <em>Journal of Statistical Software</em>, Vol 59(8), 1-40. <a href="https://www.jstatsoft.org/v59/i08/">https://www.jstatsoft.org/v59/i08/</a>.
</p>
<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013) &lt;doi:10.1111/rssb.12000&gt;
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>, <em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.cvdglars">coef.cvdglars</a></code>, <code><a href="#topic+print.cvdglars">print.cvdglars</a></code>, <code><a href="#topic+plot.cvdglars">plot.cvdglars</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
# Logistic regression model
# y ~ Binomial
set.seed(123)
n &lt;- 100
p &lt;- 100
X &lt;- matrix(rnorm(n * p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[, 1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit_cv &lt;- cvdglars.fit(X, y, family = binomial)
fit_cv
</code></pre>

<hr>
<h2 id='dglars'>dgLARS Solution Curve for GLM</h2><span id='topic+dglars'></span><span id='topic+dglars.fit'></span>

<h3>Description</h3>

<p><code>dglars</code> function is used to estimate the solution curve defined by dgLARS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dglars(formula, family = gaussian, g, unpenalized, 
b_wght, data, subset, contrasts = NULL, control = list())

dglars.fit(X, y, family = gaussian, g, unpenalized, 
b_wght, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dglars_+3A_formula">formula</code></td>
<td>
<p>an object of class &ldquo;<code><a href="stats.html#topic+formula">formula</a></code>&rdquo;:
a symbolic description of the model to be fitted. When the
<code>binomial</code> family is used, the responce can be a vector
with entries 0/1 (failure/success) or, alternatively, a
matrix where the first column is the number of &ldquo;successes&rdquo;
and the second column is the number of &ldquo;failures&rdquo;.</p>
</td></tr>
<tr><td><code id="dglars_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function used to specify the model. This can be a character string
naming a family function or the result of a call to a family function
(see <code><a href="stats.html#topic+family">family</a></code> for details). By default the gaussian family
with identity link function is used.</p>
</td></tr>
<tr><td><code id="dglars_+3A_g">g</code></td>
<td>
<p>argument available only for <code>ccd</code> algorithm. When the model
is fitted by using the <code>ccd</code> algorithm, this argument can be used to
specify the values of the tuning parameter.</p>
</td></tr>
<tr><td><code id="dglars_+3A_unpenalized">unpenalized</code></td>
<td>
<p>a vector used to specify the unpenalized estimators;
<code>unpenalized</code> can be a vector of integers or characters specifying
the names of the predictors with unpenalized estimators (see example
below for more details).</p>
</td></tr>
<tr><td><code id="dglars_+3A_b_wght">b_wght</code></td>
<td>
<p>a <code class="reqn">p+1</code>-dimensional vector used to compute
the weights in the adaptive dgLARS method. <code>b_wght</code> is used
to specify the initial estimates of the parameter vector.</p>
</td></tr>
<tr><td><code id="dglars_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by &lsquo;as.data.frame&rsquo; to a data frame) containing the
variables in the model. If not found in &lsquo;data&rsquo;, the
variables are taken from &lsquo;environment(formula)&rsquo;.</p>
</td></tr>
<tr><td><code id="dglars_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="dglars_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the &lsquo;contrasts.arg&rsquo; of
&lsquo;model.matrix.default&rsquo;.</p>
</td></tr>
<tr><td><code id="dglars_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dglars_+3A_x">X</code></td>
<td>
<p>design matrix of dimension <code class="reqn">n\times p</code>.</p>
</td></tr>
<tr><td><code id="dglars_+3A_y">y</code></td>
<td>
<p>response vector. When the <code>binomial</code> family is used,
this argument can be a vector with entries 0 (failure) or 1
(success). Alternatively, the response can be a matrix where
the first column is the number of &ldquo;successes&rdquo; and the second
column is the number of &ldquo;failures&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dglars</code> function implements the differential geometric generalization 
of the least angle regression method (Efron et al., 2004) proposed in 
Augugliaro et al. (2013) and Pazira et al. (2017).
</p>
<p>As in &ldquo;<code><a href="stats.html#topic+glm">glm</a></code>&rdquo;, the user can specify family and link function using
the argument <code>family</code>. When the <code>binomial</code> family is used, the responce
can be a vector with entries 0/1 (failure/success) or, alternatively, a matrix where
the first column is the number of &ldquo;successes&rdquo; and the second column is the number
of &ldquo;failures&rdquo;. Starting with the version 2.0.0, the model can be specified combining
family and link functions as describted in the following table:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>Family</b>   </td><td style="text-align: left;"> <b>Link</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>gaussian</code> </td><td style="text-align: left;"> &lsquo;<code>identity</code>&rsquo;, &lsquo;<code>log</code>&rsquo; and &lsquo;<code>inverse</code>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>binomial</code> </td><td style="text-align: left;"> &lsquo;<code>logit</code>&rsquo;, &lsquo;<code>probit</code>&rsquo;, &lsquo;<code>cauchit</code>&rsquo;, &lsquo;<code>log</code>&rsquo; and &lsquo;<code>cloglog</code>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>poisson</code>  </td><td style="text-align: left;"> &lsquo;<code>log</code>&rsquo;, &lsquo;<code>identity</code>&rsquo;, and &lsquo;<code>sqrt</code>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Gamma</code>    </td><td style="text-align: left;"> &lsquo;<code>inverse</code>&rsquo;, &lsquo;<code>identity</code>&rsquo; and &lsquo;<code>log</code>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>inverse.gaussian</code> </td><td style="text-align: left;"> &lsquo;<code>1/mu^2</code>&rsquo;, &lsquo;<code>inverse</code>&rsquo;, &lsquo;<code>identity</code>&rsquo;, and &lsquo;<code>log</code>&rsquo;
</td>
</tr>

</table>

<p>The <code>R</code> code for binomial, Gamma and inverse gaussian families is due to
Hassan Pazira while the fortran version is due to Luigi Augugliaro.
</p>
<p><code>dglars.fit</code> is a workhorse function: it is more efficient when the design
matrix does not require manipulations. For this reason we suggest to use this function
when the dgLARS method is applied in a high-dimensional setting, i.e., when <code>p&gt;n</code>.
</p>
<p>When gaussian, gamma or inverse.gaussian is used to model the error distribution, <code>dglars</code>
returns the vector of the estimates of the dispersion parameter <code class="reqn">\phi</code>; by
default, the generalized Pearson statistic is used as estimator but the user can use
the function <code>phihat</code> to specify other estimators (see <code><a href="#topic+phihat">phihat</a></code> for
more details).
</p>
<p>The dgLARS solution curve can be estimated using two different algorithms, i.e. the 
predictor-corrector method and the cyclic coordinate descent method (see below for 
more details about the argument <code>algorithm</code>). The first algorithm is
based on two steps. In the first step, called predictor step, an approximation of 
the point that lies on the solution curve is computed. If the control parameter 
<code>dg_max</code> is equal to zero, in this step it is also computed an approximation 
of the optimal step size using a generalization of the method proposed in Efron 
et al. (2004). The optimal step size is defined as the reduction of the tuning parameter, 
denoted by <code class="reqn">d\gamma</code>, such that at <code class="reqn">\gamma-d\gamma</code> there is a change in the
active set. In the second step, called corrector step, a Newton-Raphson algorithm is used to
correct the approximation previously computed. The main problem of this algorithm is that the
number of arithmetic operations required to compute the approximation scales as the cube
of the variables, this means that such algorithm is cumbersome in a high dimensional setting. 
To overcome this problem, the second algorithm compute the dgLARS solution curve using an 
adaptive version of the cyclic coordinate descent method proposed in Friedman et al. (2010).
</p>
<p>The argument <code>control</code> is a list that can supply any of the following components:
</p>

<dl>
<dt><code>algorithm</code>:</dt><dd><p>a string specifying the algorithm used to
compute the solution curve. The predictor-corrector algorithm is used
when <code>algorithm = ''pc''</code> (default), while the cyclic coordinate
descent method is used setting <code>algorithm = ''ccd''</code>;</p>
</dd>
<dt><code>method</code>:</dt><dd><p>a string by means of to specify the kind of solution curve.
If <code>method = ''dgLASSO''</code> (default) the algorithm computes the solution
curve defined by the differential geometric generalization of the LASSO
estimator; otherwise (<code>method = ''dgLARS''</code>) the differential geometric
generalization of the least angle regression method is used;</p>
</dd>
<dt><code>nv</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. An integer value
between 1 and <code class="reqn">\min(n,p)</code> used to specify the maximum number of
variables in the final model. Default is <code>nv = min(n - 1, p)</code>;</p>
</dd>
<dt><code>np</code>:</dt><dd><p>control parameter for the <code>pc/ccd</code> algorithm. A non negative 
integer used to define the maximum number of solution points. For the predictor-corrector 
algorithm <code>np</code> is set to <code class="reqn">50\times\min(n - 1, p)</code> (default); for 
the cyclic coordinate descent method, if <code>g</code> is not specified, this argument is
set equal to 100 (default);</p>
</dd>
<dt><code>g0</code>:</dt><dd><p>control parameter for the <code>pc/ccd</code> algorithm. This parameter is 
used to set the smallest value for the tuning parameter <code class="reqn">\gamma</code>. Default is 
<code>g0 = ifelse(p &lt; n, 1.0e-04, 0.05)</code>; this argument is not required when <code>g</code> is
used with the cyclic coordinate descent algorithm;</p>
</dd>
<dt><code>dg_max</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. A non negative 
value used to specify the largest value for the step size. Setting <code>dg_max = 0</code> 
(default) the predictor-corrector algorithm computes an approximation of the optimal 
step size (see Augugliaro et al. (2013) for more details);</p>
</dd>
<dt><code>nNR</code>:</dt><dd><p>control criterion parameter for the <code>pc</code> algorithm. A non 
negative integer used to specify the maximum number of iterations of the Newton-Raphson 
algorithm. Default is <code>nNR = 50</code>;</p>
</dd>
<dt><code>NReps</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. A non negative 
value used to define the convergence of the Newton-Raphson algorithm. Default is 
<code>NReps = 1.0e-06</code>;</p>
</dd>
<dt><code>ncrct</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. When the Newton-Raphson 
algorithm does not converge, the step size (<code class="reqn">d\gamma</code>) is reduced by 
<code class="reqn">d\gamma = cf \cdot d\gamma</code> and the corrector step is repeated. <code>ncrct</code> 
is a non negative integer used to specify the maximum number of trials for the corrector step. 
Default is <code>ncrct = 50</code>;</p>
</dd>
<dt><code>cf</code>:</dt><dd><p>control parameter for the <code>pc</code> algorithm. The contractor factor 
is a real value belonging to the interval <code class="reqn">[0,1]</code> used to reduce the step size 
as previously described. Default is <code>cf = 0.5</code>;</p>
</dd>
<dt><code>nccd</code>:</dt><dd><p>control parameter for the <code>ccd</code> algorithm. A non negative integer 
used to specify the maximum number for steps of the cyclic coordinate descent algorithm.
Default is <code>1.0e+05</code>.</p>
</dd>
<dt><code>eps</code></dt><dd><p>control parameter for the <code>pc/ccd</code> algorithm. The meaning of 
this parameter is related to the algorithm used to estimate the solution curve:
</p>
			
<dl>
<dt><code>i.</code></dt><dd><p>if <code>algorithm = ''pc''</code> then <code>eps</code> is used
</p>

<dl>
<dt><code>a.</code></dt><dd><p>to identify a variable that will be included in the active 
set (absolute value of the corresponding Rao's score test 
statistic belongs to 
<code class="reqn">[\gamma - \code{eps}, \gamma + \code{eps}]</code>);</p>
</dd>
<dt><code>b.</code></dt><dd><p>to establish if the corrector step must be repeated;</p>
</dd>
<dt><code>c.</code></dt><dd><p>to define the convergence of the algorithm, i.e., the 
actual value of the tuning parameter belongs to the interval 
<code class="reqn">[\code{g0 - eps},\code{g0 + eps}]</code>;</p>
</dd>
</dl>
</dd>
<dt><code>ii.</code></dt><dd><p>if <code>algorithm = ''ccd''</code> then <code>eps</code> is used to define the 
convergence for a single solution point, i.e., each inner coordinate-descent loop 
continues until the maximum change in the Rao's score test statistic, after any 
coefficient update, is less than <code>eps</code>.</p>
</dd></dl>

<p>Default is <code>eps = 1.0e-05.</code></p>
</dd></dl>



<h3>Value</h3>

<p><code>dglars</code> returns an object with S3 class &ldquo;<code>dglars</code>&rdquo;, i.e., a list containing the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object;</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>if the model is fitted by <code>dglars</code>, the used formula is returned;</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>a description of the error distribution used in the model;</p>
</td></tr>
<tr><td><code>unpenalized</code></td>
<td>
<p>the vector used to specify the unpenalized estimators;</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>the number of points of the dgLARS solution curve;</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the <code class="reqn">(p + 1)\times\code{np}</code> matrix corresponding to the 
dgLARS solution curve;</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the <code>np</code> dimensional vector of the Pearson estimates of the disperion 
parameter;</p>
</td></tr>
<tr><td><code>ru</code></td>
<td>
<p>the matrix of the Rao's score test statistics of the variables included in 
the final model. This component is reported only if the predictor-corrector algorithm 
is used to fit the model;</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>the <code>np</code> dimensional vector of the deviance corresponding to the 
values of the tuning parameter <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code>nnonzero</code></td>
<td>
<p>the sequence of number of nonzero coefficients for each value of the 
tuning parameter <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the sequence of <code class="reqn">\gamma</code> values used to compute the solution curve;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the used design matrix;</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the used response vector;</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the vector of weights used to compute the adaptive dglars method;</p>
</td></tr>
<tr><td><code>action</code></td>
<td>
<p>a <code>np</code> dimensional vector of characters used to show how is 
changed the active set for each value of the tuning parameter <code class="reqn">\gamma</code>;</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>an integer value used to encode the warnings and the errors related 
to the algorithm used to fit the model. The values returned are:
</p>

<dl>
<dt><code>0</code></dt><dd><p>convergence of the algorithm has been achieved;</p>
</dd>
<dt><code>1</code></dt><dd><p>problems related with the predictor-corrector 
method: error in predictor step;</p>
</dd>
<dt><code>2</code></dt><dd><p>problems related with the predictor-corrector 
method: error in corrector step;</p>
</dd>
<dt><code>3</code></dt><dd><p>maximum number of iterations has been reached;</p>
</dd>
<dt><code>4</code></dt><dd><p>error in dynamic allocation memory;</p>
</dd>
<dt><code>5</code></dt><dd><p>fitted expected value is out of range;</p>
</dd>
<dt><code>6</code></dt><dd><p>does not exist dgLARS estimator;</p>
</dd>
<dt><code>7</code></dt><dd><p>maximum number of solution points ('codenp') reached.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the list of control parameters used to compute the dgLARS solution curve.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro and Hassan Pazira<br />
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2016) &lt;doi:10.1093/biomet/asw023&gt;
<em>A differential-geometric approach to generalized linear models with grouped predictors</em>, 
<em>Biometrika</em>, Vol 103(3), 563-577.
</p>
<p>Augugliaro L., Mineo A.M. and Wit E.C. (2014) &lt;doi:10.18637/jss.v059.i08&gt;
<em>dglars: An R Package to Estimate Sparse Generalized Linear Models</em>, <em>Journal of Statistical Software</em>, Vol 59(8), 1-40. <a href="https://www.jstatsoft.org/v59/i08/">https://www.jstatsoft.org/v59/i08/</a>.
</p>
<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013) &lt;doi:10.1111/rssb.12000&gt;
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>, <em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>
<p>Efron B., Hastie T., Johnstone I. and Tibshirani R. (2004) &lt;doi:10.1214/009053604000000067&gt;
<em>Least Angle Regression</em>, <em>The Annals of Statistics</em>, Vol. 32(2), 407-499.
</p>
<p>Friedman J., Hastie T. and Tibshirani R. (2010) &lt;doi:10.18637/jss.v033.i01&gt;
<em>Regularization Paths for Generalized Linear Models via Coordinate Descent</em>, <em>Journal of Statistical Software</em>, Vol. 33(1), 1-22.
</p>
<p>Pazira H., Augugliaro L. and Wit E.C. (2018) &lt;doi:10.1007/s11222-017-9761-7&gt;
<em>Extended di erential geometric LARS for high-dimensional GLMs with general dispersion parameter</em>,
<em>Statistics and Computing</em>, Vol. 28(4), 753-774.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.dglars">coef.dglars</a></code>, <code><a href="#topic+phihat">phihat</a></code>, <code><a href="#topic+plot.dglars">plot.dglars</a></code>, <code><a href="#topic+print.dglars">print.dglars</a></code> and <code><a href="#topic+summary.dglars">summary.dglars</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

#############################
# y ~ Binomial
n &lt;- 100
p &lt;- 100
X &lt;- matrix(rnorm(n * p), n, p)
eta &lt;- 1 + 2 * X[,1]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars(y ~ X, family = binomial)
fit

# adaptive dglars method
b_wght &lt;- coef(fit)$beta[, 20]
fit &lt;- dglars(y ~ X, family = binomial, b_wght = b_wght) 
fit 

# the first three coefficients are not penalized
fit &lt;- dglars(y ~ X, family = binomial, unpenalized = 1:3) 
fit 

# 'probit' link function
fit &lt;- dglars(y ~ X, family = binomial("probit"))
fit

############################
# y ~ Poisson 
n &lt;- 100
p &lt;- 100
X &lt;- matrix(rnorm(n * p), n, p)
eta &lt;- 2 + 2 * X[,1]
mu &lt;- poisson()$linkinv(eta)
y &lt;- rpois(n, mu)
fit &lt;- dglars(y ~ X, family = poisson)
fit

############################
# y ~ Gamma
n &lt;- 100
p &lt;- 100
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + 2 * X[,1]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
fit &lt;- dglars(y ~ X, Gamma("log"))
fit
</code></pre>

<hr>
<h2 id='dglars-internal'>Internal dglars Functions</h2><span id='topic+d2th_dmu2_mk'></span><span id='topic+d2mu_de2_mk'></span><span id='topic+dglars_pc'></span><span id='topic+dglars_ccd'></span><span id='topic+make_dglars'></span><span id='topic+make_coef'></span><span id='topic+make_ru'></span><span id='topic+make_action'></span><span id='topic+make_summary_table'></span><span id='topic+setDiff'></span><span id='topic+cvdglars_pc'></span><span id='topic+cvdglars_ccd'></span><span id='topic+make_cvdglars'></span>

<h3>Description</h3>

<p>Internal dglars functions.</p>


<h3>Details</h3>

<p>These functions are not intended for use by users.</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro</p>

<hr>
<h2 id='duke'>
Duke breast cancer microarray experiment
</h2><span id='topic+duke'></span>

<h3>Description</h3>

<p>This data set details microarray experiment for 44 breast cancer patients. The binary variable <code>Status</code> is used to classify the patients into estrogen receptor-positive (<code>Status = 0</code>) and estrogen receptor-negative (<code>Status = 1</code>). The other variables  contain the expression level of the considered genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(duke)</code></pre>


<h3>References</h3>

<p>M. West, C. Blanchette, H. Dressman, E. Huang, S. Ishida, R. Spang, H. Zuzan, J.A. Olson, Jr., J.R. Marks and Joseph R. Nevins (2001) &lt;doi:10.1073/pnas.201162998&gt;
<em>Predicting the clinical status of human breast cancer by using gene expression profiles</em>, <em>Proceedings of the National Accademy of Sciences of the USA</em>, Vol 98(20), 11462-11467.
</p>

<hr>
<h2 id='gdf'>
Estimate the Generalized Degrees-of-Freedom
</h2><span id='topic+gdf'></span><span id='topic+print.gof_dglars'></span>

<h3>Description</h3>

<p><code>gdf</code> returns to estimate of the generalized degrees-of-freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdf(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdf_+3A_object">object</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a general nonlinear modelling procedure, a rigorous definition of 
degrees-of-freedom is obtained using the covariance penalty theory 
(Efron, 2004). This theory was used in Augugliaro et al. (2013) to
define a measure of model complexity for the dgLARS method, called
&ldquo;generalized degrees-of-freedom&rdquo;. The <code>gdf</code> function
implements the estimator proposed in Augugliaro et al. (2013).
</p>


<h3>Value</h3>

<p><code>gdf</code> returns a vector of length <code>np</code> with the generalized degrees-of-freedom.</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro and Hassan Pazira<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Augugliaro L., Mineo A.M. and Wit E.C. (2014) &lt;doi:10.18637/jss.v059.i08&gt;
<em>dglars: An R Package to Estimate Sparse Generalized Linear Models</em>, 
<em>Journal of Statistical Software</em>, Vol 59(8), 1-40. <a href="https://www.jstatsoft.org/v59/i08/">https://www.jstatsoft.org/v59/i08/</a>.
</p>
<p>Augugliaro L., Mineo A.M. and Wit E.C. (2013) &lt;doi:10.1111/rssb.12000&gt;
<em>dgLARS: a differential geometric approach to sparse generalized linear models</em>, 
<em>Journal of the Royal Statistical Society. Series B.</em>, Vol 75(3), 471-498.
</p>
<p>Efron B. (2004) &lt;doi:10.1198/016214504000000692&gt;
<em>The estimation of prediction error: covariance penalties and cross-validation</em>, 
<em>Journal of the American Statistical Association</em>, Vol. 99(467), 619-632.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dglars">dglars</a></code>, <code><a href="#topic+AIC.dglars">AIC.dglars</a></code>, <code><a href="#topic+BIC.dglars">BIC.dglars</a></code> and <code><a href="#topic+summary.dglars">summary.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n*p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[,1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars(y ~ X, binomial)
gdf(fit)
</code></pre>

<hr>
<h2 id='grcv'>
General Refitted Cross-Validation Estimator
</h2><span id='topic+grcv'></span>

<h3>Description</h3>

<p><code>grcv</code> computes the estimate of the dispersion parameter using the general refitted cross-validation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grcv(object, type = c("BIC", "AIC"), nit = 10L, trace = FALSE,
     control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grcv_+3A_object">object</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="grcv_+3A_type">type</code></td>
<td>
<p>the measure of goodness-of-fit used in Step 2 to select the two set of variables (see section <b>Description</b> for more details). Default is <code>type = BIC</code>.</p>
</td></tr>
<tr><td><code id="grcv_+3A_control">control</code></td>
<td>
<p>a list of control parameters passed to the function <code><a href="#topic+dglars">dglars</a></code>.</p>
</td></tr>
<tr><td><code id="grcv_+3A_nit">nit</code></td>
<td>
<p>integer specifying the number of times that the general refitted cross-validation method is repeated (see section <b>Description</b> for more details). Default is <code>nit = 10L</code>.</p>
</td></tr>
<tr><td><code id="grcv_+3A_trace">trace</code></td>
<td>
<p>flag used to print out information about the algorithm. Default is <code>trace = FALSE</code>.</p>
</td></tr>
<tr><td><code id="grcv_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code><a href="#topic+AIC.dglars">AIC.dglars</a></code> or <code><a href="#topic+BIC.dglars">BIC.dglars</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general refitted cross-validation (grcv) estimator (Pazira et al., 2018) is an estimator of the dispersion parameter of the exponential family based on the following four stage procedure:
</p>

<table>
<tr>
 <td style="text-align: center;">
Step </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: center;">
1. </td><td style="text-align: left;"> randomly split the data set <code class="reqn">D = (y, X)</code> into two even datasets, denoted by <code class="reqn">D_1</code> and <code class="reqn">D_2</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
2. </td><td style="text-align: left;"> fit dglars model to the dataset <code class="reqn">D_1</code> to select a set of variables <code class="reqn">A_1</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
   </td><td style="text-align: left;"> fit dglars model to the dataset <code class="reqn">D_2</code> to select a set of variables <code class="reqn">A_2</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
3. </td><td style="text-align: left;"> fit the glm model to the dataset <code class="reqn">D_1</code> using the variables that are in <code class="reqn">A_2</code>; then estimate the </td>
</tr>
<tr>
 <td style="text-align: center;">
   </td><td style="text-align: left;"> disporsion parameter using the Pearson method. Denote by <code class="reqn">\hat{\phi}_1(A_2)</code> the resulting estimate.</td>
</tr>
<tr>
 <td style="text-align: center;">
   </td><td style="text-align: left;"> fit the glm model to the dataset <code class="reqn">D_2</code> using the variables that are in <code class="reqn">A_1</code>; then estimate the </td>
</tr>
<tr>
 <td style="text-align: center;">
   </td><td style="text-align: left;"> disporsion parameter using the Pearson method. Denote by <code class="reqn">\hat{\phi}_2(A_1)</code> the resulting estimate.</td>
</tr>
<tr>
 <td style="text-align: center;">
4. </td><td style="text-align: left;"> estimate <code class="reqn">\phi</code> using the following estimator: <code class="reqn">\hat{\phi}_{grcv} = (\hat{\phi}_1(A_2) + \hat{\phi}_2(A_1)) / 2</code>.
</td>
</tr>

</table>

<p>In order to reduce the random variabilty due to the splitting of the dataset (Step 1), the previous procedure is repeated &lsquo;<code>nit</code>&rsquo;-times; the median of the resulting estimates is used as final estimate of the dispersion parameter. In Step 3, the two sets of variables are selected using the <code><a href="#topic+AIC.dglars">AIC.dglars</a></code> and <code><a href="#topic+BIC.dglars">BIC.dglars</a></code>; in this step, the Pearson method is used to obtain a first estimate of the dispersion parameter. Furthermore, if the function <code><a href="stats.html#topic+glm">glm</a></code> does not converge the function <code><a href="#topic+dglars">dglars</a></code> is used to compute the maximum likelihood estimates.
</p>


<h3>Value</h3>

<p><code>grcv</code> returns the estimate of the dispersion parameter.</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro and Hassan Pazira<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Pazira H., Augugliaro L. and Wit E.C. (2018) &lt;doi:10.1007/s11222-017-9761-7&gt;
<em>Extended differential-geometric LARS for high-dimensional GLMs with general dispersion parameter</em>,
<em>Statistics and Computing</em>, Vol 28(4), 753-774.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phihat">phihat</a></code>, <code><a href="#topic+AIC.dglars">AIC.dglars</a></code> and <code><a href="#topic+BIC.dglars">BIC.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################
# y ~ Gamma
set.seed(321)
n &lt;- 100
p &lt;- 50
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + 2 * X[,1]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
fit &lt;- dglars(y ~ X, Gamma("log"))

phi
grcv(fit, type = "AIC")
grcv(fit, type = "BIC")
</code></pre>

<hr>
<h2 id='logLik.dglars'>Extract Log-Likelihood</h2><span id='topic+logLik'></span><span id='topic+logLik.dglars'></span><span id='topic+print.loglik_dglars'></span>

<h3>Description</h3>

<p>logLik method for an object with class &lsquo;dglars&rsquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
logLik(object, phi = c("pearson", "deviance", "mle", "grcv"),
	g = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.dglars_+3A_object">object</code></td>
<td>
<p>any fitted <code>dglars</code> object from which the log-likelihood values can be extracted.</p>
</td></tr>
<tr><td><code id="logLik.dglars_+3A_phi">phi</code></td>
<td>
<p>a description of the estimator used to estimate the dispersion pamater (see below for more details).</p>
</td></tr>
<tr><td><code id="logLik.dglars_+3A_g">g</code></td>
<td>
<p>vector of values of the tuning parameter.</p>
</td></tr>
<tr><td><code id="logLik.dglars_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function <code><a href="#topic+grcv">grcv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>logLik.dglars</code> returns the sequence of the log-likelihood values of the models fitted by &ldquo;<code>dglars</code>&rdquo;. For the binomial and Poisson family, the dispersion parameter is assumed known and equal to one while for the other families the dispersion parameter is estimated using the method specified by the argument &ldquo;<code>phi</code>&rdquo; (see <code><a href="#topic+phihat">phihat</a></code> for more details). The optional argument <code>g</code> is used to specified the values of the tuning parameter; if not specified (default), the log-likelihood values are computed for the sequence of models storage in <code>object</code> otherwise <code><a href="#topic+predict.dglars">predict.dglars</a></code> is used to compute the estimate of the parameters needed to evaluate the log-likelihood function (see the example below).
</p>


<h3>Value</h3>

<p><code>logLik.dglars</code> returns an object of class &ldquo;<code>loglik_dglars</code>&rdquo;. This is a named list containing the following components:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood of the sequence of models fitted by dglars method.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the numbers of non-zero estimates corresponding to the used <code class="reqn">\gamma</code>-values.</p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>the fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the sequence of <code class="reqn">\gamma</code>-values.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a description of the estimator used to estimate the dispersion pamater.</p>
</td></tr>
<tr><td><code>phih</code></td>
<td>
<p>the sequence of estimated dispersion parameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dglars">dglars</a></code>, <code><a href="#topic+phihat">phihat</a></code>, <code><a href="#topic+predict.dglars">predict.dglars</a></code>, <code><a href="#topic+AIC.dglars">AIC.dglars</a></code> and <code><a href="#topic+BIC.dglars">BIC.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################
# y ~ Poisson

library(dglars)
set.seed(123)
n &lt;- 100
p &lt;- 5
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + X[, 1]  + X[, 2]
mu &lt;- poisson()$linkinv(eta)
y &lt;- rpois(n, mu)
out &lt;- dglars(y ~ X, poisson)
logLik(out)
logLik(out, g = seq(2, 0.5, by = -0.1))

############################
# y ~ Gamma

n &lt;- 100
p &lt;- 5
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + 2 * X[, 1L]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
out &lt;- dglars(y ~ X, Gamma("log"))

# generalized Pearson statistic
logLik(out, phi = "pearson")

# deviance estimator
logLik(out, phi = "deviance")

# mle estimator
logLik(out, phi = "mle")

# grcv estimator
logLik(out, phi = "grcv")
</code></pre>

<hr>
<h2 id='phihat'>Estimate the Dispersion Parameter</h2><span id='topic+phihat'></span>

<h3>Description</h3>

<p><code>phihat</code> returns the estimates of the dispersion parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phihat(object, type = c("pearson", "deviance", "mle", "grcv"), g = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phihat_+3A_object">object</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="phihat_+3A_type">type</code></td>
<td>
<p>a description of the used estimator.</p>
</td></tr>
<tr><td><code id="phihat_+3A_g">g</code></td>
<td>
<p>vector of values of the tuning parameter.</p>
</td></tr>
<tr><td><code id="phihat_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function <code><a href="#topic+grcv">grcv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phihat</code> implements four different estimators of the dispersion parameter, i.e, the generalized Pearson statistic (<code>type = "pearson"</code>), the deviance estimator (<code>type = "deviance"</code>), the maximum likelihood estimator (<code>type = "mle"</code>) and general refitted cross-Validation estimator (<code>type = "grcv"</code>) proposed in Pazira et al. (2018). For regression models with Gamma family, the maximum likelihood estimator of the dispersion parameter is computed using the approximation proposed in Cordeiro et al. (1997).
</p>


<h3>Value</h3>

<p><code>phihat</code> returns a vector with the estimates of the dispersion parameter.</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>References</h3>

<p>Cordeiro G. M. and McCullagh P. (1991) &lt;doi:10.2307/2345592&gt;
Bias Correction in Generalized Linear Models,
<em>Journal of the Royal Statistical Society. Series B.</em>, Vol 53(3), 629&ndash;643.
</p>
<p>Jorgensen B. (1997, ISBN:0412997188)
<em>The Theory of Dispersion Models</em>,
Chapman and Hall, Great Britain.
</p>
<p>Pazira H., Augugliaro L. and Wit E.C. (2018) &lt;doi:10.1007/s11222-017-9761-7&gt;
Extended differential-geometric LARS for high-dimensional GLMs with general dispersion parameter,
<em>Statistics and Computing</em>, Vol 28(4), 753-774.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grcv">grcv</a></code>, <code><a href="#topic+coef.dglars">coef.dglars</a></code>, <code><a href="#topic+logLik.dglars">logLik.dglars</a></code>, <code><a href="#topic+AIC.dglars">AIC.dglars</a></code> and <code><a href="#topic+BIC.dglars">BIC.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################
# y ~ Gamma

library("dglars")
set.seed(321)
n &lt;- 100
p &lt;- 50
X &lt;- matrix(abs(rnorm(n*p)),n,p)
eta &lt;- 1 + 2 * X[, 1L]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
fit &lt;- dglars(y ~ X, Gamma("log"))
g &lt;- seq(range(fit$g)[1L], range(fit$g)[2L], length = 10)

# generalized Pearson statistic
phihat(fit, type = "pearson")
phihat(fit, type = "pearson", g = g)

# deviance estimator
phihat(fit, type = "deviance")
phihat(fit, type = "deviance", g = g)

# mle
phihat(fit, type = "mle")
phihat(fit, type = "mle", g = g)

# grcv
phihat(fit, type = "grcv")
phihat(fit, type = "grcv", g = g)
</code></pre>

<hr>
<h2 id='plot.cvdglars'>Plot from a cvdglars Object</h2><span id='topic+plot.cvdglars'></span>

<h3>Description</h3>

<p>Plots the cross-validation curve, and upper and lower standard deviation curves, 
as a function of the used <code class="reqn">\gamma</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvdglars'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cvdglars_+3A_x">x</code></td>
<td>
<p>fitted <code>cvdglars</code> object.</p>
</td></tr>
<tr><td><code id="plot.cvdglars_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot for a <code>cvdglars</code> object is produced. 
</p>
<p>The plot shows the curve of the cross-validation deviance and the upper and lower 
standard deviation curves. A vertical dashed red line is used the indetify the value
of the <code class="reqn">\gamma</code> parameter corresponding to the minimum of the cross-validation
deviance.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cvdglars">cvdglars</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
# Logistic regression model
# y ~ Binomial
set.seed(123)
n &lt;- 100
p &lt;- 100
X &lt;- matrix(rnorm(n*p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[,1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit_cv &lt;- cvdglars.fit(X, y, family = binomial)
plot(fit_cv)
</code></pre>

<hr>
<h2 id='plot.dglars'>Plot from a dglars Object</h2><span id='topic+plot.dglars'></span>

<h3>Description</h3>

<p>Produces plots to study the sequence of models identified by dgLARS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
plot(x, type = c("both", "AIC", "BIC"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dglars_+3A_x">x</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="plot.dglars_+3A_type">type</code></td>
<td>
<p> a description of the measure of goodness-of-fit used to compare
the sequence of models fitted by <code>dglars</code> or <code>dglars.fit</code>. See
below for a more details.</p>
</td></tr>
<tr><td><code id="plot.dglars_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>AIC.dglars</code> or 
<code>BIC.dglars</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.dglars</code> method produces different plots to study the sequence of 
models fitted by dgLARS method. 
</p>
<p>First plot gives information about the goodness-of-fit of the sequence of models 
fitted by dgLARS method. The user can plot the sequence of AIC (<code>type = "AIC"</code>)
or BIC values (<code>type = "BIC"</code>). By default, AIC and BIC values are shown on the 
same plot (<code>type = "both"</code>). More general measures of goodness-of-fit can be 
specified by using the argument &ldquo;...&rdquo; to pass futher arguments to function 
<code><a href="#topic+AIC.dglars">AIC.dglars</a></code> (see the examples below). The value of the tuning parameter 
corresponding to the minimum of the used measure of goodness-of-fit is indentified by
a vertical dashed red line, while the <code class="reqn">\gamma</code> values at which corresponds a 
change in the active set are labeled by vertical dashed gray lines. Second plot shows 
the coefficient profile plot; if the predictor-corrector algorithm is used to fit the
model, the third plot shows the Rao's score test statistics as function of <code class="reqn">\gamma</code>.
</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro and Hassan Pazira<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dglars">dglars</a></code>, <code><a href="#topic+summary.dglars">summary.dglars</a></code> and <code><a href="#topic+AIC.dglars">AIC.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
# Logistic regression model
set.seed(123)
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n * p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[, 1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars.fit(X, y, family = binomial)
plot(fit) 
plot(fit, type = "AIC")
plot(fit, type = "BIC")
plot(fit, type = "AIC", k = 5)
plot(fit, type = "AIC", complexity = "gdf")
</code></pre>

<hr>
<h2 id='predict.dglars'>Predict Method for dgLARS Fits.</h2><span id='topic+predict'></span><span id='topic+predict.dglars'></span>

<h3>Description</h3>

<p><code>predict.dglars</code> is used to obtain general predictions from a <code>dglars</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
predict(object, xnew, ynew, g = NULL, 
type = c("coefficients", "nnonzero", "predictors", "eta", 
"mu", "probability", "class", "deviance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dglars_+3A_object">object</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="predict.dglars_+3A_xnew">xnew</code></td>
<td>
<p>matrix of new values of the predictors at which predictions are to be made. This argument is not used for <code>type</code> &ldquo;<code>coefficients</code>&rdquo;, &ldquo;<code>nnonzero</code>&rdquo; and &ldquo;<code>predictors</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="predict.dglars_+3A_ynew">ynew</code></td>
<td>
<p>vector of new values of the responce variable. This argument is used only when <code>type</code> ie equal to &ldquo;<code>deviance</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="predict.dglars_+3A_g">g</code></td>
<td>
<p>value(s) of the tuning parameter <code class="reqn">\gamma</code> at which the predictions are required. By default, the predictions are made using the sequence of <code class="reqn">\gamma</code> values storaged in <code>dglars</code>.</p>
</td></tr>
<tr><td><code id="predict.dglars_+3A_type">type</code></td>
<td>
<p>type of prediction required; see below for more details.</p>
</td></tr>
<tr><td><code id="predict.dglars_+3A_...">...</code></td>
<td>
<p>additional argument used to ensure the compatibility with the generic method function &ldquo;<code><a href="#topic+predict">predict</a></code>&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned by <code>predict.dglars</code> depends on <code>type</code> argument:
</p>
<table>
<tr><td><code>coefficients:</code></td>
<td>
<p>a named list with components &ldquo;<code>beta</code>&rdquo;, i.e., the matrix corresponding to the dgLARS solution curve, and &ldquo;<code>phi</code>&rdquo;, i.e., the sequence of Pearson estimates of the dispersion parameter;</p>
</td></tr>
<tr><td><code>nnonzero:</code></td>
<td>
<p>the number of nonzero estimates;</p>
</td></tr>
<tr><td><code>predictors:</code></td>
<td>
<p>a named list; each component is a vector containing the indices of the variables that are in the active set;</p>
</td></tr>
<tr><td><code>eta:</code></td>
<td>
<p>a matrix with the linear preditors. If <code>xnew</code> is not specified then the linear predictors are computed using <code>object$X</code>;</p>
</td></tr>
<tr><td><code>mu:</code></td>
<td>
<p>a matrix with the fitted expeted values, obtained by transforming the linear predictor by the inverse of the link function. For models with &lsquo;binomial&rsquo; family, canonical link function (&lsquo;<code>logit</code>&rsquo;) and response a vector with elements 0 (failure) or 1 (success), <code>type = "mu"</code> and <code>type = "probability"</code> give the same result. If <code>xnew</code> is not spefified then these values are computed using <code>object$X</code>;</p>
</td></tr>
<tr><td><code>probability:</code></td>
<td>
<p>available only for &lsquo;<code>binomial</code>&rsquo; family. In this case <code>predict.dglars</code> returns a matrix with the fitted probabilities; furthermore, if the model is specified by using the canonical link function (&lsquo;<code>logit</code>&rsquo;) and response a vector with entries 0/1, <code>type = "mu"</code> and <code>type = "probability"</code> give the same result. If <code>xnew</code> is not specified then these values are computed using <code>object$X</code>;</p>
</td></tr>
<tr><td><code>class:</code></td>
<td>
<p>available only for &lsquo;<code>binomial</code>&rsquo; family. In this case <code>predict.dglars</code> returns a matrix with the fitted class. If <code>xnew</code> is not specified then these values are computed using <code>object$X</code> otherwise <code>xnew</code> is used to compute the fitted probabilities;</p>
</td></tr>
<tr><td><code>deviance:</code></td>
<td>
<p>a vector with the scaled residual deviances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dglars">dglars</a></code> and <code><a href="#topic+coef.dglars">coef.dglars</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################
# Logistic regression model
set.seed(123)
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n * p), n, p)
Xnew &lt;- matrix(rnorm(n * p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[, 1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars.fit(X, y, binomial)
coef(fit)
predict(fit, type = "coefficients")
g &lt;- seq(3, 1, by = -0.1)
coef(fit, g = g)
predict(fit, type = "coefficients", g = g)
predict(fit, type = "nnonzero")
predict(fit, type = "nnonzero", g = g)
predict(fit, type = "predictors")
predict(fit, type = "predictors", g = g)
predict(fit, type = "eta", g = g)
predict(fit, type = "eta", g = g, xnew = Xnew)
predict(fit, type = "mu", g = g)
predict(fit, type = "mu", g = g, xnew = Xnew)
predict(fit, type = "probability", g = g)
predict(fit, type = "probability", g = g, xnew = Xnew)
predict(fit, type = "class", g = g)
predict(fit, type = "class", g = g, xnew = Xnew)
</code></pre>

<hr>
<h2 id='print.cvdglars'>Print a cvdglars Object</h2><span id='topic+print.cvdglars'></span>

<h3>Description</h3>

<p>Print information about the dgLARS models selected by <code class="reqn">k</code>-fold cross-validation deviance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvdglars'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cvdglars_+3A_x">x</code></td>
<td>
<p>fitted <code>dglars</code> object</p>
</td></tr>
<tr><td><code id="print.cvdglars_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout</p>
</td></tr>
<tr><td><code id="print.cvdglars_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the object <code>x</code> is printed, followed by 
the estimate of the coefficients of the variables included in the 
active set. Such estimates are obtained using the whole data set 
while the optimal value of the tuning parameter is estimated by 
<code class="reqn">k</code>-fold cross-validation deviance. The last part of the print 
gives information about the <code class="reqn">k</code>-fold cross-validation deviance, 
the algorithm and the method used to compute the solution curve.
</p>


<h3>Value</h3>

<p>The vector of the estimates is silently returned.</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cvdglars">cvdglars</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################
# Logistic regression model

set.seed(123)

n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n*p) ,n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[,1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- cvdglars.fit(X, y, family = "binomial")
fit
</code></pre>

<hr>
<h2 id='print.dglars'>
Printing a dgLARS Object
</h2><span id='topic+print.dglars'></span>

<h3>Description</h3>

<p>Print information about the sequence of models estimated by dgLARS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dglars_+3A_x">x</code></td>
<td>
<p>fitted <code>dglars</code> object</p>
</td></tr>
<tr><td><code id="print.dglars_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout</p>
</td></tr>
<tr><td><code id="print.dglars_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the object <code>x</code> is printed, followed by a 
five-column <code>data.frame</code> with columns &ldquo;<code>Sequence</code>&rdquo;, 
&ldquo;<code>g</code>&rdquo;, &ldquo;<code>Dev</code>&rdquo;, &ldquo;<code>%Dev</code>&rdquo; and 
&ldquo;<code>n. non zero</code>&rdquo;. The column named &ldquo;<code>Sequence</code>&rdquo; 
gives information on how is changed the active set along the path. The 
column &ldquo;<code>g</code>&rdquo; shows the sequence of <code class="reqn">\gamma</code> 
values used to compute the solution curve, while the columns &ldquo;<code>Dev</code>&rdquo; 
and &ldquo;<code>%Dev</code>&rdquo; show the corresponding deviance and the fraction 
of explained deviance, respectively. Finally the &ldquo;<code>n. non zero</code>&rdquo;
column shows the number of nonzero coefficients. The last part gives information 
about the algorithm and the method used to compute the solution curve. 
The code about the convergence of the used algorithm is also showed.
</p>


<h3>Value</h3>

<p>The <code>data.frame</code> above is silently returned.</p>


<h3>Author(s)</h3>

<p>Luigi Augugliaro<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dglars">dglars</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################
# y ~ Binomial
set.seed(123)
n &lt;- 100
p &lt;- 100
X &lt;- matrix(rnorm(n * p), n, p)
eta &lt;- 1 + 2 * X[,1]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars(y ~ X, family = binomial)
fit

# adaptive dglars method
b_wght &lt;- coef(fit)$beta[, 20]
fit &lt;- dglars(y ~ X, family = binomial, b_wght = b_wght) 
fit 

# the first three coefficients are not penalized
fit &lt;- dglars(y ~ X, family = binomial, unpenalized = 1:3) 
fit 

# 'probit' link function
fit &lt;- dglars(y ~ X, family = binomial("probit"))
fit
</code></pre>

<hr>
<h2 id='summary.dglars'>Summaryzing dgLARS Fits</h2><span id='topic+summary'></span><span id='topic+summary.dglars'></span>

<h3>Description</h3>

<p>Summary method for an object with class 'dglars'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dglars'
summary(object, type = c("AIC", "BIC"), 
digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dglars_+3A_object">object</code></td>
<td>
<p>fitted <code>dglars</code> object.</p>
</td></tr>
<tr><td><code id="summary.dglars_+3A_type">type</code></td>
<td>
<p>a description of the used measure of goodness-of-fit, i.e., the Akaike Information Criterion (<code>type = "AIC"</code>) or the Bayesian Information Criterion (<code>type = "BIC"</code>). See below for the description of how to define more general measures of goodness-of-fit.</p>
</td></tr>
<tr><td><code id="summary.dglars_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout.</p>
</td></tr>
<tr><td><code id="summary.dglars_+3A_...">...</code></td>
<td>
<p>additional arguments passed to &ldquo;<code>AIC.dglars</code>&rdquo; or &ldquo;<code>BIC.dglars</code>&rdquo;. See below for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.dglars</code> gives information about the sequence of models estimtaed by dgLARS method.
</p>
<p>To select the best fitted model, summary method uses a measure of goodness-of-fit (GoF) defined as follows: </p>
<p style="text-align: center;"><code class="reqn">-2 \mbox{log-likelihood} + k \mbox{comp},</code>
</p>
<p> where &ldquo;comp&rdquo; represents the term used to measure the complexity of the fitted models, and <code class="reqn">k</code> is the 'weight' of the complexity in the previous formula. This quantity is computed using the functions &ldquo;<code>AIC.dglars</code>&rdquo; or &ldquo;<code>BIC.dglars</code>&rdquo;.
</p>
<p>By default, <code>summary.dglars</code> function computes the AIC criterion, but the user can use &ldquo;<code>dots</code>&rdquo; to pass to the function <code>AIC.dglars</code> the additional arguments needed to compute a more general measure of goodness-of-fit, i.e, &ldquo;<code>g</code>&rdquo;, &ldquo;<code>phi</code>&rdquo;, &ldquo;<code>k</code>&rdquo; and &ldquo;<code>complexity</code>&rdquo; (see &ldquo;<code><a href="#topic+AIC.dglars">AIC.dglars</a></code>&rdquo; for the description of these arguments). Below we give some examples on how to use these additional arguments.
</p>
<p>The output of the summary method is divided in two sections. 
</p>
<p>The first section shows the call that produced <code>object</code> followed by a <code>data.frame</code>. The column named &ldquo;<code>Sequence</code>&rdquo; gives information on how is changed the active set along the path. The column &ldquo;<code>g</code>&rdquo; shows the sequence of the <code class="reqn">\gamma</code>-values used to compute the solution curve, while the column &ldquo;<code>%Dev</code>&rdquo; shows the the fraction of explained deviance. The remaining columns show the complexity measure, the used measure of goodness-of-fit and the corresponding ranking of the fitted models.
</p>
<p>The second section shows the details of the selected model, i.e. family and link function used to specify the generalized linear model, the penalized estimate of the coefficient vector, the value of the tuning parameter, the null and residual deviance, and finaly the value of the used measure of goodness-of-fit. Information about the method and the algorithm used to compute the solution curve is also provided.
</p>


<h3>Value</h3>

<p><code>summary.dglars</code> function silently returns a named list with components:
</p>
<table>
<tr><td><code>table</code></td>
<td>
<p>a <code>data.frame</code> with the information about the sequence 
of model fitted by <code>dglars</code> function;</p>
</td></tr>
<tr><td><code>formula.gof</code></td>
<td>
<p>if the model is specified by the formula in <code>dglars</code>, 
then the formula of the selected model is reported;</p>
</td></tr>
<tr><td><code>b.gof</code></td>
<td>
<p>the estimates of the coefficients of the selected model;</p>
</td></tr>
<tr><td><code>phi.gof</code></td>
<td>
<p>the estimate of the dispersion parameter of the selected model;</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>the null residual deviance;</p>
</td></tr>
<tr><td><code>resdev.gof</code></td>
<td>
<p>the residual deviance of the selected model;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>a description of the measure of goodness-of-fit used to select the
model;</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the &lsquo;weight&rsquo; used to compute the measure of goodness-of-fit;</p>
</td></tr>
<tr><td><code>complexity</code></td>
<td>
<p>a description of the method used to measure the complexity
of the fitted models;</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a description of the method used the estimate the dispersion
parameter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luigi Augugliaro and Hassan Pazira<br /> 
Maintainer: Luigi Augugliaro <a href="mailto:luigi.augugliaro@unipa.it">luigi.augugliaro@unipa.it</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dglars">dglars</a></code>, <code><a href="#topic+AIC.dglars">AIC.dglars</a></code>, <code><a href="#topic+BIC.dglars">BIC.dglars</a></code> and <code><a href="#topic+gdf">gdf</a></code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################
# Logistic regression model
set.seed(123)
n &lt;- 100
p &lt;- 10
X &lt;- matrix(rnorm(n*p), n, p)
b &lt;- 1:2
eta &lt;- b[1] + X[, 1] * b[2]
mu &lt;- binomial()$linkinv(eta)
y &lt;- rbinom(n, 1, mu)
fit &lt;- dglars(y ~ X, family = binomial)

summary(fit, type = "AIC")
summary(fit, type = "AIC", k = 0.1)
summary(fit, type = "AIC", complexity = "gdf")
summary(fit, type = "BIC", complexity = "df")
summary(fit, type = "BIC", complexity = "gdf")

############################
# y ~ Gamma
n &lt;- 100
p &lt;- 10
X &lt;- matrix(abs(rnorm(n * p)), n, p)
eta &lt;- 1 + 2 * X[, 1]
mu &lt;- drop(Gamma()$linkinv(eta))
shape &lt;- 0.5
phi &lt;- 1 / shape
y &lt;- rgamma(n, scale = mu / shape, shape = shape)
fit &lt;- dglars(y ~ X, Gamma("log"))

summary(fit, phi = "pearson")
summary(fit, phi = "deviance")
summary(fit, phi = "mle")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
