<!DOCTYPE html><html lang="en"><head><title>Help for package dots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#boston_water'><p>Boston Water</p></a></li>
<li><a href='#clip_water'><p>Remove Water</p></a></li>
<li><a href='#dots'><p>Make dot density plots</p></a></li>
<li><a href='#dots_points'><p>Make dot density points</p></a></li>
<li><a href='#engine_sf_hexagonal'><p>Generate Hexagonal Points with <code>sf</code></p></a></li>
<li><a href='#engine_sf_random'><p>Generate Random Points with <code>sf</code></p></a></li>
<li><a href='#engine_sf_regular'><p>Generate Regular Points with <code>sf</code></p></a></li>
<li><a href='#engine_sp_clustered'><p>Generate Clustered Points with <code>sp</code></p></a></li>
<li><a href='#engine_sp_hexagonal'><p>Generate Hexagonal Points with <code>sp</code></p></a></li>
<li><a href='#engine_sp_nonaligned'><p>Generate Nonaligned Points with <code>sp</code></p></a></li>
<li><a href='#engine_sp_random'><p>Generate Random Points with <code>sp</code></p></a></li>
<li><a href='#engine_sp_regular'><p>Generate Regular Points with <code>sp</code></p></a></li>
<li><a href='#engine_sp_stratified'><p>Generate Stratified Points with <code>sp</code></p></a></li>
<li><a href='#engine_terra'><p>Generate Points with <code>terra</code></p></a></li>
<li><a href='#filter_pts'><p>Filter Points to a Region</p></a></li>
<li><a href='#suffolk'><p>Suffolk County, MA Voting Districts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Dot Density Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate point data for representing people within spatial data. This
  collects a suite of tools for creating simple dot density maps. Several functions 
  from different spatial packages are standardized to take the same arguments so
  that they can be easily substituted for each other.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, magrittr, rlang, rmapshaper, sf, terra, purrr, dplyr,
sp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/christopherkenny/dots">https://github.com/christopherkenny/dots</a>,
<a href="http://christophertkenny.com/dots/">http://christophertkenny.com/dots/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/christopherkenny/dots/issues">https://github.com/christopherkenny/dots/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), wacolors</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-11 16:33:36 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher T. Kenny
    <a href="https://orcid.org/0000-0002-9386-6860"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher T. Kenny &lt;christopherkenny@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-15 08:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='boston_water'>Boston Water</h2><span id='topic+boston_water'></span>

<h3>Description</h3>

<p>This data contains the largest named water within Suffolk County MA, with geographies simplified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("boston_water")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 10 observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('boston_water')
</code></pre>

<hr>
<h2 id='clip_water'>Remove Water</h2><span id='topic+clip_water'></span>

<h3>Description</h3>

<p>Remove Water
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_water(shp, water, filter_islands = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clip_water_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="clip_water_+3A_water">water</code></td>
<td>
<p>water shapes to remove with <code>sf</code> geometry</p>
</td></tr>
<tr><td><code id="clip_water_+3A_filter_islands">filter_islands</code></td>
<td>
<p>logical. Should additional filtering be done to remove small areas?</p>
</td></tr>
<tr><td><code id="clip_water_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>rmapshaper::ms_filter_islands()</code>.
Only used if <code>filter_islands = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# time to run varies greatly, depending on machine
data(suffolk)
data(boston_water)
clip_water(suffolk, boston_water[10, ])

</code></pre>

<hr>
<h2 id='dots'>Make dot density plots</h2><span id='topic+dots'></span>

<h3>Description</h3>

<p>Make dot density plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots(
  shp,
  cols,
  engine = engine_terra,
  divisor = 250,
  min_point = 0.1 * divisor
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dots_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="dots_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; columns to produce dots for.</p>
</td></tr>
<tr><td><code id="dots_+3A_engine">engine</code></td>
<td>
<p>backend to use. Default is <code>engine_terra</code>.</p>
</td></tr>
<tr><td><code id="dots_+3A_divisor">divisor</code></td>
<td>
<p>Number of people per dot. Default is 250.</p>
</td></tr>
<tr><td><code id="dots_+3A_min_point">min_point</code></td>
<td>
<p>Minimum number of people to generate one dot. Defaults to 10% of the divisor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('suffolk')
# subset to first 20 rows for speed on CRAN
dots(suffolk[1:20, ], c(vap_black), divisor = 2000)
</code></pre>

<hr>
<h2 id='dots_points'>Make dot density points</h2><span id='topic+dots_points'></span>

<h3>Description</h3>

<p>Make dot density points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots_points(
  shp,
  cols,
  engine = engine_terra,
  divisor = 250,
  min_point = 0.1 * divisor
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dots_points_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="dots_points_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; columns to produce dots for.</p>
</td></tr>
<tr><td><code id="dots_points_+3A_engine">engine</code></td>
<td>
<p>backend to use. Default is <code>engine_terra</code>.</p>
</td></tr>
<tr><td><code id="dots_points_+3A_divisor">divisor</code></td>
<td>
<p>Number of people per dot. Default is 250.</p>
</td></tr>
<tr><td><code id="dots_points_+3A_min_point">min_point</code></td>
<td>
<p>Minimum number of people to generate one dot. Defaults to 10% of the divisor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('suffolk')
# subset to first 20 rows for speed on CRAN
dots_points(suffolk[1:20, ], c(vap_black))
</code></pre>

<hr>
<h2 id='engine_sf_hexagonal'>Generate Hexagonal Points with <code>sf</code></h2><span id='topic+engine_sf_hexagonal'></span>

<h3>Description</h3>

<p>Uses <code>sf::st_sample()</code> to produce points and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sf_hexagonal(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sf_hexagonal_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sf_hexagonal_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sf_hexagonal(suffolk[16:20,], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sf_random'>Generate Random Points with <code>sf</code></h2><span id='topic+engine_sf_random'></span>

<h3>Description</h3>

<p>Uses <code>sf::st_sample()</code> to produce points and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sf_random(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sf_random_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sf_random_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sf_random(suffolk[16:20,], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sf_regular'>Generate Regular Points with <code>sf</code></h2><span id='topic+engine_sf_regular'></span>

<h3>Description</h3>

<p>Uses <code>sf::st_sample()</code> to produce points and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sf_regular(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sf_regular_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sf_regular_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sf_regular(suffolk[16:20,], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sp_clustered'>Generate Clustered Points with <code>sp</code></h2><span id='topic+engine_sp_clustered'></span>

<h3>Description</h3>

<p>Uses <code>sp::spsample()</code> with method &quot;clustered&quot; to produce points, converts back to <code>sf</code>,
and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sp_clustered(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sp_clustered_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sp_clustered_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sp_clustered(suffolk[16:20, ], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sp_hexagonal'>Generate Hexagonal Points with <code>sp</code></h2><span id='topic+engine_sp_hexagonal'></span>

<h3>Description</h3>

<p>Uses <code>sp::spsample()</code> with method &quot;hexagonal&quot; to produce points, converts back to <code>sf</code>,
and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sp_hexagonal(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sp_hexagonal_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sp_hexagonal_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sp_hexagonal(suffolk[16:20, ], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sp_nonaligned'>Generate Nonaligned Points with <code>sp</code></h2><span id='topic+engine_sp_nonaligned'></span>

<h3>Description</h3>

<p>Uses <code>sp::spsample()</code> with method &quot;nonaligned&quot; to produce points, converts back to <code>sf</code>,
and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sp_nonaligned(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sp_nonaligned_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sp_nonaligned_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sp_nonaligned(suffolk[16:20, ], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sp_random'>Generate Random Points with <code>sp</code></h2><span id='topic+engine_sp_random'></span>

<h3>Description</h3>

<p>Uses <code>sp::spsample()</code> with method &quot;random&quot; to produce points, converts back to <code>sf</code>,
and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sp_random(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sp_random_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sp_random_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sp_random(suffolk[16:20,], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sp_regular'>Generate Regular Points with <code>sp</code></h2><span id='topic+engine_sp_regular'></span>

<h3>Description</h3>

<p>Uses <code>sp::spsample()</code> with method &quot;regular&quot; to produce points, converts back to <code>sf</code>,
and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sp_regular(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sp_regular_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sp_regular_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sp_regular(suffolk[16:20,], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_sp_stratified'>Generate Stratified Points with <code>sp</code></h2><span id='topic+engine_sp_stratified'></span>

<h3>Description</h3>

<p>Uses <code>sp::spsample()</code> with method &quot;regular&quot; to produce points, converts back to <code>sf</code>,
and spatial joins with input <code>shp</code>.
Each engine function takes the same arguments and produces comparable outputs.
Final number of points may be approximate for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_sp_stratified(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_sp_stratified_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_sp_stratified_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_sp_stratified(suffolk[16:20, ], 'pop_nhpi')
</code></pre>

<hr>
<h2 id='engine_terra'>Generate Points with <code>terra</code></h2><span id='topic+engine_terra'></span>

<h3>Description</h3>

<p>Uses <code>terra::dots()</code> to produce points and transforms back to <code>sf</code>.
Each engine function takes the same arguments and produces comparable outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_terra(shp, col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engine_terra_+3A_shp">shp</code></td>
<td>
<p>input shp with <code>sf</code> geometry.</p>
</td></tr>
<tr><td><code id="engine_terra_+3A_col">col</code></td>
<td>
<p>character column name to produce points with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data('suffolk')
engine_terra(suffolk, 'pop_nhpi')
</code></pre>

<hr>
<h2 id='filter_pts'>Filter Points to a Region</h2><span id='topic+filter_pts'></span>

<h3>Description</h3>

<p>Filter Points to a Region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_pts(pts, shp, cond = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_pts_+3A_pts">pts</code></td>
<td>
<p>points with <code>sf</code> geometry to filter</p>
</td></tr>
<tr><td><code id="filter_pts_+3A_shp">shp</code></td>
<td>
<p>shp to filter to</p>
</td></tr>
<tr><td><code id="filter_pts_+3A_cond">cond</code></td>
<td>
<p>geometry subset to reduce shp to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with <code>sf</code> geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(suffolk)
pts &lt;- dots_points(suffolk, pop, divisor = 1000)
filter_pts(pts, suffolk, pop &lt; 1000)
</code></pre>

<hr>
<h2 id='suffolk'>Suffolk County, MA Voting Districts</h2><span id='topic+suffolk'></span>

<h3>Description</h3>

<p>This data contains the voting districts for Suffolk County MA, with geographies simplified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("suffolk")
</code></pre>


<h3>Format</h3>

<p>An sf dataframe with 295 observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('suffolk')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
