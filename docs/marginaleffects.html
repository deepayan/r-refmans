<!DOCTYPE html><html><head><title>Help for package marginaleffects</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {marginaleffects}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comparisons'><p>Comparisons Between Predictions Made With Different Regressor Values</p></a></li>
<li><a href='#complete_levels'><p>Create a data.frame with all factor or character levels</p></a></li>
<li><a href='#datagrid'><p>Data grids</p></a></li>
<li><a href='#datagridcf'><p>Deprecated function</p></a></li>
<li><a href='#deltamethod'><p>Deprecated function</p></a></li>
<li><a href='#expect_margins'><p><code>tinytest</code> helper</p></a></li>
<li><a href='#expect_predictions'><p><code>tinytest</code> helper</p></a></li>
<li><a href='#expect_slopes'><p><code>tinytest</code> helper</p></a></li>
<li><a href='#get_averages'><p>Average Estimates (aka &quot;Margins&quot;)</p></a></li>
<li><a href='#get_coef'><p>Get a named vector of coefficients from a model object (internal function)</p></a></li>
<li><a href='#get_group_names'><p>Get levels of the outcome variable in grouped or multivariate models</p></a></li>
<li><a href='#get_model_matrix'><p>Get a named model matrix</p></a></li>
<li><a href='#get_predict'><p>Get predicted values from a model object (internal function)</p></a></li>
<li><a href='#get_varcov_args'><p>Take a <code>summary()</code> style <code>vcov</code> argument and convert it to</p>
<code>insight::get_varcov()</code></a></li>
<li><a href='#get_vcov'><p>Get a named variance-covariance matrix from a model object (internal function)</p></a></li>
<li><a href='#hypotheses'><p>(Non-)Linear Tests for Null Hypotheses, Joint Hypotheses, Equivalence, Non Superiority, and Non Inferiority</p></a></li>
<li><a href='#inferences'><p>(EXPERIMENTAL) Bootstrap, Conformal, and Simulation-Based Inference</p></a></li>
<li><a href='#marginal_means'><p>Deprecated function</p></a></li>
<li><a href='#marginaleffects'><p>Deprecated function</p></a></li>
<li><a href='#marginalmeans'><p>Deprecated function</p></a></li>
<li><a href='#meffects'><p>Deprecated function</p></a></li>
<li><a href='#plot_comparisons'><p>Plot Conditional or Marginal Comparisons</p></a></li>
<li><a href='#plot_predictions'><p>Plot Conditional or Marginal Predictions</p></a></li>
<li><a href='#plot_slopes'><p>Plot Conditional or Marginal Slopes</p></a></li>
<li><a href='#posterior_draws'><p>Extract Posterior Draws or Bootstrap Resamples from <code>marginaleffects</code> Objects</p></a></li>
<li><a href='#posteriordraws'><p><code>posteriordraws()</code> is an alias to <code>posterior_draws()</code></p></a></li>
<li><a href='#predictions'><p>Predictions</p></a></li>
<li><a href='#print.marginaleffects'><p>Print <code>marginaleffects</code> objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sanitize_model_specific.glimML'><p>Method to raise model-specific warnings and errors</p></a></li>
<li><a href='#set_coef'><p>Internal function to set coefficients</p></a></li>
<li><a href='#slopes'><p>Slopes (aka Partial derivatives, Marginal Effects, or Trends)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Predictions, Comparisons, Slopes, Marginal Means, and Hypothesis
Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.18.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute and plot predictions, slopes, marginal means, and comparisons (contrasts, risk ratios, odds, etc.) for over 100 classes of statistical and machine learning models in R. Conduct linear and non-linear hypothesis tests, or equivalence tests. Calculate uncertainty estimates using the delta method, bootstrapping, or simulation-based inference.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marginaleffects.com/">https://marginaleffects.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vincentarelbundock/marginaleffects/issues">https://github.com/vincentarelbundock/marginaleffects/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, data.table, generics, insight (&ge; 0.19.7), methods,
rlang, Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, Amelia, afex, aod, bench, betareg, BH, bife, biglm,
blme, boot, brglm2, brms, brmsmargins, broom, car, carData,
causaldata, collapse, conflicted, countrycode, covr, crch,
DALEXtra, DCchoice, dbarts, distributional, dplyr, emmeans,
equivalence, estimatr, fixest, fmeffects, fontquiver, future,
fwb, gam, gamlss, gamlss.dist, geepack, ggdag, ggdist,
ggokabeito, ggplot2, ggrepel, glmmTMB, glmx, haven, here,
itsadug, ivreg, kableExtra, knitr, lme4, lmerTest, logistf,
magrittr, margins, MatchIt, MASS, mclogit, MCMCglmm,
missRanger, mgcv, mhurdle, mice, miceadds, mlogit, mlr3verse,
modelbased, modelsummary, nlme, nnet, numDeriv, optmatch,
ordinal, parameters, parsnip, partykit, patchwork, pkgdown,
phylolm, plm, polspline, poorman, posterior, prediction, pscl,
purrr, quantreg, Rchoice, rcmdcheck, remotes, rmarkdown, rms,
robust, robustbase, robustlmm, rsample, rstanarm, rstantools,
rsvg, sampleSelection, sandwich, scam, spelling, speedglm,
survey, survival, svglite, systemfonts, tibble, tidymodels,
tidyr, tidyverse, tinysnapshot, tinytest, titanic, truncreg,
tsModel, withr, workflows, yaml, xgboost, testthat (&ge; 3.0.0),
altdoc</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'backtransform.R' 'bootstrap_boot.R'
'bootstrap_fwb.R' 'bootstrap_rsample.R' 'broom.R' 'by.R' 'ci.R'
'comparisons.R' 'complete_levels.R' 'conformal.R' 'datagrid.R'
'deprecated.R' 'equivalence.R' 'get_averages.R' 'get_coef.R'
'get_contrast_data.R' 'get_contrast_data_character.R'
'get_contrast_data_factor.R' 'get_contrast_data_logical.R'
'get_contrast_data_numeric.R' 'get_contrasts.R'
'get_group_names.R' 'get_hypothesis.R' 'get_jacobian.R'
'get_model_matrix.R' 'get_model_matrix_attribute.R'
'get_modeldata.R' 'get_predict.R' 'get_se_delta.R'
'get_term_labels.R' 'get_vcov.R' 'github_issue.R' 'hush.R'
'hypotheses.R' 'hypotheses_joint.R' 'imputation.R'
'inferences.R' 'mean_or_mode.R' 'methods.R' 'set_coef.R'
'methods_MASS.R' 'methods_MCMCglmm.R' 'methods_Rchoice.R'
'methods_afex.R' 'methods_aod.R' 'methods_betareg.R'
'methods_bife.R' 'methods_biglm.R' 'methods_nnet.R'
'methods_brglm2.R' 'sanity_model.R' 'methods_brms.R'
'methods_crch.R' 'methods_dataframe.R' 'methods_dbarts.R'
'methods_fixest.R' 'methods_gamlss.R' 'methods_glmmTMB.R'
'methods_glmx.R' 'methods_inferences_simulation.R'
'methods_lme4.R' 'methods_mclogit.R' 'methods_mgcv.R'
'methods_mhurdle.R' 'methods_mlm.R' 'methods_mlogit.R'
'methods_mlr3.R' 'methods_nlme.R' 'methods_ordinal.R'
'methods_plm.R' 'methods_pscl.R' 'methods_quantreg.R'
'methods_rms.R' 'methods_robustlmm.R' 'methods_rstanarm.R'
'methods_sampleSelection.R' 'methods_scam.R' 'methods_stats.R'
'methods_survey.R' 'methods_survival.R' 'methods_tidymodels.R'
'methods_tobit1.R' 'modelarchive.R' 'myTryCatch.R' 'package.R'
'plot.R' 'plot_build.R' 'plot_comparisons.R'
'plot_predictions.R' 'plot_slopes.R' 'posterior_draws.R'
'predictions.R' 'print.R' 'recall.R' 'sanitize_comparison.R'
'sanitize_condition.R' 'sanitize_conf_level.R'
'sanitize_hypothesis.R' 'sanitize_interaction.R'
'sanitize_newdata.R' 'sanitize_numderiv.R' 'sanitize_type.R'
'sanitize_variables.R' 'sanitize_vcov.R' 'sanity.R'
'sanity_by.R' 'sanity_dots.R' 'settings.R' 'slopes.R' 'sort.R'
'tinytest.R' 'type_dictionary.R' 'unpack_matrix_cols.R'
'utils.R'</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 02:13:40 UTC; vincent</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Arel-Bundock
    <a href="https://orcid.org/0000-0003-2042-7063"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Marcio Augusto Diniz
    <a href="https://orcid.org/0000-0002-2427-7843"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Etienne Bacher <a href="https://orcid.org/0000-0002-9271-5075"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincent Arel-Bundock &lt;vincent.arel-bundock@umontreal.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 12:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='comparisons'>Comparisons Between Predictions Made With Different Regressor Values</h2><span id='topic+comparisons'></span><span id='topic+avg_comparisons'></span>

<h3>Description</h3>

<p>Predict the outcome variable at different regressor values (e.g., college
graduates vs. others), and compare those predictions by computing a difference,
ratio, or some other function. <code>comparisons()</code> can return many quantities of
interest, such as contrasts, differences, risk ratios, changes in log odds, lift,
slopes, elasticities, etc.
</p>

<ul>
<li> <p><code>comparisons()</code>: unit-level (conditional) estimates.
</p>
</li>
<li> <p><code>avg_comparisons()</code>: average (marginal) estimates.
</p>
</li></ul>

<p><code>variables</code> identifies the focal regressors whose &quot;effect&quot; we are interested in. <code>comparison</code> determines how predictions with different regressor values are compared (difference, ratio, odds, etc.). The <code>newdata</code> argument and the <code>datagrid()</code> function control where statistics are evaluated in the predictor space: &quot;at observed values&quot;, &quot;at the mean&quot;, &quot;at representative values&quot;, etc.
</p>
<p>See the comparisons vignette and package website for worked examples and case studies:
</p>

<ul>
<li> <p><a href="https://marginaleffects.com/vignettes/comparisons.html">https://marginaleffects.com/vignettes/comparisons.html</a>
</p>
</li>
<li> <p><a href="https://marginaleffects.com/">https://marginaleffects.com/</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>comparisons(
  model,
  newdata = NULL,
  variables = NULL,
  comparison = "difference",
  type = NULL,
  vcov = TRUE,
  by = FALSE,
  conf_level = 0.95,
  transform = NULL,
  cross = FALSE,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  eps = NULL,
  numderiv = "fdforward",
  ...
)

avg_comparisons(
  model,
  newdata = NULL,
  variables = NULL,
  type = NULL,
  vcov = TRUE,
  by = TRUE,
  conf_level = 0.95,
  comparison = "difference",
  transform = NULL,
  cross = FALSE,
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  eps = NULL,
  numderiv = "fdforward",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparisons_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="comparisons_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the comparisons.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level contrasts for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li><p> data frame: Unit-level contrasts for each row of the <code>newdata</code> data frame.
</p>
</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Contrasts at the Mean. Contrasts when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Contrasts at the Median. Contrasts when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Contrasts at Marginal Means.
</p>
</li>
<li><p> &quot;tukey&quot;: Contrasts at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Contrasts on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li> <p><code>newdata = datagrid(mpg = fivenum)</code>: <code>mpg</code> variable held at Tukey's five numbers (using the <code>fivenum</code> function), and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <a href="#topic+datagrid">datagrid</a> documentation.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_variables">variables</code></td>
<td>
<p>Focal variables
</p>

<ul>
<li> <p><code>NULL</code>: compute comparisons for all the variables in the model object (can be slow).
</p>
</li>
<li><p> Character vector: subset of variables (usually faster).
</p>
</li>
<li><p> Named list: names identify the subset of variables of interest, and values define the type of contrast to compute. Acceptable values depend on the variable type:
</p>

<ul>
<li><p> Factor or character variables:
</p>

<ul>
<li><p> &quot;reference&quot;: Each factor level is compared to the factor reference (base) level
</p>
</li>
<li><p> &quot;all&quot;: All combinations of observed levels
</p>
</li>
<li><p> &quot;sequential&quot;: Each factor level is compared to the previous factor level
</p>
</li>
<li><p> &quot;pairwise&quot;: Each factor level is compared to all other levels
</p>
</li>
<li><p> &quot;minmax&quot;: The highest and lowest levels of a factor.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses.
</p>
</li>
<li><p> Vector of length 2 with the two values to compare.
</p>
</li>
<li><p> Data frame with the same number of rows as <code>newdata</code>, with two columns of &quot;lo&quot; and &quot;hi&quot; values to compare.
</p>
</li>
<li><p> Function that accepts a vector and returns a data frame with two columns of &quot;lo&quot; and &quot;hi&quot; values to compare. See examples below.
</p>
</li></ul>

</li>
<li><p> Logical variables:
</p>

<ul>
<li><p> NULL: contrast between TRUE and FALSE
</p>
</li>
<li><p> Data frame with the same number of rows as <code>newdata</code>, with two columns of &quot;lo&quot; and &quot;hi&quot; values to compare.
</p>
</li>
<li><p> Function that accepts a vector and returns a data frame with two columns of &quot;lo&quot; and &quot;hi&quot; values to compare. See examples below.
</p>
</li></ul>

</li>
<li><p> Numeric variables:
</p>

<ul>
<li><p> Numeric of length 1: Forward contrast for a gap of <code>x</code>, computed between the observed value and the observed value plus <code>x</code>. Users can set a global option to get a &quot;center&quot; or &quot;backward&quot; contrast instead: <code>options(marginaleffects_contrast_direction="center")</code>
</p>
</li>
<li><p> Numeric vector of length 2: Contrast between the largest and the smallest elements of the <code>x</code> vector.
</p>
</li>
<li><p> Data frame with the same number of rows as <code>newdata</code>, with two columns of &quot;lo&quot; and &quot;hi&quot; values to compare.
</p>
</li>
<li><p> Function that accepts a vector and returns a data frame with two columns of &quot;lo&quot; and &quot;hi&quot; values to compare. See examples below.
</p>
</li>
<li><p> &quot;iqr&quot;: Contrast across the interquartile range of the regressor.
</p>
</li>
<li><p> &quot;sd&quot;: Contrast across one standard deviation around the regressor mean.
</p>
</li>
<li><p> &quot;2sd&quot;: Contrast across two standard deviations around the regressor mean.
</p>
</li>
<li><p> &quot;minmax&quot;: Contrast between the maximum and the minimum values of the regressor.
</p>
</li></ul>

</li>
<li><p> Examples:
</p>

<ul>
<li> <p><code>variables = list(gear = "pairwise", hp = 10)</code>
</p>
</li>
<li> <p><code>variables = list(gear = "sequential", hp = c(100, 120))</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;variables = list(hp = \(x) data.frame(low = x - 5, high = x + 10))&#8288;</code>
</p>
</li>
<li><p> See the Examples section below for more.
</p>
</li></ul>

</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_comparison">comparison</code></td>
<td>
<p>How should pairs of predictions be compared? Difference, ratio, odds ratio, or user-defined functions.
</p>

<ul>
<li><p> string: shortcuts to common contrast functions.
</p>

<ul>
<li><p> Supported shortcuts strings: difference, differenceavg, differenceavgwts, dydx, eyex, eydx, dyex, dydxavg, eyexavg, eydxavg, dyexavg, dydxavgwts, eyexavgwts, eydxavgwts, dyexavgwts, ratio, ratioavg, ratioavgwts, lnratio, lnratioavg, lnratioavgwts, lnor, lnoravg, lnoravgwts, lift, liftavg, expdydx, expdydxavg, expdydxavgwts
</p>
</li>
<li><p> See the Comparisons section below for definitions of each transformation.
</p>
</li></ul>

</li>
<li><p> function: accept two equal-length numeric vectors of adjusted predictions (<code>hi</code> and <code>lo</code>) and returns a vector of contrasts of the same length, or a unique numeric value.
</p>

<ul>
<li><p> See the Transformations section below for examples of valid functions.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="comparisons_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="comparisons_+3A_transform">transform</code></td>
<td>
<p>string or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: &quot;exp&quot;, &quot;ln&quot;</p>
</td></tr>
<tr><td><code id="comparisons_+3A_cross">cross</code></td>
<td>

<ul>
<li> <p><code>FALSE</code>: Contrasts represent the change in adjusted predictions when one predictor changes and all other variables are held constant.
</p>
</li>
<li> <p><code>TRUE</code>: Contrasts represent the changes in adjusted predictions when all the predictors specified in the <code>variables</code> argument are manipulated simultaneously (a &quot;cross-contrast&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="comparisons_+3A_p_adjust">p_adjust</code></td>
<td>
<p>Adjust p-values for multiple comparisons: &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, or &quot;fdr&quot;. See <a href="stats.html#topic+p.adjust">stats::p.adjust</a></p>
</td></tr>
<tr><td><code id="comparisons_+3A_df">df</code></td>
<td>
<p>Degrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and <code>Inf</code>. When <code>df</code> is <code>Inf</code>, the normal distribution is used. When <code>df</code> is finite, the <code>t</code> distribution is used. See <a href="insight.html#topic+get_df">insight::get_df</a> for a convenient function to extract degrees of freedom. Ex: <code>slopes(model, df = insight::get_df(model))</code></p>
</td></tr>
<tr><td><code id="comparisons_+3A_eps">eps</code></td>
<td>
<p>NULL or numeric value which determines the step size to use when
calculating numerical derivatives: (f(x+eps)-f(x))/eps. When <code>eps</code> is
<code>NULL</code>, the step size is 0.0001 multiplied by the difference between
the maximum and minimum values of the variable with respect to which we
are taking the derivative. Changing <code>eps</code> may be necessary to avoid
numerical problems in certain models.</p>
</td></tr>
<tr><td><code id="comparisons_+3A_numderiv">numderiv</code></td>
<td>
<p>string or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.
</p>

<ul>
<li><p> &quot;fdforward&quot;: finite difference method with forward differences
</p>
</li>
<li><p> &quot;fdcenter&quot;: finite difference method with central differences (default)
</p>
</li>
<li><p> &quot;richardson&quot;: Richardson extrapolation method
</p>
</li>
<li><p> Extra arguments can be specified by passing a list to the <code>numDeriv</code> argument, with the name of the method first and named arguments following, ex: <code>numderiv=list("fdcenter", eps = 1e-5)</code>. When an unknown argument is used, <code>marginaleffects</code> prints the list of valid arguments for each method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="comparisons_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per observation (per term/group) and several columns:
</p>

<ul>
<li> <p><code>rowid</code>: row number of the <code>newdata</code> data frame
</p>
</li>
<li> <p><code>type</code>: prediction type, as defined by the <code>type</code> argument
</p>
</li>
<li> <p><code>group</code>: (optional) value of the grouped outcome (e.g., categorical outcome models)
</p>
</li>
<li> <p><code>term</code>: the variable whose marginal effect is computed
</p>
</li>
<li> <p><code>dydx</code>: slope of the outcome with respect to the term, for a given combination of predictor values
</p>
</li>
<li> <p><code>std.error</code>: standard errors computed by via the delta method.
</p>
</li>
<li> <p><code>p.value</code>: p value associated to the <code>estimate</code> column. The null is determined by the <code>hypothesis</code> argument (0 by default), and p values are computed before applying the <code>transform</code> argument.
</p>
</li>
<li> <p><code>s.value</code>: Shannon information transforms of p values. How many consecutive &quot;heads&quot; tosses would provide the same amount of evidence (or &quot;surprise&quot;) against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst's intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).
</p>
</li>
<li> <p><code>conf.low</code>: lower bound of the confidence interval (or equal-tailed interval for bayesian models)
</p>
</li>
<li> <p><code>conf.high</code>: upper bound of the confidence interval (or equal-tailed interval for bayesian models)
</p>
</li></ul>

<p>See <code>?print.marginaleffects</code> for printing options.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>avg_comparisons()</code>: Average comparisons
</p>
</li></ul>


<h3>Standard errors using the delta method</h3>

<p>Standard errors for all quantities estimated by <code>marginaleffects</code> can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to <code>1e-8</code>, or to <code>1e-4</code> times the smallest absolute model coefficient, whichever is largest.
</p>
<p><code>marginaleffects</code> can delegate numeric differentiation to the <code>numDeriv</code> package, which allows more flexibility. To do this, users can pass arguments to the <code>numDeriv::jacobian</code> function through a global option. For example:
</p>

<ul>
<li> <p><code>options(marginaleffects_numDeriv = list(method = "simple", method.args = list(eps = 1e-6)))</code>
</p>
</li>
<li> <p><code>options(marginaleffects_numDeriv = list(method = "Richardson", method.args = list(eps = 1e-5)))</code>
</p>
</li>
<li> <p><code>options(marginaleffects_numDeriv = NULL)</code>
</p>
</li></ul>

<p>See the &quot;Standard Errors and Confidence Intervals&quot; vignette on the <code>marginaleffects</code> website for more details on the computation of standard errors:
</p>
<p>https://marginaleffects.com/vignettes/uncertainty.html
</p>
<p>Note that the <code>inferences()</code> function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:
</p>
<p>https://marginaleffects.com/vignettes/bootstrap.html
</p>


<h3>Model-Specific Arguments</h3>

<p>Some model types allow model-specific arguments to modify the nature of
marginal effects, predictions, marginal means, and contrasts. Please report
other package-specific <code>predict()</code> arguments on Github so we can add them to
the table below.
</p>
<p>https://github.com/vincentarelbundock/marginaleffects/issues</p>

<table>
<tr>
 <td style="text-align: left;">
   Package </td><td style="text-align: left;"> Class </td><td style="text-align: left;"> Argument </td><td style="text-align: left;"> Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>brms</code> </td><td style="text-align: left;"> <code>brmsfit</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>re_formula</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lme4</code> </td><td style="text-align: left;"> <code>merMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>glmmTMB</code> </td><td style="text-align: left;"> <code>glmmTMB</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>zitype</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mgcv</code> </td><td style="text-align: left;"> <code>bam</code> </td><td style="text-align: left;"> <code>exclude</code> </td><td style="text-align: left;"> <a href="mgcv.html#topic+predict.bam">mgcv::predict.bam</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>robustlmm</code> </td><td style="text-align: left;"> <code>rlmerMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>comparison argument functions</h3>

<p>The following transformations can be applied by supplying one of the shortcut strings to the
<code>comparison</code> argument.
<code>hi</code> is a vector of adjusted predictions for the &quot;high&quot; side of the
contrast. <code>lo</code> is a vector of adjusted predictions for the &quot;low&quot; side of the
contrast. <code>y</code> is a vector of adjusted predictions for the original data. <code>x</code>
is the predictor in the original data. <code>eps</code> is the step size to use to
compute derivatives and elasticities.</p>

<table>
<tr>
 <td style="text-align: left;">
   Shortcut </td><td style="text-align: left;"> Function </td>
</tr>
<tr>
 <td style="text-align: left;">
   difference </td><td style="text-align: left;"> \(hi, lo) hi - lo </td>
</tr>
<tr>
 <td style="text-align: left;">
   differenceavg </td><td style="text-align: left;"> \(hi, lo) mean(hi - lo) </td>
</tr>
<tr>
 <td style="text-align: left;">
   dydx </td><td style="text-align: left;"> \(hi, lo, eps) (hi - lo)/eps </td>
</tr>
<tr>
 <td style="text-align: left;">
   eyex </td><td style="text-align: left;"> \(hi, lo, eps, y, x) (hi - lo)/eps * (x/y) </td>
</tr>
<tr>
 <td style="text-align: left;">
   eydx </td><td style="text-align: left;"> \(hi, lo, eps, y, x) ((hi - lo)/eps)/y </td>
</tr>
<tr>
 <td style="text-align: left;">
   dyex </td><td style="text-align: left;"> \(hi, lo, eps, x) ((hi - lo)/eps) * x </td>
</tr>
<tr>
 <td style="text-align: left;">
   dydxavg </td><td style="text-align: left;"> \(hi, lo, eps) mean((hi - lo)/eps) </td>
</tr>
<tr>
 <td style="text-align: left;">
   eyexavg </td><td style="text-align: left;"> \(hi, lo, eps, y, x) mean((hi - lo)/eps * (x/y)) </td>
</tr>
<tr>
 <td style="text-align: left;">
   eydxavg </td><td style="text-align: left;"> \(hi, lo, eps, y, x) mean(((hi - lo)/eps)/y) </td>
</tr>
<tr>
 <td style="text-align: left;">
   dyexavg </td><td style="text-align: left;"> \(hi, lo, eps, x) mean(((hi - lo)/eps) * x) </td>
</tr>
<tr>
 <td style="text-align: left;">
   ratio </td><td style="text-align: left;"> \(hi, lo) hi/lo </td>
</tr>
<tr>
 <td style="text-align: left;">
   ratioavg </td><td style="text-align: left;"> \(hi, lo) mean(hi)/mean(lo) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lnratio </td><td style="text-align: left;"> \(hi, lo) log(hi/lo) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lnratioavg </td><td style="text-align: left;"> \(hi, lo) log(mean(hi)/mean(lo)) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lnor </td><td style="text-align: left;"> \(hi, lo) log((hi/(1 - hi))/(lo/(1 - lo))) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lnoravg </td><td style="text-align: left;"> \(hi, lo) log((mean(hi)/(1 - mean(hi)))/(mean(lo)/(1 - mean(lo)))) </td>
</tr>
<tr>
 <td style="text-align: left;">
   lift </td><td style="text-align: left;"> \(hi, lo) (hi - lo)/lo </td>
</tr>
<tr>
 <td style="text-align: left;">
   liftavg </td><td style="text-align: left;"> \(hi, lo) (mean(hi - lo))/mean(lo) </td>
</tr>
<tr>
 <td style="text-align: left;">
   expdydx </td><td style="text-align: left;"> \(hi, lo, eps) ((exp(hi) - exp(lo))/exp(eps))/eps </td>
</tr>
<tr>
 <td style="text-align: left;">
   expdydxavg </td><td style="text-align: left;"> \(hi, lo, eps) mean(((exp(hi) - exp(lo))/exp(eps))/eps) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Bayesian posterior summaries</h3>

<p>By default, credible intervals in bayesian models are built as equal-tailed
intervals. This can be changed to a highest density interval by setting a global
option:
</p>
<p><code>options("marginaleffects_posterior_interval" = "eti")</code>
</p>
<p><code>options("marginaleffects_posterior_interval" = "hdi")</code>
</p>
<p>By default, the center of the posterior distribution in bayesian models is
identified by the median. Users can use a different summary function by setting a
global option:
</p>
<p><code>options("marginaleffects_posterior_center" = "mean")</code>
</p>
<p><code>options("marginaleffects_posterior_center" = "median")</code>
</p>
<p>When estimates are averaged using the <code>by</code> argument, the <code>tidy()</code> function, or
the <code>summary()</code> function, the posterior distribution is marginalized twice over.
First, we take the average <em>across</em> units but <em>within</em> each iteration of the
MCMC chain, according to what the user requested in <code>by</code> argument or
<code>tidy()/summary()</code> functions. Then, we identify the center of the resulting
posterior using the function supplied to the
<code>"marginaleffects_posterior_center"</code> option (the median by default).
</p>


<h3>Equivalence, Inferiority, Superiority</h3>

<p><code class="reqn">\theta</code> is an estimate, <code class="reqn">\sigma_\theta</code> its estimated standard error, and <code class="reqn">[a, b]</code> are the bounds of the interval supplied to the <code>equivalence</code> argument.
</p>
<p>Non-inferiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \leq a</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &gt; a</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - a)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Upper-tail probability
</p>
</li></ul>

<p>Non-superiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \geq b</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &lt; b</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - b)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Lower-tail probability
</p>
</li></ul>

<p>Equivalence: Two One-Sided Tests (TOST)
</p>

<ul>
<li><p> p: Maximum of the non-inferiority and non-superiority p values.
</p>
</li></ul>

<p>Thanks to Russell V. Lenth for the excellent <code>emmeans</code> package and documentation which inspired this feature.
</p>


<h3>Prediction types</h3>

<p>The <code>type</code> argument determines the scale of the predictions used to compute quantities of interest with functions from the <code>marginaleffects</code> package. Admissible values for <code>type</code> depend on the model object. When users specify an incorrect value for <code>type</code>, <code>marginaleffects</code> will raise an informative error with a list of valid <code>type</code> values for the specific model object. The first entry in the list in that error message is the default type.
</p>
<p>The <code>invlink(link)</code> is a special type defined by <code>marginaleffects</code>. It is available for some (but not all) models and functions. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with <code>type="invlink(link)"</code> will not always be equivalent to the average of estimates with <code>type="response"</code>.
</p>
<p>Some of the most common <code>type</code> values are:
</p>
<p>response, link, E, Ep, average, class, conditional, count, cum.prob, cumprob, density, detection, disp, ev, expected, expvalue, fitted, invlink(link), latent, latent_N, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob
</p>


<h3>References</h3>


<ul>
<li><p> Greenland S. 2019. &quot;Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.&quot; The American Statistician. 73(S1): 106–114.
</p>
</li>
<li><p> Cole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. &quot;Surprise!&quot; American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(marginaleffects)

# Linear model
tmp &lt;- mtcars
tmp$am &lt;- as.logical(tmp$am)
mod &lt;- lm(mpg ~ am + factor(cyl), tmp)
avg_comparisons(mod, variables = list(cyl = "reference"))
avg_comparisons(mod, variables = list(cyl = "sequential"))
avg_comparisons(mod, variables = list(cyl = "pairwise"))

# GLM with different scale types
mod &lt;- glm(am ~ factor(gear), data = mtcars)
avg_comparisons(mod, type = "response")
avg_comparisons(mod, type = "link")

# Contrasts at the mean
comparisons(mod, newdata = "mean")

# Contrasts between marginal means
comparisons(mod, newdata = "marginalmeans")

# Contrasts at user-specified values
comparisons(mod, newdata = datagrid(am = 0, gear = tmp$gear))
comparisons(mod, newdata = datagrid(am = unique, gear = max))

m &lt;- lm(mpg ~ hp + drat + factor(cyl) + factor(am), data = mtcars)
comparisons(m, variables = "hp", newdata = datagrid(FUN_factor = unique, FUN_numeric = median))

# Numeric contrasts
mod &lt;- lm(mpg ~ hp, data = mtcars)
avg_comparisons(mod, variables = list(hp = 1))
avg_comparisons(mod, variables = list(hp = 5))
avg_comparisons(mod, variables = list(hp = c(90, 100)))
avg_comparisons(mod, variables = list(hp = "iqr"))
avg_comparisons(mod, variables = list(hp = "sd"))
avg_comparisons(mod, variables = list(hp = "minmax"))

# using a function to specify a custom difference in one regressor
dat &lt;- mtcars
dat$new_hp &lt;- 49 * (dat$hp - min(dat$hp)) / (max(dat$hp) - min(dat$hp)) + 1
modlog &lt;- lm(mpg ~ log(new_hp) + factor(cyl), data = dat)
fdiff &lt;- \(x) data.frame(x, x + 10)
avg_comparisons(modlog, variables = list(new_hp = fdiff))

# Adjusted Risk Ratio: see the contrasts vignette
mod &lt;- glm(vs ~ mpg, data = mtcars, family = binomial)
avg_comparisons(mod, comparison = "lnratioavg", transform = exp)

# Adjusted Risk Ratio: Manual specification of the `comparison`
avg_comparisons(
     mod,
     comparison = function(hi, lo) log(mean(hi) / mean(lo)),
     transform = exp)
# cross contrasts
mod &lt;- lm(mpg ~ factor(cyl) * factor(gear) + hp, data = mtcars)
avg_comparisons(mod, variables = c("cyl", "gear"), cross = TRUE)

# variable-specific contrasts
avg_comparisons(mod, variables = list(gear = "sequential", hp = 10))

# hypothesis test: is the `hp` marginal effect at the mean equal to the `drat` marginal effect
mod &lt;- lm(mpg ~ wt + drat, data = mtcars)

comparisons(
    mod,
    newdata = "mean",
    hypothesis = "wt = drat")

# same hypothesis test using row indices
comparisons(
    mod,
    newdata = "mean",
    hypothesis = "b1 - b2 = 0")

# same hypothesis test using numeric vector of weights
comparisons(
    mod,
    newdata = "mean",
    hypothesis = c(1, -1))

# two custom contrasts using a matrix of weights
lc &lt;- matrix(c(
    1, -1,
    2, 3),
    ncol = 2)
comparisons(
    mod,
    newdata = "mean",
    hypothesis = lc)

# Effect of a 1 group-wise standard deviation change
# First we calculate the SD in each group of `cyl`
# Second, we use that SD as the treatment size in the `variables` argument
library(dplyr)
mod &lt;- lm(mpg ~ hp + factor(cyl), mtcars)
tmp &lt;- mtcars %&gt;%
    group_by(cyl) %&gt;%
    mutate(hp_sd = sd(hp))
avg_comparisons(mod, 
    variables = list(hp = function(x) data.frame(x, x + tmp$hp_sd)),
    by = "cyl")

# `by` argument
mod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)
comparisons(mod, by = TRUE)

mod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)
avg_comparisons(mod, variables = "hp", by = c("vs", "am"))

library(nnet)
mod &lt;- multinom(factor(gear) ~ mpg + am * vs, data = mtcars, trace = FALSE)
by &lt;- data.frame(
    group = c("3", "4", "5"),
    by = c("3,4", "3,4", "5"))
comparisons(mod, type = "probs", by = by)

</code></pre>

<hr>
<h2 id='complete_levels'>Create a data.frame with all factor or character levels</h2><span id='topic+complete_levels'></span>

<h3>Description</h3>

<p><code>model.matrix</code> breaks when <code>newdata</code> includes a factor
variable, but not all levels are present in the data. This is bad for us
because we often want to get predictions with one (or few) rows, where some
factor levels are inevitably missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_levels(x, character_levels = NULL)
</code></pre>

<hr>
<h2 id='datagrid'>Data grids</h2><span id='topic+datagrid'></span>

<h3>Description</h3>

<p>Generate a data grid of user-specified values for use in the <code>newdata</code> argument of the <code>predictions()</code>, <code>comparisons()</code>, and <code>slopes()</code> functions. This is useful to define where in the predictor space we want to evaluate the quantities of interest. Ex: the predicted outcome or slope for a 37 year old college graduate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datagrid(
  ...,
  model = NULL,
  newdata = NULL,
  by = NULL,
  grid_type = "mean_or_mode",
  FUN_character = NULL,
  FUN_factor = NULL,
  FUN_logical = NULL,
  FUN_numeric = NULL,
  FUN_integer = NULL,
  FUN_binary = NULL,
  FUN_other = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datagrid_+3A_...">...</code></td>
<td>
<p>named arguments with vectors of values or functions for user-specified variables.
</p>

<ul>
<li><p> Functions are applied to the variable in the <code>model</code> dataset or <code>newdata</code>, and must return a vector of the appropriate type.
</p>
</li>
<li><p> Character vectors are automatically transformed to factors if necessary.
+The output will include all combinations of these variables (see Examples below.)
</p>
</li></ul>
</td></tr>
<tr><td><code id="datagrid_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="datagrid_+3A_newdata">newdata</code></td>
<td>
<p>data.frame (one and only one of the <code>model</code> and <code>newdata</code> arguments can be used.)</p>
</td></tr>
<tr><td><code id="datagrid_+3A_by">by</code></td>
<td>
<p>character vector with grouping variables within which <code style="white-space: pre;">&#8288;FUN_*&#8288;</code> functions are applied to create &quot;sub-grids&quot; with unspecified variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_grid_type">grid_type</code></td>
<td>
<p>character. Determines the functions to apply to each variable. The defaults can be overridden by defining individual variables explicitly in <code>...</code>, or by supplying a function to one of the <code style="white-space: pre;">&#8288;FUN_*&#8288;</code> arguments.
</p>

<ul>
<li><p> &quot;mean_or_mode&quot;: Character, factor, logical, and binary variables are set to their modes. Numeric, integer, and other variables are set to their means.
</p>
</li>
<li><p> &quot;balanced&quot;: Each unique level of character, factor, logical, and binary variables are preserved. Numeric, integer, and other variables are set to their means. Warning: When there are many variables and many levels per variable, a balanced grid can be very large. In those cases, it is better to use <code>grid_type="mean_or_mode"</code> and to specify the unique levels of a subset of named variables explicitly.
</p>
</li>
<li><p> &quot;counterfactual&quot;: the entire dataset is duplicated for each combination of the variable values specified in <code>...</code>. Variables not explicitly supplied to <code>datagrid()</code> are set to their observed values in the original dataset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_character">FUN_character</code></td>
<td>
<p>the function to be applied to character variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_factor">FUN_factor</code></td>
<td>
<p>the function to be applied to factor variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_logical">FUN_logical</code></td>
<td>
<p>the function to be applied to logical variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_numeric">FUN_numeric</code></td>
<td>
<p>the function to be applied to numeric variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_integer">FUN_integer</code></td>
<td>
<p>the function to be applied to integer variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_binary">FUN_binary</code></td>
<td>
<p>the function to be applied to binary variables.</p>
</td></tr>
<tr><td><code id="datagrid_+3A_fun_other">FUN_other</code></td>
<td>
<p>the function to be applied to other variable types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>datagrid</code> is used in a <code>predictions()</code>, <code>comparisons()</code>, or <code>slopes()</code> call as the
<code>newdata</code> argument, the model is automatically inserted in the <code>model</code> argument of <code>datagrid()</code>
call, and users do not need to specify either the <code>model</code> or <code>newdata</code> arguments. The same behavior will occur when the value supplied to <code style="white-space: pre;">&#8288;newdata=&#8288;</code> is a function call which starts with &quot;datagrid&quot;. This is intended to allow users to create convenience shortcuts like:
</p>
<pre>
library(marginaleffects)
mod &lt;- lm(mpg ~ am + vs + factor(cyl) + hp, mtcars)
datagrid_bal &lt;- function(...) datagrid(..., grid_type = "balanced")
predictions(model, newdata = datagrid_bal(cyl = 4))
</pre>
<p>If users supply a model, the data used to fit that model is retrieved using
the <code>insight::get_data</code> function.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> in which each row corresponds to one combination of the named
predictors supplied by the user via the <code>...</code> dots. Variables which are not
explicitly defined are held at their mean or mode.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The output only has 2 rows, and all the variables except `hp` are at their
# mean or mode.
datagrid(newdata = mtcars, hp = c(100, 110))

# We get the same result by feeding a model instead of a data.frame
mod &lt;- lm(mpg ~ hp, mtcars)
datagrid(model = mod, hp = c(100, 110))

# Use in `marginaleffects` to compute "Typical Marginal Effects". When used
# in `slopes()` or `predictions()` we do not need to specify the
#`model` or `newdata` arguments.
slopes(mod, newdata = datagrid(hp = c(100, 110)))

# datagrid accepts functions
datagrid(hp = range, cyl = unique, newdata = mtcars)
comparisons(mod, newdata = datagrid(hp = fivenum))

# The full dataset is duplicated with each observation given counterfactual
# values of 100 and 110 for the `hp` variable. The original `mtcars` includes
# 32 rows, so the resulting dataset includes 64 rows.
dg &lt;- datagrid(newdata = mtcars, hp = c(100, 110), grid_type = "counterfactual")
nrow(dg)

# We get the same result by feeding a model instead of a data.frame
mod &lt;- lm(mpg ~ hp, mtcars)
dg &lt;- datagrid(model = mod, hp = c(100, 110), grid_type = "counterfactual")
nrow(dg)
</code></pre>

<hr>
<h2 id='datagridcf'>Deprecated function</h2><span id='topic+datagridcf'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datagridcf(...)
</code></pre>

<hr>
<h2 id='deltamethod'>Deprecated function</h2><span id='topic+deltamethod'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltamethod(...)
</code></pre>

<hr>
<h2 id='expect_margins'><code>tinytest</code> helper</h2><span id='topic+expect_margins'></span>

<h3>Description</h3>

<p><code>tinytest</code> helper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_margins(
  results,
  margins_object,
  se = TRUE,
  tolerance = 1e-05,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='expect_predictions'><code>tinytest</code> helper</h2><span id='topic+expect_predictions'></span>

<h3>Description</h3>

<p><code>tinytest</code> helper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_predictions(object, se = TRUE, n_row = NULL, n_col = NULL)
</code></pre>

<hr>
<h2 id='expect_slopes'><code>tinytest</code> helper</h2><span id='topic+expect_slopes'></span>

<h3>Description</h3>

<p><code>tinytest</code> helper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_slopes(object, n_unique = NULL, pct_na = 5, se = TRUE, ...)
</code></pre>

<hr>
<h2 id='get_averages'>Average Estimates (aka &quot;Margins&quot;)</h2><span id='topic+get_averages'></span>

<h3>Description</h3>

<p>Calculate average estimates by taking the (group-wise) mean of all the unit-level
estimates computed by the <code>predictions()</code>, <code>comparisons()</code>, or <code>slopes()</code> functions.
</p>
<p>Warning: It is generally faster and safer to use the <code>by</code> argument of one of
the three functions listed above. Alternatively, one can call it in one step:
</p>
<p><code>avg_slopes(model)</code>
</p>
<p><code>slopes(model, by = TRUE)</code>
</p>
<p>Proceeding in two steps by assigning the unit-level estimates is typically
slower, because all estimates must be computed twice.
</p>
<p>Note that the <code>tidy()</code> and <code>summary()</code> methods are slower wrappers around <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_averages(x, by = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_averages_+3A_x">x</code></td>
<td>
<p>Object produced by the <code>predictions()</code>, <code>comparisons()</code>, or <code>slopes()</code> functions.</p>
</td></tr>
<tr><td><code id="get_averages_+3A_by">by</code></td>
<td>
<p>Character vector of variable names over which to compute group-wise average estimates. When <code>by=NULL</code>, the global average (per term) is reported.</p>
</td></tr>
<tr><td><code id="get_averages_+3A_...">...</code></td>
<td>
<p>All additional arguments are passed to the original fitting
function to override the original call options: <code>conf_level</code>, <code>transform</code>,
etc. See <code>?predictions</code>, <code>?comparisons</code>, <code>?slopes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard errors are estimated using the delta method. See the <code>marginaleffects</code> website for details.
</p>
<p>In Bayesian models (e.g., <code>brms</code>), estimates are aggregated applying the
median (or mean) function twice. First, we apply it to all
marginal effects for each posterior draw, thereby estimating one Average (or
Median) Marginal Effect per iteration of the MCMC chain. Second, we
calculate the mean and the <code>quantile</code> function to the results of Step 1 to
obtain the Average Marginal Effect and its associated interval.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of estimates and uncertainty estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mod &lt;- lm(mpg ~ factor(gear), data = mtcars)
avg_comparisons(mod, variables = list(gear = "sequential"))

</code></pre>

<hr>
<h2 id='get_coef'>Get a named vector of coefficients from a model object (internal function)</h2><span id='topic+get_coef'></span><span id='topic+get_coef.default'></span><span id='topic+get_coef.polr'></span><span id='topic+get_coef.afex_aov'></span><span id='topic+get_coef.betareg'></span><span id='topic+get_coef.multinom'></span><span id='topic+get_coef.brmultinom'></span><span id='topic+get_coef.bracl'></span><span id='topic+get_coef.brmsfit'></span><span id='topic+get_coef.data.frame'></span><span id='topic+get_coef.gamlss'></span><span id='topic+get_coef.glmmTMB'></span><span id='topic+get_coef.merMod'></span><span id='topic+get_coef.lmerModLmerTest'></span><span id='topic+get_coef.lmerMod'></span><span id='topic+get_coef.mblogit'></span><span id='topic+get_coef.gam'></span><span id='topic+get_coef.mlm'></span><span id='topic+get_coef.selection'></span><span id='topic+get_coef.scam'></span><span id='topic+get_coef.nls'></span><span id='topic+get_coef.svyolr'></span><span id='topic+get_coef.workflow'></span>

<h3>Description</h3>

<p>Get a named vector of coefficients from a model object (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_coef(model, ...)

## Default S3 method:
get_coef(model, ...)

## S3 method for class 'polr'
get_coef(model, ...)

## S3 method for class 'afex_aov'
get_coef(model, ...)

## S3 method for class 'betareg'
get_coef(model, ...)

## S3 method for class 'multinom'
get_coef(model, ...)

## S3 method for class 'brmultinom'
get_coef(model, ...)

## S3 method for class 'bracl'
get_coef(model, ...)

## S3 method for class 'brmsfit'
get_coef(model, ...)

## S3 method for class 'data.frame'
get_coef(model, ...)

## S3 method for class 'gamlss'
get_coef(model, ...)

## S3 method for class 'glmmTMB'
get_coef(model, ...)

## S3 method for class 'merMod'
get_coef(model, ...)

## S3 method for class 'lmerModLmerTest'
get_coef(model, ...)

## S3 method for class 'lmerMod'
get_coef(model, ...)

## S3 method for class 'mblogit'
get_coef(model, ...)

## S3 method for class 'gam'
get_coef(model, ...)

## S3 method for class 'mlm'
get_coef(model, ...)

## S3 method for class 'selection'
get_coef(model, ...)

## S3 method for class 'scam'
get_coef(model, ...)

## S3 method for class 'nls'
get_coef(model, ...)

## S3 method for class 'svyolr'
get_coef(model, ...)

## S3 method for class 'workflow'
get_coef(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_coef_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="get_coef_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of coefficients. The names must match those of the variance matrix.
</p>

<hr>
<h2 id='get_group_names'>Get levels of the outcome variable in grouped or multivariate models</h2><span id='topic+get_group_names'></span><span id='topic+get_group_names.default'></span><span id='topic+get_group_names.polr'></span><span id='topic+get_group_names.multinom'></span><span id='topic+get_group_names.bracl'></span><span id='topic+get_group_names.brmsfit'></span><span id='topic+get_group_names.mblogit'></span><span id='topic+get_group_names.mlm'></span><span id='topic+get_group_names.clm'></span><span id='topic+get_group_names.hurdle'></span><span id='topic+get_group_names.svyolr'></span>

<h3>Description</h3>

<p>Get levels of the outcome variable in grouped or multivariate models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group_names(model, ...)

## Default S3 method:
get_group_names(model, ...)

## S3 method for class 'polr'
get_group_names(model, ...)

## S3 method for class 'multinom'
get_group_names(model, ...)

## S3 method for class 'bracl'
get_group_names(model, ...)

## S3 method for class 'brmsfit'
get_group_names(model, ...)

## S3 method for class 'mblogit'
get_group_names(model, type, ...)

## S3 method for class 'mlm'
get_group_names(model, ...)

## S3 method for class 'clm'
get_group_names(model, ...)

## S3 method for class 'hurdle'
get_group_names(model, type = "count", ...)

## S3 method for class 'svyolr'
get_group_names(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_group_names_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="get_group_names_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
<tr><td><code id="get_group_names_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='get_model_matrix'>Get a named model matrix</h2><span id='topic+get_model_matrix'></span><span id='topic+get_model_matrix.default'></span>

<h3>Description</h3>

<p>Get a named model matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_model_matrix(model, newdata)

## Default S3 method:
get_model_matrix(model, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_model_matrix_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="get_model_matrix_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code><a href="#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Marginal Effects at the Mean. Slopes when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Marginal Effects at the Median. Slopes when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Marginal Effects at Marginal Means. See Details section below.
</p>
</li>
<li><p> &quot;tukey&quot;: Marginal Effects at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Marginal Effects on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li></ul>
</td></tr>
</table>

<hr>
<h2 id='get_predict'>Get predicted values from a model object (internal function)</h2><span id='topic+get_predict'></span><span id='topic+get_predict.default'></span><span id='topic+get_predict.polr'></span><span id='topic+get_predict.glmmPQL'></span><span id='topic+get_predict.MCMCglmm'></span><span id='topic+get_predict.afex_aov'></span><span id='topic+get_predict.glimML'></span><span id='topic+get_predict.betareg'></span><span id='topic+get_predict.bife'></span><span id='topic+get_predict.biglm'></span><span id='topic+get_predict.multinom'></span><span id='topic+get_predict.brmultinom'></span><span id='topic+get_predict.brmsfit'></span><span id='topic+get_predict.crch'></span><span id='topic+get_predict.bart'></span><span id='topic+get_predict.fixest'></span><span id='topic+get_predict.gamlss'></span><span id='topic+get_predict.glmmTMB'></span><span id='topic+get_predict.inferences_simulation'></span><span id='topic+get_predict.merMod'></span><span id='topic+get_predict.lmerModLmerTest'></span><span id='topic+get_predict.lmerMod'></span><span id='topic+get_predict.mblogit'></span><span id='topic+get_predict.mhurdle'></span><span id='topic+get_predict.mlogit'></span><span id='topic+get_predict.Learner'></span><span id='topic+get_predict.clm'></span><span id='topic+get_predict.rq'></span><span id='topic+get_predict.rms'></span><span id='topic+get_predict.orm'></span><span id='topic+get_predict.lrm'></span><span id='topic+get_predict.ols'></span><span id='topic+get_predict.rlmerMod'></span><span id='topic+get_predict.stanreg'></span><span id='topic+get_predict.lm'></span><span id='topic+get_predict.glm'></span><span id='topic+get_predict.svyolr'></span><span id='topic+get_predict.coxph'></span><span id='topic+get_predict.model_fit'></span><span id='topic+get_predict.workflow'></span><span id='topic+get_predict.tobit1'></span>

<h3>Description</h3>

<p>Get predicted values from a model object (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predict(model, newdata, type, ...)

## Default S3 method:
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'polr'
get_predict(model, newdata = insight::get_data(model), type = "probs", ...)

## S3 method for class 'glmmPQL'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'MCMCglmm'
get_predict(model, newdata, type = "response", ndraws = 1000, ...)

## S3 method for class 'afex_aov'
get_predict(model, newdata = NULL, ...)

## S3 method for class 'glimML'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'betareg'
get_predict(model, newdata, ...)

## S3 method for class 'bife'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'biglm'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'multinom'
get_predict(model, newdata = insight::get_data(model), type = "probs", ...)

## S3 method for class 'brmultinom'
get_predict(model, newdata = insight::get_data(model), type = "probs", ...)

## S3 method for class 'brmsfit'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'crch'
get_predict(model, newdata = NULL, type = "location", ...)

## S3 method for class 'bart'
get_predict(model, newdata = NULL, ...)

## S3 method for class 'fixest'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'gamlss'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'glmmTMB'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'inferences_simulation'
get_predict(model, newdata, ...)

## S3 method for class 'merMod'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'lmerModLmerTest'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'lmerMod'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'mblogit'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'mhurdle'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'mlogit'
get_predict(model, newdata, ...)

## S3 method for class 'Learner'
get_predict(model, newdata, type = NULL, ...)

## S3 method for class 'clm'
get_predict(model, newdata = insight::get_data(model), type = "prob", ...)

## S3 method for class 'rq'
get_predict(model, newdata = insight::get_data(model), type = NULL, ...)

## S3 method for class 'rms'
get_predict(model, newdata = insight::get_data(model), type = NULL, ...)

## S3 method for class 'orm'
get_predict(model, newdata = insight::get_data(model), type = NULL, ...)

## S3 method for class 'lrm'
get_predict(model, newdata = insight::get_data(model), type = NULL, ...)

## S3 method for class 'ols'
get_predict(model, newdata = insight::get_data(model), type = NULL, ...)

## S3 method for class 'rlmerMod'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'stanreg'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'lm'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'glm'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)

## S3 method for class 'svyolr'
get_predict(model, newdata = insight::get_data(model), type = "probs", ...)

## S3 method for class 'coxph'
get_predict(model, newdata = insight::get_data(model), type = "lp", ...)

## S3 method for class 'model_fit'
get_predict(model, newdata, type = NULL, ...)

## S3 method for class 'workflow'
get_predict(model, newdata, type = NULL, ...)

## S3 method for class 'tobit1'
get_predict(model, newdata = insight::get_data(model), type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predict_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="get_predict_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code><a href="#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Marginal Effects at the Mean. Slopes when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Marginal Effects at the Median. Slopes when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Marginal Effects at Marginal Means. See Details section below.
</p>
</li>
<li><p> &quot;tukey&quot;: Marginal Effects at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Marginal Effects on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="get_predict_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="get_predict_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of predicted values with a number of rows equal to the
number of rows in <code>newdata</code> and columns &quot;rowid&quot; and &quot;estimate&quot;. A &quot;group&quot;
column is added for multivariate models or models with categorical outcomes.
</p>

<hr>
<h2 id='get_varcov_args'>Take a <code>summary()</code> style <code>vcov</code> argument and convert it to
<code>insight::get_varcov()</code></h2><span id='topic+get_varcov_args'></span>

<h3>Description</h3>

<p>Take a <code>summary()</code> style <code>vcov</code> argument and convert it to
<code>insight::get_varcov()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_varcov_args(model, vcov)
</code></pre>

<hr>
<h2 id='get_vcov'>Get a named variance-covariance matrix from a model object (internal function)</h2><span id='topic+get_vcov'></span><span id='topic+get_vcov.default'></span><span id='topic+get_vcov.MCMCglmm'></span><span id='topic+get_vcov.afex_aov'></span><span id='topic+get_vcov.glimML'></span><span id='topic+get_vcov.biglm'></span><span id='topic+get_vcov.brmsfit'></span><span id='topic+get_vcov.bart'></span><span id='topic+get_vcov.gamlss'></span><span id='topic+get_vcov.glmmTMB'></span><span id='topic+get_vcov.inferences_simulation'></span><span id='topic+get_vcov.mhurdle'></span><span id='topic+get_vcov.Learner'></span><span id='topic+get_vcov.orm'></span><span id='topic+get_vcov.scam'></span><span id='topic+get_vcov.model_fit'></span><span id='topic+get_vcov.workflow'></span>

<h3>Description</h3>

<p>Get a named variance-covariance matrix from a model object (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vcov(model, ...)

## Default S3 method:
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'MCMCglmm'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'afex_aov'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'glimML'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'biglm'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'brmsfit'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'bart'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'gamlss'
get_vcov(model, ...)

## S3 method for class 'glmmTMB'
get_vcov(model, ...)

## S3 method for class 'inferences_simulation'
get_vcov(model, ...)

## S3 method for class 'mhurdle'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'Learner'
get_vcov(model, ...)

## S3 method for class 'orm'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'scam'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'model_fit'
get_vcov(model, type = NULL, ...)

## S3 method for class 'workflow'
get_vcov(model, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vcov_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="get_vcov_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
<tr><td><code id="get_vcov_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_vcov_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named square matrix of variance and covariances. The names must match the coefficient names.
</p>

<hr>
<h2 id='hypotheses'>(Non-)Linear Tests for Null Hypotheses, Joint Hypotheses, Equivalence, Non Superiority, and Non Inferiority</h2><span id='topic+hypotheses'></span>

<h3>Description</h3>

<p>Uncertainty estimates are calculated as first-order approximate standard errors for linear or non-linear functions of a vector of random variables with known or estimated covariance matrix. In that sense, <code><a href="#topic+hypotheses">hypotheses</a></code> emulates the behavior of the excellent and well-established <a href="car.html#topic+deltaMethod">car::deltaMethod</a> and <a href="car.html#topic+linearHypothesis">car::linearHypothesis</a> functions, but it supports more models; requires fewer dependencies; expands the range of tests to equivalence and superiority/inferiority; and offers convenience features like robust standard errors.
</p>
<p>To learn more, read the hypothesis tests vignette, visit the
package website, or scroll down this page for a full list of vignettes:
</p>

<ul>
<li> <p><a href="https://marginaleffects.com/vignettes/hypothesis.html">https://marginaleffects.com/vignettes/hypothesis.html</a>
</p>
</li>
<li> <p><a href="https://marginaleffects.com/">https://marginaleffects.com/</a>
</p>
</li></ul>

<p>Warning #1: Tests are conducted directly on the scale defined by the <code>type</code> argument. For some models, it can make sense to conduct hypothesis or equivalence tests on the <code>"link"</code> scale instead of the <code>"response"</code> scale which is often the default.
</p>
<p>Warning #2: For hypothesis tests on objects produced by the <code>marginaleffects</code> package, it is safer to use the <code>hypothesis</code> argument of the original function.  Using <code>hypotheses()</code> may not work in certain environments, in lists, or when working programmatically with *apply style functions.
</p>
<p>Warning #3: The tests assume that the <code>hypothesis</code> expression is (approximately) normally distributed, which for non-linear functions of the parameters may not be realistic. More reliable confidence intervals can be obtained using the <code>inferences()</code> function with <code>method = "boot"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypotheses(
  model,
  hypothesis = NULL,
  vcov = NULL,
  conf_level = 0.95,
  df = Inf,
  equivalence = NULL,
  joint = FALSE,
  joint_test = "f",
  FUN = NULL,
  numderiv = "fdforward",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypotheses_+3A_model">model</code></td>
<td>
<p>Model object or object generated by the <code>comparisons()</code>, <code>slopes()</code>, or <code>predictions()</code> functions.</p>
</td></tr>
<tr><td><code id="hypotheses_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="hypotheses_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="hypotheses_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="hypotheses_+3A_df">df</code></td>
<td>
<p>Degrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and <code>Inf</code>. When <code>df</code> is <code>Inf</code>, the normal distribution is used. When <code>df</code> is finite, the <code>t</code> distribution is used. See <a href="insight.html#topic+get_df">insight::get_df</a> for a convenient function to extract degrees of freedom. Ex: <code>slopes(model, df = insight::get_df(model))</code></p>
</td></tr>
<tr><td><code id="hypotheses_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="hypotheses_+3A_joint">joint</code></td>
<td>
<p>Joint test of statistical significance. The null hypothesis value can be set using the <code>hypothesis</code> argument.
</p>

<ul>
<li><p> FALSE: Hypotheses are not tested jointly.
</p>
</li>
<li><p> TRUE: All parameters are tested jointly.
</p>
</li>
<li><p> String: A regular expression to match parameters to be tested jointly. <code>grep(joint, perl = TRUE)</code>
</p>
</li>
<li><p> Character vector of parameter names to be tested. Characters refer to the names of the vector returned by <code>coef(object)</code>.
</p>
</li>
<li><p> Integer vector of indices. Which parameters positions to test jointly.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hypotheses_+3A_joint_test">joint_test</code></td>
<td>
<p>A character string specifying the type of test, either &quot;f&quot; or &quot;chisq&quot;. The null hypothesis is set by the <code>hypothesis</code> argument, with default null equal to 0 for all parameters.</p>
</td></tr>
<tr><td><code id="hypotheses_+3A_fun">FUN</code></td>
<td>
<p><code>NULL</code> or function.
</p>

<ul>
<li> <p><code>NULL</code> (default): hypothesis test on a model's coefficients, or on the quantities estimated by one of the <code>marginaleffects</code> package functions.
</p>
</li>
<li><p> Function which accepts a model object and returns a numeric vector or a data.frame with two columns called <code>term</code> and <code>estimate</code>. This argument can be useful when users want to conduct a hypothesis test on an arbitrary function of quantities held in a model object. See examples below.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hypotheses_+3A_numderiv">numderiv</code></td>
<td>
<p>string or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.
</p>

<ul>
<li><p> &quot;fdforward&quot;: finite difference method with forward differences
</p>
</li>
<li><p> &quot;fdcenter&quot;: finite difference method with central differences (default)
</p>
</li>
<li><p> &quot;richardson&quot;: Richardson extrapolation method
</p>
</li>
<li><p> Extra arguments can be specified by passing a list to the <code>numDeriv</code> argument, with the name of the method first and named arguments following, ex: <code>numderiv=list("fdcenter", eps = 1e-5)</code>. When an unknown argument is used, <code>marginaleffects</code> prints the list of valid arguments for each method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hypotheses_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Joint hypothesis tests</h3>

<p>The test statistic for the joint Wald test is calculated as (R * theta_hat - r)' * inv(R * V_hat * R') * (R * theta_hat - r) / Q,
where theta_hat is the vector of estimated parameters, V_hat is the estimated covariance matrix, R is a Q x P matrix for testing Q hypotheses on P parameters,
r is a Q x 1 vector for the null hypothesis, and Q is the number of rows in R. If the test is a Chi-squared test, the test statistic is not normalized.
</p>
<p>The p-value is then calculated based on either the F-distribution (for F-test) or the Chi-squared distribution (for Chi-squared test).
For the F-test, the degrees of freedom are Q and (n - P), where n is the sample size and P is the number of parameters.
For the Chi-squared test, the degrees of freedom are Q.
</p>


<h3>Equivalence, Inferiority, Superiority</h3>

<p><code class="reqn">\theta</code> is an estimate, <code class="reqn">\sigma_\theta</code> its estimated standard error, and <code class="reqn">[a, b]</code> are the bounds of the interval supplied to the <code>equivalence</code> argument.
</p>
<p>Non-inferiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \leq a</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &gt; a</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - a)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Upper-tail probability
</p>
</li></ul>

<p>Non-superiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \geq b</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &lt; b</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - b)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Lower-tail probability
</p>
</li></ul>

<p>Equivalence: Two One-Sided Tests (TOST)
</p>

<ul>
<li><p> p: Maximum of the non-inferiority and non-superiority p values.
</p>
</li></ul>

<p>Thanks to Russell V. Lenth for the excellent <code>emmeans</code> package and documentation which inspired this feature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(marginaleffects)
mod &lt;- lm(mpg ~ hp + wt + factor(cyl), data = mtcars)

# When `FUN` and `hypotheses` are `NULL`, `hypotheses()` returns a data.frame of parameters
hypotheses(mod)

# Test of equality between coefficients
hypotheses(mod, hypothesis = "hp = wt")

# Non-linear function
hypotheses(mod, hypothesis = "exp(hp + wt) = 0.1")

# Robust standard errors
hypotheses(mod, hypothesis = "hp = wt", vcov = "HC3")

# b1, b2, ... shortcuts can be used to identify the position of the
# parameters of interest in the output of FUN
hypotheses(mod, hypothesis = "b2 = b3")

# wildcard
hypotheses(mod, hypothesis = "b* / b2 = 1")

# term names with special characters have to be enclosed in backticks
hypotheses(mod, hypothesis = "`factor(cyl)6` = `factor(cyl)8`")

mod2 &lt;- lm(mpg ~ hp * drat, data = mtcars)
hypotheses(mod2, hypothesis = "`hp:drat` = drat")

# predictions(), comparisons(), and slopes()
mod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)
cmp &lt;- comparisons(mod, newdata = "mean")
hypotheses(cmp, hypothesis = "b1 = b2")

mfx &lt;- slopes(mod, newdata = "mean")
hypotheses(cmp, hypothesis = "b2 = 0.2")

pre &lt;- predictions(mod, newdata = datagrid(hp = 110, mpg = c(30, 35)))
hypotheses(pre, hypothesis = "b1 = b2")

# The `FUN` argument can be used to compute standard errors for fitted values
mod &lt;- glm(am ~ hp + mpg, data = mtcars, family = binomial)

f &lt;- function(x) predict(x, type = "link", newdata = mtcars)
p &lt;- hypotheses(mod, FUN = f)
head(p)

f &lt;- function(x) predict(x, type = "response", newdata = mtcars)
p &lt;- hypotheses(mod, FUN = f)
head(p)

# Complex aggregation
# Step 1: Collapse predicted probabilities by outcome level, for each individual
# Step 2: Take the mean of the collapsed probabilities by group and `cyl`
library(dplyr)
library(MASS)
library(dplyr)

dat &lt;- transform(mtcars, gear = factor(gear))
mod &lt;- polr(gear ~ factor(cyl) + hp, dat)

aggregation_fun &lt;- function(model) {
    predictions(model, vcov = FALSE) |&gt;
        mutate(group = ifelse(group %in% c("3", "4"), "3 &amp; 4", "5")) |&gt;
        summarize(estimate = sum(estimate), .by = c("rowid", "cyl", "group")) |&gt;
        summarize(estimate = mean(estimate), .by = c("cyl", "group")) |&gt;
        rename(term = cyl)
}

hypotheses(mod, FUN = aggregation_fun)

# Equivalence, non-inferiority, and non-superiority tests
mod &lt;- lm(mpg ~ hp + factor(gear), data = mtcars)
p &lt;- predictions(mod, newdata = "median")
hypotheses(p, equivalence = c(17, 18))

mfx &lt;- avg_slopes(mod, variables = "hp")
hypotheses(mfx, equivalence = c(-.1, .1))

cmp &lt;- avg_comparisons(mod, variables = "gear", hypothesis = "pairwise")
hypotheses(cmp, equivalence = c(0, 10))

# joint hypotheses: character vector
model &lt;- lm(mpg ~ as.factor(cyl) * hp, data = mtcars)
hypotheses(model, joint = c("as.factor(cyl)6:hp", "as.factor(cyl)8:hp"))

# joint hypotheses: regular expression
hypotheses(model, joint = "cyl")

# joint hypotheses: integer indices
hypotheses(model, joint = 2:3)

# joint hypotheses: different null hypotheses
hypotheses(model, joint = 2:3, hypothesis = 1)
hypotheses(model, joint = 2:3, hypothesis = 1:2)

# joint hypotheses: marginaleffects object
cmp &lt;- avg_comparisons(model)
hypotheses(cmp, joint = "cyl")

</code></pre>

<hr>
<h2 id='inferences'>(EXPERIMENTAL) Bootstrap, Conformal, and Simulation-Based Inference</h2><span id='topic+inferences'></span>

<h3>Description</h3>

<p>Warning: This function is experimental. It may be renamed, the user interface may change, or the functionality may migrate to arguments in other <code>marginaleffects</code> functions.
</p>
<p>Apply this function to a <code>marginaleffects</code> object to change the inferential method used to compute uncertainty estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferences(
  x,
  method,
  R = 1000,
  conf_type = "perc",
  conformal_test = NULL,
  conformal_calibration = NULL,
  conformal_score = "residual_abs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferences_+3A_x">x</code></td>
<td>
<p>Object produced by one of the core <code>marginaleffects</code> functions.</p>
</td></tr>
<tr><td><code id="inferences_+3A_method">method</code></td>
<td>
<p>String
</p>

<ul>
<li><p> &quot;delta&quot;: delta method standard errors
</p>
</li>
<li><p> &quot;boot&quot; package
</p>
</li>
<li><p> &quot;fwb&quot;: fractional weighted bootstrap
</p>
</li>
<li><p> &quot;rsample&quot; package
</p>
</li>
<li><p> &quot;simulation&quot; from a multivariate normal distribution (Krinsky &amp; Robb, 1986)
</p>
</li>
<li><p> &quot;mi&quot; multiple imputation for missing data
</p>
</li>
<li><p> &quot;conformal_split&quot;: prediction intervals using split conformal prediction (see Angelopoulos &amp; Bates, 2022)
</p>
</li>
<li><p> &quot;conformal_cv+&quot;: prediction intervals using cross-validation+ conformal prediction (see Barber et al., 2020)
</p>
</li></ul>
</td></tr>
<tr><td><code id="inferences_+3A_r">R</code></td>
<td>
<p>Number of resamples, simulations, or cross-validation folds.</p>
</td></tr>
<tr><td><code id="inferences_+3A_conf_type">conf_type</code></td>
<td>
<p>String: type of bootstrap interval to construct.
</p>

<ul>
<li> <p><code>boot</code>: &quot;perc&quot;, &quot;norm&quot;, &quot;basic&quot;, or &quot;bca&quot;
</p>
</li>
<li> <p><code>fwb</code>: &quot;perc&quot;, &quot;norm&quot;, &quot;basic&quot;, &quot;bc&quot;, or &quot;bca&quot;
</p>
</li>
<li> <p><code>rsample</code>: &quot;perc&quot; or &quot;bca&quot;
</p>
</li>
<li> <p><code>simulation</code>: argument ignored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inferences_+3A_conformal_test">conformal_test</code></td>
<td>
<p>Data frame of test data for conformal prediction.</p>
</td></tr>
<tr><td><code id="inferences_+3A_conformal_calibration">conformal_calibration</code></td>
<td>
<p>Data frame of calibration data for split conformal prediction (<code style="white-space: pre;">&#8288;method="conformal_split&#8288;</code>).</p>
</td></tr>
<tr><td><code id="inferences_+3A_conformal_score">conformal_score</code></td>
<td>
<p>String. Warning: The <code>type</code> argument in <code>predictions()</code> must generate predictions which are on the same scale as the outcome variable. Typically, this means that <code>type</code> must be &quot;response&quot; or &quot;probs&quot;.
</p>

<ul>
<li><p> &quot;residual_abs&quot; or &quot;residual_sq&quot; for regression tasks (numeric outcome)
</p>
</li>
<li><p> &quot;softmax&quot; for classification tasks (when <code>predictions()</code> returns a <code>group</code> columns, such as multinomial or ordinal logit models.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inferences_+3A_...">...</code></td>
<td>

<ul>
<li><p> If <code>method="boot"</code>, additional arguments are passed to <code>boot::boot()</code>.
</p>
</li>
<li><p> If <code>method="fwb"</code>, additional arguments are passed to <code>fwb::fwb()</code>.
</p>
</li>
<li><p> If <code>method="rsample"</code>, additional arguments are passed to <code>rsample::bootstraps()</code>.
</p>
</li>
<li><p> Additional arguments are ignored for all other methods.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>method="simulation"</code>, we conduct simulation-based inference following the method discussed in Krinsky &amp; Robb (1986):
</p>

<ol>
<li><p> Draw <code>R</code> sets of simulated coefficients from a multivariate normal distribution with mean equal to the original model's estimated coefficients and variance equal to the model's variance-covariance matrix (classical, &quot;HC3&quot;, or other).
</p>
</li>
<li><p> Use the <code>R</code> sets of coefficients to compute <code>R</code> sets of estimands: predictions, comparisons, slopes, or hypotheses.
</p>
</li>
<li><p> Take quantiles of the resulting distribution of estimands to obtain a confidence interval and the standard deviation of simulated estimates to estimate the standard error.
</p>
</li></ol>

<p>When <code>method="fwb"</code>, drawn weights are supplied to the model fitting function's <code>weights</code> argument; if the model doesn't accept non-integer weights, this method should not be used. If weights were included in the original model fit, they are extracted by <code><a href="stats.html#topic+weights">weights()</a></code> and multiplied by the drawn weights. These weights are supplied to the <code>wts</code> argument of the estimation function (e.g., <code>comparisons()</code>).
</p>


<h3>Value</h3>

<p>A <code>marginaleffects</code> object with simulation or bootstrap resamples and objects attached.
</p>


<h3>References</h3>

<p>Krinsky, I., and A. L. Robb. 1986. “On Approximating the Statistical Properties of Elasticities.” Review of Economics and Statistics 68 (4): 715–9.
</p>
<p>King, Gary, Michael Tomz, and Jason Wittenberg. &quot;Making the most of statistical analyses: Improving interpretation and presentation.&quot; American journal of political science (2000): 347-361
</p>
<p>Dowd, Bryan E., William H. Greene, and Edward C. Norton. &quot;Computation of standard errors.&quot; Health services research 49.2 (2014): 731-750.
</p>
<p>Angelopoulos, Anastasios N., and Stephen Bates. 2022. &quot;A Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification.&quot; arXiv. https://doi.org/10.48550/arXiv.2107.07511.
</p>
<p>Barber, Rina Foygel, Emmanuel J. Candes, Aaditya Ramdas, and Ryan J. Tibshirani. 2020. “Predictive Inference with the Jackknife+.” arXiv. http://arxiv.org/abs/1905.02928.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(marginaleffects)
library(magrittr)
set.seed(1024)
mod &lt;- lm(Sepal.Length ~ Sepal.Width * Species, data = iris)

# bootstrap
avg_predictions(mod, by = "Species") %&gt;%
  inferences(method = "boot")

avg_predictions(mod, by = "Species") %&gt;%
  inferences(method = "rsample")

# Fractional (bayesian) bootstrap
avg_slopes(mod, by = "Species") %&gt;%
  inferences(method = "fwb") %&gt;%
  posterior_draws("rvar") %&gt;%
  data.frame()

# Simulation-based inference
slopes(mod) %&gt;%
  inferences(method = "simulation") %&gt;%
  head()

## End(Not run)
</code></pre>

<hr>
<h2 id='marginal_means'>Deprecated function</h2><span id='topic+marginal_means'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_means(
  model,
  variables = NULL,
  newdata = NULL,
  vcov = TRUE,
  conf_level = 0.95,
  type = NULL,
  transform = NULL,
  cross = FALSE,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  wts = "equal",
  by = NULL,
  numderiv = "fdforward",
  ...
)
</code></pre>

<hr>
<h2 id='marginaleffects'>Deprecated function</h2><span id='topic+marginaleffects'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginaleffects(...)
</code></pre>

<hr>
<h2 id='marginalmeans'>Deprecated function</h2><span id='topic+marginalmeans'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalmeans(
  model,
  variables = NULL,
  newdata = NULL,
  vcov = TRUE,
  conf_level = 0.95,
  type = NULL,
  transform = NULL,
  cross = FALSE,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  wts = "equal",
  by = NULL,
  numderiv = "fdforward",
  ...
)
</code></pre>

<hr>
<h2 id='meffects'>Deprecated function</h2><span id='topic+meffects'></span>

<h3>Description</h3>

<p>Deprecated function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meffects(...)
</code></pre>

<hr>
<h2 id='plot_comparisons'>Plot Conditional or Marginal Comparisons</h2><span id='topic+plot_comparisons'></span>

<h3>Description</h3>

<p>Plot comparisons on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).
</p>
<p>The <code>by</code> argument is used to plot marginal comparisons, that is, comparisons made on the original data, but averaged by subgroups. This is analogous to using the <code>by</code> argument in the <code>comparisons()</code> function.
</p>
<p>The <code>condition</code> argument is used to plot conditional comparisons, that is, comparisons made on a user-specified grid. This is analogous to using the <code>newdata</code> argument and <code>datagrid()</code> function in a <code>comparisons()</code> call. All variables whose values are not specified explicitly are treated as usual by <code>datagrid()</code>, that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the <code>condition</code> argument, or supply model-specific arguments to compute population-level estimates. See details below.
</p>
<p>See the &quot;Plots&quot; vignette and website for tutorials and information on how to customize plots:
</p>

<ul>
<li><p> https://marginaleffects.com/vignettes/plot.html
</p>
</li>
<li><p> https://marginaleffects.com
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_comparisons(
  model,
  variables = NULL,
  condition = NULL,
  by = NULL,
  newdata = NULL,
  type = "response",
  vcov = NULL,
  conf_level = 0.95,
  wts = NULL,
  comparison = "difference",
  transform = NULL,
  rug = FALSE,
  gray = FALSE,
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_comparisons_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_variables">variables</code></td>
<td>
<p>Name of the variable whose contrast we want to plot on the y-axis.</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_condition">condition</code></td>
<td>
<p>Conditional slopes
</p>

<ul>
<li><p> Character vector (max length 4): Names of the predictors to display.
</p>
</li>
<li><p> Named list (max length 4): List names correspond to predictors. List elements can be:
</p>

<ul>
<li><p> Numeric vector
</p>
</li>
<li><p> Function which returns a numeric vector or a set of unique categorical values
</p>
</li>
<li><p> Shortcut strings for common reference values: &quot;minmax&quot;, &quot;quartile&quot;, &quot;threenum&quot;
</p>
</li></ul>

</li>
<li><p> 1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).
</p>
</li>
<li><p> Numeric variables in positions 2 and 3 are summarized by Tukey's five numbers <code>?stats::fivenum</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_newdata">newdata</code></td>
<td>
<p>When <code>newdata</code> is <code>NULL</code>, the grid is determined by the <code>condition</code> argument. When <code>newdata</code> is not <code>NULL</code>, the argument behaves in the same way as in the <code>comparisons()</code> function.</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_comparison">comparison</code></td>
<td>
<p>How should pairs of predictions be compared? Difference, ratio, odds ratio, or user-defined functions.
</p>

<ul>
<li><p> string: shortcuts to common contrast functions.
</p>

<ul>
<li><p> Supported shortcuts strings: difference, differenceavg, differenceavgwts, dydx, eyex, eydx, dyex, dydxavg, eyexavg, eydxavg, dyexavg, dydxavgwts, eyexavgwts, eydxavgwts, dyexavgwts, ratio, ratioavg, ratioavgwts, lnratio, lnratioavg, lnratioavgwts, lnor, lnoravg, lnoravgwts, lift, liftavg, expdydx, expdydxavg, expdydxavgwts
</p>
</li>
<li><p> See the Comparisons section below for definitions of each transformation.
</p>
</li></ul>

</li>
<li><p> function: accept two equal-length numeric vectors of adjusted predictions (<code>hi</code> and <code>lo</code>) and returns a vector of contrasts of the same length, or a unique numeric value.
</p>

<ul>
<li><p> See the Transformations section below for examples of valid functions.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_transform">transform</code></td>
<td>
<p>string or function. Transformation applied to unit-level estimates and confidence intervals just before the function returns results. Functions must accept a vector and return a vector of the same length. Support string shortcuts: &quot;exp&quot;, &quot;ln&quot;</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_rug">rug</code></td>
<td>
<p>TRUE displays tick marks on the axes to mark the distribution of raw data.</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_gray">gray</code></td>
<td>
<p>FALSE grayscale or color plot</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_draw">draw</code></td>
<td>
<p><code>TRUE</code> returns a <code>ggplot2</code> plot. <code>FALSE</code> returns a <code>data.frame</code> of the underlying data.</p>
</td></tr>
<tr><td><code id="plot_comparisons_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object
</p>


<h3>Model-Specific Arguments</h3>

<p>Some model types allow model-specific arguments to modify the nature of
marginal effects, predictions, marginal means, and contrasts. Please report
other package-specific <code>predict()</code> arguments on Github so we can add them to
the table below.
</p>
<p>https://github.com/vincentarelbundock/marginaleffects/issues</p>

<table>
<tr>
 <td style="text-align: left;">
   Package </td><td style="text-align: left;"> Class </td><td style="text-align: left;"> Argument </td><td style="text-align: left;"> Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>brms</code> </td><td style="text-align: left;"> <code>brmsfit</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>re_formula</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lme4</code> </td><td style="text-align: left;"> <code>merMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>glmmTMB</code> </td><td style="text-align: left;"> <code>glmmTMB</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>zitype</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mgcv</code> </td><td style="text-align: left;"> <code>bam</code> </td><td style="text-align: left;"> <code>exclude</code> </td><td style="text-align: left;"> <a href="mgcv.html#topic+predict.bam">mgcv::predict.bam</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>robustlmm</code> </td><td style="text-align: left;"> <code>rlmerMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(mpg ~ hp * drat * factor(am), data = mtcars)

plot_comparisons(mod, variables = "hp", condition = "drat")

plot_comparisons(mod, variables = "hp", condition = c("drat", "am"))

plot_comparisons(mod, variables = "hp", condition = list("am", "drat" = 3:5))

plot_comparisons(mod, variables = "am", condition = list("hp", "drat" = range))

plot_comparisons(mod, variables = "am", condition = list("hp", "drat" = "threenum"))
</code></pre>

<hr>
<h2 id='plot_predictions'>Plot Conditional or Marginal Predictions</h2><span id='topic+plot_predictions'></span>

<h3>Description</h3>

<p>Plot predictions on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).
</p>
<p>The <code>by</code> argument is used to plot marginal predictions, that is, predictions made on the original data, but averaged by subgroups. This is analogous to using the <code>by</code> argument in the <code>predictions()</code> function.
</p>
<p>The <code>condition</code> argument is used to plot conditional predictions, that is, predictions made on a user-specified grid. This is analogous to using the <code>newdata</code> argument and <code>datagrid()</code> function in a <code>predictions()</code> call. All variables whose values are not specified explicitly are treated as usual by <code>datagrid()</code>, that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the <code>condition</code> argument, or supply model-specific arguments to compute population-level estimates. See details below.
</p>
<p>See the &quot;Plots&quot; vignette and website for tutorials and information on how to customize plots:
</p>

<ul>
<li><p> https://marginaleffects.com/vignettes/plot.html
</p>
</li>
<li><p> https://marginaleffects.com
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_predictions(
  model,
  condition = NULL,
  by = NULL,
  newdata = NULL,
  type = NULL,
  vcov = NULL,
  conf_level = 0.95,
  wts = NULL,
  transform = NULL,
  points = 0,
  rug = FALSE,
  gray = FALSE,
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_predictions_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_condition">condition</code></td>
<td>
<p>Conditional predictions
</p>

<ul>
<li><p> Character vector (max length 4): Names of the predictors to display.
</p>
</li>
<li><p> Named list (max length 4): List names correspond to predictors. List elements can be:
</p>

<ul>
<li><p> Numeric vector
</p>
</li>
<li><p> Function which returns a numeric vector or a set of unique categorical values
</p>
</li>
<li><p> Shortcut strings for common reference values: &quot;minmax&quot;, &quot;quartile&quot;, &quot;threenum&quot;
</p>
</li></ul>

</li>
<li><p> 1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).
</p>
</li>
<li><p> Numeric variables in positions 2 and 3 are summarized by Tukey's five numbers <code>?stats::fivenum</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_predictions_+3A_by">by</code></td>
<td>
<p>Marginal predictions
</p>

<ul>
<li><p> Character vector (max length 3): Names of the categorical predictors to marginalize across.
</p>
</li>
<li><p> 1: x-axis. 2: color. 3: facets.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_predictions_+3A_newdata">newdata</code></td>
<td>
<p>When <code>newdata</code> is <code>NULL</code>, the grid is determined by the <code>condition</code> argument. When <code>newdata</code> is not <code>NULL</code>, the argument behaves in the same way as in the <code>predictions()</code> function.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_predictions_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_predictions_+3A_transform">transform</code></td>
<td>
<p>A function applied to unit-level adjusted predictions and confidence intervals just before the function returns results. For bayesian models, this function is applied to individual draws from the posterior distribution, before computing summaries.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_points">points</code></td>
<td>
<p>Number between 0 and 1 which controls the transparency of raw data points. 0 (default) does not display any points.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_rug">rug</code></td>
<td>
<p>TRUE displays tick marks on the axes to mark the distribution of raw data.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_gray">gray</code></td>
<td>
<p>FALSE grayscale or color plot</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_draw">draw</code></td>
<td>
<p><code>TRUE</code> returns a <code>ggplot2</code> plot. <code>FALSE</code> returns a <code>data.frame</code> of the underlying data.</p>
</td></tr>
<tr><td><code id="plot_predictions_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object or data frame (if <code>draw=FALSE</code>)
</p>


<h3>Model-Specific Arguments</h3>

<p>Some model types allow model-specific arguments to modify the nature of
marginal effects, predictions, marginal means, and contrasts. Please report
other package-specific <code>predict()</code> arguments on Github so we can add them to
the table below.
</p>
<p>https://github.com/vincentarelbundock/marginaleffects/issues</p>

<table>
<tr>
 <td style="text-align: left;">
   Package </td><td style="text-align: left;"> Class </td><td style="text-align: left;"> Argument </td><td style="text-align: left;"> Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>brms</code> </td><td style="text-align: left;"> <code>brmsfit</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>re_formula</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lme4</code> </td><td style="text-align: left;"> <code>merMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>glmmTMB</code> </td><td style="text-align: left;"> <code>glmmTMB</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>zitype</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mgcv</code> </td><td style="text-align: left;"> <code>bam</code> </td><td style="text-align: left;"> <code>exclude</code> </td><td style="text-align: left;"> <a href="mgcv.html#topic+predict.bam">mgcv::predict.bam</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>robustlmm</code> </td><td style="text-align: left;"> <code>rlmerMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Prediction types</h3>

<p>The <code>type</code> argument determines the scale of the predictions used to compute quantities of interest with functions from the <code>marginaleffects</code> package. Admissible values for <code>type</code> depend on the model object. When users specify an incorrect value for <code>type</code>, <code>marginaleffects</code> will raise an informative error with a list of valid <code>type</code> values for the specific model object. The first entry in the list in that error message is the default type.
</p>
<p>The <code>invlink(link)</code> is a special type defined by <code>marginaleffects</code>. It is available for some (but not all) models and functions. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with <code>type="invlink(link)"</code> will not always be equivalent to the average of estimates with <code>type="response"</code>.
</p>
<p>Some of the most common <code>type</code> values are:
</p>
<p>response, link, E, Ep, average, class, conditional, count, cum.prob, cumprob, density, detection, disp, ev, expected, expvalue, fitted, invlink(link), latent, latent_N, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(mpg ~ hp + wt, data = mtcars)
plot_predictions(mod, condition = "wt")

mod &lt;- lm(mpg ~ hp * wt * am, data = mtcars)
plot_predictions(mod, condition = c("hp", "wt"))

plot_predictions(mod, condition = list("hp", wt = "threenum"))

plot_predictions(mod, condition = list("hp", wt = range))

</code></pre>

<hr>
<h2 id='plot_slopes'>Plot Conditional or Marginal Slopes</h2><span id='topic+plot_slopes'></span>

<h3>Description</h3>

<p>Plot slopes on the y-axis against values of one or more predictors (x-axis, colors/shapes, and facets).
</p>
<p>The <code>by</code> argument is used to plot marginal slopes, that is, slopes made on the original data, but averaged by subgroups. This is analogous to using the <code>by</code> argument in the <code>slopes()</code> function.
</p>
<p>The <code>condition</code> argument is used to plot conditional slopes, that is, slopes computed on a user-specified grid. This is analogous to using the <code>newdata</code> argument and <code>datagrid()</code> function in a <code>slopes()</code> call. All variables whose values are not specified explicitly are treated as usual by <code>datagrid()</code>, that is, they are held at their mean or mode (or rounded mean for integers). This includes grouping variables in mixed-effects models, so analysts who fit such models may want to specify the groups of interest using the <code>condition</code> argument, or supply model-specific arguments to compute population-level estimates. See details below.
See the &quot;Plots&quot; vignette and website for tutorials and information on how to customize plots:
</p>

<ul>
<li><p> https://marginaleffects.com/vignettes/plot.html
</p>
</li>
<li><p> https://marginaleffects.com
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plot_slopes(
  model,
  variables = NULL,
  condition = NULL,
  by = NULL,
  newdata = NULL,
  type = "response",
  vcov = NULL,
  conf_level = 0.95,
  wts = NULL,
  slope = "dydx",
  rug = FALSE,
  gray = FALSE,
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_slopes_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_variables">variables</code></td>
<td>
<p>Name of the variable whose marginal effect (slope) we want to plot on the y-axis.</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_condition">condition</code></td>
<td>
<p>Conditional slopes
</p>

<ul>
<li><p> Character vector (max length 4): Names of the predictors to display.
</p>
</li>
<li><p> Named list (max length 4): List names correspond to predictors. List elements can be:
</p>

<ul>
<li><p> Numeric vector
</p>
</li>
<li><p> Function which returns a numeric vector or a set of unique categorical values
</p>
</li>
<li><p> Shortcut strings for common reference values: &quot;minmax&quot;, &quot;quartile&quot;, &quot;threenum&quot;
</p>
</li></ul>

</li>
<li><p> 1: x-axis. 2: color/shape. 3: facet (wrap if no fourth variable, otherwise cols of grid). 4: facet (rows of grid).
</p>
</li>
<li><p> Numeric variables in positions 2 and 3 are summarized by Tukey's five numbers <code>?stats::fivenum</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_slopes_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_slopes_+3A_newdata">newdata</code></td>
<td>
<p>When <code>newdata</code> is <code>NULL</code>, the grid is determined by the <code>condition</code> argument. When <code>newdata</code> is not <code>NULL</code>, the argument behaves in the same way as in the <code>slopes()</code> function.</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_slopes_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_slopes_+3A_slope">slope</code></td>
<td>
<p>string indicates the type of slope or (semi-)elasticity to compute:
</p>

<ul>
<li><p> &quot;dydx&quot;: dY/dX
</p>
</li>
<li><p> &quot;eyex&quot;: dY/dX * Y / X
</p>
</li>
<li><p> &quot;eydx&quot;: dY/dX * Y
</p>
</li>
<li><p> &quot;dyex&quot;: dY/dX / X
</p>
</li>
<li><p> Y is the predicted value of the outcome; X is the observed value of the predictor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_slopes_+3A_rug">rug</code></td>
<td>
<p>TRUE displays tick marks on the axes to mark the distribution of raw data.</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_gray">gray</code></td>
<td>
<p>FALSE grayscale or color plot</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_draw">draw</code></td>
<td>
<p><code>TRUE</code> returns a <code>ggplot2</code> plot. <code>FALSE</code> returns a <code>data.frame</code> of the underlying data.</p>
</td></tr>
<tr><td><code id="plot_slopes_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object
</p>


<h3>Model-Specific Arguments</h3>

<p>Some model types allow model-specific arguments to modify the nature of
marginal effects, predictions, marginal means, and contrasts. Please report
other package-specific <code>predict()</code> arguments on Github so we can add them to
the table below.
</p>
<p>https://github.com/vincentarelbundock/marginaleffects/issues</p>

<table>
<tr>
 <td style="text-align: left;">
   Package </td><td style="text-align: left;"> Class </td><td style="text-align: left;"> Argument </td><td style="text-align: left;"> Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>brms</code> </td><td style="text-align: left;"> <code>brmsfit</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>re_formula</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lme4</code> </td><td style="text-align: left;"> <code>merMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>glmmTMB</code> </td><td style="text-align: left;"> <code>glmmTMB</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>zitype</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mgcv</code> </td><td style="text-align: left;"> <code>bam</code> </td><td style="text-align: left;"> <code>exclude</code> </td><td style="text-align: left;"> <a href="mgcv.html#topic+predict.bam">mgcv::predict.bam</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>robustlmm</code> </td><td style="text-align: left;"> <code>rlmerMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>library(marginaleffects)
mod &lt;- lm(mpg ~ hp * drat * factor(am), data = mtcars)

plot_slopes(mod, variables = "hp", condition = "drat")

plot_slopes(mod, variables = "hp", condition = c("drat", "am"))

plot_slopes(mod, variables = "hp", condition = list("am", "drat" = 3:5))

plot_slopes(mod, variables = "am", condition = list("hp", "drat" = range))

plot_slopes(mod, variables = "am", condition = list("hp", "drat" = "threenum"))

</code></pre>

<hr>
<h2 id='posterior_draws'>Extract Posterior Draws or Bootstrap Resamples from <code>marginaleffects</code> Objects</h2><span id='topic+posterior_draws'></span>

<h3>Description</h3>

<p>Extract Posterior Draws or Bootstrap Resamples from <code>marginaleffects</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_draws(x, shape = "long")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_draws_+3A_x">x</code></td>
<td>
<p>An object produced by a <code>marginaleffects</code> package function, such as <code>predictions()</code>, <code>avg_slopes()</code>, <code>hypotheses()</code>, etc.</p>
</td></tr>
<tr><td><code id="posterior_draws_+3A_shape">shape</code></td>
<td>
<p>string indicating the shape of the output format:
</p>

<ul>
<li><p> &quot;long&quot;: long format data frame
</p>
</li>
<li><p> &quot;DxP&quot;: Matrix with draws as rows and parameters as columns
</p>
</li>
<li><p> &quot;PxD&quot;: Matrix with draws as rows and parameters as columns
</p>
</li>
<li><p> &quot;rvar&quot;: Random variable datatype (see <code>posterior</code> package documentation).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>drawid</code> and <code>draw</code> columns.
</p>

<hr>
<h2 id='posteriordraws'><code>posteriordraws()</code> is an alias to <code>posterior_draws()</code></h2><span id='topic+posteriordraws'></span>

<h3>Description</h3>

<p>This alias is kept for backward compatibility and because some users may prefer that name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriordraws(x, shape = "long")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriordraws_+3A_x">x</code></td>
<td>
<p>An object produced by a <code>marginaleffects</code> package function, such as <code>predictions()</code>, <code>avg_slopes()</code>, <code>hypotheses()</code>, etc.</p>
</td></tr>
<tr><td><code id="posteriordraws_+3A_shape">shape</code></td>
<td>
<p>string indicating the shape of the output format:
</p>

<ul>
<li><p> &quot;long&quot;: long format data frame
</p>
</li>
<li><p> &quot;DxP&quot;: Matrix with draws as rows and parameters as columns
</p>
</li>
<li><p> &quot;PxD&quot;: Matrix with draws as rows and parameters as columns
</p>
</li>
<li><p> &quot;rvar&quot;: Random variable datatype (see <code>posterior</code> package documentation).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>drawid</code> and <code>draw</code> columns.
</p>

<hr>
<h2 id='predictions'>Predictions</h2><span id='topic+predictions'></span><span id='topic+avg_predictions'></span>

<h3>Description</h3>

<p>Outcome predicted by a fitted model on a specified scale for a given combination of values of the predictor variables, such as their observed values, their means, or factor levels (a.k.a. &quot;reference grid&quot;).
</p>

<ul>
<li> <p><code>predictions()</code>: unit-level (conditional) estimates.
</p>
</li>
<li> <p><code>avg_predictions()</code>: average (marginal) estimates.
</p>
</li></ul>

<p>The <code>newdata</code> argument and the <code>datagrid()</code> function can be used to control where statistics are evaluated in the predictor space: &quot;at observed values&quot;, &quot;at the mean&quot;, &quot;at representative values&quot;, etc.
</p>
<p>See the predictions vignette and package website for worked examples and case studies:
</p>

<ul>
<li> <p><a href="https://marginaleffects.com/vignettes/predictions.html">https://marginaleffects.com/vignettes/predictions.html</a>
</p>
</li>
<li> <p><a href="https://marginaleffects.com/">https://marginaleffects.com/</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>predictions(
  model,
  newdata = NULL,
  variables = NULL,
  vcov = TRUE,
  conf_level = 0.95,
  type = NULL,
  by = FALSE,
  byfun = NULL,
  wts = NULL,
  transform = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  numderiv = "fdforward",
  ...
)

avg_predictions(
  model,
  newdata = NULL,
  variables = NULL,
  vcov = TRUE,
  conf_level = 0.95,
  type = NULL,
  by = TRUE,
  byfun = NULL,
  wts = NULL,
  transform = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  numderiv = "fdforward",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictions_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="predictions_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate predictions.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level predictions for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Predictions at the Mean. Predictions when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Predictions at the Median. Predictions when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Predictions at Marginal Means. See Details section below.
</p>
</li>
<li><p> &quot;tukey&quot;: Predictions at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Predictions on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_variables">variables</code></td>
<td>
<p>Counterfactual variables.
</p>

<ul>
<li><p> Output:
</p>

<ul>
<li> <p><code>predictions()</code>: The entire dataset is replicated once for each unique combination of <code>variables</code>, and predictions are made.
</p>
</li>
<li> <p><code>avg_predictions()</code>: The entire dataset is replicated, predictions are made, and they are marginalized by <code>variables</code> categories.
</p>
</li>
<li><p> Warning: This can be expensive in large datasets.
</p>
</li>
<li><p> Warning: Users who need &quot;conditional&quot; predictions should use the <code>newdata</code> argument instead of <code>variables</code>.
</p>
</li></ul>

</li>
<li><p> Input:
</p>

<ul>
<li> <p><code>NULL</code>: computes one prediction per row of <code>newdata</code>
</p>
</li>
<li><p> Character vector: the dataset is replicated once of every combination of unique values of the variables identified in <code>variables</code>.
</p>
</li>
<li><p> Named list: names identify the subset of variables of interest and their values. For numeric variables, the <code>variables</code> argument supports functions and string shortcuts:
</p>

<ul>
<li><p> A function which returns a numeric value
</p>
</li>
<li><p> Numeric vector: Contrast between the 2nd element and the 1st element of the <code>x</code> vector.
</p>
</li>
<li><p> &quot;iqr&quot;: Contrast across the interquartile range of the regressor.
</p>
</li>
<li><p> &quot;sd&quot;: Contrast across one standard deviation around the regressor mean.
</p>
</li>
<li><p> &quot;2sd&quot;: Contrast across two standard deviations around the regressor mean.
</p>
</li>
<li><p> &quot;minmax&quot;: Contrast between the maximum and the minimum values of the regressor.
</p>
</li>
<li><p> &quot;threenum&quot;: mean and 1 standard deviation on both sides
</p>
</li>
<li><p> &quot;fivenum&quot;: Tukey's five numbers
</p>
</li></ul>

</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="predictions_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="predictions_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_byfun">byfun</code></td>
<td>
<p>A function such as <code>mean()</code> or <code>sum()</code> used to aggregate
estimates within the subgroups defined by the <code>by</code> argument. <code>NULL</code> uses the
<code>mean()</code> function. Must accept a numeric vector and return a single numeric
value. This is sometimes used to take the sum or mean of predicted
probabilities across outcome or predictor
levels. See examples section.</p>
</td></tr>
<tr><td><code id="predictions_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_transform">transform</code></td>
<td>
<p>A function applied to unit-level adjusted predictions and confidence intervals just before the function returns results. For bayesian models, this function is applied to individual draws from the posterior distribution, before computing summaries.</p>
</td></tr>
<tr><td><code id="predictions_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="predictions_+3A_p_adjust">p_adjust</code></td>
<td>
<p>Adjust p-values for multiple comparisons: &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, or &quot;fdr&quot;. See <a href="stats.html#topic+p.adjust">stats::p.adjust</a></p>
</td></tr>
<tr><td><code id="predictions_+3A_df">df</code></td>
<td>
<p>Degrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and <code>Inf</code>. When <code>df</code> is <code>Inf</code>, the normal distribution is used. When <code>df</code> is finite, the <code>t</code> distribution is used. See <a href="insight.html#topic+get_df">insight::get_df</a> for a convenient function to extract degrees of freedom. Ex: <code>slopes(model, df = insight::get_df(model))</code></p>
</td></tr>
<tr><td><code id="predictions_+3A_numderiv">numderiv</code></td>
<td>
<p>string or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.
</p>

<ul>
<li><p> &quot;fdforward&quot;: finite difference method with forward differences
</p>
</li>
<li><p> &quot;fdcenter&quot;: finite difference method with central differences (default)
</p>
</li>
<li><p> &quot;richardson&quot;: Richardson extrapolation method
</p>
</li>
<li><p> Extra arguments can be specified by passing a list to the <code>numDeriv</code> argument, with the name of the method first and named arguments following, ex: <code>numderiv=list("fdcenter", eps = 1e-5)</code>. When an unknown argument is used, <code>marginaleffects</code> prints the list of valid arguments for each method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predictions_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per observation and several columns:
</p>

<ul>
<li> <p><code>rowid</code>: row number of the <code>newdata</code> data frame
</p>
</li>
<li> <p><code>type</code>: prediction type, as defined by the <code>type</code> argument
</p>
</li>
<li> <p><code>group</code>: (optional) value of the grouped outcome (e.g., categorical outcome models)
</p>
</li>
<li> <p><code>estimate</code>: predicted outcome
</p>
</li>
<li> <p><code>std.error</code>: standard errors computed using the delta method.
</p>
</li>
<li> <p><code>p.value</code>: p value associated to the <code>estimate</code> column. The null is determined by the <code>hypothesis</code> argument (0 by default), and p values are computed before applying the <code>transform</code> argument. For models of class <code>feglm</code>, <code>Gam</code>, <code>glm</code> and <code>negbin</code>, p values are computed on the link scale by default unless the <code>type</code> argument is specified explicitly.
</p>
</li>
<li> <p><code>s.value</code>: Shannon information transforms of p values. How many consecutive &quot;heads&quot; tosses would provide the same amount of evidence (or &quot;surprise&quot;) against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst's intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).
</p>
</li>
<li> <p><code>conf.low</code>: lower bound of the confidence interval (or equal-tailed interval for bayesian models)
</p>
</li>
<li> <p><code>conf.high</code>: upper bound of the confidence interval (or equal-tailed interval for bayesian models)
</p>
</li></ul>

<p>See <code>?print.marginaleffects</code> for printing options.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>avg_predictions()</code>: Average predictions
</p>
</li></ul>


<h3>Standard errors using the delta method</h3>

<p>Standard errors for all quantities estimated by <code>marginaleffects</code> can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to <code>1e-8</code>, or to <code>1e-4</code> times the smallest absolute model coefficient, whichever is largest.
</p>
<p><code>marginaleffects</code> can delegate numeric differentiation to the <code>numDeriv</code> package, which allows more flexibility. To do this, users can pass arguments to the <code>numDeriv::jacobian</code> function through a global option. For example:
</p>

<ul>
<li> <p><code>options(marginaleffects_numDeriv = list(method = "simple", method.args = list(eps = 1e-6)))</code>
</p>
</li>
<li> <p><code>options(marginaleffects_numDeriv = list(method = "Richardson", method.args = list(eps = 1e-5)))</code>
</p>
</li>
<li> <p><code>options(marginaleffects_numDeriv = NULL)</code>
</p>
</li></ul>

<p>See the &quot;Standard Errors and Confidence Intervals&quot; vignette on the <code>marginaleffects</code> website for more details on the computation of standard errors:
</p>
<p>https://marginaleffects.com/vignettes/uncertainty.html
</p>
<p>Note that the <code>inferences()</code> function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:
</p>
<p>https://marginaleffects.com/vignettes/bootstrap.html
</p>


<h3>Model-Specific Arguments</h3>

<p>Some model types allow model-specific arguments to modify the nature of
marginal effects, predictions, marginal means, and contrasts. Please report
other package-specific <code>predict()</code> arguments on Github so we can add them to
the table below.
</p>
<p>https://github.com/vincentarelbundock/marginaleffects/issues</p>

<table>
<tr>
 <td style="text-align: left;">
   Package </td><td style="text-align: left;"> Class </td><td style="text-align: left;"> Argument </td><td style="text-align: left;"> Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>brms</code> </td><td style="text-align: left;"> <code>brmsfit</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>re_formula</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lme4</code> </td><td style="text-align: left;"> <code>merMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>glmmTMB</code> </td><td style="text-align: left;"> <code>glmmTMB</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>zitype</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mgcv</code> </td><td style="text-align: left;"> <code>bam</code> </td><td style="text-align: left;"> <code>exclude</code> </td><td style="text-align: left;"> <a href="mgcv.html#topic+predict.bam">mgcv::predict.bam</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>robustlmm</code> </td><td style="text-align: left;"> <code>rlmerMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Bayesian posterior summaries</h3>

<p>By default, credible intervals in bayesian models are built as equal-tailed
intervals. This can be changed to a highest density interval by setting a global
option:
</p>
<p><code>options("marginaleffects_posterior_interval" = "eti")</code>
</p>
<p><code>options("marginaleffects_posterior_interval" = "hdi")</code>
</p>
<p>By default, the center of the posterior distribution in bayesian models is
identified by the median. Users can use a different summary function by setting a
global option:
</p>
<p><code>options("marginaleffects_posterior_center" = "mean")</code>
</p>
<p><code>options("marginaleffects_posterior_center" = "median")</code>
</p>
<p>When estimates are averaged using the <code>by</code> argument, the <code>tidy()</code> function, or
the <code>summary()</code> function, the posterior distribution is marginalized twice over.
First, we take the average <em>across</em> units but <em>within</em> each iteration of the
MCMC chain, according to what the user requested in <code>by</code> argument or
<code>tidy()/summary()</code> functions. Then, we identify the center of the resulting
posterior using the function supplied to the
<code>"marginaleffects_posterior_center"</code> option (the median by default).
</p>


<h3>Equivalence, Inferiority, Superiority</h3>

<p><code class="reqn">\theta</code> is an estimate, <code class="reqn">\sigma_\theta</code> its estimated standard error, and <code class="reqn">[a, b]</code> are the bounds of the interval supplied to the <code>equivalence</code> argument.
</p>
<p>Non-inferiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \leq a</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &gt; a</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - a)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Upper-tail probability
</p>
</li></ul>

<p>Non-superiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \geq b</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &lt; b</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - b)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Lower-tail probability
</p>
</li></ul>

<p>Equivalence: Two One-Sided Tests (TOST)
</p>

<ul>
<li><p> p: Maximum of the non-inferiority and non-superiority p values.
</p>
</li></ul>

<p>Thanks to Russell V. Lenth for the excellent <code>emmeans</code> package and documentation which inspired this feature.
</p>


<h3>Prediction types</h3>

<p>The <code>type</code> argument determines the scale of the predictions used to compute quantities of interest with functions from the <code>marginaleffects</code> package. Admissible values for <code>type</code> depend on the model object. When users specify an incorrect value for <code>type</code>, <code>marginaleffects</code> will raise an informative error with a list of valid <code>type</code> values for the specific model object. The first entry in the list in that error message is the default type.
</p>
<p>The <code>invlink(link)</code> is a special type defined by <code>marginaleffects</code>. It is available for some (but not all) models and functions. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with <code>type="invlink(link)"</code> will not always be equivalent to the average of estimates with <code>type="response"</code>.
</p>
<p>Some of the most common <code>type</code> values are:
</p>
<p>response, link, E, Ep, average, class, conditional, count, cum.prob, cumprob, density, detection, disp, ev, expected, expvalue, fitted, invlink(link), latent, latent_N, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob
</p>


<h3>References</h3>


<ul>
<li><p> Greenland S. 2019. &quot;Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.&quot; The American Statistician. 73(S1): 106–114.
</p>
</li>
<li><p> Cole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. &quot;Surprise!&quot; American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# Adjusted Prediction for every row of the original dataset
mod &lt;- lm(mpg ~ hp + factor(cyl), data = mtcars)
pred &lt;- predictions(mod)
head(pred)

# Adjusted Predictions at User-Specified Values of the Regressors
predictions(mod, newdata = datagrid(hp = c(100, 120), cyl = 4))

m &lt;- lm(mpg ~ hp + drat + factor(cyl) + factor(am), data = mtcars)
predictions(m, newdata = datagrid(FUN_factor = unique, FUN_numeric = median))

# Average Adjusted Predictions (AAP)
library(dplyr)
mod &lt;- lm(mpg ~ hp * am * vs, mtcars)

avg_predictions(mod)

predictions(mod, by = "am")

# Conditional Adjusted Predictions
plot_predictions(mod, condition = "hp")

# Counterfactual predictions with the `variables` argument
# the `mtcars` dataset has 32 rows

mod &lt;- lm(mpg ~ hp + am, data = mtcars)
p &lt;- predictions(mod)
head(p)
nrow(p)

# average counterfactual predictions
avg_predictions(mod, variables = "am")

# counterfactual predictions obtained by replicating the entire for different
# values of the predictors
p &lt;- predictions(mod, variables = list(hp = c(90, 110)))
nrow(p)


# hypothesis test: is the prediction in the 1st row equal to the prediction in the 2nd row
mod &lt;- lm(mpg ~ wt + drat, data = mtcars)

predictions(
    mod,
    newdata = datagrid(wt = 2:3),
    hypothesis = "b1 = b2")

# same hypothesis test using row indices
predictions(
    mod,
    newdata = datagrid(wt = 2:3),
    hypothesis = "b1 - b2 = 0")

# same hypothesis test using numeric vector of weights
predictions(
    mod,
    newdata = datagrid(wt = 2:3),
    hypothesis = c(1, -1))

# two custom contrasts using a matrix of weights
lc &lt;- matrix(c(
    1, -1,
    2, 3),
    ncol = 2)
predictions(
    mod,
    newdata = datagrid(wt = 2:3),
    hypothesis = lc)


# `by` argument
mod &lt;- lm(mpg ~ hp * am * vs, data = mtcars)
predictions(mod, by = c("am", "vs"))

library(nnet)
nom &lt;- multinom(factor(gear) ~ mpg + am * vs, data = mtcars, trace = FALSE)

# first 5 raw predictions
predictions(nom, type = "probs") |&gt; head()

# average predictions
avg_predictions(nom, type = "probs", by = "group")

by &lt;- data.frame(
    group = c("3", "4", "5"),
    by = c("3,4", "3,4", "5"))

predictions(nom, type = "probs", by = by)

# sum of predicted probabilities for combined response levels
mod &lt;- multinom(factor(cyl) ~ mpg + am, data = mtcars, trace = FALSE)
by &lt;- data.frame(
    by = c("4,6", "4,6", "8"),
    group = as.character(c(4, 6, 8)))
predictions(mod, newdata = "mean", byfun = sum, by = by)

</code></pre>

<hr>
<h2 id='print.marginaleffects'>Print <code>marginaleffects</code> objects</h2><span id='topic+print.marginaleffects'></span>

<h3>Description</h3>

<p>This function controls the text which is printed to the console when one of the core <code>marginalefffects</code> functions is called and the object is returned: <code>predictions()</code>, <code>comparisons()</code>, <code>slopes()</code>, <code>hypotheses()</code>, <code>avg_predictions()</code>, <code>avg_comparisons()</code>, <code>avg_slopes()</code>.
</p>
<p>All of those functions return standard data frames. Columns can be extracted by name, <code>predictions(model)$estimate</code>, and all the usual data manipulation functions work out-of-the-box:  <code>colnames()</code>, <code>head()</code>, <code>subset()</code>, <code>dplyr::filter()</code>, <code>dplyr::arrange()</code>, etc.
</p>
<p>Some of the data columns are not printed by default. You can disable pretty printing and print the full results as a standard data frame using the <code>style</code> argument or by applying <code>as.data.frame()</code> on the object. See examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marginaleffects'
print(
  x,
  digits = getOption("marginaleffects_print_digits", default = 3),
  p_eps = getOption("marginaleffects_print_p_eps", default = 0.001),
  topn = getOption("marginaleffects_print_topn", default = 5),
  nrows = getOption("marginaleffects_print_nrows", default = 30),
  ncols = getOption("marginaleffects_print_ncols", default = 30),
  style = getOption("marginaleffects_print_style", default = "summary"),
  type = getOption("marginaleffects_print_type", default = TRUE),
  column_names = getOption("marginaleffects_print_column_names", default = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.marginaleffects_+3A_x">x</code></td>
<td>
<p>An object produced by one of the <code>marginaleffects</code> package functions.</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_digits">digits</code></td>
<td>
<p>The number of digits to display.</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_p_eps">p_eps</code></td>
<td>
<p>p values smaller than this number are printed in &quot;&lt;0.001&quot; style.</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_topn">topn</code></td>
<td>
<p>The number of rows to be printed from the beginning and end of tables with more than <code>nrows</code> rows.</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_nrows">nrows</code></td>
<td>
<p>The number of rows which will be printed before truncation.</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_ncols">ncols</code></td>
<td>
<p>The maximum number of column names to display at the bottom of the printed output.</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_style">style</code></td>
<td>
<p>&quot;summary&quot; or &quot;data.frame&quot;</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_type">type</code></td>
<td>
<p>boolean: should the type be printed?</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_column_names">column_names</code></td>
<td>
<p>boolean: should the column names be printed?</p>
</td></tr>
<tr><td><code id="print.marginaleffects_+3A_...">...</code></td>
<td>
<p>Other arguments are currently ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(marginaleffects)
mod &lt;- lm(mpg ~ hp + am + factor(gear), data = mtcars)
p &lt;- predictions(mod, by = c("am", "gear"))
p

subset(p, am == 1)

print(p, style = "data.frame")

data.frame(p)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sanitize_model_specific.glimML'>Method to raise model-specific warnings and errors</h2><span id='topic+sanitize_model_specific.glimML'></span><span id='topic+sanitize_model_specific.betareg'></span><span id='topic+sanitize_model_specific'></span><span id='topic+sanitize_model_specific.default'></span><span id='topic+sanitize_model_specific.brmsfit'></span><span id='topic+sanitize_model_specific.bart'></span><span id='topic+sanitize_model_specific.glmmTMB'></span><span id='topic+sanitize_model_specific.inferences_simulation'></span><span id='topic+sanitize_model_specific.mblogit'></span><span id='topic+sanitize_model_specific.mlogit'></span><span id='topic+sanitize_model_specific.clm'></span><span id='topic+sanitize_model_specific.plm'></span><span id='topic+sanitize_model_specific.rqs'></span><span id='topic+sanitize_model_specific.svyolr'></span><span id='topic+sanitize_model_specific.svyglm'></span>

<h3>Description</h3>

<p>Method to raise model-specific warnings and errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glimML'
sanitize_model_specific(model, ...)

## S3 method for class 'betareg'
sanitize_model_specific(model, ...)

sanitize_model_specific(model, ...)

## Default S3 method:
sanitize_model_specific(
  model,
  vcov = NULL,
  calling_function = "marginaleffects",
  ...
)

## S3 method for class 'brmsfit'
sanitize_model_specific(model, ...)

## S3 method for class 'bart'
sanitize_model_specific(model, ...)

## S3 method for class 'glmmTMB'
sanitize_model_specific(
  model,
  vcov = NULL,
  calling_function = "marginaleffects",
  ...
)

## S3 method for class 'inferences_simulation'
sanitize_model_specific(model, vcov = FALSE, ...)

## S3 method for class 'mblogit'
sanitize_model_specific(model, calling_function = "marginaleffects", ...)

## S3 method for class 'mlogit'
sanitize_model_specific(model, newdata, ...)

## S3 method for class 'clm'
sanitize_model_specific(model, ...)

## S3 method for class 'plm'
sanitize_model_specific(model, ...)

## S3 method for class 'plm'
sanitize_model_specific(model, ...)

## S3 method for class 'rqs'
sanitize_model_specific(model, ...)

## S3 method for class 'svyolr'
sanitize_model_specific(model, wts = NULL, ...)

## S3 method for class 'svyglm'
sanitize_model_specific(model, wts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_model_specific.glimML_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="sanitize_model_specific.glimML_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
<tr><td><code id="sanitize_model_specific.glimML_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="sanitize_model_specific.glimML_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code><a href="#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Marginal Effects at the Mean. Slopes when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Marginal Effects at the Median. Slopes when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Marginal Effects at Marginal Means. See Details section below.
</p>
</li>
<li><p> &quot;tukey&quot;: Marginal Effects at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Marginal Effects on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="sanitize_model_specific.glimML_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A warning, an error, or nothing
</p>

<hr>
<h2 id='set_coef'>Internal function to set coefficients</h2><span id='topic+set_coef'></span><span id='topic+set_coef.default'></span><span id='topic+set_coef.polr'></span><span id='topic+set_coef.glmmPQL'></span><span id='topic+set_coef.hetprob'></span><span id='topic+set_coef.ivpml'></span><span id='topic+set_coef.afex_aov'></span><span id='topic+set_coef.glimML'></span><span id='topic+set_coef.betareg'></span><span id='topic+set_coef.multinom'></span><span id='topic+set_coef.crch'></span><span id='topic+set_coef.hxlr'></span><span id='topic+set_coef.data.frame'></span><span id='topic+set_coef.gamlss'></span><span id='topic+set_coef.glmmTMB'></span><span id='topic+set_coef.glmx'></span><span id='topic+set_coef.merMod'></span><span id='topic+set_coef.lmerModLmerTest'></span><span id='topic+set_coef.lmerMod'></span><span id='topic+set_coef.mlm'></span><span id='topic+set_coef.lme'></span><span id='topic+set_coef.hurdle'></span><span id='topic+set_coef.zeroinfl'></span><span id='topic+set_coef.rlmerMod'></span><span id='topic+set_coef.selection'></span><span id='topic+set_coef.scam'></span><span id='topic+set_coef.glm'></span><span id='topic+set_coef.lm'></span><span id='topic+set_coef.nls'></span><span id='topic+set_coef.svyolr'></span><span id='topic+set_coef.model_fit'></span><span id='topic+set_coef.workflow'></span>

<h3>Description</h3>

<p>Set the coefficients in a model to different values and return the modified object (internal function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_coef(model, coefs, ...)

## Default S3 method:
set_coef(model, coefs, ...)

## S3 method for class 'polr'
set_coef(model, coefs, ...)

## S3 method for class 'glmmPQL'
set_coef(model, coefs, ...)

## S3 method for class 'hetprob'
set_coef(model, coefs, ...)

## S3 method for class 'ivpml'
set_coef(model, coefs, ...)

## S3 method for class 'afex_aov'
set_coef(model, coefs, ...)

## S3 method for class 'glimML'
set_coef(model, coefs, ...)

## S3 method for class 'betareg'
set_coef(model, coefs, ...)

## S3 method for class 'multinom'
set_coef(model, coefs, ...)

## S3 method for class 'crch'
set_coef(model, coefs, ...)

## S3 method for class 'hxlr'
set_coef(model, coefs, ...)

## S3 method for class 'data.frame'
set_coef(model, coefs, ...)

## S3 method for class 'gamlss'
set_coef(model, coefs, ...)

## S3 method for class 'glmmTMB'
set_coef(model, coefs, ...)

## S3 method for class 'glmx'
set_coef(model, coefs, ...)

## S3 method for class 'merMod'
set_coef(model, coefs, ...)

## S3 method for class 'lmerModLmerTest'
set_coef(model, coefs, ...)

## S3 method for class 'lmerMod'
set_coef(model, coefs, ...)

## S3 method for class 'mlm'
set_coef(model, coefs, ...)

## S3 method for class 'lme'
set_coef(model, coefs, ...)

## S3 method for class 'hurdle'
set_coef(model, coefs, ...)

## S3 method for class 'zeroinfl'
set_coef(model, coefs, ...)

## S3 method for class 'rlmerMod'
set_coef(model, coefs, ...)

## S3 method for class 'selection'
set_coef(model, coefs, ...)

## S3 method for class 'scam'
set_coef(model, coefs, ...)

## S3 method for class 'glm'
set_coef(model, coefs, ...)

## S3 method for class 'lm'
set_coef(model, coefs, ...)

## S3 method for class 'nls'
set_coef(model, coefs, ...)

## S3 method for class 'svyolr'
set_coef(model, coefs, ...)

## S3 method for class 'model_fit'
set_coef(model, coefs, ...)

## S3 method for class 'workflow'
set_coef(model, coefs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_coef_+3A_model">model</code></td>
<td>
<p>object to modify</p>
</td></tr>
<tr><td><code id="set_coef_+3A_coefs">coefs</code></td>
<td>
<p>vector of coefficients to insert in the model object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To compute the variance of marginal effects we need to take the
Jacobian with
</p>


<h3>Value</h3>

<p>Model object of the same class as the <code>model</code> argument, but with
different stored coefficients.
</p>

<hr>
<h2 id='slopes'>Slopes (aka Partial derivatives, Marginal Effects, or Trends)</h2><span id='topic+slopes'></span><span id='topic+avg_slopes'></span>

<h3>Description</h3>

<p>Partial derivative of the regression equation with respect to a regressor of interest.
</p>

<ul>
<li> <p><code>slopes()</code>: unit-level (conditional) estimates.
</p>
</li>
<li> <p><code>avg_slopes()</code>: average (marginal) estimates.
</p>
</li></ul>

<p>The <code>newdata</code> argument and the <code>datagrid()</code> function can be used to control where statistics are evaluated in the predictor space: &quot;at observed values&quot;, &quot;at the mean&quot;, &quot;at representative values&quot;, etc.
</p>
<p>See the slopes vignette and package website for worked examples and case studies:
</p>

<ul>
<li> <p><a href="https://marginaleffects.com/vignettes/slopes.html">https://marginaleffects.com/vignettes/slopes.html</a>
</p>
</li>
<li> <p><a href="https://marginaleffects.com/">https://marginaleffects.com/</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>slopes(
  model,
  newdata = NULL,
  variables = NULL,
  type = NULL,
  by = FALSE,
  vcov = TRUE,
  conf_level = 0.95,
  slope = "dydx",
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  eps = NULL,
  numderiv = "fdforward",
  ...
)

avg_slopes(
  model,
  newdata = NULL,
  variables = NULL,
  type = NULL,
  by = TRUE,
  vcov = TRUE,
  conf_level = 0.95,
  slope = "dydx",
  wts = NULL,
  hypothesis = NULL,
  equivalence = NULL,
  p_adjust = NULL,
  df = Inf,
  eps = NULL,
  numderiv = "fdforward",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slopes_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="slopes_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code><a href="#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Marginal Effects at the Mean. Slopes when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Marginal Effects at the Median. Slopes when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Marginal Effects at Marginal Means. See Details section below.
</p>
</li>
<li><p> &quot;tukey&quot;: Marginal Effects at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Marginal Effects on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_variables">variables</code></td>
<td>
<p>Focal variables
</p>

<ul>
<li> <p><code>NULL</code>: compute slopes or comparisons for all the variables in the model object (can be slow).
</p>
</li>
<li><p> Character vector: subset of variables (usually faster).
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="slopes_+3A_by">by</code></td>
<td>
<p>Aggregate unit-level estimates (aka, marginalize, average over). Valid inputs:
</p>

<ul>
<li> <p><code>FALSE</code>: return the original unit-level estimates.
</p>
</li>
<li> <p><code>TRUE</code>: aggregate estimates for each term.
</p>
</li>
<li><p> Character vector of column names in <code>newdata</code> or in the data frame produced by calling the function without the <code>by</code> argument.
</p>
</li>
<li><p> Data frame with a <code>by</code> column of group labels, and merging columns shared by <code>newdata</code> or the data frame produced by calling the same function without the <code>by</code> argument.
</p>
</li>
<li><p> See examples below.
</p>
</li>
<li><p> For more complex aggregations, you can use the <code>FUN</code> argument of the <code>hypotheses()</code> function. See that function's documentation and the Hypothesis Test vignettes on the <code>marginaleffects</code> website.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_conf_level">conf_level</code></td>
<td>
<p>numeric value between 0 and 1. Confidence level to use to build a confidence interval.</p>
</td></tr>
<tr><td><code id="slopes_+3A_slope">slope</code></td>
<td>
<p>string indicates the type of slope or (semi-)elasticity to compute:
</p>

<ul>
<li><p> &quot;dydx&quot;: dY/dX
</p>
</li>
<li><p> &quot;eyex&quot;: dY/dX * Y / X
</p>
</li>
<li><p> &quot;eydx&quot;: dY/dX * Y
</p>
</li>
<li><p> &quot;dyex&quot;: dY/dX / X
</p>
</li>
<li><p> Y is the predicted value of the outcome; X is the observed value of the predictor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_wts">wts</code></td>
<td>
<p>string or numeric: weights to use when computing average contrasts or slopes. These weights only affect the averaging in <code style="white-space: pre;">&#8288;avg_*()&#8288;</code> or with the <code>by</code> argument, and not the unit-level estimates themselves. Internally, estimates and weights are passed to the <code>weighted.mean()</code> function.
</p>

<ul>
<li><p> string: column name of the weights variable in <code>newdata</code>. When supplying a column name to <code>wts</code>, it is recommended to supply the original data (including the weights variable) explicitly to <code>newdata</code>.
</p>
</li>
<li><p> numeric: vector of length equal to the number of rows in the original data or in <code>newdata</code> (if supplied).
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_hypothesis">hypothesis</code></td>
<td>
<p>specify a hypothesis test or custom contrast using a numeric value, vector, or matrix, a string, or a string formula.
</p>

<ul>
<li><p> Numeric:
</p>

<ul>
<li><p> Single value: the null hypothesis used in the computation of Z and p (before applying <code>transform</code>).
</p>
</li>
<li><p> Vector: Weights to compute a linear combination of (custom contrast between) estimates. Length equal to the number of rows generated by the same function call, but without the <code>hypothesis</code> argument.
</p>
</li>
<li><p> Matrix: Each column is a vector of weights, as describe above, used to compute a distinct linear combination of (contrast between) estimates. The column names of the matrix are used as labels in the output.
</p>
</li></ul>

</li>
<li><p> String formula to specify linear or non-linear hypothesis tests. If the <code>term</code> column uniquely identifies rows, terms can be used in the formula. Otherwise, use <code>b1</code>, <code>b2</code>, etc. to identify the position of each parameter. The <code style="white-space: pre;">&#8288;b*&#8288;</code> wildcard can be used to test hypotheses on all estimates. Examples:
</p>

<ul>
<li> <p><code>hp = drat</code>
</p>
</li>
<li> <p><code>hp + drat = 12</code>
</p>
</li>
<li> <p><code>b1 + b2 + b3 = 0</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;b* / b1 = 1&#8288;</code>
</p>
</li></ul>

</li>
<li><p> String:
</p>

<ul>
<li><p> &quot;pairwise&quot;: pairwise differences between estimates in each row.
</p>
</li>
<li><p> &quot;reference&quot;: differences between the estimates in each row and the estimate in the first row.
</p>
</li>
<li><p> &quot;sequential&quot;: difference between an estimate and the estimate in the next row.
</p>
</li>
<li><p> &quot;revpairwise&quot;, &quot;revreference&quot;, &quot;revsequential&quot;: inverse of the corresponding hypotheses, as described above.
</p>
</li></ul>

</li>
<li><p> See the Examples section below and the vignette: https://marginaleffects.com/vignettes/hypothesis.html
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_equivalence">equivalence</code></td>
<td>
<p>Numeric vector of length 2: bounds used for the two-one-sided test (TOST) of equivalence, and for the non-inferiority and non-superiority tests. See Details section below.</p>
</td></tr>
<tr><td><code id="slopes_+3A_p_adjust">p_adjust</code></td>
<td>
<p>Adjust p-values for multiple comparisons: &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, or &quot;fdr&quot;. See <a href="stats.html#topic+p.adjust">stats::p.adjust</a></p>
</td></tr>
<tr><td><code id="slopes_+3A_df">df</code></td>
<td>
<p>Degrees of freedom used to compute p values and confidence intervals. A single numeric value between 1 and <code>Inf</code>. When <code>df</code> is <code>Inf</code>, the normal distribution is used. When <code>df</code> is finite, the <code>t</code> distribution is used. See <a href="insight.html#topic+get_df">insight::get_df</a> for a convenient function to extract degrees of freedom. Ex: <code>slopes(model, df = insight::get_df(model))</code></p>
</td></tr>
<tr><td><code id="slopes_+3A_eps">eps</code></td>
<td>
<p>NULL or numeric value which determines the step size to use when
calculating numerical derivatives: (f(x+eps)-f(x))/eps. When <code>eps</code> is
<code>NULL</code>, the step size is 0.0001 multiplied by the difference between
the maximum and minimum values of the variable with respect to which we
are taking the derivative. Changing <code>eps</code> may be necessary to avoid
numerical problems in certain models.</p>
</td></tr>
<tr><td><code id="slopes_+3A_numderiv">numderiv</code></td>
<td>
<p>string or list of strings indicating the method to use to for the numeric differentiation used in to compute delta method standard errors.
</p>

<ul>
<li><p> &quot;fdforward&quot;: finite difference method with forward differences
</p>
</li>
<li><p> &quot;fdcenter&quot;: finite difference method with central differences (default)
</p>
</li>
<li><p> &quot;richardson&quot;: Richardson extrapolation method
</p>
</li>
<li><p> Extra arguments can be specified by passing a list to the <code>numDeriv</code> argument, with the name of the method first and named arguments following, ex: <code>numderiv=list("fdcenter", eps = 1e-5)</code>. When an unknown argument is used, <code>marginaleffects</code> prints the list of valid arguments for each method.
</p>
</li></ul>
</td></tr>
<tr><td><code id="slopes_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &quot;slope&quot; or &quot;marginal effect&quot; is the partial derivative of the regression equation
with respect to a variable in the model. This function uses automatic
differentiation to compute slopes for a vast array of models,
including non-linear models with transformations (e.g., polynomials).
Uncertainty estimates are computed using the delta method.
</p>
<p>Numerical derivatives for the <code>slopes</code> function are calculated
using a simple epsilon difference approach: <code class="reqn">\partial Y / \partial X = (f(X + \varepsilon/2) - f(X-\varepsilon/2)) / \varepsilon</code>,
where f is the <code>predict()</code> method associated with the model class, and
<code class="reqn">\varepsilon</code> is determined by the <code>eps</code> argument.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per observation (per term/group) and several columns:
</p>

<ul>
<li> <p><code>rowid</code>: row number of the <code>newdata</code> data frame
</p>
</li>
<li> <p><code>type</code>: prediction type, as defined by the <code>type</code> argument
</p>
</li>
<li> <p><code>group</code>: (optional) value of the grouped outcome (e.g., categorical outcome models)
</p>
</li>
<li> <p><code>term</code>: the variable whose marginal effect is computed
</p>
</li>
<li> <p><code>dydx</code>: slope of the outcome with respect to the term, for a given combination of predictor values
</p>
</li>
<li> <p><code>std.error</code>: standard errors computed by via the delta method.
</p>
</li>
<li> <p><code>p.value</code>: p value associated to the <code>estimate</code> column. The null is determined by the <code>hypothesis</code> argument (0 by default), and p values are computed before applying the <code>transform</code> argument. For models of class <code>feglm</code>, <code>Gam</code>, <code>glm</code> and <code>negbin</code>, p values are computed on the link scale by default unless the <code>type</code> argument is specified explicitly.
</p>
</li>
<li> <p><code>s.value</code>: Shannon information transforms of p values. How many consecutive &quot;heads&quot; tosses would provide the same amount of evidence (or &quot;surprise&quot;) against the null hypothesis that the coin is fair? The purpose of S is to calibrate the analyst's intuition about the strength of evidence encoded in p against a well-known physical phenomenon. See Greenland (2019) and Cole et al. (2020).
</p>
</li>
<li> <p><code>conf.low</code>: lower bound of the confidence interval (or equal-tailed interval for bayesian models)
</p>
</li>
<li> <p><code>conf.high</code>: upper bound of the confidence interval (or equal-tailed interval for bayesian models)
</p>
</li></ul>

<p>See <code>?print.marginaleffects</code> for printing options.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>avg_slopes()</code>: Average slopes
</p>
</li></ul>


<h3>Standard errors using the delta method</h3>

<p>Standard errors for all quantities estimated by <code>marginaleffects</code> can be obtained via the delta method. This requires differentiating a function with respect to the coefficients in the model using a finite difference approach. In some models, the delta method standard errors can be sensitive to various aspects of the numeric differentiation strategy, including the step size. By default, the step size is set to <code>1e-8</code>, or to <code>1e-4</code> times the smallest absolute model coefficient, whichever is largest.
</p>
<p><code>marginaleffects</code> can delegate numeric differentiation to the <code>numDeriv</code> package, which allows more flexibility. To do this, users can pass arguments to the <code>numDeriv::jacobian</code> function through a global option. For example:
</p>

<ul>
<li> <p><code>options(marginaleffects_numDeriv = list(method = "simple", method.args = list(eps = 1e-6)))</code>
</p>
</li>
<li> <p><code>options(marginaleffects_numDeriv = list(method = "Richardson", method.args = list(eps = 1e-5)))</code>
</p>
</li>
<li> <p><code>options(marginaleffects_numDeriv = NULL)</code>
</p>
</li></ul>

<p>See the &quot;Standard Errors and Confidence Intervals&quot; vignette on the <code>marginaleffects</code> website for more details on the computation of standard errors:
</p>
<p>https://marginaleffects.com/vignettes/uncertainty.html
</p>
<p>Note that the <code>inferences()</code> function can be used to compute uncertainty estimates using a bootstrap or simulation-based inference. See the vignette:
</p>
<p>https://marginaleffects.com/vignettes/bootstrap.html
</p>


<h3>Model-Specific Arguments</h3>

<p>Some model types allow model-specific arguments to modify the nature of
marginal effects, predictions, marginal means, and contrasts. Please report
other package-specific <code>predict()</code> arguments on Github so we can add them to
the table below.
</p>
<p>https://github.com/vincentarelbundock/marginaleffects/issues</p>

<table>
<tr>
 <td style="text-align: left;">
   Package </td><td style="text-align: left;"> Class </td><td style="text-align: left;"> Argument </td><td style="text-align: left;"> Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>brms</code> </td><td style="text-align: left;"> <code>brmsfit</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>re_formula</code> </td><td style="text-align: left;"> <a href="brms.html#topic+posterior_predict.brmsfit">brms::posterior_predict</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lme4</code> </td><td style="text-align: left;"> <code>merMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="lme4.html#topic+predict.merMod">lme4::predict.merMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>glmmTMB</code> </td><td style="text-align: left;"> <code>glmmTMB</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>zitype</code> </td><td style="text-align: left;"> <a href="glmmTMB.html#topic+predict.glmmTMB">glmmTMB::predict.glmmTMB</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>mgcv</code> </td><td style="text-align: left;"> <code>bam</code> </td><td style="text-align: left;"> <code>exclude</code> </td><td style="text-align: left;"> <a href="mgcv.html#topic+predict.bam">mgcv::predict.bam</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>robustlmm</code> </td><td style="text-align: left;"> <code>rlmerMod</code> </td><td style="text-align: left;"> <code>re.form</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>allow.new.levels</code> </td><td style="text-align: left;"> <a href="robustlmm.html#topic+rlmerMod-class">robustlmm::predict.rlmerMod</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>MCMCglmm</code> </td><td style="text-align: left;"> <code>ndraws</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Bayesian posterior summaries</h3>

<p>By default, credible intervals in bayesian models are built as equal-tailed
intervals. This can be changed to a highest density interval by setting a global
option:
</p>
<p><code>options("marginaleffects_posterior_interval" = "eti")</code>
</p>
<p><code>options("marginaleffects_posterior_interval" = "hdi")</code>
</p>
<p>By default, the center of the posterior distribution in bayesian models is
identified by the median. Users can use a different summary function by setting a
global option:
</p>
<p><code>options("marginaleffects_posterior_center" = "mean")</code>
</p>
<p><code>options("marginaleffects_posterior_center" = "median")</code>
</p>
<p>When estimates are averaged using the <code>by</code> argument, the <code>tidy()</code> function, or
the <code>summary()</code> function, the posterior distribution is marginalized twice over.
First, we take the average <em>across</em> units but <em>within</em> each iteration of the
MCMC chain, according to what the user requested in <code>by</code> argument or
<code>tidy()/summary()</code> functions. Then, we identify the center of the resulting
posterior using the function supplied to the
<code>"marginaleffects_posterior_center"</code> option (the median by default).
</p>


<h3>Equivalence, Inferiority, Superiority</h3>

<p><code class="reqn">\theta</code> is an estimate, <code class="reqn">\sigma_\theta</code> its estimated standard error, and <code class="reqn">[a, b]</code> are the bounds of the interval supplied to the <code>equivalence</code> argument.
</p>
<p>Non-inferiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \leq a</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &gt; a</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - a)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Upper-tail probability
</p>
</li></ul>

<p>Non-superiority:
</p>

<ul>
<li> <p><code class="reqn">H_0</code>: <code class="reqn">\theta \geq b</code>
</p>
</li>
<li> <p><code class="reqn">H_1</code>: <code class="reqn">\theta &lt; b</code>
</p>
</li>
<li> <p><code class="reqn">t=(\theta - b)/\sigma_\theta</code>
</p>
</li>
<li><p> p: Lower-tail probability
</p>
</li></ul>

<p>Equivalence: Two One-Sided Tests (TOST)
</p>

<ul>
<li><p> p: Maximum of the non-inferiority and non-superiority p values.
</p>
</li></ul>

<p>Thanks to Russell V. Lenth for the excellent <code>emmeans</code> package and documentation which inspired this feature.
</p>


<h3>Prediction types</h3>

<p>The <code>type</code> argument determines the scale of the predictions used to compute quantities of interest with functions from the <code>marginaleffects</code> package. Admissible values for <code>type</code> depend on the model object. When users specify an incorrect value for <code>type</code>, <code>marginaleffects</code> will raise an informative error with a list of valid <code>type</code> values for the specific model object. The first entry in the list in that error message is the default type.
</p>
<p>The <code>invlink(link)</code> is a special type defined by <code>marginaleffects</code>. It is available for some (but not all) models and functions. With this link type, we first compute predictions on the link scale, then we use the inverse link function to backtransform the predictions to the response scale. This is useful for models with non-linear link functions as it can ensure that confidence intervals stay within desirable bounds, ex: 0 to 1 for a logit model. Note that an average of estimates with <code>type="invlink(link)"</code> will not always be equivalent to the average of estimates with <code>type="response"</code>.
</p>
<p>Some of the most common <code>type</code> values are:
</p>
<p>response, link, E, Ep, average, class, conditional, count, cum.prob, cumprob, density, detection, disp, ev, expected, expvalue, fitted, invlink(link), latent, latent_N, linear.predictor, linpred, location, lp, mean, numeric, p, ppd, pr, precision, prediction, prob, probability, probs, quantile, risk, scale, survival, unconditional, utility, variance, xb, zero, zlink, zprob
</p>


<h3>References</h3>


<ul>
<li><p> Greenland S. 2019. &quot;Valid P-Values Behave Exactly as They Should: Some Misleading Criticisms of P-Values and Their Resolution With S-Values.&quot; The American Statistician. 73(S1): 106–114.
</p>
</li>
<li><p> Cole, Stephen R, Jessie K Edwards, and Sander Greenland. 2020. &quot;Surprise!&quot; American Journal of Epidemiology 190 (2): 191–93. https://doi.org/10.1093/aje/kwaa136
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# Unit-level (conditional) Marginal Effects
mod &lt;- glm(am ~ hp * wt, data = mtcars, family = binomial)
mfx &lt;- slopes(mod)
head(mfx)

# Average Marginal Effect (AME)
avg_slopes(mod, by = TRUE)


# Marginal Effect at the Mean (MEM)
slopes(mod, newdata = datagrid())

# Marginal Effect at User-Specified Values
# Variables not explicitly included in `datagrid()` are held at their means
slopes(mod, newdata = datagrid(hp = c(100, 110)))

# Group-Average Marginal Effects (G-AME)
# Calculate marginal effects for each observation, and then take the average
# marginal effect within each subset of observations with different observed
# values for the `cyl` variable:
mod2 &lt;- lm(mpg ~ hp * cyl, data = mtcars)
avg_slopes(mod2, variables = "hp", by = "cyl")

# Marginal Effects at User-Specified Values (counterfactual)
# Variables not explicitly included in `datagrid()` are held at their
# original values, and the whole dataset is duplicated once for each
# combination of the values in `datagrid()`
mfx &lt;- slopes(mod,
              newdata = datagrid(hp = c(100, 110),
              grid_type = "counterfactual"))
head(mfx)

# Heteroskedasticity robust standard errors
mfx &lt;- slopes(mod, vcov = sandwich::vcovHC(mod))
head(mfx)

# hypothesis test: is the `hp` marginal effect at the mean equal to the `drat` marginal effect
mod &lt;- lm(mpg ~ wt + drat, data = mtcars)

slopes(
    mod,
    newdata = "mean",
    hypothesis = "wt = drat")

# same hypothesis test using row indices
slopes(
    mod,
    newdata = "mean",
    hypothesis = "b1 - b2 = 0")

# same hypothesis test using numeric vector of weights
slopes(
    mod,
    newdata = "mean",
    hypothesis = c(1, -1))

# two custom contrasts using a matrix of weights
lc &lt;- matrix(c(
    1, -1,
    2, 3),
    ncol = 2)
colnames(lc) &lt;- c("Contrast A", "Contrast B")
slopes(
    mod,
    newdata = "mean",
    hypothesis = lc)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
