<!DOCTYPE html><html lang="en"><head><title>Help for package PHSMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PHSMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bernoulli+20distribution'><p>Bernoulli distribution</p></a></li>
<li><a href='#decodeHSMM'><p>State decoding</p></a></li>
<li><a href='#muskox'><p>Muskox movement data</p></a></li>
<li><a href='#n2wHSMM'><p>Parameter transformation from natural to working parameters</p></a></li>
<li><a href='#nll_Rcpp'><p>Negative log-likelihood evaluation</p></a></li>
<li><a href='#npllHSMM'><p>negative penalised HSMM log-likelihood function</p></a></li>
<li><a href='#plotDw'><p>Plot of the estimated HSMM dwell-time distributions.</p></a></li>
<li><a href='#pmleHSMM'><p>HSMM penalised maximum likelihood estimation</p></a></li>
<li><a href='#pseudoResHSMM'><p>HSMM pseudo-residuals</p></a></li>
<li><a href='#tpmHMM'><p>Tranistion probability matrix of the HMM representation</p></a></li>
<li><a href='#w2nHSMM'><p>Parameter transformation from working to natural parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalised Maximum Likelihood Estimation for Hidden Semi-Markov
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Jennifer Pohle</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jennifer Pohle &lt;jennifer.pohle@uni-bielefeld.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for penalised maximum likelihood estimation of hidden semi-Markov models (HSMMs) with flexible state dwell-time distributions. These include functions for model fitting, model checking and state-decoding. The package considers HSMMs for univariate time series with state-dependent gamma, normal, Poisson or Bernoulli distributions. For details, see Pohle, J., Adam, T. and Beumer, L.T. (2021): Flexible estimation of the state dwell-time distribution in hidden semi-Markov models. &lt;<a href="https://doi.org/10.48550/arXiv.2101.09197">doi:10.48550/arXiv.2101.09197</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-04 15:51:01 UTC; jenni</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-09 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bernoulli+20distribution'>Bernoulli distribution</h2><span id='topic+dbern'></span><span id='topic+pbern'></span>

<h3>Description</h3>

<p>Probability mass function and cumulative distribution function of the Bernoulli distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbern(y, prob)
pbern(y, prob)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bernoulli+2B20distribution_+3A_y">y</code></td>
<td>
<p>a vector of zeros and ones.</p>
</td></tr>
<tr><td><code id="Bernoulli+2B20distribution_+3A_prob">prob</code></td>
<td>
<p>probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code relies on the functions <code><a href="stats.html#topic+dbinom">dbinom</a></code> and <code><a href="stats.html#topic+pbinom">pbinom</a></code> with <code>size=1</code> and <code>log=FALSE</code>.
</p>


<h3>Value</h3>

<p><code>dbern</code> returns the probability mass function, <code>pbern</code> returns the cumulative distribution function.
</p>


<h3>References</h3>

<p>See the documentation for <code><a href="stats.html#topic+dbinom">dbinom</a></code> and <code><a href="stats.html#topic+pbinom">pbinom</a></code> for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbern(c(0,1),0.4)
pbern(c(0,1),0.4)
</code></pre>

<hr>
<h2 id='decodeHSMM'>State decoding</h2><span id='topic+decodeHSMM'></span>

<h3>Description</h3>

<p>State decoding for the HSMM estimated using <code><a href="#topic+pmleHSMM">pmleHSMM</a></code>. Decoding is based on the Viterbi algorithm and the corresponding HMM model representation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeHSMM(y, mod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decodeHSMM_+3A_y">y</code></td>
<td>
<p>vector containing the observed time series.</p>
</td></tr>
<tr><td><code id="decodeHSMM_+3A_mod">mod</code></td>
<td>
<p>model object as returned by <code>pmleHSMM</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the decoded states.
</p>


<h3>References</h3>

<p>For more details about the Viterbi algorithm, see for example:
</p>
<p>Zucchini, W., MacDonald, I.L. and Langrock, R. (2016): <em>Hidden Markov models for time series:
An introduction using R</em>. 2nd edition. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# running this example might take a few minutes
#
# 1.) 2-state gamma-HSMM for hourly muskox step length
# with an unstructured start of length of 10
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
mu0&lt;-c(5,150)
sigma0&lt;-c(3,180)
#
# fit 2-state gamma-HSMM with lambda=c(100,100)
# and difference order 3
# estimation might take a few minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=2,p_list=p_list0,mu=mu0,
                sigma=sigma0,lambda=c(100,100),order_diff=3,
                y_dist='gamma')
#
# state decoding
s_HSMM&lt;-decodeHSMM(muskox$step,mod=PHSMM)
# plot sequence of the decoded time series
plot(muskox$step[1:1000],type='h',xlab='time (h)',ylab='step (m)',
  main='',col=s_HSMM)
legend('topright',c('state 1','state 2'),lwd=2,col=1:2)




# running this example might take a few minutes
#
# 2.) 3-state gamma-HSMM for hourly muskox step length
# with an unstructured start of length of 10
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[3]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
omega0&lt;-matrix(0.5,3,3)
diag(omega0)&lt;-0
mu0&lt;-c(5,100,350)
sigma0&lt;-c(3,90,300)
#
# fit 3-state gamma-HSMM with lambda=c(1000,1000,1000)
# and difference order 3
# estimation might take some minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=3,p_list=p_list0,mu=mu0,
                sigma=sigma0,omega=omega0,
                lambda=c(1000,1000,1000),
                order_diff=3,y_dist='gamma')
#
# state decoding
s_HSMM&lt;-decodeHSMM(muskox$step,mod=PHSMM)
# plot sequence of the decoded time series
plot(muskox$step[1:1000],type='h',xlab='time (h)',ylab='step (m)',
  main='',col=s_HSMM)
legend('topright',c('state 1','state 2', 'state 3'),lwd=2,col=1:3)

</code></pre>

<hr>
<h2 id='muskox'>Muskox movement data</h2><span id='topic+muskox'></span>

<h3>Description</h3>

<p>Example data based on the movement of a muskox tracked in northeast Greenland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muskox
</code></pre>


<h3>Format</h3>

<p>A data frame with 6825 GPS-based observations and 5 columns:
</p>

<ul>
<li> <p><code>date</code>: date
</p>
</li>
<li> <p><code>tday</code>: time of day
</p>
</li>
<li> <p><code>x</code>: UTM easting coordinate
</p>
</li>
<li> <p><code>y</code>: UTM northing coordinate
</p>
</li>
<li> <p><code>step</code>: hourly step length calculated based on the coordinates of time t and t+1</p>
</li></ul>



<h3>Source</h3>

<p>Schmidt, N.M. (2020). Data for <em>&quot;An application of upscaled optimal foraging theory using hidden Markov modelling: year-round behavioural variation in a large arctic herbivore&quot;</em> [Data set]. Zenodo. http://doi.org/10.5281/zenodo.3768080.
</p>


<h3>References</h3>

<p>The data set is based on a subset of the data described and analysed in:
</p>
<p>Beumer, L.T., Pohle, J., Schmidt, N.M, Chimienti, M., Desforges, J.-P., Hansen, L.H., Langrock, R., Pedersen, S.H., Stelvig, M. and van Beest, F.M. (2020). An application of upscaled optimal foraging theory using hidden Markov modelling: year-round behavioural variation in a large arctic herbivore&quot;. <em>Movement Ecology</em>, <strong>8</strong>, https://doi.org/10.1186/s40462-020-00213-x.
</p>

<hr>
<h2 id='n2wHSMM'>Parameter transformation from natural to working parameters</h2><span id='topic+n2wHSMM'></span>

<h3>Description</h3>

<p>Parameter transformation from the natural (constraint) HSMM parameters into unconstraint working parameters which are used in the numerical maximum likelihood estimation. Not intended to be run by the user (internal function, called by the function <code><a href="#topic+pmleHSMM">pmleHSMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2wHSMM(N, p_list, mu, sigma=NULL, omega=NULL, delta=NULL, 
      y_dist=c("norm","gamma","pois","bern"), stationary=TRUE, p_ref=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n2wHSMM_+3A_n">N</code></td>
<td>
<p>number of states of the HSMM, integer greater than 1.</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_p_list">p_list</code></td>
<td>
<p>list containing the parameters of the states' dwell-time distributions. The list consists of <code>N</code> probability vectors, i.e. one vector for each state. Each probability vector contains the state dwell-time probabilities for the unstructured start and, as last element, the probability mass captured in the geometric tail. Thus, each vector must sum to one and automatically determines the length of the unstructured start of the according state dwell-time distribution.</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_mu">mu</code></td>
<td>
<p>vector of length <code>N</code> containing the state-dependent mean values if gamma, normal or Poisson distributions are chosen and the state-dependent probabilities if the Bernoulli distribution is chosen. The values must be sorted in an ascending order.</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>N</code> containing the state-dependent standard deviations if gamma or normal distributions are chosen. <code>NULL</code> (default) otherwise.</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_omega">omega</code></td>
<td>
<p>conditional transition probability matrix of the underlying semi-Markov chain. Only needed if the number of states is greater than 2, <code>NULL</code> (default) otherwise. In the former case, <code>omega</code> is a matrix with <code>N</code> rows and <code>N</code> columns, its diagonal elements must be zero and its rows must sum to one.</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_delta">delta</code></td>
<td>
<p>vector of length N containing the initial distribution. Only needed if <code>stationary=FALSE</code>, otherwise delta is ignored and can be set to <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_y_dist">y_dist</code></td>
<td>
<p>character determining the class of state-dependent distributions. Supported values are <code>"norm"</code> (normal distribution), <code>"gamma"</code> (gamma distribution), <code>"pois"</code> (Poisson distribution) and <code>"bern"</code> (Bernoulli distribution).</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_stationary">stationary</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), stationarity is assumed, if <code>FALSE</code>, the underlying state-sequence is assumed to enter a new state at time t=1 and it is necessary to define the initial distribution <code>delta</code>.</p>
</td></tr>
<tr><td><code id="n2wHSMM_+3A_p_ref">p_ref</code></td>
<td>
<p>positive integer determining the reference dwell-time probability used for the multinomial logit parameter transformation. Default value is 2. Only needs to be changed if the dwell-time probability for dwell time r=2 is estimated very close to zero in order to avoid numerical problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation from natural to working parameters is needed to carry out an unconstraint optimisation. The function includes log-transformations for positive parameters and (multinomial) logit-transformations for probabilities, probability vectors and matrices.
</p>


<h3>Value</h3>

<p>A vector of unconstraint working parameters characterising the HSMM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># natural parameters for 2-state HSMM with state-dependent normal distributions
p_list0&lt;-list() # list of dwell-time distribution vectors,
                # vector elements must sum to one
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.1),1-pgeom(9,0.1))
mu0&lt;-c(-10,10) # mean values
sigma0&lt;-c(3,5) # standard deviations
# parameter transformation:
n2wHSMM(N=2,p_list=p_list0,mu=mu0,sigma=sigma0,y_dist='norm',stationary=TRUE)
</code></pre>

<hr>
<h2 id='nll_Rcpp'>Negative log-likelihood evaluation</h2><span id='topic+nll_Rcpp'></span>

<h3>Description</h3>

<p>Evaluation of the negative HMM log-likelihood function based on the forward algorithm, written in <code>C++</code> (internal function, called by the function <code><a href="#topic+npllHSMM">npllHSMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nll_Rcpp(allprobs, gamma, delta, T_y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nll_Rcpp_+3A_allprobs">allprobs</code></td>
<td>
<p>matrix containing the state-dependent distribution values for each observation (row) and state (column), respectively.</p>
</td></tr>
<tr><td><code id="nll_Rcpp_+3A_gamma">gamma</code></td>
<td>
<p>transition probability matrix.</p>
</td></tr>
<tr><td><code id="nll_Rcpp_+3A_delta">delta</code></td>
<td>
<p>initial distribution.</p>
</td></tr>
<tr><td><code id="nll_Rcpp_+3A_t_y">T_y</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the negative log-likelihood value.
</p>

<hr>
<h2 id='npllHSMM'>negative penalised HSMM log-likelihood function</h2><span id='topic+npllHSMM'></span>

<h3>Description</h3>

<p>Evaluates the negative penalised log-likelihood function of the HSMM (internal function, called by the function <code><a href="#topic+pmleHSMM">pmleHSMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npllHSMM(parvect ,N, y, R_vec, lambda, order_diff,
        y_dist=c("norm","gamma","pois","bern"),
        stationary=TRUE, T_y,  p_ref=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npllHSMM_+3A_parvect">parvect</code></td>
<td>
<p>vector of unconstraint working parameter as returned by the function <code><a href="#topic+n2wHSMM">n2wHSMM</a></code>.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_n">N</code></td>
<td>
<p>number of states of the HSMM, integer greater than 1.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_y">y</code></td>
<td>
<p>vector containing the observed time series.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_r_vec">R_vec</code></td>
<td>
<p>vector of length <code>N</code> containing the lengths of the unstructured starts of the dwell-time distributions.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_lambda">lambda</code></td>
<td>
<p>vector of length <code>N</code> containing the smoothing parameter values to weight the penalty term.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_order_diff">order_diff</code></td>
<td>
<p>order of the differences used for the penalty term, positive integer which does not exceed the length of the unstructured starts.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_y_dist">y_dist</code></td>
<td>
<p>character determining the class of state-dependent distributions. Supported values are <code>"norm"</code> (normal distribution), <code>"gamma"</code> (gamma distribution), <code>"pois"</code> (Poisson distribution) and <code>"bern"</code> (Bernoulli distribution).</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_stationary">stationary</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), stationarity is assumed, if <code>FALSE</code>, the underlying state-sequence is assumed to enter a new state at time t=1.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_t_y">T_y</code></td>
<td>
<p>length of the observed time series.</p>
</td></tr>
<tr><td><code id="npllHSMM_+3A_p_ref">p_ref</code></td>
<td>
<p>positive integer determining the reference dwell-time probability used for the multinomial logit parameter transformation. Default value is 2. Only needs to be changed if the dwell-time probability for dwell time r=2 is estimated very close to zero in order to avoid numerical problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The penalised log-likelihood function relies on the exact HMM representation of the HSMM and is evaluated using the forward algorithm which is implemented in <code>C++</code> to speed up the calculation.
</p>


<h3>Value</h3>

<p>Returns the value of the negative penalised HSMM log-likelihood function for the given parameters and time series.
</p>


<h3>References</h3>

<p>Pohle, J., Adam, T. and Beumer, L.T. (2021): Flexible estimation of the state dwell-time distribution in hidden semi-Markov models. arXiv:<a href="https://arxiv.org/abs/2101.09197">https://arxiv.org/abs/2101.09197</a>.
</p>
<p>Zucchini, W., MacDonald, I.L. and Langrock, R. (2016): <em>Hidden Markov models for time series:
An introduction using R</em>. 2nd edition. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3-state gamma HSMM and hourly muskox step length
# natural parameters
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[3]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
omega0&lt;-matrix(0.5,3,3)
diag(omega0)&lt;-0
mu0&lt;-c(5,100,350)
sigma0&lt;-c(3,90,300)
R_vec&lt;-sapply(p_list0,length)-1 # lengths of the unstructured starts
# working parameter vector
parvect&lt;-n2wHSMM(N=3,p_list=p_list0,mu=mu0,sigma=sigma0,
  omega=omega0,y_dist='gamma')
# evaluate the negative penalised log-likelihood function
npllHSMM(parvect,N=3,muskox$step,R_vec=R_vec,lambda=c(1000,1000,1000),
  order_diff=2,y_dist="gamma",T_y=nrow(muskox))
</code></pre>

<hr>
<h2 id='plotDw'>Plot of the estimated HSMM dwell-time distributions.</h2><span id='topic+plotDw'></span>

<h3>Description</h3>

<p>Plots the HSMM dwell-time distributions estimated using <code><a href="#topic+pmleHSMM">pmleHSMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDw(mod, R_max, state='all', mfrow=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDw_+3A_mod">mod</code></td>
<td>
<p>model object as returned by <code>pmleHSMM</code>.</p>
</td></tr>
<tr><td><code id="plotDw_+3A_r_max">R_max</code></td>
<td>
<p>integer, maximum dwell time for which the dwell-time probabilities are plotted.</p>
</td></tr>
<tr><td><code id="plotDw_+3A_state">state</code></td>
<td>
<p>value determining the states for which the distributions are plotted. Either &quot;all&quot; (default) for plotting the dwell-time distributions of all states, or positive integer in 1,..,N.</p>
</td></tr>
<tr><td><code id="plotDw_+3A_mfrow">mfrow</code></td>
<td>
<p>If <code>NULL</code> (default) and <code>state="all"</code>, the probability mass functions are plotted one below the other. Otherwise, a vector of length 2 which determines the number of rows (first element) and the number of columns (second argument) of the matrix of plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the estimated HSMM dwell-time distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# running this example might take a few minutes
#
# 1.) 2-state gamma-HSMM for hourly muskox step length
# with an unstructured start of length of 10
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
mu0&lt;-c(5,150)
sigma0&lt;-c(3,180)
#
# fit 2-state gamma-HSMM with lambda=c(100,100)
# and difference order 3
# estimation might take a few minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=2,p_list=p_list0,mu=mu0,
                sigma=sigma0,lambda=c(100,100),order_diff=3,
                y_dist='gamma')
#
# plot the estimated dwell-time distributions
# for dwell-times up to 12
plotDw(mod=PHSMM,R_max=12)
plotDw(mod=PHSMM,R_max=12,state=1)
plotDw(mod=PHSMM,R_max=12,mfrow=c(1,2))




# running this example might take a few minutes
#
# 2.) 3-state gamma-HSMM for hourly muskox step length
# with an unstructured start of length of 10
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[3]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
omega0&lt;-matrix(0.5,3,3)
diag(omega0)&lt;-0
mu0&lt;-c(5,100,350)
sigma0&lt;-c(3,90,300)
#
# fit 3-state gamma-HSMM with lambda=c(1000,1000,1000)
# and difference order 3
# estimation might take some minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=3,p_list=p_list0,mu=mu0,
                sigma=sigma0,omega=omega0,
                lambda=c(1000,1000,1000),
                order_diff=3,y_dist='gamma')
#
# plot the estimated dwell-time distributions
# for dwell-times up to 15
plotDw(mod=PHSMM,R_max=15)
plotDw(mod=PHSMM,R_max=15,state=1)
plotDw(mod=PHSMM,R_max=15,mfrow=c(1,3))

</code></pre>

<hr>
<h2 id='pmleHSMM'>HSMM penalised maximum likelihood estimation</h2><span id='topic+pmleHSMM'></span>

<h3>Description</h3>

<p>Estimates the parameters of a hidden semi-Markov model (HSMM) for univariate time series using numerical penalised maximum likelihood estimation. The dwell times are modelled using distributions with an unstructured start and a geometric tail. During the estimation, (higher-order) differences between adjacent dwell-time probabilities are penalised to derive smooth and flexible estimates. The function allows for normal-, gamma-, Poisson- or Bernoulli-distributions in the state-dependent process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmleHSMM(y, N, p_list, mu, sigma=NULL, omega=NULL, delta=NULL,
        lambda, order_diff, y_dist=c("norm","gamma","pois","bern"),
        stationary=TRUE, p_ref=2, print.level=0, iterlim=10000,
        stepmax=NULL, hessian=FALSE, gradtol=10^(-6))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmleHSMM_+3A_y">y</code></td>
<td>
<p>vector containing the observed time series.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_n">N</code></td>
<td>
<p>number of states of the HSMM, integer greater than 1.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_p_list">p_list</code></td>
<td>
<p>list of vectors containing the starting values for the state dwell-time distributions. The list comprises <code>N</code> vectors, i.e. one vector for each state. Each vector contains the state's dwell-time probabilities for the unstructured start and, as last element, the probability mass captured in the geometric tail. Thus, each vector must sum to one and automatically determines the length of the unstructured start of the according state dwell-time distribution.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_mu">mu</code></td>
<td>
<p>starting values for the state-dependent mean values if normal, gamma or Poisson distributions are used to model the state-dependent observations. State-dependent probabilities if Bernoulli distributions are chosen. The vector is of length <code>N</code> and the values must be sorted in an ascending order (to avoid label switching).</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_sigma">sigma</code></td>
<td>
<p>starting values for the state-dependent standard deviations if gamma or normal state-dependent distributions are used. In that case, <code>sigma</code> is a vector of length <code>N</code>, otherwise it is <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_omega">omega</code></td>
<td>
<p>starting values for the conditional transition probability matrix of the underlying semi-Markov chain. Only needed if the number of states exceeds 2, otherwise it is <code>NULL</code> (default). In the former case, <code>omega</code> is a matrix with <code>N</code> rows and <code>N</code> columns, its diagonal elements must be zero and its rows must sum to one.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_delta">delta</code></td>
<td>
<p>starting values for the initial distribution of the underlying semi-Markov chain if <code>stationary=FALSE</code>. In that case, <code>delta</code> is a vector of dimension <code>N</code> and its elements must sum to one. For <code>stationary=TRUE</code>, delta is ignored and can be set to <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_lambda">lambda</code></td>
<td>
<p>vector of length N containing the smoothing parameter values to weight the penalty term.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_order_diff">order_diff</code></td>
<td>
<p>order of the differences used for the penalty term, positive integer which does not exceed the length of the unstructured starts (as determined by <code>p_list</code>).</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_y_dist">y_dist</code></td>
<td>
<p>character determining the class of state-dependent distributions used to model the observations. Supported values are <code>"norm"</code> (normal distribution), <code>"gamma"</code> (gamma distribution), <code>"pois"</code> (Poisson distribution) and <code>"bern"</code> (Bernoulli distribution).</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_stationary">stationary</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), stationarity is assumed, if <code>FALSE</code>, an initial distribution is estimated and the underlying state-sequence is assumed to enter a new state at time t=1.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_p_ref">p_ref</code></td>
<td>
<p>positive integer determining the reference dwell-time probability used for the multinomial logit parameter transformation. Default value is 2. Only needs to be changed if the dwell-time probability for dwell time r=2 is estimated very close to zero in order to avoid numerical problems.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_print.level">print.level</code></td>
<td>
<p>print level for the optimisation procedure <code>nlm</code>. Default value is 0 corresponding to no printing. See <code><a href="stats.html#topic+nlm">nlm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_iterlim">iterlim</code></td>
<td>
<p>maximum number of iterations for the optimisation procedure <code>nlm</code>. Default value is 10000.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_stepmax">stepmax</code></td>
<td>
<p>stepmax value for <code>nlm</code>. The default value <code>NULL</code> corresponds to the <code>nlm</code> default. See <code><a href="stats.html#topic+nlm">nlm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_hessian">hessian</code></td>
<td>
<p>Logical, if TRUE, the hessian matrix is calculated and returned by <code>nlm</code>, if <code>FALSE</code> (default), the hessian is not calculated.</p>
</td></tr>
<tr><td><code id="pmleHSMM_+3A_gradtol">gradtol</code></td>
<td>
<p>tolerance value for a convergence criterion used by <code>nlm</code>. Default value is 10^(-6). See <code><a href="stats.html#topic+nlm">nlm</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numerical penalised maximum likelihood estimation requires starting values for each HSMM parameter. If these starting values are poorly chosen, the algorithm might fail in finding the global optimum of the penalised log-likelihood function. Therefore, it is highly recommended to repeat the estimation several times using different sets of starting values.
</p>
<p>The maximisation of the penalised log-likelihood function is carried out using the optimisation routine <code>nlm</code>. The likelihood evaluation is written in <code>C++</code> to speed up the estimation.
</p>


<h3>Value</h3>

<p>An HSMM model object, i.e. a list containing:
</p>
<table role = "presentation">
<tr><td><code>p_list</code></td>
<td>
<p>list containing the penalised maximum likelihood estimates for the state dwell-time distributions.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>vector containing the penalised maximum likelihood estimates for the state-dependent mean values or state-dependent probabilities, depending on the chosen class of state-dependent distributions.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>vector containing the penalised maximum likelihood estimates for the state-dependent standard deviations if state-dependent gamma or normal distributions are used.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>vector containing the equilibrium distribution if <code>stationary=TRUE</code>, otherwise vector of the estimated initial distribution.</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>penalised maximum likelihood estimate of the conditional HSMM transition probability matrix.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>transition probability matrix corresponding to the HMM representation of the estimated HSMM.</p>
</td></tr>
<tr><td><code>npll</code></td>
<td>
<p>minimum negative penalised log likelihood value as found by nlm.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>gradient of the negative penalised log-likelihood function as returned by nlm.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations until convergence.</p>
</td></tr>
<tr><td><code>code_conv</code></td>
<td>
<p>convergence code as returned by nlm.</p>
</td></tr>
<tr><td><code>w_parvect</code></td>
<td>
<p>vector of the penalised maximum likelihood working parameters.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Logical, as specified for the estimation.</p>
</td></tr>
<tr><td><code>y_dist</code></td>
<td>
<p>state-dependent distribution, as specified for the estimation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>See <code><a href="stats.html#topic+nlm">nlm</a></code> for further details on the numerical optimisation routine.
</p>
<p>For details on the model formulation and likelihood function, see:
</p>
<p>Pohle, J., Adam, T. and Beumer, L.T. (2021): Flexible estimation of the state dwell-time distribution in hidden semi-Markov models. arXiv:<a href="https://arxiv.org/abs/2101.09197">https://arxiv.org/abs/2101.09197</a>.
</p>
<p>Langrock, R. and Zucchini W. (2011): Hidden Markov models with arbitrary state dwell-time distributions. <em>Computational Statistics and Data Analysis</em>, <strong>55</strong>, p. 715&ndash;724.
</p>
<p>Zucchini, W., MacDonald, I.L. and Langrock, R. (2016): <em>Hidden Markov models for time series:
An introduction using R</em>. 2nd edition. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# running this example might take a few minutes
#
# 1.) fit 2-state gamma-HSMM to hourly muskox step length
# using a length of 10 for the unstructured start
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
mu0&lt;-c(5,150)
sigma0&lt;-c(3,180)
#
# fit 2-state gamma-HSMM with lambda=c(100,100)
# and difference order 3
# estimation might take a few minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=2,p_list=p_list0,mu=mu0,
                sigma=sigma0,lambda=c(100,100),order_diff=3,
                y_dist='gamma')




# running this example might take a few minutes
#
# 2.) fit 3-state gamma-HSMM to hourly muskox step length
# using a length of 10 for the unstructured start
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[3]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
omega0&lt;-matrix(0.5,3,3)
diag(omega0)&lt;-0
mu0&lt;-c(5,100,350)
sigma0&lt;-c(3,90,300)
#
# fit 3-state gamma-HSMM with lambda=c(1000,1000,1000)
# and difference order 3
# estimation might take some minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=3,p_list=p_list0,mu=mu0,
                sigma=sigma0,omega=omega0,
                lambda=c(1000,1000,1000),
                order_diff=3,y_dist='gamma')

</code></pre>

<hr>
<h2 id='pseudoResHSMM'>HSMM pseudo-residuals</h2><span id='topic+pseudoResHSMM'></span>

<h3>Description</h3>

<p>Pseudo-residuals based on the one-step ahead forecast distributions under the HSMM which was estimated using <code><a href="#topic+pmleHSMM">pmleHSMM</a></code>. This function can only be used for HSMMs with state-dependent normal or gamma distributions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudoResHSMM(y, mod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudoResHSMM_+3A_y">y</code></td>
<td>
<p>vector containing the observations.</p>
</td></tr>
<tr><td><code id="pseudoResHSMM_+3A_mod">mod</code></td>
<td>
<p>model object as returned by <code>pmleHSMM</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A good model fit is indicated by standard normally distributed pseudo-residuals. 
</p>


<h3>Value</h3>

<p>Returns a vector containing the forecast pseudo-residuals.
</p>


<h3>References</h3>

<p>For more details about pseudo-residuals in the context of HMMs, see:
</p>
<p>Zucchini, W., MacDonald, I.L. and Langrock, R. (2016): <em>Hidden Markov models for time series:
An introduction using R</em>. 2nd edition. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# running this example might take a few minutes
#
# 1.) 2-state gamma-HSMM for hourly muskox step length
# with an unstructured start of length of 10
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
mu0&lt;-c(5,150)
sigma0&lt;-c(3,180)
#
# fit 2-state gamma-HSMM with lambda=c(100,100)
# and difference order 3
# estimation might take a few minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=2,p_list=p_list0,mu=mu0,
                sigma=sigma0,lambda=c(100,100),order_diff=3,
                y_dist='gamma')
#
# pseudo-residuals
pseudoRes&lt;-pseudoResHSMM(y=muskox$step,PHSMM)
hist(pseudoRes,probability=TRUE)
z&lt;-seq(-3,3,0.01)
lines(z,dnorm(z),col='blue')




# running this example might take a few minutes
#
# 2.) 3-state gamma-HSMM for hourly muskox step length
# with an unstructured start of length of 10
#
# initial values
p_list0&lt;-list()
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[3]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
omega0&lt;-matrix(0.5,3,3)
diag(omega0)&lt;-0
mu0&lt;-c(5,100,350)
sigma0&lt;-c(3,90,300)
#
# fit 3-state gamma-HSMM with lambda=c(1000,1000,1000)
# and difference order 3
# estimation might take some minutes
PHSMM&lt;-pmleHSMM(y=muskox$step,N=3,p_list=p_list0,mu=mu0,
                sigma=sigma0,omega=omega0,
                lambda=c(1000,1000,1000),
                order_diff=3,y_dist='gamma')
#
# pseudo-residuals
pseudoRes&lt;-pseudoResHSMM(y=muskox$step,PHSMM)
hist(pseudoRes,probability=TRUE)
z&lt;-seq(-3,3,0.01)
lines(z,dnorm(z),col='blue')

</code></pre>

<hr>
<h2 id='tpmHMM'>Tranistion probability matrix of the HMM representation</h2><span id='topic+tpmHMM'></span>

<h3>Description</h3>

<p>Construction of the transition probability matrix corresponding to the HMM which exactly represents the HSMM. Not intended to be run by the user (internal function, called by the functions <code><a href="#topic+w2nHSMM">w2nHSMM</a></code> and <code><a href="#topic+pmleHSMM">pmleHSMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpmHMM(N, omega, d_r, R_vec, eps=1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpmHMM_+3A_n">N</code></td>
<td>
<p>number of states of the HSMM, integer greater than 1.</p>
</td></tr>
<tr><td><code id="tpmHMM_+3A_omega">omega</code></td>
<td>
<p>conditional transition probability matrix of the HSMM with N rows and N columns. The diagonal elements must be zero and the rows must sum to one.</p>
</td></tr>
<tr><td><code id="tpmHMM_+3A_d_r">d_r</code></td>
<td>
<p>list of vectors containing the dwell-time probabilities of the unstructured starts.</p>
</td></tr>
<tr><td><code id="tpmHMM_+3A_r_vec">R_vec</code></td>
<td>
<p>vector of length N containing the lengths of the unstructured starts of the state dwell-time distributions.</p>
</td></tr>
<tr><td><code id="tpmHMM_+3A_eps">eps</code></td>
<td>
<p>to avoid negative probabilities due to numerical underflow. Default is <code>1e-10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the transition probability matrix of the HMM which exactly represents the HSMM.
</p>


<h3>References</h3>

<p>For details on the code and construction of the matrix, see:
</p>
<p>Langrock, R. and Zucchini W. (2011): Hidden Markov models with arbitrary state dwell-time distributions. <em>Computational Statistics and Data Analysis</em>, <strong>55</strong>, p. 715&ndash;724.
</p>
<p>Zucchini, W., MacDonald, I.L. and Langrock, R. (2016): <em>Hidden Markov models for time series:
An introduction using R</em>. 2nd edition. Chapman &amp; Hall/CRC, Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list of dwell-time probability vectors 
# (vector elements should not sum to one)
d_r&lt;-list()
d_r[[1]]&lt;-c(dgeom(0:9,0.2))
d_r[[2]]&lt;-c(dgeom(0:9,0.1))
# tranistion probability matrix:
Gamma&lt;-tpmHMM(N=2,omega=matrix(c(0,1,1,0),2,2),
  d_r=d_r,R_vec=sapply(d_r,length))
</code></pre>

<hr>
<h2 id='w2nHSMM'>Parameter transformation from working to natural parameters</h2><span id='topic+w2nHSMM'></span>

<h3>Description</h3>

<p>Transforms unconstraint HSMM working parameters back into (constraint) natural parameters. Not intended to be run by the user (internal function, called by the functions <code><a href="#topic+pmleHSMM">pmleHSMM</a></code> and <code><a href="#topic+npllHSMM">npllHSMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w2nHSMM(N, parvect, R_vec, y_dist=c("norm","gamma","pois","bern"),
      stationary=TRUE, p_ref=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="w2nHSMM_+3A_n">N</code></td>
<td>
<p>number of states of the HSMM, integer greater than 1.</p>
</td></tr>
<tr><td><code id="w2nHSMM_+3A_parvect">parvect</code></td>
<td>
<p>vector of unconstraint working parameter as obtained by the function <code><a href="#topic+n2wHSMM">n2wHSMM</a></code>.</p>
</td></tr>
<tr><td><code id="w2nHSMM_+3A_r_vec">R_vec</code></td>
<td>
<p>vector of length <code>N</code> containing the lengths of the unstructured starts of the dwell-time distributions.</p>
</td></tr>
<tr><td><code id="w2nHSMM_+3A_y_dist">y_dist</code></td>
<td>
<p>character determining the class of state-dependent distributions used to model the observations. Supported values are <code>"norm"</code> (normal distribution), <code>"gamma"</code> (gamma distribution), <code>"pois"</code> (Poisson distribution) and <code>"bern"</code> (Bernoulli distribution).</p>
</td></tr>
<tr><td><code id="w2nHSMM_+3A_stationary">stationary</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), stationarity is assumed, if <code>FALSE</code>, the underlying state-sequence is assumed to enter a new state at time t=1.</p>
</td></tr>
<tr><td><code id="w2nHSMM_+3A_p_ref">p_ref</code></td>
<td>
<p>positive integer determining the reference dwell-time probability used for the multinomial logit parameter transformation. Default value is 2. Only needs to be changed if the dwell-time probability for dwell time r=2 is estimated very close to zero in order to avoid numerical problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reverses the transformation of the function <code><a href="#topic+n2wHSMM">n2wHSMM</a></code> and back-transforms the unconstraint parameters into the constraint natural parameters. Note that if <code>y_dist="gamma"</code>, <code>mu</code> and <code>sigma</code> do not include the mean values and standard deviations, but the shape and rate parameters as required by the density functions <code><a href="stats.html#topic+dgamma">dgamma</a></code> and <code><a href="stats.html#topic+pgamma">pgamma</a></code>. The mean and standard deviations are then assigned to <code>mu2</code> and <code>sigma2</code>.
</p>


<h3>Value</h3>

<p>A list containing the natural parameters
</p>
<table role = "presentation">
<tr><td><code>p_list</code></td>
<td>
<p>list containing the dwell-time distribution vectors for each state. Each of the <code>N</code> vectors contains the state dwell-time probabilities for the unstructured start and, as last element, the probability mass captured in the geometric tail. Thus, each vector sums to one.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>vector of length <code>N</code>. For <code>y_dist="norm"</code> and <code>y_dist="pois"</code>, it contains the state-dependent mean values, for <code>y_dist="gamma"</code>, it contains the state-dependent shape parameters, and for <code>y_dist="bern"</code>, it contains the state-dependent probabilities.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>vector of length <code>N</code> containing the state-dependent standard deviations if <code>y_dist="norm"</code> and the state-dependent rates if <code>y_dist="gamma"</code>. <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>conditional transition probability matrix of the HSMM.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>equilibrium distribution if <code>stationary=TRUE</code>, initial distribution of length N if <code>stationary=FALSE</code>.</p>
</td></tr>
<tr><td><code>d_r</code></td>
<td>
<p>list containing the dwell-time probabilities of the unstructured starts.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>transition probability matrix of the HMM which represents the HSMM.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># natural parameters for 2-state HSMM with state-dependent normal distributions
p_list0&lt;-list() # list of dwell-time distribution vectors,
                # vector elements must sum to one
p_list0[[1]]&lt;-c(dgeom(0:9,0.2),1-pgeom(9,0.2))
p_list0[[2]]&lt;-c(dgeom(0:9,0.1),1-pgeom(9,0.1))
mu0&lt;-c(-10,10) # mean values
sigma0&lt;-c(3,5) # standard deviations
# parameter transformation:
parvect&lt;-n2wHSMM(N=2,p_list=p_list0,mu=mu0,sigma=sigma0,y_dist='norm',stationary=TRUE)
# back-transformation:
npar&lt;-w2nHSMM(N=2,parvect=parvect,R_vec=sapply(p_list0,length)-1,y_dist='norm')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
