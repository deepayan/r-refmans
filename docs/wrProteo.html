<!DOCTYPE html><html><head><title>Help for package wrProteo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wrProteo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.atomicMasses'><p>Molecular mass for Elements</p></a></li>
<li><a href='#.checkKnitrProt'><p>Checking presence of knitr and rmarkdown</p></a></li>
<li><a href='#.checkSetupGroups'><p>Additional/final chek and adjustments to sample-order after readSampleMetaData()</p></a></li>
<li><a href='#.commonSpecies'><p>Get matrix with UniProt abbreviations for selected species as well as simple names</p></a></li>
<li><a href='#.extrSpecPref'><p>Extract additional information to construct colum SpecType</p></a></li>
<li><a href='#.imputeNA'><p>Basic NA-imputaton (main)</p></a></li>
<li><a href='#.plotQuantDistr'><p>Generic plotting of density distribution for quantitation import-functions</p></a></li>
<li><a href='#AAmass'><p>Molecular mass for amino-acids</p></a></li>
<li><a href='#AucROC'><p>AUC from ROC-curves</p></a></li>
<li><a href='#cleanListCoNames'><p>Selective batch cleaning of sample- (ie column-) names in list</p></a></li>
<li><a href='#combineMultFilterNAimput'><p>Combine Multiple Filters On NA-imputed Data</p></a></li>
<li><a href='#convAASeq2mass'><p>Molecular mass for amino-acids</p></a></li>
<li><a href='#corColumnOrder'><p>Order Columns in list of matrixes</p></a></li>
<li><a href='#countNoOfCommonPeptides'><p>Compare in-silico digested proteomes for unique and shared peptides, counts per protein or as peptides</p>
</p>
<p>Compare in-silico digested proteomes for unique and shared peptides, counts per protein or as peptides.</p>
The in-silico digestion may be performed separately using the package <a href="https://bioconductor.org/packages/release/bioc/html/cleaver.html">cleaver</a>.
Note: input must be list (or multiple names lists) of proteins with their respective peptides (eg by in-silico digestion).</a></li>
<li><a href='#exportSdrfDraft'><p>Export Sample Meta-data from Quantification-Software as Sdrf-draft</p></a></li>
<li><a href='#extractTestingResults'><p>Extract Results From Moderated t-tests</p></a></li>
<li><a href='#extrSpeciesAnnot'><p>Extract species annotation</p></a></li>
<li><a href='#foldChangeArrow2'><p>Add arrow for expected Fold-Change to VolcanoPlot or MA-plot</p></a></li>
<li><a href='#fuseProteomicsProjects'><p>Combine Multiple Proteomics Data-Sets</p></a></li>
<li><a href='#getUPS1acc'><p>Accession-Numbers And Names Of UPS-1 Proteins</p></a></li>
<li><a href='#isolNAneighb'><p>Isolate NA-neighbours</p></a></li>
<li><a href='#massDeFormula'><p>Molecular mass from chemical formula</p></a></li>
<li><a href='#matrixNAinspect'><p>Histogram of content of NAs in matrix</p></a></li>
<li><a href='#matrixNAneighbourImpute'><p>Imputation of NA-values based on non-NA replicates</p></a></li>
<li><a href='#plotROC'><p>Plot ROC curves</p></a></li>
<li><a href='#razorNoFilter'><p>Filter based on either number of total peptides and specific peptides or number of razor petides</p></a></li>
<li><a href='#readAlphaPeptFile'><p>Read (Normalized) Quantitation Data Files Produced By AlphaPept</p></a></li>
<li><a href='#readDiaNNFile'><p>Read Tabulated Files Exported by DIA-NN At Protein Level</p></a></li>
<li><a href='#readDiaNNPeptides'><p>Read Tabulated Files Exported by DiaNN At Peptide Level</p></a></li>
<li><a href='#readFasta2'><p>Read file of protein sequences in fasta format</p></a></li>
<li><a href='#readFragpipeFile'><p>Read Tabulated Files Exported by FragPipe At Protein Level</p></a></li>
<li><a href='#readMassChroQFile'><p>Read tabulated files imported from MassChroQ</p></a></li>
<li><a href='#readMaxQuantFile'><p>Read Quantitation Data-Files (proteinGroups.txt) Produced From MaxQuant At Protein Level</p></a></li>
<li><a href='#readMaxQuantPeptides'><p>Read Peptide Identificationa and Quantitation Data-Files (peptidess.txt) Produced By MaxQuant</p></a></li>
<li><a href='#readOpenMSFile'><p>Read csv files exported by OpenMS</p></a></li>
<li><a href='#readProlineFile'><p>Read xlsx, csv or tsv files exported from Proline and MS-Angel</p></a></li>
<li><a href='#readProtDiscovererPeptides'><p>readProtDiscovererPeptides, depreciated</p></a></li>
<li><a href='#readProtDiscovFile'><p>Read Tabulated Files Exported By ProteomeDiscoverer At Protein Level, Deprecated</p></a></li>
<li><a href='#readProtDiscovPeptides'><p>Read Tabulated Files Exported by ProteomeDiscoverer At Peptide Level, Deprecated</p></a></li>
<li><a href='#readProteomeDiscovererFile'><p>Read Tabulated Files Exported By ProteomeDiscoverer At Protein Level</p></a></li>
<li><a href='#readProteomeDiscovererPeptides'><p>Read Tabulated Files Exported by ProteomeDiscoverer At Peptide Level</p></a></li>
<li><a href='#readSampleMetaData'><p>Read Sample Meta-data from Quantification-Software And/Or Sdrf And Align To Experimental Data</p></a></li>
<li><a href='#readSdrf'><p>Read proteomics meta-data as sdrf file</p></a></li>
<li><a href='#readUCSCtable'><p>Read annotation files from UCSC</p></a></li>
<li><a href='#readUniProtExport'><p>Read protein annotation as exported from UniProt batch-conversion</p></a></li>
<li><a href='#readWombatNormFile'><p>Read (Normalized) Quantitation Data Files Produced By Wombat At Protein Level</p></a></li>
<li><a href='#removeSampleInList'><p>Remove Samples/Columns From list of matrixes</p></a></li>
<li><a href='#replMissingProtNames'><p>Complement Missing EntryNames In Annotation</p></a></li>
<li><a href='#shortSoftwName'><p>Get Short Names of Proteomics Quantitation Software</p></a></li>
<li><a href='#summarizeForROC'><p>Summarize statistical test result for plotting ROC-curves</p></a></li>
<li><a href='#test2grp'><p>t-test each line of 2 groups of data</p></a></li>
<li><a href='#testRobustToNAimputation'><p>Pair-wise testing robust to NA-imputation</p></a></li>
<li><a href='#VolcanoPlotW2'><p>Deprecialed Volcano-plot</p></a></li>
<li><a href='#writeFasta2'><p>Write sequences in fasta format to file</p>
</p>
<p>This function writes sequences from character vector as fasta formatted file (from <a href="https://www.uniprot.org">UniProt</a>)</p>
Line-headers are based on names of elements of input vector <code>prot</code>.
This function also allows comparing the main vector of sequences with a reference vector <code>ref</code> to check if any of the sequences therein are truncated.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.11.0.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Proteomics Data Analysis Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>Wolfgang Raffelsberger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wolfgang Raffelsberger &lt;w.raffelsberger@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Data analysis of proteomics experiments by mass spectrometry is supported by this collection of functions mostly dedicated to the analysis of (bottom-up) quantitative (XIC) data. 
    Fasta-formatted proteomes (eg from UniProt Consortium &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgky1049">doi:10.1093/nar/gky1049</a>&gt;) can be read with automatic parsing and multiple annotation types (like species origin, abbreviated gene names, etc) extracted. 
	Initial results from multiple software for protein (and peptide) quantitation can be imported (to a common format): 
	MaxQuant (Tyanova et al 2016 &lt;<a href="https://doi.org/10.1038%2Fnprot.2016.136">doi:10.1038/nprot.2016.136</a>&gt;), Dia-NN (Demichev et al 2020 &lt;<a href="https://doi.org/10.1038%2Fs41592-019-0638-x">doi:10.1038/s41592-019-0638-x</a>&gt;), 
	Fragpipe(da Veiga et al 2020 &lt;<a href="https://doi.org/10.1038%2Fs41592-020-0912-y">doi:10.1038/s41592-020-0912-y</a>&gt;), MassChroq (Valot et al 2011 &lt;<a href="https://doi.org/10.1002%2Fpmic.201100120">doi:10.1002/pmic.201100120</a>&gt;), 
    OpenMS (Strauss et al 2021 &lt;<a href="https://doi.org/10.1038%2Fnmeth.3959">doi:10.1038/nmeth.3959</a>&gt;), ProteomeDiscoverer (Orsburn 2021 &lt;<a href="https://doi.org/10.3390%2Fproteomes9010015">doi:10.3390/proteomes9010015</a>&gt;), 
	Proline (Bouyssie et al 2020 &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa118">doi:10.1093/bioinformatics/btaa118</a>&gt;), AlphaPept (preprint Strauss et al &lt;<a href="https://doi.org/10.1101%2F2021.07.23.453379">doi:10.1101/2021.07.23.453379</a>&gt;) 
	and Wombat-P (Bouyssie et al 2023 &lt;<a href="https://doi.org/10.1021%2Facs.jproteome.3c00636">doi:10.1021/acs.jproteome.3c00636</a>&gt;. 
	Meta-data provided by initial analysis software and/or in sdrf format can be integrated to the analysis. 
    Quantitative proteomics measurements frequently contain multiple NA values, due to physical absence of given peptides in some samples, limitations in sensitivity or other reasons. 
    Help is provided to inspect the data graphically to investigate the nature of NA-values via their respective replicate measurements 
	and to help/confirm the choice of NA-replacement algorithms. 
	Meta-data in sdrf-format (Perez-Riverol et al 2020 &lt;<a href="https://doi.org/10.1021%2Facs.jproteome.0c00376">doi:10.1021/acs.jproteome.0c00376</a>&gt;) or similar tabular formats can be imported and included.
	Missing values can be inspected and imputed based on the concept of NA-neighbours or other methods.
    Dedicated filtering and statistical testing using the framework of package 'limma' &lt;<a href="https://doi.org/10.18129%2FB9.bioc.limma">doi:10.18129/B9.bioc.limma</a>&gt; can be run, enhanced by multiple rounds of NA-replacements to provide robustness towards rare stochastic events. 
    Multi-species samples, as frequently used in benchmark-tests (eg Navarro et al 2016 &lt;<a href="https://doi.org/10.1038%2Fnbt.3685">doi:10.1038/nbt.3685</a>&gt;, Ramus et al 2016 &lt;<a href="https://doi.org/10.1016%2Fj.jprot.2015.11.011">doi:10.1016/j.jprot.2015.11.011</a>&gt;), can be run with special options considering 
    such sub-groups during normalization and testing. Subsequently, ROC curves (Hand and Till 2001 &lt;<a href="https://doi.org/10.1023%2FA%3A1010920819831">doi:10.1023/A:1010920819831</a>&gt;) can be constructed to compare multiple analysis approaches.
    As detailed example the data-set from Ramus et al 2016 &lt;<a href="https://doi.org/10.1016%2Fj.jprot.2015.11.011">doi:10.1016/j.jprot.2015.11.011</a>&gt;) quantified by MaxQuant, ProteomeDiscoverer,
    and Proline is provided with a detailed analysis of heterologous spike-in proteins.     </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, knitr, limma, stats, utils, wrMisc (&ge;
1.14.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table, fdrtool, kableExtra, MASS, RColorBrewer, readxl,
ROTS, rmarkdown, R.utils, sm, wrGraph (&ge; 1.3.7)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-13 09:19:54 UTC; wraff</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.atomicMasses'>Molecular mass for Elements</h2><span id='topic+.atomicMasses'></span>

<h3>Description</h3>

<p>This fuction returns the molecular mass based of main elements found in biology/proteomics as average and mono-isotopic mass. 
The result includes H, C, N, O, P, S, Se  and the electrone.
The values are bsed on http://www.ionsource.com/Card/Mass/mass.htm in ref to http://physics.nist.gov/Comp (as of 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.atomicMasses()
</code></pre>


<h3>Value</h3>

<p>This function returns a numeric matrix with mass values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+massDeFormula">massDeFormula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.atomicMasses()
</code></pre>

<hr>
<h2 id='.checkKnitrProt'>Checking presence of knitr and rmarkdown</h2><span id='topic+.checkKnitrProt'></span>

<h3>Description</h3>

<p>This function allows checking presence of knitr and rmarkdown
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkKnitrProt(tryF = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkKnitrProt_+3A_tryf">tryF</code></td>
<td>
<p>(logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a logical value
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+presenceFilt">presenceFilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.checkKnitrProt()
</code></pre>

<hr>
<h2 id='.checkSetupGroups'>Additional/final chek and adjustments to sample-order after readSampleMetaData()</h2><span id='topic+.checkSetupGroups'></span>

<h3>Description</h3>

<p>This (low-level) function performs an additional/final chek &amp; adjustments to sample-names after readSampleMetaData()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkSetupGroups(
  abund,
  setupSd,
  gr = NULL,
  sampleNames = NULL,
  quantMeth = NULL,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checkSetupGroups_+3A_abund">abund</code></td>
<td>
<p>(matrix or data.frame) abundance data, only the colnames will be used</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_setupsd">setupSd</code></td>
<td>
<p>(list) describing sammple-setup, typically produced by   from package wrMisc</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_gr">gr</code></td>
<td>
<p>(factor) optional custom information about replicate-layout, has priority over setuoSd</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom sample-names, has priority over abund and setuoSd</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_quantmeth">quantMeth</code></td>
<td>
<p>(character) 2-letter abbreviation of name of quantitation-software (eg 'MQ')</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id=".checkSetupGroups_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an enlaged/updated list 'setupSd' (set setupSd$sampleNames,  setupSd$groups)
</p>


<h3>See Also</h3>

<p>used in <code>readProtDiscovererFile</code>,  <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readFragpipeFile">readFragpipeFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2021)
</code></pre>

<hr>
<h2 id='.commonSpecies'>Get matrix with UniProt abbreviations for selected species as well as simple names</h2><span id='topic+.commonSpecies'></span>

<h3>Description</h3>

<p>This (low-level) function allows accessing matrix with UniProt abbreviations for species frequently used in research.
This information may be used to harmonize species descriptions or extract species information out of protein-names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.commonSpecies()
</code></pre>


<h3>Value</h3>

<p>This function returns a 2-column matrix with species names
</p>


<h3>See Also</h3>

<p>used eg in <code>readProtDiscovererFile</code>,  <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readFragpipeFile">readFragpipeFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.commonSpecies()
</code></pre>

<hr>
<h2 id='.extrSpecPref'>Extract additional information to construct colum SpecType</h2><span id='topic+.extrSpecPref'></span>

<h3>Description</h3>

<p>This (low-level) function creates the column annot[,'SpecType'] which may help distinguishing different lines/proteins.
This information may, for example, be used to normalize only to all proteins of a common backgroud matrix (species).
If $mainSpecies or $conta: match to annot[,&quot;Species&quot;], annot[,&quot;EntryName&quot;], annot[,&quot;GeneName&quot;], if length==1 grep in  annot[,&quot;Species&quot;]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extrSpecPref(
  specPref,
  annot,
  useColumn = c("Species", "EntryName", "GeneName", "Accession"),
  suplInp = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extrSpecPref_+3A_specpref">specPref</code></td>
<td>
<p>(list) may contain $mainSpecies, $conta ...</p>
</td></tr>
<tr><td><code id=".extrSpecPref_+3A_annot">annot</code></td>
<td>
<p>(matrix) main protein annotation</p>
</td></tr>
<tr><td><code id=".extrSpecPref_+3A_usecolumn">useColumn</code></td>
<td>
<p>(factor) columns from annot to use/mine</p>
</td></tr>
<tr><td><code id=".extrSpecPref_+3A_suplinp">suplInp</code></td>
<td>
<p>(matrix) additional custom annotation</p>
</td></tr>
<tr><td><code id=".extrSpecPref_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".extrSpecPref_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging (starting with 'mainSpecies','conta' and others - later may overwrite prev settings)</p>
</td></tr>
<tr><td><code id=".extrSpecPref_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with additional column 'SpecType'
</p>


<h3>See Also</h3>

<p>used in <code>readProtDiscovererFile</code>,  <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readFragpipeFile">readFragpipeFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.commonSpecies()
</code></pre>

<hr>
<h2 id='.imputeNA'>Basic NA-imputaton (main)</h2><span id='topic+.imputeNA'></span>

<h3>Description</h3>

<p>This (lower-level) function allows to perfom the basic NA-imputaton.
Note, at this point the information from argument <code>gr</code> is not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.imputeNA(
  dat,
  gr = NULL,
  impParam,
  exclNeg = TRUE,
  inclLowValMod = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".imputeNA_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main data (may contain <code>NA</code>)</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_gr">gr</code></td>
<td>
<p>(character or factor) grouping of columns of <code>dat</code>, replicate association</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_impparam">impParam</code></td>
<td>
<p>(numeric) 1st for mean; 2nd for sd; 3rd for seed</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_exclneg">exclNeg</code></td>
<td>
<p>(logical) exclude negative</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_incllowvalmod">inclLowValMod</code></td>
<td>
<p>(logical) label on x-axis on plot</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_debug">debug</code></td>
<td>
<p>(logical) supplemental messages for debugging</p>
</td></tr>
<tr><td><code id=".imputeNA_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with <code>$data</code> and <code>$datImp</code>
</p>


<h3>See Also</h3>

<p>for more complex treatment <code><a href="#topic+matrixNAneighbourImpute">matrixNAneighbourImpute</a></code>;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- matrix(11:22, ncol=4)
dat1[3:4] &lt;- NA
.imputeNA(dat1, impParam=c(mean(dat1, na.rm=TRUE), 0.1))

</code></pre>

<hr>
<h2 id='.plotQuantDistr'>Generic plotting of density distribution for quantitation import-functions</h2><span id='topic+.plotQuantDistr'></span>

<h3>Description</h3>

<p>This (low-level) function allows (generic) plotting of density distribution for quantitation import-functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plotQuantDistr(
  abund,
  quant,
  custLay = NULL,
  normalizeMeth = NULL,
  softNa = NULL,
  refLi = NULL,
  refLiIni = NULL,
  notLogAbund = NA,
  figMarg = c(3.5, 3.5, 3, 1),
  tit = NULL,
  las = NULL,
  cexAxis = 0.8,
  nameSer = NULL,
  cexNameSer = NULL,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".plotQuantDistr_+3A_abund">abund</code></td>
<td>
<p>(matrix or data.frame) abundance data, will be plottes as distribution</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_quant">quant</code></td>
<td>
<p>(matrix or data.frame) optional additional abundance data, to plot 2nd distribution, eg of normalized data</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_custlay">custLay</code></td>
<td>
<p>(matrix) describing sammple-setup, typically produced by</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character, length=1) name of normalization method (will be displayed in title of figure)</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_softna">softNa</code></td>
<td>
<p>(character, length=1) name of quantitation-software (typically 2-letter abbreviation, eg 'MQ')</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_refli">refLi</code></td>
<td>
<p>(integer) to display number reference lines</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_refliini">refLiIni</code></td>
<td>
<p>(integer) to display initial number reference lines</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_notlogabund">notLogAbund</code></td>
<td>
<p>(logical) set to <code>TRUE</code> if <code>abund</code> is linear but should be plotted as log2</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_figmarg">figMarg</code></td>
<td>
<p>(numeric, length=4) custom figure margins (will be passed to <code><a href="graphics.html#topic+par">par</a></code>), defaults to c(3.5, 3.5, 3, 1)</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_tit">tit</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_las">las</code></td>
<td>
<p>(integer) indicate orientation of text in axes</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_cexaxis">cexAxis</code></td>
<td>
<p>(numeric) size of numeric axis labels as cex-expansion factor (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_nameser">nameSer</code></td>
<td>
<p>(character) custom label for data-sets or columns (length must match number of data-sets)</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_cexnameser">cexNameSer</code></td>
<td>
<p>(numeric) size of individual data-series labels as cex-expansion factor (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id=".plotQuantDistr_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns logical value (if data were valid for plotting) and produces a density dustribution figure (if data were found valid)
</p>


<h3>See Also</h3>

<p>used in <code>readProtDiscovererFile</code>,  <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readFragpipeFile">readFragpipeFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018);  datT8 &lt;- matrix(round(rnorm(800) +3,1), nc=8, dimnames=list(paste(
  "li",1:100,sep=""), paste(rep(LETTERS[1:3],c(3,3,2)),letters[18:25],sep="")))
.plotQuantDistr(datT8, quant=NULL, refLi=NULL, tit="Synthetic Data Distribution")                                
</code></pre>

<hr>
<h2 id='AAmass'>Molecular mass for amino-acids</h2><span id='topic+AAmass'></span>

<h3>Description</h3>

<p>Calculate molecular mass based on atomic composition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AAmass(massTy = "mono", inPept = TRUE, inclSpecAA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AAmass_+3A_massty">massTy</code></td>
<td>
<p>(character) 'mono' or 'average'</p>
</td></tr>
<tr><td><code id="AAmass_+3A_inpept">inPept</code></td>
<td>
<p>(logical) remove H20 corresponding to water loss at peptide bond formaton</p>
</td></tr>
<tr><td><code id="AAmass_+3A_inclspecaa">inclSpecAA</code></td>
<td>
<p>(logical) include ornithine O &amp; selenocysteine U</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector with masses for all amino-acids (argument 'massTy' to switch from mono-isotopic to average mass)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+massDeFormula">massDeFormula</a></code>, <code><a href="wrMisc.html#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>massDeFormula(c("12H12O","HO"," 2H 1 Se, 6C 2N","HSeCN"," ","e"))
AAmass()
</code></pre>

<hr>
<h2 id='AucROC'>AUC from ROC-curves</h2><span id='topic+AucROC'></span>

<h3>Description</h3>

<p>This function calculates the AUC (area under the curve) from ROC data in matrix of specificity and sensitivity values,
as provided in the output from  <code><a href="#topic+summarizeForROC">summarizeForROC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AucROC(
  dat,
  useCol = c("spec", "sens"),
  returnIfInvalid = NA,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AucROC_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main inut containig sensitivity and specificity data (from <code>summarizeForROC</code>)</p>
</td></tr>
<tr><td><code id="AucROC_+3A_usecol">useCol</code></td>
<td>
<p>(character or integer) column names to be used: 1st for specificity and 2nd for sensitivity count columns</p>
</td></tr>
<tr><td><code id="AucROC_+3A_returnifinvalid">returnIfInvalid</code></td>
<td>
<p>(<code>NA</code> or <code>NULL</code>) what to return if data for calculating ROC is invalid or incomplete</p>
</td></tr>
<tr><td><code id="AucROC_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="AucROC_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="AucROC_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix including imputed values or list of final and matrix with number of imputed by group (plus optional plot)
</p>


<h3>See Also</h3>

<p>preparing ROC data <code><a href="#topic+summarizeForROC">summarizeForROC</a></code>, (re)plot the ROC figure <code><a href="#topic+plotROC">plotROC</a></code>;
note that numerous other packages also provide support for working with ROC-curves : Eg <a href="https://CRAN.R-project.org/package=dlstats">rocPkgShort</a>,
<a href="https://CRAN.R-project.org/package=ROCR">ROCR</a>, <a href="https://CRAN.R-project.org/package=pROC">pROC</a> or <a href="https://CRAN.R-project.org/package=ROCit">ROCit</a>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019); test1 &lt;- list(annot=cbind(Species=c(rep("b",35), letters[sample.int(n=3,
  size=150,replace=TRUE)])), BH=matrix(c(runif(35,0,0.01), runif(150)), ncol=1))
roc1 &lt;- summarizeForROC(test1, spec=c("a","b","c"), annotCol="Species")
AucROC(roc1)
</code></pre>

<hr>
<h2 id='cleanListCoNames'>Selective batch cleaning of sample- (ie column-) names in list</h2><span id='topic+cleanListCoNames'></span>

<h3>Description</h3>

<p>This function allows to manipulate sample-names (ie colnames of abundance data) in a batch-wise manner from data stored as multiple matrixes or data.frames of a list.
Import functions such as <code>readMaxQuantFile()</code> organize initial flat files into lists (of matrixes) of the different types of data.
Many times all column names in such lists carry long names including redundant information, like the overall experiment name or date, etc.
The aim of this function is to facilitate 'cleaning' the sample- (ie column-) names to obtain short and concise names.
Character terms to be removed (via argument <code>rem</code>) and/or replaced/subsitituted (via argument <code>subst</code>) should be given as they are, characters with special behaviour in <code>grep</code> (like '.') will be protected internally.
Note, that the character substitution part will be done first, and the removal part (without character replacement) afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanListCoNames(
  dat,
  rem = NULL,
  subst = c("-", "_"),
  lstE = c("raw", "quant", "counts"),
  mathOper = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanListCoNames_+3A_dat">dat</code></td>
<td>
<p>(list) main input</p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_rem">rem</code></td>
<td>
<p>(character) character string to be removed, may be named 'left' and 'right' for more specific exact pattern matching
(this part will be perfomed before character substitutions by <code>subst</code>)</p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_subst">subst</code></td>
<td>
<p>(character of length=2, or matrix with 2 columns) pair(s) of character-strings for replacement (1st as search-item and 2nd as replacement); this part is performed after character-removal via <code>rem</code></p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_lste">lstE</code></td>
<td>
<p>(character, length=1) names of list-elements where colnames should be cleaned</p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_mathoper">mathOper</code></td>
<td>
<p>(character, length=1) optional mathematical operation on numerical part of sample-names (eg <code>mathOper='/2'</code> for deviding numeric part of colnames by 2)</p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="cleanListCoNames_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list (equivalent to input <code>dat</code>)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- matrix(1:12, ncol=4, dimnames=list(1:3, paste0("sample_R.",1:4)))
dat1 &lt;- list(raw=dat1, quant=dat1, notes="other..")
cleanListCoNames(dat1, rem=c(left="sample_"), c(".","-"))
</code></pre>

<hr>
<h2 id='combineMultFilterNAimput'>Combine Multiple Filters On NA-imputed Data</h2><span id='topic+combineMultFilterNAimput'></span>

<h3>Description</h3>

<p>In most omics data-analysis one needs to employ a certain number of filtering strategies to avoid getting artifacts to the step of statistical testing.
<code>combineMultFilterNAimput</code> takes on one side the origial data and on the other side NA-imputed data to create several differnet filters and to finally combine them.
A filter aiming to take away the least abundant values (using the imputede data) can be fine-tuned by the argument <code>abundThr</code>. 
This step compares the means for each group and line, at least one grou-mean has to be &gt; the threshold (based on hypothesis 
that if all conditions represent extrememy low measures their diffrenetial may not be determined with certainty).
In contrast, the filter addressing the number of missing values (<code>NA</code>) uses the original data, the arguments <code>colTotNa</code>,<code>minSpeNo</code> and <code>minTotNo</code> 
are used at this step. Basically, this step allows defining a minimum content of 'real' (ie non-NA) values for further considering the measurements as reliable.
This part uses internally <code><a href="wrMisc.html#topic+presenceFilt">presenceFilt</a></code> for filtering elevated content of <code>NA</code> per line.
Finally, this function combines both filters (as matrix of <code>FALSE</code> and <code>TRUE</code>) on NA-imputed and original data 
and retruns a vector of logical values if corresponding lines passe all filter criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineMultFilterNAimput(
  dat,
  imputed,
  grp,
  annDat = NULL,
  abundThr = NULL,
  colRazNa = NULL,
  colTotNa = NULL,
  minSpeNo = 1,
  minTotNo = 2,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineMultFilterNAimput_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main data (may contain <code>NA</code>)</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_imputed">imputed</code></td>
<td>
<p>(character)  same as 'dat' but with all <code>NA</code> imputed</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_grp">grp</code></td>
<td>
<p>(character or factor) define groups of replicates (in columns of 'dat')</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_anndat">annDat</code></td>
<td>
<p>(matrix or data.frame) annotation data (should match lines of 'dat')</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_abundthr">abundThr</code></td>
<td>
<p>(numeric) optional threshold filter for minimumn abundance</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_colrazna">colRazNa</code></td>
<td>
<p>(character) if razor peptides are used: column name for razor peptide count</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_coltotna">colTotNa</code></td>
<td>
<p>(character) column name for total peptide count</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_minspeno">minSpeNo</code></td>
<td>
<p>(integer) minimum number of specific peptides for maintaining proteins</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_mintotno">minTotNo</code></td>
<td>
<p>(integer) minimum total ie max razor number of peptides</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="combineMultFilterNAimput_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector of logical values if corresponding line passes filter criteria
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+presenceFilt">presenceFilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2013)
datT6 &lt;- matrix(round(rnorm(300)+3,1), ncol=6,
  dimnames=list(paste0("li",1:50), letters[19:24]))
datT6 &lt;- datT6 +matrix(rep(1:nrow(datT6),ncol(datT6)), ncol=ncol(datT6))
datT6[6:7,c(1,3,6)] &lt;- NA
datT6[which(datT6 &lt; 11 &amp; datT6 &gt; 10.5)] &lt;- NA
datT6[which(datT6 &lt; 6 &amp; datT6 &gt; 5)] &lt;- NA
datT6[which(datT6 &lt; 4.6 &amp; datT6 &gt; 4)] &lt;- NA
datT6b &lt;- matrixNAneighbourImpute(datT6, gr=gl(2,3))
datT6c &lt;- combineMultFilterNAimput(datT6, datT6b, grp=gl(2,3), abundThr=2)

</code></pre>

<hr>
<h2 id='convAASeq2mass'>Molecular mass for amino-acids</h2><span id='topic+convAASeq2mass'></span>

<h3>Description</h3>

<p>This function calculates the molecular mass of one-letter code amion-acid sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convAASeq2mass(
  x,
  massTy = "mono",
  seqName = TRUE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convAASeq2mass_+3A_x">x</code></td>
<td>
<p>(character) aminoacid sequence (single upper case letters for describing a peptide/protein)</p>
</td></tr>
<tr><td><code id="convAASeq2mass_+3A_massty">massTy</code></td>
<td>
<p>(character) default 'mono' for mono-isotopic masses (alternative 'average')</p>
</td></tr>
<tr><td><code id="convAASeq2mass_+3A_seqname">seqName</code></td>
<td>
<p>(logical) optional (alternative) names for the content of 'x' (ie aa seq) as name (always if 'x' has no names)</p>
</td></tr>
<tr><td><code id="convAASeq2mass_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="convAASeq2mass_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This functions returns a vector with masses for all amino-acids (argument 'massTy' to switch form mono-isotopic to average mass)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+massDeFormula">massDeFormula</a></code>, <code><a href="#topic+AAmass">AAmass</a></code>, <code><a href="wrMisc.html#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convAASeq2mass(c("PEPTIDE","fPROTEINES"))
pep1 &lt;- c(aa="AAAA", de="DEFDEF")
convAASeq2mass(pep1, seqN=FALSE)
</code></pre>

<hr>
<h2 id='corColumnOrder'>Order Columns in list of matrixes</h2><span id='topic+corColumnOrder'></span>

<h3>Description</h3>

<p>This function orders columns in list of matrixes (or matrix) according to argument <code>sampNames</code>.
This function can be used to adjust/correct the order of samples after reading data using <code>readMaxQuantFile()</code>, <code>readPDExport()</code> etc.
The input may also be MArrayLM-type object from package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> or from <code>moderTestXgrp</code> or <code>moderTest2grp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corColumnOrder(
  dat,
  replNames = NULL,
  sampNames,
  useListElem = c("quant", "raw", "counts"),
  annotElem = "sampleSetup",
  newNames = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corColumnOrder_+3A_dat">dat</code></td>
<td>
<p>(matrix, list or MArrayLM-object from limma) main input of which columns should get re-ordered, may be output from <code>moderTestXgrp</code> or <code>moderTest2grp</code>.</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_replnames">replNames</code></td>
<td>
<p>(character) new column-names (in order as input from <code>dat</code>), allows renaming colnames before defining new order</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_sampnames">sampNames</code></td>
<td>
<p>(character) column-names in desired order for output (must match colnames of <code>dat</code> or <code>replNames</code>, if used)</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_uselistelem">useListElem</code></td>
<td>
<p>(character) in case <code>dat</code> is list, all list-elements who's columns should get (re-)ordered</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_annotelem">annotElem</code></td>
<td>
<p>(character) name of list-element of <code>dat</code> with annotation data to get in new order</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_newnames">newNames</code></td>
<td>
<p>depreciated, plese use <code>replNames</code> instead</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="corColumnOrder_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of same class as input <code>dat</code>  (ie matrix, list or MArrayLM-object from limma)
</p>


<h3>See Also</h3>

<p><code>moderTestXgrp</code> for single comparisons; <code><a href="base.html#topic+order">order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grp &lt;- factor(rep(LETTERS[c(3,1,4)], c(2,3,3)))
dat1 &lt;- matrix(1:15, ncol=5, dimnames=list(NULL,c("D","A","C","E","B")))
corColumnOrder(dat1, sampNames=LETTERS[1:5])

dat1 &lt;- list(quant=dat1,raw=dat1)
  dat1
corColumnOrder(dat1, sampNames=LETTERS[1:5])
</code></pre>

<hr>
<h2 id='countNoOfCommonPeptides'>Compare in-silico digested proteomes for unique and shared peptides, counts per protein or as peptides
Compare in-silico digested proteomes for unique and shared peptides, counts per protein or as peptides.
The in-silico digestion may be performed separately using the package <a href="https://bioconductor.org/packages/release/bioc/html/cleaver.html">cleaver</a>.
Note: input must be list (or multiple names lists) of proteins with their respective peptides (eg by in-silico digestion).</h2><span id='topic+countNoOfCommonPeptides'></span>

<h3>Description</h3>

<p>Compare in-silico digested proteomes for unique and shared peptides, counts per protein or as peptides
</p>
<p>Compare in-silico digested proteomes for unique and shared peptides, counts per protein or as peptides.
The in-silico digestion may be performed separately using the package <a href="https://bioconductor.org/packages/release/bioc/html/cleaver.html">cleaver</a>.
Note: input must be list (or multiple names lists) of proteins with their respective peptides (eg by in-silico digestion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countNoOfCommonPeptides(
  ...,
  prefix = c("Hs", "Sc", "Ec"),
  sep = "_",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countNoOfCommonPeptides_+3A_...">...</code></td>
<td>
<p>(list) multiple lists of (ini-silico) digested proteins (typically protein ID as names) with their respectice peptides (AA sequence), one entry for each species</p>
</td></tr>
<tr><td><code id="countNoOfCommonPeptides_+3A_prefix">prefix</code></td>
<td>
<p>(character) optional (species-) prefix for entries in '...', will be only considered if '...' has no names</p>
</td></tr>
<tr><td><code id="countNoOfCommonPeptides_+3A_sep">sep</code></td>
<td>
<p>(character) concatenation symbol</p>
</td></tr>
<tr><td><code id="countNoOfCommonPeptides_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="countNoOfCommonPeptides_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="countNoOfCommonPeptides_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with $byPep as list of logical matrixes for each peptide (as line) and unique/shared/etc for each species; $byProt as list of matrixes with count data per proten (as line) for each species; $tab with simple summary-type count data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readFasta2">readFasta2</a></code> and/or <code>cleave-methods</code> in package <a href="https://bioconductor.org/packages/release/bioc/html/cleaver.html">cleaver</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The example mimics a proteomics experiment where extracts form E coli and 
## Saccharomyces cerevisiae were mixed, thus not all peptdes may occur unique.  
(mi2 = countNoOfCommonPeptides(Ec=list(E1=letters[1:4],E2=letters[c(3:7)],
  E3=letters[c(4,8,13)],E4=letters[9]),Sc=list(S1=letters[c(2:3,6)], 
  S2=letters[10:13],S3=letters[c(5,6,11)],S4=letters[c(11)],S5="n")))
##  a .. uni E, b .. inteR, c .. inteR(+intra E), d .. intra E  (no4), e .. inteR, 
##  f .. inteR +intra E   (no6), g .. uni E, h .. uni E  no 8), i .. uni E, 
##  j .. uni S (no10), k .. intra S  (no11), l .. uni S (no12), m .. inteR  (no13)
lapply(mi2$byProt,head)
mi2$tab
</code></pre>

<hr>
<h2 id='exportSdrfDraft'>Export Sample Meta-data from Quantification-Software as Sdrf-draft</h2><span id='topic+exportSdrfDraft'></span>

<h3>Description</h3>

<p>Sample/experimental annotation meta-data form <a href="https://www.maxquant.org/">MaxQuant</a> that was previously import can now be formatted in sdrf-style and exported
using this function to write a draft-sdrf-file. Please note that this information will not _complete_ in respect to all information used in data-bases like  Pride.
Sdrf-files provide additional meta-information about samles and MS-runs in a standardized format, they may also be part of submissions to <a href="https://www.ebi.ac.uk/pride/">Pride</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportSdrfDraft(
  lst,
  fileName = "sdrfDraft.tsv",
  correctFileExtension = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportSdrfDraft_+3A_lst">lst</code></td>
<td>
<p>(list) object created by import-function (MaxQuant)</p>
</td></tr>
<tr><td><code id="exportSdrfDraft_+3A_filename">fileName</code></td>
<td>
<p>(character) file-name (and path) to be used when exprting</p>
</td></tr>
<tr><td><code id="exportSdrfDraft_+3A_correctfileextension">correctFileExtension</code></td>
<td>
<p>(logical) if <code>TRUE</code> the fileName will get a <code>.tsv</code>-extension if not already present</p>
</td></tr>
<tr><td><code id="exportSdrfDraft_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="exportSdrfDraft_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="exportSdrfDraft_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gathering as much as possible information about samples and MS-runs requires that the additional files created from software, like MaxQuant using <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, 
is present and was imported when calling the import-function (eg using the argument _suplAnnotFile=TRUE_).
Please note that this functionality was designed for the case where no (external) sdrf-file is available. 
Thus, when data was imported including exteranl sdrf (uinsg the _sdrf=_ argument), exporting incomplete annotation-data from MaxQuant-produced files does not make any sense and therefore won't be possible.
</p>
<p>After exporting the draft sdrf the user is advised to check and complete the information in the resulting file.
Unfortunately, not all information present in a standard sdrf-file (like on <a href="https://www.ebi.ac.uk/pride/">Pride</a>) cannot be gathered automatically,
but key columns are already present and thus may facilitate completing.
Please note, that the file-format has been defined as <code>.tsv</code>, thus columns/fields should be separated by tabs.
At manual editing and completion, some editing- or tabulator-software may change the file-extesion to <code>.tsv.txt</code>,
in this case the final files should be renamed as <code>.tsv</code> to remain compatible with Pride.
</p>
<p>At this point only the import of data from MaxQuant via <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code> has been developed to extract information for creating a draft-sdrf.
Other data/file-import functions may be further developed to gather as much as possible equivalent information in the future.
</p>


<h3>Value</h3>

<p>This function writes an Sdrf draft to file
</p>


<h3>See Also</h3>

<p>This function may be used after reading/importig data by <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code> in absence of sdrf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
fiNaMQ &lt;- "proteinGroups.txt.gz"
dataMQ &lt;- readMaxQuantFile(path1, file=fiNaMQ, refLi="mainSpe", sdrf=FALSE, suplAnnotFile=TRUE)
## Here we'll write simply in the current temporary directory of this R-session
exportSdrfDraft(dataMQ, file.path(tempdir(),"testSdrf.tsv"))

</code></pre>

<hr>
<h2 id='extractTestingResults'>Extract Results From Moderated t-tests</h2><span id='topic+extractTestingResults'></span>

<h3>Description</h3>

<p>This function allows convenient access to results produced using the functions <code>moderTest2grp</code> or <code>moderTestXgrp</code>.
The user can define the threshold which type of multiple testing correction should be used
(as long as the  multiple testing correction method was actually performed as part of testing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTestingResults(
  stat,
  compNo = 1,
  statTy = "BH",
  thrsh = 0.05,
  FCthrs = 1.5,
  annotCol = c("Accession", "EntryName", "GeneName"),
  nSign = 6,
  addTy = c("allMeans"),
  filename = NULL,
  fileTy = "csvUS",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractTestingResults_+3A_stat">stat</code></td>
<td>
<p>('MArrayLM'-object or list) Designed for the output from <code>moderTest2grp</code> or <code>moderTestXgrp</code></p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_compno">compNo</code></td>
<td>
<p>(integer) the comparison number/index to be used</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_statty">statTy</code></td>
<td>
<p>(character) the multiple-testing correction type to be considered when looking for significant changes  with threshold <code>thrsh</code> (depends on which have been run initially with <code>moderTest2grp</code> or <code>moderTestXgrp</code>)</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_thrsh">thrsh</code></td>
<td>
<p>(numeric) the threshold to be applied on <code>statTy</code> for the result of the statistcal testing (after multiple testing correction)</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_fcthrs">FCthrs</code></td>
<td>
<p>(numeric) Fold-Change threshold given as Fold-change and NOT log2(FC), default at 1.5 (for filtering at M-value =0.585)</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column-names from the annotation to be included</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_nsign">nSign</code></td>
<td>
<p>(integer) number of significant digits whe returning results</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_addty">addTy</code></td>
<td>
<p>(character) additional groups to add (so far only &quot;allMeans&quot; available) in addition to the means used in the pairwise comparison</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_filename">filename</code></td>
<td>
<p>(character) optional (path and) file-name for exporting results to csv-file</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_filety">fileTy</code></td>
<td>
<p>(character) file-type to be used with argument <code>filename</code>, may be 'csvEur' or 'csvUS'</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="extractTestingResults_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a limma-type MA-object (which can be handeled like a list)
</p>


<h3>See Also</h3>

<p><code>moderTest2grp</code> for single comparisons, <code>moderTestXgrp</code> for multiple comparisons, <code><a href="limma.html#topic+lmFit">lmFit</a></code> and the <code>eBayes</code>-family of functions in package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grp &lt;- factor(rep(LETTERS[c(3,1,4)],c(2,3,3)))
set.seed(2017); t8 &lt;- matrix(round(rnorm(208*8,10,0.4),2), ncol=8,
  dimnames=list(paste(letters[],rep(1:8,each=26),sep=""), paste(grp,c(1:2,1:3,1:3),sep="")))
t8[3:6,1:2] &lt;- t8[3:6,1:2] +3                    # augment lines 3:6 (c-f) 
t8[5:8,c(1:2,6:8)] &lt;- t8[5:8,c(1:2,6:8)] -1.5    # lower lines 
t8[6:7,3:5] &lt;- t8[6:7,3:5] +2.2                  # augment lines 
## expect to find C/A in c,d,g, (h)
## expect to find C/D in c,d,e,f
## expect to find A/D in f,g,(h) 
library(wrMisc)     # for testing we'll use this package
test8 &lt;- moderTestXgrp(t8, grp) 
extractTestingResults(test8)
</code></pre>

<hr>
<h2 id='extrSpeciesAnnot'>Extract species annotation</h2><span id='topic+extrSpeciesAnnot'></span>

<h3>Description</h3>

<p><code>extrSpeciesAnnot</code> identifies species-related annotation (as suffix to identifyers) for data comnining multiple species and returns alternative (short) names.  
This function also suppresses extra heading or tailing space or punctuation characters.
In case multiple tags are found, the last tag is reported and a message of alert may be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrSpeciesAnnot(
  annot,
  spec = c("_CONT", "_HUMAN", "_YEAST", "_ECOLI"),
  shortNa = c("cont", "H", "S", "E"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrSpeciesAnnot_+3A_annot">annot</code></td>
<td>
<p>(character) vector with initial annotation</p>
</td></tr>
<tr><td><code id="extrSpeciesAnnot_+3A_spec">spec</code></td>
<td>
<p>(character) the tags to be identified</p>
</td></tr>
<tr><td><code id="extrSpeciesAnnot_+3A_shortna">shortNa</code></td>
<td>
<p>(character) the final abbreviation used, order and lengt must fit to argument <code>annot</code></p>
</td></tr>
<tr><td><code id="extrSpeciesAnnot_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="extrSpeciesAnnot_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="extrSpeciesAnnot_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a character vector with single (last of multiple) term if found in argument <code>annot</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec &lt;- c("keratin_CONT","AB_HUMAN","CD_YEAST","EF_G_HUMAN","HI_HUMAN_ECOLI","_YEAST_012")
extrSpeciesAnnot(spec) 
</code></pre>

<hr>
<h2 id='foldChangeArrow2'>Add arrow for expected Fold-Change to VolcanoPlot or MA-plot</h2><span id='topic+foldChangeArrow2'></span>

<h3>Description</h3>

<p>NOTE : This function is deprecated, please use <code><a href="wrGraph.html#topic+foldChangeArrow">foldChangeArrow</a></code> instead !!
This function was made for adding an arrow indicating a fold-change to MA- or Volcano-plots. 
When comparing mutiple concentratios of standards in benchmark-tests it may be useful to indicate the expected ratio in a pair-wise comparison.
In case of main input as list or MArrayLM-object (as generated from limma), the colum-names of multiple pairwise comparisons can be used 
for extracting a numeric content (supposed as concentrations in sample-names) which will be used to determine the expected ratio used for plotting. 
Optionally the ratio used for plotting can be returned as numeric value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldChangeArrow2(
  FC,
  useComp = 1,
  isLin = TRUE,
  asX = TRUE,
  col = 1,
  arr = c(0.005, 0.15),
  lwd = NULL,
  addText = c(line = -0.9, cex = 0.7, txt = "expected", loc = "toright"),
  returnRatio = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldChangeArrow2_+3A_fc">FC</code></td>
<td>
<p>(numeric, list or MArrayLM-object) main information for drawing arrow : either numeric value for fold-change/log2-ratio of object to search for colnames of statistical testing for extracting numeric part</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_usecomp">useComp</code></td>
<td>
<p>(integer) only used in case FC is list or MArrayLM-object an has multiple pairwise-comparisons</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_islin">isLin</code></td>
<td>
<p>(logical) inidicate if <code>FC</code> is log2 or not</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_asx">asX</code></td>
<td>
<p>(logical) indicate if arrow should be on x-axis</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_col">col</code></td>
<td>
<p>(integer or character) custom color</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_arr">arr</code></td>
<td>
<p>(numeric, length=2) start- and end-points of arrow (as relative to entire plot)</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_lwd">lwd</code></td>
<td>
<p>(numeric) line-width of arrow</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_addtext">addText</code></td>
<td>
<p>(logical or named vector) indicate if text explaining arrow should be displayed, use <code>TRUE</code> for default (on top right of plot), 
or any combination of 'loc','line','cex','side','adj','col','text' (or 'txt') for customizing specific elements</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_returnratio">returnRatio</code></td>
<td>
<p>(logical) return ratio</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="foldChangeArrow2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>addText</code> also allows specifying a fixed position when using <code>addText=c(loc="bottomleft")</code>, also bottomright, topleft, topright, toleft and toright may be used.
In this case the elemts <code>side</code> and <code>adjust</code> will be redefined to accomodate the text in the corner specified. 
</p>
<p>Ultimately this function will be integated to the package wrGraph.
</p>


<h3>Value</h3>

<p>plots arrow only (and explicative text), if <code>returnRatio=TRUE</code> also returns numeric value for extracted ratio
</p>


<h3>See Also</h3>

<p>new version : <code><a href="wrGraph.html#topic+foldChangeArrow">foldChangeArrow</a></code>; used with <code><a href="wrGraph.html#topic+MAplotW">MAplotW</a></code>, <code><a href="wrGraph.html#topic+VolcanoPlotW">VolcanoPlotW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(rnorm(20,1.5,0.1),1:20)
#deprecated# foldChangeArrow2(FC=1.5) 

</code></pre>

<hr>
<h2 id='fuseProteomicsProjects'>Combine Multiple Proteomics Data-Sets</h2><span id='topic+fuseProteomicsProjects'></span>

<h3>Description</h3>

<p>This function allows combining up to 3 separate data-sets previously imported using wrProteo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuseProteomicsProjects(
  x,
  y,
  z = NULL,
  columnNa = "Accession",
  NA.rm = TRUE,
  listNa = c(quant = "quant", annot = "annot"),
  all = FALSE,
  textModif = NULL,
  shortNa = NULL,
  retProtLst = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuseProteomicsProjects_+3A_x">x</code></td>
<td>
<p>(list) First Proteomics data-set</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_y">y</code></td>
<td>
<p>(list) Second Proteomics data-set</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_z">z</code></td>
<td>
<p>(list) optional third Proteomics data-set</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_columnna">columnNa</code></td>
<td>
<p>(character) column names from annotation</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_na.rm">NA.rm</code></td>
<td>
<p>(logical) remove <code>NA</code>s</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_listna">listNa</code></td>
<td>
<p>(character) names of key list-elemnts from <code>x</code> to be treated; the first one is used as pattern for the format of quantitation data, 
,  the last one for the annotation data</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_all">all</code></td>
<td>
<p>(logical) union of intersect or merge should be performed between x, y and z</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_textmodif">textModif</code></td>
<td>
<p>(character) Additional modifications to the identifiers from argument <code>columnNa</code>; 
so far intregrated: <code>rmPrecAA</code> for removing preceeding caps letters (amino-acids, eg [KR].AGVIFPVGR.[ML] =&gt; AGVIFPVGR) 
or <code>rmTerminalDigit</code> for removing terminal digits (charge-states)</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_shortna">shortNa</code></td>
<td>
<p>(character) for appending to output-colnames</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_retprotlst">retProtLst</code></td>
<td>
<p>(logical) return list-object similar to input, otherwise a matrix of fused/aligned quantitation data</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="fuseProteomicsProjects_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some quantification software way give some identifyers multiple times, ie as multiple lines (eg for different modifictions or charge states, etc).
In this case this function tries first to summarize all lines with identical identifyers (using the function <code><a href="wrMisc.html#topic+combineRedundLinesInList">combineRedundLinesInList</a></code>
which used by default the median value). 
Thus, it is very important to know your data and to understand when lines that appear with the same identifyers should/may be fused/summarized without 
doing damage to the later biological interpretation ! The user may specify for each dataset the colum out of the protein/peptide-annotation to use
via the argument <code>columnNa</code>. 
Then, this content will be matched as identical match, so when combining data from different software special care shoud be taken !
</p>
<p>Please note, that (at this point) the data from different series/objects will be joined as they are, ie without any additional normalization.
It is up to the user to inspect the resulting data and to decide if and which type of normalization may be suitable !
</p>
<p>Please do NOT try combining protein and peptide quntification data.
</p>


<h3>Value</h3>

<p>This function returns a list with the same number of list-elements as  <code>$x</code>, ie typically this contains :
<code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, 
<code>$annot</code>, optionally <code>$counts</code> an array with number of peptides, <code>$quantNotes</code> or <code>$notes</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
dataMQ &lt;- readMaxQuantFile(path1, specPref=NULL, normalizeMeth="median")
MCproFi1 &lt;- "tinyMC.RData"
dataMC &lt;- readMassChroQFile(path1, file=MCproFi1, plotGraph=FALSE)
dataFused &lt;- fuseProteomicsProjects(dataMQ, dataMC)
dim(dataMQ$quant)
dim(dataMC$quant)
dim(dataFused$quant)
</code></pre>

<hr>
<h2 id='getUPS1acc'>Accession-Numbers And Names Of UPS-1 Proteins</h2><span id='topic+getUPS1acc'></span>

<h3>Description</h3>

<p><a href="https://www.sigmaaldrich.com/FR/en/product/sigma/ups1">UPS-1</a> and UPS-2 are mix of 48 of human proteins frequently used 
as standard in spike-in experiments. They are comercially available from Sigma-Aldrich.
This function allows accessing their accession-numbers and associated Names on <a href="https://www.uniprot.org/">UniProt</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUPS1acc()
</code></pre>


<h3>Value</h3>

<p>This function returns data.frame with accession-numbers as stated by the supplier (<code>$acFull</code>),
trimmed accession-numbers, ie without version numbers (<code>$ac</code>) 
and associated (<code>UniProt</code>) names on <a href="https://www.uniprot.org/">UniProt</a> as well as the species designation for the collection of 48 human UPS-1 proteins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(getUPS1acc())
</code></pre>

<hr>
<h2 id='isolNAneighb'>Isolate NA-neighbours</h2><span id='topic+isolNAneighb'></span>

<h3>Description</h3>

<p>This functions extracts all replicate-values where at least one of the replicates is <code>NA</code> and sorts by number of <code>NA</code>s per group.
A list with all <code>NA</code>-neighbours organized by the number of <code>NA</code>s gets returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolNAneighb(mat, gr, silent = FALSE, debug = FALSE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolNAneighb_+3A_mat">mat</code></td>
<td>
<p>(matrix or data.frame) main data (may contain <code>NA</code>)</p>
</td></tr>
<tr><td><code id="isolNAneighb_+3A_gr">gr</code></td>
<td>
<p>(character or factor) grouping of columns of 'mat', replicate association</p>
</td></tr>
<tr><td><code id="isolNAneighb_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="isolNAneighb_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="isolNAneighb_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with NA-neighbours sorted by number of NAs in replicate group
</p>


<h3>See Also</h3>

<p>This function gets used by <code><a href="#topic+matrixNAneighbourImpute">matrixNAneighbourImpute</a></code> and <code><a href="#topic+testRobustToNAimputation">testRobustToNAimputation</a></code>; estimation of mode <code><a href="wrMisc.html#topic+stableMode">stableMode</a></code>; detection of NAs <code><a href="stats.html#topic+na.fail">na.fail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- c(22.2, 22.5, 22.2, 22.2, 21.5, 22.0, 22.1, 21.7, 21.5, 22, 22.2, 22.7,
  NA, NA, NA, NA, NA, NA, NA, 21.2,   NA, NA, NA, NA,
  NA, 22.6, 23.2, 23.2,  22.4, 22.8, 22.8, NA,  23.3, 23.2, NA, 23.7,
  NA, 23.0, 23.1, 23.0,  23.2, 23.2, NA, 23.3,  NA, NA, 23.3, 23.8)
mat1 &lt;- matrix(mat1, ncol=12, byrow=TRUE)
gr4 &lt;- gl(3, 4)
isolNAneighb(mat1, gr4)
</code></pre>

<hr>
<h2 id='massDeFormula'>Molecular mass from chemical formula</h2><span id='topic+massDeFormula'></span>

<h3>Description</h3>

<p>Calculate molecular mass based on atomic composition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>massDeFormula(
  comp,
  massTy = "mono",
  rmEmpty = FALSE,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="massDeFormula_+3A_comp">comp</code></td>
<td>
<p>(character) atomic compostion</p>
</td></tr>
<tr><td><code id="massDeFormula_+3A_massty">massTy</code></td>
<td>
<p>(character) 'mono' or 'average'</p>
</td></tr>
<tr><td><code id="massDeFormula_+3A_rmempty">rmEmpty</code></td>
<td>
<p>(logical) suppress empty entries</p>
</td></tr>
<tr><td><code id="massDeFormula_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="massDeFormula_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a numeric vector with mass
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>massDeFormula(c("12H12O","HO"," 2H 1 Se, 6C 2N","HSeCN"," ","e"))
</code></pre>

<hr>
<h2 id='matrixNAinspect'>Histogram of content of NAs in matrix</h2><span id='topic+matrixNAinspect'></span>

<h3>Description</h3>

<p><code>matrixNAinspect</code> makes histograms of the full data and shows sub-population of <code>NA</code>-neighbour values.  
The aim of this function is to investigate the nature of <code>NA</code> values in matrix (of experimental measures) where replicate measurements are available.
If a given element was measured twice, and one of these measurements revealed a <code>NA</code> while the other one gave a (finite) numeric value, the non-NA-value is considered a <code>NA</code>-neighbour.  
The subpopulation of these <code>NA</code>-neighbour values will then be highlighted in the resulting histogram.
In a number of experimental settiongs some actual measurements may not meet an arbitrary defined baseline (as 'zero') or may be too low to be distinguishable from noise that 
associated measures were initially recorded as <code>NA</code>. In several types of measurments in proteomics and transcriptomics this may happen.
So this fucntion allows to collect all <code>NA</code>-neighbour values and compare them to the global distribution of the data to investigate if <code>NA</code>-neighbours are typically very low values.
In case of data with multiple replicates <code>NA</code>-neighbour values may be distinguished for the case of 2 <code>NA</code> per group/replicate-set.
The resulting plots are typically used to decide if and how <code>NA</code> values may get replaced by imputed random values or wether measues containing <code>NA</code>-values should rather me omitted.
Of course, such decisions do have a strong impact on further steps of data-analysis and should be performed with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixNAinspect(
  dat,
  gr = NULL,
  retnNA = TRUE,
  xLab = NULL,
  tit = NULL,
  xLim = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixNAinspect_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main numeric data</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_gr">gr</code></td>
<td>
<p>(charcter or factor) grouping of columns of dat indicating who is a replicate of whom (ie the length of 'gr' must be equivalent to the number of columns in 'dat')</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_retnna">retnNA</code></td>
<td>
<p>(logical) report number of NAs in graphic</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_xlab">xLab</code></td>
<td>
<p>(character) custom x-label</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_tit">tit</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_xlim">xLim</code></td>
<td>
<p>(numerical,length=2) custom x-axis limits</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="matrixNAinspect_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function produces a graphic (to the current graphical device)
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="stats.html#topic+na.fail">na.fail</a></code>, <code><a href="wrMisc.html#topic+naOmit">naOmit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2013)
datT6 &lt;- matrix(round(rnorm(300)+3,1), ncol=6, 
  dimnames=list(paste("li",1:50,sep=""), letters[19:24]))
datT6 &lt;- datT6 +matrix(rep(1:nrow(datT6),ncol(datT6)), ncol=ncol(datT6))
datT6[6:7,c(1,3,6)] &lt;- NA
datT6[which(datT6 &lt; 11 &amp; datT6 &gt; 10.5)] &lt;- NA
datT6[which(datT6 &lt; 6 &amp; datT6 &gt; 5)] &lt;- NA
datT6[which(datT6 &lt; 4.6 &amp; datT6 &gt; 4)] &lt;- NA
matrixNAinspect(datT6, gr=gl(2,3)) 
</code></pre>

<hr>
<h2 id='matrixNAneighbourImpute'>Imputation of NA-values based on non-NA replicates</h2><span id='topic+matrixNAneighbourImpute'></span>

<h3>Description</h3>

<p>It is assumed that <code>NA</code>-values appear in data when quantitation values are very low (as this appears eg in quantitative shotgun proteomics).
Here, the concept of (technical) replicates is used to investigate what kind of values appear in the other replicates next to NA-values for the same line/protein.
Groups of replicate samples  are defined via argument <code>gr</code> which descibes the columns of <code>dat</code>).
Then, they are inspected for each line to gather NA-neighbour values (ie those values where NAs and regular measures are observed the same time).
Eg, let's consider a line contains a set of 4 replicates for a given group. Now, if 2 of them are <code>NA</code>-values, the remaining 2 non-<code>NA</code>-values will be considered as NA-neighbours.
Ultimately, the aim is to replaces all <code>NA</code>-values based on values from a normal distribution ressembling theire respective NA-neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixNAneighbourImpute(
  dat,
  gr,
  imputMethod = "mode2",
  retnNA = TRUE,
  avSd = c(0.15, 0.5),
  avSdH = NULL,
  NAneigLst = NULL,
  plotHist = c("hist", "mode"),
  xLab = NULL,
  xLim = NULL,
  yLab = NULL,
  yLim = NULL,
  tit = NULL,
  figImputDetail = TRUE,
  seedNo = NULL,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixNAneighbourImpute_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main data (may contain <code>NA</code>)</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_gr">gr</code></td>
<td>
<p>(character or factor) grouping of columns of 'dat', replicate association</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_imputmethod">imputMethod</code></td>
<td>
<p>(character) choose the imputation method (may be 'mode2'(default), 'mode1', 'datQuant', 'modeAdopt' or 'informed')</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_retnna">retnNA</code></td>
<td>
<p>(logical) decide (if =<code>TRUE</code>) only NA-substuted data should be returned, or if list with $data, $nNA, $NAneighbour and $randParam should be returned</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_avsd">avSd</code></td>
<td>
<p>(numerical,length=2) population characteristics 'high' (mean and sd) for &gt;1 <code>NA</code>-neighbours (per line)</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_avsdh">avSdH</code></td>
<td>
<p>depreciated, please use <code>avSd</code> inestad; (numerical,length=2) population characteristics 'high' (mean and sd) for &gt;1 <code>NA</code>-neighbours (per line)</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_naneiglst">NAneigLst</code></td>
<td>
<p>(list) option for repeated rounds of imputations: list of <code>NA</code>-neighbour values can be furnished for slightly faster processing</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_plothist">plotHist</code></td>
<td>
<p>(character or logical) decide if supplemental figure with histogram shoud be drawn, the details 'Hist','quant' (display quantile of originak data), 'mode' (display mode of original data) can be chosen explicitely</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_xlab">xLab</code></td>
<td>
<p>(character) label on x-axis on plot</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_xlim">xLim</code></td>
<td>
<p>(numeric, length=2) custom x-axis limits</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_ylab">yLab</code></td>
<td>
<p>(character) label on y-axis on plot</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_ylim">yLim</code></td>
<td>
<p>(numeric, length=2) custom y-axis limits</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_tit">tit</code></td>
<td>
<p>(character) title on plot</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_figimputdetail">figImputDetail</code></td>
<td>
<p>(logical) display details about data (number of NAs) and imputation in graph (min number of NA-neighbours per protein and group, quantile to model, mean and sd of imputed)</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_seedno">seedNo</code></td>
<td>
<p>(integer) seed-value for normal random values</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="matrixNAneighbourImpute_+3A_debug">debug</code></td>
<td>
<p>(logical) supplemental messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default a histogram gets plotted showing the initial, imputed and final distribution to check the global hypothesis that <code>NA</code>-values arose
from very low measurements and to appreciate the impact of the imputed values to the overall final distribution.
</p>
<p>There are a number of experimental settings where low measurements may be reported as <code>NA</code>.
Sometimes an arbitrary defined baseline (as 'zero') may provoke those values found below being unfortunately reported as <code>NA</code> or as 0 (in case of MaxQuant).
In quantitative proteomics (DDA-mode) the presence of numerous high-abundance peptides will lead to the fact that a number of less
intense MS-peaks don't get identified properly and will then be reported as <code>NA</code> in the respective samples,
while the same peptides may by correctly identified and quantified in other (replicate) samples.
So, if a given protein/peptide gets properly quantified in some replicate samples but reported as <code>NA</code> in other replicate samples
one may thus speculate that similar values like in the successful quantifications may have occored.
Thus, imputation of <code>NA</code>-values may be done on the basis of <code>NA</code>-neighbours.
</p>
<p>When extracting <code>NA</code>-neighbours, a slightly more focussed approach gets checked, too, the 2-<code>NA</code>-neighbours : In case a set of replicates for a given protein
contains at least 2 non-<code>NA</code>-values (instead of just one) it will be considered as a (min) 2-<code>NA</code>-neighbour as well as regular <code>NA</code>-neighbour.
If &gt;300 of these (min) 2-<code>NA</code>-neighbours get found, they will be used instead of the regular <code>NA</code>-neighbours.
For creating a collection of normal random values one may use directly the mode of the <code>NA</code>-neighbours (or 2-<code>NA</code>-neighbours, if &gt;300 such values available).
To do so, the first value of argument <code>avSd</code> must be set to <code>NA</code>. Otherwise, the first value <code>avSd</code> will be used as quantile of all data to define the mean
for the imputed data (ie as <code>quantile(dat, avSd[1], na.rm=TRUE)</code>). The sd for generating normal random values will be taken from the sd of all  <code>NA</code>-neighbours (or 2-<code>NA</code>-neighbours)
multiplied by the second value in argument <code>avSd</code> (or <code>avSd</code>, if &gt;300 2-<code>NA</code>-neighbours), since the sd of the <code>NA</code>-neighbours is usually quite high.
In extremely rare cases it may happen that no <code>NA</code>-neighbours are found (ie if <code>NA</code>s occur, all replicates are <code>NA</code>).
Then, this function replaces <code>NA</code>-values based on the normal random values obtained as dscribed above.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$data</code> .. matrix of data where <code>NA</code> are replaced by imputed values, <code>$nNA</code> .. number of <code>NA</code> by group, <code>$randParam</code> .. parameters used for making random data
</p>


<h3>See Also</h3>

<p>this function gets used by <code><a href="#topic+testRobustToNAimputation">testRobustToNAimputation</a></code>; estimation of mode <code><a href="wrMisc.html#topic+stableMode">stableMode</a></code>; detection of NAs <code><a href="stats.html#topic+na.fail">na.fail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2013)
datT6 &lt;- matrix(round(rnorm(300)+3,1), ncol=6, dimnames=list(paste("li",1:50,sep=""),
  letters[19:24]))
datT6 &lt;- datT6 +matrix(rep(1:nrow(datT6), ncol(datT6)), ncol=ncol(datT6))
datT6[6:7, c(1,3,6)] &lt;- NA
datT6[which(datT6 &lt; 11 &amp; datT6 &gt; 10.5)] &lt;- NA
datT6[which(datT6 &lt; 6 &amp; datT6 &gt; 5)] &lt;- NA
datT6[which(datT6 &lt; 4.6 &amp; datT6 &gt; 4)] &lt;- NA
datT6b &lt;- matrixNAneighbourImpute(datT6, gr=gl(2,3))
head(datT6b$data)
</code></pre>

<hr>
<h2 id='plotROC'>Plot ROC curves</h2><span id='topic+plotROC'></span>

<h3>Description</h3>

<p><code>plotROC</code> plots ROC curves based on results from <code><a href="#topic+summarizeForROC">summarizeForROC</a></code>.
This function plots only, it does not return any data. It allows printing simultaneously multiple ROC curves from different studies,
it is also compatible with data from 3 species mix as in proteomics benchmark.
Input can be prepared using <code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code> followed by <code><a href="#topic+summarizeForROC">summarizeForROC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotROC(
  dat,
  ...,
  useColumn = 2:3,
  methNames = NULL,
  col = NULL,
  pch = 1,
  bg = NULL,
  tit = NULL,
  xlim = NULL,
  ylim = NULL,
  point05 = 0.05,
  pointSi = 0.85,
  nByMeth = NULL,
  speciesOrder = NULL,
  txtLoc = NULL,
  legCex = 0.72,
  las = 1,
  addSuplT = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotROC_+3A_dat">dat</code></td>
<td>
<p>(matrix) from testing (eg  <code><a href="#topic+summarizeForROC">summarizeForROC</a></code> )</p>
</td></tr>
<tr><td><code id="plotROC_+3A_...">...</code></td>
<td>
<p>optional additional data-sets to include as seprate ROC-curves to same plot (must be of same type of format as 'dat')</p>
</td></tr>
<tr><td><code id="plotROC_+3A_usecolumn">useColumn</code></td>
<td>
<p>(integer or character, length=2) columns from <code>dat</code> to be used for pecificity and sensitivity</p>
</td></tr>
<tr><td><code id="plotROC_+3A_methnames">methNames</code></td>
<td>
<p>(character) names of methods (data-sets) to be displayed</p>
</td></tr>
<tr><td><code id="plotROC_+3A_col">col</code></td>
<td>
<p>(character) custom colors for lines and text (choose one color for each different data-set)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_pch">pch</code></td>
<td>
<p>(integer) type of symbol to be used (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_bg">bg</code></td>
<td>
<p>(character) background color in plot (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_tit">tit</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id="plotROC_+3A_xlim">xlim</code></td>
<td>
<p>(numeric, length=2) custom x-axis limits</p>
</td></tr>
<tr><td><code id="plotROC_+3A_ylim">ylim</code></td>
<td>
<p>(numeric, length=2) custom y-axis limits</p>
</td></tr>
<tr><td><code id="plotROC_+3A_point05">point05</code></td>
<td>
<p>(numeric) specific point to highlight in plot (typically at alpha=0.05)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_pointsi">pointSi</code></td>
<td>
<p>(numeric) size of points (as expansion factor <code>cex</code>)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_nbymeth">nByMeth</code></td>
<td>
<p>(integer) value of n to display</p>
</td></tr>
<tr><td><code id="plotROC_+3A_speciesorder">speciesOrder</code></td>
<td>
<p>(integer) custom order of species in legend</p>
</td></tr>
<tr><td><code id="plotROC_+3A_txtloc">txtLoc</code></td>
<td>
<p>(numeric, length=3) location for text (x, y location and proportional factor for line-offset, default is c(0.4,0.3,0.04))</p>
</td></tr>
<tr><td><code id="plotROC_+3A_legcex">legCex</code></td>
<td>
<p>(numeric) cex expansion factor for legend (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_las">las</code></td>
<td>
<p>(numeric) factor for text-orientation (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="plotROC_+3A_addsuplt">addSuplT</code></td>
<td>
<p>(logical) add text with information about precision,accuracy and FDR</p>
</td></tr>
<tr><td><code id="plotROC_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="plotROC_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="plotROC_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns only a plot with ROC curves
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summarizeForROC">summarizeForROC</a></code>, <code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roc0 &lt;- cbind(alph=c(2e-6,4e-5,4e-4,2.7e-3,1.6e-2,4.2e-2,8.3e-2,1.7e-1,2.7e-1,4.1e-1,5.3e-1,
	 6.8e-1,8.3e-1,9.7e-1), spec=c(1,1,1,1,0.957,0.915,0.915,0.809,0.702,0.489,0.362,0.234,
  0.128,0.0426), sens=c(0,0,0.145,0.942,2.54,2.68,3.33,3.99,4.71,5.87,6.67,8.04,8.77,
  9.93)/10, n.pos.a=c(0,0,0,0,2,4,4,9,14,24,36,41) )
plotROC(roc0)
</code></pre>

<hr>
<h2 id='razorNoFilter'>Filter based on either number of total peptides and specific peptides or number of razor petides</h2><span id='topic+razorNoFilter'></span>

<h3>Description</h3>

<p><code>razorNoFilter</code> filters based on either a) number of total peptides and specific peptides or b) numer of razor petides.
This function was designed for filtering using a mimimum number of (PSM-) count values following the common practice to consider results with 2 or more peptide counts as reliable. 
The function be (re-)run independently on each of various questions (comparisons).
Note: Non-integer data will be truncated to integer (equivalent to  <code>floor</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>razorNoFilter(
  annot,
  speNa = NULL,
  totNa = NULL,
  minRazNa = NULL,
  minSpeNo = 1,
  minTotNo = 2,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="razorNoFilter_+3A_annot">annot</code></td>
<td>
<p>(matrix or data.frame) main data (may contain NAs) with (PSM-) count values for each protein</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_spena">speNa</code></td>
<td>
<p>(integer or character) indicate which column of 'annot' has number of specific peptides</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_totna">totNa</code></td>
<td>
<p>(integer or character) indicate which column of 'annot' has number of total peptides</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_minrazna">minRazNa</code></td>
<td>
<p>(integer or character) name of column with number of razor peptides, alternative to 'minSpeNo'&amp; 'minTotNo'</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_minspeno">minSpeNo</code></td>
<td>
<p>(integer) minimum number of pecific peptides</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_mintotno">minTotNo</code></td>
<td>
<p>(integer) minimum total ie max razor number of peptides</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="razorNoFilter_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector of logical values if corresponding line passes filter criteria
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+presenceFilt">presenceFilt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019); datT &lt;- matrix(sample.int(20,60,replace=TRUE), ncol=6,
  dimnames=list(letters[1:10], LETTERS[1:6])) -3
datT[,2] &lt;- datT[,2] +2
datT[which(datT &lt;0)] &lt;- 0
razorNoFilter(datT, speNa="A", totNa="B")
</code></pre>

<hr>
<h2 id='readAlphaPeptFile'>Read (Normalized) Quantitation Data Files Produced By AlphaPept</h2><span id='topic+readAlphaPeptFile'></span>

<h3>Description</h3>

<p>Protein quantification results from <a href="https://github.com/MannLabs/alphapept">AlphaPept</a> can be read using this function.
Input files compressed as .gz can be read as well.
The protein abundance values (XIC) get extracted. Since protein annotation is not very extensive with this format of data, the function allows reading the
initial fasta files (from the directory above the quantitation-results) allowing to extract more protein-annotation (like species).
Sample-annotation (if available) can be extracted from  sdrf files, too.
The protein abundance values may be normalized using multiple methods (median normalization as default), the determination of normalization factors can be restricted to specific proteins
(normalization to bait protein(s), or to invariable matrix of spike-in experiments).
The protein annotation data gets parsed to extract specific fields (ID, name, description, species ...).
Besides, a graphical display of the distribution of protein abundance values may be generated before and after normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readAlphaPeptFile(
  fileName = "results_proteins.csv",
  path = NULL,
  fasta = NULL,
  isLog2 = FALSE,
  normalizeMeth = "none",
  quantCol = "_LFQ$",
  contamCol = NULL,
  read0asNA = TRUE,
  refLi = NULL,
  sampleNames = NULL,
  specPref = NULL,
  extrColNames = NULL,
  remRev = TRUE,
  remConta = FALSE,
  separateAnnot = TRUE,
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  titGraph = NULL,
  wex = 1.6,
  plotGraph = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readAlphaPeptFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read (default 'results_proteins.csv'). Gz-compressed files can be read, too.</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_fasta">fasta</code></td>
<td>
<p>(logical or character) if <code>TRUE</code> the (first) fasta from one direcory higher than <code>fileName</code> will be read as fasta-file to extract further protein annotation;
if <code>character</code> a fasta-file at this location will be read/used/</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_islog2">isLog2</code></td>
<td>
<p>(logical) typically data read from AlphaPept are expected NOT to be <code>isLog2=TRUE</code></p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA (thus avoid -Inf in log2 results)</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data should be used for normalization, ie which line is main species; if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_specpref">specPref</code></td>
<td>
<p>(character) prefix to identifiers allowing to separate i) recognize contamination database, ii) species of main identifications and iii) spike-in species</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_extrcolnames">extrColNames</code></td>
<td>
<p>(character or <code>NULL</code>) custom definition of col-names to extract</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_remrev">remRev</code></td>
<td>
<p>(logical) option to remove all protein-identifications based on reverse-peptides</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_remconta">remConta</code></td>
<td>
<p>(logical) option to remove all proteins identified as contaminants</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(logical, character, list or data.frame) optional extraction and adding of experimenal meta-data:
if <code>sdrf=TRUE</code> the 1st sdrf in the directory above <code>fileName</code> will be used
if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by Compomics; if <code>gr</code> is provided, it gets priority for grouping of replicates
if <code>TRUE</code> default to files 'summary.txt' (needed to match information of <code>sdrf</code>) and 'parameters.txt' which can be found in the same folder as the main quantitation results;
if <code>character</code> the respective file-names (relative ro absolute path), 1st is expected to correspond to 'summary.txt' (tabulated text, the samples as given to Compomics) and 2nd to 'parameters.txt' (tabulated text, all parameters given to Compomics)</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_wex">wex</code></td>
<td>
<p>(numeric)  relative expansion factor of the violin in plot</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) optional plot vioplot of initial and normalized data (using <code>normalizeMeth</code>); alternatively the argument may contain numeric details that will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readAlphaPeptFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meta-data describing the samples and experimental setup may be available from a sdrf-file (from the directory above the analysis/quantiication results)
If available, the meta-data will be examined for determining groups of replicates and
the results thereof can be found in $sampleSetup$levels.
Alternatively, a dataframe formatted like sdrf-files (ie for each sample a separate line, see also function <code>readSdrf</code>) may be given, too.
</p>
<p>This import-function has been developed using AlphaPept version x.x.
The final output is a list containing these elements: <code>$raw</code>, <code>$quant</code>, <code>$annot</code>, <code>$counts</code>, <code>$sampleSetup</code>, <code>$quantNotes</code>, <code>$notes</code>, or (if <code>separateAnnot=FALSE</code>) data.frame
with annotation- and main quantification-content. If <code>sdrf</code> information has been found, an add-tional list-element <code>setup</code>
will be added containg the entire meta-data as <code>setup$meta</code> and the suggested organization as <code>setup$lev</code>.
</p>


<h3>Value</h3>

<p>This function returns a list with  <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code> (columns ), <code>$counts</code> an array with 'PSM' and 'NoOfRazorPeptides',
<code>$quantNotes</code>, <code>$notes</code> and optional <code>setup</code> for meta-data from <code>sdrf</code>; or a data.frame with quantitation and annotation if <code>separateAnnot=FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readProteomeDiscovererFile">readProteomeDiscovererFile</a></code>; <code><a href="#topic+readProlineFile">readProlineFile</a></code> (and other import-functions), <code><a href="#topic+matrixNAinspect">matrixNAinspect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
# Here we'll load a short/trimmed example file
fiNaAP &lt;- "tinyAlpaPeptide.csv.gz"
dataAP &lt;- readAlphaPeptFile(file=fiNaAP, path=path1, tit="tiny AlphaPaptide ")
summary(dataAP$quant)
</code></pre>

<hr>
<h2 id='readDiaNNFile'>Read Tabulated Files Exported by DIA-NN At Protein Level</h2><span id='topic+readDiaNNFile'></span>

<h3>Description</h3>

<p>This function allows importing protein identification and quantification results from <a href="https://github.com/vdemichev/DiaNN">DIA-NN</a>.
Data should be exported as tabulated text (tsv) as protein-groups (pg) to allow import by thus function. 
Quantification data and other relevant information will be parsed and extracted (similar to the other import-functions from this package).
The final output is a list containing as (main) elements: <code>$annot</code>, <code>$raw</code> and <code>$quant</code>, or a data.frame with the quantication data and a part of the annotation if argument <code>separateAnnot=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDiaNNFile(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  read0asNA = TRUE,
  quantCol = "\\.raw$",
  annotCol = NULL,
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  plotGraph = TRUE,
  titGraph = "DiaNN",
  wex = 1.6,
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDiaNNFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA (thus avoid -Inf in log2 results)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final log2 (normalized) quantitations</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_fdrcol">FDRCol</code></td>
<td>
<p>- not used (the argument was kept to remain with the same synthax as the other import functions fo this package)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readDiaNNFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using DIA-NN version 1.8.x.
Note, reading gene-group (gg) files is in priciple possible, but resulting files typically lack protein-identifiers which may be less convenient in later steps of analysis.
Thus, it is suggested to rather read protein-group (pg) files.
</p>
<p>Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment related information.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProtDiscovFile">readProtDiscovFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diaNNFi1 &lt;- "tinyDiaNN1.tsv.gz"   
## This file contains much less identifications than one may usually obtain
path1 &lt;- system.file("extdata", package="wrProteo")
## let's define the main species and allow tagging some contaminants
specPref1 &lt;- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="HUMAN")
dataNN &lt;- readDiaNNFile(path1, file=diaNNFi1, specPref=specPref1, tit="Tiny DIA-NN Data")
summary(dataNN$quant)
</code></pre>

<hr>
<h2 id='readDiaNNPeptides'>Read Tabulated Files Exported by DiaNN At Peptide Level</h2><span id='topic+readDiaNNPeptides'></span>

<h3>Description</h3>

<p>This function allows importing peptide identification and quantification results from <a href="https://github.com/vdemichev/DiaNN">DiaNN</a>.
Data should be exported as tabulated text (tsv) to allow import by thus function.
Quantification data and other relevant information will be extracted similar like the other import-functions from this package.
The final output is a list containing as (main) elements: <code>$annot</code>, <code>$raw</code> and <code>$quant</code>, or a data.frame with the quantication data and a part of the annotation if argument <code>separateAnnot=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDiaNNPeptides(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  read0asNA = TRUE,
  quantCol = "\\.raw$",
  annotCol = NULL,
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  plotGraph = TRUE,
  titGraph = "DiaNN",
  wex = 1.6,
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDiaNNPeptides_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA (thus avoid -Inf in log2 results)</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final log2 (normalized) quantitations</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_fdrcol">FDRCol</code></td>
<td>
<p>(list) - not used</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readDiaNNPeptides_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using DiaNN version 1.8.x.
</p>
<p>Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment related information.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProtDiscovFile">readProtDiscovFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diaNNFi1 &lt;- "tinyDiaNN1.tsv.gz"
## This file contains much less identifications than one may usually obtain
path1 &lt;- system.file("extdata", package="wrProteo")
## let's define the main species and allow tagging some contaminants
specPref1 &lt;- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="HUMAN")
dataNN &lt;- readDiaNNFile(path1, file=diaNNFi1, specPref=specPref1, tit="Tiny DIA-NN Data")
summary(dataNN$quant)

</code></pre>

<hr>
<h2 id='readFasta2'>Read file of protein sequences in fasta format</h2><span id='topic+readFasta2'></span>

<h3>Description</h3>

<p>Read fasta formatted file (from <a href="https://www.uniprot.org">UniProt</a>) to extract (protein) sequences and name.
If <code>tableOut=TRUE</code> output may be organized as matrix for separating meta-annotation (eg uniqueIdentifier, entryName, proteinName, GN) in separate columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFasta2(
  filename,
  delim = "|",
  databaseSign = c("sp", "tr", "generic", "gi"),
  removeEntries = NULL,
  tableOut = FALSE,
  UniprSep = c("OS=", "OX=", "GN=", "PE=", "SV="),
  cleanCols = TRUE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFasta2_+3A_filename">filename</code></td>
<td>
<p>(character) names fasta-file to be read</p>
</td></tr>
<tr><td><code id="readFasta2_+3A_delim">delim</code></td>
<td>
<p>(character) delimeter at header-line</p>
</td></tr>
<tr><td><code id="readFasta2_+3A_databasesign">databaseSign</code></td>
<td>
<p>(character) characters at beginning right after the '&gt;' (typically specifying the data-base-origin), they will be excluded from the sequance-header</p>
</td></tr>
<tr><td><code id="readFasta2_+3A_removeentries">removeEntries</code></td>
<td>
<p>(character) if <code>'empty'</code> allows removing entries without any sequence entries; set to <code>'duplicated'</code> to remove duplicate entries (same sequence and same header)</p>
</td></tr>
<tr><td><code id="readFasta2_+3A_tableout">tableOut</code></td>
<td>
<p>(logical) toggle to return named character-vector or matrix with enhaced parsing of fasta-header. The resulting matrix will contain the comumns 'database','uniqueIdentifier','entryName','proteinName','sequence' and further columns depending on argument <code>UniprSep</code></p>
</td></tr>
<tr><td><code id="readFasta2_+3A_uniprsep">UniprSep</code></td>
<td>
<p>(character) separators for further separating entry-fields if <code>tableOut=TRUE</code>, see also <a href="https://www.uniprot.org/help/fasta-headers">UniProt-FASTA-headers</a></p>
</td></tr>
<tr><td><code id="readFasta2_+3A_cleancols">cleanCols</code></td>
<td>
<p>(logical) remove columns with all entries NA, if <code>tableOut=TRUE</code></p>
</td></tr>
<tr><td><code id="readFasta2_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readFasta2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="readFasta2_+3A_debug">debug</code></td>
<td>
<p>(logical) supplemental messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns (depending on parameter <code>tableOut</code>) a) a simple character vector (of sequence) with Uniprot ID as name or b) a matrix with columns: 'database','uniqueIdentifier','entryName','proteinName','sequence' and further columns depending on argument <code>UniprSep</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeFasta2">writeFasta2</a></code> for writing as fasta, or for reading <code><a href="base.html#topic+scan">scan</a></code> or  <code>read.fasta</code> from the package <a href="https://CRAN.R-project.org/package=seqinr">seqinr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Tiny example with common contaminants
path1 &lt;- system.file('extdata',package='wrProteo')
fiNa &lt;-  "conta1.fasta.gz"
fasta1 &lt;- readFasta2(file.path(path1,fiNa))
## now let's read and further separate annotation-fields
fasta2 &lt;- readFasta2(file.path(path1,fiNa),tableOut=TRUE)
str(fasta1)
</code></pre>

<hr>
<h2 id='readFragpipeFile'>Read Tabulated Files Exported by FragPipe At Protein Level</h2><span id='topic+readFragpipeFile'></span>

<h3>Description</h3>

<p>This function allows importing protein identification and quantification results from <a href="https://fragpipe.nesvilab.org/">Fragpipe</a>
which were previously exported as tabulated text (tsv). Quantification data and other relevant information will be extracted similar like the other import-functions from this package.
The final output is a list containing the elements: <code>$annot</code>, <code>$raw</code> and <code>$quant</code>, or a data.frame with the quantication data and a part of the annotation if argument <code>separateAnnot=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFragpipeFile(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  read0asNA = TRUE,
  quantCol = "Intensity$",
  annotCol = NULL,
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = list("Protein.Probability", lim = 0.99),
  groupPref = list(lowNumberOfGroups = TRUE),
  plotGraph = TRUE,
  titGraph = "FragPipe",
  wex = 1.6,
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFragpipeFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA (thus avoid -Inf in log2 results)</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final log2 (normalized) quantitations</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_fdrcol">FDRCol</code></td>
<td>
<p>(list) optional indication to search for protein FDR information</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readFragpipeFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using Fragpipe versions 18.0 and 19.0.
</p>
<p>Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment related information.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProtDiscovFile">readProtDiscovFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FPproFi1 &lt;- "tinyFragpipe1.tsv.gz"
path1 &lt;- system.file("extdata", package="wrProteo")
## let's define the main species and allow tagging some contaminants
specPref1 &lt;- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="MOUSE")
dataFP &lt;- readFragpipeFile(path1, file=FPproFi1, specPref=specPref1, tit="Tiny Fragpipe Data")
summary(dataFP$quant)

</code></pre>

<hr>
<h2 id='readMassChroQFile'>Read tabulated files imported from MassChroQ</h2><span id='topic+readMassChroQFile'></span>

<h3>Description</h3>

<p>Quantification results using MassChroQ should be initially treated using the R-package MassChroqR (both distributed by the PAPPSO at http://pappso.inrae.fr/)
for initial normalization on peptide-level and combination of peptide values into protein abundances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMassChroQFile(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  refLi = NULL,
  separateAnnot = TRUE,
  titGraph = "MassChroQ",
  wex = NULL,
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = FALSE,
  groupPref = list(lowNumberOfGroups = TRUE),
  plotGraph = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMassChroQFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read (may be tsv, csv, rda or rdata); both US and European csv formats are supported</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method (will be sent to  <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange. Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, it gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by ProteomeDiscoverer; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>TRUE</code> defaults to file '*InputFiles.txt' (needed to match information of <code>sdrf</code>) which can be exported next to main quantitation results;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readMassChroQFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The final output of this fucntion is a list containing 3 elements: <code>$annot</code>, <code>$raw</code>, <code>$quant</code> and  <code>$notes</code>, or returns data.frame with entire content of file if <code>separateAnnot=FALSE</code>. Other list-elements remain empty to keep format compatible to other import functions.
</p>
<p>This function has been developed using MassChroQ version 2.2 and R-package MassChroqR version 0.4.0. Both are distributed by the PAPPSO (http://pappso.inrae.fr/).
When saving quantifications generated in R as RData (with extension .rdata or .rda) using the R-packages associated with MassChroq, the ABUNDANCE_TABLE produced by  mcq.get.compar(XICAB) should be used.
</p>
<p>After import data get (re-)normalized according to <code>normalizeMeth</code> and <code>refLi</code>, and boxplots or vioplots drawn.
</p>


<h3>Value</h3>

<p>This function returns list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code> and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readProlineFile">readProlineFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
fiNa &lt;- "tinyMC.RData"
dataMC &lt;- readMassChroQFile(file=fiNa, path=path1)
</code></pre>

<hr>
<h2 id='readMaxQuantFile'>Read Quantitation Data-Files (proteinGroups.txt) Produced From MaxQuant At Protein Level</h2><span id='topic+readMaxQuantFile'></span>

<h3>Description</h3>

<p>Protein quantification results from <a href="https://www.maxquant.org">MaxQuant</a> can be read using this function and relevant information extracted.
Input files compressed as .gz can be read as well.
The protein abundance values (XIC), peptide counting information like number of unique razor-peptides or PSM values and sample-annotation (if available) can be extracted, too.
The protein abundance values may be normalized using multiple methods (median normalization as default), the determination of normalization factors can be restricted to specific proteins
(normalization to bait protein(s), or to invariable matrix of spike-in experiments).
The protein annotation data gets parsed to extract specific fields (ID, name, description, species ...).
Besides, a graphical display of the distribution of protein abundance values may be generated before and after normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMaxQuantFile(
  path,
  fileName = "proteinGroups.txt",
  normalizeMeth = "median",
  quantCol = "LFQ.intensity",
  contamCol = "Potential.contaminant",
  pepCountCol = c("Razor + unique peptides", "Unique peptides", "MS.MS.count"),
  read0asNA = TRUE,
  refLi = NULL,
  sampleNames = NULL,
  extrColNames = c("Majority.protein.IDs", "Fasta.headers", "Number.of.proteins"),
  specPref = c(conta = "conta|CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  remRev = TRUE,
  remConta = FALSE,
  separateAnnot = TRUE,
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  titGraph = NULL,
  wex = 1.6,
  plotGraph = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMaxQuantFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read (default 'proteinGroups.txt' as typically generated by MaxQuant in txt folder). Gz-compressed files can be read, too.</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_pepcountcol">pepCountCol</code></td>
<td>
<p>(character) pattern to search among column-names for count data (1st entry for 'Razor + unique peptides', 2nd fro 'Unique peptides', 3rd for 'MS.MS.count' (PSM))</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA (thus avoid -Inf in log2 results)</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data should be used for normalization, ie which line is main species; if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_extrcolnames">extrColNames</code></td>
<td>
<p>(character) column names to be read (1st position: prefix for LFQ quantitation, default 'LFQ.intensity'; 2nd: column name for protein-IDs, default 'Majority.protein.IDs'; 3rd: column names of fasta-headers, default 'Fasta.headers', 4th: column name for number of protein IDs matching, default 'Number.of.proteins')</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_specpref">specPref</code></td>
<td>
<p>(character) prefix to identifiers allowing to separate i) recognize contamination database, ii) species of main identifications and iii) spike-in species</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_remrev">remRev</code></td>
<td>
<p>(logical) option to remove all protein-identifications based on reverse-peptides</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_remconta">remConta</code></td>
<td>
<p>(logical) option to remove all proteins identified as contaminants</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by MaxQuant; if <code>gr</code> is provided, it gets priority for grouping of replicates
if <code>TRUE</code> default to files 'summary.txt' (needed to match information of <code>sdrf</code>) and 'parameters.txt' which can be found in the same folder as the main quantitation results;
if <code>character</code> the respective file-names (relative ro absolute path), 1st is expected to correspond to 'summary.txt' (tabulated text, the samples as given to MaxQuant) and 2nd to 'parameters.txt' (tabulated text, all parameters given to MaxQuant)</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_wex">wex</code></td>
<td>
<p>(numeric)  relative expansion factor of the violin in plot</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) optional plot vioplot of initial and normalized data (using <code>normalizeMeth</code>); alternatively the argument may contain numeric details that will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readMaxQuantFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://www.maxquant.org">MaxQuant</a> is proteomics quantification software provided by the MaxPlanck institute.
By default MaxQuant writes the results of each run to the path <code>combined/txt</code>, from there (only) the files
'proteinGroups.txt' (main quantitation at protein level), 'summary.txt' and 'parameters.txt' will be used.
</p>
<p>Meta-data describing the samples and experimental setup may be available from two sources :
a) The file <code>summary.txt</code> which gets produced by MaxQuant in the same folder as the main quantification data.
b) Furthermore, meta-data deposited as <code>sdrf</code> at Pride can be retreived (via the respective github page) when giving the accession number in argument <code>sdrf</code>.
Then, the meta-data will be examined for determining groups of replicates and
the results thereof can be found in $sampleSetup$levels.
Alternatively, a dataframe formatted like sdrf-files (ie for each sample a separate line, see also function <code>readSdrf</code>) may be given.
In tricky cases it is also possible to precise the column-name to use for defining the groups of replicates or the method for automatically choosing
the most suited column via the 2nd value of the argument <code>sdrf</code>.
Please note, that sdrf is still experimental and only a small fraction of proteomics-data on Pride have been annotated accordingly.
If a valid sdrf is furnished, it's information has priority over the information extracted from the MaxQuant produced file summary.txt.
</p>
<p>This import-function has been developed using MaxQuant versions 1.6.10.x to 2.0.x, the format of the resulting file 'proteinGroups.txt' is typically well conserved between versions.
The final output is a list containing these elements: <code>$raw</code>, <code>$quant</code>, <code>$annot</code>, <code>$counts</code>, <code>$sampleSetup</code>, <code>$quantNotes</code>, <code>$notes</code>, or (if <code>separateAnnot=FALSE</code>) data.frame
with annotation- and main quantification-content. If <code>sdrf</code> information has been found, an add-tional list-element <code>setup</code>
will be added containg the entire meta-data as <code>setup$meta</code> and the suggested organization as <code>setup$lev</code>.
</p>


<h3>Value</h3>

<p>This function returns a list with  <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code> (columns ), <code>$counts</code> an array with 'PSM' and 'NoOfRazorPeptides',
<code>$quantNotes</code>, <code>$notes</code> and optional <code>setup</code> for meta-data from <code>sdrf</code>; or a data.frame with quantitation and annotation if <code>separateAnnot=FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readProteomeDiscovererFile">readProteomeDiscovererFile</a></code>; <code><a href="#topic+readProlineFile">readProlineFile</a></code> (and other imprtfunctions), <code><a href="#topic+matrixNAinspect">matrixNAinspect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
# Here we'll load a short/trimmed example file (thus not the MaxQuant default name)
fiNa &lt;- "proteinGroupsMaxQuant1.txt.gz"
specPr &lt;- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="YEAST", spike="HUMAN_UPS")
dataMQ &lt;- readMaxQuantFile(path1, file=fiNa, specPref=specPr, tit="tiny MaxQuant")
summary(dataMQ$quant)
matrixNAinspect(dataMQ$quant, gr=gl(3,3))
</code></pre>

<hr>
<h2 id='readMaxQuantPeptides'>Read Peptide Identificationa and Quantitation Data-Files (peptidess.txt) Produced By MaxQuant</h2><span id='topic+readMaxQuantPeptides'></span>

<h3>Description</h3>

<p>Peptide level identification and quantification data produced by <a href="https://www.maxquant.org/">MaxQuant</a> can be read using
this function and relevant information extracted.
Input files compressed as .gz can be read as well.
The peptide abundance values (XIC), peptide counting information and sample-annotation (if available) can be extracted, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMaxQuantPeptides(
  path,
  fileName = "peptides.txt",
  normalizeMeth = "median",
  quantCol = "LFQ.intensity",
  contamCol = "Potential.contaminant",
  pepCountCol = "Experiment",
  refLi = NULL,
  sampleNames = NULL,
  extrColNames = c("Sequence", "Proteins", "Leading.razor.protein", "Start.position",
    "End.position", "Mass", "Missed.cleavages", "Unique..Groups.", "Unique..Proteins.",
    "Charges"),
  specPref = c(conta = "conta|CON_|LYSC_CHICK", mainSpecies = "HUMAN"),
  remRev = TRUE,
  remConta = FALSE,
  separateAnnot = TRUE,
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  titGraph = NULL,
  wex = 1.6,
  plotGraph = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMaxQuantPeptides_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read (default 'peptides.txt' as typically generated by MaxQuant in txt folder). Gz-compressed files can be read, too.</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method (for details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_pepcountcol">pepCountCol</code></td>
<td>
<p>(character) pattern to search among column-names for count data (defaults to 'Experiment')</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data should be used for normalization, ie which line is main species; if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_extrcolnames">extrColNames</code></td>
<td>
<p>(character) column names to be read (1st position: prefix for LFQ quantitation, default 'LFQ.intensity';
2nd: column name for peptide-IDs, default )</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_specpref">specPref</code></td>
<td>
<p>(character) prefix to identifiers allowing to separate i) recognize contamination database,
ii) species of main identifications and iii) spike-in species</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_remrev">remRev</code></td>
<td>
<p>(logical) option to remove all peptide-identifications based on reverse-peptides</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_remconta">remConta</code></td>
<td>
<p>(logical) option to remove all peptides identified as contaminants</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code>
for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of
replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character,
this may be the ID at ProteomeExchange. Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided;
if <code>gr</code> is provided, it gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by MaxQuant; if <code>gr</code> is provided, it gets priority for grouping of replicates
if <code>TRUE</code> default to files 'summary.txt' (needed to match information of <code>sdrf</code>) and 'parameters.txt' which can be found in the same folder as the main quantitation results;
if <code>character</code> the respective file-names (relative ro absolute path), 1st is expected to correspond to 'summary.txt' (tabulated text, the samples as given to MaxQuant) and 2nd to 'parameters.txt' (tabulated text, all parameters given to MaxQuant)</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_wex">wex</code></td>
<td>
<p>(numeric)  relative expansion factor of the violin in plot</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) optional plot vioplot of initial and normalized data (using <code>normalizeMeth</code>); alternatively the argument may contain numeric details that will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readMaxQuantPeptides_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The peptide annotation data gets parsed to extract specific fields (ID, name, description, species ...).
Besides, a graphical display of the distribution of peptide abundance values may be generated before and after normalization.
</p>
<p><a href="https://www.maxquant.org/">MaxQuant</a> is proteomics quantification software provided by the MaxPlanck institute.
By default MaxQuant write the results of each run to the path <code>combined/txt</code>, from there (only) the files
'peptides.txt' (main quantitation at peptide level), 'summary.txt' and 'parameters.txt' will be used for this function.
</p>
<p>Meta-data describing the samples and experimental setup may be available from two sources :
a) The file <code>summary.txt</code> which gets produced by MaxQuant in the same folder as the main quantification data.
b) Furthermore, meta-data deposited as <code>sdrf</code> at Pride can be retreived (via the respective github page) when giving
the accession number in argument <code>sdrf</code>.
Then, the meta-data will be examined for determining groups of replicates and
the results thereof can be found in $sampleSetup$levels.
Alternatively, a dataframe formatted like sdrf-files (ie for each sample a separate line, see also function <code>readSdrf</code>) may be given.
In tricky cases it is also possible to precise the column-name to use for defining the groups of replicates or the method for automatically choosing
the most suited column via the 2nd value of the argument <code>sdrf</code>, see also the function <code>defineSamples</code> (which gets used internally).
Please note, that sdrf is still experimental and only a small fraction of proteomics-data on Pride have been annotated accordingly.
If a valid sdrf is furnished, it's information has priority over the information extracted from the MaxQuant produced file summary.txt.
</p>
<p>This function has been developed using MaxQuant versions 1.6.10.x to 2.0.x, the format of the resulting file 'peptides.txt'
is typically well conserved between versions.
The final output is a list containing these elements: <code>$raw</code>, <code>$quant</code>, <code>$annot</code>, <code>$counts</code>, <code>$sampleSetup</code>,
<code>$quantNotes</code>, <code>$notes</code>, or (if <code>separateAnnot=FALSE</code>) data.frame
with annotation- and main quantification-content. If <code>sdrf</code> information has been found, an add-tional list-element <code>setup</code>
will be added containg the entire meta-data as <code>setup$meta</code> and the suggested organization as <code>setup$lev</code>.
</p>


<h3>Value</h3>

<p>This function returns a list with  <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code> (columns ), <code>$counts</code> an array with 'PSM' and 'NoOfRazorPeptides',
<code>$quantNotes</code>, <code>$notes</code> and optional <code>setup</code> for meta-data from <code>sdrf</code>; or a data.frame with quantitation and annotation if <code>separateAnnot=FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>), for reading protein level <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here we'll load a short/trimmed example file (thus not the MaxQuant default name)
MQpepFi1 &lt;- "peptides_tinyMQ.txt.gz"
path1 &lt;- system.file("extdata", package="wrProteo")
specPref1 &lt;- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="YEAST", spec2="HUMAN")
dataMQpep &lt;- readMaxQuantPeptides(path1, file=MQpepFi1, specPref=specPref1,
  tit="Tiny MaxQuant Peptides")
summary(dataMQpep$quant)
</code></pre>

<hr>
<h2 id='readOpenMSFile'>Read csv files exported by OpenMS</h2><span id='topic+readOpenMSFile'></span>

<h3>Description</h3>

<p>Protein quantification results form <a href="https://openms.de/">OpenMS</a> 
which were exported as <code>.csv</code> can be imported and relevant information extracted. 
Peptide data get summarized by protein by top3 or sum methods.
The final output is a list containing the elements: <code>$annot</code>, <code>$raw</code>, <code>$quant</code> ie normaized final quantifications, or returns data.frame with entire content of file if <code>separateAnnot=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readOpenMSFile(
  fileName = NULL,
  path = NULL,
  normalizeMeth = "median",
  refLi = NULL,
  sampleNames = NULL,
  quantCol = "Intensity",
  sumMeth = "top3",
  minPepNo = 1,
  protNaCol = "ProteinName",
  separateAnnot = TRUE,
  plotGraph = TRUE,
  tit = "OpenMS",
  wex = 1.6,
  specPref = c(conta = "LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readOpenMSFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method (will be sent to  <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) new column-names for quantification data (by default the names from files with spectra will be used)</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_summeth">sumMeth</code></td>
<td>
<p>(character) method for summarizing peptide data (so far 'top3' and 'sum' available)</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_minpepno">minPepNo</code></td>
<td>
<p>(integer) minumun number of peptides to be used for retruning quantification</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_protnacol">protNaCol</code></td>
<td>
<p>(character) column name to be read/extracted for the annotation section (default &quot;ProteinName&quot;)</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_tit">tit</code></td>
<td>
<p>(character) custom title to plot</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe', 
and optional following ones for supplemental tags/species - maked as 'species2','species3',...); 
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="readOpenMSFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed based on the OpenMS peptide-identification and label-free-quantification module.
Csv input files may also be compresses as .gz.
</p>
<p>Note: With this version the information about protein-modifications (PTMs) may not yet get exploited fully.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>,<code>$expSetup</code> and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readProtDiscovFile">readProtDiscovFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
fiNa &lt;- "OpenMS_tiny.csv.gz"
dataOM &lt;- readOpenMSFile(file=fiNa, path=path1, tit="tiny OpenMS example")
summary(dataOM$quant)

</code></pre>

<hr>
<h2 id='readProlineFile'>Read xlsx, csv or tsv files exported from Proline and MS-Angel</h2><span id='topic+readProlineFile'></span>

<h3>Description</h3>

<p>Quantification results from Proline <a href="http://www.profiproteomics.fr/proline/">Proline</a> and MS-Angel exported as xlsx format can be read directly using this function.
Besides, files in tsv, csv (European and US format) or tabulated txt can be read, too.
Then relevant information gets extracted, the data can optionally normalized and displayed as boxplot or vioplot.
The final output is a list containing 6 elements: <code>$raw</code>, <code>$quant</code>,  <code>$annot</code>, <code>$counts</code>, <code>$quantNotes</code> and <code>$notes</code>.
Alternatively, a data.frame with annotation and quantitation data may be returned if <code>separateAnnot=FALSE</code>.
Note: There is no normalization by default since quite frequently data produced by Proline are already sufficiently normalized.
The figure produced using the argument <code>plotGraph=TRUE</code> may help judging if the data appear sufficiently normalized (distribtions should align).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProlineFile(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  logConvert = TRUE,
  sampleNames = NULL,
  quantCol = "^abundance_",
  annotCol = c("accession", "description", "is_validated", "protein_set_score",
    "X.peptides", "X.specific_peptides"),
  remStrainNo = TRUE,
  pepCountCol = c("^psm_count_", "^peptides_count_"),
  trimColnames = FALSE,
  refLi = NULL,
  separateAnnot = TRUE,
  plotGraph = TRUE,
  titGraph = NULL,
  wex = 2,
  specPref = c(conta = "_conta\\|", mainSpecies = "OS=Homo sapiens"),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = TRUE,
  groupPref = list(lowNumberOfGroups = TRUE),
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProlineFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to read; .xlsx-, .csv-, .txt- and .tsv can be read (csv, txt and tsv may be gz-compressed). Reading xlsx requires package 'readxl'.</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_path">path</code></td>
<td>
<p>(character) optional path (note: Windows backslash sould be protected or written as '/')</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method (for details and options see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_logconvert">logConvert</code></td>
<td>
<p>(logical) convert numeric data as log2, will be placed in $quant</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) colums with main quantitation-data : precise colnames to extract, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) precise colnames or if length=1 pattern to search among column-names for $annot</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_remstrainno">remStrainNo</code></td>
<td>
<p>(logical) if <code>TRUE</code>, the organism annotation will be trimmed to uppercaseWord+space+lowercaseWord (eg Homo sapiens)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_pepcountcol">pepCountCol</code></td>
<td>
<p>(character) pattern to search among column-names for count data of PSM and NoOfPeptides</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_trimcolnames">trimColnames</code></td>
<td>
<p>(logical) optional trimming of column-names of any redundant characters from beginning and end</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_refli">refLi</code></td>
<td>
<p>(integer) custom decide which line of data is main species, if single character entry it will be used to choose a group of species (eg 'mainSpe')</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) separate annotation form numeric data (quantCol and annotCol must be defined)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or matrix of integer) optional plot vioplot of initial data; if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange, 
the second element may give futher indicatations for automatic organization of groups of replicates. 
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by quantification software; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>TRUE</code> defaults to file '*InputFiles.txt' (needed to match information of <code>sdrf</code>) which can be exported next to main quantitation results;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="readProlineFile_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using Proline version 1.6.1 coupled with MS-Angel 1.6.1.
The classical way of using ths function consists in exporting results produced by Proline and MS-Angel as xlsx file.
Besides, other formats may be read, too. This includes csv (eg the main sheet/table of ths xlsx exported file saved as csv).
<a href="https://github.com/wombat-p">WOMBAT</a> represents an effort to automatize quantitative proteomics experiments, using this route
data get exported as txt files which can be read, too.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code> (columns ), <code>$counts</code> an array with 'PSM' and 'NoOfPeptides', <code>$quantNotes</code> and <code>$notes</code>; or a data.frame with quantitation and annotation if <code>separateAnnot=FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
fiNa &lt;- "exampleProlineABC.csv.gz"
dataABC &lt;- readProlineFile(path=path1, file=fiNa)
summary(dataABC$quant)
</code></pre>

<hr>
<h2 id='readProtDiscovererPeptides'>readProtDiscovererPeptides, depreciated</h2><span id='topic+readProtDiscovererPeptides'></span>

<h3>Description</h3>

<p>This function has been depreciated and replaced by <code><a href="#topic+readProteomeDiscovererPeptides">readProteomeDiscovererPeptides</a></code> (from this package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProtDiscovererPeptides(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProtDiscovererPeptides_+3A_...">...</code></td>
<td>
<p>Actually, this function doesn't ready any input any more</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns <code>NULL</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readProteomeDiscovererFile">readProteomeDiscovererFile</a></code>, <code><a href="#topic+readProteomeDiscovererPeptides">readProteomeDiscovererPeptides</a></code>
</p>

<hr>
<h2 id='readProtDiscovFile'>Read Tabulated Files Exported By ProteomeDiscoverer At Protein Level, Deprecated</h2><span id='topic+readProtDiscovFile'></span>

<h3>Description</h3>

<p>Depreciated old version of Protein identification and quantification results from
<a href="https://www.thermofisher.com/order/catalog/product/OPTON-30812">Thermo ProteomeDiscoverer</a>
which were exported as tabulated text can be imported and relevant information extracted.
The final output is a list containing 3 elements: <code>$annot</code>, <code>$raw</code> and optional <code>$quant</code>,
or returns data.frame with entire content of file if <code>separateAnnot=FALSE</code>.
Please use readProteomeDiscovererFile() from the same package instead !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProtDiscovFile(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  read0asNA = TRUE,
  quantCol = "^Abundances*",
  annotCol = NULL,
  contamCol = "Contaminant",
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = list(c("^Protein.FDR.Confidence", "High"), c("^Found.in.Sample.", "High")),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = TRUE,
  groupPref = list(lowNumberOfGroups = TRUE),
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  plotGraph = TRUE,
  wex = 1.6,
  titGraph = "Proteome Discoverer",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProtDiscovFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data (ProteomeDiscoverer does not automatically use file-names from spectra); this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants marked by ProteomeDiscoverer.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final log2 (normalized) quantitations</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_fdrcol">FDRCol</code></td>
<td>
<p>(list) optional indication to search for protein FDR information</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by ProteomeDiscoverer; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>TRUE</code> defaults to file '*InputFiles.txt' (needed to match information of <code>sdrf</code>) which can be exported next to main quantitation results;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readProtDiscovFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been replaced by <code>readProteomeDiscovererFile</code> (from the same package) !
The syntax  and strcuture of output has remained the same, you can simply replace the name of the function called.
</p>
<p>This function has been developed using Thermo ProteomeDiscoverer versions 2.2 to 2.5.
The format of resulting files at export also depends which columns are chosen as visible inside ProteomeDiscoverer and subsequently get chosen for export.
Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment realted information.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants
This function replaces the depreciated function <code>readPDExport</code>.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readFragpipeFile">readFragpipeFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
fiNa &lt;- "tinyPD_allProteins.txt.gz"
## Please use the function readProteinDiscovererFile(), as shown below (same syntax)
dataPD &lt;- readProteomeDiscovererFile(file=fiNa, path=path1, suplAnnotFile=FALSE)
summary(dataPD$quant)

</code></pre>

<hr>
<h2 id='readProtDiscovPeptides'>Read Tabulated Files Exported by ProteomeDiscoverer At Peptide Level, Deprecated</h2><span id='topic+readProtDiscovPeptides'></span>

<h3>Description</h3>

<p>Depreciated old version of Peptide identification and quantification results from <a href="https://www.thermofisher.com/order/catalog/product/OPTON-30812">Thermo ProteomeDiscoverer</a>
which were exported as tabulated text can be imported and relevant information extracted.
The final output is a list containing 3 elements: <code>$annot</code>, <code>$raw</code> and optional <code>$quant</code>, or returns data.frame with entire content of file if <code>separateAnnot=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProtDiscovPeptides(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  suplAnnotFile = TRUE,
  gr = NULL,
  sdrf = NULL,
  read0asNA = TRUE,
  quantCol = "^Abundances*",
  annotCol = NULL,
  contamCol = "Contaminant",
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = list(c("^Protein.FDR.Confidence", "High"), c("^Found.in.Sample.", "High")),
  plotGraph = TRUE,
  titGraph = "Proteome Discoverer",
  wex = 1.6,
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProtDiscovPeptides_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) new column-names for quantification data (ProteomeDiscoverer does not automatically use file-names from spectra); this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by ProteomeDiscoverer; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>TRUE</code> defaults to file '*InputFiles.txt' (needed to match information of <code>sdrf</code>) which can be exported next to main quantitation results;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants marked by ProteomeDiscoverer.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_fdrcol">FDRCol</code></td>
<td>
<p>(list) optional indication to search for protein FDR information</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) depreciated custom title to plot, please use 'tit'</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readProtDiscovPeptides_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using Thermo ProteomeDiscoverer versions 2.2 to 2.5.
The format of resulting files at export also depends which columns are chosen as visible inside ProteomeDiscoverer and subsequently get chosen for export.
Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment realted information.
Precedent and following aminoacids (relative to identified protease recognition sites) will be removed form peptide sequences and be displayed in $annot as columns 'prec' and 'foll'.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants
This function replaces the depreciated function <code>readPDExport</code>.
</p>
<p>Besides, ProteomeDiscoverer version number and full raw-file path will be extracted for $notes in final output.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProteomeDiscovererFile">readProteomeDiscovererFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")

</code></pre>

<hr>
<h2 id='readProteomeDiscovererFile'>Read Tabulated Files Exported By ProteomeDiscoverer At Protein Level</h2><span id='topic+readProteomeDiscovererFile'></span>

<h3>Description</h3>

<p>Protein identification and quantification results from
<a href="https://www.thermofisher.com/order/catalog/product/OPTON-30812">Thermo ProteomeDiscoverer</a>
which were exported as tabulated text can be imported and relevant information extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProteomeDiscovererFile(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  read0asNA = TRUE,
  quantCol = "^Abundance",
  annotCol = NULL,
  contamCol = "Contaminant",
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = list(c("^Protein.FDR.Confidence", "High"), c("^Found.in.Sample.", "High")),
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = TRUE,
  groupPref = list(lowNumberOfGroups = TRUE),
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  plotGraph = TRUE,
  wex = 1.6,
  titGraph = "Proteome Discoverer",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProteomeDiscovererFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data (ProteomeDiscoverer does not automatically use file-names from spectra); this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) define ywhich columns should be extracted as quantitation data : The argument may be the exact column-names to be used, or if length=1 
content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code>;
if <code>quantCol='allAfter_calc.pI'</code> all columns to the right of the column 'calc.pI' will be interpreted as quantitation data 
(may be useful with files that have been manually edited before passing to wrProteo)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants marked by ProteomeDiscoverer.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final log2 (normalized) quantitations</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_fdrcol">FDRCol</code></td>
<td>
<p>(list) optional indication to search for protein FDR information</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by ProteomeDiscoverer; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>TRUE</code> defaults to file '*InputFiles.txt' (needed to match information of <code>sdrf</code>) which can be exported next to main quantitation results;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using Thermo ProteomeDiscoverer versions 2.2 to 2.5.
The format of resulting files at export also depends which columns are chosen as visible inside ProteomeDiscoverer and subsequently get chosen for export.
Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment realted information.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants.
</p>
<p>The final output is a list containing as (main) elements: <code>$annot</code>, <code>$raw</code> and optional <code>$quant</code>,
or returns data.frame with entire content of file if <code>separateAnnot=FALSE</code>.
</p>
<p>This function replaces the depreciated function <code>readProtDiscovFile</code>.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>, <code><a href="#topic+readFragpipeFile">readFragpipeFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
fiNa &lt;- "tinyPD_allProteins.txt.gz"
dataPD &lt;- readProteomeDiscovererFile(file=fiNa, path=path1, suplAnnotFile=FALSE)
summary(dataPD$quant)

</code></pre>

<hr>
<h2 id='readProteomeDiscovererPeptides'>Read Tabulated Files Exported by ProteomeDiscoverer At Peptide Level</h2><span id='topic+readProteomeDiscovererPeptides'></span>

<h3>Description</h3>

<p>Initials petide identificationa and quantification results form <a href="https://www.thermofisher.com/order/catalog/product/OPTON-30812">Thermo ProteomeDiscoverer</a>
which were exported as tabulated text can be imported and relevant information extracted.
The final output is a list containing 3 elements: <code>$annot</code>, <code>$raw</code> and optional <code>$quant</code>, or returns data.frame with entire content of file if <code>separateAnnot=FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProteomeDiscovererPeptides(
  fileName,
  path = NULL,
  normalizeMeth = "median",
  sampleNames = NULL,
  suplAnnotFile = TRUE,
  gr = NULL,
  sdrf = NULL,
  read0asNA = TRUE,
  quantCol = "^Abundances*",
  annotCol = NULL,
  contamCol = "Contaminant",
  refLi = NULL,
  separateAnnot = TRUE,
  FDRCol = list(c("^Protein.FDR.Confidence", "High"), c("^Found.in.Sample.", "High")),
  plotGraph = TRUE,
  titGraph = "Proteome Discoverer",
  wex = 1.6,
  specPref = c(conta = "CON_|LYSC_CHICK", mainSpecies = "OS=Homo sapiens"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) new column-names for quantification data (ProteomeDiscoverer does not automatically use file-names from spectra); this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by ProteomeDiscoverer; however, if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates;
if <code>TRUE</code> defaults to file '*InputFiles.txt' (needed to match information of <code>sdrf</code>) which can be exported next to main quantitation results;
if <code>character</code> the respective file-name (relative or absolute path)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data: if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_annotcol">annotCol</code></td>
<td>
<p>(character) column names to be read/extracted for the annotation section (default  c(&quot;Accession&quot;,&quot;Description&quot;,&quot;Gene&quot;,&quot;Contaminant&quot;,&quot;Sum.PEP.Score&quot;,&quot;Coverage....&quot;,&quot;X..Peptides&quot;,&quot;X..PSMs&quot;,&quot;X..Unique.Peptides&quot;, &quot;X..AAs&quot;,&quot;MW..kDa.&quot;) )</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants marked by ProteomeDiscoverer.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_fdrcol">FDRCol</code></td>
<td>
<p>(list) optional indication to search for protein FDR information</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical or integer) optional plot of type vioplot of initial and normalized data (using <code>normalizeMeth</code>); if integer, it will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) depreciated custom title to plot, please use 'tit'</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_wex">wex</code></td>
<td>
<p>(integer) relative expansion factor of the violin-plot (will be passed to <code><a href="wrGraph.html#topic+vioplotW">vioplotW</a></code>)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_specpref">specPref</code></td>
<td>
<p>(character or list) define characteristic text for recognizing (main) groups of species (1st for comtaminants - will be marked as 'conta', 2nd for main species- marked as 'mainSpe',
and optional following ones for supplemental tags/species - maked as 'species2','species3',...);
if list and list-element has multiple values they will be used for exact matching of accessions (ie 2nd of argument <code>annotCol</code>)</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readProteomeDiscovererPeptides_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been developed using Thermo ProteomeDiscoverer versions 2.2 to 2.5.
The format of resulting files at export also depends which columns are chosen as visible inside ProteomeDiscoverer and subsequently get chosen for export.
Using the argument <code>suplAnnotFile</code> it is possible to specify a specific file (or search for default file) to read for extracting file-names as sample-names and other experiment realted information.
Precedent and following aminoacids (relative to identified protease recognition sites) will be removed form peptide sequences and be displayed in $annot as columns 'prec' and 'foll'.
If a column named <code>contamCol</code> is found, the data will be lateron filtered to remove all contaminants, set to <code>NULL</code> for keeping all contaminants
This function replaces the depreciated function <code>readPDExport</code>.
</p>
<p>Besides, ProteomeDiscoverer version number and full raw-file path will be extracted for $notes in final output.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code>, <code>$counts</code> an array with number of peptides, <code>$quantNotes</code>
and <code>$notes</code>; or if <code>separateAnnot=FALSE</code> the function returns a data.frame with annotation and quantitation only
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProteomeDiscovererFile">readProteomeDiscovererFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")

</code></pre>

<hr>
<h2 id='readSampleMetaData'>Read Sample Meta-data from Quantification-Software And/Or Sdrf And Align To Experimental Data</h2><span id='topic+readSampleMetaData'></span>

<h3>Description</h3>

<p>Sample/experimental annotation meta-data form <a href="https://www.maxquant.org/">MaxQuant</a>, ProteomeDiscoverer, FragPipe, Proline or similar, can be read using this function and relevant information extracted.
Furthermore, annotation in <a href="https://github.com/bigbio/proteomics-sample-metadata">sdrf-format</a> can be added (the order of sdrf will be adjated automatically, if possible).
This functions returns a list with grouping of samples into replicates and additional information gathered.
Input files compressed as .gz can be read as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSampleMetaData(
  quantMeth,
  sdrf = NULL,
  suplAnnotFile = NULL,
  path = ".",
  abund = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSampleMetaData_+3A_quantmeth">quantMeth</code></td>
<td>
<p>(character, length=1) quantification method used; 2-letter abbreviations like 'MQ','PD','PL','FP' etc may be used</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_sdrf">sdrf</code></td>
<td>
<p>(character, list or data.frame) optional extraction and adding of experimenal meta-data:
if character, this may be the ID at ProteomeExchange or a similarly formatted local file. <code>sdrf</code> will get priority over <code>suplAnnotFile</code>, if provided.</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by MaxQuant; if <code>gr</code> is provided, it gets priority for grouping of replicates
if <code>TRUE</code> in case of <code>method=="MQ"</code> (MaxQuant) default to files 'summary.txt' (needed to match information of <code>sdrf</code>) and 'parameters.txt' which can be found in the same folder as the main quantitation results;
if <code>character</code> the respective file-names (relative ro absolute path), 1st is expected to correspond to 'summary.txt' (tabulated text, the samples as given to MaxQuant) and 2nd to 'parameters.txt' (tabulated text, all parameters given to MaxQuant)
in case of <code>method=="PL"</code> (Proline), this argument should contain the initial file-name (for the identification and quantification data) in the first position</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_path">path</code></td>
<td>
<p>(character) optional path of file(s) to be read</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_abund">abund</code></td>
<td>
<p>(matrix or data.frame) experimental quantitation data; only column-names will be used for aligning order of annotated samples</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates);
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readSampleMetaData_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When initally reading/importing quantitation data, typically very little is known about the setup of different samples in the underlying experiment.
The overall aim is to read and mine the corresponding sample-annotation documeneted by the quantitation-software and/or from n sdrf repository and to attach it to the experimental data.
This way, in subsequent steps of analysis (eg PCA, statictical tests) the user does not have to bother stuying the experimental setup to figure out which
samples should be considered as relicate of whom.
</p>
<p>Sample annotation meta-data can be obtained from two sources :
a) form additional files produced (and exported) by the initial quantitation software (so far MaxQuant and ProteomeDiscoverer have een implemeneted) or
b) from the universal sdrf-format (from Pride or user-supplied).
Both types can be imported and checked in the same run, if valid sdrf-information is found this will be given priority.
For more information about the sdrf format please see <a href="https://github.com/bigbio/proteomics-sample-metadata">sdrf on github</a>.
</p>


<h3>Value</h3>

<p>This function returns a list with <code>$lev</code> and <code>$level</code> (grouping of samples given as integer), and <code>$meth</code> (method by which grouping as determined).
If valid <code>sdrf</code> was given, the resultant list contains in addition <code>$sdrfDat</code> (data.frame of annotation).
Alternatively it may contain a <code>$sdrfExport</code> if sufficient information has been gathered (so far only for MaxQuant) for a draft sdrf for export (that should be revised and completed by the user).
If software annotation has been found it will be shown in <code>$annotBySoft</code>.
If all entries are invalid or entries do not pass the tests, this functions returns an empty <code>list</code>.
</p>


<h3>See Also</h3>

<p>this function is used internally by <code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProtDiscovFile">readProtDiscovFile</a></code> etc; use <code><a href="#topic+readSdrf">readSdrf</a></code> for reading sdrf-files, <code><a href="wrMisc.html#topic+replicateStructure">replicateStructure</a></code> for mining annotation columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdrf001819Setup &lt;- readSampleMetaData(quantMeth=NA, sdrf="PXD001819")
str(sdrf001819Setup)

</code></pre>

<hr>
<h2 id='readSdrf'>Read proteomics meta-data as sdrf file</h2><span id='topic+readSdrf'></span>

<h3>Description</h3>

<p>This function allows reading proteomics meta-data from sdrf file, as they are provided on https://github.com/bigbio/proteomics-sample-metadata.
A data.frame containing all annotation data will be returned. To stay conform with the (non-obligatory) recommendations, columnnames are shown as lower caps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSdrf(
  fi,
  chCol = "auto",
  urlPrefix = "github",
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSdrf_+3A_fi">fi</code></td>
<td>
<p>(character) main input; may be full path or url to the file with meta-annotation. If a short project-name is given,
it will be searched based at the location of <code>urlPrefix</code></p>
</td></tr>
<tr><td><code id="readSdrf_+3A_chcol">chCol</code></td>
<td>
<p>(character, length=1) optional checking of column-names</p>
</td></tr>
<tr><td><code id="readSdrf_+3A_urlprefix">urlPrefix</code></td>
<td>
<p>(character, length=1) prefix to add to search when no complete path or url is given on <code>fi</code>, defaults to proteomics-metadata-standard on github</p>
</td></tr>
<tr><td><code id="readSdrf_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readSdrf_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
<tr><td><code id="readSdrf_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The packages utils and wrMisc must be installed.
Please note that reading sdrf files (if not provided as local copy) will take a few seconds, depending on the responsiveness of github.
</p>


<h3>Value</h3>

<p>This function returns the content of sdrf-file as data.frame (or <code>NULL</code> if the corresponding file was not found)
</p>


<h3>See Also</h3>

<p>in <code><a href="utils.html#topic+read.table">read.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This may take a few sconds...
sdrf001819 &lt;- readSdrf("PXD001819")
str(sdrf001819)


</code></pre>

<hr>
<h2 id='readUCSCtable'>Read annotation files from UCSC</h2><span id='topic+readUCSCtable'></span>

<h3>Description</h3>

<p>This function allows reading and importing genomic <a href="https://genome.ucsc.edu/cgi-bin/hgTables">UCSC-annotation</a> data.
Files can be read as default UCSC exprot or as GTF-format. 
In the context of proteomics we noticed that sometimes UniProt tables from UCSC are hard to match to identifiers from UniProt Fasta-files, ie many protein-identifiers won't match.
For this reason additional support is given to reading 'Genes and Gene Predictions': Since this table does not include protein-identifiers, a non-redundant list of ENSxxx transcript identifiers 
can be exprted as file for an additional stop of conversion, eg using a batch conversion tool at the site of <a href="https://www.uniprot.org/id-mapping/">UniProt</a>. 
The initial genomic annotation can then be complemented using <code><a href="#topic+readUniProtExport">readUniProtExport</a></code>. 
Using this more elaborate route, we found higher coverage when trying to add genomic annotation to protein-identifiers to proteomics results with annnotation based on an initial Fasta-file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readUCSCtable(
  fiName,
  exportFileNa = NULL,
  gtf = NA,
  simplifyCols = c("gene_id", "chr", "start", "end", "strand", "frame"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readUCSCtable_+3A_finame">fiName</code></td>
<td>
<p>(character) name (and path) of file to read</p>
</td></tr>
<tr><td><code id="readUCSCtable_+3A_exportfilena">exportFileNa</code></td>
<td>
<p>(character) optional file-name to be exported, if <code>NULL</code> no file will be written</p>
</td></tr>
<tr><td><code id="readUCSCtable_+3A_gtf">gtf</code></td>
<td>
<p>(logical) specify if file <code>fiName</code> in gtf-format (see <a href="https://genome.ucsc.edu/cgi-bin/hgTables">UCSC</a>)</p>
</td></tr>
<tr><td><code id="readUCSCtable_+3A_simplifycols">simplifyCols</code></td>
<td>
<p>(character) optional list of column-names to be used for simplification  (if 6 column-headers are given) : the 1st value will be used to identify the column
used as refence to summarize all lines with this ID; for the 2nd (typically chromosome names) will be taken a representative value, 
for the 3rd (typically gene start site) will be taken the minimum, 
for the 4th (typically gene end site) will be taken the maximum, for the 5th and 6th a representative values will be reported;</p>
</td></tr>
<tr><td><code id="readUCSCtable_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readUCSCtable_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="readUCSCtable_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix, optionally the file 'exportFileNa' may be written
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readUniProtExport">readUniProtExport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
gtfFi &lt;- file.path(path1, "UCSC_hg38_chr11extr.gtf.gz")
# here we'll write the file for UniProt conversion to tempdir() to keep things tidy
expFi &lt;- file.path(tempdir(), "deUcscForUniProt2.txt")
UcscAnnot1 &lt;- readUCSCtable(gtfFi, exportFileNa=expFi)

## results can be further combined with readUniProtExport() 
deUniProtFi &lt;- file.path(path1, "deUniProt_hg38chr11extr.tab")
deUniPr1 &lt;- readUniProtExport(deUniProtFi, deUcsc=UcscAnnot1,
  targRegion="chr11:1-135,086,622")  
deUniPr1[1:5,-5] 
</code></pre>

<hr>
<h2 id='readUniProtExport'>Read protein annotation as exported from UniProt batch-conversion</h2><span id='topic+readUniProtExport'></span>

<h3>Description</h3>

<p>This function allows reading and importing protein-ID conversion results from <a href="https://www.uniprot.org/id-mapping/">UniProt</a>.
To do so, first copy/paste your query IDs into <a href="https://www.uniprot.org/id-mapping/">UniProt</a> 'Retrieve/ID mapping' field called '1. Provide your identifiers' (or upload as file), verify '2. Select options'.
In a typical case of 'enst000xxx' IDs  you may leave default settings, ie 'Ensemble Transcript' as input and 'UniProt KB' as output. Then, 'Submit' your search and retreive results via 
'Download', you need to specify a 'Tab-separated' format ! If you download as 'Compressed' you need to decompress the .gz file before running the function <code>readUCSCtable</code> 
In addition, a file with UCSC annotation (Ensrnot accessions and chromosomic locations, obtained using <code><a href="#topic+readUCSCtable">readUCSCtable</a></code>) can be integrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readUniProtExport(
  UniProtFileNa,
  deUcsc = NULL,
  targRegion = NULL,
  useUniPrCol = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readUniProtExport_+3A_uniprotfilena">UniProtFileNa</code></td>
<td>
<p>(character) name (and path) of file exported from Uniprot (tabulated text file inlcuding headers)</p>
</td></tr>
<tr><td><code id="readUniProtExport_+3A_deucsc">deUcsc</code></td>
<td>
<p>(data.frame) object produced by <code>readUCSCtable</code> to be combined with data from <code>UniProtFileNa</code></p>
</td></tr>
<tr><td><code id="readUniProtExport_+3A_targregion">targRegion</code></td>
<td>
<p>(character or list) optional marking of chromosomal locations to be part of a given chromosomal target region, 
may be given as character like <code>chr11:1-135,086,622</code> or as <code>list</code> with a first component characterizing the chromosome and a integer-vector with start- and end- sites</p>
</td></tr>
<tr><td><code id="readUniProtExport_+3A_useuniprcol">useUniPrCol</code></td>
<td>
<p>(character) optional declaration which colums from UniProt exported file should be used/imported (default 'EnsID','Entry','Entry.name','Status','Protein.names','Gene.names','Length').</p>
</td></tr>
<tr><td><code id="readUniProtExport_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readUniProtExport_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="readUniProtExport_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a typicall use case, first chromosomic location annotation is extracted from UCSC for the species of interest and imported to R using  <code><a href="#topic+readUCSCtable">readUCSCtable</a></code> . 
However, the tables provided by UCSC don't contain Uniprot IDs. Thus, an additional (batch-)conversion step needs to get added. 
For this reason <code><a href="#topic+readUCSCtable">readUCSCtable</a></code> allows writing a file with Ensemble transcript IDs which can be converted tu UniProt IDs at the site of  <a href="https://www.uniprot.org/id-mapping/">UniProt</a>. 
Then, UniProt annotation (downloaded as tab-separated) can be imported and combined with the genomic annotation using this function.
</p>


<h3>Value</h3>

<p>This function returns a data.frame (with columns $EnsID, $Entry, $Entry.name, $Status, $Protein.names, $Gene.names, $Length; if <code>deUcsc</code> is integrated plus: $chr, $type, $start, $end, $score, $strand, $Ensrnot, $avPos)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readUCSCtable">readUCSCtable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata",package="wrProteo")
deUniProtFi &lt;- file.path(path1,"deUniProt_hg38chr11extr.tab")
deUniPr1a &lt;- readUniProtExport(deUniProtFi) 
str(deUniPr1a)

## Workflow starting with UCSC annotation (gtf) files :
gtfFi &lt;- file.path(path1,"UCSC_hg38_chr11extr.gtf.gz")
UcscAnnot1 &lt;- readUCSCtable(gtfFi)
## Results of conversion at UniProt are already available (file "deUniProt_hg38chr11extr.tab")
myTargRegion &lt;- list("chr1", pos=c(198110001,198570000))
myTargRegion2 &lt;-"chr11:1-135,086,622"      # works equally well
deUniPr1 &lt;- readUniProtExport(deUniProtFi,deUcsc=UcscAnnot1,
  targRegion=myTargRegion)
## Now UniProt IDs and genomic locations are both available :
str(deUniPr1)
</code></pre>

<hr>
<h2 id='readWombatNormFile'>Read (Normalized) Quantitation Data Files Produced By Wombat At Protein Level</h2><span id='topic+readWombatNormFile'></span>

<h3>Description</h3>

<p>Protein quantification results from <a href="https://github.com/wombat-p">Wombat-P</a> using the Bioconductor package Normalizer can be read using this function and relevant information extracted.
Input files compressed as .gz can be read as well.
The protein abundance values (XIC), peptide counting get extracted. Since protein annotation is not very extensive with this format of data, the function allows reading the
initial fasta files (from the directory above the quantitation-results) allowing to extract more protein-annotation (like species).
Sample-annotation (if available) can be extracted from  sdrf files, which are typically part of the Wombat output, too.
The protein abundance values may be normalized using multiple methods (median normalization as default), the determination of normalization factors can be restricted to specific proteins
(normalization to bait protein(s), or to invariable matrix of spike-in experiments).
The protein annotation data gets parsed to extract specific fields (ID, name, description, species ...).
Besides, a graphical display of the distribution of protein abundance values may be generated before and after normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readWombatNormFile(
  fileName,
  path = NULL,
  quantSoft = "(quant software not specified)",
  fasta = NULL,
  isLog2 = TRUE,
  normalizeMeth = "none",
  quantCol = "abundance_",
  contamCol = NULL,
  pepCountCol = c("number_of_peptides"),
  read0asNA = TRUE,
  refLi = NULL,
  sampleNames = NULL,
  extrColNames = c("protein_group"),
  specPref = NULL,
  remRev = TRUE,
  remConta = FALSE,
  separateAnnot = TRUE,
  gr = NULL,
  sdrf = NULL,
  suplAnnotFile = NULL,
  groupPref = list(lowNumberOfGroups = TRUE),
  titGraph = NULL,
  wex = 1.6,
  plotGraph = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readWombatNormFile_+3A_filename">fileName</code></td>
<td>
<p>(character) name of file to be read (default 'proteinGroups.txt' as typically generated by Compomics in txt folder). Gz-compressed files can be read, too.</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_path">path</code></td>
<td>
<p>(character) path of file to be read</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_quantsoft">quantSoft</code></td>
<td>
<p>(character) qunatification-software used inside Wombat-P</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_fasta">fasta</code></td>
<td>
<p>(logical or character) if <code>TRUE</code> the (first) fasta from one direcory higher than <code>fileName</code> will be read as fasta-file to extract further protein annotation;
if <code>character</code> a fasta-file at this location will be read/used/</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_islog2">isLog2</code></td>
<td>
<p>(logical) typically data read from Wombat are expected to be <code>isLog2=TRUE</code></p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_normalizemeth">normalizeMeth</code></td>
<td>
<p>(character) normalization method, defaults to <code>median</code>, for more details see <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>)</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_quantcol">quantCol</code></td>
<td>
<p>(character or integer) exact col-names, or if length=1 content of <code>quantCol</code> will be used as pattern to search among column-names for $quant using <code>grep</code></p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_contamcol">contamCol</code></td>
<td>
<p>(character or integer, length=1) which columns should be used for contaminants</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_pepcountcol">pepCountCol</code></td>
<td>
<p>(character) pattern to search among column-names for count data (1st entry for 'Razor + unique peptides', 2nd fro 'Unique peptides', 3rd for 'MS.MS.count' (PSM))</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_read0asna">read0asNA</code></td>
<td>
<p>(logical) decide if initial quntifications at 0 should be transformed to NA (thus avoid -Inf in log2 results)</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_refli">refLi</code></td>
<td>
<p>(character or integer) custom specify which line of data should be used for normalization, ie which line is main species; if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_samplenames">sampleNames</code></td>
<td>
<p>(character) custom column-names for quantification data; this argument has priority over <code>suplAnnotFile</code></p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_extrcolnames">extrColNames</code></td>
<td>
<p>(character) column names to be read (1st position: prefix for LFQ quantitation, default 'LFQ.intensity'; 2nd: column name for protein-IDs, default 'Majority.protein.IDs'; 3rd: column names of fasta-headers, default 'Fasta.headers', 4th: column name for number of protein IDs matching, default 'Number.of.proteins')</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_specpref">specPref</code></td>
<td>
<p>(character) prefix to identifiers allowing to separate i) recognize contamination database, ii) species of main identifications and iii) spike-in species</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_remrev">remRev</code></td>
<td>
<p>(logical) option to remove all protein-identifications based on reverse-peptides</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_remconta">remConta</code></td>
<td>
<p>(logical) option to remove all proteins identified as contaminants</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_separateannot">separateAnnot</code></td>
<td>
<p>(logical) if <code>TRUE</code> output will be organized as list with <code>$annot</code>, <code>$abund</code> for initial/raw abundance values and <code>$quant</code> with final normalized quantitations</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_gr">gr</code></td>
<td>
<p>(character or factor) custom defined pattern of replicate association, will override final grouping of replicates from <code>sdrf</code> and/or <code>suplAnnotFile</code> (if provided)   </p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_sdrf">sdrf</code></td>
<td>
<p>(logical, character, list or data.frame) optional extraction and adding of experimenal meta-data:
if <code>sdrf=TRUE</code> the 1st sdrf in the directory above <code>fileName</code> will be used
if character, this may be the ID at ProteomeExchange,
the second element may give futher indicatations for automatic organization of groups of replicates.
Besides, the output from <code>readSdrf</code> or a list from <code>defineSamples</code> may be provided; if <code>gr</code> is provided, <code>gr</code> gets priority for grouping of replicates</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_suplannotfile">suplAnnotFile</code></td>
<td>
<p>(logical or character) optional reading of supplemental files produced by Compomics; if <code>gr</code> is provided, it gets priority for grouping of replicates
if <code>TRUE</code> default to files 'summary.txt' (needed to match information of <code>sdrf</code>) and 'parameters.txt' which can be found in the same folder as the main quantitation results;
if <code>character</code> the respective file-names (relative ro absolute path), 1st is expected to correspond to 'summary.txt' (tabulated text, the samples as given to Compomics) and 2nd to 'parameters.txt' (tabulated text, all parameters given to Compomics)</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_grouppref">groupPref</code></td>
<td>
<p>(list) additional parameters for interpreting meta-data to identify structure of groups (replicates), will be passed to <code>readSampleMetaData</code>.
May contain <code>lowNumberOfGroups=FALSE</code> for automatically choosing a rather elevated number of groups if possible (defaults to low number of groups, ie higher number of samples per group)</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_titgraph">titGraph</code></td>
<td>
<p>(character) custom title to plot of distribution of quantitation values</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_wex">wex</code></td>
<td>
<p>(numeric)  relative expansion factor of the violin in plot</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_plotgraph">plotGraph</code></td>
<td>
<p>(logical) optional plot vioplot of initial and normalized data (using <code>normalizeMeth</code>); alternatively the argument may contain numeric details that will be passed to <code>layout</code> when plotting</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="readWombatNormFile_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By standard workflow of Wombat-P writes the results of each analysis-method/quantification-algorithm as .csv files
Meta-data describing the proteins may be available from two sources :
a) The 1st column of the Wombat/normalizer output.
b) Form the .fasta file in the directory above the analysis/quantiication results of the Wombar-workflow
</p>
<p>Meta-data describing the samples and experimental setup may be available from a sdrf-file (from the directory above the analysis/quantiication results)
If available, the meta-data will be examined for determining groups of replicates and
the results thereof can be found in $sampleSetup$levels.
Alternatively, a dataframe formatted like sdrf-files (ie for each sample a separate line, see also function <code>readSdrf</code>) may be given, too.
</p>
<p>This import-function has been developed using Wombat-P version 1.x.
The final output is a list containing these elements: <code>$raw</code>, <code>$quant</code>, <code>$annot</code>, <code>$counts</code>, <code>$sampleSetup</code>, <code>$quantNotes</code>, <code>$notes</code>, or (if <code>separateAnnot=FALSE</code>) data.frame
with annotation- and main quantification-content. If <code>sdrf</code> information has been found, an add-tional list-element <code>setup</code>
will be added containg the entire meta-data as <code>setup$meta</code> and the suggested organization as <code>setup$lev</code>.
</p>


<h3>Value</h3>

<p>This function returns a list with  <code>$raw</code> (initial/raw abundance values), <code>$quant</code> with final normalized quantitations, <code>$annot</code> (columns ), <code>$counts</code> an array with 'PSM' and 'NoOfRazorPeptides',
<code>$quantNotes</code>, <code>$notes</code> and optional <code>setup</code> for meta-data from <code>sdrf</code>; or a data.frame with quantitation and annotation if <code>separateAnnot=FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="wrMisc.html#topic+normalizeThis">normalizeThis</a></code>) , <code><a href="#topic+readProteomeDiscovererFile">readProteomeDiscovererFile</a></code>; <code><a href="#topic+readProlineFile">readProlineFile</a></code> (and other import-functions), <code><a href="#topic+matrixNAinspect">matrixNAinspect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path1 &lt;- system.file("extdata", package="wrProteo")
# Here we'll load a short/trimmed example file (originating from Compomics)
fiNa &lt;- "tinyWombCompo1.csv.gz"
dataWB &lt;- readWombatNormFile(file=fiNa, path=path1, tit="tiny Wombat/Compomics, Normalized ")
summary(dataWB$quant)
</code></pre>

<hr>
<h2 id='removeSampleInList'>Remove Samples/Columns From list of matrixes</h2><span id='topic+removeSampleInList'></span>

<h3>Description</h3>

<p>Remove samples (ie columns) from every instance of list of matrixes.
Note: This function assumes same order of columns in list-elements 'listElem' !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeSampleInList(
  dat,
  remSamp,
  listElem = c("raw", "quant", "counts", "sampleSetup"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeSampleInList_+3A_dat">dat</code></td>
<td>
<p>(list) main input to be filtered</p>
</td></tr>
<tr><td><code id="removeSampleInList_+3A_remsamp">remSamp</code></td>
<td>
<p>(integer) column number to exclude</p>
</td></tr>
<tr><td><code id="removeSampleInList_+3A_listelem">listElem</code></td>
<td>
<p>(character) names of list-elements where columns indicated with 'remSamp' should be removed</p>
</td></tr>
<tr><td><code id="removeSampleInList_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="removeSampleInList_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="removeSampleInList_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix including imputed values or list of final and matrix with number of imputed by group (plus optional plot)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testRobustToNAimputation">testRobustToNAimputation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019)
datT6 &lt;- matrix(round(rnorm(300)+3,1), ncol=6, dimnames=list(paste("li",1:50,sep=""),
  letters[19:24]))
datL &lt;- list(raw=datT6, quant=datT6, annot=matrix(nrow=nrow(datT6), ncol=2))
datDelta2 &lt;- removeSampleInList(datL, remSam=2)
</code></pre>

<hr>
<h2 id='replMissingProtNames'>Complement Missing EntryNames In Annotation</h2><span id='topic+replMissingProtNames'></span>

<h3>Description</h3>

<p>This function helps replacing missing EntryNames (in $annot) after reading quantification results. 
To do so the comumn-names of <code>annCol</code> will be used : 
The content of 2nd element (and optional 3rd element) will be used to replace missing content in column defined by 1st element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replMissingProtNames(
  x,
  annCol = c("EntryName", "Accession", "SpecType"),
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replMissingProtNames_+3A_x">x</code></td>
<td>
<p>(list) output of <code>readMaxQuantFile</code>, <code>readProtDiscovFile</code> or <code>readProlineFile</code>. 
This list must be a matrix and contain $annot with the columns designated in <code>annCol</code>.</p>
</td></tr>
<tr><td><code id="replMissingProtNames_+3A_anncol">annCol</code></td>
<td>
<p>(character) the column-names form <code>x$annot</code>) which will be used : The first column designs the
column where empty fields are searched and the 2nd and (optional) 3rd will be used to fill the empty spots in the st column</p>
</td></tr>
<tr><td><code id="replMissingProtNames_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="replMissingProtNames_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="replMissingProtNames_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list (like as input), but with missing elments of $annot completed (if available in other columns)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMaxQuantFile">readMaxQuantFile</a></code>, <code><a href="#topic+readProtDiscovFile">readProtDiscovFile</a></code>, <code><a href="#topic+readProlineFile">readProlineFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- list(quant=matrix(sample(11:99,9,replace=TRUE), ncol=3), annot=cbind(EntryName=c(
  "YP010_YEAST","",""),Accession=c("A5Z2X5","P01966","P35900"), SpecType=c("Yeast",NA,NA)))
replMissingProtNames(dat)
</code></pre>

<hr>
<h2 id='shortSoftwName'>Get Short Names of Proteomics Quantitation Software</h2><span id='topic+shortSoftwName'></span>

<h3>Description</h3>

<p>Get/convert short names of various proteomics quantitation software names.
A 2-letter abbreviation will be returned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortSoftwName(
  x,
  tryAsLower = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortSoftwName_+3A_x">x</code></td>
<td>
<p>(character) 'mono' or 'average'</p>
</td></tr>
<tr><td><code id="shortSoftwName_+3A_tryaslower">tryAsLower</code></td>
<td>
<p>(logical)</p>
</td></tr>
<tr><td><code id="shortSoftwName_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="shortSoftwName_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="shortSoftwName_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector with masses for all amino-acids (argument 'massTy' to switch from mono-isotopic to average mass)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+massDeFormula">massDeFormula</a></code>, <code><a href="wrMisc.html#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shortSoftwName(c("maxquant","DIANN"))
</code></pre>

<hr>
<h2 id='summarizeForROC'>Summarize statistical test result for plotting ROC-curves</h2><span id='topic+summarizeForROC'></span>

<h3>Description</h3>

<p>This function takes statistical testing results (obtained using <code><a href="#topic+testRobustToNAimputation">testRobustToNAimputation</a></code> or <code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code>,
based on <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>) and calculates specifcity and sensitivity values for plotting ROC-curves along a panel of thresholds.
Based on annotation (from test$annot) with the user-defined column for species (argument 'spec') the counts of TP (true positives), FP (false positves), FN (false negatives) and TN are determined.
In addition, an optional plot may be produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeForROC(
  test,
  useComp = 1,
  tyThr = "BH",
  thr = NULL,
  columnTest = NULL,
  FCthrs = NULL,
  spec = c("H", "E", "S"),
  annotCol = "Species",
  filterMat = "filter",
  batchMode = FALSE,
  tit = NULL,
  color = 1,
  plotROC = TRUE,
  pch = 1,
  bg = NULL,
  overlPlot = FALSE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeForROC_+3A_test">test</code></td>
<td>
<p>(list or class <code>MArrayLM</code>, S3-object from limma) from testing (eg <code><a href="#topic+testRobustToNAimputation">testRobustToNAimputation</a></code> or <code><a href="#topic+test2grp">test2grp</a></code></p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_usecomp">useComp</code></td>
<td>
<p>(character or integer) in case multiple comparisons (ie multiple columns 'test$tyThr'); which pairwise comparison to used</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_tythr">tyThr</code></td>
<td>
<p>(character,length=1) type of statistical test-result to be used for sensitivity and specificity calculations (eg 'BH','lfdr' or 'p.value'), must be list-element of 'test'</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_thr">thr</code></td>
<td>
<p>(numeric) stat test (FDR/p-value) threshold, if <code>NULL</code> a panel of 108 p-value threshold-levels values will be used for calculating specifcity and sensitivity</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_columntest">columnTest</code></td>
<td>
<p>depreciated, please use 'useComp' instead</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_fcthrs">FCthrs</code></td>
<td>
<p>(numeric) Fold-Change threshold (display as line) give as Fold-change and NOT as log2(FC), default at 1.5, set to <code>NA</code> for omitting</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_spec">spec</code></td>
<td>
<p>(character) labels for those species which should be matched to column <code>annotCol</code> ('spec') of test$annot and used for sensitivity and specificity calculations. Important : 1st entry for species designed as constant (ie matrix) and subsequent labels for spike-ins (expected variable)</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_annotcol">annotCol</code></td>
<td>
<p>(character, length=1) column name of <code>test$annot</code> to use to separate species</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_filtermat">filterMat</code></td>
<td>
<p>(character) name (or index) of element of <code>test</code> containing matrix or vector of logical filtering results</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_batchmode">batchMode</code></td>
<td>
<p>(logical) if <code>batchMode=TRUE</code> the function will return an empty matrix if no proteins qualify for computing ROC (eg all spike-proteins not passig filters), and <code>plotROC</code> will be set to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_tit">tit</code></td>
<td>
<p>(character) optinal custom title in graph</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_color">color</code></td>
<td>
<p>(character or integer) color in graph</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_plotroc">plotROC</code></td>
<td>
<p>(logical) toogle plot on or off</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_pch">pch</code></td>
<td>
<p>(integer) type of symbol to be used (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_bg">bg</code></td>
<td>
<p>(character) backgroud in plot (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_overlplot">overlPlot</code></td>
<td>
<p>(logical) overlay to existing plot if <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="summarizeForROC_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determining TP and FP counts requires 'ground trouth' experiments, where it is known in advance which proteins are expected to change abundance between two groups of samples.
Typically this is done by mixing proteins of different species origin, the first species noted by argument 'spec' designes the species to be considered constant (expected as FN in statistical tests).
Then, one or mutiple additional spike-in species can be defined. As the spike-in cocentration should have been altered between different gruops of samples, they are expected as TP.
</p>
<p>The main aim of this function consists in providing specifcity and sensitivity values, plus counts of TP (true positives), FP (false positves), FN (false negatives) and TN (true negatives),
along various thrsholds (specified in column 'alph') for statistical tests preformed prior to calling this function.
</p>
<p>Note, that the choice of species-annotation plays a crucial role who the counting results are obtained.
In case of multiple spike-in species the user should pay attention if they all are expected to change abundance at the same ratio.
If not, it is advised to run this function multiple times sperately only with the subset of those species expected to change at same ratio.
</p>
<p>The dot on the plotted curve shows the results at the level of the single threshold alpha=0.05.
For plotting multiple ROC curves as overlay and additional graphical parameters/options you may use <code><a href="#topic+plotROC">plotROC</a></code>.
</p>
<p>See also <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">ROC on Wkipedia</a> for explanations of TP,FP,FN and TN as well as examples.
Note that numerous other packages also provide support for building and plotting ROC-curves : Eg <a href="https://CRAN.R-project.org/package=dlstats">rocPkgShort</a>,
<a href="https://CRAN.R-project.org/package=ROCR">ROCR</a>, <a href="https://CRAN.R-project.org/package=pROC">pROC</a> or <a href="https://CRAN.R-project.org/package=ROCit">ROCit</a>
</p>


<h3>Value</h3>

<p>This function returns a numeric matrix containing the columns 'alph', 'spec', 'sens', 'prec', 'accur', 'FD' plus two columns with absolute numbers of lines (genes/proteins) passing the current threshold level alpha (1st species, all other species)
</p>


<h3>See Also</h3>

<p>replot the figure using <code><a href="#topic+plotROC">plotROC</a></code>, calculate AUC using <code><a href="#topic+AucROC">AucROC</a></code>, robust test for preparing tables <code><a href="#topic+testRobustToNAimputation">testRobustToNAimputation</a></code>, <code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code>, <code><a href="#topic+test2grp">test2grp</a></code>, <code>eBayes</code> in package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>, <code><a href="stats.html#topic+t.test">t.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019); test1 &lt;- list(annot=cbind(Species=c(rep("b",35), letters[sample.int(n=3,
  size=150, replace=TRUE)])), BH=matrix(c(runif(35,0,0.01), runif(150)), ncol=1))
tail(roc1 &lt;- summarizeForROC(test1, spec=c("a","b","c"), annotCol="Species"))

</code></pre>

<hr>
<h2 id='test2grp'>t-test each line of 2 groups of data</h2><span id='topic+test2grp'></span>

<h3>Description</h3>

<p><code>test2grp</code> performs t-test on two groups of data using <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>,
this is a custom implementation of <code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code> for proteomics.
The final obkect also includes the results without moderation by <code>limma</code> (eg BH-FDR in <code>$nonMod.BH</code>). 
Furthermore, there is an option to make use of package ROTS (note, this will increase the time of computatins considerably).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test2grp(
  dat,
  questNo,
  useCol = NULL,
  grp = NULL,
  annot = NULL,
  ROTSn = 0,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test2grp_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main data (may contain NAs)</p>
</td></tr>
<tr><td><code id="test2grp_+3A_questno">questNo</code></td>
<td>
<p>(integer) specify here which question, ie comparison should be adressed</p>
</td></tr>
<tr><td><code id="test2grp_+3A_usecol">useCol</code></td>
<td>
<p>(integer or character)</p>
</td></tr>
<tr><td><code id="test2grp_+3A_grp">grp</code></td>
<td>
<p>(character or factor)</p>
</td></tr>
<tr><td><code id="test2grp_+3A_annot">annot</code></td>
<td>
<p>(matrix or data.frame)</p>
</td></tr>
<tr><td><code id="test2grp_+3A_rotsn">ROTSn</code></td>
<td>
<p>(integer) number of iterations ROTS runs (stabilization of reseults may be seen with &gt;300)</p>
</td></tr>
<tr><td><code id="test2grp_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="test2grp_+3A_debug">debug</code></td>
<td>
<p>(logical) display additional messages for debugging</p>
</td></tr>
<tr><td><code id="test2grp_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a limma-type S3 object of class 'MArrayLM' (which can be accessed like a list); multiple testing correction types or modified testing by ROTS may get included ('p.value','FDR','BY','lfdr' or 'ROTS.BH')
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code>, <code><a href="wrMisc.html#topic+pVal2lfdr">pVal2lfdr</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code>, <code>ROTS</code> from the Bioconductor package <a href="https://www.bioconductor.org/packages/release/bioc/html/ROTS.html">ROTS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018);  datT8 &lt;- matrix(round(rnorm(800)+3,1), nc=8, dimnames=list(paste(
  "li",1:100,sep=""), paste(rep(LETTERS[1:3],c(3,3,2)),letters[18:25],sep="")))
datT8[3:6,1:2] &lt;- datT8[3:6,1:2] +3   # augment lines 3:6 (c-f) 
datT8[5:8,5:6] &lt;- datT8[5:8,5:6] +3   # augment lines 5:8 (e-h) 
grp8 &lt;- gl(3,3,labels=LETTERS[1:3],length=8)
datL &lt;- list(data=datT8, filt= wrMisc::presenceFilt(datT8,grp=grp8,maxGrpM=1,ratMa=0.8))
testAvB0 &lt;- wrMisc::moderTest2grp(datT8[,1:6], gl(2,3))
testAvB &lt;- test2grp(datL, questNo=1)
</code></pre>

<hr>
<h2 id='testRobustToNAimputation'>Pair-wise testing robust to NA-imputation</h2><span id='topic+testRobustToNAimputation'></span>

<h3>Description</h3>

<p>This function replaces <code>NA</code> values based on group neighbours (based on grouping of columns in argument <code>gr</code>), following overall assumption of close to Gaussian distribution.
Furthermore, it is assumed that <code>NA</code>-values originate from experimental settings where measurements at or below detection limit are recoreded as <code>NA</code>.
In  such cases (eg in proteomics) it is current practice to replace <code>NA</code>-values by very low (random) values in order to be able to perform t-tests.
However, random normal values used for replacing may in rare cases deviate from the average (the 'assumed' value) and in particular, if multiple <code>NA</code> replacements are above the average, 
may look like induced biological data and be misinterpreted as so.      
The statistical testing uses <code>eBayes</code> from Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a> for robust testing in the context of small numbers of replicates. 
By repeating multiple times the process of replacing <code>NA</code>-values and subsequent testing the results can be sumarized afterwards by median over all repeated runs to remmove the stochastic effect of individual NA-imputation.
Thus, one may gain stability towards random-character of <code>NA</code> imputations by repeating imputation &amp; test 'nLoop' times and summarize p-values by median (results stabilized at 50-100 rounds).
It is necessary to define all groups of replicates in <code>gr</code> to obtain all possible pair-wise testing (multiple columns in $BH, $lfdr etc). 
The modified testing-procedure of Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/ROTS.html">ROTS</a> may optionaly be included, if desired.
This function returns a <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>-like S3 list-object further enriched by additional fields/elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testRobustToNAimputation(
  dat,
  gr = NULL,
  annot = NULL,
  retnNA = TRUE,
  avSd = c(0.15, 0.5),
  avSdH = NULL,
  plotHist = FALSE,
  xLab = NULL,
  tit = NULL,
  imputMethod = "mode2",
  seedNo = NULL,
  multCorMeth = NULL,
  nLoop = 100,
  lfdrInclude = NULL,
  ROTSn = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testRobustToNAimputation_+3A_dat">dat</code></td>
<td>
<p>(matrix or data.frame) main data (may contain <code>NA</code>); if <code>dat</code> is list containing $quant and $annot as matrix, the element $quant will be used</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_gr">gr</code></td>
<td>
<p>(character or factor) replicate association; if <code>dat</code> contains a list-element <code>$sampleSetup$groups</code> or <code>$sampleSetup$lev</code> this may be used in case <code>gr=NULL</code></p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_annot">annot</code></td>
<td>
<p>(matrix or data.frame) annotation (lines must match lines of data !), if <code>annot</code> is <code>NULL</code> and argument <code>dat</code> is a list containing both $quant and $annot, the element $annot will be used</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_retnna">retnNA</code></td>
<td>
<p>(logical) retain and report number of <code>NA</code></p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_avsd">avSd</code></td>
<td>
<p>(numerical,length=2) population characteristics (mean and sd) for &gt;1 <code>NA</code>-neighbours (per line)</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_avsdh">avSdH</code></td>
<td>
<p>depreciated, please use <code>avSd</code> inestad; (numerical,length=2) population characteristics 'high' (mean and sd) for &gt;1 <code>NA</code>-neighbours (per line)</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_plothist">plotHist</code></td>
<td>
<p>(logical) additional histogram of original, imputed and resultant distribution (made using <code><a href="#topic+matrixNAneighbourImpute">matrixNAneighbourImpute</a></code> )</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_xlab">xLab</code></td>
<td>
<p>(character) custom x-axis label</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_tit">tit</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_imputmethod">imputMethod</code></td>
<td>
<p>(character) choose the imputation method (may be 'mode2'(default), 'mode1', 'datQuant', 'modeAdopt', 'informed' or 'none', for details see <code><a href="#topic+matrixNAneighbourImpute">matrixNAneighbourImpute</a></code> )</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_seedno">seedNo</code></td>
<td>
<p>(integer) seed-value for normal random values</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_multcormeth">multCorMeth</code></td>
<td>
<p>(character) define which method(s) for correction of multipl testing should be run (for choice : 'BH','lfdr','BY','tValTab', choosing several is possible)</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_nloop">nLoop</code></td>
<td>
<p>(integer) number of runs of independent <code>NA</code>-imputation</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_lfdrinclude">lfdrInclude</code></td>
<td>
<p>(logical) depreciated, please used <code>multCorMeth</code> instead (include lfdr estimations, may cause warning message(s) concerning convergence if few too lines/proteins in dataset tested).</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_rotsn">ROTSn</code></td>
<td>
<p>(integer) depreciated, please used <code>multCorMeth</code> instead (number of repeats by <code>ROTS</code>, if <code>NULL</code> <code>ROTS</code> will not be called)</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
<tr><td><code id="testRobustToNAimputation_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) This function allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>multCorMeth</code> allows to choose which multiple correction algorimths will be used and included to the final results.
Possible options are 'lfdr','BH','BY','tValTab', ROTSn='100' (name to element necessary) or 'noLimma' (to add initial p.values and BH to limma-results). By default 'lfdr' (local false discovery rate from package 'fdrtools') and 'BH' (Benjamini-Hochberg FDR) are chosen.
The option 'BY' referrs to Benjamini-Yakuteli FDR, 'tValTab' allows exporting all individual t-values from the repeated NA-substitution and subsequent testing.
</p>
<p>This function is compatible with automatic extraction of experimental setup based on sdrf or other quantitation-specific sample annotation.
In this case, the results of automated importing and mining of sample annotation should be stored as <code>$sampleSetup$groups</code> or <code>$sampleSetup$lev</code>  
</p>
<p>For details 'on choice of NA-impuation procedures with arguments 'imputMethod' and 'avSd' please see  <code><a href="#topic+matrixNAneighbourImpute">matrixNAneighbourImpute</a></code>.
</p>


<h3>Value</h3>

<p>This function returns a limma-type S3 object of class 'MArrayLM' (which can be accessed lika a list); multiple results of testing or multiple testing correction types may get included ('p.value','FDR','BY','lfdr' or 'ROTS.BH')
</p>


<h3>See Also</h3>

<p>NA-imputation via <code><a href="#topic+matrixNAneighbourImpute">matrixNAneighbourImpute</a></code>, modereated t-test without NA-imputation <code><a href="wrMisc.html#topic+moderTest2grp">moderTest2grp</a></code>, calculating lfdr <code><a href="wrMisc.html#topic+pVal2lfdr">pVal2lfdr</a></code>, <code>eBayes</code> in Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/limma.html">limma</a>, <code><a href="stats.html#topic+t.test">t.test</a></code>,<code>ROTS</code> of Bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/ROTS.html">ROTS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2015); rand1 &lt;- round(runif(600) +rnorm(600,1,2),3)
dat1 &lt;- matrix(rand1,ncol=6) + matrix(rep((1:100)/20,6),ncol=6)
dat1[13:16,1:3] &lt;- dat1[13:16,1:3] +2      # augment lines 13:16 
dat1[19:20,1:3] &lt;- dat1[19:20,1:3] +3      # augment lines 19:20
dat1[15:18,4:6] &lt;- dat1[15:18,4:6] +1.4    # augment lines 15:18 
dat1[dat1 &lt;1] &lt;- NA                        # mimick some NAs for low abundance
## normalize data
boxplot(dat1, main="data before normalization")
dat1 &lt;- wrMisc::normalizeThis(as.matrix(dat1), meth="median")
## designate replicate relationships in samples ...  
grp1 &lt;- gl(2, 3, labels=LETTERS[1:2])                   
## moderated t-test with repeated inputations (may take &gt;10 sec,  &gt;60 sec if ROTSn &gt;0 !) 
PLtestR1 &lt;- testRobustToNAimputation(dat=dat1, gr=grp1, retnNA=TRUE, nLoop=70)
names(PLtestR1)
</code></pre>

<hr>
<h2 id='VolcanoPlotW2'>Deprecialed Volcano-plot</h2><span id='topic+VolcanoPlotW2'></span>

<h3>Description</h3>

<p>Please use VolcanoPlotW() from package wrGraph.
This function does NOT produce a plot any more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VolcanoPlotW2(
  Mvalue,
  pValue = NULL,
  useComp = 1,
  filtFin = NULL,
  ProjNa = NULL,
  FCthrs = NULL,
  FdrList = NULL,
  FdrThrs = NULL,
  FdrType = NULL,
  subTxt = NULL,
  grayIncrem = TRUE,
  col = NULL,
  pch = 16,
  compNa = NULL,
  batchFig = FALSE,
  cexMa = 1.8,
  cexLa = 1.1,
  limM = NULL,
  limp = NULL,
  annotColumn = NULL,
  annColor = NULL,
  cexPt = NULL,
  cexSub = NULL,
  cexTxLab = 0.7,
  namesNBest = NULL,
  NbestCol = 1,
  sortLeg = "descend",
  NaSpecTypeAsContam = TRUE,
  useMar = c(6.2, 4, 4, 2),
  returnData = FALSE,
  callFrom = NULL,
  silent = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VolcanoPlotW2_+3A_mvalue">Mvalue</code></td>
<td>
<p>(numeric or matrix) data to plot; M-values are typically calculated as difference of log2-abundance values and 'pValue' the mean of log2-abundance values;
M-values and p-values may be given as 2 columsn of a matrix, in this case the argument <code>pValue</code> should remain NULL</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_pvalue">pValue</code></td>
<td>
<p>(numeric, list or data.frame) if <code>NULL</code> it is assumed that 2nd column of 'Mvalue' contains the p-values to be used</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_usecomp">useComp</code></td>
<td>
<p>(integer, length=1) choice of which of multiple comparisons to present in <code>Mvalue</code> (if generated using <code>moderTestXgrp()</code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_filtfin">filtFin</code></td>
<td>
<p>(matrix or logical) The data may get filtered before plotting: If <code>FALSE</code> no filtering will get applied; if matrix of <code>TRUE</code>/<code>FALSE</code> it will be used as optional custom filter, otherwise (if <code>Mvalue</code> if an <code>MArrayLM</code>-object eg from limma) a default filtering based on the <code>filtFin</code> element will be applied</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_projna">ProjNa</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_fcthrs">FCthrs</code></td>
<td>
<p>(numeric) Fold-Change threshold (display as line) give as Fold-change and NOT log2(FC), default at 1.5, set to <code>NA</code> for omitting</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_fdrlist">FdrList</code></td>
<td>
<p>(numeric) FDR data or name of list-element</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_fdrthrs">FdrThrs</code></td>
<td>
<p>(numeric) FDR threshold (display as line), default at 0.05, set to <code>NA</code> for omitting</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_fdrtype">FdrType</code></td>
<td>
<p>(character) FDR-type to extract if <code>Mvalue</code> is 'MArrayLM'-object (eg produced by from <code>moderTest2grp</code> etc);
if <code>NULL</code> it will search for suitable fields/values in this order : 'FDR','BH',&quot;lfdr&quot; and 'BY'</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_subtxt">subTxt</code></td>
<td>
<p>(character) custom sub-title</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_grayincrem">grayIncrem</code></td>
<td>
<p>(logical) if <code>TRUE</code>, display overlay of points as increased shades of gray</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_col">col</code></td>
<td>
<p>(character) custom color(s) for points of plot (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_pch">pch</code></td>
<td>
<p>(integer) type of symbol(s) to plot (default=16) (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_compna">compNa</code></td>
<td>
<p>(character) names of groups compared</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_batchfig">batchFig</code></td>
<td>
<p>(logical) if <code>TRUE</code> figure title and axes legends will be kept shorter for display on fewer splace</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_cexma">cexMa</code></td>
<td>
<p>(numeric) font-size of title, as expansion factor (see also <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_cexla">cexLa</code></td>
<td>
<p>(numeric) size of axis-labels, as expansion factor (see also <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_limm">limM</code></td>
<td>
<p>(numeric, length=2) range of axis M-values</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_limp">limp</code></td>
<td>
<p>(numeric, length=2) range of axis FDR / p-values</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_annotcolumn">annotColumn</code></td>
<td>
<p>(character) column names of annotation to be extracted (only if <code>Mvalue</code> is <code>MArrayLM</code>-object containing matrix $annot).
The first entry (typically 'SpecType') is used for different symbols in figure, the second (typically 'GeneName') is used as prefered text for annotating the best points (if <code>namesNBest</code> allows to do so.)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_anncolor">annColor</code></td>
<td>
<p>(character or integer) colors for specific groups of annoatation (only if <code>Mvalue</code> is <code>MArrayLM</code>-object containing matrix $annot)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_cexpt">cexPt</code></td>
<td>
<p>(numeric) size of points, as expansion factor (see also <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_cexsub">cexSub</code></td>
<td>
<p>(numeric) size of subtitle, as expansion factor (see also <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_cextxlab">cexTxLab</code></td>
<td>
<p>(numeric) size of text-labels for points, as expansion factor (see also <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_namesnbest">namesNBest</code></td>
<td>
<p>(integer or character) number of best points to add names in figure; if 'passThr' all points passing FDR and FC-filtes will be selected; 
if the initial object <code>Mvalue</code> contains a list-element called 'annot' the second of the column specified in argument <code>annotColumn</code> will be used as text</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_nbestcol">NbestCol</code></td>
<td>
<p>(character or integer) colors for text-labels of best points</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_sortleg">sortLeg</code></td>
<td>
<p>(character) sorting of 'SpecType' annotation either ascending ('ascend') or descending ('descend'), no sorting if <code>NULL</code></p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_naspectypeascontam">NaSpecTypeAsContam</code></td>
<td>
<p>(logical) consider lines/proteins with <code>NA</code> in Mvalue$annot[,&quot;SpecType&quot;] as contaminants (if a 'SpecType' for contaminants already exits)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_usemar">useMar</code></td>
<td>
<p>(numeric,length=4) custom margings (see also <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_returndata">returnData</code></td>
<td>
<p>(logical) optional returning data.frame with (ID, Mvalue, pValue, FDRvalue, passFilt)</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="VolcanoPlotW2_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td></tr>
</table>


<h3>Value</h3>

<p>deprecated - returns nothing
</p>


<h3>See Also</h3>

<p>this function was replaced by <code><a href="wrGraph.html#topic+plotPCAw">plotPCAw</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2005); mat &lt;- matrix(round(runif(900),2), ncol=9)
</code></pre>

<hr>
<h2 id='writeFasta2'>Write sequences in fasta format to file
This function writes sequences from character vector as fasta formatted file (from <a href="https://www.uniprot.org">UniProt</a>) 
Line-headers are based on names of elements of input vector <code>prot</code>.
This function also allows comparing the main vector of sequences with a reference vector <code>ref</code> to check if any of the sequences therein are truncated.</h2><span id='topic+writeFasta2'></span>

<h3>Description</h3>

<p>Write sequences in fasta format to file
</p>
<p>This function writes sequences from character vector as fasta formatted file (from <a href="https://www.uniprot.org">UniProt</a>) 
Line-headers are based on names of elements of input vector <code>prot</code>.
This function also allows comparing the main vector of sequences with a reference vector <code>ref</code> to check if any of the sequences therein are truncated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFasta2(
  prot,
  fileNa = NULL,
  ref = NULL,
  lineLength = 60,
  eol = "\n",
  truSuf = "_tru",
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeFasta2_+3A_prot">prot</code></td>
<td>
<p>(character) vector of sequenes, names will be used for fasta-header</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_filena">fileNa</code></td>
<td>
<p>(character) name (and path) for file to be written</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_ref">ref</code></td>
<td>
<p>(character) optional/additional set of (reference-) sequences (only for comparison to <code>prot</code>), length of proteins from <code>prot</code> will be checked to mark truncated proteins by '_tru'</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_linelength">lineLength</code></td>
<td>
<p>(integer, length=1) number of sequence characters per line (default 60, should be &gt;1 and &lt;10000)</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_eol">eol</code></td>
<td>
<p>(character) the character(s) to print at the end of each line (row); for example, eol = &quot;\r\n&quot; will produce Windows' line endings on a Unix-alike OS</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_trusuf">truSuf</code></td>
<td>
<p>(character) suffix to be added for sequences found truncated when comparing with <code>ref</code></p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_debug">debug</code></td>
<td>
<p>(logical) supplemental messages for debugging</p>
</td></tr>
<tr><td><code id="writeFasta2_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of messages produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sequences without any names will be given generic headers like protein01 ... etc.
</p>


<h3>Value</h3>

<p>This function writes the sequences from <code>prot</code> as fasta formatted-file
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readFasta2">readFasta2</a></code> for reading fasta, <code>write.fasta</code> from the package <a href="https://CRAN.R-project.org/package=seqinr">seqinr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prots &lt;- c(SEQU1="ABCDEFGHIJKL", SEQU2="CDEFGHIJKLMNOP")
writeFasta2(prots, fileNa=file.path(tempdir(),"testWrite.fasta"), lineLength=6)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
