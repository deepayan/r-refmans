<!DOCTYPE html><html><head><title>Help for package adaptsmoFMRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adaptsmoFMRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptiveGMRF'><p>Adaptive GMRF Model (Real Data)</p></a></li>
<li><a href='#adaptiveGMRF2COVAR'><p>Adaptive GMRF Model (Real Data)</p></a></li>
<li><a href='#adaptsmoFMRI-package'><p>Adaptive Smoothing of FMRI Data</p></a></li>
<li><a href='#data_simfmri'><p>Simulated FMRI Data Set (for one covariate)</p></a></li>
<li><a href='#data_simfmri2COVAR'><p>Simulated FMRI Data Set (for two covariates)</p></a></li>
<li><a href='#sim.adaptiveGMRF'><p>Adaptive GMRF Model for Simulated Data</p></a></li>
<li><a href='#sim.adaptiveGMRF2COVAR'><p>Adaptive GMRF Model for Simulated Data</p></a></li>
<li><a href='#sim.fmri'><p>Simulate FMRI Data</p></a></li>
<li><a href='#sim.fmri2COVAR'><p>Simulate FMRI Data</p></a></li>
<li><a href='#sim.weightsplot'><p>Plot Function for Weights (Simulated Data)</p></a></li>
<li><a href='#weightsplot'><p>Plot Function for Weights (Real Data)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Smoothing of FMRI Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Adaptive smoothing functions for estimating the blood
    oxygenation level dependent (BOLD) effect by using functional Magnetic
    Resonance Imaging (fMRI) data, based on adaptive Gauss Markov random
    fields, for real as well as simulated data. The implemented models make 
    use of efficient Markov Chain Monte Carlo methods. Implemented methods 
    are based on the research developed by A. Brezger, L. Fahrmeir, A. 
    Hennerfeind (2007) <a href="https://www.jstor.org/stable/4626770">https://www.jstor.org/stable/4626770</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.2.0)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adaptive-gmrf-2covar.R' 'adaptive-gmrf.R'
'plot-weights-real.R' 'plot-weights-sim.R'
'sim-adaptive-gmrf-2covar.R' 'sim-adaptive-gmrf.R'
'sim-fmri-2covar.R' 'sim-fmri.R'</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, spatstat, spatstat.geom, Matrix, coda,
mvtnorm, MCMCpack, parallel</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-24 09:09:31 UTC; gordonmax</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian Hughes [aut, cre, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Hughes &lt;hughesgm@me.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-25 10:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptiveGMRF'>Adaptive GMRF Model (Real Data)</h2><span id='topic+adaptiveGMRF'></span>

<h3>Description</h3>

<p>This function estimates the effects of functional MR
Images (fMRI), with the method of efficient Markov Chain
Monte Carlo (MCMC) simulation. The Metropolis Hastings
(MH) algorithm is used for the non-approximate case and
the Gibbs sampler for the approximate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  adaptiveGMRF(data, hrf, approximate = FALSE, K = 500, a =
    0.001, b = 0.001, c = 0.001, d = 0.001, nu = 1, filter
    = NULL, block = 1, burnin = 1, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptiveGMRF_+3A_data">data</code></td>
<td>
<p>fMRI-data, needs to be an array of dimension
<code>(dx x dy x T)</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_hrf">hrf</code></td>
<td>
<p>haemodynamic response function, needs to be a
vector of length <code>T</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_approximate">approximate</code></td>
<td>
<p>logical, if <code>TRUE</code> then the
approximate case is choosen. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_k">K</code></td>
<td>
<p>scalar, length of the MCMC path, hence iteration
steps.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_a">a</code></td>
<td>
<p>scalar, shape hyperparameter of the
inverse-gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_b">b</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_c">c</code></td>
<td>
<p>scalar, shape hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_d">d</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_filter">filter</code></td>
<td>
<p>scalar, a value between 0 and 1 defining to
which extent the fMRI-data should be filtered.  The
corresponding formular is <code>max(fmri)*filter</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_nu">nu</code></td>
<td>
<p>scalar, shape and scale hyperparameter of the
gamma distribution of the interaction weights
(<code class="reqn">w_{ij}</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_block">block</code></td>
<td>
<p>scalar, when <code>approximate==TRUE</code> then a
block of weights is updated at a time.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_burnin">burnin</code></td>
<td>
<p>scalar, defining the first iteration steps
which should be omitted from MCMC path.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF_+3A_thin">thin</code></td>
<td>
<p>scalar, only every <code>thin</code> step of MCMC
path is saved to output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>dx</code></td>
<td>
<p>scalar, number of pixels in x-direction.</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>scalar, number of pixels in y-direction.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>scalar, number of pixels.</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p>matrix, coordinates of pixels.</p>
</td></tr>
<tr><td><code>NEI</code></td>
<td>
<p>scalar, number of weights.</p>
</td></tr>
<tr><td><code>nei</code></td>
<td>
<p>matrix, locations of weights in precision matrix.</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>matrix, masked out pixels.</p>
</td></tr>
<tr><td><code>beta.out</code></td>
<td>
<p>matrix, MCMC path of covariates.</p>
</td></tr>
<tr><td><code>w.out</code></td>
<td>
<p>matrix, MCMC path of weights.</p>
</td></tr>
<tr><td><code>sigma.out</code></td>
<td>
<p>matrix, MCMC path of variance parameters.</p>
</td></tr>
<tr><td><code>tauk.out</code></td>
<td>
<p>matrix, MCMC path of hyper parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is solely for one covariate and real data
sets.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example function for simulated data (one covariate).
</code></pre>

<hr>
<h2 id='adaptiveGMRF2COVAR'>Adaptive GMRF Model (Real Data)</h2><span id='topic+adaptiveGMRF2COVAR'></span>

<h3>Description</h3>

<p>This function estimates the effects of functional MR
Images (fMRI), with the method of efficient Markov Chain
Monte Carlo (MCMC) simulation. The Metropolis Hastings
(MH) algorithm is used for the non-approximate case and
the Gibbs sampler for the approximate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  adaptiveGMRF2COVAR(data, hrf, approximate = FALSE, K =
    500, a = 0.001, b = 0.001, c = 0.001, d = 0.001, nu =
    1, filter = NULL, block = 1, burnin = 1, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_data">data</code></td>
<td>
<p>fMRI-data, needs to be an array of dimension
<code>(dx x dy x T)</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_hrf">hrf</code></td>
<td>
<p>haemodynamic response function, needs to be a
vector of length <code>T</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_approximate">approximate</code></td>
<td>
<p>logical, if <code>TRUE</code> then the
approximate case is choosen. Def#' ault is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_k">K</code></td>
<td>
<p>scalar, length of the MCMC path, hence iteration
steps.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_a">a</code></td>
<td>
<p>scalar, shape hyperparameter of the
inverse-gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_b">b</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_c">c</code></td>
<td>
<p>scalar, shape hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_d">d</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_filter">filter</code></td>
<td>
<p>scalar, a value between 0 and 1 defining to
which extent the fMRI-data should be filtered.  The
corresponding formular is <code>max(fmri)*filter</code>.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_nu">nu</code></td>
<td>
<p>scalar, shape and scale hyperparameter of the
gamma distribution of the interaction weights
(<code class="reqn">w_{ij}</code>).</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_block">block</code></td>
<td>
<p>scalar, when <code>approximate==TRUE</code> then a
block of weights is updated at a time.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_burnin">burnin</code></td>
<td>
<p>scalar, defining the first iteration steps
which should be omitted from MCMC path.</p>
</td></tr>
<tr><td><code id="adaptiveGMRF2COVAR_+3A_thin">thin</code></td>
<td>
<p>scalar, only every <code>thin</code> step of MCMC
path is saved to output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>dx</code></td>
<td>
<p>scalar, number of pixels in x-direction.</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>scalar, number of pixels in y-direction.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>scalar, number of pixels.</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p>matrix, coordinates of pixels.</p>
</td></tr>
<tr><td><code>NEI</code></td>
<td>
<p>scalar, number of weights.</p>
</td></tr>
<tr><td><code>nei</code></td>
<td>
<p>matrix, locations of weights in precision matrix.</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>matrix, masked out pixels.</p>
</td></tr>
<tr><td><code>beta.out</code></td>
<td>
<p>matrix, MCMC path of covariates.</p>
</td></tr>
<tr><td><code>w.out</code></td>
<td>
<p>matrix, MCMC path of weights.</p>
</td></tr>
<tr><td><code>sigma.out</code></td>
<td>
<p>matrix, MCMC path of variance parameters.</p>
</td></tr>
<tr><td><code>tauk.out</code></td>
<td>
<p>matrix, MCMC path of hyper parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is solely for two covariates and real data
sets.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example function for simulated data (one covariate).
</code></pre>

<hr>
<h2 id='adaptsmoFMRI-package'>Adaptive Smoothing of FMRI Data</h2><span id='topic+adaptsmoFMRI-package'></span><span id='topic+adaptsmoFMRI'></span>

<h3>Description</h3>

<p>Adaptive smoothing functions for estimating the blood
oxygenation level dependent (BOLD) effect by using functional Magnetic
Resonance Imaging (fMRI) data, based on adaptive Gauss Markov random
fields, for real as well as simulated data. The implemented models make 
use of efficient Markov Chain Monte Carlo methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> adaptsmoFMRI</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-16</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Maximilian Hughes
Maintainer: <a href="mailto:hughesgm@me.com">hughesgm@me.com</a>
</p>


<h3>References</h3>

<p>A. Brezger, L. Fahrmeir, A. Hennerfeind
<em>Adaptive Gaussian Markov random fields with applications in
human brain mapping</em>, Applied Statistics, <b>56</b>, Part 3,
pp. 327-345, 2007
</p>
<p>V. J. Schmid, A. Thornton, B. Witcher 
<em>Working with the DICOM and NIfTI Data Standards in R</em>, 
Journal of Statistical Software, <b>Volume 44</b>, Issue 6. 2011
</p>

<hr>
<h2 id='data_simfmri'>Simulated FMRI Data Set (for one covariate)</h2><span id='topic+data_simfmri'></span>

<h3>Description</h3>

<p>The data set contains a synthetic spatiotemporal data set, hence a 
simulated data set. The data set is an array of dimension 20 x 20 x 210.</p>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Note</h3>

<p>This data set was created while inserting one covariate.</p>

<hr>
<h2 id='data_simfmri2COVAR'>Simulated FMRI Data Set (for two covariates)</h2><span id='topic+data_simfmri2COVAR'></span>

<h3>Description</h3>

<p>The data set contains a synthetic spatiotemporal data set, hence a 
simulated data set. The data set is an array of dimension 20 x 20 x 180.</p>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Note</h3>

<p>This data set was created while inserting two covariates.</p>

<hr>
<h2 id='sim.adaptiveGMRF'>Adaptive GMRF Model for Simulated Data</h2><span id='topic+sim.adaptiveGMRF'></span>

<h3>Description</h3>

<p>This function estimates the effects of a synthetic
spatiotemporal data set resembling functional MR Images
(fMRI), with the method of efficient Markov Chain Monte
Carlo (MCMC) simulation. The Metropolis Hastings (MH)
algorithm is used for the non-approximate case and the
Gibbs sampler for the approximate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim.adaptiveGMRF(data, hrf, approximate = FALSE, K = 500,
    a = 1, b = 1, c = 1, d = 1, nu = 1, block = 1, burnin =
    1, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.adaptiveGMRF_+3A_data">data</code></td>
<td>
<p>simulated fMRI-data, needs to be an array of
dimension <code>(20 x 20 x T)</code>.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_hrf">hrf</code></td>
<td>
<p>haemodynamic response function, needs to be a
vector of length <code>T</code>.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_approximate">approximate</code></td>
<td>
<p>logical, if <code>TRUE</code> then the
approximate case is chosen. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_k">K</code></td>
<td>
<p>scalar, length of the MCMC path, hence iteration
steps.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_a">a</code></td>
<td>
<p>scalar, shape hyperparameter of the
inverse-gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_b">b</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_c">c</code></td>
<td>
<p>scalar, shape hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_d">d</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_nu">nu</code></td>
<td>
<p>scalar, shape and scale hyperparameter of the
gamma distribution of the interaction weights
(<code class="reqn">w_{ij}</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_block">block</code></td>
<td>
<p>scalar, when <code>approximate==TRUE</code> then a
block of weights is updated at a time.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_burnin">burnin</code></td>
<td>
<p>scalar, defining the first iteration steps
which should be omitted from MCMC path.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF_+3A_thin">thin</code></td>
<td>
<p>scalar, only every <code>thin</code> step of MCMC
path is saved to output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>dx</code></td>
<td>
<p>scalar, number of pixels in x-direction.</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>scalar, number of pixels in y-direction.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>scalar, number of pixels.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>scalar, number of MCMC iterations.</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p>matrix, coordinates of pixels.</p>
</td></tr>
<tr><td><code>nei</code></td>
<td>
<p>matrix, locations of weights in precision matrix.</p>
</td></tr>
<tr><td><code>NEI</code></td>
<td>
<p>scalar, number of weights.</p>
</td></tr>
<tr><td><code>beta.out</code></td>
<td>
<p>matrix, MCMC path of covariates.</p>
</td></tr>
<tr><td><code>w.out</code></td>
<td>
<p>matrix, MCMC path of weights.</p>
</td></tr>
<tr><td><code>sigma.out</code></td>
<td>
<p>matrix, MCMC path of variance parameters.</p>
</td></tr>
<tr><td><code>tauk.out</code></td>
<td>
<p>matrix, MCMC path of hyper parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is solely for one covariate.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># non-transformed hr-function
T &lt;- 210
seq.length &lt;- T*3
index &lt;- seq(3, T*3, by = 3)
hrf &lt;- rep(c(-0.5, 0.5), each=30, times=ceiling(T/30*1.5))
hrf &lt;- as.matrix(hrf[index])
# get simulated data
data("sim_fmri")
data &lt;- data_simfmri
# execute function
set.seed(111222)
K &lt;- 2
a &lt;- b &lt;- c &lt;- d &lt;- nu &lt;- 1
test.sim.adaptive &lt;- sim.adaptiveGMRF(data, hrf, approximate=TRUE, K,
                                      a, b, c, d, nu)
</code></pre>

<hr>
<h2 id='sim.adaptiveGMRF2COVAR'>Adaptive GMRF Model for Simulated Data</h2><span id='topic+sim.adaptiveGMRF2COVAR'></span>

<h3>Description</h3>

<p>This function estimates the effects of a synthetic
spatiotemporal data set resembling functional MR Images
(fMRI), with the method of efficient Markov Chain Monte
Carlo (MCMC) simulation. The Metropolis Hastings (MH)
algorithm is used for the non-approximate case and the
Gibbs sampler for the approximate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim.adaptiveGMRF2COVAR(data, hrf, approximate = FALSE, K
    = 500, a = 1, b = 1, c = 1, d = 1, nu = 1, block = 1,
    burnin = 1, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_data">data</code></td>
<td>
<p>simulated fMRI-data, needs to be an array of
dimension <code>(20 x 20 x T)</code>.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_hrf">hrf</code></td>
<td>
<p>haemodynamic response function, needs to be a
vector of length <code>T</code>.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_approximate">approximate</code></td>
<td>
<p>logical, if <code>TRUE</code> then the
approximate case is chosen. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_k">K</code></td>
<td>
<p>scalar, length of the MCMC path, hence iteration
steps.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_a">a</code></td>
<td>
<p>scalar, shape hyperparameter of the
inverse-gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_b">b</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the variance parameter
(<code class="reqn">\sigma_i^2</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_c">c</code></td>
<td>
<p>scalar, shape hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_d">d</code></td>
<td>
<p>scalar, scale hyperparameter of the inverse
gamma distribution of the precision parameter
(<code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_nu">nu</code></td>
<td>
<p>scalar, shape and scale hyperparameter of the
gamma distribution of the interaction weights
(<code class="reqn">w_{ij}</code>).</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_block">block</code></td>
<td>
<p>scalar, when <code>approximate==TRUE</code> then a
block of weights is updated at a time.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_burnin">burnin</code></td>
<td>
<p>scalar, defining the first iteration steps
which should be omitted from MCMC path.</p>
</td></tr>
<tr><td><code id="sim.adaptiveGMRF2COVAR_+3A_thin">thin</code></td>
<td>
<p>scalar, only every <code>thin</code> step of MCMC
path is saved to output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>dx</code></td>
<td>
<p>scalar, number of pixels in x-direction.</p>
</td></tr>
<tr><td><code>dy</code></td>
<td>
<p>scalar, number of pixels in y-direction.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>scalar, number of pixels.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>scalar, number of MCMC iterations.</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p>matrix, coordinates of pixels.</p>
</td></tr>
<tr><td><code>nei</code></td>
<td>
<p>matrix, locations of weights in precision matrix.</p>
</td></tr>
<tr><td><code>NEI</code></td>
<td>
<p>scalar, number of weights.</p>
</td></tr>
<tr><td><code>beta.out</code></td>
<td>
<p>matrix, MCMC path of covariates.</p>
</td></tr>
<tr><td><code>w.out</code></td>
<td>
<p>matrix, MCMC path of weights.</p>
</td></tr>
<tr><td><code>sigma.out</code></td>
<td>
<p>matrix, MCMC path of variance parameters.</p>
</td></tr>
<tr><td><code>tauk.out</code></td>
<td>
<p>matrix, MCMC path of hyper parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is solely for two covariates.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example function for simulated data (one covariate).
</code></pre>

<hr>
<h2 id='sim.fmri'>Simulate FMRI Data</h2><span id='topic+sim.fmri'></span>

<h3>Description</h3>

<p>This function returns the synthetic spatiotemporal data
set resembling functional MR Images (fMRI) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim.fmri(hrf, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.fmri_+3A_hrf">hrf</code></td>
<td>
<p>haemodynamic response function, needs to be a
vector of length <code>T</code>.</p>
</td></tr>
<tr><td><code id="sim.fmri_+3A_beta">beta</code></td>
<td>
<p>scalar, defines the height of the activated
area, in form of a cylinder.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned data is simulated on a 20 x 20 grid.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fmri</code></td>
<td>
<p>matrix, simulated fmri data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is solely for one covariate.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># non-transformed hr-function
T &lt;- 210
seq.length &lt;- T*3
index &lt;- seq(3, T*3, by = 3)
hrf &lt;- rep(c(-0.5, 0.5), each=30, times=ceiling(T/30*1.5))
hrf &lt;- as.matrix(hrf[index])
# define height of activation area
beta &lt;- 3
# use function to obtain fmri data
data &lt;- sim.fmri(hrf, beta)$fmri
</code></pre>

<hr>
<h2 id='sim.fmri2COVAR'>Simulate FMRI Data</h2><span id='topic+sim.fmri2COVAR'></span>

<h3>Description</h3>

<p>This function returns the synthetic spatiotemporal data
set resembling functional MR Images (fMRI) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim.fmri2COVAR(hrf, beta.Var1, beta.Var2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.fmri2COVAR_+3A_hrf">hrf</code></td>
<td>
<p>haemodynamic response function, needs to be a
vector of length <code>T</code>.</p>
</td></tr>
<tr><td><code id="sim.fmri2COVAR_+3A_beta.var1">beta.Var1</code></td>
<td>
<p>scalar, defines the height of the
activated area, in form of a cylinder of the first grid.</p>
</td></tr>
<tr><td><code id="sim.fmri2COVAR_+3A_beta.var2">beta.Var2</code></td>
<td>
<p>scalar, defines the height of the
activated area, in form of a cylinder of the second
grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned data is simulated on a 20 x 20 grid.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fmri</code></td>
<td>
<p>matrix, simulated fmri data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is solely for two covariates.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># non-transformed hr-function
T &lt;- 180
seq.length &lt;- T*3
index &lt;- seq(3, T*3, by = 3)
vis &lt;- rep(c(-0.5, 0.5), each=30, times=ceiling(T/30*1.5))
vis &lt;- as.matrix(vis[index])
aud &lt;- rep(c(-0.5, 0.5), each=45, times=ceiling(T/30*1.5))
aud &lt;- as.matrix(aud[index])
hrf &lt;- cbind(vis,aud)
# define height of activation area
beta.Var1 &lt;- beta.Var2 &lt;- 3
# use function to obtain fmri data
data &lt;- sim.fmri2COVAR(hrf, beta.Var1, beta.Var2)$fmri
</code></pre>

<hr>
<h2 id='sim.weightsplot'>Plot Function for Weights (Simulated Data)</h2><span id='topic+sim.weightsplot'></span>

<h3>Description</h3>

<p>This function plots the weights interacting between
estimated effects for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim.weightsplot(weights, nei, nx, ny, thresh = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.weightsplot_+3A_weights">weights</code></td>
<td>
<p>matrix, containing MCMC-output the of
posterior estimates of weights.</p>
</td></tr>
<tr><td><code id="sim.weightsplot_+3A_nei">nei</code></td>
<td>
<p>matrix, locations of weights in precision
matrix.</p>
</td></tr>
<tr><td><code id="sim.weightsplot_+3A_nx">nx</code></td>
<td>
<p>scalar, number of pixels in x-direction.</p>
</td></tr>
<tr><td><code id="sim.weightsplot_+3A_ny">ny</code></td>
<td>
<p>scalar, number of pixels in y-direction.</p>
</td></tr>
<tr><td><code id="sim.weightsplot_+3A_thresh">thresh</code></td>
<td>
<p>scalar, defining the threshold to which the
median of the weights smaller than this threshold should
be plotted.</p>
</td></tr>
<tr><td><code id="sim.weightsplot_+3A_...">...</code></td>
<td>
<p>graphical parameters for <code>image</code> can
also be passed on as arguments to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Note</h3>

<p>This function is solely for MCMC-outputs on simulated
data.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>

<hr>
<h2 id='weightsplot'>Plot Function for Weights (Real Data)</h2><span id='topic+weightsplot'></span>

<h3>Description</h3>

<p>This function plots the weights interacting between
estimated effects for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  weightsplot(weights, nei, nx, ny, coord, thresh = 0.1,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightsplot_+3A_weights">weights</code></td>
<td>
<p>matrix, containing MCMC-output the of
posterior estimates of weights.</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_nei">nei</code></td>
<td>
<p>matrix, locations of weights in precision
matrix.</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_nx">nx</code></td>
<td>
<p>scalar, number of pixels in x-direction.</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_ny">ny</code></td>
<td>
<p>scalar, number of pixels in y-direction.</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_coord">coord</code></td>
<td>
<p>matrix, coordinates of pixels.</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_thresh">thresh</code></td>
<td>
<p>scalar, defining the threshold to which
the median of the weights smaller than this threshold
should be plotted.</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_...">...</code></td>
<td>
<p>graphical parameters for <code>image</code> can
also be passed on as arguments to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Note</h3>

<p>This function is solely for MCMC-outputs on real data.
</p>


<h3>Author(s)</h3>

<p>Maximilian Hughes
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
