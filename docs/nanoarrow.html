<!DOCTYPE html><html><head><title>Help for package nanoarrow</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nanoarrow}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nanoarrow-package'><p>nanoarrow: Interface to the 'nanoarrow' 'C' Library</p></a></li>
<li><a href='#array_stream_set_finalizer'><p>Register an array stream finalizer</p></a></li>
<li><a href='#as_nanoarrow_array'><p>Convert an object to a nanoarrow array</p></a></li>
<li><a href='#as_nanoarrow_array_stream'><p>Convert an object to a nanoarrow array_stream</p></a></li>
<li><a href='#as_nanoarrow_buffer'><p>Convert an object to a nanoarrow buffer</p></a></li>
<li><a href='#as_nanoarrow_schema'><p>Convert an object to a nanoarrow schema</p></a></li>
<li><a href='#basic_array_stream'><p>Create ArrayStreams from batches</p></a></li>
<li><a href='#convert_array'><p>Convert an Array into an R vector</p></a></li>
<li><a href='#convert_array_stream'><p>Convert an Array Stream into an R vector</p></a></li>
<li><a href='#infer_nanoarrow_ptype'><p>Infer an R vector prototype</p></a></li>
<li><a href='#infer_nanoarrow_ptype_extension'><p>Implement Arrow extension types</p></a></li>
<li><a href='#na_type'><p>Create type objects</p></a></li>
<li><a href='#na_vctrs'><p>Vctrs extension type</p></a></li>
<li><a href='#nanoarrow_array_init'><p>Modify nanoarrow arrays</p></a></li>
<li><a href='#nanoarrow_buffer_init'><p>Create and modify nanoarrow buffers</p></a></li>
<li><a href='#nanoarrow_extension_array'><p>Create Arrow extension arrays</p></a></li>
<li><a href='#nanoarrow_extension_spec'><p>Register Arrow extension types</p></a></li>
<li><a href='#nanoarrow_pointer_is_valid'><p>Danger zone: low-level pointer operations</p></a></li>
<li><a href='#nanoarrow_version'><p>Underlying 'nanoarrow' C library build</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to the 'nanoarrow' 'C' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an 'R' interface to the 'nanoarrow' 'C' library and the
  'Apache Arrow' application binary interface. Functions to import and
  export 'ArrowArray', 'ArrowSchema', and 'ArrowArrayStream' 'C' structures
  to and from 'R' objects are provided alongside helpers to facilitate zero-copy
  data transfer among 'R' bindings to libraries implementing the 'Arrow' 'C'
  data interface.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/apache/arrow-nanoarrow">https://github.com/apache/arrow-nanoarrow</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/apache/arrow-nanoarrow/issues">https://github.com/apache/arrow-nanoarrow/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>arrow (&ge; 9.0.0), bit64, blob, hms, rlang, testthat (&ge;
3.0.0), tibble, vctrs, withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/build/bootstrap:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 13:51:24 UTC; dewey</td>
</tr>
<tr>
<td>Author:</td>
<td>Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Apache Arrow [aut, cph],
  Apache Software Foundation [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dewey Dunnington &lt;dewey@dunnington.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 09:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='nanoarrow-package'>nanoarrow: Interface to the 'nanoarrow' 'C' Library</h2><span id='topic+nanoarrow'></span><span id='topic+nanoarrow-package'></span>

<h3>Description</h3>

<p>Provides an 'R' interface to the 'nanoarrow' 'C' library and the 'Apache Arrow' application binary interface. Functions to import and export 'ArrowArray', 'ArrowSchema', and 'ArrowArrayStream' 'C' structures to and from 'R' objects are provided alongside helpers to facilitate zero-copy data transfer among 'R' bindings to libraries implementing the 'Arrow' 'C' data interface.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dewey Dunnington <a href="mailto:dewey@dunnington.ca">dewey@dunnington.ca</a> (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Apache Arrow <a href="mailto:dev@arrow.apache.org">dev@arrow.apache.org</a> [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Apache Software Foundation <a href="mailto:dev@arrow.apache.org">dev@arrow.apache.org</a> [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/apache/arrow-nanoarrow">https://github.com/apache/arrow-nanoarrow</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/apache/arrow-nanoarrow/issues">https://github.com/apache/arrow-nanoarrow/issues</a>
</p>
</li></ul>


<hr>
<h2 id='array_stream_set_finalizer'>Register an array stream finalizer</h2><span id='topic+array_stream_set_finalizer'></span>

<h3>Description</h3>

<p>In some cases, R functions that return a <a href="#topic+as_nanoarrow_array_stream">nanoarrow_array_stream</a>
may require that the scope of some other object outlive that of the array
stream. If there is a need for that object to be released deterministically
(e.g., to close open files), you can register a function to run after the
stream's release callback is invoked from the R thread. Note that this
finalizer will <strong>not</strong> be run if the stream's release callback is invoked
from a <strong>non</strong>-R thread. In this case, the finalizer and its chain of
environments will be garbage-collected when <code>nanoarrow:::preserved_empty()</code>
is run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_stream_set_finalizer(array_stream, finalizer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_stream_set_finalizer_+3A_array_stream">array_stream</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_array_stream">nanoarrow_array_stream</a></p>
</td></tr>
<tr><td><code id="array_stream_set_finalizer_+3A_finalizer">finalizer</code></td>
<td>
<p>A function that will be called with zero arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A newly allocated <code>array_stream</code> whose release callback will call
the supplied finalizer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- array_stream_set_finalizer(
  basic_array_stream(list(1:5)),
  function() message("All done!")
)
stream$release()

</code></pre>

<hr>
<h2 id='as_nanoarrow_array'>Convert an object to a nanoarrow array</h2><span id='topic+as_nanoarrow_array'></span>

<h3>Description</h3>

<p>In nanoarrow an 'array' refers to the <code style="white-space: pre;">&#8288;struct ArrowArray&#8288;</code> definition
in the Arrow C data interface. At the R level, we attach a
<a href="#topic+as_nanoarrow_schema">schema</a> such that functionally the nanoarrow_array
class can be used in a similar way as an <code>arrow::Array</code>. Note that in
nanoarrow an <code>arrow::RecordBatch</code> and a non-nullable <code>arrow::StructArray</code>
are represented identically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nanoarrow_array(x, ..., schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_nanoarrow_array_+3A_x">x</code></td>
<td>
<p>An object to convert to a array</p>
</td></tr>
<tr><td><code id="as_nanoarrow_array_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
<tr><td><code id="as_nanoarrow_array_+3A_schema">schema</code></td>
<td>
<p>An optional schema used to enforce conversion to a particular
type. Defaults to <code><a href="#topic+infer_nanoarrow_schema">infer_nanoarrow_schema()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'nanoarrow_array'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(array &lt;- as_nanoarrow_array(1:5))
as.vector(array)

(array &lt;- as_nanoarrow_array(data.frame(x = 1:5)))
as.data.frame(array)

</code></pre>

<hr>
<h2 id='as_nanoarrow_array_stream'>Convert an object to a nanoarrow array_stream</h2><span id='topic+as_nanoarrow_array_stream'></span>

<h3>Description</h3>

<p>In nanoarrow, an 'array stream' corresponds to the <code style="white-space: pre;">&#8288;struct ArrowArrayStream&#8288;</code>
as defined in the Arrow C Stream interface. This object is used to represent
a stream of <a href="#topic+as_nanoarrow_array">arrays</a> with a common
<a href="#topic+as_nanoarrow_schema">schema</a>. This is similar to an
<a href="arrow.html#topic+RecordBatchReader">arrow::RecordBatchReader</a> except it can be used to represent a stream of
any type (not just record batches). Note that a stream of record batches
and a stream of non-nullable struct arrays are represented identically.
Also note that array streams are mutable objects and are passed by
reference and not by value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nanoarrow_array_stream(x, ..., schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_nanoarrow_array_stream_+3A_x">x</code></td>
<td>
<p>An object to convert to a array_stream</p>
</td></tr>
<tr><td><code id="as_nanoarrow_array_stream_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
<tr><td><code id="as_nanoarrow_array_stream_+3A_schema">schema</code></td>
<td>
<p>An optional schema used to enforce conversion to a particular
type. Defaults to <code><a href="#topic+infer_nanoarrow_schema">infer_nanoarrow_schema()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'nanoarrow_array_stream'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(stream &lt;- as_nanoarrow_array_stream(data.frame(x = 1:5)))
stream$get_schema()
stream$get_next()

# The last batch is returned as NULL
stream$get_next()

# Release the stream
stream$release()

</code></pre>

<hr>
<h2 id='as_nanoarrow_buffer'>Convert an object to a nanoarrow buffer</h2><span id='topic+as_nanoarrow_buffer'></span>

<h3>Description</h3>

<p>Convert an object to a nanoarrow buffer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nanoarrow_buffer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_nanoarrow_buffer_+3A_x">x</code></td>
<td>
<p>An object to convert to a buffer</p>
</td></tr>
<tr><td><code id="as_nanoarrow_buffer_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'nanoarrow_buffer'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>array &lt;- as_nanoarrow_array(c(NA, 1:4))
array$buffers
as.raw(array$buffers[[1]])
as.raw(array$buffers[[2]])
convert_buffer(array$buffers[[1]])
convert_buffer(array$buffers[[2]])

</code></pre>

<hr>
<h2 id='as_nanoarrow_schema'>Convert an object to a nanoarrow schema</h2><span id='topic+as_nanoarrow_schema'></span><span id='topic+infer_nanoarrow_schema'></span><span id='topic+nanoarrow_schema_parse'></span><span id='topic+nanoarrow_schema_modify'></span>

<h3>Description</h3>

<p>In nanoarrow a 'schema' refers to a <code style="white-space: pre;">&#8288;struct ArrowSchema&#8288;</code> as defined in the
Arrow C Data interface. This data structure can be used to represent an
<code><a href="arrow.html#topic+schema">arrow::schema()</a></code>, an <code><a href="arrow.html#topic+Field">arrow::field()</a></code>, or an <code>arrow::DataType</code>. Note that
in nanoarrow, an <code><a href="arrow.html#topic+schema">arrow::schema()</a></code> and a non-nullable <code><a href="arrow.html#topic+data-type">arrow::struct()</a></code>
are represented identically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_nanoarrow_schema(x, ...)

infer_nanoarrow_schema(x, ...)

nanoarrow_schema_parse(x, recursive = FALSE)

nanoarrow_schema_modify(x, new_values, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_nanoarrow_schema_+3A_x">x</code></td>
<td>
<p>An object to convert to a schema</p>
</td></tr>
<tr><td><code id="as_nanoarrow_schema_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
<tr><td><code id="as_nanoarrow_schema_+3A_recursive">recursive</code></td>
<td>
<p>Use <code>TRUE</code> to include a <code>children</code> member when parsing
schemas.</p>
</td></tr>
<tr><td><code id="as_nanoarrow_schema_+3A_new_values">new_values</code></td>
<td>
<p>New schema component to assign</p>
</td></tr>
<tr><td><code id="as_nanoarrow_schema_+3A_validate">validate</code></td>
<td>
<p>Use <code>FALSE</code> to skip schema validation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'nanoarrow_schema'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infer_nanoarrow_schema(integer())
infer_nanoarrow_schema(data.frame(x = integer()))

</code></pre>

<hr>
<h2 id='basic_array_stream'>Create ArrayStreams from batches</h2><span id='topic+basic_array_stream'></span>

<h3>Description</h3>

<p>Create ArrayStreams from batches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basic_array_stream(batches, schema = NULL, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basic_array_stream_+3A_batches">batches</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list()</a></code> of <a href="#topic+as_nanoarrow_array">nanoarrow_array</a> objects
or objects that can be coerced via <code><a href="#topic+as_nanoarrow_array">as_nanoarrow_array()</a></code>.</p>
</td></tr>
<tr><td><code id="basic_array_stream_+3A_schema">schema</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> or <code>NULL</code> to guess
based on the first schema.</p>
</td></tr>
<tr><td><code id="basic_array_stream_+3A_validate">validate</code></td>
<td>
<p>Use <code>FALSE</code> to skip the validation step (i.e., if you
know that the arrays are valid).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+as_nanoarrow_array_stream">nanoarrow_array_stream</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(stream &lt;- basic_array_stream(list(data.frame(a = 1, b = 2))))
as.data.frame(stream$get_next())
stream$get_next()

</code></pre>

<hr>
<h2 id='convert_array'>Convert an Array into an R vector</h2><span id='topic+convert_array'></span>

<h3>Description</h3>

<p>Converts <code>array</code> to the type specified by <code>to</code>. This is a low-level interface;
most users should use <code>as.data.frame()</code> or <code>as.vector()</code> unless finer-grained
control is needed over the conversion. This function is an S3 generic
dispatching on <code>to</code>: developers may implement their own S3 methods for
custom vector types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_array(array, to = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_array_+3A_array">array</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_array">nanoarrow_array</a>.</p>
</td></tr>
<tr><td><code id="convert_array_+3A_to">to</code></td>
<td>
<p>A target prototype object describing the type to which <code>array</code>
should be converted, or <code>NULL</code> to use the default conversion as
returned by <code><a href="#topic+infer_nanoarrow_ptype">infer_nanoarrow_ptype()</a></code>. Alternatively, a function can be
passed to perform an alternative calculation of the default ptype as
a function of <code>array</code> and the default inference of the prototype.</p>
</td></tr>
<tr><td><code id="convert_array_+3A_...">...</code></td>
<td>
<p>Passed to S3 methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conversions are implemented for the following R vector types:
</p>

<ul>
<li> <p><code><a href="base.html#topic+logical">logical()</a></code>: Any numeric type can be converted to <code><a href="base.html#topic+logical">logical()</a></code> in addition
to the bool type. For numeric types, any non-zero value is considered <code>TRUE</code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+integer">integer()</a></code>: Any numeric type can be converted to <code><a href="base.html#topic+integer">integer()</a></code>; however,
a warning will be signaled if the any value is outside the range of the
32-bit integer.
</p>
</li>
<li> <p><code><a href="base.html#topic+double">double()</a></code>: Any numeric type can be converted to <code><a href="base.html#topic+double">double()</a></code>. This
conversion currently does not warn for values that may not roundtrip
through a floating-point double (e.g., very large uint64 and int64 values).
</p>
</li>
<li> <p><code><a href="base.html#topic+character">character()</a></code>: String and large string types can be converted to
<code><a href="base.html#topic+character">character()</a></code>. The conversion does not check for valid UTF-8: if you need
finer-grained control over encodings, use <code>to = blob::blob()</code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+factor">factor()</a></code>: Dictionary-encoded arrays of strings can be converted to
<code>factor()</code>; however, this must be specified explicitly (i.e.,
<code>convert_array(array, factor())</code>) because arrays arriving
in chunks can have dictionaries that contain different levels. Use
<code>convert_array(array, factor(levels = c(...)))</code> to materialize an array
into a vector with known levels.
</p>
</li>
<li> <p><a href="base.html#topic+as.Date">Date</a>: Only the date32 type can be converted to an R Date vector.
</p>
</li>
<li> <p><code><a href="hms.html#topic+hms">hms::hms()</a></code>: Time32 and time64 types can be converted to <code><a href="hms.html#topic+hms">hms::hms()</a></code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+difftime">difftime()</a></code>: Time32, time64, and duration types can be converted to
R <code><a href="base.html#topic+difftime">difftime()</a></code> vectors. The value is converted to match the <code><a href="base.html#topic+units">units()</a></code>
attribute of <code>to</code>.
</p>
</li>
<li> <p><code><a href="blob.html#topic+blob">blob::blob()</a></code>: String, large string, binary, and large binary types can
be converted to <code><a href="blob.html#topic+blob">blob::blob()</a></code>.
</p>
</li>
<li> <p><code><a href="vctrs.html#topic+list_of">vctrs::list_of()</a></code>: List, large list, and fixed-size list types can be
converted to <code><a href="vctrs.html#topic+list_of">vctrs::list_of()</a></code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+data.frame">data.frame()</a></code>: Struct types can be converted to <code><a href="base.html#topic+data.frame">data.frame()</a></code>.
</p>
</li>
<li> <p><code><a href="vctrs.html#topic+unspecified">vctrs::unspecified()</a></code>: Any type can be converted to <code><a href="vctrs.html#topic+unspecified">vctrs::unspecified()</a></code>;
however, a warning will be raised if any non-null values are encountered.
</p>
</li></ul>

<p>In addition to the above conversions, a null array may be converted to any
target prototype except <code><a href="base.html#topic+data.frame">data.frame()</a></code>. Extension arrays are currently
converted as their storage type.
</p>


<h3>Value</h3>

<p>An R vector of type <code>to</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>array &lt;- as_nanoarrow_array(data.frame(x = 1:5))
str(convert_array(array))
str(convert_array(array, to = data.frame(x = double())))

</code></pre>

<hr>
<h2 id='convert_array_stream'>Convert an Array Stream into an R vector</h2><span id='topic+convert_array_stream'></span><span id='topic+collect_array_stream'></span>

<h3>Description</h3>

<p>Converts <code>array_stream</code> to the type specified by <code>to</code>. This is a low-level
interface; most users should use <code>as.data.frame()</code> or <code>as.vector()</code> unless
finer-grained control is needed over the conversion. See <code><a href="#topic+convert_array">convert_array()</a></code>
for details of the conversion process; see <code><a href="#topic+infer_nanoarrow_ptype">infer_nanoarrow_ptype()</a></code> for
default inferences of <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_array_stream(array_stream, to = NULL, size = NULL, n = Inf)

collect_array_stream(array_stream, n = Inf, schema = NULL, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_array_stream_+3A_array_stream">array_stream</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_array_stream">nanoarrow_array_stream</a>.</p>
</td></tr>
<tr><td><code id="convert_array_stream_+3A_to">to</code></td>
<td>
<p>A target prototype object describing the type to which <code>array</code>
should be converted, or <code>NULL</code> to use the default conversion as
returned by <code><a href="#topic+infer_nanoarrow_ptype">infer_nanoarrow_ptype()</a></code>. Alternatively, a function can be
passed to perform an alternative calculation of the default ptype as
a function of <code>array</code> and the default inference of the prototype.</p>
</td></tr>
<tr><td><code id="convert_array_stream_+3A_size">size</code></td>
<td>
<p>The exact size of the output, if known. If specified,
slightly more efficient implementation may be used to collect the output.</p>
</td></tr>
<tr><td><code id="convert_array_stream_+3A_n">n</code></td>
<td>
<p>The maximum number of batches to pull from the array stream.</p>
</td></tr>
<tr><td><code id="convert_array_stream_+3A_schema">schema</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> or <code>NULL</code> to guess
based on the first schema.</p>
</td></tr>
<tr><td><code id="convert_array_stream_+3A_validate">validate</code></td>
<td>
<p>Use <code>FALSE</code> to skip the validation step (i.e., if you
know that the arrays are valid).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>convert_array_stream()</code>: An R vector of type <code>to</code>.
</p>
</li>
<li> <p><code>collect_array_stream()</code>: A <code>list()</code> of <a href="#topic+as_nanoarrow_array">nanoarrow_array</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>stream &lt;- as_nanoarrow_array_stream(data.frame(x = 1:5))
str(convert_array_stream(stream))
str(convert_array_stream(stream, to = data.frame(x = double())))

stream &lt;- as_nanoarrow_array_stream(data.frame(x = 1:5))
collect_array_stream(stream)

</code></pre>

<hr>
<h2 id='infer_nanoarrow_ptype'>Infer an R vector prototype</h2><span id='topic+infer_nanoarrow_ptype'></span>

<h3>Description</h3>

<p>Resolves the default <code>to</code> value to use in <code><a href="#topic+convert_array">convert_array()</a></code> and
<code><a href="#topic+convert_array_stream">convert_array_stream()</a></code>. The default conversions are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_nanoarrow_ptype(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_nanoarrow_ptype_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a>,
<a href="#topic+as_nanoarrow_array">nanoarrow_array</a>, or
<a href="#topic+as_nanoarrow_array_stream">nanoarrow_array_stream</a>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> null to <code><a href="vctrs.html#topic+unspecified">vctrs::unspecified()</a></code>
</p>
</li>
<li><p> boolean to <code><a href="base.html#topic+logical">logical()</a></code>
</p>
</li>
<li><p> int8, uint8, int16, uint16, and int13 to <code><a href="base.html#topic+integer">integer()</a></code>
</p>
</li>
<li><p> uint32, int64, uint64, float, and double to <code><a href="base.html#topic+double">double()</a></code>
</p>
</li>
<li><p> string and large string to <code><a href="base.html#topic+character">character()</a></code>
</p>
</li>
<li><p> struct to <code><a href="base.html#topic+data.frame">data.frame()</a></code>
</p>
</li>
<li><p> binary and large binary to <code><a href="blob.html#topic+blob">blob::blob()</a></code>
</p>
</li>
<li><p> list, large_list, and fixed_size_list to <code><a href="vctrs.html#topic+list_of">vctrs::list_of()</a></code>
</p>
</li>
<li><p> time32 and time64 to <code><a href="hms.html#topic+hms">hms::hms()</a></code>
</p>
</li>
<li><p> duration to <code><a href="base.html#topic+difftime">difftime()</a></code>
</p>
</li>
<li><p> date32 to <code><a href="base.html#topic+as.Date">as.Date()</a></code>
</p>
</li>
<li><p> timestamp to <code><a href="base.html#topic+as.POSIXct">as.POSIXct()</a></code>
</p>
</li></ul>

<p>Additional conversions are possible by specifying an explicit value for
<code>to</code>. For details of each conversion, see <code><a href="#topic+convert_array">convert_array()</a></code>.
</p>


<h3>Value</h3>

<p>An R vector of zero size describing the target into which
the array should be materialized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>infer_nanoarrow_ptype(as_nanoarrow_array(1:10))

</code></pre>

<hr>
<h2 id='infer_nanoarrow_ptype_extension'>Implement Arrow extension types</h2><span id='topic+infer_nanoarrow_ptype_extension'></span><span id='topic+convert_array_extension'></span><span id='topic+as_nanoarrow_array_extension'></span>

<h3>Description</h3>

<p>Implement Arrow extension types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_nanoarrow_ptype_extension(
  extension_spec,
  x,
  ...,
  warn_unregistered = TRUE
)

convert_array_extension(
  extension_spec,
  array,
  to,
  ...,
  warn_unregistered = TRUE
)

as_nanoarrow_array_extension(extension_spec, x, ..., schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_nanoarrow_ptype_extension_+3A_extension_spec">extension_spec</code></td>
<td>
<p>An extension specification inheriting from
'nanoarrow_extension_spec'.</p>
</td></tr>
<tr><td><code id="infer_nanoarrow_ptype_extension_+3A_x">x</code>, <code id="infer_nanoarrow_ptype_extension_+3A_array">array</code>, <code id="infer_nanoarrow_ptype_extension_+3A_to">to</code>, <code id="infer_nanoarrow_ptype_extension_+3A_schema">schema</code>, <code id="infer_nanoarrow_ptype_extension_+3A_...">...</code></td>
<td>
<p>Passed from <code><a href="#topic+infer_nanoarrow_ptype">infer_nanoarrow_ptype()</a></code>,
<code><a href="#topic+convert_array">convert_array()</a></code>, <code><a href="#topic+as_nanoarrow_array">as_nanoarrow_array()</a></code>, and/or
<code><a href="#topic+as_nanoarrow_array_stream">as_nanoarrow_array_stream()</a></code>.</p>
</td></tr>
<tr><td><code id="infer_nanoarrow_ptype_extension_+3A_warn_unregistered">warn_unregistered</code></td>
<td>
<p>Use <code>FALSE</code> to infer/convert based on the storage
type without a warning.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>infer_nanoarrow_ptype_extension()</code>: The R vector prototype to be used
as the default conversion target.
</p>
</li>
<li> <p><code>convert_array_extension()</code>: An R vector of type <code>to</code>.
</p>
</li>
<li> <p><code>as_nanoarrow_array_extension()</code>: A <a href="#topic+as_nanoarrow_array">nanoarrow_array</a>
of type <code>schema</code>.
</p>
</li></ul>


<hr>
<h2 id='na_type'>Create type objects</h2><span id='topic+na_type'></span><span id='topic+na_na'></span><span id='topic+na_bool'></span><span id='topic+na_int8'></span><span id='topic+na_uint8'></span><span id='topic+na_int16'></span><span id='topic+na_uint16'></span><span id='topic+na_int32'></span><span id='topic+na_uint32'></span><span id='topic+na_int64'></span><span id='topic+na_uint64'></span><span id='topic+na_half_float'></span><span id='topic+na_float'></span><span id='topic+na_double'></span><span id='topic+na_string'></span><span id='topic+na_large_string'></span><span id='topic+na_binary'></span><span id='topic+na_large_binary'></span><span id='topic+na_fixed_size_binary'></span><span id='topic+na_date32'></span><span id='topic+na_date64'></span><span id='topic+na_time32'></span><span id='topic+na_time64'></span><span id='topic+na_duration'></span><span id='topic+na_interval_months'></span><span id='topic+na_interval_day_time'></span><span id='topic+na_interval_month_day_nano'></span><span id='topic+na_timestamp'></span><span id='topic+na_decimal128'></span><span id='topic+na_decimal256'></span><span id='topic+na_struct'></span><span id='topic+na_sparse_union'></span><span id='topic+na_dense_union'></span><span id='topic+na_list'></span><span id='topic+na_large_list'></span><span id='topic+na_fixed_size_list'></span><span id='topic+na_map'></span><span id='topic+na_dictionary'></span><span id='topic+na_extension'></span>

<h3>Description</h3>

<p>In nanoarrow, types, fields, and schemas are all represented by a
<a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a>. These functions are convenience
constructors to create these objects in a readable way. Use <code><a href="#topic+na_type">na_type()</a></code> to
construct types based on the constructor name, which is also the name that
prints/is returned by <code><a href="#topic+nanoarrow_schema_parse">nanoarrow_schema_parse()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_type(
  type_name,
  byte_width = NULL,
  unit = NULL,
  timezone = NULL,
  column_types = NULL,
  item_type = NULL,
  key_type = NULL,
  value_type = NULL,
  index_type = NULL,
  ordered = NULL,
  list_size = NULL,
  keys_sorted = NULL,
  storage_type = NULL,
  extension_name = NULL,
  extension_metadata = NULL,
  nullable = NULL
)

na_na(nullable = TRUE)

na_bool(nullable = TRUE)

na_int8(nullable = TRUE)

na_uint8(nullable = TRUE)

na_int16(nullable = TRUE)

na_uint16(nullable = TRUE)

na_int32(nullable = TRUE)

na_uint32(nullable = TRUE)

na_int64(nullable = TRUE)

na_uint64(nullable = TRUE)

na_half_float(nullable = TRUE)

na_float(nullable = TRUE)

na_double(nullable = TRUE)

na_string(nullable = TRUE)

na_large_string(nullable = TRUE)

na_binary(nullable = TRUE)

na_large_binary(nullable = TRUE)

na_fixed_size_binary(byte_width, nullable = TRUE)

na_date32(nullable = TRUE)

na_date64(nullable = TRUE)

na_time32(unit = c("ms", "s"), nullable = TRUE)

na_time64(unit = c("us", "ns"), nullable = TRUE)

na_duration(unit = c("ms", "s", "us", "ns"), nullable = TRUE)

na_interval_months(nullable = TRUE)

na_interval_day_time(nullable = TRUE)

na_interval_month_day_nano(nullable = TRUE)

na_timestamp(unit = c("us", "ns", "s", "ms"), timezone = "", nullable = TRUE)

na_decimal128(precision, scale, nullable = TRUE)

na_decimal256(precision, scale, nullable = TRUE)

na_struct(column_types = list(), nullable = FALSE)

na_sparse_union(column_types = list())

na_dense_union(column_types = list())

na_list(item_type, nullable = TRUE)

na_large_list(item_type, nullable = TRUE)

na_fixed_size_list(item_type, list_size, nullable = TRUE)

na_map(key_type, item_type, keys_sorted = FALSE, nullable = TRUE)

na_dictionary(value_type, index_type = na_int32(), ordered = FALSE)

na_extension(storage_type, extension_name, extension_metadata = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_type_+3A_type_name">type_name</code></td>
<td>
<p>The name of the type (e.g., &quot;int32&quot;). This form of the
constructor is useful for writing tests that loop over many types.</p>
</td></tr>
<tr><td><code id="na_type_+3A_byte_width">byte_width</code></td>
<td>
<p>For <code><a href="#topic+na_fixed_size_binary">na_fixed_size_binary()</a></code>, the number of bytes
occupied by each item.</p>
</td></tr>
<tr><td><code id="na_type_+3A_unit">unit</code></td>
<td>
<p>One of 's' (seconds), 'ms' (milliseconds), 'us' (microseconds),
or 'ns' (nanoseconds).</p>
</td></tr>
<tr><td><code id="na_type_+3A_timezone">timezone</code></td>
<td>
<p>A string representing a timezone name. The empty string &quot;&quot;
represents a naive point in time (i.e., one that has no associated
timezone).</p>
</td></tr>
<tr><td><code id="na_type_+3A_column_types">column_types</code></td>
<td>
<p>A <code>list()</code> of <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a>s.</p>
</td></tr>
<tr><td><code id="na_type_+3A_item_type">item_type</code></td>
<td>
<p>For <code><a href="#topic+na_list">na_list()</a></code>, <code><a href="#topic+na_large_list">na_large_list()</a></code>, <code><a href="#topic+na_fixed_size_list">na_fixed_size_list()</a></code>,
and <code><a href="#topic+na_map">na_map()</a></code>, the <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> representing
the item type.</p>
</td></tr>
<tr><td><code id="na_type_+3A_key_type">key_type</code></td>
<td>
<p>The <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> representing the
<code><a href="#topic+na_map">na_map()</a></code> key type.</p>
</td></tr>
<tr><td><code id="na_type_+3A_value_type">value_type</code></td>
<td>
<p>The <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> representing the
<code><a href="#topic+na_dictionary">na_dictionary()</a></code> or <code><a href="#topic+na_map">na_map()</a></code> value type.</p>
</td></tr>
<tr><td><code id="na_type_+3A_index_type">index_type</code></td>
<td>
<p>The <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> representing the
<code><a href="#topic+na_dictionary">na_dictionary()</a></code> index type.</p>
</td></tr>
<tr><td><code id="na_type_+3A_ordered">ordered</code></td>
<td>
<p>Use <code>TRUE</code> to assert that the order of values in the
dictionary are meaningful.</p>
</td></tr>
<tr><td><code id="na_type_+3A_list_size">list_size</code></td>
<td>
<p>The number of elements in each item in a
<code><a href="#topic+na_fixed_size_list">na_fixed_size_list()</a></code>.</p>
</td></tr>
<tr><td><code id="na_type_+3A_keys_sorted">keys_sorted</code></td>
<td>
<p>Use <code>TRUE</code> to assert that keys are sorted.</p>
</td></tr>
<tr><td><code id="na_type_+3A_storage_type">storage_type</code></td>
<td>
<p>For <code><a href="#topic+na_extension">na_extension()</a></code>, the underlying value type.</p>
</td></tr>
<tr><td><code id="na_type_+3A_extension_name">extension_name</code></td>
<td>
<p>For <code><a href="#topic+na_extension">na_extension()</a></code>, the extension name. This is
typically namespaced separated by dots (e.g., arrow.r.vctrs).</p>
</td></tr>
<tr><td><code id="na_type_+3A_extension_metadata">extension_metadata</code></td>
<td>
<p>A string or raw vector defining extension metadata.
Most Arrow extension types define extension metadata as a JSON object.</p>
</td></tr>
<tr><td><code id="na_type_+3A_nullable">nullable</code></td>
<td>
<p>Use <code>FALSE</code> to assert that this field cannot contain
null values.</p>
</td></tr>
<tr><td><code id="na_type_+3A_precision">precision</code></td>
<td>
<p>The total number of digits representable by the decimal type</p>
</td></tr>
<tr><td><code id="na_type_+3A_scale">scale</code></td>
<td>
<p>The number of digits after the decimal point in a decimal type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na_int32()
na_struct(list(col1 = na_int32()))

</code></pre>

<hr>
<h2 id='na_vctrs'>Vctrs extension type</h2><span id='topic+na_vctrs'></span>

<h3>Description</h3>

<p>The Arrow format provides a rich type system that can handle most R
vector types; however, many R vector types do not roundtrip perfectly
through Arrow memory. The vctrs extension type uses <code><a href="vctrs.html#topic+vec_data">vctrs::vec_data()</a></code>,
<code><a href="vctrs.html#topic+vec_proxy">vctrs::vec_restore()</a></code>, and <code><a href="vctrs.html#topic+vec_ptype">vctrs::vec_ptype()</a></code> in calls to
<code><a href="#topic+as_nanoarrow_array">as_nanoarrow_array()</a></code> and <code><a href="#topic+convert_array">convert_array()</a></code> to ensure roundtrip fidelity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_vctrs(ptype, storage_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_vctrs_+3A_ptype">ptype</code></td>
<td>
<p>A vctrs prototype as returned by <code><a href="vctrs.html#topic+vec_ptype">vctrs::vec_ptype()</a></code>.
The prototype can be of arbitrary size, but a zero-size vector
is sufficient here.</p>
</td></tr>
<tr><td><code id="na_vctrs_+3A_storage_type">storage_type</code></td>
<td>
<p>For <code><a href="#topic+na_extension">na_extension()</a></code>, the underlying value type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vctr &lt;- as.POSIXlt("2000-01-02 03:45", tz = "UTC")
array &lt;- as_nanoarrow_array(vctr, schema = na_vctrs(vctr))
infer_nanoarrow_ptype(array)
convert_array(array)

</code></pre>

<hr>
<h2 id='nanoarrow_array_init'>Modify nanoarrow arrays</h2><span id='topic+nanoarrow_array_init'></span><span id='topic+nanoarrow_array_set_schema'></span><span id='topic+nanoarrow_array_modify'></span>

<h3>Description</h3>

<p>Create a new array or from an existing array, modify one or more parameters.
When importing an array from elsewhere, <code>nanoarrow_array_set_schema()</code> is
useful to attach the data type information to the array (without this
information there is little that nanoarrow can do with the array since its
content cannot be otherwise interpreted). <code>nanoarrow_array_modify()</code> can
create a shallow copy and modify various parameters to create a new array,
including setting children and buffers recursively. These functions power the
<code style="white-space: pre;">&#8288;$&lt;-&#8288;</code> operator, which can modify one parameter at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoarrow_array_init(schema)

nanoarrow_array_set_schema(array, schema, validate = TRUE)

nanoarrow_array_modify(array, new_values, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoarrow_array_init_+3A_schema">schema</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a> to attach to this
<code>array</code>.</p>
</td></tr>
<tr><td><code id="nanoarrow_array_init_+3A_array">array</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_array">nanoarrow_array</a>.</p>
</td></tr>
<tr><td><code id="nanoarrow_array_init_+3A_validate">validate</code></td>
<td>
<p>Use <code>FALSE</code> to skip validation. Skipping validation may
result in creating an array that will crash R.</p>
</td></tr>
<tr><td><code id="nanoarrow_array_init_+3A_new_values">new_values</code></td>
<td>
<p>A named <code>list()</code> of values to replace.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>nanoarrow_array_init()</code> returns a possibly invalid but initialized
array with a given <code>schema</code>.
</p>
</li>
<li> <p><code>nanoarrow_array_set_schema()</code> returns <code>array</code>, invisibly. Note that
<code>array</code> is modified in place by reference.
</p>
</li>
<li> <p><code>nanoarrow_array_modify()</code> returns a shallow copy of <code>array</code> with the
modified parameters such that the original array remains valid.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nanoarrow_array_init(na_string())

# Modify an array using $ and &lt;-
array &lt;- as_nanoarrow_array(1:5)
array$length &lt;- 4
as.vector(array)

# Modify potentially more than one component at a time
array &lt;- as_nanoarrow_array(1:5)
as.vector(nanoarrow_array_modify(array, list(length = 4)))

# Attach a schema to an array
array &lt;- as_nanoarrow_array(-1L)
nanoarrow_array_set_schema(array, na_uint32())
as.vector(array)

</code></pre>

<hr>
<h2 id='nanoarrow_buffer_init'>Create and modify nanoarrow buffers</h2><span id='topic+nanoarrow_buffer_init'></span><span id='topic+nanoarrow_buffer_append'></span><span id='topic+convert_buffer'></span>

<h3>Description</h3>

<p>Create and modify nanoarrow buffers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoarrow_buffer_init()

nanoarrow_buffer_append(buffer, new_buffer)

convert_buffer(buffer, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoarrow_buffer_init_+3A_buffer">buffer</code>, <code id="nanoarrow_buffer_init_+3A_new_buffer">new_buffer</code></td>
<td>
<p><a href="#topic+as_nanoarrow_buffer">nanoarrow_buffer</a>s.</p>
</td></tr>
<tr><td><code id="nanoarrow_buffer_init_+3A_to">to</code></td>
<td>
<p>A target prototype object describing the type to which <code>array</code>
should be converted, or <code>NULL</code> to use the default conversion as
returned by <code><a href="#topic+infer_nanoarrow_ptype">infer_nanoarrow_ptype()</a></code>. Alternatively, a function can be
passed to perform an alternative calculation of the default ptype as
a function of <code>array</code> and the default inference of the prototype.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>nanoarrow_buffer_init()</code>: An object of class 'nanoarrow_buffer'
</p>
</li>
<li> <p><code>nanoarrow_buffer_append()</code>: Returns <code>buffer</code>, invisibly. Note that
<code>buffer</code> is modified in place by reference.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>buffer &lt;- nanoarrow_buffer_init()
nanoarrow_buffer_append(buffer, 1:5)

array &lt;- nanoarrow_array_modify(
  nanoarrow_array_init(na_int32()),
  list(length = 5, buffers = list(NULL, buffer))
)
as.vector(array)

</code></pre>

<hr>
<h2 id='nanoarrow_extension_array'>Create Arrow extension arrays</h2><span id='topic+nanoarrow_extension_array'></span>

<h3>Description</h3>

<p>Create Arrow extension arrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoarrow_extension_array(
  storage_array,
  extension_name,
  extension_metadata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoarrow_extension_array_+3A_storage_array">storage_array</code></td>
<td>
<p>A <a href="#topic+as_nanoarrow_array">nanoarrow_array</a>.</p>
</td></tr>
<tr><td><code id="nanoarrow_extension_array_+3A_extension_name">extension_name</code></td>
<td>
<p>For <code><a href="#topic+na_extension">na_extension()</a></code>, the extension name. This is
typically namespaced separated by dots (e.g., arrow.r.vctrs).</p>
</td></tr>
<tr><td><code id="nanoarrow_extension_array_+3A_extension_metadata">extension_metadata</code></td>
<td>
<p>A string or raw vector defining extension metadata.
Most Arrow extension types define extension metadata as a JSON object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+as_nanoarrow_array">nanoarrow_array</a> with attached extension
schema.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nanoarrow_extension_array(1:10, "some_ext", '{"key": "value"}')

</code></pre>

<hr>
<h2 id='nanoarrow_extension_spec'>Register Arrow extension types</h2><span id='topic+nanoarrow_extension_spec'></span><span id='topic+register_nanoarrow_extension'></span><span id='topic+unregister_nanoarrow_extension'></span><span id='topic+resolve_nanoarrow_extension'></span>

<h3>Description</h3>

<p>Register Arrow extension types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoarrow_extension_spec(data = list(), subclass = character())

register_nanoarrow_extension(extension_name, extension_spec)

unregister_nanoarrow_extension(extension_name)

resolve_nanoarrow_extension(extension_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoarrow_extension_spec_+3A_data">data</code></td>
<td>
<p>Optional data to include in the extension type specification</p>
</td></tr>
<tr><td><code id="nanoarrow_extension_spec_+3A_subclass">subclass</code></td>
<td>
<p>A subclass for the extension type specification. Extension
methods will dispatch on this object.</p>
</td></tr>
<tr><td><code id="nanoarrow_extension_spec_+3A_extension_name">extension_name</code></td>
<td>
<p>An Arrow extension type name (e.g., arrow.r.vctrs)</p>
</td></tr>
<tr><td><code id="nanoarrow_extension_spec_+3A_extension_spec">extension_spec</code></td>
<td>
<p>An extension specification inheriting from
'nanoarrow_extension_spec'.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>nanoarrow_extension_spec()</code> returns an object of class
'nanoarrow_extension_spec'.
</p>
</li>
<li> <p><code>register_nanoarrow_extension()</code> returns <code>extension_spec</code>, invisibly.
</p>
</li>
<li> <p><code>unregister_nanoarrow_extension()</code> returns <code>extension_name</code>, invisibly.
</p>
</li>
<li> <p><code>resolve_nanoarrow_extension()</code> returns an object of class
'nanoarrow_extension_spec' or NULL if the extension type was not
registered.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nanoarrow_extension_spec("mynamespace.mytype", subclass = "mypackage_mytype_spec")
</code></pre>

<hr>
<h2 id='nanoarrow_pointer_is_valid'>Danger zone: low-level pointer operations</h2><span id='topic+nanoarrow_pointer_is_valid'></span><span id='topic+nanoarrow_pointer_addr_dbl'></span><span id='topic+nanoarrow_pointer_addr_chr'></span><span id='topic+nanoarrow_pointer_addr_pretty'></span><span id='topic+nanoarrow_pointer_release'></span><span id='topic+nanoarrow_pointer_move'></span><span id='topic+nanoarrow_pointer_export'></span><span id='topic+nanoarrow_allocate_schema'></span><span id='topic+nanoarrow_allocate_array'></span><span id='topic+nanoarrow_allocate_array_stream'></span><span id='topic+nanoarrow_pointer_set_protected'></span>

<h3>Description</h3>

<p>The <a href="#topic+as_nanoarrow_schema">nanoarrow_schema</a>,
<a href="#topic+as_nanoarrow_array">nanoarrow_array</a>,
and <a href="#topic+as_nanoarrow_array_stream">nanoarrow_array_stream</a> classes are
represented in R as external pointers (<code>EXTPTRSXP</code>). When these objects
go out of scope (i.e., when they are garbage collected or shortly
thereafter), the underlying object's <code>release()</code> callback is called if
the underlying pointer is non-null and if the <code>release()</code> callback is
non-null.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoarrow_pointer_is_valid(ptr)

nanoarrow_pointer_addr_dbl(ptr)

nanoarrow_pointer_addr_chr(ptr)

nanoarrow_pointer_addr_pretty(ptr)

nanoarrow_pointer_release(ptr)

nanoarrow_pointer_move(ptr_src, ptr_dst)

nanoarrow_pointer_export(ptr_src, ptr_dst)

nanoarrow_allocate_schema()

nanoarrow_allocate_array()

nanoarrow_allocate_array_stream()

nanoarrow_pointer_set_protected(ptr_src, protected)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoarrow_pointer_is_valid_+3A_ptr">ptr</code>, <code id="nanoarrow_pointer_is_valid_+3A_ptr_src">ptr_src</code>, <code id="nanoarrow_pointer_is_valid_+3A_ptr_dst">ptr_dst</code></td>
<td>
<p>An external pointer to a <code style="white-space: pre;">&#8288;struct ArrowSchema&#8288;</code>,
<code style="white-space: pre;">&#8288;struct ArrowArray&#8288;</code>, or <code style="white-space: pre;">&#8288;struct ArrowArrayStream&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nanoarrow_pointer_is_valid_+3A_protected">protected</code></td>
<td>
<p>An object whose scope must outlive that of <code>ptr</code>. This is
useful for array streams since at least two specifications involving the
array stream specify that the stream is only valid for the lifecycle of
another object (e.g., an AdbcStatement or OGRDataset).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When interacting with other C Data Interface implementations, it is
important to keep in mind that the R object wrapping these pointers is
always passed by reference (because it is an external pointer) and may
be referred to by another R object (e.g., an element in a <code>list()</code> or as a
variable assigned in a user's environment). When importing a schema,
array, or array stream into nanoarrow this is not a problem: the R object
takes ownership of the lifecycle and memory is released when the R
object is garbage collected. In this case, one can use
<code><a href="#topic+nanoarrow_pointer_move">nanoarrow_pointer_move()</a></code> where <code>ptr_dst</code> was created using
<code style="white-space: pre;">&#8288;nanoarrow_allocate_*()&#8288;</code>.
</p>
<p>The case of exporting is more complicated and as such has a dedicated
function, <code><a href="#topic+nanoarrow_pointer_export">nanoarrow_pointer_export()</a></code>, that implements different logic
schemas, arrays, and array streams:
</p>

<ul>
<li><p> Schema objects are (deep) copied such that a fresh copy of the schema
is exported and made the responsibility of some other C data interface
implementation.
</p>
</li>
<li><p> Array objects are exported as a shell around the original array that
preserves a reference to the R object. This ensures that the buffers
and children pointed to by the array are not copied and that any references
to the original array are not invalidated.
</p>
</li>
<li><p> Array stream objects are moved: the responsibility for the object is
transferred to the other C data interface implementation and any
references to the original R object are invalidated. Because these
objects are mutable, this is typically what you want (i.e., you should
not be pulling arrays from a stream accidentally from two places).
</p>
</li></ul>

<p>If you know the lifecycle of your object (i.e., you created the R object
yourself and never passed references to it elsewhere), you can slightly
more efficiently call <code><a href="#topic+nanoarrow_pointer_move">nanoarrow_pointer_move()</a></code> for all three pointer
types.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>nanoarrow_pointer_is_valid()</code> returns TRUE if the pointer is non-null
and has a non-null release callback.
</p>
</li>
<li> <p><code>nanoarrow_pointer_addr_dbl()</code> and <code>nanoarrow_pointer_addr_chr()</code> return
pointer representations that may be helpful to facilitate moving or
exporting nanoarrow objects to other libraries.
</p>
</li>
<li> <p><code>nanoarrow_pointer_addr_pretty()</code> gives a pointer representation suitable
for printing or error messages.
</p>
</li>
<li> <p><code>nanoarrow_pointer_release()</code> returns <code>ptr</code>, invisibly.
</p>
</li>
<li> <p><code>nanoarrow_pointer_move()</code> and <code>nanoarrow_pointer_export()</code> reeturn
<code>ptr_dst</code>, invisibly.
</p>
</li>
<li> <p><code>nanoarrow_allocate_array()</code>, <code>nanoarrow_allocate_schema()</code>, and
<code>nanoarrow_allocate_array_stream()</code> return an
<a href="#topic+as_nanoarrow_array">array</a>, a <a href="#topic+as_nanoarrow_schema">schema</a>, and an
<a href="#topic+as_nanoarrow_array_stream">array stream</a>, respectively.
</p>
</li></ul>


<hr>
<h2 id='nanoarrow_version'>Underlying 'nanoarrow' C library build</h2><span id='topic+nanoarrow_version'></span>

<h3>Description</h3>

<p>Underlying 'nanoarrow' C library build
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nanoarrow_version(runtime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nanoarrow_version_+3A_runtime">runtime</code></td>
<td>
<p>Compare TRUE and FALSE values to detect a
possible ABI mismatch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string identifying the version of nanoarrow this package
was compiled against.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nanoarrow_version()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
