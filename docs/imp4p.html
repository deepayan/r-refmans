<!DOCTYPE html><html><head><title>Help for package imp4p</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imp4p}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#imp4p-package'><p>Introduction to the IMP4P package</p></a></li>
<li><a href='#estim.bound'>
<p>Estimation of lower and upper bounds for missing values.</p></a></li>
<li><a href='#estim.mix'>
<p>Estimation of a mixture model of MCAR and MNAR values in each column of a data matrix.</p></a></li>
<li><a href='#fast_apply_nb_na'>
<p>Function similar to the function <code>apply(X,dim,function(x)sum(is.na(x)))</code>.</p></a></li>
<li><a href='#fast_apply_nb_not_na'>
<p>Function similar to the function <code>apply(X,dim,function(x)sum(!is.na(x)))</code>.</p></a></li>
<li><a href='#fast_apply_sd_na_rm_T'>
<p>Function similar to the function <code>apply(X,dim,sd,na.rm=TRUE)</code>.</p></a></li>
<li><a href='#fast_apply_sum_na_rm_T'>
<p>Function similar to the function <code>apply(X,dim,sum,na.rm=TRUE)</code>.</p></a></li>
<li><a href='#fast_sim'>
<p>Function to compute similarity measures between a vector and each row of a matrix.</p></a></li>
<li><a href='#gen.cond'>
<p>Function allowing to create a vector indicating the membership of each sample to a condition.</p></a></li>
<li><a href='#impute.igcda'>
<p>Imputing missing values by assuming that the distribution of complete values is Gaussian in each column of an input matrix. This algorithm is named &quot;Imputation under a Gaussian Complete Data Assumption&quot; (IGCDA).</p></a></li>
<li><a href='#impute.mi'>
<p>Imputation of data sets containing peptide intensities with a multiple imputation strategy.</p></a></li>
<li><a href='#impute.mix'>
<p>Imputation using a decision rule under an assumption of a mixture of MCAR and MNAR values.</p></a></li>
<li><a href='#impute.mle'>
<p>Imputing missing values using a maximum likelihood estimation (MLE).</p></a></li>
<li><a href='#impute.pa'>
<p>Imputation of peptides having no value in a biological condition (present in a condition / absent in another).</p></a></li>
<li><a href='#impute.PCA'>
<p>Imputing missing values using Principal Components Analysis.</p></a></li>
<li><a href='#impute.rand'>
<p>Imputation of peptides with a random value.</p></a></li>
<li><a href='#impute.RF'>
<p>Imputing missing values using Random Forest.</p></a></li>
<li><a href='#impute.slsa'>
<p>Imputing missing values using an adaptation of the LSimpute algorithm (Bo et al. (2004)) to experimental designs. This algorithm is named &quot;Structured Least Squares Algorithm&quot; (SLSA).</p></a></li>
<li><a href='#mi.mix'>
<p>Multiple imputation from a matrix of probabilities of being MCAR for each missing value.</p></a></li>
<li><a href='#miss.mcar.process'>
<p>Estimating the MCAR mechanism in a sample.</p></a></li>
<li><a href='#miss.total.process'>
<p>Estimating the missing data mechanism in a sample.</p></a></li>
<li><a href='#pi.mcar.karpievitch'>
<p>Estimating the proportion of MCAR values in biological conditions using the method of Karpievitch (2009).</p></a></li>
<li><a href='#pi.mcar.logit'>
<p>Estimating the proportion of MCAR values in a sample using a logit model.</p></a></li>
<li><a href='#pi.mcar.probit'>
<p>Estimating the proportion of MCAR values in a sample using a probit model.</p></a></li>
<li><a href='#prob.mcar'>
<p>Estimation of a vector of probabilities that missing values are MCAR.</p></a></li>
<li><a href='#prob.mcar.tab'>
<p>Estimation of a matrix of probabilities that missing values are MCAR.</p></a></li>
<li><a href='#sim.data'>
<p>Simulation of data sets by controlling the proportion of MCAR values and the distribution of MNAR values.</p></a></li>
<li><a href='#translatedRandomBeta'>
<p>Function to generated values following a translated Beta distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imputation for Proteomics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Quentin Giai Gianetto</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to analyse missing value mechanisms and to impute data sets in the context of bottom-up MS-based proteomics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), Iso, stats, truncnorm, norm, missForest, missMDA</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.8)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-02 09:05:48 UTC; qgiaigia</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-02 21:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='imp4p-package'>Introduction to the IMP4P package</h2><span id='topic+imp4p-package'></span><span id='topic+imp4p'></span>

<h3>Description</h3>

<p>This package provides functions to analyse missing value mechanisms in the context of bottom-up MS-based quantitative proteomics.
</p>
<p>It allows estimating a mixture model of missing completely-at-random (MCAR) values and missing not-at-random (MNAR) values.
</p>
<p>It also contains functions allowing the imputation of missing values under hypotheses of MCAR and/or MNAR values.
</p>
<p>The main functions of this package are the <code><a href="#topic+estim.mix">estim.mix</a></code> (estimation of a model of MCAR and MNAR (left-censored) values),  <code><a href="#topic+impute.mi">impute.mi</a></code> (multiple imputation) and <code><a href="#topic+impute.mix">impute.mix</a></code> (imputation based on a decision rule). It provides also several imputation algorithms for MS-based data. They can be used to impute matrices containing peptide intensities (as Maxquant outputs for instance).
</p>
<p>Missing values has to be indicated with NA and a log-2 transformation of the intensities has to be applied before using these functions. An example for using this package from MaxQuant outputs is provided in Giai Gianetto Q. (2021).
</p>
<p>More explanations and details on the functions of this package are available in Giai Gianetto Q. et al. (2020) (doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>).
</p>


<h3>Author(s)</h3>

<p>Maintainer: Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Giai Gianetto, Q., Wieczorek S., Cout√© Y., Burger, T. (2020).  A peptide-level multiple imputation strategy accounting for the different natures of missing values in proteomics data. bioRxiv 2020.05.29.122770; doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>
</p>
<p>Giai Gianetto, Q. (2021) Statistical analysis of post-translational modifications quantified by label-free proteomics across multiple biological conditions with R: illustration from SARS-CoV-2 infected cells. (pasteur-03243433)
</p>

<hr>
<h2 id='estim.bound'>
Estimation of lower and upper bounds for missing values.
</h2><span id='topic+estim.bound'></span>

<h3>Description</h3>

<p>This function allows estimating lower and upper bounds for missing values of an input matrix. It can be used before to use the functions <code><a href="#topic+prob.mcar">prob.mcar</a></code> and <code><a href="#topic+prob.mcar.tab">prob.mcar.tab</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim.bound(tab, conditions, q=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estim.bound_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to the intensities measured in an experimental sample, and each row to the ones of an identified peptide.</p>
</td></tr>
<tr><td><code id="estim.bound_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each sample belongs.</p>
</td></tr>
<tr><td><code id="estim.bound_+3A_q">q</code></td>
<td>
<p>A numeric value allowing to define confidence intervals for missing values (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each condition, this function estimates lower and upper bounds for missing values of row <code>i</code> by:
</p>
<p><code>upper(i)=max(tab[i,]);</code>
</p>
<p><code>lower(i)=max(tab[i,])-quant_diff(q);</code>
</p>
<p>where <code>quant_diff(q)</code> corresponds to a quantile value of the differences between the maximum and the minimum of the observed values for all the peptides in the condition. As a result, if <code>q</code> is close to 1, <code>quant_diff(q)</code> represents an extrem value between the maximum and the minimum of the intensity values in a condition for a peptide.
</p>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>tab.lower</code></td>
<td>
<p>A matrix with the lower bounds for each missing value in <code>tab</code>.</p>
</td></tr>
<tr><td><code>tab.upper</code></td>
<td>
<p>A matrix with the upper bounds for each missing value in <code>tab</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob.mcar">prob.mcar</a></code>,<code><a href="#topic+prob.mcar.tab">prob.mcar.tab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,pi.mcar=0.2,para=0.5,nb.cond=2,nb.repbio=3,
nb.sample=5,m.c=25,sd.c=2,sd.rb=0.5,sd.r=0.2);

data=res.sim$dat.obs;
cond=res.sim$conditions;

#Estimation of lower and upper bounds for each missing value
res=estim.bound(data,conditions=cond);

</code></pre>

<hr>
<h2 id='estim.mix'>
Estimation of a mixture model of MCAR and MNAR values in each column of a data matrix.
</h2><span id='topic+estim.mix'></span>

<h3>Description</h3>

<p>This function allows estimating a mixture model of MCAR and MNAR values in each column of data sets similar to the ones which can be studied in MS-based quantitative proteomics. Such data matrices contain intensity values of identified peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim.mix(tab, tab.imp, conditions, x.step.mod=150, x.step.pi=150,
nb.rei=200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estim.mix_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="estim.mix_+3A_tab.imp">tab.imp</code></td>
<td>
<p>A matrix where the missing values of <code>tab</code> have been imputed under the assumption that they are all MCAR. For instance, such a matrix can be obtained by using the function <code><a href="#topic+impute.slsa">impute.slsa</a></code> of this package.</p>
</td></tr>
<tr><td><code id="estim.mix_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
<tr><td><code id="estim.mix_+3A_x.step.mod">x.step.mod</code></td>
<td>
<p>The number of points in the intervals used for estimating the cumulative distribution functions of the mixing model in each column.</p>
</td></tr>
<tr><td><code id="estim.mix_+3A_x.step.pi">x.step.pi</code></td>
<td>
<p>The number of points in the intervals used for estimating the proportion of MCAR values in each column.</p>
</td></tr>
<tr><td><code id="estim.mix_+3A_nb.rei">nb.rei</code></td>
<td>
<p>The number of initializations of the minimization algorithm used to estimate the proportion of MCAR values (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aims to estimate the following mixture model in each column:
</p>
<p><code class="reqn">F_{tot}(x)=\pi_{na}\times F_{na}(x)+(1-\pi_{na})\times F_{obs}(x)</code>
</p>
<p><code class="reqn">F_{na}(x)=\pi_{mcar}\times F_{tot}(x)+(1-\pi_{mcar})\times F_{mnar}(x)</code>
</p>
<p>where <code class="reqn">\pi_{na}</code> is the proportion of missing values, <code class="reqn">\pi_{mcar}</code> is the proportion of MCAR values, <code class="reqn">F_{tot}</code> is the cumulative distribution function (cdf) of the complete values, <code class="reqn">F_{na}</code> is the cdf of the missing values, <code class="reqn">F_{obs}</code> is the cdf of the observed values, and <code class="reqn">F_{mnar}</code> is the cdf of the MNAR values.
</p>
<p>To estimate this model, a first step consists to compute a rough estimate of <code class="reqn">F_{na}</code>  by assuming that all missing values are MCAR (thanks to the argument <code>tab.imp</code>). This rough estimate is noted <code class="reqn">\hat{F}_{na}</code>.
</p>
<p>In a second step, the proportion of MCAR values is estimated. To do so, the ratio
</p>
<p><code class="reqn">\hat{\pi}(x)=(1-\hat{F}_{na}(x))/(1-\hat{F}_{tot}(x))</code>
</p>
<p>is computed for different <code class="reqn">x</code>, where
</p>
<p><code class="reqn">\hat{F}_{tot}(x)=\pi_{na}\times \hat{F}_{na}(x)+(1-\pi_{na})\times \hat{F}_{obs}(x)</code>
</p>
<p>with <code class="reqn">\hat{F}_{obs}</code> the empirical cdf of the observed values.
</p>
<p>Next, the following minimization is performed:
</p>
<p><code class="reqn">\min_{1&gt;k&gt;0,a&gt;0,d&gt;0}f(k,a,d)</code>
</p>
<p>where
</p>
<p><code class="reqn">f(k,a,d)=\sum_x \frac{1}{s(x)^2}\times [\hat{\pi}(x)-k-(1-k)\frac{\exp(-a\times [x-lower_x]^d)}{1-\hat{F}_{tot}(x)}]^2</code>
</p>
<p>where <code class="reqn">s(x)^2</code> is an estimate of the asymptotic variance of <code class="reqn">\hat{\pi}(x)</code>, <code class="reqn">lower_x</code> is an estimate of the minimum of the complete values. To perform this minimization, the function <code>optim</code> with the method &quot;L-BFGS-B&quot; is used. Because it is function of its initialization, it is possible to reinitialize a number of times the minimisation algorithm with the argument <code>nb.rei</code>: the parameters leading to the lowest minimum are next kept.
</p>
<p>Once <code>k</code>, <code>a</code> and <code>d</code> are estimated, one can use several methods to estimate <code class="reqn">\pi_{mcar}</code>: it is estimated
by <code class="reqn">k</code>;
</p>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>abs.pi</code></td>
<td>
<p>A numeric matrix containing the intervals used for estimating the ratio
</p>
<p><code>(1-F_na(x))/(1-F_tot(x))</code>
</p>
<p>in each column.</p>
</td></tr>
<tr><td><code>pi.init</code></td>
<td>
<p>A numeric matrix containing the estimated ratios
</p>
<p><code>(1-F_na(x))/(1-F_tot(x))</code>
</p>
<p>where <code>x</code> belongs to <code>abs.pi[,j]</code> for each sample <code>j</code>.</p>
</td></tr>
<tr><td><code>var.pi.init</code></td>
<td>
<p>A numeric matrix containing the estimated asymptotic variances of <code>pi.init</code>.</p>
</td></tr>
<tr><td><code>trend.pi.init</code></td>
<td>
<p>A numeric matrix containing the estimated trend of the model used in the minimization algorithm.</p>
</td></tr>
<tr><td><code>abs.mod</code></td>
<td>
<p>A numeric vector containing the interval used for estimating the mixture models in each column.</p>
</td></tr>
<tr><td><code>pi.na</code></td>
<td>
<p>A numeric vector containing the proportions of missing values in each column.</p>
</td></tr>
<tr><td><code>F.na</code></td>
<td>
<p>A numeric matrix containing the estimated cumulative distribution functions of missing values in each column on the interval <code>abs.mod</code>.</p>
</td></tr>
<tr><td><code>F.tot</code></td>
<td>
<p>A numeric matrix containing the estimated cumulative distribution functions of complete values in each column on the interval <code>abs.mod</code>.</p>
</td></tr>
<tr><td><code>F.obs</code></td>
<td>
<p>A numeric matrix containing the estimated cumulative distribution functions of observed values in each column on the interval <code>abs.mod</code>.</p>
</td></tr>
<tr><td><code>pi.mcar</code></td>
<td>
<p>A numeric vector containing the estimations of the proportion of MCAR values in each column.</p>
</td></tr>
<tr><td><code>MinRes</code></td>
<td>
<p>A numeric matrix containing the three parameters of the model used in the minimization algorithm (three first rows), and the value of minimized function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute.slsa">impute.slsa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of missing values with a MCAR-devoted algorithm: here the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.slsa, conditions=res.sim$condition);

</code></pre>

<hr>
<h2 id='fast_apply_nb_na'>
Function similar to the function <code>apply(X,dim,function(x)sum(is.na(x)))</code>.
</h2><span id='topic+fast_apply_nb_na'></span>

<h3>Description</h3>

<p>This function is similar to the function <code>apply(X,dim,function(x)sum(is.na(x)))</code> but written thanks to the Rcpp package and therefore faster than <code>apply(X,dim,function(x)sum(is.na(x)))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_apply_nb_na(X, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_apply_nb_na_+3A_x">X</code></td>
<td>

<p>A data matrix containing numeric and missing values.
</p>
</td></tr>
<tr><td><code id="fast_apply_nb_na_+3A_dim">dim</code></td>
<td>

<p>A numeric value: 1 if the number of missing values has to be computed for each row of <code>X</code>, or 2 if it has to be computed for each column of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the number of missing values in either each row or each column of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
##function (X, dim)
##{
##    .Call("imp4p_fast_apply_nb_na", PACKAGE = "imp4p", X, dim)
##  }
##
## You can compare the execution time with a traditional apply function by
## library(rbenchmark)
## res.sim=sim.data(nb.pept=2000,nb.miss=600);
## benchmark(fast_apply_nb_na(res.sim$dat.obs, 1),
##           apply(res.sim$dat.obs,1,function(x)sum(is.na(x))))
##
##
##

</code></pre>

<hr>
<h2 id='fast_apply_nb_not_na'>
Function similar to the function <code>apply(X,dim,function(x)sum(!is.na(x)))</code>.
</h2><span id='topic+fast_apply_nb_not_na'></span>

<h3>Description</h3>

<p>This function is similar to the function <code>apply(X,dim,function(x)sum(!is.na(x)))</code> but written thanks to the Rcpp package and therefore faster than <code>apply(X,dim,function(x)sum(!is.na(x)))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_apply_nb_not_na(X, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_apply_nb_not_na_+3A_x">X</code></td>
<td>

<p>A data matrix containing numeric and missing values.
</p>
</td></tr>
<tr><td><code id="fast_apply_nb_not_na_+3A_dim">dim</code></td>
<td>

<p>A numeric value: 1 if the number of observed values has to be computed for each row of <code>X</code>, or 2 if it has to be computed for each column of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the number of observed values in either each row or each column of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
##function (X, dim)
##{
##    .Call("imp4p_fast_apply_nb_not_na", PACKAGE = "imp4p", X,
##        dim)
##  }
##
## You can compare the execution time with a traditional apply function by
## library(rbenchmark)
## res.sim=sim.data(nb.pept=2000,nb.miss=600);
## benchmark(fast_apply_nb_not_na(res.sim$dat.obs, 1),
##           apply(res.sim$dat.obs,1,function(x)sum(!is.na(x))))
</code></pre>

<hr>
<h2 id='fast_apply_sd_na_rm_T'>
Function similar to the function <code>apply(X,dim,sd,na.rm=TRUE)</code>.
</h2><span id='topic+fast_apply_sd_na_rm_T'></span>

<h3>Description</h3>

<p>This function is similar to the function <code>apply(X,dim,sd,na.rm=TRUE)</code> but written thanks to the Rcpp package and therefore faster than <code>apply(X,dim,sd,na.rm=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_apply_sd_na_rm_T(X, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_apply_sd_na_rm_T_+3A_x">X</code></td>
<td>

<p>A data matrix containing numeric and missing values.
</p>
</td></tr>
<tr><td><code id="fast_apply_sd_na_rm_T_+3A_dim">dim</code></td>
<td>

<p>A numeric value: 1 if the standard deviation has to be computed for each row of <code>X</code>, or 2 if the standard deviation has to be computed for each column of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the standard deviation of observed values in either each row or each column of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
##function (X, dim)
##{
##    .Call("imp4p_fast_apply_sd_na_rm_T", PACKAGE = "imp4p", X,
##        dim)
##  }
##
## You can compare the execution time with a traditional apply function by
## library(rbenchmark)
## res.sim=sim.data(nb.pept=2000,nb.miss=600);
## benchmark(fast_apply_sd_na_rm_T(res.sim$dat.obs, 1),
##           apply(res.sim$dat.obs,1,sd,na.rm=TRUE))
</code></pre>

<hr>
<h2 id='fast_apply_sum_na_rm_T'>
Function similar to the function <code>apply(X,dim,sum,na.rm=TRUE)</code>.
</h2><span id='topic+fast_apply_sum_na_rm_T'></span>

<h3>Description</h3>

<p>This function is similar to the function <code>apply(X,dim,sum,na.rm=TRUE)</code> but written thanks to the Rcpp package and therefore faster than <code>apply(X,dim,sum,na.rm=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_apply_sum_na_rm_T(X, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_apply_sum_na_rm_T_+3A_x">X</code></td>
<td>

<p>A data matrix containing numeric and missing values.
</p>
</td></tr>
<tr><td><code id="fast_apply_sum_na_rm_T_+3A_dim">dim</code></td>
<td>

<p>A numeric value: 1 if the sum has to be computed for each row of <code>X</code>, or 2 if the sum has to be computed for each column of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the sum of observed values in either each row or each column of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
##function (X, dim)
##{
##    .Call("imp4p_fast_apply_sum_na_rm_T", PACKAGE = "imp4p",
##        X, dim)
##  }
##
## You can compare the execution time with a traditional apply function by
## library(rbenchmark)
## res.sim=sim.data(nb.pept=2000,nb.miss=600);
## benchmark(fast_apply_sum_na_rm_T(res.sim$dat.obs, 1),
##           apply(res.sim$dat.obs,1,sum,na.rm=TRUE))
</code></pre>

<hr>
<h2 id='fast_sim'>
Function to compute similarity measures between a vector and each row of a matrix.
</h2><span id='topic+fast_sim'></span>

<h3>Description</h3>

<p>This function allows computing a similarity measure between a vector and each row of a matrix. The similarity measure is defined by d^2 where d is the Euclidean distance between the vector and each row. It is implemented thanks to the RCpp package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_sim(prot, mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_sim_+3A_prot">prot</code></td>
<td>

<p>A numeric vector containing numeric and missing values.
</p>
</td></tr>
<tr><td><code id="fast_sim_+3A_mat">mat</code></td>
<td>

<p>A data matrix containing numeric and missing values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the values of the similarity measures between the <code>prot</code> vector and each row of the <code>mat</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=20000,nb.miss=1000);

#Fast computation of similarities
fast_sim(res.sim$dat.obs[1,],res.sim$dat.obs);

</code></pre>

<hr>
<h2 id='gen.cond'>
Function allowing to create a vector indicating the membership of each sample to a condition.
</h2><span id='topic+gen.cond'></span>

<h3>Description</h3>

<p>This function creates a vector of factors where each element refers to a condition to which a sample belongs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.cond(nb_cond=2,nb_sample=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.cond_+3A_nb_cond">nb_cond</code></td>
<td>
<p>Number of biological conditions.</p>
</td></tr>
<tr><td><code id="gen.cond_+3A_nb_sample">nb_sample</code></td>
<td>
<p>Number of samples in each condition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of factors of length nb_cond*nb_sample.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cond=gen.cond(nb_cond=2,nb_sample=6)
#[1] 1 1 1 1 1 1 2 2 2 2 2 2
#Levels: 1 2
</code></pre>

<hr>
<h2 id='impute.igcda'>
Imputing missing values by assuming that the distribution of complete values is Gaussian in each column of an input matrix. This algorithm is named &quot;Imputation under a Gaussian Complete Data Assumption&quot; (IGCDA).
</h2><span id='topic+impute.igcda'></span>

<h3>Description</h3>

<p>This function allows imputing missing values under the assumption that the distribution of complete values has to be Gaussian in each column.
</p>
<p>Note that the imputed values are not necessary small values (compared to observed values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.igcda(tab, tab.imp, conditions, q=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.igcda_+3A_tab">tab</code></td>
<td>
<p>A numeric vector or matrix with observed and missing values.</p>
</td></tr>
<tr><td><code id="impute.igcda_+3A_tab.imp">tab.imp</code></td>
<td>
<p>A matrix where the missing values of <code>tab</code> have been imputed under the assumption that they are all MCAR. For instance, such a matrix can be obtained by using the function <code><a href="#topic+impute.slsa">impute.slsa</a></code> of this package.</p>
</td></tr>
<tr><td><code id="impute.igcda_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
<tr><td><code id="impute.igcda_+3A_q">q</code></td>
<td>
<p>A quantile value (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean and variance of the Gaussian distribution are determined using a linear regression between the quantiles of the observed values <code>q_{obs}</code> and the ones of the standard normal distribution <code>q_{N(0,1)}</code>.
</p>
<p>The quantile value is used for determining the minimum of imputed values. This minimum is determined by the minimum observed value in the dataset minus <code>quant_diff(q)</code> where <code>quant_diff(q)</code> corresponds to a quantile value of the differences between the maximum and the minimum of the observed values for all the peptides in the condition. As a result, if <code>q</code> is close to 1, <code>quant_diff(q)</code> represents an extrem value between the maximum and the minimum of the intensity values in a condition for a peptide.
</p>


<h3>Value</h3>

<p>The numeric input matrix with imputed values. The distribution of the intensity values in each of its columns is supposed to be Gaussian.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of missing values with a MCAR-devoted algorithm: here the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

#Imputation of missing values under a Gaussian assumption
dat.gauss=impute.igcda(tab=res.sim$dat.obs, tab.imp=dat.slsa, conditions=res.sim$conditions);

</code></pre>

<hr>
<h2 id='impute.mi'>
Imputation of data sets containing peptide intensities with a multiple imputation strategy.
</h2><span id='topic+impute.mi'></span>

<h3>Description</h3>

<p>This function allows imputing data sets containing peptide intensities with a multiple imputation strategy distinguishing MCAR and MNAR values. For details, see Giai Gianetto Q. et al. (2020) (doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.mi(tab, conditions, repbio=NULL, reptech=NULL, nb.iter=3, nknn=15, selec=1000,
siz=900, weight=1, ind.comp=1, progress.bar=TRUE, x.step.mod=300, x.step.pi=300,
nb.rei=100, q=0.95, methodMCAR="mle",ncp.max=5,
maxiter = 10, ntree = 100, variablewise = FALSE,
decreasing = FALSE, verbose = FALSE, mtry = floor(sqrt(ncol(tab))),
replace = TRUE, classwt = NULL, cutoff = NULL, strata = NULL, sampsize = NULL,
nodesize = NULL, maxnodes = NULL, xtrue = NA,
parallelize = c('no', 'variables', 'forests'),
methodMNAR="igcda",q.min = 0.025, q.norm = 3, eps = 0,
distribution = "unif", param1 = 3, param2 = 1, R.q.min=1);
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.mi_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing only numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_repbio">repbio</code></td>
<td>
<p>A vector of factors indicating the biological replicate to which each column belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_reptech">reptech</code></td>
<td>
<p>A vector of factors indicating the technical replicate to which each column belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_nb.iter">nb.iter</code></td>
<td>
<p>The number of iterations used for the multiple imputation method (see <code><a href="#topic+mi.mix">mi.mix</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_methodmcar">methodMCAR</code></td>
<td>
<p>The method used for imputing MCAR data. If <code>methodMCAR="mle"</code> (default), then the <code><a href="#topic+impute.mle">impute.mle</a></code> function is used (imputation using an EM algorithm). If <code>methodMCAR="pca"</code>, then the <code><a href="#topic+impute.PCA">impute.PCA</a></code> function is used (imputation using Principal Component Analysis). If <code>methodMCAR="rf"</code>, then the <code><a href="#topic+impute.RF">impute.RF</a></code> function is used (imputation using Random Forest). Else, the <code><a href="#topic+impute.slsa">impute.slsa</a></code> function is used (imputation using Least Squares on nearest neighbours).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_methodmnar">methodMNAR</code></td>
<td>
<p>The method used for imputing MNAR data. If <code>methodMNAR="igcda"</code> (default), then the <code><a href="#topic+impute.igcda">impute.igcda</a></code> function is used. Else, the <code><a href="#topic+impute.pa">impute.pa</a></code> function is used.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_nknn">nknn</code></td>
<td>
<p>The number of nearest neighbours used in the SLSA algorithm (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_selec">selec</code></td>
<td>
<p>A parameter to select a part of the dataset to find nearest neighbours between rows. This can be useful for big data sets (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_siz">siz</code></td>
<td>
<p>A parameter to select a part of the dataset to perform imputations with the MCAR-devoted algorithm. This can be useful for big data sets (see <code><a href="#topic+mi.mix">mi.mix</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_weight">weight</code></td>
<td>
<p>The way of weighting in the algorithm (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_ind.comp">ind.comp</code></td>
<td>
<p>If <code>ind.comp=1</code>, only nearest neighbours without missing values are selected to fit linear models (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>). Else, they can contain missing values.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_progress.bar">progress.bar</code></td>
<td>
<p>If <code>TRUE</code>, a progress bar is displayed.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_x.step.mod">x.step.mod</code></td>
<td>
<p>The number of points in the intervals used for estimating the cumulative distribution functions of the mixing model in each column (see <code><a href="#topic+estim.mix">estim.mix</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_x.step.pi">x.step.pi</code></td>
<td>
<p>The number of points in the intervals used for estimating the proportion of MCAR values in each column (see <code><a href="#topic+estim.mix">estim.mix</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_nb.rei">nb.rei</code></td>
<td>
<p>The number of initializations of the minimization algorithm used to estimate the proportion of MCAR values (see Details) (see <code><a href="#topic+estim.mix">estim.mix</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_q">q</code></td>
<td>
<p>A quantile value (see <code><a href="#topic+impute.igcda">impute.igcda</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_ncp.max">ncp.max</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.PCA">impute.PCA</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_maxiter">maxiter</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_ntree">ntree</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_variablewise">variablewise</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_decreasing">decreasing</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_verbose">verbose</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_mtry">mtry</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_replace">replace</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_classwt">classwt</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_cutoff">cutoff</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_strata">strata</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_sampsize">sampsize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_nodesize">nodesize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_maxnodes">maxnodes</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_xtrue">xtrue</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_parallelize">parallelize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_q.min">q.min</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_q.norm">q.norm</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_eps">eps</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_distribution">distribution</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_param1">param1</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_param2">param2</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mi_+3A_r.q.min">R.q.min</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, a mixture model of MCAR and MNAR values is estimated in each column of <code>tab</code>. This model is used to estimate probabilities that each missing value is MCAR. Then, these probabilities are used to perform a multiple imputation strategy (see <code><a href="#topic+mi.mix">mi.mix</a></code>). Rows with no value in a condition are imputed using the <code><a href="#topic+impute.pa">impute.pa</a></code> function. More details and explanations can be bound in Giai Gianetto (2020).
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Giai Gianetto, Q., Wieczorek S., Cout√© Y., Burger, T. (2020).  A peptide-level multiple imputation strategy accounting for the different natures of missing values in proteomics data. bioRxiv 2020.05.29.122770; doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,nb.cond=2);

#Imputation of the dataset noting the conditions to which the samples belong.
result=impute.mi(tab=res.sim$dat.obs, conditions=res.sim$conditions);

#Imputation of the dataset noting the conditions to which the samples belong
#and also their biological replicate, and using the SLSA method for the MCAR values
result=impute.mi(tab=res.sim$dat.obs, conditions=res.sim$conditions,
repbio=res.sim$repbio, methodMCAR = "slsa");

#For large data sets, the SLSA imputation can be accelerated thanks to the selec parameter
#and the siz parameter (see impute.slsa and mi.mix)
#but it may result in a less accurate data imputation. Note that selec has to be greater than siz.
#Here, nb.iter is fixed to 3
result1=impute.mi(tab=res.sim$dat.obs, conditions=res.sim$conditions, progress.bar=TRUE,
selec=400, siz=300, nb.iter=3, methodMCAR = "slsa", methodMNAR = "igcda");

</code></pre>

<hr>
<h2 id='impute.mix'>
Imputation using a decision rule under an assumption of a mixture of MCAR and MNAR values.
</h2><span id='topic+impute.mix'></span>

<h3>Description</h3>

<p>This function allows imputing data sets with a MCAR-devoted algorithm and a MNAR-devoted algorithm using probabilities that missing values are MCAR. If such a probability is superior to a chosen threshold, then the MCAR-devoted algorithm is used, otherwise it is the MNAR-devoted algorithm. For details, see Giai Gianetto, Q. et al. (2020) (doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.mix(tab, prob.MCAR, threshold, conditions, repbio=NULL, reptech=NULL,
methodMCAR="mle",nknn=15,weight=1, selec="all", ind.comp=1, progress.bar=TRUE, q=0.95,
ncp.max=5, maxiter = 10, ntree = 100, variablewise = FALSE, decreasing = FALSE,
verbose = FALSE, mtry = floor(sqrt(ncol(tab))), replace = TRUE,classwt = NULL,
cutoff = NULL, strata = NULL, sampsize = NULL, nodesize = NULL, maxnodes = NULL,
xtrue = NA, parallelize = c('no', 'variables', 'forests'),
methodMNAR="igcda", q.min = 0.025, q.norm = 3, eps = 0, distribution = "unif",
param1 = 3, param2 = 1, R.q.min=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.mix_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_prob.mcar">prob.MCAR</code></td>
<td>
<p>A matrix of probabilities that each missing value is MCAR. For instance such a matrix can be obtained from the function <code><a href="#topic+prob.mcar.tab">prob.mcar.tab</a></code> of this package.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_threshold">threshold</code></td>
<td>
<p>A value such that if the probability that a missing value is MCAR is superior to it, then a MCAR-devoted algorithm is used, otherwise it is a MNAR-devoted algorithm that is used.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_repbio">repbio</code></td>
<td>
<p>A vector of factors indicating the biological replicate to which each column belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_reptech">reptech</code></td>
<td>
<p>A vector of factors indicating the technical replicate to which each column belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_methodmcar">methodMCAR</code></td>
<td>
<p>The method used for imputing MCAR data. If <code>methodi="mle"</code> (default), then the <code><a href="#topic+impute.mle">impute.mle</a></code> function is used (imputation using an EM algorithm). If <code>methodi="pca"</code>, then the <code><a href="#topic+impute.PCA">impute.PCA</a></code> function is used (imputation using Principal Component Analysis). If <code>methodi="rf"</code>, then the <code><a href="#topic+impute.RF">impute.RF</a></code> function is used (imputation using Random Forest). Else, the <code><a href="#topic+impute.slsa">impute.slsa</a></code> function is used (imputation using Least Squares on nearest neighbours).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_methodmnar">methodMNAR</code></td>
<td>
<p>The method used for imputing MNAR data. If <code>methodMNAR="igcda"</code> (default), then the <code><a href="#topic+impute.igcda">impute.igcda</a></code> function is used. Else, the <code><a href="#topic+impute.pa">impute.pa</a></code> function is used.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_nknn">nknn</code></td>
<td>
<p>The number of nearest neighbours used in the SLSA algorithm (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_weight">weight</code></td>
<td>
<p>The way of weighting in the algorithm (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_selec">selec</code></td>
<td>
<p>A parameter to select a part of the dataset to find nearest neighbours between rows. This can be useful for big data sets (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_ind.comp">ind.comp</code></td>
<td>
<p>If <code>ind.comp=1</code>, only nearest neighbours without missing values are selected to fit linear models (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>). Else, they can contain missing values.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_progress.bar">progress.bar</code></td>
<td>
<p>If <code>TRUE</code>, a progress bar is displayed.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_q">q</code></td>
<td>
<p>A quantile value (see <code><a href="#topic+impute.igcda">impute.igcda</a></code>).</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_ncp.max">ncp.max</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.PCA">impute.PCA</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_maxiter">maxiter</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_ntree">ntree</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_variablewise">variablewise</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_decreasing">decreasing</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_verbose">verbose</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_mtry">mtry</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_replace">replace</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_classwt">classwt</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_cutoff">cutoff</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_strata">strata</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_sampsize">sampsize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_nodesize">nodesize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_maxnodes">maxnodes</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_xtrue">xtrue</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_parallelize">parallelize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_q.min">q.min</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_q.norm">q.norm</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_eps">eps</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_distribution">distribution</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_param1">param1</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_param2">param2</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="impute.mix_+3A_r.q.min">R.q.min</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The missing values for which <code>prob.MCAR</code> is superior to a chosen threshold are imputed with one of the MCAR-devoted imputation methods (<code><a href="#topic+impute.mle">impute.mle</a></code>, <code><a href="#topic+impute.RF">impute.RF</a></code>, <code><a href="#topic+impute.PCA">impute.PCA</a></code> or <code><a href="#topic+impute.slsa">impute.slsa</a></code>). The other missing values are considered MNAR and imputed with <code><a href="#topic+impute.igcda">impute.igcda</a></code>. More details and explanations can be bound in Giai Gianetto (2020).
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Giai Gianetto, Q., Wieczorek S., Cout√© Y., Burger, T. (2020).  A peptide-level multiple imputation strategy accounting for the different natures of missing values in proteomics data. bioRxiv 2020.05.29.122770; doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Fast imputation of missing values with the impute.rand algorithm
dat.rand=impute.rand(tab=res.sim$dat.obs,conditions=res.sim$condition);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.rand, conditions=res.sim$condition);

#Computing probabilities to be MCAR
born=estim.bound(tab=res.sim$dat.obs,conditions=res.sim$condition);
proba=prob.mcar.tab(born$tab.upper,res);

#Imputation under the assumption of MCAR and MNAR values
tabi=impute.mix(tab=res.sim$dat.obs, prob.MCAR=proba, threshold=0.5, conditions=res.sim$conditions,
repbio=res.sim$repbio, methodMCAR="slsa", methodMNAR="igcda", nknn=15, weight=1, selec="all",
ind.comp=1, progress.bar=TRUE);

</code></pre>

<hr>
<h2 id='impute.mle'>
Imputing missing values using a maximum likelihood estimation (MLE).
</h2><span id='topic+impute.mle'></span>

<h3>Description</h3>

<p>Imputing missing values using the EM algorithm proposed in section 5.4.1 of Schafer (1997). The function is based on the imp.norm function of the R package norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.mle(tab, conditions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.mle_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.mle_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each sample belongs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See section 5.4.1 of Schafer (1997) for the theory. It is built from functions proposed in the R package norm.
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Schafer, J. L. (1997). Analysis of incomplete multivariate data. Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,nb.cond=2);

#Imputation of missing values with the mle algorithm
dat.mle=impute.mle(tab=res.sim$dat.obs,conditions=res.sim$condition);

</code></pre>

<hr>
<h2 id='impute.pa'>
Imputation of peptides having no value in a biological condition (present in a condition / absent in another).
</h2><span id='topic+impute.pa'></span>

<h3>Description</h3>

<p>This function imputes missing values by small values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.pa(tab, conditions, q.min = 0.025, q.norm = 3, eps = 0,
distribution = "unif", param1 = 3, param2 = 1, R.q.min=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.pa_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_q.min">q.min</code></td>
<td>
<p>A quantile value of the observed values allowing defining the maximal value which can be generated. This maximal value is defined by the quantile <code>q.min</code> of the observed values distribution minus <code>eps</code>. Default is 0.025 (the maximal value is the 2.5 percentile of observed values minus <code>eps</code>).</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_q.norm">q.norm</code></td>
<td>
<p>A quantile value of a normal distribution allowing defining the minimal value which can be generated. Default is 3 (the minimal value is the maximal value minus qn*median(sd(observed values)) where sd is the standard deviation of a row in a condition).</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_eps">eps</code></td>
<td>
<p>A value allowing defining the maximal value which can be generated. This maximal value is defined by the quantile <code>q.min</code> of the observed values distribution minus <code>eps</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_distribution">distribution</code></td>
<td>
<p>Distribution used to generated missing values. You have the choice between &quot;unif&quot; for the uniform distribution, &quot;beta&quot; for the Beta distribution or &quot;dirac&quot; for the Dirac distribution. Default is &quot;unif&quot;.</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_param1">param1</code></td>
<td>
<p>Parameter <code>shape1</code> of the Beta distribution.</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_param2">param2</code></td>
<td>
<p>Parameter <code>shape2</code> of the Beta distribution.</p>
</td></tr>
<tr><td><code id="impute.pa_+3A_r.q.min">R.q.min</code></td>
<td>
<p>Parameter used for the Dirac distribution. In this case, all the missing values are imputed by a single value which is equal to <code>R.q.min*quantile(tab[,j], probs=q.min, na.rm=T)</code>. Default is 1 : the imputed value is the <code>qmin</code> quantile of observed values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the missing values in a column by random draws from a specified distribution. The value of <code>eps</code> can be interpreted as a minimal fold-change value above which the present/absent peptides appear.
</p>


<h3>Value</h3>

<p>A list composed of :
</p>
<p>- <code>tab.imp</code> : the input matrix <code>tab</code> with imputed values instead of missing values.
</p>
<p>- <code>para</code> : the parameters of the distribution which has been used to impute.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of the simulated data set with small values
data.small.val=impute.pa(res.sim$dat.obs,res.sim$conditions);

</code></pre>

<hr>
<h2 id='impute.PCA'>
Imputing missing values using Principal Components Analysis.
</h2><span id='topic+impute.PCA'></span>

<h3>Description</h3>

<p>Imputing missing values using the algorithm proposed by Josse and Husson (2013). The function is based on the imputePCA function of the R package missMDA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.PCA(tab, conditions, ncp.max=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.PCA_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.PCA_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each sample belongs.</p>
</td></tr>
<tr><td><code id="impute.PCA_+3A_ncp.max">ncp.max</code></td>
<td>
<p>integer corresponding to the maximum number of components to test (used in the <code>estim_ncpPCA</code> function of R package missMDA).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Josse and Husson (2013) for the theory. It is built from functions proposed in the R package missMDA.
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Josse, J &amp; Husson, F. (2013). Handling missing values in exploratory multivariate data analysis methods. Journal de la SFdS. 153 (2), pp. 79-99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,nb.cond=2);

#Imputation of missing values with PCA
dat.pca=impute.PCA(tab=res.sim$dat.obs,conditions=res.sim$condition);

</code></pre>

<hr>
<h2 id='impute.rand'>
Imputation of peptides with a random value.
</h2><span id='topic+impute.rand'></span>

<h3>Description</h3>

<p>For each row (peptide), this function imputes missing values by random values following a Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.rand(tab, conditions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.rand_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.rand_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each row (peptide), this function imputes missing values by random values following a Gaussian distribution centered on the mean of the observed values in the condition for the specific peptide and with a standard deviation equal to the first quartile of the distribution of the standard deviation the values observed for all the peptides. Rows with only missing values in a condition are not imputed (the <code><a href="#topic+impute.pa">impute.pa</a></code> function can be used for this purpose).
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of the simulated data set with random values
data.rand=impute.rand(res.sim$dat.obs,res.sim$conditions);

</code></pre>

<hr>
<h2 id='impute.RF'>
Imputing missing values using Random Forest.
</h2><span id='topic+impute.RF'></span>

<h3>Description</h3>

<p>Imputing missing values using the algorithm proposed by Stekhoven and Buehlmann (2012). The function is based on the missForest function of the R package missForest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.RF(tab, conditions,
                    maxiter = 10, ntree = 100, variablewise = FALSE,
                    decreasing = FALSE, verbose = FALSE,
                    mtry = floor(sqrt(ncol(tab))), replace = TRUE,
                    classwt = NULL, cutoff = NULL, strata = NULL,
                    sampsize = NULL, nodesize = NULL, maxnodes = NULL,
                    xtrue = NA, parallelize = c('no', 'variables', 'forests'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.RF_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each sample belongs.</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_maxiter">maxiter</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_ntree">ntree</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_variablewise">variablewise</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_decreasing">decreasing</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_verbose">verbose</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_mtry">mtry</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_replace">replace</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_classwt">classwt</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_cutoff">cutoff</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_strata">strata</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_sampsize">sampsize</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_nodesize">nodesize</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_maxnodes">maxnodes</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_xtrue">xtrue</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
<tr><td><code id="impute.RF_+3A_parallelize">parallelize</code></td>
<td>
<p>parameter of the <code>missForest</code> function (missForest R package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Stekhoven and Buehlmann (2012) for the theory. It is built from functions proposed in the R package missForest.
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Stekhoven, D.J. and Buehlmann, P. (2012), 'MissForest - nonparametric missing value imputation for mixed-type data', Bioinformatics, 28(1) 2012, 112-118, doi: 10.1093/bioinformatics/btr597
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,nb.cond=2);

#Imputation of missing values with Random Forest
dat.rf=impute.RF(tab=res.sim$dat.obs,conditions=res.sim$condition);

</code></pre>

<hr>
<h2 id='impute.slsa'>
Imputing missing values using an adaptation of the LSimpute algorithm (Bo et al. (2004)) to experimental designs. This algorithm is named &quot;Structured Least Squares Algorithm&quot; (SLSA).
</h2><span id='topic+impute.slsa'></span>

<h3>Description</h3>

<p>This function is an adaptation of the LSimpute algorithm (Bo et al. (2004)) to experimental designs usually met in MS-based quantitative proteomics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.slsa(tab, conditions, repbio=NULL, reptech=NULL, nknn=30, selec="all", weight="o",
ind.comp=1, progress.bar=TRUE)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.slsa_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each sample belongs.</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_repbio">repbio</code></td>
<td>
<p>A vector of factors indicating the biological replicate to which each sample belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_reptech">reptech</code></td>
<td>
<p>A vector of factors indicating the technical replicate to which each sample belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_nknn">nknn</code></td>
<td>
<p>The number of nearest neighbours used in the algorithm (see Details).</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_selec">selec</code></td>
<td>
<p>A parameter to select a part of the dataset to find nearest neighbours between rows. This can be useful for big data sets (see Details).</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_weight">weight</code></td>
<td>
<p>The way of weighting in the algorithm (see Details).</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_ind.comp">ind.comp</code></td>
<td>
<p>If <code>ind.comp=1</code>, only nearest neighbours without missing values are selected to fit linear models (see Details). Else, they can contain missing values.</p>
</td></tr>
<tr><td><code id="impute.slsa_+3A_progress.bar">progress.bar</code></td>
<td>
<p>If <code>TRUE</code>, a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imputes the missing values condition by condition. The rows of the input matrix are imputed when they have at least one observed value in the considered condition. For the rows having only missing values in a condition, you can use the <code><a href="#topic+impute.pa">impute.pa</a></code> function.
</p>
<p>For each row, a similarity measure between the observed values of this row and the ones of the other rows is computed. The similarity measure which is used is the absolute pairwise correlation coefficient if at least three side-by-side values are observed, and the inverse of the euclidean distance between side-by-side observed values in the other cases.
</p>
<p>For big data sets, this step can be time consuming and that is why the input parameter <code>selec</code> allows to select random rows in the data set. If <code>selec="all"</code>, then all the rows of the data set are considered; while if <code>selec</code> is a numeric value, for instance <code>selec=100</code>, then only 100 random rows are selected in the data set for computing similarity measures with each row containing missing values.
</p>
<p>Once similarity measures are computed for a specific row, then the <code>nknn</code> rows with the highest similarity measures are considered to fit linear models and to predict several estimates for each missing value (see Bo et al. (2004)). If <code>ind.comp=1</code>, then only nearest neighbours without missing values in the condition are considered. However, unlike the original algorithm, our algorithm allows to consider the design of experiments that are specified in input through the vectors <code>conditions</code>, <code>repbio</code> and <code>reptech</code>. Note that <code>conditions</code> has to get a lower number of levels than <code>repbio</code>; and  <code>repbio</code> has to get a lower number of levels than <code>reptech</code>.
</p>
<p>In the original algorithm, several predictions of each missing value are done from the estimated linear models and, then, they are weighted in function of their similarity measure and summed (see Bo et al. (2004)). In our algorithm, one can use the original weighting function of Bo et al. (2004) if <code>weight="o"</code>, i.e. <code>(sim^2/(1-sim^2+1e-06))^2</code> where <code>sim</code> is the similarity measure; or the weighting function <code>sim^weight</code> if <code>weight</code> is a numeric value.
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with imputed values instead of missing values.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Bo, T. H., Dysvik, B., &amp; Jonassen, I. (2004). LSimpute: accurate estimation of missing values in microarray data with least squares methods. Nucleic acids research, 32(3), e34.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of missing values with the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

</code></pre>

<hr>
<h2 id='mi.mix'>
Multiple imputation from a matrix of probabilities of being MCAR for each missing value.
</h2><span id='topic+mi.mix'></span>

<h3>Description</h3>

<p>This function allows imputing data sets with a multiple imputation strategy. For details, see Giai Gianetto Q. et al. (2020) (doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.mix(tab, tab.imp, prob.MCAR, conditions, repbio=NULL, reptech=NULL, nb.iter=3, nknn=15,
weight=1, selec="all", siz=500, ind.comp=1, methodMCAR="mle", q=0.95,
progress.bar=TRUE, details=FALSE, ncp.max=5, maxiter = 10, ntree = 100,
variablewise = FALSE, decreasing = FALSE, verbose = FALSE, mtry = floor(sqrt(ncol(tab))),
replace = TRUE,classwt = NULL, cutoff = NULL, strata = NULL, sampsize = NULL,
nodesize = NULL, maxnodes = NULL,xtrue = NA, parallelize = c('no', 'variables',
'forests'), methodMNAR="igcda",q.min = 0.025, q.norm = 3, eps = 0, distribution = "unif",
param1 = 3, param2 = 1, R.q.min=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.mix_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_tab.imp">tab.imp</code></td>
<td>
<p>A matrix where the missing values of <code>tab</code> have been imputed under the assumption that they are all MCAR. For instance, such a matrix can be obtained from the function <code><a href="#topic+impute.slsa">impute.slsa</a></code> of this package.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_prob.mcar">prob.MCAR</code></td>
<td>
<p>A matrix of probabilities that each missing value is MCAR. For instance such a matrix can be obtained from the function <code><a href="#topic+prob.mcar.tab">prob.mcar.tab</a></code> of this package.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_repbio">repbio</code></td>
<td>
<p>A vector of factors indicating the biological replicate to which each column belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_reptech">reptech</code></td>
<td>
<p>A vector of factors indicating the technical replicate to which each column belongs. Default is NULL (no experimental design is considered).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_nb.iter">nb.iter</code></td>
<td>
<p>The number of iterations used for the multiple imputation method.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_nknn">nknn</code></td>
<td>
<p>The number of nearest neighbours used in the SLSA algorithm (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_selec">selec</code></td>
<td>
<p>A parameter to select a part of the dataset to find nearest neighbours between rows. This can be useful for big data sets (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_siz">siz</code></td>
<td>
<p>A parameter to select a part of the dataset to perform imputations with a MCAR-devoted algorithm. This can be useful for big data sets. Note that <code>siz</code> needs to be inferior to <code>selec</code>.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_weight">weight</code></td>
<td>
<p>The way of weighting in the algorithm (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_ind.comp">ind.comp</code></td>
<td>
<p>If <code>ind.comp=1</code>, only nearest neighbours without missing values are selected to fit linear models (see <code><a href="#topic+impute.slsa">impute.slsa</a></code>). Else, they can contain missing values.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_methodmcar">methodMCAR</code></td>
<td>
<p>The method used for imputing MCAR data. If <code>methodi="mle"</code> (default), then the <code><a href="#topic+impute.mle">impute.mle</a></code> function is used (imputation using an EM algorithm). If <code>methodi="pca"</code>, then the <code><a href="#topic+impute.PCA">impute.PCA</a></code> function is used (imputation using Principal Component Analysis). If <code>methodi="rf"</code>, then the <code><a href="#topic+impute.RF">impute.RF</a></code> function is used (imputation using Random Forest). Else, the <code><a href="#topic+impute.slsa">impute.slsa</a></code> function is used (imputation using Least Squares on nearest neighbours).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_methodmnar">methodMNAR</code></td>
<td>
<p>The method used for imputing MNAR data. If <code>methodMNAR="igcda"</code> (default), then the <code><a href="#topic+impute.igcda">impute.igcda</a></code> function is used. Else, the <code><a href="#topic+impute.pa">impute.pa</a></code> function is used.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_q">q</code></td>
<td>
<p>A quantile value (see <code><a href="#topic+impute.igcda">impute.igcda</a></code>).</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_progress.bar">progress.bar</code></td>
<td>
<p>If <code>TRUE</code>, a progress bar is displayed.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_details">details</code></td>
<td>
<p>If <code>TRUE</code>, the function gives a list of three values: <code>imputed.matrix</code> a matrix with the average of imputed values for each missing value, <code>sd.imputed.matrix</code> a matrix with the standard deviations of imputed values for each missing value, <code>all.imputed.matrices</code> an array with all the <code>nb.iter</code> matrices of imputed values that have been generated.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_ncp.max">ncp.max</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.PCA">impute.PCA</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_maxiter">maxiter</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_ntree">ntree</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_variablewise">variablewise</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_decreasing">decreasing</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_verbose">verbose</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_mtry">mtry</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_replace">replace</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_classwt">classwt</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_cutoff">cutoff</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_strata">strata</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_sampsize">sampsize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_nodesize">nodesize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_maxnodes">maxnodes</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_xtrue">xtrue</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_parallelize">parallelize</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.RF">impute.RF</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_q.min">q.min</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_q.norm">q.norm</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_eps">eps</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_distribution">distribution</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_param1">param1</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_param2">param2</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
<tr><td><code id="mi.mix_+3A_r.q.min">R.q.min</code></td>
<td>
<p>parameter of the <code><a href="#topic+impute.pa">impute.pa</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each iteration, a matrix indicating the MCAR values is generated by Bernouilli distributions having parameters given by the matrix <code>prob.MCAR</code>. The generated MCAR values are next imputed thanks to the matrix <code>tab.imp</code>. For each row containing MNAR values, the other rows are imputed thanks to the function  <code><a href="#topic+impute.igcda">impute.igcda</a></code> and, next, the considered row is imputed thanks to one of the MCAR-devoted imputation methods (<code><a href="#topic+impute.mle">impute.mle</a></code>, <code><a href="#topic+impute.RF">impute.RF</a></code>, <code><a href="#topic+impute.PCA">impute.PCA</a></code> or <code><a href="#topic+impute.slsa">impute.slsa</a></code>). So, the function <code><a href="#topic+impute.igcda">impute.igcda</a></code> allows to deform the correlation structure of the dataset in view to be closer to that of the true values, while the MCAR-devoted imputation method will impute by taking into account this modified correlation structure.
</p>


<h3>Value</h3>

<p>The input matrix <code>tab</code> with average imputed values instead of missing values if <code>details=FALSE</code> (default). If <code>details=TRUE</code>, a list of three values: <code>imputed.matrix</code> a matrix with the average of imputed values for each missing value, <code>sd.imputed.matrix</code> a matrix with the standard deviations of imputed values for each missing value, <code>all.imputed.matrices</code> an array with all the <code>nb.iter</code> matrices of imputed values that have been generated.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Giai Gianetto, Q., Wieczorek S., Cout√© Y., Burger, T. (2020).  A peptide-level multiple imputation strategy accounting for the different natures of missing values in proteomics data. bioRxiv 2020.05.29.122770; doi: doi: <a href="https://doi.org/10.1101/2020.05.29.122770">10.1101/2020.05.29.122770</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=5000,nb.miss=1000);

#Fast imputation of missing values with the impute.rand algorithm
dat.rand=impute.rand(tab=res.sim$dat.obs,conditions=res.sim$condition);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.rand, conditions=res.sim$condition);

#Computing probabilities to be MCAR
born=estim.bound(tab=res.sim$dat.obs,conditions=res.sim$condition);
proba=prob.mcar.tab(tab.u=born$tab.upper,res=res);

#Multiple imputation strategy with 3 iterations (can be time consuming in function of the data set!)
data.mi=mi.mix(tab=res.sim$dat.obs, tab.imp=dat.rand, prob.MCAR=proba, conditions=
res.sim$conditions, repbio=res.sim$repbio, nb.iter=3);

</code></pre>

<hr>
<h2 id='miss.mcar.process'>
Estimating the MCAR mechanism in a sample.
</h2><span id='topic+miss.mcar.process'></span>

<h3>Description</h3>

<p>This function allows estimating the MCAR data mechanism, i.e. the probability to be MCAR given that the value is missing in function of the intensity level, from an estimation of a mixture model of MNAR and MCAR values (see <code><a href="#topic+estim.mix">estim.mix</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miss.mcar.process(abs,pi_mcar,F_tot,F_na)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miss.mcar.process_+3A_abs">abs</code></td>
<td>
<p>The interval on which is estimated the MCAR data mechanism.</p>
</td></tr>
<tr><td><code id="miss.mcar.process_+3A_pi_mcar">pi_mcar</code></td>
<td>
<p>An estimation of the proportion of MCAR values.</p>
</td></tr>
<tr><td><code id="miss.mcar.process_+3A_f_tot">F_tot</code></td>
<td>
<p>An estimation of the cumulative distribution function of the complete values on the interval <code>abs</code>.</p>
</td></tr>
<tr><td><code id="miss.mcar.process_+3A_f_na">F_na</code></td>
<td>
<p>An estimation of the cumulative distribution function of the missing values on the interval <code>abs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>abs</code></td>
<td>
<p>The interval on which is estimated the MCAR data mechanism.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The estimated probability to be MCAR given that the value is missing on the interval <code>abs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,pi.mcar=0.2,para=0.5,nb.cond=2,nb.repbio=3,
nb.sample=5,m.c=25,sd.c=2,sd.rb=0.5,sd.r=0.2);

#Imputation of missing values with the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.slsa, conditions=res.sim$condition);

#Estimating the MCAR mechanism in the first replicate
mcp=miss.mcar.process(res$abs.mod,res$pi.mcar[1],res$F.tot[,1],res$F.na[,1])
plot(mcp$abs,mcp$p,ty="l",xlab="Intensity values",ylab="Estimated probability to be MCAR")

</code></pre>

<hr>
<h2 id='miss.total.process'>
Estimating the missing data mechanism in a sample.
</h2><span id='topic+miss.total.process'></span>

<h3>Description</h3>

<p>This function allows estimating the missing data mechanism, i.e. the probability to be missing  in function of the intensity level, from an estimation of a mixture model of MNAR and MCAR values (see <code><a href="#topic+estim.mix">estim.mix</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miss.total.process(abs,pi_na,F_na,F_tot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miss.total.process_+3A_abs">abs</code></td>
<td>
<p>The interval on which is estimated the missing data mechanism.</p>
</td></tr>
<tr><td><code id="miss.total.process_+3A_pi_na">pi_na</code></td>
<td>
<p>The proportion of missing values.</p>
</td></tr>
<tr><td><code id="miss.total.process_+3A_f_na">F_na</code></td>
<td>
<p>An estimation of the cumulative distribution function of the missing values on the interval <code>abs</code>.</p>
</td></tr>
<tr><td><code id="miss.total.process_+3A_f_tot">F_tot</code></td>
<td>
<p>An estimation of the cumulative distribution function of the complete values on the interval <code>abs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>abs</code></td>
<td>
<p>The interval on which is estimated the missing data mechanism.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The estimated probability to be missing in function of the intensity level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of missing values with the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.slsa, conditions=res.sim$condition);

#Estimating the missing mechanism in the first replicate
mtp=miss.total.process(res$abs.mod,res$pi.na[1],res$F.na[,1],res$F.tot[,1])
plot(mtp$abs,mtp$p,ty="l",xlab="Intensity values",ylab="Estimated probability to be missing")

</code></pre>

<hr>
<h2 id='pi.mcar.karpievitch'>
Estimating the proportion of MCAR values in biological conditions using the method of Karpievitch (2009).
</h2><span id='topic+pi.mcar.karpievitch'></span>

<h3>Description</h3>

<p>This function allows estimating the proportion of MCAR values in biological conditions using the method of Karpievitch (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.mcar.karpievitch(tab,conditions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.mcar.karpievitch_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="pi.mcar.karpievitch_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>pi.mcar</code></td>
<td>
<p>The proportion of MCAR values in each biological condition.</p>
</td></tr>
<tr><td><code>prop.na</code></td>
<td>
<p>The proportion of missing values for each peptide in each condition.</p>
</td></tr>
<tr><td><code>moy</code></td>
<td>
<p>The average of observed values for each peptide in each condition.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>References</h3>

<p>Karpievitch, Y., Stanley, J., Taverner, T., Huang, J., Adkins, J. N., Ansong, C., ... &amp; Smith, R. D. (2009). A statistical framework for protein quantitation in bottom-up MS-based proteomics. Bioinformatics, 25(16), 2028-2034.</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Proportion of MCAR values in each condition
pi.mcar.karpievitch(tab=res.sim$dat.obs,conditions=res.sim$conditions)

</code></pre>

<hr>
<h2 id='pi.mcar.logit'>
Estimating the proportion of MCAR values in a sample using a logit model.
</h2><span id='topic+pi.mcar.logit'></span>

<h3>Description</h3>

<p>This function allows estimating the proportion of MCAR values in a sample using a logit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.mcar.logit(tab,conditions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.mcar.logit_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="pi.mcar.logit_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>pi.mcar</code></td>
<td>
<p>The estimated proportion of MCAR values.</p>
</td></tr>
<tr><td><code>coef1</code></td>
<td>
<p>The estimated intercept of each logit model estimated in a sample.</p>
</td></tr>
<tr><td><code>coef2</code></td>
<td>
<p>The estimated coefficient of each logit model estimated in a sample.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Proportion of MCAR values in each sample
pi.mcar.logit(tab=res.sim$dat.obs,conditions=res.sim$conditions)

</code></pre>

<hr>
<h2 id='pi.mcar.probit'>
Estimating the proportion of MCAR values in a sample using a probit model.
</h2><span id='topic+pi.mcar.probit'></span>

<h3>Description</h3>

<p>This function allows estimating the proportion of MCAR values in a sample using a probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.mcar.probit(tab,conditions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.mcar.probit_+3A_tab">tab</code></td>
<td>
<p>A data matrix containing numeric and missing values. Each column of this matrix is assumed to correspond to an experimental sample, and each row to an identified peptide.</p>
</td></tr>
<tr><td><code id="pi.mcar.probit_+3A_conditions">conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each column (experimental sample) belongs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of:
</p>
<table>
<tr><td><code>pi.mcar</code></td>
<td>
<p>The estimated proportion of MCAR values.</p>
</td></tr>
<tr><td><code>coef1</code></td>
<td>
<p>The estimated intercept of each probit model estimated in a sample.</p>
</td></tr>
<tr><td><code>coef2</code></td>
<td>
<p>The estimated coefficient of each probit model estimated in a sample.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Proportion of MCAR values in each sample
pi.mcar.probit(tab=res.sim$dat.obs, conditions=res.sim$condition);

</code></pre>

<hr>
<h2 id='prob.mcar'>
Estimation of a vector of probabilities that missing values are MCAR.
</h2><span id='topic+prob.mcar'></span>

<h3>Description</h3>

<p>This function returns a vector of probabilities that each missing value is MCAR from specified confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.mcar(b.u,absc,pi.na,pi.mcar,F.tot,F.obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob.mcar_+3A_b.u">b.u</code></td>
<td>
<p>A numeric vector of upper bounds for missing values.</p>
</td></tr>
<tr><td><code id="prob.mcar_+3A_absc">absc</code></td>
<td>
<p>The interval on which is estimated the MCAR data mechanism.</p>
</td></tr>
<tr><td><code id="prob.mcar_+3A_pi.na">pi.na</code></td>
<td>
<p>The estimated proportion of missing values.</p>
</td></tr>
<tr><td><code id="prob.mcar_+3A_pi.mcar">pi.mcar</code></td>
<td>
<p>The estimated proportion of MCAR values among missing values.</p>
</td></tr>
<tr><td><code id="prob.mcar_+3A_f.tot">F.tot</code></td>
<td>
<p>An estimation of the cumulative distribution function of the complete values on the interval <code>absc</code>.</p>
</td></tr>
<tr><td><code id="prob.mcar_+3A_f.obs">F.obs</code></td>
<td>
<p>An estimation of the cumulative distribution function of the missing values on the interval <code>absc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of estimated probabilities to be MCAR for missing values assuming upper bounds for them (<code>b.u</code>). The input arguments <code>absc</code>, <code>pi.mcar</code>, <code>pi.na</code>, <code>F.tot</code> and <code>F.obs</code> can be estimated thanks to the function <code><a href="#topic+estim.mix">estim.mix</a></code>.
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600);

#Imputation of missing values with the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.slsa, conditions=res.sim$condition);

#Computing probabilities to be MCAR
born=estim.bound(tab=res.sim$dat.obs,conditions=res.sim$condition);

#Computing probabilities to be MCAR in the first column of result$tab.mod
proba=prob.mcar(b.u=born$tab.upper[,1],absc=res$abs.mod,pi.na=res$pi.na[1],
pi.mcar=res$pi.mcar[1], F.tot=res$F.tot[,1], F.obs=res$F.obs[,1]);

</code></pre>

<hr>
<h2 id='prob.mcar.tab'>
Estimation of a matrix of probabilities that missing values are MCAR.
</h2><span id='topic+prob.mcar.tab'></span>

<h3>Description</h3>

<p>This function returns a matrix of probabilities that each missing value is MCAR from specified confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.mcar.tab(tab.u,res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob.mcar.tab_+3A_tab.u">tab.u</code></td>
<td>
<p>A numeric matrix of upper bounds for missing values.</p>
</td></tr>
<tr><td><code id="prob.mcar.tab_+3A_res">res</code></td>
<td>
<p>An output list resulting from the function <code><a href="#topic+estim.mix">estim.mix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of estimated probabilities to be MCAR for missing values assuming upper bounds for them (<code>tab.u</code>).
</p>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.mix">estim.mix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulating data
res.sim=sim.data(nb.pept=2000,nb.miss=600,para=5);

#Imputation of missing values with a MCAR-devoted algorithm: here the slsa algorithm
dat.slsa=impute.slsa(tab=res.sim$dat.obs,conditions=res.sim$condition,repbio=res.sim$repbio);

#Estimation of the mixture model
res=estim.mix(tab=res.sim$dat.obs, tab.imp=dat.slsa, conditions=res.sim$condition);

#Computing probabilities to be MCAR
born=estim.bound(tab=res.sim$dat.obs,conditions=res.sim$condition);
proba=prob.mcar.tab(born$tab.upper,res);

#Histogram of probabilities to be MCAR associated to generated MCAR values
hist(proba[res.sim$list.MCAR[[1]],1],

freq=FALSE,main="Estimated probabilities to be MCAR for known MCAR values",xlab="",col=2);

</code></pre>

<hr>
<h2 id='sim.data'>
Simulation of data sets by controlling the proportion of MCAR values and the distribution of MNAR values.
</h2><span id='topic+sim.data'></span>

<h3>Description</h3>

<p>This function simulates data sets similar to MS-based bottom-up proteomic data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
sim.data(nb.pept=15000,nb.miss=5000,pi.mcar=0.2,para=3,nb.cond=1,nb.repbio=3,
nb.sample=3,m.c=25,sd.c=2,sd.rb=0.5,sd.r=0.2)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.data_+3A_nb.pept">nb.pept</code></td>
<td>
<p>The number of rows (identified peptides) of the generated data set.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_nb.miss">nb.miss</code></td>
<td>
<p>The number of missing values to generate in each column.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_pi.mcar">pi.mcar</code></td>
<td>
<p>The proportion of MCAR values in each column.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_para">para</code></td>
<td>
<p>Parameter used for simulating MNAR values in columns (see Details).</p>
</td></tr>
<tr><td><code id="sim.data_+3A_nb.cond">nb.cond</code></td>
<td>
<p>The number of studied biological conditions.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_nb.repbio">nb.repbio</code></td>
<td>
<p>The number of biological samples in each condition.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_nb.sample">nb.sample</code></td>
<td>
<p>The number of samples coming from each biological sample.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_m.c">m.c</code></td>
<td>
<p>The mean of the average values in each condition.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_sd.c">sd.c</code></td>
<td>
<p>The standard deviation of the average values in each condition.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_sd.rb">sd.rb</code></td>
<td>
<p>The standard deviation of the average values in each biological sample.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_sd.r">sd.r</code></td>
<td>
<p>The standard deviation of values in each row among the samples coming from a same biological sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the average of intensities of a peptide <code>i</code> in a condition is generated by a Gaussian distribution <code class="reqn">m_{cond}\sim N(m.c,sd.c)</code>. Second, the effect of a biological sample is generated by <code class="reqn">m_{bio}\sim N(0,sd.rb)</code>. The value of a peptide <code>i</code> in the sample <code>j</code> belonging to a specific biological sample and a specific condition is finally generated by <code class="reqn">x_{ij}\sim N(m_{cond}+m_{bio},sd.r)</code>.
</p>
<p>Next, the MCAR values are generated in each column by random draws without replacement among the indexes of rows. The MNAR values are generated in the remaining indexes of rows by random draws without replacement and by respecting the following probabilities:
</p>
<p><code class="reqn">P(x_{ij} is MNAR)=1-(x_{ij}-min_i(x_{ij}))/((max_i(x_{ij})-min_i(x_{ij}))*(para))</code>
</p>
<p>where <code class="reqn">para</code> allows adjusting the distribution of MNAR values. If <code class="reqn">para=0</code>, then the MNAR values are uniformly distributed among intensity level. More <code class="reqn">para</code> is high and more the MNAR values arise for small intensity levels and not for high intensity levels.
</p>


<h3>Value</h3>

<table>
<tr><td><code>dat.obs</code></td>
<td>
<p>The simulated data set.</p>
</td></tr>
<tr><td><code>dat.comp</code></td>
<td>
<p>The simulated data set without missing values.</p>
</td></tr>
<tr><td><code>list.MCAR</code></td>
<td>
<p>The index of MCAR values among the rows in each column of the data set.</p>
</td></tr>
<tr><td><code>nMCAR</code></td>
<td>
<p>The number of MCAR values in each sample (after deleting rows with only generated missing values).</p>
</td></tr>
<tr><td><code>nNA</code></td>
<td>
<p>The number of missing values in each sample (after deleting rows with only generated missing values).</p>
</td></tr>
<tr><td><code>conditions</code></td>
<td>
<p>A vector of factors indicating the biological condition to which each sample belongs.</p>
</td></tr>
<tr><td><code>repbio</code></td>
<td>
<p>A vector of factors indicating the biological sample to which each sample belongs.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Quentin Giai Gianetto &lt;quentin2g@yahoo.fr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function can be used as
res.sim=sim.data(nb.pept=2000,nb.miss=600);
## Simulated data matrix
data=res.sim$dat.obs;
## Vector of conditions of membership for each sample
cond=res.sim$conditions;
## Vector of biological sample of membership for each sample
repbio=res.sim$repbio;
## Percentage of generated MCAR values for each sample
pi_mcar=res.sim$nMCAR/res.sim$nNA

</code></pre>

<hr>
<h2 id='translatedRandomBeta'>
Function to generated values following a translated Beta distribution
</h2><span id='topic+translatedRandomBeta'></span>

<h3>Description</h3>

<p>Function to generate values following a translated Beta distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translatedRandomBeta(n, min, max, param1 = 3, param2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translatedRandomBeta_+3A_n">n</code></td>
<td>

<p>Number of values to generate.
</p>
</td></tr>
<tr><td><code id="translatedRandomBeta_+3A_min">min</code></td>
<td>

<p>Minimum of the values to be generated.
</p>
</td></tr>
<tr><td><code id="translatedRandomBeta_+3A_max">max</code></td>
<td>

<p>Maximum of the values to be generated.
</p>
</td></tr>
<tr><td><code id="translatedRandomBeta_+3A_param1">param1</code></td>
<td>

<p>Parameter of the Beta distribution.
</p>
</td></tr>
<tr><td><code id="translatedRandomBeta_+3A_param2">param2</code></td>
<td>

<p>Parameter of the Beta distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values following a translated Beta distribution.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
