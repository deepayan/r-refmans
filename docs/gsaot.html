<!DOCTYPE html><html lang="en"><head><title>Help for package gsaot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gsaot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lower_bound'><p>Calculate lower bounds for Optimal Transport sensitivity indices</p></a></li>
<li><a href='#ot_indices'><p>Calculate Optimal Transport sensitivity indices for multivariate y</p></a></li>
<li><a href='#ot_indices_1d'><p>Evaluate Optimal Transport indices on one dimensional outputs</p></a></li>
<li><a href='#ot_indices_smap'><p>Evaluate sensitivity maps using Optimal Transport indices</p></a></li>
<li><a href='#ot_indices_wb'><p>Evaluate Wasserstein-Bures approximation of the Optimal Transport solution</p></a></li>
<li><a href='#plot_inner_stats'><p>Plot Optimal Transport inner statistics</p></a></li>
<li><a href='#plot.gsaot_indices'><p>Plot Optimal Transport sensitivity indices</p></a></li>
<li><a href='#print.gsaot_indices'><p>Print Optimal Transport Sensitivity indices information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Compute Global Sensitivity Analysis Indices Using Optimal
Transport</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Computing Global Sensitivity Indices from given data using Optimal Transport, as defined in Borgonovo et al (2024) &lt;<a href="https://doi.org/10.1287%2Fmnsc.2023.01796">doi:10.1287/mnsc.2023.01796</a>&gt;. You provide an input sample, an output sample, decide the algorithm, and compute the indices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, ggplot2, patchwork (&ge; 1.2.0), Rcpp, RcppEigen (&ge;
0.3.4.0.0), Rdpack (&ge; 2.4), stats, transport (&ge; 0.15.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pietrocipolla/gsaot">https://github.com/pietrocipolla/gsaot</a>,
<a href="https://pietrocipolla.github.io/gsaot/">https://pietrocipolla.github.io/gsaot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pietrocipolla/gsaot/issues">https://github.com/pietrocipolla/gsaot/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-09 14:05:11 UTC; dagileonardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Leonardo Chiani <a href="https://orcid.org/0009-0007-2491-6290"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Emanuele Borgonovo [rev],
  Elmar Plischke [rev],
  Massimo Tavoni [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leonardo Chiani &lt;leonardo.chiani@polimi.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 14:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='lower_bound'>Calculate lower bounds for Optimal Transport sensitivity indices</h2><span id='topic+lower_bound'></span>

<h3>Description</h3>

<p>Calculate lower bounds for Optimal Transport sensitivity indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower_bound(
  y,
  M,
  bound = "dummy",
  dummy_optns = NULL,
  cost = "L2",
  discrete_out = FALSE,
  solver = "sinkhorn",
  solver_optns = NULL,
  scaling = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lower_bound_+3A_y">y</code></td>
<td>
<p>An array or a matrix containing the output values.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of partitions for continuous
inputs.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_bound">bound</code></td>
<td>
<p>(default <code>"dummy"</code>) A string defining the type of lower bound to
compute. Should be <code>"dummy"</code> or <code>"entropic"</code>. See <code>details</code> for more
information.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_dummy_optns">dummy_optns</code></td>
<td>
<p>(default <code>NULL</code>) A list containing the options on the
distribution of the dummy variable. See <code>details</code> for more information.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_cost">cost</code></td>
<td>
<p>(default <code>"L2"</code>) A string or function defining the cost function
of the Optimal Transport problem. It should be &quot;L2&quot; or a function taking as
input y and returning a cost matrix. If <code>cost="L2"</code>, <code>ot_indices</code> uses the
squared Euclidean metric.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_discrete_out">discrete_out</code></td>
<td>
<p>(default <code>FALSE</code>) Logical, by default the output sample
in <code>y</code> are equally weighted. If <code>discrete_out=TRUE</code>, the function tries to
create an histogram of the realizations and to use the histogram as
weights. It works if the output is discrete or mixed and the number of
realizations is large. The advantage of this option is to reduce the
dimension of the cost matrix.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_solver">solver</code></td>
<td>
<p>Solver for the Optimal Transport problem. Currently supported
options are:
</p>

<ul>
<li> <p><code>"sinkhorn"</code> (default), the Sinkhorn's solver (Cuturi 2013).
</p>
</li>
<li> <p><code>"sinkhorn_log"</code>, the Sinkhorn's solver in log scale (Peyr√© et al. 2019).
</p>
</li>
<li> <p><code>"transport"</code>, a solver of the non regularized OT problem using <code><a href="transport.html#topic+transport">transport::transport()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lower_bound_+3A_solver_optns">solver_optns</code></td>
<td>
<p>(optional) A list containing the options for the Optimal
Transport solver. See details for allowed options and default ones.</p>
</td></tr>
<tr><td><code id="lower_bound_+3A_scaling">scaling</code></td>
<td>
<p>(default <code>TRUE</code>) Logical that sets whether or not to scale the
cost matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows the computation of two different lower bounds.
With <code>bound="dummy"</code>, the function samples from a distribution defined in
<code>dummy_optns</code> (by default a standard normal), independent from the output
<code>y</code> and then computes the indices using the algorithm specified in
<code>solver</code>. Under the hood, <code>lower_bound</code> calls the other available functions
in the package:
</p>

<ul>
<li> <p><code><a href="#topic+ot_indices_1d">ot_indices_1d()</a></code> (for <code style="white-space: pre;">&#8288;solver="1d&#8288;</code>)
</p>
</li>
<li> <p><code><a href="#topic+ot_indices_wb">ot_indices_wb()</a></code> (for <code>solver="wasserstein-bures"</code>)
</p>
</li>
<li> <p><code><a href="#topic+ot_indices">ot_indices()</a></code> (for <code>solver %in% c("sinkhorn", "sinkhorn_log", "wasserstein")</code>)
The user can choose the distribution of the dummy variable using the
argument <code>dummy_optns</code>. <code>dummy_optns</code> should be a named list with at least
a term called <code>"distr"</code> defining the sampling function. The other terms in
the list are used as arguments to the sampling function. With
<code>bound="entropic"</code>, the function computes the lower bound of the entropic
indices. In this case, <code>solver</code> should be either <code>"sinkhorn"</code> or
<code>"sinkhorn_log"</code>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>gsaot_indices</code> for <code>bound="dummy"</code> or a scalar
for <code>bound="entropic"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

mx &lt;- c(1, 1, 1)
Sigmax &lt;- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x3 &lt;- rnorm(N)

x &lt;- cbind(x1, x2, x3)
x &lt;- mx + x %*% chol(Sigmax)

A &lt;- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
y &lt;- t(A %*% t(x))

M &lt;- 25

sink_lb &lt;- lower_bound(y, M, bound = "entropic")
dummy_lb &lt;- lower_bound(y, M, bound = "dummy")

# Custom sampling funtion and network simplex solver
dummy_optns &lt;- list(distr = "rgamma", shape = 3)
dummy_lb_cust &lt;- lower_bound(y, M, bound = "dummy",
                                  dummy_optns = dummy_optns,
                                  solver = "transport")
</code></pre>

<hr>
<h2 id='ot_indices'>Calculate Optimal Transport sensitivity indices for multivariate y</h2><span id='topic+ot_indices'></span>

<h3>Description</h3>

<p><code>ot_indices</code> calculates sensitivity indices using Optimal
Transport (OT) for a multivariate output sample <code>y</code> with respect to input
data <code>x</code>. Sensitivity indices measure the influence of inputs on outputs,
with values ranging between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ot_indices(
  x,
  y,
  M,
  cost = "L2",
  discrete_out = FALSE,
  solver = "sinkhorn",
  solver_optns = NULL,
  scaling = TRUE,
  boot = FALSE,
  stratified_boot = FALSE,
  R = NULL,
  parallel = "no",
  ncpus = 1,
  conf = 0.95,
  type = "norm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ot_indices_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame containing the input(s) values. The values
can be numeric, factors, or strings. The type of data changes the
partitioning. If the values are continuous (double), the function
partitions the data into <code>M</code> sets. If the values are discrete (integers,
strings, factors), the number of partitioning sets is data-driven.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_y">y</code></td>
<td>
<p>A matrix containing the output values. Each column represents a
different output variable, and each row represents a different observation.
Only numeric values are allowed.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of partitions for continuous
inputs.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_cost">cost</code></td>
<td>
<p>(default <code>"L2"</code>) A string or function defining the cost function
of the Optimal Transport problem. It should be &quot;L2&quot; or a function taking as
input y and returning a cost matrix. If <code>cost="L2"</code>, <code>ot_indices</code> uses the
squared Euclidean metric.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_discrete_out">discrete_out</code></td>
<td>
<p>(default <code>FALSE</code>) Logical, by default the output sample
in <code>y</code> are equally weighted. If <code>discrete_out=TRUE</code>, the function tries to
create an histogram of the realizations and to use the histogram as
weights. It works if the output is discrete or mixed and the number of
realizations is large. The advantage of this option is to reduce the
dimension of the cost matrix.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_solver">solver</code></td>
<td>
<p>Solver for the Optimal Transport problem. Currently supported
options are:
</p>

<ul>
<li> <p><code>"sinkhorn"</code> (default), the Sinkhorn's solver (Cuturi 2013).
</p>
</li>
<li> <p><code>"sinkhorn_log"</code>, the Sinkhorn's solver in log scale (Peyr√© et al. 2019).
</p>
</li>
<li> <p><code>"transport"</code>, a solver of the non regularized OT problem using <code><a href="transport.html#topic+transport">transport::transport()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ot_indices_+3A_solver_optns">solver_optns</code></td>
<td>
<p>(optional) A list containing the options for the Optimal
Transport solver. See details for allowed options and default ones.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_scaling">scaling</code></td>
<td>
<p>(default <code>TRUE</code>) Logical that sets whether or not to scale the
cost matrix.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_boot">boot</code></td>
<td>
<p>(default <code>FALSE</code>) Logical that sets whether or not to perform
bootstrapping of the OT indices.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_stratified_boot">stratified_boot</code></td>
<td>
<p>(default <code>FALSE</code>) Logical that sets the type of
resampling performed. With <code>stratified_boot=FALSE</code>, the function resamples
the dataset and then creates the partitions. Otherwise, first, it
creates the partitions and then it performs stratified bootstrapping with
strata being the partitions.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_r">R</code></td>
<td>
<p>(default <code>NULL</code>) Positive integer, number of bootstrap replicas.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_parallel">parallel</code></td>
<td>
<p>(default <code>"no"</code>) The type of parallel operation to be used
(if any). If missing, the default is taken from the option <code>boot.parallel</code>
(and if that is not set, <code>"no"</code>). Only considered if <code>boot = TRUE</code>. For
more information, check the <code><a href="boot.html#topic+boot">boot::boot()</a></code> function.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_ncpus">ncpus</code></td>
<td>
<p>(default <code>1</code>) Positive integer: number of processes to be used
in parallel operation: typically one would chose this to the number of
available CPUs. Check the <code>ncpus</code> option in the <code><a href="boot.html#topic+boot">boot::boot()</a></code> function of
the boot package.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_conf">conf</code></td>
<td>
<p>(default <code>0.95</code>) Number between <code>0</code> and <code>1</code> representing the
confidence level. Only considered if <code>boot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ot_indices_+3A_type">type</code></td>
<td>
<p>(default <code>"norm"</code>) Method to compute the confidence interval.
Only considered if <code>boot = TRUE</code>. For more information, check the <code>type</code>
option of <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Solvers</h4>

<p>OT is a widely studied topic in Operational Research and Calculus. The
reference for the OT solvers in this package is
Peyr√© et al. (2019). The default solver is
<code>"sinkhorn"</code>, the Sinkhorn's solver introduced in
Cuturi (2013). It solves the
entropic-regularized version of the OT problem. The <code>"sinkhorn_log"</code> solves
the same OT problem but in log scale. It is more stable for low values of
the regularization parameter but slower to converge. The option
<code>"transport"</code> is used to choose a solver for the non-regularized OT
problem. Under the hood, the function calls <code><a href="transport.html#topic+transport">transport::transport()</a></code> from
package <code>transport</code>. This option does not define the solver per se, but the
solver should be defined with the argument <code>solver_optns</code>. See the next
section for more information.
</p>



<h4>Solver options</h4>

<p>The argument <code>solver_optns</code> should be empty (for default options) or a list
with all or some of the required solver parameters. All the parameters not
included in the list will be set to default values. The solvers
<code>"sinkhorn"</code> and <code>"sinkhorn_log"</code> have the same options:
</p>

<ul>
<li> <p><code>numIterations</code> (default <code>1e3</code>): a positive integer defining the maximum number
of Sinkhorn's iterations allowed. If the solver does not converge in the
number of iterations set, the solver will throw an error.
</p>
</li>
<li> <p><code>epsilon</code> (default <code>0.01</code>): a positive real number defining the regularization
coefficient. If the value is too low, the solver may return <code>NA</code>.
</p>
</li>
<li> <p><code>maxErr</code> (default <code>1e-9</code>): a positive real number defining the
approximation error threshold between the marginal histogram of the
partition and the one computed by the solver. The solver may fail to
converge in <code>numIterations</code> if this value is too low.
</p>
</li></ul>

<p>The solver <code>"transport"</code> has the parameters:
</p>

<ul>
<li> <p><code>method</code> (default <code style="white-space: pre;">&#8288;"networkflow&#8288;</code>): string defining the solver of the OT
problem.
</p>
</li>
<li> <p><code>control</code>: a named list of parameters for the chosen method or the result
of a call to <code><a href="transport.html#topic+trcontrol">transport::trcontrol()</a></code>.
</p>
</li>
<li> <p><code>threads</code> (default <code>1</code>): an Integer specifying the number of threads used
in parallel computing.
</p>
</li></ul>

<p>For details regarding this solver, check the <code><a href="transport.html#topic+transport">transport::transport()</a></code> help
page.
</p>



<h3>Value</h3>

<p>A <code>gsaot_indices</code> object containing:
</p>

<ul>
<li> <p><code>method</code>: a string that identifies the type of indices computed.
</p>
</li>
<li> <p><code>indices</code>: a names array containing the sensitivity indices between 0 and 1
for each column in x, indicating the influence of each input variable on
the output variables.
</p>
</li>
<li> <p><code>bound</code>: a double representing the upper bound of the separation measure or
an array representing the mean of the separation for each input according
to the bootstrap replicas.
</p>
</li>
<li> <p><code>x</code>, <code>y</code>: input and output data provided as arguments of the function.
</p>
</li>
<li> <p><code>inner_statistic</code>: a list of matrices containing the values of the inner
statistics for the partitions defined by <code>partitions</code>. If <code>method = wasserstein-bures</code>, each matrix has three rows containing the
Wasserstein-Bures indices, the Advective, and the Diffusive components.
</p>
</li>
<li> <p><code>partitions</code>: a matrix containing the partitions built to calculate the
sensitivity indices. Each column contains the partition associated to the
same column in <code>x</code>. If <code>boot = TRUE</code>, the object contains also:
</p>
</li>
<li> <p><code>indices_ci</code>: a <code>data.frame</code> with first column the input, second and third
columns the lower and upper bound of the confidence interval.
</p>
</li>
<li> <p><code>inner_statistic_ci</code>: a list of matrices. Each element of the list contains
the lower and upper confidence bounds for the partition defined by the row.
</p>
</li>
<li> <p><code>bound_ci</code>: a list containing the lower and upper bounds of the confidence
intervals of the separation measure bound.
</p>
</li>
<li> <p><code>type</code>, <code>conf</code>: type of confidence interval and confidence level, provided
as arguments.
</p>
</li></ul>



<h3>References</h3>

<p>Cuturi M (2013).
&ldquo;Sinkhorn distances: Lightspeed computation of optimal transport.&rdquo;
<em>Advances in neural information processing systems</em>, <b>26</b>.<br /><br /> Peyr√© G, Cuturi M, others (2019).
&ldquo;Computational optimal transport: With applications to data science.&rdquo;
<em>Foundations and Trends¬Æ in Machine Learning</em>, <b>11</b>(5-6), 355&ndash;607.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ot_indices_1d">ot_indices_1d()</a></code>, <code><a href="#topic+ot_indices_wb">ot_indices_wb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

mx &lt;- c(1, 1, 1)
Sigmax &lt;- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x3 &lt;- rnorm(N)

x &lt;- cbind(x1, x2, x3)
x &lt;- mx + x %*% chol(Sigmax)

A &lt;- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
y &lt;- t(A %*% t(x))

x &lt;- data.frame(x)

M &lt;- 25

# Calculate sensitivity indices
sensitivity_indices &lt;- ot_indices(x, y, M)
sensitivity_indices

</code></pre>

<hr>
<h2 id='ot_indices_1d'>Evaluate Optimal Transport indices on one dimensional outputs</h2><span id='topic+ot_indices_1d'></span>

<h3>Description</h3>

<p>Evaluate Optimal Transport indices on one dimensional outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ot_indices_1d(
  x,
  y,
  M,
  boot = FALSE,
  R = NULL,
  parallel = "no",
  ncpus = 1,
  conf = 0.95,
  type = "norm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ot_indices_1d_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame containing the input(s) values. The values
can be numeric, factors, or strings. The type of data changes the
partitioning. If the values are continuous (double), the function
partitions the data into <code>M</code> sets. If the values are discrete (integers,
strings, factors), the number of partitioning sets is data-driven.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_y">y</code></td>
<td>
<p>An array containing the output values.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of partitions for continuous
inputs.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_boot">boot</code></td>
<td>
<p>(default <code>FALSE</code>) Logical that sets whether or not to perform
bootstrapping of the OT indices.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_r">R</code></td>
<td>
<p>(default <code>NULL</code>) Positive integer, number of bootstrap replicas.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_parallel">parallel</code></td>
<td>
<p>(default <code>"no"</code>) The type of parallel operation to be used
(if any). If missing, the default is taken from the option <code>boot.parallel</code>
(and if that is not set, <code>"no"</code>). Only considered if <code>boot = TRUE</code>. For
more information, check the <code><a href="boot.html#topic+boot">boot::boot()</a></code> function.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_ncpus">ncpus</code></td>
<td>
<p>(default <code>1</code>) Positive integer: number of processes to be used
in parallel operation: typically one would chose this to the number of
available CPUs. Check the <code>ncpus</code> option in the <code><a href="boot.html#topic+boot">boot::boot()</a></code> function of
the boot package.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_conf">conf</code></td>
<td>
<p>(default <code>0.95</code>) Number between <code>0</code> and <code>1</code> representing the
confidence level. Only considered if <code>boot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ot_indices_1d_+3A_type">type</code></td>
<td>
<p>(default <code>"norm"</code>) Method to compute the confidence interval.
Only considered if <code>boot = TRUE</code>. For more information, check the <code>type</code>
option of <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gsaot_indices</code> object containing:
</p>

<ul>
<li> <p><code>method</code>: a string that identifies the type of indices computed.
</p>
</li>
<li> <p><code>indices</code>: a names array containing the sensitivity indices between 0 and 1
for each column in x, indicating the influence of each input variable on
the output variables.
</p>
</li>
<li> <p><code>bound</code>: a double representing the upper bound of the separation measure or
an array representing the mean of the separation for each input according
to the bootstrap replicas.
</p>
</li>
<li> <p><code>x</code>, <code>y</code>: input and output data provided as arguments of the function.
</p>
</li>
<li> <p><code>inner_statistic</code>: a list of matrices containing the values of the inner
statistics for the partitions defined by <code>partitions</code>. If <code>method = wasserstein-bures</code>, each matrix has three rows containing the
Wasserstein-Bures indices, the Advective, and the Diffusive components.
</p>
</li>
<li> <p><code>partitions</code>: a matrix containing the partitions built to calculate the
sensitivity indices. Each column contains the partition associated to the
same column in <code>x</code>. If <code>boot = TRUE</code>, the object contains also:
</p>
</li>
<li> <p><code>indices_ci</code>: a <code>data.frame</code> with first column the input, second and third
columns the lower and upper bound of the confidence interval.
</p>
</li>
<li> <p><code>inner_statistic_ci</code>: a list of matrices. Each element of the list contains
the lower and upper confidence bounds for the partition defined by the row.
</p>
</li>
<li> <p><code>bound_ci</code>: a list containing the lower and upper bounds of the confidence
intervals of the separation measure bound.
</p>
</li>
<li> <p><code>type</code>, <code>conf</code>: type of confidence interval and confidence level, provided
as arguments.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ot_indices">ot_indices()</a></code>, <code><a href="#topic+ot_indices_wb">ot_indices_wb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
y &lt;- 10 * x
ot_indices_1d(data.frame(x), y, 30)
</code></pre>

<hr>
<h2 id='ot_indices_smap'>Evaluate sensitivity maps using Optimal Transport indices</h2><span id='topic+ot_indices_smap'></span>

<h3>Description</h3>

<p>Evaluate sensitivity maps using Optimal Transport indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ot_indices_smap(x, y, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ot_indices_smap_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame containing the input(s) values. The values
can be numeric, factors, or strings. The type of data changes the
partitioning. If the values are continuous (double), the function
partitions the data into <code>M</code> sets. If the values are discrete (integers,
strings, factors), the number of partitioning sets is data-driven.</p>
</td></tr>
<tr><td><code id="ot_indices_smap_+3A_y">y</code></td>
<td>
<p>A matrix containing the output values. Each column is interpreted as
a different output.</p>
</td></tr>
<tr><td><code id="ot_indices_smap_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of partitions for continuous
inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column represents an input and each row
represents an output. The values are indices between 0 and 1 computed using
<code><a href="#topic+ot_indices_1d">ot_indices_1d()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x &lt;- cbind(x1, x2)

y1 &lt;- 10 * x1
y2 &lt;- x1 + x2
y &lt;- cbind(y1, y2)

ot_indices_smap(data.frame(x), y, 30)
</code></pre>

<hr>
<h2 id='ot_indices_wb'>Evaluate Wasserstein-Bures approximation of the Optimal Transport solution</h2><span id='topic+ot_indices_wb'></span>

<h3>Description</h3>

<p>Evaluate Wasserstein-Bures approximation of the Optimal Transport solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ot_indices_wb(
  x,
  y,
  M,
  boot = FALSE,
  R = NULL,
  parallel = "no",
  ncpus = 1,
  conf = 0.95,
  type = "norm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ot_indices_wb_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame containing the input(s) values. The values
can be numeric, factors, or strings. The type of data changes the
partitioning. If the values are continuous (double), the function
partitions the data into <code>M</code> sets. If the values are discrete (integers,
strings, factors), the number of partitioning sets is data-driven.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_y">y</code></td>
<td>
<p>A matrix containing the output values. Each column represents a
different output variable, and each row represents a different observation.
Only numeric values are allowed.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_m">M</code></td>
<td>
<p>A scalar representing the number of partitions for continuous
inputs.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_boot">boot</code></td>
<td>
<p>(default <code>FALSE</code>) Logical that sets whether or not to perform
bootstrapping of the OT indices.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_r">R</code></td>
<td>
<p>(default <code>NULL</code>) Positive integer, number of bootstrap replicas.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_parallel">parallel</code></td>
<td>
<p>(default <code>"no"</code>) The type of parallel operation to be used
(if any). If missing, the default is taken from the option <code>boot.parallel</code>
(and if that is not set, <code>"no"</code>). Only considered if <code>boot = TRUE</code>. For
more information, check the <code><a href="boot.html#topic+boot">boot::boot()</a></code> function.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_ncpus">ncpus</code></td>
<td>
<p>(default <code>1</code>) Positive integer: number of processes to be used
in parallel operation: typically one would chose this to the number of
available CPUs. Check the <code>ncpus</code> option in the <code><a href="boot.html#topic+boot">boot::boot()</a></code> function of
the boot package.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_conf">conf</code></td>
<td>
<p>(default <code>0.95</code>) Number between <code>0</code> and <code>1</code> representing the
confidence level. Only considered if <code>boot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ot_indices_wb_+3A_type">type</code></td>
<td>
<p>(default <code>"norm"</code>) Method to compute the confidence interval.
Only considered if <code>boot = TRUE</code>. For more information, check the <code>type</code>
option of <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gsaot_indices</code> object containing:
</p>

<ul>
<li> <p><code>method</code>: a string that identifies the type of indices computed.
</p>
</li>
<li> <p><code>indices</code>: a names array containing the sensitivity indices between 0 and 1
for each column in x, indicating the influence of each input variable on
the output variables.
</p>
</li>
<li> <p><code>bound</code>: a double representing the upper bound of the separation measure or
an array representing the mean of the separation for each input according
to the bootstrap replicas.
</p>
</li>
<li> <p><code>x</code>, <code>y</code>: input and output data provided as arguments of the function.
</p>
</li>
<li> <p><code>inner_statistic</code>: a list of matrices containing the values of the inner
statistics for the partitions defined by <code>partitions</code>. If <code>method = wasserstein-bures</code>, each matrix has three rows containing the
Wasserstein-Bures indices, the Advective, and the Diffusive components.
</p>
</li>
<li> <p><code>partitions</code>: a matrix containing the partitions built to calculate the
sensitivity indices. Each column contains the partition associated to the
same column in <code>x</code>. If <code>boot = TRUE</code>, the object contains also:
</p>
</li>
<li> <p><code>indices_ci</code>: a <code>data.frame</code> with first column the input, second and third
columns the lower and upper bound of the confidence interval.
</p>
</li>
<li> <p><code>inner_statistic_ci</code>: a list of matrices. Each element of the list contains
the lower and upper confidence bounds for the partition defined by the row.
</p>
</li>
<li> <p><code>bound_ci</code>: a list containing the lower and upper bounds of the confidence
intervals of the separation measure bound.
</p>
</li>
<li> <p><code>type</code>, <code>conf</code>: type of confidence interval and confidence level, provided
as arguments.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ot_indices">ot_indices()</a></code>, <code><a href="#topic+ot_indices_1d">ot_indices_1d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

mx &lt;- c(1, 1, 1)
Sigmax &lt;- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x3 &lt;- rnorm(N)

x &lt;- cbind(x1, x2, x3)
x &lt;- mx + x %*% chol(Sigmax)

A &lt;- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
y &lt;- t(A %*% t(x))

x &lt;- data.frame(x)
y &lt;- y

ot_indices_wb(x, y, 100)
</code></pre>

<hr>
<h2 id='plot_inner_stats'>Plot Optimal Transport inner statistics</h2><span id='topic+plot_inner_stats'></span>

<h3>Description</h3>

<p>Plot Optimal Transport based inner statistics for each partition using
<code>ggplot2</code> package. If provided, it plots also the uncertainty estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_inner_stats(x, ranking = NULL, wb_all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_inner_stats_+3A_x">x</code></td>
<td>
<p>An object generated by <code><a href="#topic+ot_indices">ot_indices</a></code>,
<code><a href="#topic+ot_indices_1d">ot_indices_1d</a></code>, or <code><a href="#topic+ot_indices_wb">ot_indices_wb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_inner_stats_+3A_ranking">ranking</code></td>
<td>
<p>An integer with absolute value less or equal than the number
of inputs. If positive, select the first <code>ranking</code> inputs per importance.
If negative, select the last <code>ranking</code> inputs per importance.</p>
</td></tr>
<tr><td><code id="plot_inner_stats_+3A_wb_all">wb_all</code></td>
<td>
<p>(default <code>FALSE</code>) Logical that defines whether or not to plot
the Advective and Diffusive components of the Wasserstein-Bures indices</p>
</td></tr>
<tr><td><code id="plot_inner_stats_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>patchwork</code> object that, if called, will print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

mx &lt;- c(1, 1, 1)
Sigmax &lt;- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x3 &lt;- rnorm(N)

x &lt;- cbind(x1, x2, x3)
x &lt;- mx + x %*% chol(Sigmax)

A &lt;- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
y &lt;- t(A %*% t(x))

x &lt;- data.frame(x)

M &lt;- 25

# Get sensitivity indices
sensitivity_indices &lt;- ot_indices(x, y, M)
plot_inner_stats(sensitivity_indices)

</code></pre>

<hr>
<h2 id='plot.gsaot_indices'>Plot Optimal Transport sensitivity indices</h2><span id='topic+plot.gsaot_indices'></span>

<h3>Description</h3>

<p>Plot Optimal Transport based sensitivity indices using <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsaot_indices'
plot(x, ranking = NULL, wb_all = FALSE, dummy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gsaot_indices_+3A_x">x</code></td>
<td>
<p>An object generated by <code><a href="#topic+ot_indices">ot_indices</a></code>,
<code><a href="#topic+ot_indices_1d">ot_indices_1d</a></code>, or <code><a href="#topic+ot_indices_wb">ot_indices_wb</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gsaot_indices_+3A_ranking">ranking</code></td>
<td>
<p>An integer with absolute value less or equal than the number
of inputs. If positive, select the first <code>ranking</code> inputs per importance.
If negative, select the last <code>ranking</code> inputs per importance.</p>
</td></tr>
<tr><td><code id="plot.gsaot_indices_+3A_wb_all">wb_all</code></td>
<td>
<p>(default <code>FALSE</code>) Logical that defines whether or not to plot
the Advective and Diffusive components of the Wasserstein-Bures indices</p>
</td></tr>
<tr><td><code id="plot.gsaot_indices_+3A_dummy">dummy</code></td>
<td>
<p>(default <code>NULL</code>) A double or and object of class <code>gsaot_indices</code>
that represents a lower bound.</p>
</td></tr>
<tr><td><code id="plot.gsaot_indices_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object that, if called, will print
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

mx &lt;- c(1, 1, 1)
Sigmax &lt;- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x3 &lt;- rnorm(N)

x &lt;- cbind(x1, x2, x3)
x &lt;- mx + x %*% chol(Sigmax)

A &lt;- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
y &lt;- t(A %*% t(x))

x &lt;- data.frame(x)

M &lt;- 25

# Calculate sensitivity indices
sensitivity_indices &lt;- ot_indices_wb(x, y, M)
sensitivity_indices

plot(sensitivity_indices)

</code></pre>

<hr>
<h2 id='print.gsaot_indices'>Print Optimal Transport Sensitivity indices information</h2><span id='topic+print.gsaot_indices'></span>

<h3>Description</h3>

<p>Print Optimal Transport Sensitivity indices information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsaot_indices'
print(x, data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gsaot_indices_+3A_x">x</code></td>
<td>
<p>An object generated by <code><a href="#topic+ot_indices">ot_indices</a></code>,
<code><a href="#topic+ot_indices_1d">ot_indices_1d</a></code>, or <code><a href="#topic+ot_indices_wb">ot_indices_wb</a></code>.</p>
</td></tr>
<tr><td><code id="print.gsaot_indices_+3A_data">data</code></td>
<td>
<p>Logical, indicating whether or not the input and output data
should be printed.</p>
</td></tr>
<tr><td><code id="print.gsaot_indices_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The information contained in argument <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1000

mx &lt;- c(1, 1, 1)
Sigmax &lt;- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)

x1 &lt;- rnorm(N)
x2 &lt;- rnorm(N)
x3 &lt;- rnorm(N)

x &lt;- cbind(x1, x2, x3)
x &lt;- mx + x %*% chol(Sigmax)

A &lt;- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
y &lt;- t(A %*% t(x))

x &lt;- data.frame(x)

M &lt;- 25

# Calculate sensitivity indices
sensitivity_indices &lt;- ot_indices(x, y, M)
print(sensitivity_indices)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
