<!DOCTYPE html><html><head><title>Help for package likelihoodAsy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {likelihoodAsy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#likelihoodAsy-package'>
<p>The R likelihoodAsy Package</p></a></li>
<li><a href='#finndat'><p>Data from Finney (1947)</p></a></li>
<li><a href='#logMPL'>
<p>Modified profile likelihood computation</p></a></li>
<li><a href='#logPL'>
<p>Profile likelihood computation</p></a></li>
<li><a href='#rstar'>
<p>Inference on a scalar function of interest by the r* statistic</p></a></li>
<li><a href='#rstar.ci'>
<p>Confidence intervals on a scalar function of interest by the r* statistic</p></a></li>
<li><a href='#rstar.ci.control'>
<p>Auxiliary function for controlling computation of r*-based confidence intervals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.51</td>
</tr>
<tr>
<td>Priority:</td>
<td>optional</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Likelihood Asymptotics</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruggero Bellio and Donald Pierce</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruggero Bellio &lt;ruggero.bellio@uniud.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>cond, digest</td>
</tr>
<tr>
<td>Imports:</td>
<td>nleqslv, Rsolnp, alabama, pracma,</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for computing the r and r* statistics for inference on an arbitrary scalar function of model parameters, plus some code for the (modified) profile likelihood.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, lme4, knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-08 13:26:25 UTC; rbellio</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-15 08:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='likelihoodAsy-package'>
The R likelihoodAsy Package
</h2><span id='topic+likelihoodAsy-package'></span><span id='topic+likelihoodAsy'></span>

<h3>Description</h3>

<p>Some functions for likelihood asymptotics, based on the expository paper
</p>
<p>Pierce, D.A. and Bellio, R. (2017). Modern likelihood-frequentist inference. International Statistical Review, 85, 519-541.
</p>


<h3>Details</h3>

<p>For a detailed introduction see the vignette (<code>browseVignettes("likelihoodAsy")</code>), which includes an
R script that carries out the examples.
</p>


<h3>Author(s)</h3>

<p>Author: Ruggero Bellio and Donald A Pierce 
</p>
<p>Maintainer: Ruggero Bellio <a href="mailto:ruggero.bellio@uniud.it">ruggero.bellio@uniud.it</a>
</p>

<hr>
<h2 id='finndat'>Data from Finney (1947)</h2><span id='topic+finndat'></span>

<h3>Description</h3>

<p>Binomial data from a bioassay.</p>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 3 variables.
</p>

<dl>
<dt><code>z</code></dt><dd><p>a numeric vector of doses.</p>
</dd>
<dt><code>den</code></dt><dd><p>a numeric vector of  binomial denominators.</p>
</dd>
<dt><code>y</code></dt><dd><p>binomial responses. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Finney, D.J. (1947).  <em>Probit Analysis: A Statistical Treatment of the Sigmoid 
Response Curve</em>. Cambridge University Press, London and New York.
</p>

<hr>
<h2 id='logMPL'>
Modified profile likelihood computation
</h2><span id='topic+logMPL'></span>

<h3>Description</h3>

<p>This function evaluates the Modified Profile Likelihood (MPL) for a subset of the 
model parameter. The result is optionally returned with a minus sign, so the function 
can be used directly as input to a general-purpose optimizer.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logMPL(psival, data, mle, floglik, fscore=NULL, indpsi, datagen, R=500, seed=NULL, 
       minus=FALSE, onestep=FALSE, jhat=NULL, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logMPL_+3A_psival">psival</code></td>
<td>

<p>A numerical vector containing the value of the parameter of interest.
</p>
</td></tr>  
<tr><td><code id="logMPL_+3A_data">data</code></td>
<td>

<p>The data as a list. All the elements required to compute the likelihood function 
at a given parameter value should be included in this list. The required format of such list 
will be determined by the user-provided function <code>floglik</code>.
</p>
</td></tr>
<tr><td><code id="logMPL_+3A_mle">mle</code></td>
<td>

<p>A numerical vector, containing the maximum likelihood estimate of the entire model parameter. 	
</p>
</td></tr>  
<tr><td><code id="logMPL_+3A_floglik">floglik</code></td>
<td>

<p>A function which returns the log likelihood function at a given parameter value. 
In particular, for a certain parameter value contained in a numerical vector <code>theta</code>,
a call <code>floglik(theta, data)</code> should return a scalar numerical value, the log likelihood
function at <code>theta</code>. Note that the parameter of interest should be a subset of the coordinates
of <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="logMPL_+3A_fscore">fscore</code></td>
<td>

<p>An optional function which returns the score function at a given parameter value. It must return a numerical
vector of the same length of <code>mle</code>. For a certain parameter value contained in a numerical vector <code>theta</code>,
a call <code>fscore(theta, data)</code> should return the gradient of the log likelihood function at <code>theta</code>. Default 
is <code>NULL</code>, implying that numerical differentiation will be employed.
</p>
</td></tr>
<tr><td><code id="logMPL_+3A_indpsi">indpsi</code></td>
<td>

<p>A vector of integers in the range <code>1:length(theta)</code> containing the indexes of the parameter of interest, so
that the parameter of interest will be given by <code>theta[indpsi]</code>. 
</p>
</td></tr>
<tr><td><code id="logMPL_+3A_datagen">datagen</code></td>
<td>

<p>A function which simulates a data set. A call  <code>datagen(theta, data)</code> will generate a copy of the <code>data</code> list, 
with the values of the response variable replaced by a set of values simulated from the parametric statistical model assumed 
for the response variable. 
</p>
</td></tr>
<tr><td><code id="logMPL_+3A_r">R</code></td>
<td>

<p>The number of Monte Carlo replicates used for computing the modified profile likelihood. A positive integer, default 
is <code>500</code>.
</p>
</td></tr>
<tr><td><code id="logMPL_+3A_seed">seed</code></td>
<td>

<p>Optional positive integer, the random seed for the Monte Carlo computation. Default is <code>NULL</code>.
</p>
</td></tr>  
<tr><td><code id="logMPL_+3A_minus">minus</code></td>
<td>

<p>Logical. Should the modified profile likelihood be multiplied by -1? This may be useful for usage with 
optimizers.  Default is <code>FALSE</code>. 
</p>
</td></tr>   
<tr><td><code id="logMPL_+3A_onestep">onestep</code></td>
<td>

<p>Logical. If set to <code>TRUE</code> the constrained estimate of the nuisance parameter is replaced by a one-step approximation around the 
maximum likelihood estimate. Default is <code>FALSE</code>. 
</p>
</td></tr>      
<tr><td><code id="logMPL_+3A_jhat">jhat</code></td>
<td>

<p>A squared matrix with dimension equal to <code>length(mle)</code> containing the observed information matrix evaluated at <code>mle</code>.
It is employed only when <code>onestep=TRUE</code>. Default is <code>NULL</code>. 
</p>
</td></tr>    
<tr><td><code id="logMPL_+3A_trace">trace</code></td>
<td>

<p>Logical. When set to <code>TRUE</code> will cause the printing of the MPL value, which can be useful to monitor 
optimization. Default is <code>FALSE</code>.
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>The function  implements the Modified Profile Likelihood employing the approximation to sample space
derivatives proposed in Skovgaard (1996). The function 
is designed to be used with external functions, such as optimizers and evaluators over a grid of points.  
</p>


<h3>Value</h3>

<p>A scalar value, minus the modified profile likelihood at <code>psival</code>.
</p>


<h3>References</h3>

<p>Severini, T.A. (2000). Likelihood Methods in Statistics. Oxford University Press.
</p>
<p>Skovgaard, I.M. (1996) An explicit large-deviation approximation to one-parameter tests. 
<em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Approximating the conditional likelihood for logistic regression
# Let us define the various functions	
# Log likelihood for logistic regression
loglik.logit&lt;- function(theta, data) 
{
  y &lt;- data$y
  den &lt;- data$den
  X &lt;- data$X
  eta &lt;- X %*% theta
  p &lt;- plogis(eta)
  l &lt;- sum(y * log(p) + (den - y) * log(1-p))
  return(l)
}
# Score function
grad.logit&lt;- function(theta, data) 
{
  y &lt;- data$y
  den &lt;- data$den
  X &lt;- data$X
  eta &lt;- X %*% theta
  p &lt;- plogis(eta)
  out &lt;- t(y - p * den) %*% X
  return(drop(out))
}
# Data generator
gendat.logit&lt;- function(theta, data)
{
  X &lt;- data$X
  eta &lt;- X %*% theta
  p &lt;- plogis(eta)
  out &lt;- data
  out$y &lt;- rbinom(length(data$y), size = data$den, prob = p)
  return(out) 
}		
# Famous crying babies data
data(babies)	
mod.glm &lt;- glm(formula = cbind(r1, r2) ~ day + lull - 1, family = binomial, 
               data = babies)
data.obj &lt;- list(y = babies$r1, den = babies$r1 + babies$r2, 
                 X = model.matrix(mod.glm))	
# Numerical optimization of profile and modified profile log likelihoods
max.prof &lt;- nlminb(0, logPL, data=data.obj, thetainit=coef(mod.glm), 
                  floglik=loglik.logit, fscore=grad.logit, indpsi=19, minus=TRUE, trace=FALSE)
max.mpl &lt;- nlminb(0, logMPL, data=data.obj, mle=coef(mod.glm), 
                  floglik=loglik.logit, fscore=grad.logit, datagen=gendat.logit,
                  indpsi=19, R=50, seed=2020, minus=TRUE, trace=FALSE)
c(max.prof$par, max.mpl$par)                 
# We can plot the profile likelihood and the modified profile likelihood
# R=50 suffices for the modified profile likelihood as the model is a full exp. family
psi.vals &lt;- seq(-0.3, 3.7, l=20)
obj.prof &lt;- sapply(psi.vals, logPL, data=data.obj, thetainit=coef(mod.glm), 
                floglik=loglik.logit, fscore=grad.logit, indpsi=19, trace=FALSE)
obj.mpl &lt;- sapply(psi.vals, logMPL, data=data.obj, mle=coef(mod.glm), 
                floglik=loglik.logit, fscore=grad.logit, datagen=gendat.logit,
                indpsi=19, trace=FALSE, R=50, seed=2020)
par(pch="s")
plot(psi.vals, obj.prof - max(obj.prof), type="l", xlab=expression(psi), 
     ylab="log likelihood", lwd=2, las=1)
lines(psi.vals, obj.mpl - max(obj.mpl), col="red", lwd=2)
legend("topright", col=c(1, 2), lty=1, lwd=2, legend=c("Profile","MPL"), bty="n")
  
</code></pre>

<hr>
<h2 id='logPL'>
Profile likelihood computation
</h2><span id='topic+logPL'></span>

<h3>Description</h3>

<p>This function evaluates the profile likelihood for a subset of the model parameter. 
The result is optionally returned with a minus sign, so the function can be used directly as input 
to a general-purpose optimizer.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logPL(psival, data, thetainit, floglik, fscore=NULL, indpsi, minus=FALSE, onestep=FALSE,
      jhat=NULL, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logPL_+3A_psival">psival</code></td>
<td>

<p>A numerical vector containing the value of the parameter of interest.
</p>
</td></tr>  
<tr><td><code id="logPL_+3A_data">data</code></td>
<td>

<p>The data as a list. All the elements required to compute the likelihood function 
at a given parameter value should be included in this list. The required format of such list 
will be determined by the user-provided function <code>floglik</code>.
</p>
</td></tr>
<tr><td><code id="logPL_+3A_thetainit">thetainit</code></td>
<td>

<p>A numerical vector with the size of the entire model parameter, that will be used as starting 
point in the constrained optimization performed to obtain the maximum likelihood estimate under 
the null. The specific meaning of <code>thetainit</code> is determined by the specification of
<code>floglik</code>.  
</p>
</td></tr>     
<tr><td><code id="logPL_+3A_floglik">floglik</code></td>
<td>

<p>A function which returns the log likelihood function at a given parameter value. 
In particular, for a certain parameter value contained in a numerical vector <code>theta</code>,
a call <code>floglik(theta, data)</code> should return a scalar numerical value, the log likelihood
function at <code>theta</code>. Note that the parameter of interest should be a subset of the coordinates
of <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="logPL_+3A_fscore">fscore</code></td>
<td>

<p>An optional function which returns the score function at a given parameter value. It must return a numerical
vector of the same length as <code>thetainit</code>. For a certain parameter value contained in a numerical 
vector <code>theta</code>, a call <code>fscore(theta, data)</code> should return the gradient of the log likelihood function 
at <code>theta</code>. Default is <code>NULL</code>, implying that numerical differentiation will be employed.
</p>
</td></tr>
<tr><td><code id="logPL_+3A_indpsi">indpsi</code></td>
<td>

<p>A vector of integers in the range <code>1:length(theta)</code> containing the indexes of the parameter of interest, so
that the parameter of interest will be given by <code>theta[indpsi]</code>. 
</p>
</td></tr>
<tr><td><code id="logPL_+3A_minus">minus</code></td>
<td>

<p>Logical. Should the profile likelihood be multiplied by -1? This may be useful for usage with optimizers. 
Default is <code>FALSE</code>. 
</p>
</td></tr> 
<tr><td><code id="logPL_+3A_onestep">onestep</code></td>
<td>

<p>Logical. If set to <code>TRUE</code> the constrained estimate of the nuisance parameter is replaced by a one-step approximation around the 
maximum likelihood estimate. Default is <code>FALSE</code>. 
</p>
</td></tr>      
<tr><td><code id="logPL_+3A_jhat">jhat</code></td>
<td>

<p>A squared matrix with dimension equal to <code>length(mle)</code> containing the observed information matrix evaluated at <code>mle</code>.
It is employed only when <code>onestep=TRUE</code>. Default is <code>NULL</code>. 
</p>
</td></tr>        
<tr><td><code id="logPL_+3A_trace">trace</code></td>
<td>

<p>Logical. When set to <code>TRUE</code> will cause the printing of the MPL value, which can be useful to monitor 
optimization. Default is <code>FALSE</code>.
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>This function is designed to be used with external functions, such as optimizers and evaluators over a grid of points. 
</p>


<h3>Value</h3>

<p>A scalar value, minus the profile likelihood at <code>psival</code>.
</p>


<h3>References</h3>

<p>Severini, T.A. (2000). Likelihood Methods in Statistics. Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A negative binomial example, taken from Venables and Ripley (2002, MASS4 book)
library(MASS)
# The quine data are analysed in Section 7.4
data(quine)
# We fit a model with just the main effects
quine.nb1 &lt;- glm.nb(Days ~ Eth + Sex + Age + Lrn, data = quine) 
# The data list includes the design matrix and the response vector
quinedata&lt;-list(X=model.matrix(quine.nb1), y=quine$Days)      
# Let us define the various functions
# Log likelihood, log link
logLikNbin &lt;- function(theta,data) 
{
  y &lt;- data$y
  X &lt;- data$X
  eta &lt;- X %*% theta[1:ncol(X)] 
  mu &lt;- exp(eta)
  alpha &lt;- theta[ncol(X)+1]
  l &lt;- sum(lgamma(y + alpha) + y * log(mu) - (alpha + y) * log(alpha + mu) 
            - lgamma(alpha) + alpha * log(alpha))
  return(l)
}


# Score function
gradLikNbin &lt;- function(theta,data) 
{
  y &lt;- data$y
  X &lt;- data$X
  eta &lt;- X %*% theta[1:ncol(X)] 
  mu &lt;- exp(eta)
  alpha &lt;- theta[ncol(X)+1]
  g &lt;-rep(0,ncol(X)+1)
  g[1:ncol(X)] &lt;- t(y - (alpha+y)*mu / (alpha+mu)) %*% X
  g[ncol(X)+1] &lt;- sum(digamma( y + alpha) - log(alpha + mu) - (alpha + y) / (alpha + mu) 
                  - digamma(alpha) + 1 + log(alpha))
  return(g)
}
# Data generator
genDataNbin&lt;- function(theta,data)
{
  out &lt;- data
  X &lt;- data$X
  eta&lt;- X %*% theta[1:ncol(X)] 
  mu &lt;- exp(eta)
  out$y &lt;- rnegbin(length(data$y), mu=mu, theta=theta[ncol(X)+1])
  return(out)
}		
# First we refine the maximum likelihood estimates
mleFull &lt;- optim( c(coef(quine.nb1),quine.nb1$theta), logLikNbin, gr=gradLikNbin,
           method="BFGS", data=quinedata, control=list(fnscale=-1), hessian=TRUE) 
 # Then we can plot the profile likelihood
list.psi &lt;- seq(0.90, 1.70, l=30)
list.prof &lt;- sapply(list.psi, logPL, data=quinedata, thetainit=mleFull$par, floglik=logLikNbin, 
                    fscore=gradLikNbin, indpsi=8, trace=FALSE) 
plot(list.psi, list.prof-max(list.prof), type="l", xlab=expression(psi), ylab="Log likelihood")
</code></pre>

<hr>
<h2 id='rstar'>
Inference on a scalar function of interest by the r* statistic
</h2><span id='topic+rstar'></span>

<h3>Description</h3>

<p>This function evaluates the  r* statistic for testing of a scalar function of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstar(data, thetainit, floglik, fscore=NULL, fpsi, psival, datagen, R=1000, seed=NULL, 
      trace=TRUE, ronly=FALSE,  psidesc=NULL, constr.opt="solnp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstar_+3A_data">data</code></td>
<td>

<p>The data as a list. All the elements required to compute the log likelihood function 
at a given parameter value should be included in this list.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_thetainit">thetainit</code></td>
<td>

<p>A numerical vector containing the initial value for the parameter of the model. It will be used 
as starting point in the numerical optimization of the log likelihood function.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_floglik">floglik</code></td>
<td>

<p>A function which returns the log likelihood function at a given parameter value. 
In particular, for a certain parameter value contained in a numerical vector <code>theta</code>,
a call <code>floglik(theta, data)</code> should return a scalar numerical value, the log likelihood
function at <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_fscore">fscore</code></td>
<td>

<p>An optional function which returns the score function at a given parameter value. It must return a numerical
vector of the same length of <code>thetainit</code>. For a certain parameter value contained in a numerical vector <code>theta</code>,
a call <code>fscore(theta, data)</code> should return the gradient of the log likelihood function at <code>theta</code>. Default 
is <code>NULL</code>, implying that numerical differentiation will be employed.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_fpsi">fpsi</code></td>
<td>

<p>A function which specifies the parameter of interest. A call <code>fpsi(theta)</code> should return a scalar value. 
</p>
</td></tr>
<tr><td><code id="rstar_+3A_psival">psival</code></td>
<td>

<p>A numerical scalar value containing the value of the parameter of interest under testing.
</p>
</td></tr>  
<tr><td><code id="rstar_+3A_datagen">datagen</code></td>
<td>

<p>A function which simulates a data set. A call <code>datagen(theta, data)</code> will generate a copy of the <code>data</code> list, with the  
values of the response variable replaced by a set of values simulated from the parametric statistical model assumed for the response 	
variable.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_r">R</code></td>
<td>

<p>The number of Monte Carlo replicates used for computing the r* statistic. A positive integer, default is <code>1000</code>.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_seed">seed</code></td>
<td>

<p>Optional positive integer, the random seed for the Monte Carlo computation. Default is <code>NULL</code>.
</p>
</td></tr>  
<tr><td><code id="rstar_+3A_trace">trace</code></td>
<td>

<p>Logical. When set to <code>TRUE</code> will cause some information on the computation to be printed. Default is <code>FALSE</code>.
</p>
</td></tr>   
<tr><td><code id="rstar_+3A_ronly">ronly</code></td>
<td>

<p>Logical. If set to <code>TRUE</code> the computation of the r* statistic will be skipped, and only the value of the 
signed  likelihood ratio test statistic r will be returned by the procedure, without any Monte Carlo computation. 
Default is <code>FALSE</code>.
</p>
</td></tr>          
<tr><td><code id="rstar_+3A_psidesc">psidesc</code></td>
<td>

<p>An optional character string describing the nature of the parameter of interest. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="rstar_+3A_constr.opt">constr.opt</code></td>
<td>
  
<p>Constrained optimizer used for maximizing the log likelihood function under the null hypothesis. Possible
values are   <code>"solnp"</code> or <code>"alabama"</code>, with the former employing  the <code>solnp</code> function from
package <code>Rsolnp</code> and the latter the <code>constrOptim.nl</code> from the package <code>alabama</code>. Defauls is 
<code>"solnp"</code>.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function computes the r* statistic proposed by Skovgaard (1996) for accurate 
computation of the asymptotic distribution of the signed likelihood ratio test for
a scalar function of interest. 
</p>
<p>The function requires the user to provide three functions defining the log likelihood function,
the scalar parametric function of interest, and a function for generating
a data set from the assumed statistical model. A further function returning the gradient of the 
log likelihood is not required, but if provided it will speed up the computation. 
</p>
<p>When <code>ronly = TRUE</code> the function returns the value of the signed likelihood ratio test
statistic r only. 
</p>
<p>The function handles also one-parameter models.
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>"rstar"</code>, containing the following components:
</p>
<table>
<tr><td><code>r</code></td>
<td>

<p>The observed value the signed likelihodo ratio test statistic r for testing <code>fpsi(theta)=psival</code>. 
</p>
</td></tr>
<tr><td><code>NP</code>, <code>INF</code></td>
<td>

<p>The Nuisance Parameter adjustment (NP) and the Information adjustment (INF) from the decomposition of the r*-r adjustment. The former is not computed for one-parameter models. Neither one is computed when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>rs</code></td>
<td>

<p>The observed value of the r* statistic.  Not computed when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>theta.hat</code></td>
<td>

<p>The maximum likelihood estimate of the parameter theta, the argument of the <code>floglik</code>, <code>fscore</code>, <code>datagen</code> and 
<code>fpsi</code> functions.
</p>
</td></tr>
<tr><td><code>info.hat</code></td>
<td>

<p>The observed information matrix evaluated at <code>theta.hat</code>. Not computed when <code>ronly = TRUE</code>.
</p>
</td></tr> 
<tr><td><code>se.theta.hat</code></td>
<td>

<p>The estimated standard error of <code>theta.hat</code>. Not computed when <code>ronly = TRUE</code>.  
</p>
</td></tr>
<tr><td><code>psi.hat</code></td>
<td>

<p>The parameter of interest evaluated at <code>theta.hat</code>. 
</p>
</td></tr>
<tr><td><code>se.psi.hat</code></td>
<td>

<p>The estimated standard error for the parameter of interest. Not computed when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>theta.hyp</code></td>
<td>

<p>The constrained estimate of the parameter, under the null hypothesis <code>fpsi(theta)=psival</code>. 
</p>
</td></tr>
<tr><td><code>psi.hyp</code></td>
<td>

<p>The value under testing, equal to <code>psival</code>.
</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>

<p>Random seed used for Monte Carlo trials. Not returned when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>psidesc</code></td>
<td>

<p>A character string describing the nature of the parameter of interest. 
</p>
</td></tr>
<tr><td><code>R</code></td>
<td>

<p>Number of Monte Carlo replicates used for computing the r* statistic. Not returned when <code>ronly = TRUE</code>.
</p>
</td></tr>   
</table>
<p>There are <code>print</code> and <code>summary</code> methods for this class. 
</p>


<h3>References</h3>

<p>The method implemented in this function was proposed in
</p>
<p>Skovgaard, I.M. (1996) An explicit large-deviation approximation to one-parameter tests. 
<em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>
<p>For a general review
</p>
<p>Severini, T.A. (2000). Likelihood Methods in Statistics. Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstar.ci">rstar.ci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Autoregressive model of order 1
# We use the lh data from MASS
library(MASS)
data(lh)
dat.y &lt;- list(y=as.numeric(lh))
# First let us define the function returning the log likelihood function
# We employ careful parameterizations for the correlation and variance to
# avoid numerical problems
likAR1 &lt;- function(theta, data)
{ 
  y &lt;- data$y
  mu &lt;- theta[1]
  phi &lt;- theta[2] ### phi is log(sigma) 
  sigma2 &lt;- exp(phi*2)
  z &lt;- theta[3]   ### z is Fisher'z transform for rho
  rho &lt;- (exp(2*z)-1) / (1 + exp(2*z))
  n &lt;- length(y)
  Gamma1 &lt;- diag(1+c(0,rep(rho^2,n-2),0))
  for(i in 2:n)
    Gamma1[i,i-1]&lt;- Gamma1[i-1,i] &lt;- -rho 
  lik &lt;- -n/2 * log(sigma2) + 0.5 * log(1-rho^2) -1/(2*sigma2) * 
        mahalanobis(y, rep(mu,n), Gamma1, inverted = TRUE)
  return(lik)
}
# We need a function for simulating a data set
genDataAR1 &lt;- function(theta, data)  
{
  out &lt;- data
  mu &lt;- theta[1]
  sigma &lt;- exp(theta[2])
  z &lt;- theta[3]
  rho &lt;- (exp(2*z)-1) / (1 + exp(2*z))
  n &lt;- length(data$y)
  y &lt;- rep(0,n)
  y[1] &lt;- rnorm(1,mu,s=sigma*sqrt(1/(1-rho^2)))
  for(i in 2:n)
    y[i] &lt;- mu + rho * (y[i-1]-mu) + rnorm(1) * sigma 
  out$y &lt;- y 
  return(out)
}
# For inference on the mean parameter we need a function returning the first component of theta
psifcn.mu &lt;- function(theta) theta[1]
# Now we can call the function
rs.mu &lt;- rstar(dat.y, c(0,0,0), likAR1, fpsi=psifcn.mu, psival=2, datagen=genDataAR1, R=1000, 
               trace=TRUE, psidesc="mean parameter")
summary(rs.mu)
</code></pre>

<hr>
<h2 id='rstar.ci'>
Confidence intervals on a scalar function of interest by the r* statistic
</h2><span id='topic+rstar.ci'></span>

<h3>Description</h3>

<p>This function obtains confidence intervals for a scalar function of interest, based on the r* statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	rstar.ci(data, thetainit, floglik, fscore=NULL, fpsi, datagen, R=1000, seed=NULL, 
	         ronly=FALSE, psidesc=NULL, constr.opt="solnp", lower=NULL, upper=NULL, 
	         control=list(...), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstar.ci_+3A_data">data</code></td>
<td>

<p>The data as a list. All the elements required to compute the likelihood function 
at a given parameter value should be included in this list.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_thetainit">thetainit</code></td>
<td>

<p>A numerical vector containing the initial value for the parameter of the model. It will be used 
as starting point in the numerical optimization of the likelihood function.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_floglik">floglik</code></td>
<td>

<p>A function which returns the log likelihood function at a given parameter value. 
In particular, for a certain parameter value contained in a numerical vector <code>theta</code>,
a call <code>floglik(theta, data)</code> should return a scalar numerical value, the log likelihood
function at <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_fscore">fscore</code></td>
<td>

<p>An optional function which returns the score function at a given parameter value. It must return a 
numerical vector of the same length of <code>thetainit</code>. For a certain parameter value contained in a 
numerical vector <code>theta</code>, a call <code>fscore(theta, data)</code> should return the gradient of the 
log likelihood function at <code>theta</code>. Default is <code>NULL</code>, implying that numerical differentiation 
will be employed.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_fpsi">fpsi</code></td>
<td>

<p>A function which specifies the parameter of interest. A call <code>fpsi(theta)</code> should return a scalar 
value. 
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_datagen">datagen</code></td>
<td>

<p>A function which simulates a data set. A call <code>datagen(theta, data)</code> will generate a copy of the 
<code>data</code> list, with the values of the response variable replaced by a set of values simulated from  
the parametric statistical model assumed for the response variable.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_r">R</code></td>
<td>

<p>The number of Monte Carlo replicates used for computing the r* statistic. A positive integer, default is 
<code>1000</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_seed">seed</code></td>
<td>

<p>Optional positive integer, the random seed for the Monte Carlo computation. Default is <code>NULL</code>.
</p>
</td></tr>  
<tr><td><code id="rstar.ci_+3A_ronly">ronly</code></td>
<td>

<p>Logical. If set to <code>TRUE</code> the computation of the r* statistic will be skipped, and only the value 
of the signed likelihood ratio test statistic r will be returned by the procedure, without any Monte 
Carlo computation. Default is <code>FALSE</code>.
</p>
</td></tr>          
<tr><td><code id="rstar.ci_+3A_psidesc">psidesc</code></td>
<td>

<p>An optional character string describing the nature of the parameter of interest. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_constr.opt">constr.opt</code></td>
<td>
  
<p>Constrained optimizer used for maximizing the log likelihood function under the null hypothesis. Possible
values are   <code>"solnp"</code> or <code>"alabama"</code>, with the former employing  the <code>solnp</code> function from
package <code>Rsolnp</code> and the latter the <code>constrOptim.nl</code> from the package <code>alabama</code>. Defauls is 
<code>"solnp"</code>. 
</p>
</td></tr>    
<tr><td><code id="rstar.ci_+3A_lower">lower</code>, <code id="rstar.ci_+3A_upper">upper</code></td>
<td>

<p>Optional numeric values defining the lower/upper limit of a grid of points for the parameter of interest, 
where the r* statistic will be evaluated. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci_+3A_control">control</code></td>
<td>
   
<p>A list of parameters for controlling the computation of confidence intervals. See <a href="#topic+rstar.ci.control">rstar.ci.control</a>.
</p>
</td></tr>   
<tr><td><code id="rstar.ci_+3A_...">...</code></td>
<td>

<p>Arguments to be used to form the default <code>control</code> argument if it is not supplied directly.
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>The function obtains 90%, 95% and 99%  two-sided confidence intervals for the scalar function of 
interest based on the r* statistic.
</p>
<p>The function requires the user to provide three functions defining the log likelihood function,
the scalar parametric function of interest, and a function for generating
a data set from the assumed statistical model. A further function returning the gradient of the 
log likelihood is not required, but if provided it will speed up the computation. 
</p>
<p>When <code>ronly = TRUE</code> the function literally returns the value of the signed likelihood ratio test
statistic r only. The function handles also one-parameter models.
</p>
<p>The function provides two different strategies to obtain the various confidence intervals. The default
strategy, invoked by leaving either <code>lower</code> or <code>upper</code> to <code>NULL</code>, starts from the MLE 
and moves away in a stepwise fashion, until the r* statistic crosses the standard normal quantiles 
corresponding to the 99% two-sided confidence interval. It is crucial to start the search a bit away 
from the MLE, where the r* is singular, and this is regulated by the <code>away</code> argument of the 
<a href="#topic+rstar.ci.control">rstar.ci.control</a> function. The first strategy may fail to cross the target normal quantiles when 
the profile likelihood has an upper asymptote. For such cases, and for any other instances when the 
output of the default strategy is deemed not satisfactory, it is possible to specify the 
range of a grid of values where the r* statistic will be evaluated. The <code>lower</code> and <code>upper</code> 
argument specify the lower and upper limit of such grid, whereas the number of points is controlled by the 
<code>npoints</code> of the <a href="#topic+rstar.ci.control">rstar.ci.control</a> function.  
</p>


<h3>Value</h3>

<p>The returned value is an object of class <code>"rstarci"</code>, containing the following components:
</p>
<table>
<tr><td><code>psivals</code></td>
<td>

<p>A list of values for the parameter of interest for which the r and r* statistics have been evaluated.
</p>
</td></tr>
<tr><td><code>rvals</code></td>
<td>

<p>A numerical list containing the values of the r statistic evaluated at each element of <code>psivals</code>.
</p>
</td></tr>
<tr><td><code>NPvals</code>, <code>INFvals</code></td>
<td>

<p>Numerical lists containing the values of the Nuisance Parameter adjustment (NP) and the Information 
adjustment (INF) from the decomposition of the r*-r adjustment, for each of the <code>psivals</code> values.  
Not computed when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>rsvals</code></td>
<td>

<p>The observed value of the r* statistic at each element of <code>psivals</code>.  Not computed when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>CIr</code></td>
<td>

<p>A 3 x 2 matrix containing the 90%, 95% and 99% confidence intervals for the parameter of interest (first, 
second and third row respectively) based on the first-order r statistic.
</p>
</td></tr>
<tr><td><code>CIrs</code></td>
<td>

<p>A 3 x 2 matrix containing the 90%, 95% and 99% confidence intervals for the parameter of interest (first, 
second and third row respectively) absed on the r* statistic. Not computed when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>

<p>Random seed used for Monte Carlo replicates used for computing the r* statistic. Not returned when <code>ronly = TRUE</code>.
</p>
</td></tr>
<tr><td><code>psidesc</code></td>
<td>

<p>A character string describing the nature of the parameter of interest. 
</p>
</td></tr>
<tr><td><code>R</code></td>
<td>

<p>Number of Monte Carlo replicates used for computing the r* statistic.  Not returned when <code>ronly = TRUE</code>.
</p>
</td></tr>
</table>
<p>There are <code>print</code>, <code>summary</code> and <code>plot</code> methods for this class. 
</p>


<h3>References</h3>

<p>The method implemented in this function was proposed in
</p>
<p>Skovgaard, I.M. (1996). An explicit large-deviation approximation to one-parameter tests. 
<em>Bernoulli</em>, <b>2</b>, 145&ndash;165.
</p>
<p>For a general review
</p>
<p>Severini, T.A. (2000). Likelihood Methods in Statistics. Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstar">rstar</a>, <a href="#topic+rstar.ci.control">rstar.ci.control</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A negative binomial example, taken from Venables and Ripley (2002, MASS4 book)
library(MASS)
# The quine data are analysed in Section 7.4
data(quine)
# We fit a model with just the main effects
quine.nb1 &lt;- glm.nb(Days ~ Eth + Sex + Age + Lrn, data = quine) 
# The data list includes the design matrix and the response vector
quinedata &lt;- list(X=model.matrix(quine.nb1), y=quine$Days)      
# Let us define the required functions
# Log likelihood, log link
logLikNbin &lt;- function(theta,data) 
{
  y &lt;- data$y
  X &lt;- data$X
  eta &lt;- X %*% theta[1:ncol(X)] 
  mu &lt;- exp(eta)
  alpha &lt;- theta[ncol(X)+1]
  l &lt;- sum(lgamma(y + alpha) + y * log(mu) - (alpha + y) * log(alpha + mu) 
            - lgamma(alpha) + alpha * log(alpha))
  return(l)
}
# Score function
gradLikNbin &lt;- function(theta,data) 
{
  y &lt;- data$y
  X &lt;- data$X
  eta &lt;- X %*% theta[1:ncol(X)] 
  mu &lt;- exp(eta)
  alpha &lt;- theta[ncol(X)+1]
  g &lt;-rep(0,ncol(X)+1)
  g[1:ncol(X)] &lt;- t(y - (alpha+y)*mu / (alpha+mu)) %*% X
  g[ncol(X)+1] &lt;- sum(digamma( y + alpha) - log(alpha + mu) - (alpha + y) / (alpha + mu) 
                  - digamma(alpha) + 1 + log(alpha))
  return(g)
}
# Data generator
genDataNbin &lt;- function(theta,data)
{
  out &lt;- data
  X &lt;- data$X
  eta&lt;- X %*% theta[1:ncol(X)] 
  mu &lt;- exp(eta)
  out$y &lt;- rnegbin(length(data$y), mu=mu, theta=theta[ncol(X)+1])
  return(out)
}	
# Confidence intervals for the coefficient of EthN 
## Not run: 
obj &lt;- rstar.ci(quinedata, thetainit=c(coef(quine.nb1),quine.nb1$theta),  floglik=logLikNbin, 
                datagen=genDataNbin, fscore=gradLikNbin, fpsi=function(theta) theta[2], R=1000, 
                psidesc="Coefficient of EthN")
print(obj)
summary(obj)
plot(obj)
# Confidence intervals for the overdispersion parameter
obj &lt;- rstar.ci(quinedata, thetainit=c(coef(quine.nb1),quine.nb1$theta),  floglik=logLikNbin, 
                datagen=genDataNbin, fscore=gradLikNbin, fpsi=function(theta) theta[8], R=1000,
                psidesc="Overdispersion parameter")
summary(obj)
plot(obj)

## End(Not run)
</code></pre>

<hr>
<h2 id='rstar.ci.control'>
Auxiliary function for controlling computation of r*-based confidence intervals	
</h2><span id='topic+rstar.ci.control'></span>

<h3>Description</h3>

<p>Auxiliary function for <code>rstar.ci</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstar.ci.control(npoints=10, away=0.3, stepsizefac=3, maxstep=50, trace=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstar.ci.control_+3A_npoints">npoints</code></td>
<td>

<p>Integer giving the number of points at which the r* and r statistics will be evaluated away from the MLE 
in each direction when both <code>lower</code> and <code>upper</code> are not null. When either <code>lower</code> or <code>upper</code> 
are <code>NULL</code>, such value is only roughly proportional to the number of evaluation points. Default is <code>10</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci.control_+3A_away">away</code></td>
<td>

<p>Positive value indicating how far from the MLE the computation of the r* and r statistics will be started, expressed
in units of standard error of the scalar function of interest. Default is <code>0.3</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci.control_+3A_stepsizefac">stepsizefac</code></td>
<td>

<p>Positive value used to determine the stepsize of the confidence interval algorithm when either <code>lower</code> or 
<code>upper</code> are null. In particular, the stepsize is given by <code>stepsizefac/npoints</code> times the 
standard error of the scalar function of interest. Default is <code>3</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci.control_+3A_maxstep">maxstep</code></td>
<td>

<p>Integer giving the maximum number of steps that will be taken for crossing the normal quantiles for a 99
confidence interval for the r* statistic. Default is <code>50</code>.
</p>
</td></tr>
<tr><td><code id="rstar.ci.control_+3A_trace">trace</code></td>
<td>

<p>Logical indicating if output should be produced during the computation. Default is <code>TRUE</code>.
</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>A list with components named as the arguments. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstar.ci">rstar.ci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A variation on example(rstar.ci):
## Not run: 
obj &lt;- rstar.ci(quinedata, thetainit=c(coef(quine.nb1),quine.nb1$theta),  floglik=logLikNbin, 
                datagen=genDataNbin, fscore=gradLikNbin, fpsi=function(theta) theta[2], R=1000, 
                psidesc="Coefficient of EthN", npoints=5, away=0.1)
plot(obj)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
