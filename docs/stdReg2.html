<!DOCTYPE html><html lang="en"><head><title>Help for package stdReg2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stdReg2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stdReg2-package'><p>stdReg2: Regression Standardization for Causal Inference</p></a></li>
<li><a href='#parfrailty'><p>Fits shared frailty gamma-Weibull models</p></a></li>
<li><a href='#plot.std_glm'><p>Plots regression standardization fit</p></a></li>
<li><a href='#plot.std_surv'><p>Plots regression standardization fit</p></a></li>
<li><a href='#print.std_surv'><p>Prints summary of regression standardization fit</p></a></li>
<li><a href='#print.summary.parfrailty'><p>Print method for parametric frailty fits</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sandwich'><p>Compute the sandwich variance components from a model fit</p></a></li>
<li><a href='#standardize'><p>Get standardized estimates using the g-formula with a custom model</p></a></li>
<li><a href='#standardize_coxph'><p>Regression standardization in Cox proportional hazards models</p></a></li>
<li><a href='#standardize_gee'><p>Regression standardization in conditional generalized estimating equations</p></a></li>
<li><a href='#standardize_glm'><p>Get regression standardized estimates from a glm</p></a></li>
<li><a href='#standardize_glm_dr'><p>Get regression standardized doubly-robust estimates from a glm</p></a></li>
<li><a href='#standardize_level'><p>Get standardized estimates using the g-formula with and separate models for each exposure level in the data</p></a></li>
<li><a href='#standardize_parfrailty'><p>Regression standardization in shared frailty gamma-Weibull models</p></a></li>
<li><a href='#summary.parfrailty'><p>Summarizes parfrailty fit</p></a></li>
<li><a href='#tidy.std_custom'><p>Provide tidy output from a std_custom object for use in downstream computations</p></a></li>
<li><a href='#tidy.std_glm'><p>Provide tidy output from a std_glm object for use in downstream computations</p></a></li>
<li><a href='#tidy.std_surv'><p>Provide tidy output from a std_surv object for use in downstream computations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Standardization for Causal Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sachsmc.github.io/stdReg2/">https://sachsmc.github.io/stdReg2/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sachsmc/stdReg2/issues/">https://github.com/sachsmc/stdReg2/issues/</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains more modern tools for causal inference using regression 
      standardization. Four general classes of models are implemented; generalized 
      linear models, conditional generalized estimating equation models, 
      Cox proportional hazards models, and shared frailty gamma-Weibull models. 
      Methodological details are described in Sjölander, A. (2016) &lt;<a href="https://doi.org/10.1007%2Fs10654-016-0157-3">doi:10.1007/s10654-016-0157-3</a>&gt;. 
      Also includes functionality for doubly robust estimation for generalized linear models 
      in some special cases, and the ability to implement custom models. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, drgee, generics, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>causaldata, AF, knitr, nnet, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-28 10:51:06 UTC; micsac</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael C Sachs [aut, cre],
  Arvid Sjölander [aut],
  Erin E Gabriel [aut],
  Johan Sebastian Ohlendorff [aut],
  Adam Brand [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael C Sachs &lt;sachsmc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-28 11:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='stdReg2-package'>stdReg2: Regression Standardization for Causal Inference</h2><span id='topic+stdReg2'></span><span id='topic+stdReg2-package'></span>

<h3>Description</h3>

<p>Contains more modern tools for causal inference using regression standardization. Four general classes of models are implemented; generalized linear models, conditional generalized estimating equation models, Cox proportional hazards models, and shared frailty gamma-Weibull models. Methodological details are described in Sjölander, A. (2016) <a href="https://doi.org/10.1007/s10654-016-0157-3">doi:10.1007/s10654-016-0157-3</a>. Also includes functionality for doubly robust estimation for generalized linear models in some special cases, and the ability to implement custom models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael C Sachs <a href="mailto:sachsmc@gmail.com">sachsmc@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Arvid Sjölander
</p>
</li>
<li><p> Erin E Gabriel
</p>
</li>
<li><p> Johan Sebastian Ohlendorff
</p>
</li>
<li><p> Adam Brand
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sachsmc.github.io/stdReg2/">https://sachsmc.github.io/stdReg2/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/sachsmc/stdReg2/issues/">https://github.com/sachsmc/stdReg2/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='parfrailty'>Fits shared frailty gamma-Weibull models</h2><span id='topic+parfrailty'></span>

<h3>Description</h3>

<p><code>parfrailty</code> fits shared frailty gamma-Weibull models. It is
specifically designed to work with the function <code>standardize_parfrailty</code>, which
performs regression standardization in shared frailty gamma-Weibull models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parfrailty(formula, data, clusterid, init)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parfrailty_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code>formula</code>&quot;, in the same format as
accepted by the <a href="survival.html#topic+coxph">coxph</a> function.</p>
</td></tr>
<tr><td><code id="parfrailty_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="parfrailty_+3A_clusterid">clusterid</code></td>
<td>
<p>a string containing the name of a cluster identification
variable.</p>
</td></tr>
<tr><td><code id="parfrailty_+3A_init">init</code></td>
<td>
<p>an optional vector of initial values for the model parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parfrailty</code> fits the shared frailty gamma-Weibull model
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t_{ij}|C_{ij})=\lambda(t_{ij};\alpha,\eta)U_i\exp\{h(C_{ij};\beta)\},</code>
</p>

<p>where <code class="reqn">t_{ij}</code> and <code class="reqn">C_{ij}</code> are the survival time and covariate
vector for subject <code class="reqn">j</code> in cluster <code class="reqn">i</code>, respectively.
<code class="reqn">\lambda(t;\alpha,\eta)</code> is the Weibull baseline hazard function
</p>
<p style="text-align: center;"><code class="reqn">\eta t^{\eta-1}\alpha^{-\eta},</code>
</p>
<p> where <code class="reqn">\eta</code> is the shape
parameter and <code class="reqn">\alpha</code> is the scale parameter. <code class="reqn">U_i</code> is the
unobserved frailty term for cluster <code class="reqn">i</code>, which is assumed to have a
gamma distribution with scale = 1/shape = <code class="reqn">\phi</code>. <code class="reqn">h(X;\beta)</code> is
the regression function as specified by the <code>formula</code> argument,
parameterized by a vector <code class="reqn">\beta</code>. The ML estimates
<code class="reqn">\{\log(\hat{\alpha}),\log(\hat{\eta}),\log(\hat{\phi}),\hat{\beta}\}</code> are
obtained by maximizing the marginal (over <code class="reqn">U</code>) likelihood.
</p>


<h3>Value</h3>

<p>An object of class <code>"parfrailty"</code> which is a list containing:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p> the Maximum Likelihood (ML) estimates <code class="reqn">\{\log(\hat{\alpha}),\log(\hat{\eta}),
\log(\hat{\phi}),\hat{\beta}\}</code>. </p>
</td></tr> <tr><td><code>vcov</code></td>
<td>
<p> the variance-covariance
vector of the ML estimates. </p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p> a matrix containing the
cluster-specific contributions to the ML score equations.  </p>
</td></tr>
</table>


<h3>Note</h3>

<p>If left truncation is present, it is assumed that it is strong left
truncation.  This means that even if the truncation time may be
subject-specific, the whole cluster is unobserved if at least one subject in
the cluster dies before his/her truncation time. If all subjects in the
cluster survive beyond their subject-specific truncation times, then the
whole cluster is observed (Van den Berg and Drepper, 2016).
</p>


<h3>Author(s)</h3>

<p>Arvid Sjölander and Elisabeth Dahlqwist.
</p>


<h3>References</h3>

<p>Dahlqwist E., Pawitan Y., Sjölander A. (2019). Regression
standardization and attributable fraction estimation with between-within
frailty models for clustered survival data. <em>Statistical Methods in
Medical Research</em> <b>28</b>(2), 462-485.
</p>
<p>Van den Berg G.J., Drepper B. (2016). Inference for shared frailty survival
models with left-truncated data. <em>Econometric Reviews</em>, 35(6),
1075-1098.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(survival)

# simulate data
set.seed(5)
n &lt;- 200
m &lt;- 3
alpha &lt;- 1.5
eta &lt;- 1
phi &lt;- 0.5
beta &lt;- 1
id &lt;- rep(1:n, each = m)
U &lt;- rep(rgamma(n, shape = 1 / phi, scale = phi), each = m)
X &lt;- rnorm(n * m)
# reparameterize scale as in rweibull function
weibull.scale &lt;- alpha / (U * exp(beta * X))^(1 / eta)
T &lt;- rweibull(n * m, shape = eta, scale = weibull.scale)

# right censoring
C &lt;- runif(n * m, 0, 10)
D &lt;- as.numeric(T &lt; C)
T &lt;- pmin(T, C)

# strong left-truncation
L &lt;- runif(n * m, 0, 2)
incl &lt;- T &gt; L
incl &lt;- ave(x = incl, id, FUN = sum) == m
dd &lt;- data.frame(L, T, D, X, id)
dd &lt;- dd[incl, ]

fit &lt;- parfrailty(formula = Surv(L, T, D) ~ X, data = dd, clusterid = "id")
print(fit)
</code></pre>

<hr>
<h2 id='plot.std_glm'>Plots regression standardization fit</h2><span id='topic+plot.std_glm'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"std_glm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'std_glm'
plot(
  x,
  plot_ci = TRUE,
  ci_type = "plain",
  ci_level = 0.95,
  transform = NULL,
  contrast = NULL,
  reference = NULL,
  summary_fun = "summary_std_glm",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.std_glm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"std_glm"</code>.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_plot_ci">plot_ci</code></td>
<td>
<p>if <code>TRUE</code>, add the confidence intervals to the plot.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_transform">transform</code></td>
<td>
<p>If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively. If left unspecified,
<code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_contrast">contrast</code></td>
<td>
<p>If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument.
If not <code>NULL</code>, a doubly robust estimator of the standardized estimator is used.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_reference">reference</code></td>
<td>
<p>If <code>contrast</code> is specified, the desired reference level.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_summary_fun">summary_fun</code></td>
<td>
<p>For internal use only. Do not change.</p>
</td></tr>
<tr><td><code id="plot.std_glm_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Creates a plot as a side effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see standardize_glm

</code></pre>

<hr>
<h2 id='plot.std_surv'>Plots regression standardization fit</h2><span id='topic+plot.std_surv'></span>

<h3>Description</h3>

<p>This is a <code>plot</code> method for class <code>"std_surv"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'std_surv'
plot(
  x,
  plot_ci = TRUE,
  ci_type = "plain",
  ci_level = 0.95,
  transform = NULL,
  contrast = NULL,
  reference = NULL,
  legendpos = "bottomleft",
  summary_fun = "summary_std_coxph",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.std_surv_+3A_x">x</code></td>
<td>
<p>An object of class <code>"std_surv"</code>.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_plot_ci">plot_ci</code></td>
<td>
<p>if <code>TRUE</code>, add the confidence intervals to the plot.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals. Either &quot;plain&quot;, which
gives untransformed intervals, or &quot;log&quot;, which gives log-transformed intervals.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_transform">transform</code></td>
<td>
<p>If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively. If left unspecified,
<code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_contrast">contrast</code></td>
<td>
<p>If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument.
If not <code>NULL</code>, a doubly robust estimator of the standardized estimator is used.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_reference">reference</code></td>
<td>
<p>If <code>contrast</code> is specified, the desired reference level.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_legendpos">legendpos</code></td>
<td>
<p>position of the legend; see <a href="graphics.html#topic+legend">legend</a>.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_summary_fun">summary_fun</code></td>
<td>
<p>For internal use only. Do not change.</p>
</td></tr>
<tr><td><code id="plot.std_surv_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Creates a plot as a side effect
</p>

<hr>
<h2 id='print.std_surv'>Prints summary of regression standardization fit</h2><span id='topic+print.std_surv'></span><span id='topic+print.std_glm'></span><span id='topic+print.std_custom'></span>

<h3>Description</h3>

<p>Prints summary of regression standardization fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'std_surv'
print(x, ...)

## S3 method for class 'std_glm'
print(x, ...)

## S3 method for class 'std_custom'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.std_surv_+3A_x">x</code></td>
<td>
<p>an object of class <code>"std_glm"</code>, <code>"std_surv"</code> or <code>"std_custom"</code>.</p>
</td></tr>
<tr><td><code id="print.std_surv_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object being printed, invisibly.
</p>

<hr>
<h2 id='print.summary.parfrailty'>Print method for parametric frailty fits</h2><span id='topic+print.summary.parfrailty'></span>

<h3>Description</h3>

<p>Print method for parametric frailty fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.parfrailty'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.parfrailty_+3A_x">x</code></td>
<td>
<p>An object of class &quot;parfrailty&quot;</p>
</td></tr>
<tr><td><code id="print.summary.parfrailty_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print</p>
</td></tr>
<tr><td><code id="print.summary.parfrailty_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object being printed, invisibly
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sandwich'>Compute the sandwich variance components from a model fit</h2><span id='topic+sandwich'></span>

<h3>Description</h3>

<p>Compute the sandwich variance components from a model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sandwich(fit, data, weights, t, fit.detail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sandwich_+3A_fit">fit</code></td>
<td>
<p>A fitted model object of class <a href="stats.html#topic+glm">glm</a>, <a href="survival.html#topic+coxph">coxph</a>, ah, or <a href="survival.html#topic+survfit">survfit</a></p>
</td></tr>
<tr><td><code id="sandwich_+3A_data">data</code></td>
<td>
<p>The data used to fit the model</p>
</td></tr>
<tr><td><code id="sandwich_+3A_weights">weights</code></td>
<td>
<p>Optional weights</p>
</td></tr>
<tr><td><code id="sandwich_+3A_t">t</code></td>
<td>
<p>Optional fixed time point for survival objects</p>
</td></tr>
<tr><td><code id="sandwich_+3A_fit.detail">fit.detail</code></td>
<td>
<p>For Cox models, the result of running <a href="survival.html#topic+coxph.detail">coxph.detail</a> on the model fit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the Fisher information matrix (I) and the Score equations (U)
</p>

<hr>
<h2 id='standardize'>Get standardized estimates using the g-formula with a custom model</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Get standardized estimates using the g-formula with a custom model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(
  fitter,
  arguments,
  predict_fun,
  data,
  values,
  B = NULL,
  ci_level = 0.95,
  contrasts = NULL,
  reference = NULL,
  seed = NULL,
  times = NULL,
  transforms = NULL,
  progressbar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_+3A_fitter">fitter</code></td>
<td>
<p>The function to call to fit the data.</p>
</td></tr>
<tr><td><code id="standardize_+3A_arguments">arguments</code></td>
<td>
<p>The arguments to be used in the fitter function as a <code>list</code>.</p>
</td></tr>
<tr><td><code id="standardize_+3A_predict_fun">predict_fun</code></td>
<td>
<p>The function used to predict the means/probabilities
for a new data set on the response level. For survival data,
this should be a matrix where each column is the time, and each
row the data.</p>
</td></tr>
<tr><td><code id="standardize_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_+3A_b">B</code></td>
<td>
<p>Number of nonparametric bootstrap resamples. Default is <code>NULL</code> (no bootstrap).</p>
</td></tr>
<tr><td><code id="standardize_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_+3A_seed">seed</code></td>
<td>
<p>The seed to use with the nonparametric bootstrap.</p>
</td></tr>
<tr><td><code id="standardize_+3A_times">times</code></td>
<td>
<p>For use with survival data. Set to <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="standardize_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
<tr><td><code id="standardize_+3A_progressbar">progressbar</code></td>
<td>
<p>Logical, if TRUE will print bootstrapping progress to the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome, the exposure, and a
vector of covariates, respectively.
<code>standardize</code> uses a
model to estimate the standardized
mean <code class="reqn">\theta(x)=E\{E(Y|X=x,Z)\}</code>,
where <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>,
and the outer expectation is over the marginal distribution of <code class="reqn">Z</code>.
With survival data, <code class="reqn">Y=I(T &gt; t)</code>,
and a vector of different time points <code>times</code> (<code class="reqn">t</code>) can be given,
where <code class="reqn">T</code> is the uncensored survival time.
</p>


<h3>Value</h3>

<p>An object of class <code>std_custom</code>. Obtain numeric results using <a href="#topic+tidy.std_custom">tidy.std_custom</a>.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>B</dt><dd><p>The number of bootstrap replicates</p>
</dd>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>estimates_boot</dt><dd><p>A list of estimates, one for each bootstrap resample</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>times</dt><dd><p>The vector of times at which the calculation is done, if relevant</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>B</dt><dd><p>The number of bootstrap replicates</p>
</dd>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>estimates_boot</dt><dd><p>A list of estimates, one for each bootstrap resample</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>times</dt><dd><p>The vector of times at which the calculation is done, if relevant</p>
</dd>
</dl>

</dd></dl>



<h3>References</h3>

<p>Rothman K.J., Greenland S., Lash T.L. (2008).
<em>Modern Epidemiology</em>, 3rd edition.
Lippincott, Williams &amp; Wilkins.
</p>
<p>Sjölander A. (2016).
Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjölander A. (2016).
Estimation of causal effect measures with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(6)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean = Z)
Y &lt;- rbinom(n, 1, prob = (1 + exp(X + Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
prob_predict.glm &lt;- function(...) predict.glm(..., type = "response")

x &lt;- standardize(
  fitter = "glm",
  arguments = list(
    formula = Y ~ X * Z,
    family = "binomial"
  ),
  predict_fun = prob_predict.glm,
  data = dd,
  values = list(X = seq(-1, 1, 0.1)),
  B = 100,
  reference = 0,
  contrasts = "difference"
)
x

require(survival)
prob_predict.coxph &lt;- function(object, newdata, times) {
  fit.detail &lt;- suppressWarnings(basehaz(object))
  cum.haz &lt;- fit.detail$hazard[sapply(times, function(x) max(which(fit.detail$time &lt;= x)))]
  predX &lt;- predict(object = object, newdata = newdata, type = "risk")
  res &lt;- matrix(NA, ncol = length(times), nrow = length(predX))
  for (ti in seq_len(length(times))) {
    res[, ti] &lt;- exp(-predX * cum.haz[ti])
  }
  res
}
set.seed(68)
n &lt;- 500
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean = Z)
T &lt;- rexp(n, rate = exp(X + Z + X * Z)) # survival time
C &lt;- rexp(n, rate = exp(X + Z + X * Z)) # censoring time
U &lt;- pmin(T, C) # time at risk
D &lt;- as.numeric(T &lt; C) # event indicator
dd &lt;- data.frame(Z, X, U, D)
x &lt;- standardize(
fitter = "coxph",
  arguments = list(
    formula = Surv(U, D) ~ X + Z + X * Z,
    method = "breslow",
    x = TRUE,
    y = TRUE
  ),
  predict_fun = prob_predict.coxph,
  data = dd,
  times = 1:5,
  values = list(X = c(-1, 0, 1)),
  B = 100,
  reference = 0,
  contrasts = "difference"
)
x
</code></pre>

<hr>
<h2 id='standardize_coxph'>Regression standardization in Cox proportional hazards models</h2><span id='topic+standardize_coxph'></span>

<h3>Description</h3>

<p><code>standardize_coxph</code> performs regression standardization in Cox proportional
hazards models at specified values of the exposure over the sample
covariate distribution. Let <code class="reqn">T</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the survival
outcome, the exposure, and a vector of covariates, respectively.
<code>standardize_coxph</code> fits a Cox proportional hazards model and the Breslow estimator
of the baseline hazard in order to estimate the
standardized survival function <code class="reqn">\theta(t,x)=E\{S(t|X=x,Z)\}</code> when <code>measure = "survival"</code> or the standardized restricted mean survival up to time t <code class="reqn">\theta(t, x) = E\{\int_0^t S(u|X = x, Z) du\}</code> when <code>measure = "rmean"</code>, where
<code class="reqn">t</code> is a specific value of <code class="reqn">T</code>, <code class="reqn">x</code> is a specific value of
<code class="reqn">X</code>, and the expectation is over the marginal distribution of <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_coxph(
  formula,
  data,
  values,
  times,
  measure = c("survival", "rmean"),
  clusterid,
  ci_level = 0.95,
  ci_type = "plain",
  contrasts = NULL,
  family = "gaussian",
  reference = NULL,
  transforms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_coxph_+3A_formula">formula</code></td>
<td>
<p>The formula which is used to fit the model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_times">times</code></td>
<td>
<p>A vector containing the specific values of <code class="reqn">T</code> at
which to estimate the standardized survival function.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_measure">measure</code></td>
<td>
<p>Either &quot;survival&quot; to estimate the survival function at times
or &quot;rmean&quot; for the restricted mean survival up to the largest of times.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_clusterid">clusterid</code></td>
<td>
<p>An optional string containing the name of a cluster identification variable
when data are clustered.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals.
Either &quot;plain&quot;, which gives untransformed intervals, or &quot;log&quot;, which gives
log-transformed intervals.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_family">family</code></td>
<td>
<p>The family argument which is used to fit the glm model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_coxph_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>standardize_coxph</code> fits the Cox proportional hazards model
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t|X,Z)=\lambda_0(t)\exp\{h(X,Z;\beta)\}.</code>
</p>

<p>Breslow's estimator of the cumulative baseline hazard
<code class="reqn">\Lambda_0(t)=\int_0^t\lambda_0(u)du</code> is used together with the partial
likelihood estimate of <code class="reqn">\beta</code> to obtain estimates of the survival
function <code class="reqn">S(t|X=x,Z)</code> if <code>measure = "survival"</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t|X=x,Z)=\exp[-\hat{\Lambda}_0(t)\exp\{h(X=x,Z;\hat{\beta})\}].</code>
</p>

<p>For each <code class="reqn">t</code> in the <code>t</code> argument and for each <code class="reqn">x</code> in the
<code>x</code> argument, these estimates are averaged across all subjects (i.e.
all observed values of <code class="reqn">Z</code>) to produce estimates
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(t,x)=\sum_{i=1}^n \hat{S}(t|X=x,Z_i)/n,</code>
</p>
<p> where <code class="reqn">Z_i</code>
is the value of <code class="reqn">Z</code> for subject <code class="reqn">i</code>, <code class="reqn">i=1,...,n</code>.  The variance
for <code class="reqn">\hat{\theta}(t,x)</code> is obtained by the sandwich formula.
</p>
<p>If <code>measure = "rmean"</code>, then <code class="reqn">\Lambda_0(t)=\int_0^t\lambda_0(u)du</code>
is used together with the partial
likelihood estimate of <code class="reqn">\beta</code> to obtain estimates of the restricted mean survival
up to time t: <code class="reqn">\int_0^t S(u|X=x,Z) du</code> for each element of <code>times</code>. The estimation
and inference is done using the method described in Chen and Tsiatis 2001.
Currently, we can only estimate the difference in RMST for a single binary
exposure. Two separate Cox models are fit for each level of the exposure,
which is expected to be coded as 0/1.
</p>


<h3>Value</h3>

<p>An object of class <code>std_surv</code>. Obtain numeric results by using <a href="#topic+tidy.std_surv">tidy.std_surv</a>.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>call</dt><dd><p>The function call</p>
</dd>
<dt>input</dt><dd><p>A list with components used in the estimation</p>
</dd>
<dt>measure</dt><dd><p>Either &quot;survival&quot; or &quot;rmean&quot;</p>
</dd>
<dt>est</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>vcov</dt><dd><p>Estimated covariance matrix of counterfactual means for each time</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>times</dt><dd><p>The vector of times used in the calculation</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_type</dt><dd><p>Confidence interval type</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>call</dt><dd><p>The function call</p>
</dd>
<dt>input</dt><dd><p>A list with components used in the estimation</p>
</dd>
<dt>measure</dt><dd><p>Either &quot;survival&quot; or &quot;rmean&quot;</p>
</dd>
<dt>est</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>vcov</dt><dd><p>Estimated covariance matrix of counterfactual means for each time</p>
</dd>
</dl>

</dd></dl>



<h3>Note</h3>

<p>Standardized survival functions are sometimes referred to as (direct)
adjusted survival functions in the literature.
</p>
<p><code>standardize_coxph/standardize_parfrailty</code> does not currently handle time-varying exposures or
covariates.
</p>
<p><code>standardize_coxph/standardize_parfrailty</code> internally loops over all values in the <code>t</code> argument.
Therefore, the function will usually be considerably faster if
<code>length(t)</code> is small.
</p>
<p>The variance calculation performed by <code>standardize_coxph</code> does not condition on
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this
matters, note that
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(t,x)\}=E[var\{\hat{\theta}(t,x)|\bar{Z}\}]+var[E\{\hat{\theta}(t,x)|\bar{Z}\}].</code>
</p>

<p>The usual parameter <code class="reqn">\beta</code> in a Cox proportional hazards model does not
depend on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is independent
of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that
the term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance
decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However,
<code class="reqn">\theta(t,x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the
sample distribution for <code class="reqn">Z</code>, and thus the term
<code class="reqn">var[E\{\hat{\theta}(t,x)|\bar{Z}\}]</code> is not 0, unless one conditions on
<code class="reqn">\bar{Z}</code>. The variance calculation by Gail and Byar (1986) ignores this
term, and thus effectively conditions on <code class="reqn">\bar{Z}</code>.
</p>


<h3>Author(s)</h3>

<p>Arvid Sjölander, Adam Brand, Michael Sachs
</p>


<h3>References</h3>

<p>Chang I.M., Gelman G., Pagano M. (1982). Corrected group prognostic curves
and summary statistics. <em>Journal of Chronic Diseases</em> <b>35</b>,
669-674.
</p>
<p>Gail M.H. and Byar D.P. (1986). Variance calculations for direct adjusted
survival curves, with applications to testing for no treatment effect.
<em>Biometrical Journal</em> <b>28</b>(5), 587-599.
</p>
<p>Makuch R.W. (1982). Adjusted survival curve estimation using covariates.
<em>Journal of Chronic Diseases</em> <b>35</b>, 437-443.
</p>
<p>Sjölander A. (2016). Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjölander A. (2018). Estimation of causal effect measures with the R-package
stdReg. <em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>
<p>Chen, P. Y., Tsiatis, A. A. (2001). Causal inference on the difference of the restricted mean lifetime between two groups. <em>Biometrics</em>, <b>57</b>(4), 1030-1038.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(survival)
set.seed(7)
n &lt;- 300
Z &lt;- rnorm(n)
Zbin &lt;- rbinom(n, 1, .3)
X &lt;- rnorm(n, mean = Z)
T &lt;- rexp(n, rate = exp(X + Z + X * Z)) # survival time
C &lt;- rexp(n, rate = exp(X + Z + X * Z)) # censoring time
fact &lt;- factor(sample(letters[1:3], n, replace = TRUE))
U &lt;- pmin(T, C) # time at risk
D &lt;- as.numeric(T &lt; C) # event indicator
dd &lt;- data.frame(Z, Zbin, X, U, D, fact)
fit.std.surv &lt;- standardize_coxph(
  formula = Surv(U, D) ~ X + Z + X * Z,
  data = dd,
  values = list(X = seq(-1, 1, 0.5)),
  times = 1:5
)
print(fit.std.surv)
plot(fit.std.surv)
tidy(fit.std.surv)

fit.std &lt;- standardize_coxph(
  formula = Surv(U, D) ~ X + Zbin + X * Zbin + fact,
  data = dd,
  values = list(Zbin = 0:1),
  times = 1.5,
  measure = "rmean",
  contrast = "difference",
  reference = 0
)
print(fit.std)
tidy(fit.std)

</code></pre>

<hr>
<h2 id='standardize_gee'>Regression standardization in conditional generalized estimating equations</h2><span id='topic+standardize_gee'></span>

<h3>Description</h3>

<p><code>standardize_gee</code> performs regression standardization in linear and log-linear
fixed effects models, at specified values of the exposure, over the sample
covariate distribution. Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome,
the exposure, and a vector of covariates, respectively. It is assumed that
data are clustered with a cluster indicator <code class="reqn">i</code>. <code>standardize_gee</code> uses
fitted fixed effects model, with cluster-specific intercept <code class="reqn">a_i</code> (see
<code>details</code>), to estimate the standardized mean
<code class="reqn">\theta(x)=E\{E(Y|i,X=x,Z)\}</code>, where <code class="reqn">x</code> is a specific value of
<code class="reqn">X</code>, and the outer expectation is over the marginal distribution of
<code class="reqn">(a_i,Z)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_gee(
  formula,
  link = "identity",
  data,
  values,
  clusterid,
  case_control = FALSE,
  ci_level = 0.95,
  ci_type = "plain",
  contrasts = NULL,
  family = "gaussian",
  reference = NULL,
  transforms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_gee_+3A_formula">formula</code></td>
<td>
<p>A formula to be used with <code>"gee"</code> in the <span class="pkg">drgee</span> package.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_link">link</code></td>
<td>
<p>The link function to be used with <code>"gee"</code>.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_clusterid">clusterid</code></td>
<td>
<p>An optional string containing the name of a cluster identification variable
when data are clustered.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_case_control">case_control</code></td>
<td>
<p>Whether the data comes from a case-control study.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals.
Either &quot;plain&quot;, which gives untransformed intervals, or &quot;log&quot;, which gives
log-transformed intervals.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_family">family</code></td>
<td>
<p>The family argument which is used to fit the glm model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_gee_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>standardize_gee</code> assumes that a fixed effects model
</p>
<p style="text-align: center;"><code class="reqn">\eta\{E(Y|i,X,Z)\}=a_i+h(X,Z;\beta)</code>
</p>
<p> has been fitted. The link
function <code class="reqn">\eta</code> is assumed to be the identity link or the log link. The
conditional generalized estimating equation (CGEE) estimate of <code class="reqn">\beta</code>
is used to obtain estimates of the cluster-specific means:
</p>
<p style="text-align: center;"><code class="reqn">\hat{a}_i=\sum_{j=1}^{n_i}r_{ij}/n_i,</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">r_{ij}=Y_{ij}-h(X_{ij},Z_{ij};\hat{\beta})</code>
</p>
<p> if <code class="reqn">\eta</code> is the
identity link, and </p>
<p style="text-align: center;"><code class="reqn">r_{ij}=Y_{ij}\exp\{-h(X_{ij},Z_{ij};\hat{\beta})\}</code>
</p>

<p>if <code class="reqn">\eta</code> is the log link, and <code class="reqn">(X_{ij},Z_{ij})</code> is the value of
<code class="reqn">(X,Z)</code> for subject <code class="reqn">j</code> in cluster <code class="reqn">i</code>, <code class="reqn">j=1,...,n_i</code>,
<code class="reqn">i=1,...,n</code>. The CGEE estimate of <code class="reqn">\beta</code> and the estimate of
<code class="reqn">a_i</code> are used to estimate the mean <code class="reqn">E(Y|i,X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{E}(Y|i,X=x,Z)=\eta^{-1}\{\hat{a}_i+h(X=x,Z;\hat{\beta})\}.</code>
</p>
<p> For
each <code class="reqn">x</code> in the <code>x</code> argument, these estimates are averaged across
all subjects (i.e. all observed values of <code class="reqn">Z</code> and all estimated values
of <code class="reqn">a_i</code>) to produce estimates </p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(x)=\sum_{i=1}^n
\sum_{j=1}^{n_i} \hat{E}(Y|i,X=x,Z_i)/N,</code>
</p>
<p> where <code class="reqn">N=\sum_{i=1}^n n_i</code>.
The variance for <code class="reqn">\hat{\theta}(x)</code> is obtained by the sandwich formula.
</p>


<h3>Value</h3>

<p>An object of class <code>std_glm</code>. Obtain numeric results in a data frame with the <a href="#topic+tidy.std_glm">tidy.std_glm</a> function.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>covariance</dt><dd><p>Estimated covariance matrix of counterfactual means</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>fit_exposure</dt><dd><p>The estimated exposure model</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_type</dt><dd><p>Confidence interval type</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>covariance</dt><dd><p>Estimated covariance matrix of counterfactual means</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>fit_exposure</dt><dd><p>The estimated exposure model</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
</dl>

</dd></dl>



<h3>Note</h3>

<p>The variance calculation performed by <code>standardize_gee</code> does not condition
on the observed covariates <code class="reqn">\bar{Z}=(Z_{11},...,Z_{nn_i})</code>. To see how
this matters, note that
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(x)\}=E[var\{\hat{\theta}(x)|\bar{Z}\}]+var[E\{\hat{\theta}(x)|\bar{Z}\}].</code>
</p>

<p>The usual parameter <code class="reqn">\beta</code> in a generalized linear model does not
depend on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is independent
of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that
the term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance
decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However,
<code class="reqn">\theta(x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the sample
distribution for <code class="reqn">Z</code>, and thus the term
<code class="reqn">var[E\{\hat{\theta}(x)|\bar{Z}\}]</code> is not 0, unless one conditions on
<code class="reqn">\bar{Z}</code>.
</p>


<h3>Author(s)</h3>

<p>Arvid Sjölander.
</p>


<h3>References</h3>

<p>Goetgeluk S. and Vansteelandt S. (2008). Conditional generalized
estimating equations for the analysis of clustered and longitudinal data.
<em>Biometrics</em> <b>64</b>(3), 772-780.
</p>
<p>Martin R.S. (2017). Estimation of average marginal effects in multiplicative
unobserved effects panel models. <em>Economics Letters</em> <b>160</b>, 16-19.
</p>
<p>Sjölander A. (2019). Estimation of marginal causal effects in the presence
of confounding by cluster. <em>Biostatistics</em> doi:
10.1093/biostatistics/kxz054
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(drgee)

set.seed(4)
n &lt;- 300
ni &lt;- 2
id &lt;- rep(1:n, each = ni)
ai &lt;- rep(rnorm(n), each = ni)
Z &lt;- rnorm(n * ni)
X &lt;- rnorm(n * ni, mean = ai + Z)
Y &lt;- rnorm(n * ni, mean = ai + X + Z + 0.1 * X^2)
dd &lt;- data.frame(id, Z, X, Y)
fit.std &lt;- standardize_gee(
  formula = Y ~ X + Z + I(X^2),
  link = "identity",
  data = dd,
  values = list(X = seq(-3, 3, 0.5)),
  clusterid = "id"
)
print(fit.std)
plot(fit.std)

</code></pre>

<hr>
<h2 id='standardize_glm'>Get regression standardized estimates from a glm</h2><span id='topic+standardize_glm'></span>

<h3>Description</h3>

<p>Get regression standardized estimates from a glm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_glm(
  formula,
  data,
  values,
  clusterid,
  matched_density_cases,
  matched_density_controls,
  matching_variable,
  p_population,
  case_control = FALSE,
  ci_level = 0.95,
  ci_type = "plain",
  contrasts = NULL,
  family = "gaussian",
  reference = NULL,
  transforms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_glm_+3A_formula">formula</code></td>
<td>
<p>The formula which is used to fit the model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_clusterid">clusterid</code></td>
<td>
<p>An optional string containing the name of a cluster identification variable
when data are clustered.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_matched_density_cases">matched_density_cases</code></td>
<td>
<p>A function of the matching variable.
The probability (or density) of the matched variable among the cases.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_matched_density_controls">matched_density_controls</code></td>
<td>
<p>A function of the matching variable.
The probability (or density) of the matched variable among the controls.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_matching_variable">matching_variable</code></td>
<td>
<p>The matching variable extracted from the data set.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_p_population">p_population</code></td>
<td>
<p>Specifies the incidence in the population when <code>case_control=TRUE</code>.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_case_control">case_control</code></td>
<td>
<p>Whether the data comes from a case-control study.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals.
Either &quot;plain&quot;, which gives untransformed intervals, or &quot;log&quot;, which gives
log-transformed intervals.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_family">family</code></td>
<td>
<p>The family argument which is used to fit the glm model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_glm_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>standardize_glm</code> performs regression standardization
in generalized linear models,
at specified values of the exposure, over the sample covariate distribution.
Let <code class="reqn">Y</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the outcome, the exposure, and a
vector of covariates, respectively.
<code>standardize_glm</code> uses a fitted generalized linear
model to estimate the standardized
mean <code class="reqn">\theta(x)=E\{E(Y|X=x,Z)\}</code>,
where <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>,
and the outer expectation is over the marginal distribution of <code class="reqn">Z</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>std_glm</code>. Obtain numeric results in a data frame with the <a href="#topic+tidy.std_glm">tidy.std_glm</a> function.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>covariance</dt><dd><p>Estimated covariance matrix of counterfactual means</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>fit_exposure</dt><dd><p>The estimated exposure model</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_type</dt><dd><p>Confidence interval type</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>covariance</dt><dd><p>Estimated covariance matrix of counterfactual means</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>fit_exposure</dt><dd><p>The estimated exposure model</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
</dl>

</dd></dl>



<h3>References</h3>

<p>Rothman K.J., Greenland S., Lash T.L. (2008).
<em>Modern Epidemiology</em>, 3rd edition.
Lippincott, Williams &amp; Wilkins.
</p>
<p>Sjölander A. (2016).
Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjölander A. (2016).
Estimation of causal effect measures with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# basic example
# needs to correctly specify the outcome model and no unmeasered confounders
# (+ standard causal assunmptions)
set.seed(6)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- cut(rnorm(n, mean = Z), breaks = c(-Inf, 0, Inf), labels = c("low", "high"))
Y &lt;- rbinom(n, 1, prob = (1 + exp(as.numeric(X) + Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
x &lt;- standardize_glm(
  formula = Y ~ X * Z,
  family = "binomial",
  data = dd,
  values = list(X = c("low", "high")),
  contrasts = c("difference", "ratio"),
  reference = "low"
)
x
# different transformations of causal effects

# example from Sjölander (2016) with case-control data
# here the matching variable needs to be passed as an argument
singapore &lt;- AF::singapore
Mi &lt;- singapore$Age
m &lt;- mean(Mi)
s &lt;- sd(Mi)
d &lt;- 5
standardize_glm(
  formula = Oesophagealcancer ~ (Everhotbev + Age + Dial + Samsu + Cigs)^2,
  family = binomial, data = singapore,
  values = list(Everhotbev = 0:1), clusterid = "Set",
  case_control = TRUE,
  matched_density_cases = function(x) dnorm(x, m, s),
  matched_density_controls = function(x) dnorm(x, m - d, s),
  matching_variable = Mi,
  p_population = 19.3 / 100000
)

# multiple exposures
set.seed(7)
n &lt;- 100
Z &lt;- rnorm(n)
X1 &lt;- rnorm(n, mean = Z)
X2 &lt;- rnorm(n)
Y &lt;- rbinom(n, 1, prob = (1 + exp(X1 + X2 + Z))^(-1))
dd &lt;- data.frame(Z, X1, X2, Y)
x &lt;- standardize_glm(
  formula = Y ~ X1 + X2 + Z,
  family = "binomial",
  data = dd, values = list(X1 = 0:1, X2 = 0:1),
  contrasts = c("difference", "ratio"),
  reference = c(X1 = 0, X2 = 0)
)
x
tidy(x)

# continuous exposure
set.seed(2)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean = Z)
Y &lt;- rnorm(n, mean = X + Z + 0.1 * X^2)
dd &lt;- data.frame(Z, X, Y)
x &lt;- standardize_glm(
  formula = Y ~ X * Z,
  family = "gaussian",
  data = dd,
  values = list(X = seq(-1, 1, 0.1))
)

# plot standardized mean as a function of x
plot(x)
# plot standardized mean - standardized mean at x = 0 as a function of x
plot(x, contrast = "difference", reference = 0)

</code></pre>

<hr>
<h2 id='standardize_glm_dr'>Get regression standardized doubly-robust estimates from a glm</h2><span id='topic+standardize_glm_dr'></span>

<h3>Description</h3>

<p>Get regression standardized doubly-robust estimates from a glm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_glm_dr(
  formula_outcome,
  formula_exposure,
  data,
  values,
  ci_level = 0.95,
  ci_type = "plain",
  contrasts = NULL,
  family_outcome = "gaussian",
  family_exposure = "binomial",
  reference = NULL,
  transforms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_glm_dr_+3A_formula_outcome">formula_outcome</code></td>
<td>
<p>The formula which is used to fit the glm model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_formula_exposure">formula_exposure</code></td>
<td>
<p>The formula which is used to fit the glm model for the exposure.
If not <code>NULL</code>,
a doubly robust estimator of the standardized estimator is used.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals.
Either &quot;plain&quot;, which gives untransformed intervals, or &quot;log&quot;, which gives
log-transformed intervals.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_family_outcome">family_outcome</code></td>
<td>
<p>The family argument which is used to fit the glm model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_family_exposure">family_exposure</code></td>
<td>
<p>The family argument which is used to fit the glm model for the exposure.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_glm_dr_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>standardize_glm_dr</code> performs regression standardization
in generalized linear models, see e.g., documentation for <code>standardize_glm_dr</code>. Specifically,
this version uses a doubly robust estimator for standardization, meaning inference is valid
when either the outcome regression or the exposure model is correctly specified
and there is no unmeasured confounding.
</p>


<h3>Value</h3>

<p>An object of class <code>std_glm</code>. Obtain numeric results in a data frame with the <a href="#topic+tidy.std_glm">tidy.std_glm</a> function.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>covariance</dt><dd><p>Estimated covariance matrix of counterfactual means</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>fit_exposure</dt><dd><p>The estimated exposure model</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_type</dt><dd><p>Confidence interval type</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>covariance</dt><dd><p>Estimated covariance matrix of counterfactual means</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>fit_exposure</dt><dd><p>The estimated exposure model</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
</dl>

</dd></dl>



<h3>References</h3>

<p>Gabriel E.E., Sachs, M.C., Martinussen T., Waernbaum I.,
Goetghebeur E., Vansteelandt S., Sjölander A. (2024),
Inverse probability of treatment weighting with
generalized linear outcome models for doubly robust estimation.
<em>Statistics in Medicine</em>, <b>43</b>(3):534&ndash;547.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# doubly robust estimator
# needs to correctly specify either the outcome model or the exposure model
# for confounding
# NOTE: only works with binary exposures
data &lt;- AF::clslowbwt
x &lt;- standardize_glm_dr(
  formula_outcome = bwt ~ smoker * (race + age + lwt) + I(age^2) + I(lwt^2),
  formula_exposure = smoker ~ race * age * lwt + I(age^2) + I(lwt^2),
  family_outcome = "gaussian",
  family_exposure = "binomial",
  data = data,
  values = list(smoker = c(0, 1)), contrasts = "difference", reference = 0
)

set.seed(6)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- rbinom(n, 1, prob = (1 + exp(Z))^(-1))
Y &lt;- rbinom(n, 1, prob = (1 + exp(as.numeric(X) + Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
x &lt;- standardize_glm_dr(
  formula_outcome = Y ~ X * Z, formula_exposure = X ~ Z,
  family_outcome = "binomial",
  data = dd,
  values = list(X = 0:1), reference = 0,
  contrasts = c("difference"), transforms = c("odds")
)

</code></pre>

<hr>
<h2 id='standardize_level'>Get standardized estimates using the g-formula with and separate models for each exposure level in the data</h2><span id='topic+standardize_level'></span>

<h3>Description</h3>

<p>Get standardized estimates using the g-formula with and separate models for each exposure level in the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_level(
  fitter_list,
  arguments,
  predict_fun_list,
  data,
  values,
  B = NULL,
  ci_level = 0.95,
  contrasts = NULL,
  reference = NULL,
  seed = NULL,
  times = NULL,
  transforms = NULL,
  progressbar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_level_+3A_fitter_list">fitter_list</code></td>
<td>
<p>The function to call to fit the data (as a list).</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_arguments">arguments</code></td>
<td>
<p>The arguments to be used in the fitter function as a <code>list</code>.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_predict_fun_list">predict_fun_list</code></td>
<td>
<p>The function used to predict the means/probabilities
for a new data set on the response level. For survival data,
this should be a matrix where each column is the time, and each
row the data (as a list).</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_b">B</code></td>
<td>
<p>Number of nonparametric bootstrap resamples. Default is <code>NULL</code> (no bootstrap).</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_seed">seed</code></td>
<td>
<p>The seed to use with the nonparametric bootstrap.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_times">times</code></td>
<td>
<p>For use with survival data. Set to <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
<tr><td><code id="standardize_level_+3A_progressbar">progressbar</code></td>
<td>
<p>Logical, if TRUE will print bootstrapping progress to the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>standardize</code>. The difference is here that different models
can be fitted for each value of <code>x</code> in <code>values</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>std_custom</code>. Obtain numeric results using <a href="#topic+tidy.std_custom">tidy.std_custom</a>.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>B</dt><dd><p>The number of bootstrap replicates</p>
</dd>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>estimates_boot</dt><dd><p>A list of estimates, one for each bootstrap resample</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>times</dt><dd><p>The vector of times at which the calculation is done, if relevant</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>B</dt><dd><p>The number of bootstrap replicates</p>
</dd>
<dt>estimates</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>fit_outcome</dt><dd><p>The estimated regression model for the outcome</p>
</dd>
<dt>estimates_boot</dt><dd><p>A list of estimates, one for each bootstrap resample</p>
</dd>
<dt>exposure_names</dt><dd><p>A character vector of the exposure variable names</p>
</dd>
<dt>times</dt><dd><p>The vector of times at which the calculation is done, if relevant</p>
</dd>
</dl>

</dd></dl>



<h3>References</h3>

<p>Rothman K.J., Greenland S., Lash T.L. (2008).
<em>Modern Epidemiology</em>, 3rd edition.
Lippincott, Williams &amp; Wilkins.
</p>
<p>Sjölander A. (2016).
Regression standardization with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>31</b>(6), 563-574.
</p>
<p>Sjölander A. (2016).
Estimation of causal effect measures with the R-package stdReg.
<em>European Journal of Epidemiology</em> <b>33</b>(9), 847-858.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(survival)
prob_predict.coxph &lt;- function(object, newdata, times) {
  fit.detail &lt;- suppressWarnings(basehaz(object))
  cum.haz &lt;- fit.detail$hazard[sapply(times, function(x) max(which(fit.detail$time &lt;= x)))]
  predX &lt;- predict(object = object, newdata = newdata, type = "risk")
  res &lt;- matrix(NA, ncol = length(times), nrow = length(predX))
  for (ti in seq_len(length(times))) {
    res[, ti] &lt;- exp(-predX * cum.haz[ti])
  }
  res
}

set.seed(68)
n &lt;- 500
Z &lt;- rnorm(n)
X &lt;- rbinom(n, 1, prob = 0.5)
T &lt;- rexp(n, rate = exp(X + Z + X * Z)) # survival time
C &lt;- rexp(n, rate = exp(X + Z + X * Z)) # censoring time
U &lt;- pmin(T, C) # time at risk
D &lt;- as.numeric(T &lt; C) # event indicator
dd &lt;- data.frame(Z, X, U, D)
x &lt;- standardize_level(
  fitter_list = list("coxph", "coxph"),
  arguments = list(
    list(
      formula = Surv(U, D) ~ X + Z + X * Z,
      method = "breslow",
      x = TRUE,
      y = TRUE
    ),
    list(
      formula = Surv(U, D) ~ X,
      method = "breslow",
      x = TRUE,
      y = TRUE
    )
  ),
  predict_fun_list = list(prob_predict.coxph, prob_predict.coxph),
  data = dd,
  times = seq(1, 5, 0.1),
  values = list(X = c(0, 1)),
  B = 100,
  reference = 0,
  contrasts = "difference"
)
print(x)
</code></pre>

<hr>
<h2 id='standardize_parfrailty'>Regression standardization in shared frailty gamma-Weibull models</h2><span id='topic+standardize_parfrailty'></span>

<h3>Description</h3>

<p><code>standardize_parfrailty</code> performs regression standardization in shared frailty
gamma-Weibull models, at specified values of the exposure, over the sample
covariate distribution. Let <code class="reqn">T</code>, <code class="reqn">X</code>, and <code class="reqn">Z</code> be the survival
outcome, the exposure, and a vector of covariates, respectively.
<code>standardize_parfrailty</code> fits a parametric frailty model to
estimate the standardized survival function
<code class="reqn">\theta(t,x)=E\{S(t|X=x,Z)\}</code>, where <code class="reqn">t</code> is a specific value of
<code class="reqn">T</code>, <code class="reqn">x</code> is a specific value of <code class="reqn">X</code>, and the expectation is over
the marginal distribution of <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_parfrailty(
  formula,
  data,
  values,
  times,
  clusterid,
  ci_level = 0.95,
  ci_type = "plain",
  contrasts = NULL,
  family = "gaussian",
  reference = NULL,
  transforms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_parfrailty_+3A_formula">formula</code></td>
<td>
<p>The formula which is used to fit the model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_values">values</code></td>
<td>
<p>A named list or data.frame specifying the variables and values
at which marginal means of the outcome will be estimated.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_times">times</code></td>
<td>
<p>A vector containing the specific values of <code class="reqn">T</code> at
which to estimate the standardized survival function.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_clusterid">clusterid</code></td>
<td>
<p>An optional string containing the name of a cluster identification variable
when data are clustered.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_ci_level">ci_level</code></td>
<td>
<p>Coverage probability of confidence intervals.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_ci_type">ci_type</code></td>
<td>
<p>A string, indicating the type of confidence intervals.
Either &quot;plain&quot;, which gives untransformed intervals, or &quot;log&quot;, which gives
log-transformed intervals.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_contrasts">contrasts</code></td>
<td>
<p>A vector of contrasts in the following format:
If set to <code>"difference"</code> or <code>"ratio"</code>, then <code class="reqn">\psi(x)-\psi(x_0)</code>
or <code class="reqn">\psi(x) / \psi(x_0)</code> are constructed, where <code class="reqn">x_0</code> is a reference
level specified by the <code>reference</code> argument. Has to be <code>NULL</code>
if no references are specified.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_family">family</code></td>
<td>
<p>The family argument which is used to fit the glm model for the outcome.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_reference">reference</code></td>
<td>
<p>A vector of reference levels in the following format:
If <code>contrasts</code> is not <code>NULL</code>, the desired reference level(s). This
must be a vector or list the same length as <code>contrasts</code>, and if not named,
it is assumed that the order is as specified in contrasts.</p>
</td></tr>
<tr><td><code id="standardize_parfrailty_+3A_transforms">transforms</code></td>
<td>
<p>A vector of transforms in the following format:
If set to <code>"log"</code>, <code>"logit"</code>, or <code>"odds"</code>, the standardized
mean <code class="reqn">\theta(x)</code> is transformed into <code class="reqn">\psi(x)=\log\{\theta(x)\}</code>,
<code class="reqn">\psi(x)=\log[\theta(x)/\{1-\theta(x)\}]</code>, or
<code class="reqn">\psi(x)=\theta(x)/\{1-\theta(x)\}</code>, respectively.
If the vector is <code>NULL</code>, then <code class="reqn">\psi(x)=\theta(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>standardize_parfrailty</code> fits a shared frailty gamma-Weibull model
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t_{ij}|X_{ij},Z_{ij})=\lambda(t_{ij};\alpha,\eta)U_iexp\{h(X_{ij},Z_{ij};\beta)\}</code>
</p>

<p>, with parameterization as described in the help section for
<a href="#topic+parfrailty">parfrailty</a>. Integrating out the gamma frailty gives the survival
function
</p>
<p style="text-align: center;"><code class="reqn">S(t|X,Z)=[1+\phi\Lambda_0(t;\alpha,\eta)\exp\{h(X,Z;\beta)\}]^{-1/\phi},</code>
</p>

<p>where <code class="reqn">\Lambda_0(t;\alpha,\eta)</code> is the cumulative baseline hazard
</p>
<p style="text-align: center;"><code class="reqn">(t/\alpha)^{\eta}.</code>
</p>
<p> The ML estimates of <code class="reqn">(\alpha,\eta,\phi,\beta)</code>
are used to obtain estimates of the survival function <code class="reqn">S(t|X=x,Z)</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t|X=x,Z)=[1+\hat{\phi}\Lambda_0(t;\hat{\alpha},\hat{\eta})\exp\{h(X,Z;\hat{\beta})\}]^{-1/\hat{\phi}}.</code>
</p>

<p>For each <code class="reqn">t</code> in the <code>t</code> argument and for each <code class="reqn">x</code> in the
<code>x</code> argument, these estimates are averaged across all subjects (i.e.
all observed values of <code class="reqn">Z</code>) to produce estimates
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}(t,x)=\sum_{i=1}^n \hat{S}(t|X=x,Z_i)/n.</code>
</p>
<p> The variance for
<code class="reqn">\hat{\theta}(t,x)</code> is obtained by the sandwich formula.
</p>


<h3>Value</h3>

<p>An object of class <code>std_surv</code>. Obtain numeric results by using <a href="#topic+tidy.std_surv">tidy.std_surv</a>.
This is a list with the following components:
</p>

<dl>
<dt>res_contrast</dt><dd><p>An unnamed list with one element for each of the requested contrasts. Each element is itself a list with the elements:
</p>

<dl>
<dt>call</dt><dd><p>The function call</p>
</dd>
<dt>input</dt><dd><p>A list with components used in the estimation</p>
</dd>
<dt>measure</dt><dd><p>Either &quot;survival&quot; or &quot;rmean&quot;</p>
</dd>
<dt>est</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>vcov</dt><dd><p>Estimated covariance matrix of counterfactual means for each time</p>
</dd>
<dt>est_table</dt><dd><p>Data.frame of the estimates of the contrast with inference</p>
</dd>
<dt>times</dt><dd><p>The vector of times used in the calculation</p>
</dd>
<dt>transform</dt><dd><p>The transform argument used for this contrast</p>
</dd>
<dt>contrast</dt><dd><p>The requested contrast type</p>
</dd>
<dt>reference</dt><dd><p>The reference level of the exposure</p>
</dd>
<dt>ci_type</dt><dd><p>Confidence interval type</p>
</dd>
<dt>ci_level</dt><dd><p>Confidence interval level</p>
</dd>
</dl>
</dd>
<dt>res</dt><dd><p>A named list with the elements:
</p>

<dl>
<dt>call</dt><dd><p>The function call</p>
</dd>
<dt>input</dt><dd><p>A list with components used in the estimation</p>
</dd>
<dt>measure</dt><dd><p>Either &quot;survival&quot; or &quot;rmean&quot;</p>
</dd>
<dt>est</dt><dd><p>Estimated counterfactual means and standard errors for each exposure level</p>
</dd>
<dt>vcov</dt><dd><p>Estimated covariance matrix of counterfactual means for each time</p>
</dd>
</dl>

</dd></dl>



<h3>Note</h3>

<p>Standardized survival functions are sometimes referred to as (direct)
adjusted survival functions in the literature.
</p>
<p><code>standardize_coxph/standardize_parfrailty</code> does not currently handle time-varying exposures or
covariates.
</p>
<p><code>standardize_coxph/standardize_parfrailty</code> internally loops over all values in the <code>t</code> argument.
Therefore, the function will usually be considerably faster if
<code>length(t)</code> is small.
</p>
<p>The variance calculation performed by <code>standardize_coxph</code> does not condition on
the observed covariates <code class="reqn">\bar{Z}=(Z_1,...,Z_n)</code>. To see how this
matters, note that
</p>
<p style="text-align: center;"><code class="reqn">var\{\hat{\theta}(t,x)\}=E[var\{\hat{\theta}(t,x)|\bar{Z}\}]+var[E\{\hat{\theta}(t,x)|\bar{Z}\}].</code>
</p>

<p>The usual parameter <code class="reqn">\beta</code> in a Cox proportional hazards model does not
depend on <code class="reqn">\bar{Z}</code>. Thus, <code class="reqn">E(\hat{\beta}|\bar{Z})</code> is independent
of <code class="reqn">\bar{Z}</code> as well (since <code class="reqn">E(\hat{\beta}|\bar{Z})=\beta</code>), so that
the term <code class="reqn">var[E\{\hat{\beta}|\bar{Z}\}]</code> in the corresponding variance
decomposition for <code class="reqn">var(\hat{\beta})</code> becomes equal to 0. However,
<code class="reqn">\theta(t,x)</code> depends on <code class="reqn">\bar{Z}</code> through the average over the
sample distribution for <code class="reqn">Z</code>, and thus the term
<code class="reqn">var[E\{\hat{\theta}(t,x)|\bar{Z}\}]</code> is not 0, unless one conditions on
<code class="reqn">\bar{Z}</code>. The variance calculation by Gail and Byar (1986) ignores this
term, and thus effectively conditions on <code class="reqn">\bar{Z}</code>.
</p>


<h3>Author(s)</h3>

<p>Arvid Sjölander
</p>


<h3>References</h3>

<p>Chang I.M., Gelman G., Pagano M. (1982). Corrected group prognostic curves
and summary statistics. <em>Journal of Chronic Diseases</em> <b>35</b>,
669-674.
</p>
<p>Dahlqwist E., Pawitan Y., Sjölander A. (2019). Regression standardization
and attributable fraction estimation with between-within frailty models for
clustered survival data. <em>Statistical Methods in Medical Research</em>
<b>28</b>(2), 462-485.
</p>
<p>Gail M.H. and Byar D.P. (1986). Variance calculations for direct adjusted
survival curves, with applications to testing for no treatment effect.
<em>Biometrical Journal</em> <b>28</b>(5), 587-599.
</p>
<p>Makuch R.W. (1982). Adjusted survival curve estimation using covariates.
<em>Journal of Chronic Diseases</em> <b>35</b>, 437-443.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


require(survival)

# simulate data
set.seed(6)
n &lt;- 300
m &lt;- 3
alpha &lt;- 1.5
eta &lt;- 1
phi &lt;- 0.5
beta &lt;- 1
id &lt;- rep(1:n, each = m)
U &lt;- rep(rgamma(n, shape = 1 / phi, scale = phi), each = m)
X &lt;- rnorm(n * m)
# reparameterize scale as in rweibull function
weibull.scale &lt;- alpha / (U * exp(beta * X))^(1 / eta)
T &lt;- rweibull(n * m, shape = eta, scale = weibull.scale)

# right censoring
C &lt;- runif(n * m, 0, 10)
D &lt;- as.numeric(T &lt; C)
T &lt;- pmin(T, C)

# strong left-truncation
L &lt;- runif(n * m, 0, 2)
incl &lt;- T &gt; L
incl &lt;- ave(x = incl, id, FUN = sum) == m
dd &lt;- data.frame(L, T, D, X, id)
dd &lt;- dd[incl, ]

fit.std &lt;- standardize_parfrailty(
  formula = Surv(L, T, D) ~ X,
  data = dd,
  values = list(X = seq(-1, 1, 0.5)),
  times = 1:5,
  clusterid = "id"
)
print(fit.std)
plot(fit.std)

</code></pre>

<hr>
<h2 id='summary.parfrailty'>Summarizes parfrailty fit</h2><span id='topic+summary.parfrailty'></span>

<h3>Description</h3>

<p>This is a <code>summary</code> method for class <code>"parfrailty"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parfrailty'
summary(
  object,
  ci_type = "plain",
  ci_level = 0.95,
  digits = max(3L, getOption("digits") - 3L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.parfrailty_+3A_object">object</code></td>
<td>
<p>an object of class <code>"parfrailty"</code>.</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_ci_type">ci_type</code></td>
<td>
<p>string, indicating the type of confidence intervals. Either
&quot;plain&quot;, which gives untransformed intervals, or &quot;log&quot;, which gives
log-transformed intervals.</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_ci_level">ci_level</code></td>
<td>
<p>desired coverage probability of confidence intervals, in
decimal form.</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing..</p>
</td></tr>
<tr><td><code id="summary.parfrailty_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;summary.parfrailty&quot;, which is a list that contains relevant summary statistics about the fitted model
</p>


<h3>Author(s)</h3>

<p>Arvid Sjölander and Elisabeth Dahlqwist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parfrailty">parfrailty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See documentation for parfrailty

</code></pre>

<hr>
<h2 id='tidy.std_custom'>Provide tidy output from a std_custom object for use in downstream computations</h2><span id='topic+tidy.std_custom'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of the standardized regression fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'std_custom'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.std_custom_+3A_x">x</code></td>
<td>
<p>An object of class std_custom</p>
</td></tr>
<tr><td><code id="tidy.std_custom_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean = Z)
Y &lt;- rbinom(n, 1, prob = (1 + exp(X + Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
prob_predict.glm &lt;- function(...) predict.glm(..., type = "response")

x &lt;- standardize(
  fitter = "glm",
  arguments = list(
    formula = Y ~ X * Z,
    family = "binomial"
  ),
  predict_fun = prob_predict.glm,
  data = dd,
  values = list(X = seq(-1, 1, 0.1)),
  B = 100,
  reference = 0,
  contrasts = "difference"
)
tidy(x)

</code></pre>

<hr>
<h2 id='tidy.std_glm'>Provide tidy output from a std_glm object for use in downstream computations</h2><span id='topic+tidy.std_glm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of the standardized regression fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'std_glm'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.std_glm_+3A_x">x</code></td>
<td>
<p>An object of class std_glm</p>
</td></tr>
<tr><td><code id="tidy.std_glm_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)
n &lt;- 100
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean = Z)
Y &lt;- rbinom(n, 1, prob = (1 + exp(X + Z))^(-1))
dd &lt;- data.frame(Z, X, Y)
x &lt;- standardize_glm(
  formula = Y ~ X * Z,
  family = "binomial",
  data = dd,
  values = list(X = 0:1),
  contrasts = c("difference", "ratio"),
  reference = 0
)
tidy(x)

</code></pre>

<hr>
<h2 id='tidy.std_surv'>Provide tidy output from a std_surv object for use in downstream computations</h2><span id='topic+tidy.std_surv'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of the standardized model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'std_surv'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.std_surv_+3A_x">x</code></td>
<td>
<p>An object of class std_surv</p>
</td></tr>
<tr><td><code id="tidy.std_surv_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(survival)
set.seed(8)
n &lt;- 300
Z &lt;- rnorm(n)
X &lt;- rnorm(n, mean = Z)
time &lt;- rexp(n, rate = exp(X + Z + X * Z)) # survival time
C &lt;- rexp(n, rate = exp(X + Z + X * Z)) # censoring time
U &lt;- pmin(time, C) # time at risk
D &lt;- as.numeric(time &lt; C) # event indicator
dd &lt;- data.frame(Z, X, U, D)
x &lt;- standardize_coxph(
  formula = Surv(U, D) ~ X + Z + X * Z,
  data = dd, values = list(X = seq(-1, 1, 0.5)), times = c(2,3,4)
)

tidy(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
