<!DOCTYPE html><html lang="en"><head><title>Help for package merTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {merTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#merTools-package'><p>merTools: Provides methods for extracting and exploring results from merMod</p>
objects in the lme4 package.</a></li>
<li><a href='#averageObs'><p>Find the average observation for a merMod object</p></a></li>
<li><a href='#buildModelMatrix'><p>Build model matrix</p></a></li>
<li><a href='#collapseFrame'><p>Collapse a dataframe to a single average row</p></a></li>
<li><a href='#draw'><p>Draw a single observation out of an object matching some criteria</p></a></li>
<li><a href='#expectedRank'><p>Calculate the expected rank of random coefficients that account for</p>
uncertainty.</a></li>
<li><a href='#famlink'><p>Find link function family</p></a></li>
<li><a href='#fastdisp'><p>fastdisp: faster display of model summaries</p></a></li>
<li><a href='#FEsim'><p>Simulate fixed effects from merMod</p>
<code>FEsim</code> simulates fixed effects from merMod object posterior distributions</a></li>
<li><a href='#fetch.merMod.msgs'><p>Extract all warning msgs from a merMod object</p></a></li>
<li><a href='#findFormFuns'><p><code>findFormFuns</code> used by averageObs to calculate proper</p>
averages</a></li>
<li><a href='#fixef.merModList'><p>Extract fixed-effects estimates for a merModList</p></a></li>
<li><a href='#formulaBuild'><p>Clean formula</p></a></li>
<li><a href='#hasWeights'><p>Identify if a merMod has weights</p></a></li>
<li><a href='#hsb'><p>A subset of data from the 1982 High School and Beyond survey used as examples for HLM software</p></a></li>
<li><a href='#ICC'><p>Calculate the intraclass correlation using mixed effect models</p></a></li>
<li><a href='#levelfun'><p>Parse merMod levels</p></a></li>
<li><a href='#lmerModList'><p>Apply a multilevel model to a list of data frames</p></a></li>
<li><a href='#mkNewReTrms'><p>Utility function to make RE terms objects</p></a></li>
<li><a href='#modelFixedEff'><p>Extract averaged fixed effect parameters across a list of merMod objects</p></a></li>
<li><a href='#modelInfo'><p>Extract model information from a merMod</p></a></li>
<li><a href='#modelRandEffStats'><p>Extract data.frame of random effect statistics from merMod List</p></a></li>
<li><a href='#plot_sim_error_chks'><p>Extract all warning msgs from a merMod object</p></a></li>
<li><a href='#plotFEsim'><p>Plot the results of a simulation of the fixed effects</p></a></li>
<li><a href='#plotREsim'><p>Plot the results of a simulation of the random effects</p></a></li>
<li><a href='#predictInterval'><p>Predict from merMod objects with a prediction interval</p></a></li>
<li><a href='#print.merModList'><p>Summarize a merMod list</p></a></li>
<li><a href='#print.summary.merModList'><p>Print the summary of a merMod list</p></a></li>
<li><a href='#randomObs'><p>Select a random observation from model data</p></a></li>
<li><a href='#ranef.merModList'><p>Extract random-effects estimates for a merModList</p></a></li>
<li><a href='#REcorrExtract'><p>Extract the correlations between the slopes and the intercepts from a model</p></a></li>
<li><a href='#REextract'><p>Extracts random effects</p></a></li>
<li><a href='#REimpact'><p>Calculate the weighted mean of fitted values for various levels of</p>
random effect terms.</a></li>
<li><a href='#REmargins'><p>Calculate the predicted value for each observation across the distribution</p>
of the random effect terms.</a></li>
<li><a href='#reOnly'><p>Random Effects formula only</p></a></li>
<li><a href='#REquantile'><p>Identify group level associated with RE quantile</p></a></li>
<li><a href='#REsdExtract'><p>Extract the standard deviation of the random effects from a merMod object</p></a></li>
<li><a href='#REsim'><p>Simulate random effects from merMod</p>
<code>REsim</code> simulates random effects from merMod object posterior distributions</a></li>
<li><a href='#reTermCount'><p>Count the number of random effect terms</p></a></li>
<li><a href='#reTermNames'><p>Get names of random effect terms in a model object</p></a></li>
<li><a href='#RHSForm'><p>Parse merMod formulas</p></a></li>
<li><a href='#RMSE.merMod'><p>Estimate the Root Mean Squared Error (RMSE) for a lmerMod</p></a></li>
<li><a href='#sanitizeNames'><p>Clean up variable names in data frames</p></a></li>
<li><a href='#setup_parallel'><p>Set up parallel environment</p></a></li>
<li><a href='#shinyMer'><p>Launch a shiny app to explore your merMod interactively</p></a></li>
<li><a href='#shuffle'><p>Randomly reorder a dataframe</p></a></li>
<li><a href='#stripAttributes'><p>Remove attributes from a data.frame</p></a></li>
<li><a href='#subBoot'><p>Bootstrap a subset of an lme4 model</p></a></li>
<li><a href='#subsetList'><p>Subset a data.frame using a list of conditions</p></a></li>
<li><a href='#sum.mm'><p>Title</p></a></li>
<li><a href='#summary.merModList'><p>Print the results of a merMod list</p></a></li>
<li><a href='#superFactor'><p>Create a factor with unobserved levels</p></a></li>
<li><a href='#thetaExtract'><p>Extract theta parameters from a merMod model</p></a></li>
<li><a href='#VarCorr.merModList'><p>Extract the variances and correlations for random effects from a merMod list</p></a></li>
<li><a href='#wiggle'><p>Assign an observation to different values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Analyzing Mixed Effect Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for extracting results from mixed-effect model
    objects fit with the 'lme4' package. Allows construction of prediction intervals
    efficiently from large scale linear and generalized linear mixed-effects models.
    This method draws from the simulation framework used in the Gelman and Hill (2007) textbook:
    Data Analysis Using Regression and Multilevel/Hierarchical Models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), arm, lme4 (&ge; 1.1-11), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, parallel, nlme, future.apply,
rstanarm, Amelia, DT</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, mvtnorm, foreach, shiny, abind, ggplot2, blme,
broom.mixed, Matrix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jknowles/merTools">https://github.com/jknowles/merTools</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 19:54:58 UTC; jknow</td>
</tr>
<tr>
<td>Author:</td>
<td>Jared E. Knowles [aut, cre],
  Carl Frederick [aut],
  Alex Whitworth [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jared E. Knowles &lt;jared@civilytics.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 07:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='merTools-package'>merTools: Provides methods for extracting and exploring results from merMod
objects in the lme4 package.</h2><span id='topic+merTools'></span><span id='topic+merTools-package'></span>

<h3>Description</h3>

<p>The merTools package contains convenience tools for extracting useful
information from and exploring the implications of merMod objects created by
the lme4 package.  These convenience functions are especially useful for
merMod objects that take a long time to estimate due to their complexity or
because they are estimated on very large samples.
</p>


<h3>Details</h3>

<p>See the vignettes for usage examples
</p>


<h3>merMod extraction/utility functions</h3>


<ul>
<li> <p><code><a href="#topic+fastdisp">fastdisp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+superFactor">superFactor</a></code>
</p>
</li>
<li> <p><code><a href="#topic+REextract">REextract</a></code>
</p>
</li>
<li> <p><code><a href="#topic+REsim">REsim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+FEsim">FEsim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+RMSE.merMod">RMSE.merMod</a></code>
</p>
</li>
<li> <p><code><a href="#topic+thetaExtract">thetaExtract</a></code>
</p>
</li>
<li> <p><code><a href="#topic+REquantile">REquantile</a></code>
</p>
</li></ul>



<h3>merMod exploration functions</h3>


<ul>
<li> <p><code><a href="#topic+plotREsim">plotREsim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plotFEsim">plotFEsim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+draw">draw</a></code>
</p>
</li>
<li> <p><code><a href="#topic+wiggle">wiggle</a></code>
</p>
</li>
<li> <p><code><a href="#topic+subBoot">subBoot</a></code>
</p>
</li>
<li> <p><code><a href="#topic+predictInterval">predictInterval</a></code>
</p>
</li>
<li> <p><code><a href="#topic+expectedRank">expectedRank</a></code>
</p>
</li>
<li> <p><code><a href="#topic+REimpact">REimpact</a></code>
</p>
</li>
<li> <p><code><a href="#topic+shinyMer">shinyMer</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jared E. Knowles <a href="mailto:jared@civilytics.com">jared@civilytics.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Carl Frederick <a href="mailto:carlbfrederick@gmail.com">carlbfrederick@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Alex Whitworth <a href="mailto:whitworth.alex@gmail.com">whitworth.alex@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/jknowles/merTools">https://github.com/jknowles/merTools</a>
</p>
</li></ul>


<hr>
<h2 id='averageObs'>Find the average observation for a merMod object</h2><span id='topic+averageObs'></span>

<h3>Description</h3>

<p>Extract a data frame of a single row that represents the
average observation in a merMod object. This function also allows the
user to pass a series of conditioning argument to calculate the average
observation conditional on other characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averageObs(merMod, varList = NULL, origData = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="averageObs_+3A_mermod">merMod</code></td>
<td>
<p>a merMod object</p>
</td></tr>
<tr><td><code id="averageObs_+3A_varlist">varList</code></td>
<td>
<p>optional, a named list of conditions to subset the data on</p>
</td></tr>
<tr><td><code id="averageObs_+3A_origdata">origData</code></td>
<td>
<p>(default=NULL) a data frame containing the original,
untransformed data used to call the model. This MUST be specified if
the original variables used in formula function calls are NOT present
as 'main effects'.</p>
</td></tr>
<tr><td><code id="averageObs_+3A_...">...</code></td>
<td>
<p>not used currently</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each character and factor variable in the data.frame is assigned to the
modal category and each numeric variable is collapsed to the mean. Currently if
mode is a tie, returns a &quot;.&quot; Uses the collapseFrame function.
</p>


<h3>Value</h3>

<p>a data frame with a single row for the average observation, but with full
factor levels. See details for more.
</p>

<hr>
<h2 id='buildModelMatrix'>Build model matrix</h2><span id='topic+buildModelMatrix'></span>

<h3>Description</h3>

<p>a function to create a model matrix with all predictor terms in
both the group level and fixed effect level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildModelMatrix(model, newdata, which = "full")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildModelMatrix_+3A_model">model</code></td>
<td>
<p>a merMod object from lme4</p>
</td></tr>
<tr><td><code id="buildModelMatrix_+3A_newdata">newdata</code></td>
<td>
<p>a data frame to construct the matrix from</p>
</td></tr>
<tr><td><code id="buildModelMatrix_+3A_which">which</code></td>
<td>
<p>a character which matrix to return,default is full matrix with fixed and
random terms, other options are &quot;fixed&quot; and &quot;random&quot;</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Taken from predict.merMod in lme4
</p>

<hr>
<h2 id='collapseFrame'>Collapse a dataframe to a single average row</h2><span id='topic+collapseFrame'></span>

<h3>Description</h3>

<p>Take an entire dataframe and summarize it in one row by using the
mean and mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseFrame(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapseFrame_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each character and factor variable in the data.frame is assigned to the
modal category and each numeric variable is collapsed to the mean. Currently if
mode is a tie, returns a &quot;.&quot;
</p>


<h3>Value</h3>

<p>a data frame with a single row
</p>

<hr>
<h2 id='draw'>Draw a single observation out of an object matching some criteria</h2><span id='topic+draw'></span><span id='topic+draw.merMod'></span>

<h3>Description</h3>

<p>Draw is used to select a single observation out of an R object.
Additional parameters allow the user to control how that observation is
chosen in order to manipulate that observation later. This is a generic
function with methods for a number of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(object, type = c("random", "average"), varList = NULL, seed = NULL, ...)

## S3 method for class 'merMod'
draw(object, type = c("random", "average"), varList = NULL, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_+3A_object">object</code></td>
<td>
<p>the object to draw from</p>
</td></tr>
<tr><td><code id="draw_+3A_type">type</code></td>
<td>
<p>what kind of draw to make. Options include random or average</p>
</td></tr>
<tr><td><code id="draw_+3A_varlist">varList</code></td>
<td>
<p>a list specifying filters to subset the data by when making the
draw</p>
</td></tr>
<tr><td><code id="draw_+3A_seed">seed</code></td>
<td>
<p>numeric, optional argument to set seed for simulations, ignored if type=&quot;average&quot;</p>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>additional arguments required by certain methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases of tie, &quot;.&quot;, may be substituted for factors.
</p>


<h3>Value</h3>

<p>a data.frame with a single row representing the desired observation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
# Random case
draw(fm1, type = "random")
# Average
draw(fm1, type = "average")
# Subset
draw(fm1, type = "average", varList = list("Subject" = "308"))

</code></pre>

<hr>
<h2 id='expectedRank'>Calculate the expected rank of random coefficients that account for
uncertainty.</h2><span id='topic+expectedRank'></span>

<h3>Description</h3>

<p><code>expectedRank</code> calculates the expected rank and the percentile expected
rank of any random term in a merMod object.  A simple ranking of the estimated
random effects (as produced by <code><a href="lme4.html#topic+ranef">ranef</a></code>) is not satisfactory
because it ignores any amount of uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedRank(merMod, groupFctr = NULL, term = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectedRank_+3A_mermod">merMod</code></td>
<td>
<p>An object of class merMod</p>
</td></tr>
<tr><td><code id="expectedRank_+3A_groupfctr">groupFctr</code></td>
<td>
<p>An optional character vector specifying the name(s) the grouping factor(s)
over which the random coefficient of interest varies.  This is the
variable to the right of the pipe, <code>|</code>, in the [g]lmer formula.
This parameter is optional. If none is specified all terms will be returned.</p>
</td></tr>
<tr><td><code id="expectedRank_+3A_term">term</code></td>
<td>
<p>An optional character vector specifying the name(s) of the random coefficient of interest. This is the
variable to the left of the pipe, <code>|</code>, in the [g]lmer formula. Partial
matching is attempted on the intercept term so the following character
strings will all return rankings based on the intercept (<em>provided that
they do not match the name of another random coefficient for that factor</em>):
<code>c("(Intercept)", "Int", "intercep", ...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by Lingsma et al. (2010, see also Laird and Louis 1989),
expectedRank sums the probability that each level of the grouping factor is
greater than every other level of the grouping factor, similar to a
two-sample t-test.
</p>
<p>The formula for the expected rank is:
</p>
<p style="text-align: center;"><code class="reqn">ExpectedRank_i = 1 + \sum \phi((\theta_i - \theta_k) / \sqrt(var(\theta_i)+var(\theta_k))</code>
</p>

<p>where <code class="reqn">\phi</code> is the standard normal distribution function, <code class="reqn">\theta</code>
is the estimated random effect and <code class="reqn">var(\theta)</code> is the posterior
variance of the estimated random effect. We add one to the sum so that the
minimum rank is one instead of zero so that in the case where there is no
overlap between the variances of the random effects (or if the variances are
zero), the expected rank equals the actual rank.  The ranks are ordered such
that the winners have ranks that are greater than the losers.
</p>
<p>The formula for the percentile expected rank is:
</p>
<p style="text-align: center;"><code class="reqn">100 * (ExpectedRank_i - 0.5) / N_grps</code>
</p>

<p>where <code class="reqn">N_grps</code> is the number of grouping factor levels. The percentile
expected rank can be interpreted as the fraction of levels that score at or
below the given level.
</p>
<p>NOTE: <code>expectedRank</code> will only work under conditions that <code>lme4::ranef</code>
will work. One current example of when this is <em>not</em> the case is for
models when there are multiple terms specified per factor (e.g. uncorrelated random
coefficients for the same term, e.g.
<code>lmer(Reaction ~ Days + (1 | Subject) + (0 + Days | Subject), data = sleepstudy)</code>)
</p>


<h3>Value</h3>

<p>A data.frame with the following five columns:
</p>

<dl>
<dt>groupFctr</dt><dd><p>a character representing name of the grouping factor</p>
</dd>
<dt>groupLevel</dt><dd><p>a character representing the level of the grouping factor</p>
</dd>
<dt>term</dt><dd><p>a character representing the formula term for the group</p>
</dd>
<dt>estimate</dt><dd><p>effect estimate from <code>lme4::ranef(, condVar=TRUE)</code>).</p>
</dd>
<dt>std.error</dt><dd><p>the posterior variance of the estimate random effect
(from <code>lme4::ranef(, condVar=TRUE)</code>); named &quot;<code>term</code>&quot;_var.</p>
</dd>
<dt>ER</dt><dd><p>The expected rank.</p>
</dd>
<dt>pctER</dt><dd><p>The percentile expected rank.</p>
</dd>
</dl>



<h3>References</h3>

<p>Laird NM and Louis TA. Empirical Bayes Ranking Methods. <em>Journal of
Education Statistics</em>. 1989;14(1)29-46. Available at
<a href="http://www.jstor.org/stable/1164724">http://www.jstor.org/stable/1164724</a>.
</p>
<p>Lingsma HF, Steyerberg EW, Eijkemans MJC, et al. Comparing and
ranking hospitals based on outcome: results from The Netherlands Stroke Survey.
<em>QJM: An International Journal of Medicine</em>. 2010;103(2):99-108.
doi:10.1093/qjmed/hcp169
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#For a one-level random intercept model
m1 &lt;- lmer(Reaction ~ Days + (1 | Subject), sleepstudy)
(m1.er &lt;- expectedRank(m1))

#For a one-level random intercept model with multiple random terms
m2 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
#ranked by the random slope on Days
(m2.er1 &lt;- expectedRank(m2, term="Days"))
#ranked by the random intercept
(m2.er2 &lt;- expectedRank(m2, term="int"))

#For a two-level model with random intercepts
m3 &lt;- lmer(y ~ service * dept + (1|s) + (1|d), InstEval)
#Ranked by the random intercept on 's'
(m3.er1 &lt;- expectedRank(m3, groupFctr="s", term="Intercept"))

</code></pre>

<hr>
<h2 id='famlink'>Find link function family</h2><span id='topic+famlink'></span>

<h3>Description</h3>

<p>Find link function family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>famlink(object, resp = object@resp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="famlink_+3A_object">object</code></td>
<td>
<p>a merMod object</p>
</td></tr>
<tr><td><code id="famlink_+3A_resp">resp</code></td>
<td>
<p>the response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the link function and family
</p>

<hr>
<h2 id='fastdisp'>fastdisp: faster display of model summaries</h2><span id='topic+fastdisp'></span><span id='topic+fastdisp.merMod'></span><span id='topic+fastdisp.merModList'></span>

<h3>Description</h3>

<p>Display model fit summary of x or x like objects, fast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastdisp(x, ...)

## S3 method for class 'merMod'
fastdisp(x, ...)

## S3 method for class 'merModList'
fastdisp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastdisp_+3A_x">x</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="fastdisp_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>arm::<a href="arm.html#topic+display">display</a></code>
including number of digits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faster than the implementation in the arm package because it avoids refitting
</p>
<p>The time saving is only noticeable for large, time-consuming (g)lmer
fits.
</p>


<h3>Value</h3>

<p>A printed summary of a x object
</p>


<h3>See Also</h3>

<p><code><a href="arm.html#topic+display">display</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Compare the time for displaying this modest model
require(arm)
m1 &lt;- lmer(y ~ lectage + studage + (1|d) + (1|s), data=InstEval)
system.time(display(m1))
system.time(fastdisp(m1))

</code></pre>

<hr>
<h2 id='FEsim'>Simulate fixed effects from merMod
<code>FEsim</code> simulates fixed effects from merMod object posterior distributions</h2><span id='topic+FEsim'></span>

<h3>Description</h3>

<p>Simulate fixed effects from merMod
<code>FEsim</code> simulates fixed effects from merMod object posterior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEsim(merMod, n.sims = 200, oddsRatio = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FEsim_+3A_mermod">merMod</code></td>
<td>
<p>a merMod object from the lme4 package</p>
</td></tr>
<tr><td><code id="FEsim_+3A_n.sims">n.sims</code></td>
<td>
<p>number of simulations to use</p>
</td></tr>
<tr><td><code id="FEsim_+3A_oddsratio">oddsRatio</code></td>
<td>
<p>logical, should parameters be converted to odds ratios?</p>
</td></tr>
<tr><td><code id="FEsim_+3A_seed">seed</code></td>
<td>
<p>numeric, optional argument to set seed for simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the Gelman sim technique to build fixed effect estimates and
confidence intervals. Uses the sim function in the arm package
</p>


<h3>Value</h3>

<p>a data frame with the following columns
</p>

<dl>
<dt><code>term</code></dt><dd><p>Name of fixed term (intercept/coefficient)</p>
</dd>
<dt><code>mean</code></dt><dd><p>Mean of the simulations</p>
</dd>
<dt><code>median</code></dt><dd><p>Median of the simulations</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation of the simulations, <code>NA</code> if <code>oddsRatio=TRUE</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>require(lme4)
m2 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
fe2 &lt;- FEsim(m2, 25)
head(fe2)
</code></pre>

<hr>
<h2 id='fetch.merMod.msgs'>Extract all warning msgs from a merMod object</h2><span id='topic+fetch.merMod.msgs'></span>

<h3>Description</h3>

<p>Extract all warning msgs from a merMod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch.merMod.msgs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch.merMod.msgs_+3A_x">x</code></td>
<td>
<p>a merMod object</p>
</td></tr>
</table>

<hr>
<h2 id='findFormFuns'><code>findFormFuns</code> used by <a href="#topic+averageObs">averageObs</a> to calculate proper
averages</h2><span id='topic+findFormFuns'></span>

<h3>Description</h3>

<p>The purpose is to properly derive data for the average observation in the
data by being 'aware' of formulas that contain interactions and/or function
calls. For example, in the old behavior, if the formula contained a square
term specified as <code>I(x^2)</code>, we were returning the mean of <code>x(^2)</code> not the
square of mean(x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFormFuns(merMod, origData = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findFormFuns_+3A_mermod">merMod</code></td>
<td>
<p>the merMod object from which to draw the average observation</p>
</td></tr>
<tr><td><code id="findFormFuns_+3A_origdata">origData</code></td>
<td>
<p>(default=NULL) a data frame containing the original,
untransformed data used to call the model. This MUST be specified if
the original variables used in formula function calls are NOT present
as 'main effects'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a single row for the average observation, but with full
factor levels. See details for more.
</p>

<hr>
<h2 id='fixef.merModList'>Extract fixed-effects estimates for a merModList</h2><span id='topic+fixef.merModList'></span>

<h3>Description</h3>

<p>Extract fixed-effects estimates for a merModList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merModList'
fixef(object, add.dropped = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixef.merModList_+3A_object">object</code></td>
<td>
<p>any fitted model object from which fixed
effects estimates can be extracted.</p>
</td></tr>
<tr><td><code id="fixef.merModList_+3A_add.dropped">add.dropped</code></td>
<td>
<p>for models with rank-deficient design
matrix, reconstitute the full-length parameter vector by
adding <code>NA</code> values in appropriate locations?</p>
</td></tr>
<tr><td><code id="fixef.merModList_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently
none are used in any methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the estimates of the fixed-effects parameters from a list of
fitted <code>merMod</code> models. Takes the mean of the individual <code>fixef</code>
objects for each of the component models in the <code>merModList</code>.
</p>


<h3>Value</h3>

<p>a named, numeric vector of fixed-effects estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
fixef(mod)

</code></pre>

<hr>
<h2 id='formulaBuild'>Clean formula</h2><span id='topic+formulaBuild'></span>

<h3>Description</h3>

<p>a function to modify the formula for a merMod object to create
a model matrix with all predictor terms in both the group level and fixed
effect level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formulaBuild(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formulaBuild_+3A_model">model</code></td>
<td>
<p>a merMod object from lme4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formula object
</p>

<hr>
<h2 id='hasWeights'>Identify if a merMod has weights</h2><span id='topic+hasWeights'></span>

<h3>Description</h3>

<p>Identify if a merMod has weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasWeights(merMod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hasWeights_+3A_mermod">merMod</code></td>
<td>
<p>the merMod object to test for weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE for whether the model has weights
</p>

<hr>
<h2 id='hsb'>A subset of data from the 1982 High School and Beyond survey used as examples for HLM software</h2><span id='topic+hsb'></span>

<h3>Description</h3>

<p>A key example dataset used for examples in the HLM software manual.
Included here for use in replicating HLM analyses in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsb
</code></pre>


<h3>Format</h3>

<p>A data frame with 7,185 observations on the following 8 variables.
</p>

<dl>
<dt><code>schid</code></dt><dd><p>a numeric vector, 160 unique values</p>
</dd>
<dt><code>mathach</code></dt><dd><p>a numeric vector for the performance on a standardized math assessment</p>
</dd>
<dt><code>female</code></dt><dd><p>a numeric vector coded 0 for male and 1 for female</p>
</dd>
<dt><code>ses</code></dt><dd><p>a numeric measure of student socio-economic status</p>
</dd>
<dt><code>minority</code></dt><dd><p>a numeric vector coded 0 for white and 1 for non-white students</p>
</dd>
<dt><code>schtype</code></dt><dd><p>a numeric vector coded 0 for public and 1 for private schools</p>
</dd>
<dt><code>meanses</code></dt><dd><p>a numeric, the average SES for each school in the data set</p>
</dd>
<dt><code>size</code></dt><dd><p>a numeric for the number of students in the school</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data file used for this presentation is a subsample from the
1982 High School and Beyond Survey and is used extensively in
Hierarchical Linear Models by Raudenbush and Bryk. It consists of 7,185 students
nested in 160 schools.
</p>


<h3>Source</h3>

<p>Data made available by UCLA Institute for Digital Research and Education
(IDRE) online: <a href="https://stats.oarc.ucla.edu/other/hlm/hlm-mlm/introduction-to-multilevel-modeling-using-hlm/">https://stats.oarc.ucla.edu/other/hlm/hlm-mlm/introduction-to-multilevel-modeling-using-hlm/</a>
</p>


<h3>References</h3>

<p>Stephen W. Raudenbush and Anthony S. Bryk (2002). Hierarchical
Linear Models: Applications and Data Analysis Methods (2nd ed.). SAGE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hsb)
head(hsb)
</code></pre>

<hr>
<h2 id='ICC'>Calculate the intraclass correlation using mixed effect models</h2><span id='topic+ICC'></span>

<h3>Description</h3>

<p>Calculate the intraclass correlation using mixed effect models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICC(outcome, group, data, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICC_+3A_outcome">outcome</code></td>
<td>
<p>a character representing the variable of the outcome</p>
</td></tr>
<tr><td><code id="ICC_+3A_group">group</code></td>
<td>
<p>a character representing the name of the grouping term</p>
</td></tr>
<tr><td><code id="ICC_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="ICC_+3A_subset">subset</code></td>
<td>
<p>an optional subset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric for the intraclass correlation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sleepstudy)
ICC(outcome = "Reaction", group = "Subject", data = sleepstudy)
</code></pre>

<hr>
<h2 id='levelfun'>Parse merMod levels</h2><span id='topic+levelfun'></span>

<h3>Description</h3>

<p>Parse merMod levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levelfun(x, nl.n, allow.new.levels = FALSE)
</code></pre>

<hr>
<h2 id='lmerModList'>Apply a multilevel model to a list of data frames</h2><span id='topic+lmerModList'></span><span id='topic+blmerModList'></span><span id='topic+glmerModList'></span><span id='topic+bglmerModList'></span>

<h3>Description</h3>

<p>Apply a multilevel model to a list of data frames
</p>
<p>Apply a Bayesian multilevel model to a list of data frames
</p>
<p>Apply a generalized linear multilevel model to a list of data frames
</p>
<p>Apply a Bayesian generalized linear multilevel model to a list of data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerModList(formula, data, parallel = FALSE, ...)

blmerModList(formula, data, parallel = FALSE, ...)

glmerModList(formula, data, parallel = FALSE, ...)

bglmerModList(formula, data, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmerModList_+3A_formula">formula</code></td>
<td>
<p>a formula to pass through compatible with merMod</p>
</td></tr>
<tr><td><code id="lmerModList_+3A_data">data</code></td>
<td>
<p>a list object with each element being a data.frame</p>
</td></tr>
<tr><td><code id="lmerModList_+3A_parallel">parallel</code></td>
<td>
<p>logical, should the models be run in parallel? Default FALSE. If so,
the 'future_lapply' function from the 'future.apply' package is used. See
details.</p>
</td></tr>
<tr><td><code id="lmerModList_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the estimating function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallel computing is provided by the 'futures' package, and its
extension the 'future.apply' package to provide the 'future_lapply' function
for easy parallel computations on lists. To use this package, simply register
a parallel backend using the 'plan()' function from 'futures' - an example
is to use 'plan(multisession)'
</p>


<h3>Value</h3>

<p>a list of fitted merMod objects of class merModList
</p>
<p>a merModList
</p>
<p>a merModList
</p>
<p>a merModList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
summary(mod)

</code></pre>

<hr>
<h2 id='mkNewReTrms'>Utility function to make RE terms objects</h2><span id='topic+mkNewReTrms'></span>

<h3>Description</h3>

<p>Utility function to make RE terms objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkNewReTrms(
  object,
  newdata,
  re.form = NULL,
  na.action = na.pass,
  allow.new.levels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkNewReTrms_+3A_object">object</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="mkNewReTrms_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame to build RE terms for</p>
</td></tr>
<tr><td><code id="mkNewReTrms_+3A_re.form">re.form</code></td>
<td>
<p>a random effect formula to simulate, generated by
<code><a href="#topic+reOnly">reOnly</a></code></p>
</td></tr>
<tr><td><code id="mkNewReTrms_+3A_na.action">na.action</code></td>
<td>
<p>an object describing how NA values should be handled in newdata</p>
</td></tr>
<tr><td><code id="mkNewReTrms_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>logical, should new levels be allowed in factor variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a random effect terms object for a merMod
</p>

<hr>
<h2 id='modelFixedEff'>Extract averaged fixed effect parameters across a list of merMod objects</h2><span id='topic+modelFixedEff'></span>

<h3>Description</h3>

<p>Extract averaged fixed effect parameters across a list of merMod objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelFixedEff(modList, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelFixedEff_+3A_modlist">modList</code></td>
<td>
<p>an object of class merModList</p>
</td></tr>
<tr><td><code id="modelFixedEff_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>tidy</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rubin correction for combining estimates and standard errors from
Rubin (1987) is applied to adjust for the within and between imputation variances.
</p>


<h3>Value</h3>

<p>a data.frame of the averaged fixed effect parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
modelFixedEff(mod)

</code></pre>

<hr>
<h2 id='modelInfo'>Extract model information from a merMod</h2><span id='topic+modelInfo'></span>

<h3>Description</h3>

<p>Extract model information from a merMod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelInfo(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelInfo_+3A_object">object</code></td>
<td>
<p>a merMod object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simple summary information about the object, number
of observations, number of grouping terms, AIC, and residual standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
modelInfo(mod[[1]])
lapply(mod, modelInfo)

</code></pre>

<hr>
<h2 id='modelRandEffStats'>Extract data.frame of random effect statistics from merMod List</h2><span id='topic+modelRandEffStats'></span>

<h3>Description</h3>

<p>Extract data.frame of random effect statistics from merMod List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelRandEffStats(modList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelRandEffStats_+3A_modlist">modList</code></td>
<td>
<p>a list of multilevel models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
modelRandEffStats(mod)

</code></pre>

<hr>
<h2 id='plot_sim_error_chks'>Extract all warning msgs from a merMod object</h2><span id='topic+plot_sim_error_chks'></span>

<h3>Description</h3>

<p>Extract all warning msgs from a merMod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sim_error_chks(
  type = c("FE", "RE"),
  level = 0.95,
  stat = c("mean", "median"),
  sd = TRUE,
  sigmaScale = NULL,
  oddsRatio = FALSE,
  labs = FALSE,
  facet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sim_error_chks_+3A_type">type</code></td>
<td>
<p>check a fixed or random effect</p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_level">level</code></td>
<td>
<p>the width of the confidence interval</p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_stat">stat</code></td>
<td>
<p>a character value indicating the variable name in data of the
midpoint of the estimated interval, e.g. &quot;mean&quot; or &quot;median&quot;</p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_sd">sd</code></td>
<td>
<p>a logical indicating whether or not to plot error bars around
the estimates (default is TRUE). Calculates the width of the error bars
based on <code>level</code> and the variable named &quot;sd&quot; in <code>data</code></p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_sigmascale">sigmaScale</code></td>
<td>
<p>a numeric value to divide the estimate and the standard
deviation by in the case of doing an effect size calculation</p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_oddsratio">oddsRatio</code></td>
<td>
<p>logical, should the parameters be converted to odds ratios
before plotting</p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_labs">labs</code></td>
<td>
<p>logical, include the labels of the groups on the x-axis</p>
</td></tr>
<tr><td><code id="plot_sim_error_chks_+3A_facet">facet</code></td>
<td>
<p>Accepts either logical (<code>TRUE</code>) or <code>list</code> to specify which
random effects to plot. If <code>TRUE</code>, facets by both <code>groupFctr</code> and <code>term</code>.
If <code>list</code> selects the panel specified by the named elements of the list</p>
</td></tr>
</table>

<hr>
<h2 id='plotFEsim'>Plot the results of a simulation of the fixed effects</h2><span id='topic+plotFEsim'></span>

<h3>Description</h3>

<p>Plot the simulated fixed effects on a ggplot2 chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFEsim(
  data,
  level = 0.95,
  stat = "median",
  sd = TRUE,
  intercept = FALSE,
  sigmaScale = NULL,
  oddsRatio = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFEsim_+3A_data">data</code></td>
<td>
<p>a data.frame generated by <code><a href="#topic+FEsim">FEsim</a></code> with simulations of
the fixed effects of a <code>merMod</code></p>
</td></tr>
<tr><td><code id="plotFEsim_+3A_level">level</code></td>
<td>
<p>the width of the confidence interval</p>
</td></tr>
<tr><td><code id="plotFEsim_+3A_stat">stat</code></td>
<td>
<p>a character value indicating the variable name in data of the
midpoint of the estimated interval, e.g. &quot;mean&quot; or &quot;median&quot;</p>
</td></tr>
<tr><td><code id="plotFEsim_+3A_sd">sd</code></td>
<td>
<p>logical, indicating whether or not to plot error bars around
the estimates (default is TRUE). Calculates the width of the error bars
based on <code>level</code> and the variable named &quot;sd&quot; in <code>data</code></p>
</td></tr>
<tr><td><code id="plotFEsim_+3A_intercept">intercept</code></td>
<td>
<p>logical, should the intercept be included, default is FALSE</p>
</td></tr>
<tr><td><code id="plotFEsim_+3A_sigmascale">sigmaScale</code></td>
<td>
<p>a numeric value to divide the estimate and the standard
deviation by in the case of doing an effect size calculation</p>
</td></tr>
<tr><td><code id="plotFEsim_+3A_oddsratio">oddsRatio</code></td>
<td>
<p>logical, should the parameters be converted to odds ratios
before plotting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 plot of the coefficient effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
 (p1 &lt;- plotFEsim(FEsim(fm1)))
</code></pre>

<hr>
<h2 id='plotREsim'>Plot the results of a simulation of the random effects</h2><span id='topic+plotREsim'></span>

<h3>Description</h3>

<p>Plot the simulated random effects on a ggplot2 chart. Points that
are distinguishable from zero (i.e. the confidence band based on <code>level</code>
does not cross the red line) are highlighted. Currently, the plots are ordered
according to the grouping factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotREsim(
  data,
  level = 0.95,
  stat = "median",
  sd = TRUE,
  sigmaScale = NULL,
  oddsRatio = FALSE,
  labs = FALSE,
  facet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotREsim_+3A_data">data</code></td>
<td>
<p>a data.frame generated by <code><a href="#topic+REsim">REsim</a></code> with simulations of
the random effects of a <code>merMod</code></p>
</td></tr>
<tr><td><code id="plotREsim_+3A_level">level</code></td>
<td>
<p>the width of the confidence interval</p>
</td></tr>
<tr><td><code id="plotREsim_+3A_stat">stat</code></td>
<td>
<p>a character value indicating the variable name in data of the
midpoint of the estimated interval, e.g. &quot;mean&quot; or &quot;median&quot;</p>
</td></tr>
<tr><td><code id="plotREsim_+3A_sd">sd</code></td>
<td>
<p>a logical indicating whether or not to plot error bars around
the estimates (default is TRUE). Calculates the width of the error bars
based on <code>level</code> and the variable named &quot;sd&quot; in <code>data</code></p>
</td></tr>
<tr><td><code id="plotREsim_+3A_sigmascale">sigmaScale</code></td>
<td>
<p>a numeric value to divide the estimate and the standard
deviation by in the case of doing an effect size calculation</p>
</td></tr>
<tr><td><code id="plotREsim_+3A_oddsratio">oddsRatio</code></td>
<td>
<p>logical, should the parameters be converted to odds ratios
before plotting</p>
</td></tr>
<tr><td><code id="plotREsim_+3A_labs">labs</code></td>
<td>
<p>logical, include the labels of the groups on the x-axis</p>
</td></tr>
<tr><td><code id="plotREsim_+3A_facet">facet</code></td>
<td>
<p>Accepts either logical (<code>TRUE</code>) or <code>list</code> to specify which
random effects to plot. If <code>TRUE</code>, facets by both <code>groupFctr</code> and <code>term</code>.
If <code>list</code> selects the panel specified by the named elements of the list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 plot of the coefficient effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
 (p1 &lt;- plotREsim(REsim(fm1)))
 #Plot just the random effects for the Days slope
 (p2 &lt;- plotREsim(REsim(fm1), facet= list(groupFctr= "Subject", term= "Days")))
 
</code></pre>

<hr>
<h2 id='predictInterval'>Predict from merMod objects with a prediction interval</h2><span id='topic+predictInterval'></span>

<h3>Description</h3>

<p>This function provides a way to capture model uncertainty in
predictions from multi-level models fit with <code>lme4</code>. By drawing a sampling
distribution for the random and the fixed effects and then estimating the fitted
value across that distribution, it is possible to generate a prediction interval
for fitted values that includes all variation in the model except for variation
in the covariance parameters, theta. This is a much faster alternative than
bootstrapping for models fit to medium to large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictInterval(
  merMod,
  newdata,
  which = c("full", "fixed", "random", "all"),
  level = 0.8,
  n.sims = 1000,
  stat = c("median", "mean"),
  type = c("linear.prediction", "probability"),
  include.resid.var = TRUE,
  returnSims = FALSE,
  seed = NULL,
  .parallel = FALSE,
  .paropts = NULL,
  fix.intercept.variance = FALSE,
  ignore.fixed.terms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictInterval_+3A_mermod">merMod</code></td>
<td>
<p>a merMod object from lme4</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame of new data to predict</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_which">which</code></td>
<td>
<p>a character specifying what to return, by default it returns the
full interval, but you can also select to return only the fixed variation or
the random component variation. If full is selected the resulting data.frame
will be <code>nrow(newdata) * number of model levels</code> long</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_level">level</code></td>
<td>
<p>the width of the prediction interval</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_n.sims">n.sims</code></td>
<td>
<p>number of simulation samples to construct</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_stat">stat</code></td>
<td>
<p>take the median or mean of simulated intervals</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_type">type</code></td>
<td>
<p>type of prediction to develop</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_include.resid.var">include.resid.var</code></td>
<td>
<p>logical, include or exclude the residual variance for
linear models</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_returnsims">returnSims</code></td>
<td>
<p>logical, should all n.sims simulations be returned?</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_seed">seed</code></td>
<td>
<p>numeric, optional argument to set seed for simulations</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_.parallel">.parallel</code></td>
<td>
<p>logical should parallel computation be used, default is FALSE</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_.paropts">.paropts</code></td>
<td>
<p>-NOT USED: Caused issue #54- a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example) your
code relies on external data or packages: use the .export and .packages arguments
to supply them so that all cluster nodes have the correct environment set up
for computing.</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_fix.intercept.variance">fix.intercept.variance</code></td>
<td>
<p>logical; should the variance of the intercept
term be adjusted downwards to roughly correct for its covariance with the
random effects, as if all the random effects are intercept effects?</p>
</td></tr>
<tr><td><code id="predictInterval_+3A_ignore.fixed.terms">ignore.fixed.terms</code></td>
<td>
<p>a numeric or string vector of indexes or names of
fixed effects which should be considered as fully known (zero variance). This
can result in under-conservative intervals, but for models with random effects
nested inside fixed effects, holding the fixed effects constant intervals may
give intervals with closer to nominal coverage than the over-conservative
intervals without this option, which ignore negative correlation between the
outer (fixed) and inner (random) coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate a prediction interval, the function first computes a simulated
distribution of all of the parameters in the model. For the random, or grouping,
effects, this is done by sampling from a multivariate normal distribution which
is defined by the BLUP estimate provided by <code>ranef</code> and the associated
variance-covariance matrix for each observed level of each grouping terms. For
each grouping term, an array is build that has as many rows as there are levels
of the grouping factor, as many columns as there are predictors at that level
(e.g. an intercept and slope), and is stacked as high as there are number of
simulations. These arrays are then multiplied by the new data provided to the
function to produce a matrix of yhat values. The result is a matrix of the simulated
values of the linear predictor for each observation for each simulation. Each
grouping term has such a matrix for each observation. These values can be added
to get the estimate of the fitted value for the random effect terms, and this
can then be added to a matrix of simulated values for the fixed effect level to
come up with <code>n.sims</code> number of possible yhat values for each observation.
</p>
<p>The distribution of simulated values is cut according to the interval requested
by the function. The median or mean value as well as the upper and lower bounds
are then returned. These can be presented either on the linear predictor scale
or on the response scale using the link function in the <code>merMod</code>.
</p>


<h3>Value</h3>

<p>a data.frame with three columns:
</p>

<dl>
<dt><code>fit</code></dt><dd><p>The center of the distribution of predicted values as defined by
the <code>stat</code> parameter.</p>
</dd>
<dt><code>lwr</code></dt><dd><p>The lower prediction interval bound corresponding to the quantile cut
defined in <code>level</code>.</p>
</dd>
<dt><code>upr</code></dt><dd><p>The upper prediction interval bound corresponding to the quantile cut
defined in <code>level</code>.</p>
</dd>
</dl>

<p>If returnSims = TRUE, then the individual simulations are attached to this
data.frame in the attribute <code>sim.results</code> and are stored as a matrix.
</p>


<h3>Note</h3>

<p><code>merTools</code> includes the functions <code>subBoot</code> and <code>thetaExtract</code>
to allow the user to estimate the variability in <code>theta</code> from a larger
model by bootstrapping the model fit on a subset, to allow faster estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m1 &lt;- lmer(Reaction ~ Days + (1 | Subject), sleepstudy)
regFit &lt;- predict(m1, newdata = sleepstudy[11, ]) # a single value is returned
intFit &lt;- predictInterval(m1, newdata = sleepstudy[11, ]) # bounded values
# Can do glmer
d1 &lt;- cbpp
d1$y &lt;- d1$incidence / d1$size
 gm2 &lt;- glmer(y ~ period + (1 | herd), family = binomial, data = d1,
               nAGQ = 9, weights = d1$size)
 regFit &lt;- predict(gm2, newdata = d1[1:10, ])
 # get probabilities
 regFit &lt;- predict(gm2, newdata = d1[1:10, ], type = "response")
 intFit &lt;- predictInterval(gm2, newdata = d1[1:10, ], type = "probability")
 intFit &lt;- predictInterval(gm2, newdata = d1[1:10, ], type = "linear.prediction")
 
</code></pre>

<hr>
<h2 id='print.merModList'>Summarize a merMod list</h2><span id='topic+print.merModList'></span>

<h3>Description</h3>

<p>Summarize a merMod list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merModList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.merModList_+3A_x">x</code></td>
<td>
<p>a modList of class merModList</p>
</td></tr>
<tr><td><code id="print.merModList_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary object of model information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
summary(mod)

</code></pre>

<hr>
<h2 id='print.summary.merModList'>Print the summary of a merMod list</h2><span id='topic+print.summary.merModList'></span>

<h3>Description</h3>

<p>Print the summary of a merMod list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.merModList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.merModList_+3A_x">x</code></td>
<td>
<p>a summary of amerModList object</p>
</td></tr>
<tr><td><code id="print.summary.merModList_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary content printed to console
</p>

<hr>
<h2 id='randomObs'>Select a random observation from model data</h2><span id='topic+randomObs'></span>

<h3>Description</h3>

<p>Select a random observation from the model frame of a merMod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomObs(merMod, varList, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomObs_+3A_mermod">merMod</code></td>
<td>
<p>an object of class merMod</p>
</td></tr>
<tr><td><code id="randomObs_+3A_varlist">varList</code></td>
<td>
<p>optional, a named list of conditions to subset the data on</p>
</td></tr>
<tr><td><code id="randomObs_+3A_seed">seed</code></td>
<td>
<p>numeric, optional argument to set seed for simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each factor variable in the data frame has all factor levels from the
full model.frame stored so that the new data is compatible with predict.merMod
</p>


<h3>Value</h3>

<p>a data frame with a single row for a random observation, but with full
factor levels. See details for more.
</p>

<hr>
<h2 id='ranef.merModList'>Extract random-effects estimates for a merModList</h2><span id='topic+ranef.merModList'></span>

<h3>Description</h3>

<p>Extract random-effects estimates for a merModList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merModList'
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef.merModList_+3A_object">object</code></td>
<td>
<p>an object of a class of fitted models with
random effects, typically a
<code>merMod</code> object.</p>
</td></tr>
<tr><td><code id="ranef.merModList_+3A_...">...</code></td>
<td>
<p>some methods for these generic functions
require additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the estimates of the random-effects parameters from a list of
fitted <code>merMod</code> models. Takes the mean of the individual <code>ranef</code>
objects for each of the component models in the <code>merModList</code>.
</p>


<h3>Value</h3>

<p>a named, numeric vector of random-effects estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
ranef(mod)

</code></pre>

<hr>
<h2 id='REcorrExtract'>Extract the correlations between the slopes and the intercepts from a model</h2><span id='topic+REcorrExtract'></span>

<h3>Description</h3>

<p>Extract the correlations between the slopes and the intercepts from a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REcorrExtract(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REcorrExtract_+3A_model">model</code></td>
<td>
<p>an object that inherits from class merMod</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of the correlations among the effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
REcorrExtract(fm1)
</code></pre>

<hr>
<h2 id='REextract'>Extracts random effects</h2><span id='topic+REextract'></span>

<h3>Description</h3>

<p>Extracts random effect terms from an lme4 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REextract(merMod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REextract_+3A_mermod">merMod</code></td>
<td>
<p>a merMod object from the lme4 package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the following columns
</p>

<dl>
<dt>groupFctr</dt><dd><p>The name of the grouping factor associated with the random effects</p>
</dd>
<dt>groupID</dt><dd><p>The level of the grouping factor associated with the random effects</p>
</dd>
<dt>'term'</dt><dd><p>One column per random effect, the name is derived from the merMod</p>
</dd>
<dt>'term'_se</dt><dd><p>One column per random effect, the name is derived from the merMod</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>m2 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
rfx &lt;- REextract(m2)
#Note the column names
head(rfx)
</code></pre>

<hr>
<h2 id='REimpact'>Calculate the weighted mean of fitted values for various levels of
random effect terms.</h2><span id='topic+REimpact'></span>

<h3>Description</h3>

<p><code>REimpact</code> calculates the average predicted value for each row of a
new data frame across the distribution of <code><a href="#topic+expectedRank">expectedRank</a></code> for a
merMod object. This allows the user to make meaningful comparisons about the
influence of random effect terms on the scale of the response variable,
for user-defined inputs, and accounting for the variability in grouping terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REimpact(merMod, newdata, groupFctr = NULL, term = NULL, breaks = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REimpact_+3A_mermod">merMod</code></td>
<td>
<p>An object of class merMod</p>
</td></tr>
<tr><td><code id="REimpact_+3A_newdata">newdata</code></td>
<td>
<p>a data frame of observations to calculate group-level differences
for</p>
</td></tr>
<tr><td><code id="REimpact_+3A_groupfctr">groupFctr</code></td>
<td>
<p>The name of the grouping factor over which the random
coefficient of interest varies.  This is the variable to the right of the
pipe, <code>|</code>, in the [g]lmer formula. This parameter is optional, if not
specified, it will perform the calculation for the first effect listed
by <code>ranef</code>.</p>
</td></tr>
<tr><td><code id="REimpact_+3A_term">term</code></td>
<td>
<p>The name of the random coefficient of interest. This is the
variable to the left of the pipe, <code>|</code>, in the [g]lmer formula. Partial
matching is attempted on the intercept term so the following character
strings will all return rankings based on the intercept (<em>provided that
they do not match the name of another random coefficient for that factor</em>):
<code>c("(Intercept)", "Int", "intercep", ...)</code>.</p>
</td></tr>
<tr><td><code id="REimpact_+3A_breaks">breaks</code></td>
<td>
<p>an integer representing the number of bins to divide the group
effects into, the default is 3; alternatively it can specify breaks from 0-100
for how to cut the expected rank distribution</p>
</td></tr>
<tr><td><code id="REimpact_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="#topic+predictInterval">predictInterval</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function predicts the response at every level in the random effect term
specified by the user. Then, the expected rank of each group level is binned
to the number of bins specified by the user. Finally, a weighted mean of the
fitted value for all observations in each bin of the expected ranks is
calculated using the inverse of the variance as the weight &ndash; so that less
precise estimates are downweighted in the calculation of the mean for the bin.
Finally, a standard error for the bin mean is calculated.
</p>
<p>This function uses the formula for variance of a weighted mean
recommended by Cochran (1977).
</p>


<h3>Value</h3>

<p>A data.frame with all unique combinations of the number of cases, rows
in the newdata element, and number of bins:
</p>

<dl>
<dt>case</dt><dd><p>The row number of the observation from newdata.</p>
</dd>
<dt>bin</dt><dd><p>The ranking bin for the expected rank, the higher the bin number,
the greater the expected rank of the groups in that bin.</p>
</dd>
<dt>AvgFitWght</dt><dd><p>The weighted mean of the fitted values for case i in bin k</p>
</dd>
<dt>AvgFitWghtSE</dt><dd><p>The standard deviation of the mean of the fitted values
for case i in bin k.</p>
</dd>
<dt>nobs</dt><dd><p>The number of group effects contained in that bin.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gatz, DF and Smith, L. The Standard Error of a Weighted Mean Concentration.
I. Bootstrapping vs other methods. <em>Atmospheric Environment</em>.
1995;11(2)1185-1193. Available at
<a href="https://www.sciencedirect.com/science/article/pii/135223109400210C">https://www.sciencedirect.com/science/article/pii/135223109400210C</a>
</p>
<p>Cochran, WG. 1977. Sampling Techniques (3rd Edition). Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectedRank">expectedRank</a></code>, <code><a href="#topic+predictInterval">predictInterval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#For a one-level random intercept model
m1 &lt;- lmer(Reaction ~ Days + (1 | Subject), sleepstudy)
m1.er &lt;- REimpact(m1, newdata = sleepstudy[1, ], breaks = 2)
#For a one-level random intercept model with multiple random terms
m2 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
#ranked by the random slope on Days
m2.er1 &lt;- REimpact(m2,  newdata = sleepstudy[1, ],
           groupFctr = "Subject", term="Days")
#ranked by the random intercept
m2.er2 &lt;- REimpact(m2, newdata = sleepstudy[1, ],
             groupFctr = "Subject", term="int")

# You can also pass additional arguments to predictInterval through REimpact
g1 &lt;- lmer(y ~ lectage + studage + (1|d) + (1|s), data=InstEval)
zed &lt;- REimpact(g1, newdata = InstEval[9:12, ], groupFctr = "d", n.sims = 50,
                include.resid.var = TRUE)
zed2 &lt;- REimpact(g1, newdata = InstEval[9:12, ], groupFctr = "s", n.sims = 50,
                 include.resid.var = TRUE)
zed3 &lt;- REimpact(g1, newdata = InstEval[9:12, ], groupFctr = "d", breaks = 5,
                n.sims = 50, include.resid.var = TRUE)

</code></pre>

<hr>
<h2 id='REmargins'>Calculate the predicted value for each observation across the distribution
of the random effect terms.</h2><span id='topic+REmargins'></span>

<h3>Description</h3>

<p><code>REmargins</code> calculates the average predicted value for each row of a
new data frame across the distribution of <code><a href="#topic+expectedRank">expectedRank</a></code> for a
merMod object. This allows the user to make meaningful comparisons about the
influence of random effect terms on the scale of the response variable,
for user-defined inputs, and accounting for the variability in grouping terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REmargins(
  merMod,
  newdata = NULL,
  groupFctr = NULL,
  term = NULL,
  breaks = 4,
  .parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REmargins_+3A_mermod">merMod</code></td>
<td>
<p>An object of class merMod</p>
</td></tr>
<tr><td><code id="REmargins_+3A_newdata">newdata</code></td>
<td>
<p>a data frame of observations to calculate group-level differences
for</p>
</td></tr>
<tr><td><code id="REmargins_+3A_groupfctr">groupFctr</code></td>
<td>
<p>The name of the grouping factor over which the random
coefficient of interest varies.  This is the variable to the right of the
pipe, <code>|</code>, in the [g]lmer formula. This parameter is optional, if not
specified, it will perform the calculation for the first effect listed
by <code>ranef</code>. If the length is &gt; 1 then the combined effect of all
listed groups will calculated and marginalized over co-occurences of those
groups if desired.</p>
</td></tr>
<tr><td><code id="REmargins_+3A_term">term</code></td>
<td>
<p>The name of the random coefficient of interest. This is the
variable to the left of the pipe, <code>|</code>, in the [g]lmer formula. Partial
matching is attempted on the intercept term so the following character
strings will all return rankings based on the intercept (<em>provided that
they do not match the name of another random coefficient for that factor</em>):
<code>c("(Intercept)", "Int", "intercep", ...)</code>.</p>
</td></tr>
<tr><td><code id="REmargins_+3A_breaks">breaks</code></td>
<td>
<p>an integer representing the number of bins to divide the group
effects into, the default is 3.</p>
</td></tr>
<tr><td><code id="REmargins_+3A_.parallel">.parallel</code></td>
<td>
<p>logical should parallel computation be used, default is TRUE</p>
</td></tr>
<tr><td><code id="REmargins_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="#topic+predictInterval">predictInterval</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simulates the
</p>
<p>The function predicts the response at every level in the random effect term
specified by the user. Then, the expected rank of each group level is binned
to the number of bins specified by the user. Finally, a weighted mean of the
fitted value for all observations in each bin of the expected ranks is
calculated using the inverse of the variance as the weight &ndash; so that less
precise estimates are downweighted in the calculation of the mean for the bin.
Finally, a standard error for the bin mean is calculated.
</p>


<h3>Value</h3>

<p>A data.frame with all unique combinations of the number of cases, rows
in the newdata element:
</p>

<dl>
<dt>...</dt><dd><p>The columns of the original data taken from <code>newdata</code></p>
</dd>
<dt>case</dt><dd><p>The row number of the observation from newdata. Each row in newdata will be
repeated for all unique levels of the grouping_var, term, and breaks.</p>
</dd>
<dt>grouping_var</dt><dd><p>The grouping variable the random effect is being marginalized over.</p>
</dd>
<dt>term</dt><dd><p>The term for the grouping variable the random effect is being marginalized over.</p>
</dd>
<dt>breaks</dt><dd><p>The ntile of the effect size for <code>grouping_var</code> and <code>term</code></p>
</dd>
<dt>original_group_level</dt><dd><p>The original grouping value for this <code>case</code></p>
</dd>
<dt>fit_combined</dt><dd><p>The predicted value from <code>predictInterval</code> for this case simulated
at the Nth ntile of the expected rank distribution of <code>grouping_var</code> and <code>term</code></p>
</dd>
<dt>upr_combined</dt><dd><p>The upper bound of the predicted value.</p>
</dd>
<dt>lwr_combined</dt><dd><p>The lower bound of the predicted value.</p>
</dd>
<dt>fit_XX</dt><dd><p>For each grouping term in newdata the predicted value is decomposed into its
fit components via predictInterval and these are all returned here</p>
</dd>
<dt>upr_XX</dt><dd><p>The upper bound for the effect of each grouping term</p>
</dd>
<dt>lwr_XX</dt><dd><p>The lower bound for the effect of each grouping term</p>
</dd>
<dt>fit_fixed</dt><dd><p>The predicted fit with all the grouping terms set to 0 (average)</p>
</dd>
<dt>upr_fixed</dt><dd><p>The upper bound fit with all the grouping terms set to 0 (average)</p>
</dd>
<dt>lwr_fixed</dt><dd><p>The lower bound fit with all the grouping terms set to 0 (average)</p>
</dd>
</dl>



<h3>References</h3>

<p>Gatz, DF and Smith, L. The Standard Error of a Weighted Mean Concentration.
I. Bootstrapping vs other methods. <em>Atmospheric Environment</em>.
1995;11(2)1185-1193. Available at
<a href="https://www.sciencedirect.com/science/article/pii/135223109400210C">https://www.sciencedirect.com/science/article/pii/135223109400210C</a>
</p>
<p>Cochran, WG. 1977. Sampling Techniques (3rd Edition). Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expectedRank">expectedRank</a></code>, <code><a href="#topic+predictInterval">predictInterval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
mfx &lt;- REmargins(merMod = fm1, newdata = sleepstudy[1:10,])

# You can also pass additional arguments to predictInterval through REimpact
 g1 &lt;- lmer(y ~ lectage + studage + (1|d) + (1|s), data=InstEval)
 margin_df &lt;- REmargins(g1, newdata = InstEval[20:25, ], groupFctr = c("s"),
                        breaks = 4)
 margin_df &lt;- REmargins(g1, newdata = InstEval[20:25, ], groupFctr = c("d"),
                         breaks = 3)

</code></pre>

<hr>
<h2 id='reOnly'>Random Effects formula only</h2><span id='topic+reOnly'></span>

<h3>Description</h3>

<p>Random Effects formula only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reOnly(f, response = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reOnly_+3A_f">f</code></td>
<td>
<p>a model formula</p>
</td></tr>
<tr><td><code id="reOnly_+3A_response">response</code></td>
<td>
<p>logical, should the result include the response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formula
</p>

<hr>
<h2 id='REquantile'>Identify group level associated with RE quantile</h2><span id='topic+REquantile'></span>

<h3>Description</h3>

<p>For a user specified quantile (or quantiles) of the random effect
terms in a merMod object. This allows the user to easily identify the observation
associated with the nth percentile effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REquantile(merMod, quantile, groupFctr, term = "(Intercept)")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REquantile_+3A_mermod">merMod</code></td>
<td>
<p>a merMod object with one or more random effect levels</p>
</td></tr>
<tr><td><code id="REquantile_+3A_quantile">quantile</code></td>
<td>
<p>a numeric vector with values between 0 and 100 for quantiles</p>
</td></tr>
<tr><td><code id="REquantile_+3A_groupfctr">groupFctr</code></td>
<td>
<p>a character of the name of the random effect grouping factor to extract
quantiles from</p>
</td></tr>
<tr><td><code id="REquantile_+3A_term">term</code></td>
<td>
<p>a character of the random effect to extract for the grouping factor
specified. Default is the intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the level of the random effect grouping term that corresponds
to each quantile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
REquantile(fm1, quantile = 0.25, groupFctr = "Subject")
REquantile(fm1, quantile = 0.25, groupFctr = "Subject", term = "Days")

</code></pre>

<hr>
<h2 id='REsdExtract'>Extract the standard deviation of the random effects from a merMod object</h2><span id='topic+REsdExtract'></span>

<h3>Description</h3>

<p>Extract the standard deviation of the random effects from a merMod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REsdExtract(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REsdExtract_+3A_model">model</code></td>
<td>
<p>an object that inherits from class merMod</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector for standard deviations of the random effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
REsdExtract(fm1)
</code></pre>

<hr>
<h2 id='REsim'>Simulate random effects from merMod
<code>REsim</code> simulates random effects from merMod object posterior distributions</h2><span id='topic+REsim'></span>

<h3>Description</h3>

<p>Simulate random effects from merMod
<code>REsim</code> simulates random effects from merMod object posterior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REsim(merMod, n.sims = 200, oddsRatio = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REsim_+3A_mermod">merMod</code></td>
<td>
<p>a merMod object from the lme4 package</p>
</td></tr>
<tr><td><code id="REsim_+3A_n.sims">n.sims</code></td>
<td>
<p>number of simulations to use</p>
</td></tr>
<tr><td><code id="REsim_+3A_oddsratio">oddsRatio</code></td>
<td>
<p>logical, should parameters be converted to odds ratios?</p>
</td></tr>
<tr><td><code id="REsim_+3A_seed">seed</code></td>
<td>
<p>numeric, optional argument to set seed for simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the Gelman sim technique to build empirical Bayes estimates.
Uses the sim function in the arm package
</p>


<h3>Value</h3>

<p>a data frame with the following columns
</p>

<dl>
<dt><code>groupFctr</code></dt><dd><p>Name of the grouping factor</p>
</dd>
<dt><code>groupID</code></dt><dd><p>Level of the grouping factor</p>
</dd>
<dt><code>term</code></dt><dd><p>Name of random term (intercept/coefficient)</p>
</dd>
<dt><code>mean</code></dt><dd><p>Mean of the simulations</p>
</dd>
<dt><code>median</code></dt><dd><p>Median of the simulations</p>
</dd>
<dt><code>sd</code></dt><dd><p>Standard deviation of the simulations, <code>NA</code> if <code>oddsRatio=TRUE</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>require(lme4)
m2 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
re2 &lt;- REsim(m2, 25)
head(re2)
</code></pre>

<hr>
<h2 id='reTermCount'>Count the number of random effect terms</h2><span id='topic+reTermCount'></span>

<h3>Description</h3>

<p>Count the number of random effect terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reTermCount(model)
</code></pre>


<h3>Source</h3>

<p>From lme4 package
</p>

<hr>
<h2 id='reTermNames'>Get names of random effect terms in a model object</h2><span id='topic+reTermNames'></span>

<h3>Description</h3>

<p>Get names of random effect terms in a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reTermNames(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reTermNames_+3A_model">model</code></td>
<td>
<p>a merMod object with random effect terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with rows for each term with columns naming the grouping
term and the effect type
</p>

<hr>
<h2 id='RHSForm'>Parse merMod formulas</h2><span id='topic+RHSForm'></span>

<h3>Description</h3>

<p>Parse merMod formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RHSForm(form, as.form = FALSE)
</code></pre>

<hr>
<h2 id='RMSE.merMod'>Estimate the Root Mean Squared Error (RMSE) for a lmerMod</h2><span id='topic+RMSE.merMod'></span>

<h3>Description</h3>

<p>Extract the Root Mean Squared Error for a lmerMod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSE.merMod(merMod, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RMSE.merMod_+3A_mermod">merMod</code></td>
<td>
<p>a lmerMod object from the lme4 package</p>
</td></tr>
<tr><td><code id="RMSE.merMod_+3A_scale">scale</code></td>
<td>
<p>logical, should the result be returned on the scale of
response variable standard deviations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric which represents the RMSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(lme4)
m2 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
RMSE.merMod(m2)
</code></pre>

<hr>
<h2 id='sanitizeNames'>Clean up variable names in data frames</h2><span id='topic+sanitizeNames'></span>

<h3>Description</h3>

<p>Strips out transformations from variable names in data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitizeNames(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sanitizeNames_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with variable names cleaned to remove factor() construction
</p>

<hr>
<h2 id='setup_parallel'>Set up parallel environment</h2><span id='topic+setup_parallel'></span>

<h3>Description</h3>

<p>Set up parallel environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_parallel()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='shinyMer'>Launch a shiny app to explore your merMod interactively</h2><span id='topic+shinyMer'></span>

<h3>Description</h3>

<p><code>shinyMer</code> launches a shiny app that allows you to interactively
explore an estimated merMod using functions from <code>merTools</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shinyMer(merMod, simData = NULL, pos = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shinyMer_+3A_mermod">merMod</code></td>
<td>
<p>An object of class &quot;merMod&quot;.</p>
</td></tr>
<tr><td><code id="shinyMer_+3A_simdata">simData</code></td>
<td>
<p>A data.frame to make predictions from (optional). If
NULL, then the user can only make predictions using the data in
the frame slot of the merMod object.</p>
</td></tr>
<tr><td><code id="shinyMer_+3A_pos">pos</code></td>
<td>
<p>The position of the environment to export function arguments to.
Defaults to 1, the global environment, to allow shiny to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shiny app
</p>

<hr>
<h2 id='shuffle'>Randomly reorder a dataframe</h2><span id='topic+shuffle'></span>

<h3>Description</h3>

<p>Randomly reorder a dataframe by row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of the same dimensions with the rows reordered
randomly
</p>

<hr>
<h2 id='stripAttributes'>Remove attributes from a data.frame</h2><span id='topic+stripAttributes'></span>

<h3>Description</h3>

<p>Strips attributes off of a data frame that come with a merMod model.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stripAttributes(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stripAttributes_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with variable names cleaned to remove all attributes except for
names, row.names, and class
</p>

<hr>
<h2 id='subBoot'>Bootstrap a subset of an lme4 model</h2><span id='topic+subBoot'></span>

<h3>Description</h3>

<p>Bootstrap a subset of an lme4 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subBoot(merMod, n = NULL, FUN, R = 100, seed = NULL, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subBoot_+3A_mermod">merMod</code></td>
<td>
<p>a valid merMod object</p>
</td></tr>
<tr><td><code id="subBoot_+3A_n">n</code></td>
<td>
<p>the number of rows to sample from the original data
in the merMod object, by default will resample the entire model frame</p>
</td></tr>
<tr><td><code id="subBoot_+3A_fun">FUN</code></td>
<td>
<p>the function to apply to each bootstrapped model</p>
</td></tr>
<tr><td><code id="subBoot_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replicates, default is 100</p>
</td></tr>
<tr><td><code id="subBoot_+3A_seed">seed</code></td>
<td>
<p>numeric, optional argument to set seed for simulations</p>
</td></tr>
<tr><td><code id="subBoot_+3A_warn">warn</code></td>
<td>
<p>logical, if TRUE, warnings from lmer will be issued, otherwise they will be suppressed
default is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to estimate parameters of a
large merMod object using bootstraps on a subset of the data.
</p>


<h3>Value</h3>

<p>a data.frame of parameters extracted from each of the R replications.
The original values are appended to the top of the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
resultMatrix &lt;- subBoot(fm1, n = 160, FUN = thetaExtract, R = 20)

</code></pre>

<hr>
<h2 id='subsetList'>Subset a data.frame using a list of conditions</h2><span id='topic+subsetList'></span>

<h3>Description</h3>

<p>Split a data.frame by elements in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetList(data, list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsetList_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="subsetList_+3A_list">list</code></td>
<td>
<p>a named list of splitting conditions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with values that match the conditions in the list
</p>

<hr>
<h2 id='sum.mm'>Title</h2><span id='topic+sum.mm'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mm'
sum(
  object,
  correlation = (p &lt;= getOption("lme4.summary.cor.max")),
  use.hessian = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum.mm_+3A_object">object</code></td>
<td>
<p>a merMod object</p>
</td></tr>
<tr><td><code id="sum.mm_+3A_correlation">correlation</code></td>
<td>
<p>optional p value</p>
</td></tr>
<tr><td><code id="sum.mm_+3A_use.hessian">use.hessian</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="sum.mm_+3A_...">...</code></td>
<td>
<p>additional arguments to pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary of the object
</p>

<hr>
<h2 id='summary.merModList'>Print the results of a merMod list</h2><span id='topic+summary.merModList'></span>

<h3>Description</h3>

<p>Print the results of a merMod list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merModList'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.merModList_+3A_object">object</code></td>
<td>
<p>a modList of class merModList</p>
</td></tr>
<tr><td><code id="summary.merModList_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summary content printed to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
print(mod)
</code></pre>

<hr>
<h2 id='superFactor'>Create a factor with unobserved levels</h2><span id='topic+superFactor'></span>

<h3>Description</h3>

<p>Create a factor variable and include unobserved levels
for compatibility with model prediction functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superFactor(x, fullLev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="superFactor_+3A_x">x</code></td>
<td>
<p>a vector to be converted to a factor</p>
</td></tr>
<tr><td><code id="superFactor_+3A_fulllev">fullLev</code></td>
<td>
<p>a vector of factor levels to be assigned to x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor variable with all observed levels of x and all levels
of x in fullLev
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
regularFactor &lt;- c("A", "B", "C")
regularFactor &lt;- factor(regularFactor)
levels(regularFactor)
# Now make it super
newLevs &lt;- c("D", "E", "F")
regularFactor &lt;- superFactor(regularFactor, fullLev = newLevs)
levels(regularFactor) # now super

</code></pre>

<hr>
<h2 id='thetaExtract'>Extract theta parameters from a merMod model</h2><span id='topic+thetaExtract'></span>

<h3>Description</h3>

<p>A convenience function that returns the theta parameters for a
<code>merMod</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaExtract(merMod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thetaExtract_+3A_mermod">merMod</code></td>
<td>
<p>a valid merMod object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the covariance, theta, parameters from a <code>merMod</code>
</p>


<h3>See Also</h3>

<p>merMod
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
thetaExtract(fm1) #(a numeric vector of the covariance parameters)
</code></pre>

<hr>
<h2 id='VarCorr.merModList'>Extract the variances and correlations for random effects from a merMod list</h2><span id='topic+VarCorr.merModList'></span>

<h3>Description</h3>

<p>Extract the variances and correlations for random effects from a merMod list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merModList'
VarCorr(x, sigma = 1, rdig = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarCorr.merModList_+3A_x">x</code></td>
<td>
<p>for <code>VarCorr</code>: a fitted model object, usually an object inheriting from
class <code>merMod</code>. For <code>as.data.frame</code>, a
<code>VarCorr.merMod</code> object returned from <code>VarCorr</code>.</p>
</td></tr>
<tr><td><code id="VarCorr.merModList_+3A_sigma">sigma</code></td>
<td>
<p>an optional numeric value used as a multiplier for the
standard deviations.</p>
</td></tr>
<tr><td><code id="VarCorr.merModList_+3A_rdig">rdig</code></td>
<td>
<p>the number of digits to round to, integer</p>
</td></tr>
<tr><td><code id="VarCorr.merModList_+3A_...">...</code></td>
<td>
<p>Ignored for the <code>as.data.frame</code> method; passed to
other <code><a href="base.html#topic+print">print</a>()</code> methods for the <code>print()</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements &quot;stddev&quot; and &quot;correlation&quot; for the standard
deviations and correlations averaged across models in the list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_list &lt;- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml &lt;- "Reaction ~ Days + (Days | Subject)"
mod &lt;- lmerModList(fml, data = sim_list)
VarCorr(mod)
</code></pre>

<hr>
<h2 id='wiggle'>Assign an observation to different values</h2><span id='topic+wiggle'></span>

<h3>Description</h3>

<p>Creates a new data.frame with copies of the original observation,
each assigned to a different user-specified value of a variable. Allows the
user to look at the effect on predicted values of changing either a single variable
or multiple variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiggle(data, varlist, valueslist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wiggle_+3A_data">data</code></td>
<td>
<p>a data frame with one or more observations to be reassigned</p>
</td></tr>
<tr><td><code id="wiggle_+3A_varlist">varlist</code></td>
<td>
<p>a character vector specifying the name(s) of the variable to adjust</p>
</td></tr>
<tr><td><code id="wiggle_+3A_valueslist">valueslist</code></td>
<td>
<p>a list of vectors with the values to assign to var</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the variable specified is a factor, then wiggle will return it
as a character.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with each row assigned to the one of the new variable combinations.
All variable combinations are returned, eg wiggling two variables with 3 and 4 variables
respectively will return a new dataset with <code>3 * 4 = 12</code> observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
wiggle(iris[3,], varlist = "Sepal.Width", valueslist = list(c(1, 2, 3, 5)))
wiggle(iris[3:5,], "Sepal.Width", valueslist = list(c(1, 2, 3, 5)))
wiggle(iris[3,], c("Sepal.Width", "Petal.Length"), list(c(1,2,3,5), c(3,5,6)))
wiggle(iris[3:5,], c("Sepal.Width", "Petal.Length"), list(c(1,2,3,5), c(3,5,6)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
