<!DOCTYPE html><html><head><title>Help for package ConnMatTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ConnMatTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betasVectorDefault'><p>Compute vector of beta values</p></a></li>
<li><a href='#BevertonHolt'><p>Beverton-Holt settler-recruit relationship</p></a></li>
<li><a href='#chile.loco'><p>Connectivity matrix for loco (Concholepas concholepas) from Chile</p></a></li>
<li><a href='#ConnMatTools'><p>Tools for working with connectivity matrices</p></a></li>
<li><a href='#d.mix.dists.func'><p>Returns probability density function (PDF) for a mix of marked and unmarked</p>
individuals</a></li>
<li><a href='#d.rel.conn.beta.prior'><p>Estimate the probability distribution of relative connectivity values</p>
assuming a Beta-distributed prior</a></li>
<li><a href='#d.rel.conn.dists.func'><p>Functions for estimating the probability distribution for relative</p>
connectivity given a pair of distributions for scores for marked and unmarked
individuals</a></li>
<li><a href='#d.rel.conn.finite.settlement'><p>Estimate the probability distribution for the number of settlers originating</p>
at a site given a sample from a finite settler pool</a></li>
<li><a href='#d.rel.conn.multinomial.unnorm'><p>Calculates unnormalized probability density for relative connectivity values</p>
from multiple distinct sites</a></li>
<li><a href='#d.rel.conn.multiple'><p>Functions for estimating the probability distribution of relative</p>
connectivity values as a weighted sum over possible input parameters</a></li>
<li><a href='#d.rel.conn.unif.prior'><p>Estimate the probability distribution of relative connectivity values</p>
assuming a uniform prior distribution</a></li>
<li><a href='#damselfish.lods'><p>Sample LOD score data for simulated and real parent-child pairs</p></a></li>
<li><a href='#DispersalPerRecruitModel'><p>Population dynamics model based on lifetime-egg-production</p></a></li>
<li><a href='#DPRHomerangeGravity'><p>Extended DPR population dynamics model to include homerange movement</p></a></li>
<li><a href='#dual.mark.transmission'><p>Fraction of eggs marked for male and female mark transmission</p></a></li>
<li><a href='#eigs'><p>Compute some eigenvalues of a matrix</p></a></li>
<li><a href='#gammaParamsConvert'><p>Gamma distribution shape and scale parameters from mean and standard</p>
deviation, or vice-versa</a></li>
<li><a href='#hockeyStick'><p>Hockey-stick settler-recruit relationship</p></a></li>
<li><a href='#laplacianConnMat'><p>Uniform Laplacian connectivity matrix</p></a></li>
<li><a href='#localRetention'><p>Local retention of a connectivity matrix</p></a></li>
<li><a href='#mergeSubpops'><p>Merge subpopulations</p></a></li>
<li><a href='#optim.rel.conn.dists'><p>Maximum-likelihood estimate for relative connectivity given two distributions</p>
for scores for marked and unmarked individuals</a></li>
<li><a href='#optimalSplitConnMat'><p>Iteratively, optimally split a connectivity matrix</p></a></li>
<li><a href='#prob.marked'><p>Returns probability a set of observations correspond to marked individuals</p></a></li>
<li><a href='#protectedAreaSelection'><p>Function to select optimal network of protected areas based on connectivity</p></a></li>
<li><a href='#qualitySubpops'><p>Quality measure for subpopulation division</p></a></li>
<li><a href='#r.marked.egg.fraction'><p>Estimates of fraction of eggs marked accounting for variability in</p>
reproductive output</a></li>
<li><a href='#recSplitConnMat'><p>Recursively subdivides a set of subpoplations</p></a></li>
<li><a href='#reducedConnMat'><p>Reduced connectivity matrix according to a set of subpopulations</p></a></li>
<li><a href='#relativeLocalRetention'><p>Relative local retention of a connectivity matrix</p></a></li>
<li><a href='#selfRecruitment'><p>Self recruitment of a connectivity matrix</p></a></li>
<li><a href='#settlerRecruitSlopeCorrection'><p>Correction for slope of settler-recruit relationship</p></a></li>
<li><a href='#splitConnMat'><p>Split connectivity matrix into subpopulations</p></a></li>
<li><a href='#stepfun.hist'><p>Create a probability density step function from a histogram object</p></a></li>
<li><a href='#subpopsVectorToList'><p>Convert subpopulation vector to a list of indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Working with Connectivity Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-03</td>
</tr>
<tr>
<td>Author:</td>
<td>David M. Kaplan &lt;dmkaplan2000@gmail.com&gt; [cre,aut], Marco Andrello &lt;marco.andrello@gmail.com&gt; [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David M. Kaplan &lt;dmkaplan2000@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Collects several different methods for analyzing and
    working with connectivity data in R.  Though primarily oriented towards
    marine larval dispersal, many of the methods are general and useful for
    terrestrial systems as well.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dmkaplan2000/ConnMatTools.git">https://github.com/dmkaplan2000/ConnMatTools.git</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph,mcmc</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ConnMatTools.R' 'eigs.R' 'Jacobi_EPT_reserve_selection.R'
'utils.R' 'connectivity_estimation.R'
'connectivity_estimation.distributions.R'
'connectivity_estimation.finite_settlement.R'
'connectivity_estimation.multinomial.R'
'connectivity_estimation.multiple.R' 'datasets.R' 'dpr_model.R'
'estimating_marked_egg_fraction.R' 'retentionStats.R'
'jacobi_etal_2012.R'</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-03 10:15:59 UTC; dmk</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-03 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='betasVectorDefault'>Compute vector of beta values</h2><span id='topic+betasVectorDefault'></span>

<h3>Description</h3>

<p>Helper function to compute a set of beta values using formula used in Jacobi
et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betasVectorDefault(n, steps = 10, cycles = 3/4, coeff = 0.8, pwr = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betasVectorDefault_+3A_n">n</code></td>
<td>
<p>numerator of formula from Jacobi et al. (2012).  Normally will be
the number of columns in the connectivity matrix if one normalizes the
columns (otherwise, it would typically be <code>N^2 / sum(conn.mat)</code>, where
<code>N</code> is the number of columns of <code>conn.mat</code>.</p>
</td></tr>
<tr><td><code id="betasVectorDefault_+3A_steps">steps</code></td>
<td>
<p>number of beta values to return.  Defaults to 10.</p>
</td></tr>
<tr><td><code id="betasVectorDefault_+3A_cycles">cycles</code></td>
<td>
<p>how many cycles of <code>2*pi</code> to do.</p>
</td></tr>
<tr><td><code id="betasVectorDefault_+3A_coeff">coeff</code></td>
<td>
<p>coefficient in front of sine function</p>
</td></tr>
<tr><td><code id="betasVectorDefault_+3A_pwr">pwr</code></td>
<td>
<p>exponent in denominator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of beta values
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson, P. R. 2012.
Identification of subpopulations from connectivity matrices. Ecography, 35:
1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+optimalSplitConnMat">optimalSplitConnMat</a></code>
</p>

<hr>
<h2 id='BevertonHolt'>Beverton-Holt settler-recruit relationship</h2><span id='topic+BevertonHolt'></span>

<h3>Description</h3>

<p>Calculates recruitment based on the settler-recruit relationship from 
Beverton &amp; Holt (1957): <code> slope * settlers / (1+slope*settlers/Rmax) </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BevertonHolt(S, slope = 1/0.35, Rmax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BevertonHolt_+3A_s">S</code></td>
<td>
<p>a vector of settlement values, 1 for each site.</p>
</td></tr>
<tr><td><code id="BevertonHolt_+3A_slope">slope</code></td>
<td>
<p>slope at the origin of the settler-recruit relationship.  Can be
a vector of same length as <code>S</code>.</p>
</td></tr>
<tr><td><code id="BevertonHolt_+3A_rmax">Rmax</code></td>
<td>
<p>maximum recruitment value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slope</code> and <code>Rmax</code> can both either be scalars or vectors of the
same length as <code>S</code>.
</p>


<h3>Value</h3>

<p>A vector of recruitment values.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Beverton RJH, Holt SJ (1957) On the dynamics of exploited fish 
populations. H.M.S.O., London. 533 pp.
</p>

<hr>
<h2 id='chile.loco'>Connectivity matrix for loco (Concholepas concholepas) from Chile</h2><span id='topic+chile.loco'></span>

<h3>Description</h3>

<p>Sample connectivity matrix representing potential larval dispersal of loco 
(Concholepas concholepas) from Chile.  The matrix is for 89 sites along the 
coast of Chile and is derived from a theoretical larval transport model.
</p>


<h3>Format</h3>

<p>A square 89x89 matrix with real, positive elements.</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Garavelli L, Kaplan DM, Colas F, Stotz W, Yannicelli B, Lett C
(2014) Identifying appropriate spatial scales for marine conservation and
management using a larval dispersal model: The case of Concholepas
concholepas (loco) in Chile. Progress in Oceanography 124:42-53.
<a href="http://dx.doi.org/10.1016/j.pocean.2014.03.011">doi:10.1016/j.pocean.2014.03.011</a>
</p>

<hr>
<h2 id='ConnMatTools'>Tools for working with connectivity matrices</h2><span id='topic+ConnMatTools'></span>

<h3>Description</h3>

<p>Tools for Working with Connectivity Data
</p>


<h3>Details</h3>

<p>Collects several different methods for analyzing and
working with connectivity data in R.  Though primarily oriented
towards marine larval dispersal, many of the methods are general
and useful for terrestrial systems as well.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ConnMatTools</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-02-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>
<p>Marco Andrello <a href="mailto:marco.andrello@gmail.com">marco.andrello@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., and Jonsson, P. R. 2011. Optimal networks of 
nature reserves can be found through eigenvalue perturbation theory of the 
connectivity matrix. Ecological Applications, 21: 1861-1870.
</p>
<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson,
P. R. 2012. Identification of subpopulations from connectivity
matrices. Ecography, 35: 1004-1016.
</p>
<p>Gruss, A., Kaplan, D. M., and Lett, C. 2012. Estimating local 
settler-recruit relationship parameters for complex spatially explicit 
models. Fisheries Research, 127-128: 34-39.
</p>
<p>Kaplan, D. M., Botsford, L. W., and Jorgensen, S. 2006. Dispersal 
per recruit: An efficient method for assessing sustainability in marine 
reserve networks. Ecological Applications, 16: 2248-2263.
</p>
<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>
<p>White, J. W. 2010. Adapting the steepness parameter from 
stock-recruit curves for use in spatially explicit models. Fisheries 
Research, 102: 330-334.
</p>
<p>Gruss A, Kaplan DM, Hart DR (2011) Relative Impacts of Adult
Movement, Larval Dispersal and Harvester Movement on the Effectiveness of
Reserve Networks. PLoS ONE 6:e19960
</p>
<p>Beverton RJH, Holt SJ (1957) On the dynamics of exploited fish
populations. H.M.S.O., London. 533 pp.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+optimalSplitConnMat">optimalSplitConnMat</a></code>, <code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: optimalSplitConnMat(CM)
</code></pre>

<hr>
<h2 id='d.mix.dists.func'>Returns probability density function (PDF) for a mix of marked and unmarked 
individuals</h2><span id='topic+d.mix.dists.func'></span>

<h3>Description</h3>

<p>This function returns a probability density function (PDF) for scores for a 
mix of marked and unmarked individuals with known fraction of marked 
individuals. The distributions for marked individuals and for unmarked 
individuals must be known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.mix.dists.func(d.unmarked, d.marked)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.mix.dists.func_+3A_d.unmarked">d.unmarked</code></td>
<td>
<p>A function representing the PDF of unmarked individuals. 
Must be normalized so that it integrates to 1 for the function to work 
properly.</p>
</td></tr>
<tr><td><code id="d.mix.dists.func_+3A_d.marked">d.marked</code></td>
<td>
<p>A function representing the PDF of marked individuals.  Must 
be normalized so that it integrates to 1 for the function to work properly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function representing the PDF of observations drawn from the mixed 
distribution of marked and unmarked individuals.  The function takes two 
arguments: <code>p.marked</code>, the fraction of marked individuals in the
distribution; and <code>obs</code>, a vector of observed score values.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a></code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a></code>.
</p>

<hr>
<h2 id='d.rel.conn.beta.prior'>Estimate the probability distribution of relative connectivity values 
assuming a Beta-distributed prior</h2><span id='topic+d.rel.conn.beta.prior'></span><span id='topic+p.rel.conn.beta.prior'></span><span id='topic+q.rel.conn.beta.prior.func'></span><span id='topic+q.rel.conn.beta.prior'></span>

<h3>Description</h3>

<p>These functions calculate the probability density function 
(<code>d.rel.conn.beta.prior</code>), the probability distribution function (aka 
the cumulative distribution function; <code>p.rel.conn.beta.prior</code>) and the 
quantile function (<code>q.rel.conn.beta.prior</code>) for the relative (to all 
settlers at the destination site) connectivity value for larval transport 
between a source and destination site given a known fraction of marked 
individuals (i.e., eggs) in the source population.  A non-uniform prior is 
used for the relative connectivity value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.rel.conn.beta.prior(
  phi,
  p,
  k,
  n,
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  ...
)

p.rel.conn.beta.prior(
  phi,
  p,
  k,
  n,
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  ...
)

q.rel.conn.beta.prior.func(
  p,
  k,
  n,
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  N = 1000,
  ...
)

q.rel.conn.beta.prior(
  q,
  p,
  k,
  n,
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  N = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.rel.conn.beta.prior_+3A_phi">phi</code></td>
<td>
<p>Vector of fractions of individuals (i.e., eggs) from the source 
population settling at the destination population</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_p">p</code></td>
<td>
<p>Fraction of individuals (i.e., eggs) marked in the source population</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_k">k</code></td>
<td>
<p>Number of marked settlers found in sample</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_n">n</code></td>
<td>
<p>Total number of settlers collected</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_prior.shape1">prior.shape1</code></td>
<td>
<p>First shape parameter for Beta distributed prior. 
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_prior.shape2">prior.shape2</code></td>
<td>
<p>Second shape parameter for Beta distributed prior. 
Defaults to being the same as <code>prior.shape1</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_prior.func">prior.func</code></td>
<td>
<p>Function for prior distribution.  Should take one 
parameter, <code>phi</code>, and return a probability.  Defaults to 
<code>function(phi) dbeta(phi,prior.shape1,prior.shape2)</code>.  If this is
specified, then inputs <code>prior.shape1</code> and <code>prior.shape2</code> are
ignored.</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_...">...</code></td>
<td>
<p>Extra arguments for the <code><a href="stats.html#topic+integrate">integrate</a></code> function used 
for normalization of probability distributions.</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_n">N</code></td>
<td>
<p>Number of points at which to estimate cumulative probability 
function for reverse approximation of quantile distribution. Defaults to 
<code>1000</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.beta.prior_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior distribution for relative connectivity <code>phi</code> defaults to a 
Beta distribution with both shape parameters equal to 0.5.  This is the 
Reference or Jeffreys prior for a binomial distribution parameter.  Both 
shape parameters equal to 1 corresponds to a uniform prior.
</p>
<p>Estimations of the probability distribution are based on numerical 
integration using the <code><a href="stats.html#topic+integrate">integrate</a></code> function, and therefore are 
accurate to the level of that function.  Some modification of the default 
arguments to that function may be necessary to acheive good results for 
certain parameter values.
</p>


<h3>Value</h3>

<p>Vector of probabilities or quantiles, or a function in the case of 
<code><a href="#topic+q.rel.conn.beta.prior.func">q.rel.conn.beta.prior.func</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d.rel.conn.beta.prior</code>: Returns the probability density for 
relative connectivity between a pair of sites
</p>
</li>
<li> <p><code>p.rel.conn.beta.prior</code>: Returns the cumulative probability
distribution for relative connectivity between a paire of sites
</p>
</li>
<li> <p><code>q.rel.conn.beta.prior.func</code>: Returns a function to estimate quantiles for
the probability distribution function for relative connectivity between a
pair of sites.
</p>
</li>
<li> <p><code>q.rel.conn.beta.prior</code>: Estimates quantiles for the probability
distribution function for relative connectivity between a pair of sites
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)

k &lt;- 10 # Number of marked settlers among sample
n.obs &lt;- 87 # Number of settlers in sample

p &lt;- 0.4 # Fraction of eggs that was marked
phi &lt;- seq(0.001,1-0.001,length.out=101) # Values for relative connectivity

# Probability distribution assuming infinite settler pool and uniform prior
drc &lt;- d.rel.conn.unif.prior(phi,p,k,n.obs)
qrc &lt;- q.rel.conn.unif.prior(c(0.025,0.975),p,k,n.obs) # 95% confidence interval

# Probability distribution assuming infinite settler pool and using reference/Jeffreys prior
drp &lt;- d.rel.conn.beta.prior(phi,p,k,n.obs)
prp &lt;- p.rel.conn.beta.prior(phi,p,k,n.obs)
qrp &lt;- q.rel.conn.beta.prior(c(0.025,0.975),p,k,n.obs) # 95% confidence interval

# Make a plot of different distributions
# black = Jeffreys prior; red = uniform prior
# Jeffreys prior draws distribution slightly towards zero
plot(phi,drp,type="l",main="Probability of relative connectivity values",
     xlab=expression(phi),ylab="Probability density")
lines(phi,drc,col="red")
abline(v=qrp,col="black",lty="dashed")
abline(v=qrc,col="red",lty="dashed")
</code></pre>

<hr>
<h2 id='d.rel.conn.dists.func'>Functions for estimating the probability distribution for relative 
connectivity given a pair of distributions for scores for marked and unmarked
individuals</h2><span id='topic+d.rel.conn.dists.func'></span><span id='topic+p.rel.conn.dists.func'></span><span id='topic+q.rel.conn.dists.func'></span>

<h3>Description</h3>

<p>These functions return functions that calculate the probability density 
function (<code>d.rel.conn.dists.func</code>), the probability distribution 
function (aka the cumulative distribution function; 
<code>p.rel.conn.dists.func</code>) and the quantile function 
(<code>q.rel.conn.dists.func</code>) for relative connectivity given a set of 
observed score values, distributions for unmarked and marked individuals, and
an estimate of the fraction of all eggs marked at the source site, <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.rel.conn.dists.func(
  obs,
  d.unmarked,
  d.marked,
  p = 1,
  N = max(100, min(5000, 2 * length(obs))),
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  ...
)

p.rel.conn.dists.func(
  obs,
  d.unmarked,
  d.marked,
  p = 1,
  N = max(100, min(5000, 2 * length(obs))),
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  ...
)

q.rel.conn.dists.func(
  obs,
  d.unmarked,
  d.marked,
  p = 1,
  N = max(100, min(5000, 2 * length(obs))),
  prior.shape1 = 0.5,
  prior.shape2 = prior.shape1,
  prior.func = function(phi) dbeta(phi, prior.shape1, prior.shape2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.rel.conn.dists.func_+3A_obs">obs</code></td>
<td>
<p>Vector of observed score values for potentially marked individuals</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_d.unmarked">d.unmarked</code></td>
<td>
<p>A function representing the PDF of unmarked individuals. 
Must be normalized so that it integrates to 1 for the function to work 
properly.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_d.marked">d.marked</code></td>
<td>
<p>A function representing the PDF of marked individuals.  Must 
be normalized so that it integrates to 1 for the function to work properly.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_p">p</code></td>
<td>
<p>Fraction of individuals (i.e., eggs) marked in the source 
population. Defaults to 1.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_n">N</code></td>
<td>
<p>number of steps between 0 and 1 at which to approximate likelihood 
function as input to <code><a href="stats.html#topic+approxfun">approxfun</a></code>. Defaults to
<code>2*length(obs)</code> so long as that number is comprised between <code>100</code>
and <code>5000</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_prior.shape1">prior.shape1</code></td>
<td>
<p>First shape parameter for Beta distributed prior. 
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_prior.shape2">prior.shape2</code></td>
<td>
<p>Second shape parameter for Beta distributed prior. 
Defaults to being the same as <code>prior.shape1</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_prior.func">prior.func</code></td>
<td>
<p>Function for prior distribution.  Should take one 
parameter, <code>phi</code>, and return a probability.  Defaults to 
<code>function(phi) dbeta(phi,prior.shape1,prior.shape2)</code>.  If this is 
specified, then inputs <code>prior.shape1</code> and <code>prior.shape2</code> are 
ignored.</p>
</td></tr>
<tr><td><code id="d.rel.conn.dists.func_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code><a href="stats.html#topic+integrate">integrate</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalization of the probability distribution is carried out using a 
simple, fixed-step trapezoidal integration scheme.  By default, the number of
steps between relative connectivity values of 0 and 1 defaults to 
<code>2*length(obs)</code> so long as that number is comprised between <code>100</code> 
and <code>5000</code>.
</p>


<h3>Value</h3>

<p>A function that takes one argument (the relative connectivity for 
<code>d.rel.conn.dists.func</code> and <code>p.rel.conn.dists.func</code>; the quantile
for <code>q.rel.conn.dists.func</code>) and returns the probability density, 
cumulative probability or score value, respectively. The returned function 
accepts both vector and scalar input values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d.rel.conn.dists.func</code>: Returns a function that is PDF for relative
connectivity
</p>
</li>
<li> <p><code>p.rel.conn.dists.func</code>: Returns a function that is cumulative
probability distribution for relative connectivity
</p>
</li>
<li> <p><code>q.rel.conn.dists.func</code>: Returns a function that is quantile
function for relative connectivity
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(damselfish.lods)

# Histograms of simulated LODs
l &lt;- seq(-1,30,0.5)
h.in &lt;- hist(damselfish.lods$in.group,breaks=l)
h.out &lt;- hist(damselfish.lods$out.group,breaks=l)

# PDFs for marked and unmarked individuals based on simulations
d.marked &lt;- stepfun.hist(h.in)
d.unmarked &lt;- stepfun.hist(h.out)

# Fraction of adults genotyped at source site
p.adults &lt;- 0.25

# prior.shape1=1 # Uniform prior
prior.shape1=0.5 # Jeffreys prior

# Fraction of eggs from one or more genotyped parents
p &lt;- dual.mark.transmission(p.adults)$p

# PDF for relative connectivity
D &lt;- d.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Estimate most probable value for relative connectivity
phi.mx &lt;- optim.rel.conn.dists(damselfish.lods$real.children,
                                    d.unmarked,d.marked,p)$phi

# Estimate 95% confidence interval for relative connectivity
Q &lt;- q.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Plot it up
phi &lt;- seq(0,1,0.001)
plot(phi,D(phi),type="l",
     xlim=c(0,0.1),
     main="PDF for relative connectivity",
     xlab=expression(phi),
     ylab="Probability density")

abline(v=phi.mx,col="green",lty="dashed")
abline(v=Q(c(0.025,0.975)),col="red",lty="dashed")
</code></pre>

<hr>
<h2 id='d.rel.conn.finite.settlement'>Estimate the probability distribution for the number of settlers originating 
at a site given a sample from a finite settler pool</h2><span id='topic+d.rel.conn.finite.settlement'></span><span id='topic+p.rel.conn.finite.settlement'></span><span id='topic+q.rel.conn.finite.settlement'></span>

<h3>Description</h3>

<p>These functions calculate the probability mass function 
(<code>d.rel.conn.finite.settlement</code>), the cumulative distribution function 
(<code>p.rel.conn.finite.settlement</code>) and the quantile function 
(<code>q.rel.conn.finite.settlement</code>) for the true number of settlers at a 
site that originated in a particular site given a known fraction of marked 
eggs among the eggs originating at the source site, a sample of settlers at 
the destination site, a known fraction of which are marked, and a finite 
settler pool of known size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.rel.conn.finite.settlement(
  n.origin,
  p,
  k,
  n.obs,
  n.settlers,
  prior.n.origin = 1
)

p.rel.conn.finite.settlement(
  n.origin,
  p,
  k,
  n.obs,
  n.settlers,
  prior.n.origin = 1
)

q.rel.conn.finite.settlement(q, p, k, n.obs, n.settlers, prior.n.origin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_n.origin">n.origin</code></td>
<td>
<p>Vector of integers of possible numbers of settlers in the 
cohort that originated at the site of marking. All values should be 
integers <code>&lt;=n.settlers</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_p">p</code></td>
<td>
<p>Fraction of individuals (i.e., eggs) marked in the source population</p>
</td></tr>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_k">k</code></td>
<td>
<p>Number of marked settlers in sample</p>
</td></tr>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_n.obs">n.obs</code></td>
<td>
<p>Total number of settlers collected</p>
</td></tr>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_n.settlers">n.settlers</code></td>
<td>
<p>Total number of settlers at the destination site from which
the <code>n.obs</code> (<code>&lt;=n.settlers</code>) settlers are collected</p>
</td></tr>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_prior.n.origin">prior.n.origin</code></td>
<td>
<p>A prior probability mass function for the number of 
settlers in the cohort originating at the site of marking. Must be a scalar
or a vector of length <code>n.settlers+1</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.finite.settlement_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative connectivity between the source and destination sites is 
calculated as <code>n.origin/n.settlers</code>.
</p>


<h3>Value</h3>

<p>A vector of probabilities or quantiles.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d.rel.conn.finite.settlement</code>: Returns the probability mass 
function for the numbers of settlers in the cohort that originated at the
source site (i.e., site of marking).
</p>
</li>
<li> <p><code>p.rel.conn.finite.settlement</code>: Returns the cumulative distribution 
function for the numbers of settlers in the cohort that originated at the
source site (i.e., site of marking).
</p>
</li>
<li> <p><code>q.rel.conn.finite.settlement</code>: Returns quantiles of the cumulative
distribution function for the numbers of settlers in the cohort that
originated at the source site (i.e., site of marking).
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)

k &lt;- 10 # Number of marked settlers among sample
n.obs &lt;- 87 # Number of settlers in sample
n.settlers &lt;- 100 # Total size of settler pool

p &lt;- 0.4 # Fraction of eggs that was marked
phi &lt;- seq(0,1,length.out=101) # Values for relative connectivity

# Probability distribution assuming infinite settler pool and uniform prior
drc &lt;- d.rel.conn.unif.prior(phi,p,k,n.obs)
prc &lt;- p.rel.conn.unif.prior(phi,p,k,n.obs)
qrc &lt;- q.rel.conn.unif.prior(c(0.025,0.975),p,k,n.obs) # 95% confidence interval

# Test with finite settlement function and large (approx. infinite) settler pool
# Can be a bit slow for large settler pools
dis &lt;- d.rel.conn.finite.settlement(0:(7*n.obs),p,k,n.obs,7*n.obs)

# Quantiles
qis &lt;- q.rel.conn.finite.settlement(c(0.025,0.975),p,k,n.obs,7*n.obs)

# Finite settler pool
dfs &lt;- d.rel.conn.finite.settlement(0:n.settlers,p,k,n.obs,n.settlers)

# Quantiles for the finite settler pool
qfs &lt;- q.rel.conn.finite.settlement(c(0.025,0.975),p,k,n.obs,n.settlers)

# Make a plot of different distributions
plot(phi,drc,type="l",main="Probability of relative connectivity values",
     xlab=expression(phi),ylab="Probability density")
lines(phi,prc,col="blue")
lines((0:(7*n.obs))/(7*n.obs),dis*(7*n.obs),col="black",lty="dashed")
lines((0:n.settlers)/n.settlers,dfs*n.settlers,col="red",lty="dashed")
abline(v=qrc,col="black")
abline(v=qis/(7*n.obs),col="black",lty="dashed")
abline(v=qfs/n.settlers,col="red",lty="dashed")

</code></pre>

<hr>
<h2 id='d.rel.conn.multinomial.unnorm'>Calculates unnormalized probability density for relative connectivity values 
from multiple distinct sites</h2><span id='topic+d.rel.conn.multinomial.unnorm'></span>

<h3>Description</h3>

<p>This functions calculates the unnormalized probability density function for 
the relative (to all settlers at the destination site) connectivity value for
larval transport between multiple source sites to a destination site. An 
arbitrary number of source sites can be evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.rel.conn.multinomial.unnorm(
  phis,
  ps,
  ks,
  n.sample,
  log = FALSE,
  dirichlet.prior.alphas = 1/(length(phis) + 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.rel.conn.multinomial.unnorm_+3A_phis">phis</code></td>
<td>
<p>Vector of fractions of individuals (i.e., eggs) from the source 
populations settling at the destination population</p>
</td></tr>
<tr><td><code id="d.rel.conn.multinomial.unnorm_+3A_ps">ps</code></td>
<td>
<p>Vector of fractions of individuals (i.e., eggs) marked in each of 
the source populations</p>
</td></tr>
<tr><td><code id="d.rel.conn.multinomial.unnorm_+3A_ks">ks</code></td>
<td>
<p>Vector of numbers of marked settlers from each source population 
found in the sample</p>
</td></tr>
<tr><td><code id="d.rel.conn.multinomial.unnorm_+3A_n.sample">n.sample</code></td>
<td>
<p>Vector of total numbers of settlers collected</p>
</td></tr>
<tr><td><code id="d.rel.conn.multinomial.unnorm_+3A_log">log</code></td>
<td>
<p>Boolean indicating whether or not to return the log probability 
density.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.multinomial.unnorm_+3A_dirichlet.prior.alphas">dirichlet.prior.alphas</code></td>
<td>
<p>Parameter value for a Dirichlet prior 
distribution for the <code>phis</code>. Can be a single value for a Dirichlet 
prior with uniform parameters, or a vector of length = 
<code>length(phis)+1</code>. Defaults to <code>1/(length(phis)+1)</code>, the value for
the &quot;reference distance&quot; non-informative prior of Berger et al. 2015.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As this function returns the unnormalized probability density, it must be
normalized somehow to be produce a true probability density.  This can be
acheived using a variety of approaches, including brute force integration of
the unnormalized probability density and MCMC algorithms.
</p>


<h3>Value</h3>

<p>The unnormalized probability density value.  If <code>log=TRUE</code>, then
the logarithm of the probability density value will be returned.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>
<p>Berger JO, Bernardo JM, Sun D (2015) Overall Objective Priors. 
Bayesian Analysis 10:189-221. doi:10.1214/14-BA915
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)

ps &lt;- c(0.7,0.5) # Fraction of eggs "marked" at each source site
ks &lt;- c(4,5) # Number of marked settlers among sample from each source site
n.sample &lt;- 20 # Total sample size.  Must be &gt;= sum(ks)


phis0 = runif(3,min=0.05)
phis0 = phis0 / sum(phis0)
phis0 = phis0[1:2] # Don't include relative connectivity of unknown sites

nbatch=1e4

library(mcmc)
ans = metrop(d.rel.conn.multinomial.unnorm,
             initial=phis0,nbatch=nbatch,scale=0.1,
             log=TRUE,ps=ps,ks=ks,n.sample=n.sample)
# A more serious test would adjust blen and scale to improve results, and would repeat
# multiple times to get results from multiple MCMC chains.

# Plot marginal distribution of relative connectivity from first site
h=hist(ans$batch[,1],xlab="Rel. Conn., Site 1",
       main="Relative Connectivity for Source Site 1")

# For comparison, add on curve that would correspond to single site calculation
phi = seq(0,1,length.out=40)
d1 = d.rel.conn.beta.prior(phi,ps[1],ks[1],n.sample)

lines(phi,d1*nbatch*diff(h$breaks)[1],col="red",lwd=5)

# Image plot of bivariate probability density
t=table(cut(ans$batch[,1],phi),cut(ans$batch[,2],phi))
image(t,col=heat.colors(12)[12:1],xlab="Rel. Conn., Site 1",ylab="Rel. Conn., Site 2")

# Add line indicate region above which one can never find results as that would 
# lead to a total connectivity great than 1
abline(1,-1,col="black",lty="dashed",lwd=3)
</code></pre>

<hr>
<h2 id='d.rel.conn.multiple'>Functions for estimating the probability distribution of relative 
connectivity values as a weighted sum over possible input parameters</h2><span id='topic+d.rel.conn.multiple'></span><span id='topic+p.rel.conn.multiple'></span><span id='topic+q.rel.conn.multiple.func'></span><span id='topic+q.rel.conn.multiple'></span>

<h3>Description</h3>

<p>These functions calculate the probability density function 
(<code>d.rel.conn.multiple</code>), the probability distribution function (aka the 
cumulative distribution function; <code>p.rel.conn.multiple</code>) and the 
quantile function (<code>q.rel.conn.multiple</code>) for the relative (to all 
settlers at the destination site) connectivity value for larval transport 
between a source and destination site. This version allows one to input 
multiple possible fractions of individuals (i.e., eggs) marked at the source 
site, multiple possible numbers of settlers collected and multiple possible 
marked individuals observed in the sample.  This gives one the possibility to
produce ensemble averages over different input parameter values with 
different probabilities of being correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.rel.conn.multiple(
  phi,
  ps,
  ks,
  ns,
  weights = 1,
  d.rel.conn = d.rel.conn.beta.prior,
  ...
)

p.rel.conn.multiple(
  phi,
  ps,
  ks,
  ns,
  weights = 1,
  p.rel.conn = p.rel.conn.beta.prior,
  ...
)

q.rel.conn.multiple.func(
  ps,
  ks,
  ns,
  weights = 1,
  p.rel.conn = p.rel.conn.beta.prior,
  N = 1000,
  ...
)

q.rel.conn.multiple(
  q,
  ps,
  ks,
  ns,
  weights = 1,
  p.rel.conn = p.rel.conn.beta.prior,
  N = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.rel.conn.multiple_+3A_phi">phi</code></td>
<td>
<p>Vector of fractions of individuals (i.e., eggs) from the source 
population settling at the destination population</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_ps">ps</code></td>
<td>
<p>Vector of fractions of individuals (i.e., eggs) marked in the 
source population</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_ks">ks</code></td>
<td>
<p>Vector of numbers of marked settlers found in sample</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_ns">ns</code></td>
<td>
<p>Vector of total numbers of settlers collected</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_weights">weights</code></td>
<td>
<p>Vector of weights for each set of p, k and n values</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_d.rel.conn">d.rel.conn</code></td>
<td>
<p>Function to use to calculate probability density for 
individual combinations of <code>ps</code>, <code>ks</code> and <code>ns</code>. Defaults to 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a></code>.  Could also be 
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a></code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_...">...</code></td>
<td>
<p>Additional arguments for the function <code>d.rel.conn</code> or
<code>p.rel.conn</code></p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_p.rel.conn">p.rel.conn</code></td>
<td>
<p>Function to use to calculate cumulative probability 
distribution for individual combinations of <code>ps</code>, <code>ks</code> and 
<code>ns</code>. Defaults to <code><a href="#topic+p.rel.conn.beta.prior">p.rel.conn.beta.prior</a></code>. Could also be 
<code><a href="#topic+p.rel.conn.unif.prior">p.rel.conn.unif.prior</a></code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_n">N</code></td>
<td>
<p>Number of points at which to estimate cumulative probability 
function for reverse approximation of quantile distribution. Defaults to 
<code>1000</code>.</p>
</td></tr>
<tr><td><code id="d.rel.conn.multiple_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>ps</code>, <code>ks</code>, <code>ns</code> and <code>weights</code> can be scalars or 
vectors of the same length (or lengths divisible into that of the largest 
input parameter).  <code>weights</code> are normalized to sum to 1 before being 
used to sum probabilities from each individual set of input parameters.
</p>


<h3>Value</h3>

<p>Vector of probabilities or quantiles, or a function in the case of 
<code><a href="#topic+q.rel.conn.multiple.func">q.rel.conn.multiple.func</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d.rel.conn.multiple</code>: Estimates quantiles for the probability 
distribution function for relative connectivity between a pair of sites for
multiple possible <code>p</code>, <code>k</code> and <code>n</code> values.
</p>
</li>
<li> <p><code>p.rel.conn.multiple</code>: Estimates the cumulative probability
distribution for relative connectivity between a paire of sites for
multiple possible <code>p</code>, <code>k</code> and <code>n</code> values.
</p>
</li>
<li> <p><code>q.rel.conn.multiple.func</code>: Returns a function to estimate quantiles for
the probability distribution function for relative connectivity between a
pair of sites for multiple possible <code>p</code>, <code>k</code> and <code>n</code> values.
</p>
</li>
<li> <p><code>q.rel.conn.multiple</code>: Estimates quantiles for the probability 
distribution function for relative connectivity between a pair of sites for
multiple possible <code>p</code>, <code>k</code> and <code>n</code> values.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)

# p values have uniform probability between 0.1 and 0.4
p &lt;- seq(0.1,0.8,length.out=100)

# Weights the same for all except first and last, which are halved
w &lt;- rep(1,length(p))
w[1]&lt;-0.5
w[length(w)]&lt;-0.5

n &lt;- 20 # Sample size
k &lt;- 2 # Marked individuals in sample

# phi values to use for plotting distribution
phi &lt;- seq(0,1,0.01)

prior.shape1 = 1 # Uniform prior
# prior.shape1 = 0.5 # Jeffreys prior

# Plot distribution
plot(phi,d.rel.conn.multiple(phi,p,k,n,w,prior.shape1=prior.shape1),
     main="Probability density for relative connectivity",
     xlab=expression(phi),
     ylab="Probability density",
     type="l")

# Add standard distributions for max and min p values
lines(phi,d.rel.conn.beta.prior(phi,min(p),k,n,prior.shape1=prior.shape1),
      col="red",lty="dashed")
lines(phi,d.rel.conn.beta.prior(phi,max(p),k,n,prior.shape1=prior.shape1),
      col="red",lty="dashed")

# Add some quantiles
q = q.rel.conn.multiple(c(0.025,0.25,0.5,0.75,0.975),
                        p,k,n,w,prior.shape1=prior.shape1)
abline(v=q,col="green")
</code></pre>

<hr>
<h2 id='d.rel.conn.unif.prior'>Estimate the probability distribution of relative connectivity values 
assuming a uniform prior distribution</h2><span id='topic+d.rel.conn.unif.prior'></span><span id='topic+p.rel.conn.unif.prior'></span><span id='topic+q.rel.conn.unif.prior'></span>

<h3>Description</h3>

<p>These functions calculate the probability density function 
(<code>d.rel.conn.unif.prior</code>), the probability distribution function (aka 
the cumulative distribution function; <code>p.rel.conn.unif.prior</code>) and the 
quantile function (<code>q.rel.conn.unif.prior</code>) for the relative (to all 
settlers at the destination site) connectivity value for larval transport 
between a source and destination site given a known fraction of marked 
individuals (i.e., eggs) in the source population.  A uniform prior is used
for the relative connectivity value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.rel.conn.unif.prior(phi, p, k, n, log = FALSE, ...)

p.rel.conn.unif.prior(phi, p, k, n, log = FALSE, ...)

q.rel.conn.unif.prior(q, p, k, n, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.rel.conn.unif.prior_+3A_phi">phi</code></td>
<td>
<p>Vector of fractions of individuals (i.e., eggs) from the source 
population settling at the destination population</p>
</td></tr>
<tr><td><code id="d.rel.conn.unif.prior_+3A_p">p</code></td>
<td>
<p>Fraction of individuals (i.e., eggs) marked in the source population</p>
</td></tr>
<tr><td><code id="d.rel.conn.unif.prior_+3A_k">k</code></td>
<td>
<p>Number of marked settlers found in sample</p>
</td></tr>
<tr><td><code id="d.rel.conn.unif.prior_+3A_n">n</code></td>
<td>
<p>Total number of settlers collected</p>
</td></tr>
<tr><td><code id="d.rel.conn.unif.prior_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code>, returns natural logarithm of probabilities, except
for <code><a href="#topic+q.rel.conn.unif.prior">q.rel.conn.unif.prior</a></code>, which expects log of probabilities
as inputs</p>
</td></tr>
<tr><td><code id="d.rel.conn.unif.prior_+3A_...">...</code></td>
<td>
<p>Extra arguments to Beta distribution functions.  See 
<code><a href="stats.html#topic+dbeta">dbeta</a></code> for details.  For expert use only.</p>
</td></tr>
<tr><td><code id="d.rel.conn.unif.prior_+3A_q">q</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimations of the probability distribution are derived from the Beta 
distribution (see <code><a href="stats.html#topic+dbeta">dbeta</a></code>) and should be exact to great 
precision.
</p>


<h3>Value</h3>

<p>Vector of probabilities or quantiles.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d.rel.conn.unif.prior</code>: Returns the probability density for 
relative connectivity between a pair of sites
</p>
</li>
<li> <p><code>p.rel.conn.unif.prior</code>: Returns the cumulative probability
distribution for relative connectivity between a paire of sites
</p>
</li>
<li> <p><code>q.rel.conn.unif.prior</code>: Estimates quantiles for the probability
distribution function for relative connectivity between a pair of sites
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)

k &lt;- 10 # Number of marked settlers among sample
n.obs &lt;- 87 # Number of settlers in sample
n.settlers &lt;- 100 # Total size of settler pool

p &lt;- 0.4 # Fraction of eggs that was marked
phi &lt;- seq(0,1,length.out=101) # Values for relative connectivity

# Probability distribution assuming infinite settler pool and uniform prior
drc &lt;- d.rel.conn.unif.prior(phi,p,k,n.obs)
prc &lt;- p.rel.conn.unif.prior(phi,p,k,n.obs)
qrc &lt;- q.rel.conn.unif.prior(c(0.025,0.975),p,k,n.obs) # 95% confidence interval

# Test with finite settlement function and large (approx. infinite) settler pool
# Can be a bit slow for large settler pools
dis &lt;- d.rel.conn.finite.settlement(0:(7*n.obs),p,k,n.obs,7*n.obs)

# Quantiles
qis &lt;- q.rel.conn.finite.settlement(c(0.025,0.975),p,k,n.obs,7*n.obs)

# Finite settler pool
dfs &lt;- d.rel.conn.finite.settlement(0:n.settlers,p,k,n.obs,n.settlers)

# Quantiles for the finite settler pool
qfs &lt;- q.rel.conn.finite.settlement(c(0.025,0.975),p,k,n.obs,n.settlers)

# Make a plot of different distributions
plot(phi,drc,type="l",main="Probability of relative connectivity values",
     xlab=expression(phi),ylab="Probability density")
lines(phi,prc,col="blue")
lines((0:(7*n.obs))/(7*n.obs),dis*(7*n.obs),col="black",lty="dashed")
lines((0:n.settlers)/n.settlers,dfs*n.settlers,col="red",lty="dashed")
abline(v=qrc,col="black")
abline(v=qis/(7*n.obs),col="black",lty="dashed")
abline(v=qfs/n.settlers,col="red",lty="dashed")

</code></pre>

<hr>
<h2 id='damselfish.lods'>Sample LOD score data for simulated and real parent-child pairs</h2><span id='topic+damselfish.lods'></span>

<h3>Description</h3>

<p>This dataset contains both simulated and real 'log of the odds ratio' (LOD) 
scores for potential parent-child pairs of humbug damselfish (<em>Dascyllus
aruanus</em>) from New Caledonia. Data was generated using 
<a href="http://www.pierroton.inra.fr/genetics/labo/Software/Famoz/index.html">FaMoz</a>.
In all cases, results are for the potential parent with the highest LOD score
for a given larval fish (child). Simulated data is based on artificial 
children generated from either real potential parent-pairs (the 'in' group) 
or artificial parents generated from observed allelic frequencies (the 'out' 
group).
</p>


<h3>Format</h3>

<p>A list with 3 elements: </p>
<dl>
<dt>in.group</dt><dd><p>5000 maximum LOD 
scores for simulated children from random crossing of real potential 
parents</p>
</dd><dt>out.group</dt><dd><p>5000 maximum LOD scores for simulated children 
from random crossing of artificial potential parents based on observed 
allelic frequencies</p>
</dd><dt>real.children</dt><dd><p>Maximum LOD scores for 200 real
juvenile fish</p>
</dd></dl>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Gerber S, Chabrier P, Kremer A (2003) FAMOZ: a software for 
parentage analysis using dominant, codominant and uniparentally inherited 
markers. Molecular Ecology Notes 3:479-481. 
<a href="http://dx.doi.org/10.1046/j.1471-8286.2003.00439.x">doi:10.1046/j.1471-8286.2003.00439.x</a>
</p>
<p>Kaplan et al. (submitted) Uncertainty in marine larval 
connectivity estimation
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a></code>
</p>

<hr>
<h2 id='DispersalPerRecruitModel'>Population dynamics model based on lifetime-egg-production</h2><span id='topic+DispersalPerRecruitModel'></span>

<h3>Description</h3>

<p>This function implements the marine population dynamics model described in 
Kaplan et al. (2006).  This model is most appropriate for examining 
equilibrium dynamics of age-structured populations or temporal dynamics of 
semelparous populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DispersalPerRecruitModel(
  LEP,
  conn.mat,
  recruits0,
  timesteps = 10,
  settler.recruit.func = hockeyStick,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DispersalPerRecruitModel_+3A_lep">LEP</code></td>
<td>
<p>a vector of lifetime-egg-production (LEP; also known as 
eggs-per-recruit (EPR)) for each site.</p>
</td></tr>
<tr><td><code id="DispersalPerRecruitModel_+3A_conn.mat">conn.mat</code></td>
<td>
<p>a square connectivity matrix.  <code>dim(conn.mat) = 
rep(length(LEP),2)</code></p>
</td></tr>
<tr><td><code id="DispersalPerRecruitModel_+3A_recruits0">recruits0</code></td>
<td>
<p>a vector of initial recruitment values for each site.</p>
</td></tr>
<tr><td><code id="DispersalPerRecruitModel_+3A_timesteps">timesteps</code></td>
<td>
<p>a vector of timesteps at which to record egg production, 
settlement and recruitment.</p>
</td></tr>
<tr><td><code id="DispersalPerRecruitModel_+3A_settler.recruit.func">settler.recruit.func</code></td>
<td>
<p>a function to calculate recruitment from the 
number of settlers at each site.  Defaults to <code><a href="#topic+hockeyStick">hockeyStick</a></code>.</p>
</td></tr>
<tr><td><code id="DispersalPerRecruitModel_+3A_...">...</code></td>
<td>
<p>additional arguments to settler.recruit.func.  Typically
<code>Rmax</code> and <code>slope</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements: </p>
<table>
<tr><td><code>eggs</code></td>
<td>
<p>egg production for
the timesteps in <code>timesteps</code></p>
</td></tr>
<tr><td><code>settlers</code></td>
<td>
<p>Similar for settlement</p>
</td></tr>
<tr><td><code>recruits</code></td>
<td>
<p>Similar for recruitment</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan, D. M., Botsford, L. W., and Jorgensen, S. 2006. Dispersal
per recruit: An efficient method for assessing sustainability in marine 
reserve networks. Ecological Applications, 16: 2248-2263.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+BevertonHolt">BevertonHolt</a></code>, <code><a href="#topic+hockeyStick">hockeyStick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(chile.loco)

# Get appropriate collapse slope
# critical.FLEP=0.2 is just an example
slope &lt;- settlerRecruitSlopeCorrection(chile.loco,critical.FLEP=0.2)

# Make the middle 20 sites a reserve
# All other sites: scorched earth
n &lt;- dim(chile.loco)[2]
LEP &lt;- rep(0,n)
nn &lt;- round(n/2)-9
LEP[nn:(nn+19)] &lt;- 1

Rmax &lt;- 1

recruits0 &lt;- rep(Rmax,n)

# Use DPR model
ret &lt;- DispersalPerRecruitModel(LEP,chile.loco,recruits0,1:20,slope=slope,Rmax=Rmax,
                                settler.recruit.func=BevertonHolt)
image(1:n,1:20,ret$settlers,xlab="sites",ylab="timesteps",
      main=c("Settlement","click to proceed"))
locator(1)
plot(ret$settlers[,20],xlab="sites",ylab="equilibrium settlement",
     main="click to proceed")
locator(1)

# Same, but with a uniform Laplacian dispersal matrix and hockeyStick
cm &lt;- laplacianConnMat(n,10,0,"circular")
ret &lt;- DispersalPerRecruitModel(LEP,cm,recruits0,1:20,slope=1/0.35,Rmax=Rmax)
image(1:n,1:20,ret$settlers,xlab="sites",ylab="timesteps",
      main=c("Settlement","click to proceed"))
locator(1)
plot(ret$settlers[,20],xlab="sites",ylab="equilibrium settlement")
</code></pre>

<hr>
<h2 id='DPRHomerangeGravity'>Extended DPR population dynamics model to include homerange movement</h2><span id='topic+DPRHomerangeGravity'></span>

<h3>Description</h3>

<p>This function implements the marine population dynamics model described in 
Gruss et al. (2011).  The model is an extension of the dispersal-per-recruit 
model in Kaplan et al. (2006) to include movement in a homerange and a 
gravity model for fishing effort redistribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPRHomerangeGravity(
  larval.mat,
  adult.mat,
  recruits0,
  f0,
  timesteps = 10,
  settler.recruit.func = hockeyStick,
  LEP.of.f = function(f) 1 - f,
  YPR.of.f = function(f) f,
  gamma = 0,
  gravity.ts.interval = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DPRHomerangeGravity_+3A_larval.mat">larval.mat</code></td>
<td>
<p>a square larval connectivity matrix.  <code>dim(larval.mat)
= rep(length(recruits0),2)</code></p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_adult.mat">adult.mat</code></td>
<td>
<p>a square adult homerange movement matrix. 
<code>dim(adult.mat) = rep(length(recruits0),2)</code>. adult.mat must
be properly normalized so that each column sums to 1.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_recruits0">recruits0</code></td>
<td>
<p>a vector of initial recruitment values for each site.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_f0">f0</code></td>
<td>
<p>a vector of initial real fishing mortalities for each site.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_timesteps">timesteps</code></td>
<td>
<p>a vector of timesteps at which to record egg production, 
settlement and recruitment.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_settler.recruit.func">settler.recruit.func</code></td>
<td>
<p>a function to calculate recruitment from the 
number of settlers at each site.  Defaults to <code><a href="#topic+hockeyStick">hockeyStick</a></code>.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_lep.of.f">LEP.of.f</code></td>
<td>
<p>a function that returns lifetime-egg-productions given a 
vector of fishing rates.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_ypr.of.f">YPR.of.f</code></td>
<td>
<p>a function that returns yields-per-recruit given a vector of 
fishing rates.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_gamma">gamma</code></td>
<td>
<p>exponent for the gravity model.  Defaults to 0, i.e., no gravity
model.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_gravity.ts.interval">gravity.ts.interval</code></td>
<td>
<p>number of timesteps between updates of gravity 
model.  Defaults to 1, i.e., every timestep.</p>
</td></tr>
<tr><td><code id="DPRHomerangeGravity_+3A_...">...</code></td>
<td>
<p>additional arguments to settler.recruit.func.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>eggs</code></td>
<td>
<p>egg production for the timesteps in <code>timesteps</code></p>
</td></tr>
<tr><td><code>settlers</code></td>
<td>
<p>Similar for settlement</p>
</td></tr>
<tr><td><code>recruits</code></td>
<td>
<p>Similar for recruitment</p>
</td></tr>
<tr><td><code>fishing.mortality</code></td>
<td>
<p>Real spatial distribution of fishing mortality</p>
</td></tr>
<tr><td><code>effective.fishing.mortality</code></td>
<td>
<p>Effective fishing mortality taking into 
account adult movement</p>
</td></tr>
<tr><td><code>yield</code></td>
<td>
<p>Real spatial distribution of yield</p>
</td></tr>
<tr><td><code>effective.yield</code></td>
<td>
<p>Effective yield indicating where fish biomass caught
originates from</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Gruss A, Kaplan DM, Hart DR (2011) Relative Impacts of Adult 
Movement, Larval Dispersal and Harvester Movement on the Effectiveness of 
Reserve Networks. PLoS ONE 6:e19960
</p>
<p>Kaplan, D. M., Botsford, L. W., and Jorgensen, S. 2006. Dispersal
per recruit: An efficient method for assessing sustainability in marine 
reserve networks. Ecological Applications, 16: 2248-2263.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+BevertonHolt">BevertonHolt</a></code>, <code><a href="#topic+hockeyStick">hockeyStick</a></code>, 
<code><a href="#topic+DispersalPerRecruitModel">DispersalPerRecruitModel</a></code>
</p>

<hr>
<h2 id='dual.mark.transmission'>Fraction of eggs marked for male and female mark transmission</h2><span id='topic+dual.mark.transmission'></span>

<h3>Description</h3>

<p>Estimates the fraction of eggs produced at the source site that are the 
result of crossing parents, one or both of which have been genotyped. Based 
on the assumption that probability of breeding between pairs of individuals 
is completely independent of whether or not one or more of those individuals 
was genotyped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dual.mark.transmission(p.female, p.male = p.female)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dual.mark.transmission_+3A_p.female">p.female</code></td>
<td>
<p>Fraction of all adult females genotyped in the source 
population</p>
</td></tr>
<tr><td><code id="dual.mark.transmission_+3A_p.male">p.male</code></td>
<td>
<p>Fraction of all adult males genotyped in the source 
population. Defaults to be equal to <code>p.female</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements: </p>
<dl>
<dt>prob.matrix</dt><dd><p>2x2 
matrix with probabilities for producing offspring with male or female known
or unknown parents</p>
</dd><dt>p</dt><dd><p>fraction of all eggs produced at source site 
that will come from at least one genotyped 
parent</p>
</dd><dt>p.female.known</dt><dd><p>Fraction of eggs with a single known female 
parent among all eggs that have one or more known 
parents</p>
</dd><dt>p.male.known</dt><dd><p>Fraction of eggs with a single known male 
parent among all eggs that have one or more known 
parents</p>
</dd><dt>p.two.known.parents</dt><dd><p>Fraction of eggs with two known parents
among all eggs that have one or more known parents</p>
</dd></dl>



<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(damselfish.lods)

# Histograms of simulated LODs
l &lt;- seq(-1,30,0.5)
h.in &lt;- hist(damselfish.lods$in.group,breaks=l)
h.out &lt;- hist(damselfish.lods$out.group,breaks=l)

# PDFs for marked and unmarked individuals based on simulations
d.marked &lt;- stepfun.hist(h.in)
d.unmarked &lt;- stepfun.hist(h.out)

# Fraction of adults genotyped at source site
p.adults &lt;- 0.25

# prior.shape1=1 # Uniform prior
prior.shape1=0.5 # Jeffreys prior

# Fraction of eggs from one or more genotyped parents
p &lt;- dual.mark.transmission(p.adults)$p

# PDF for relative connectivity
D &lt;- d.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Estimate most probable value for relative connectivity
phi.mx &lt;- optim.rel.conn.dists(damselfish.lods$real.children,
                                    d.unmarked,d.marked,p)$phi

# Estimate 95% confidence interval for relative connectivity
Q &lt;- q.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Plot it up
phi &lt;- seq(0,1,0.001)
plot(phi,D(phi),type="l",
     xlim=c(0,0.1),
     main="PDF for relative connectivity",
     xlab=expression(phi),
     ylab="Probability density")

abline(v=phi.mx,col="green",lty="dashed")
abline(v=Q(c(0.025,0.975)),col="red",lty="dashed")
</code></pre>

<hr>
<h2 id='eigs'>Compute some eigenvalues of a matrix</h2><span id='topic+eigs'></span>

<h3>Description</h3>

<p>This function computes a limited number of eigenvalues and eigenvectors of a 
matrix. It uses <code><a href="igraph.html#topic+arpack">arpack</a></code> function from the 
<a href="igraph.html#topic+igraph">igraph</a> package. If this package is not available, it will use 
the standard <code><a href="base.html#topic+eigen">eigen</a></code> function to do the calculation, but will 
issue a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigs(
  M,
  nev = min(dim(M)[1] - 1, 1),
  sym = sum(abs(M - t(M)))/sum(abs(M)) &lt; 1e-10,
  which = "LM",
  use.arpack = TRUE,
  options.arpack = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigs_+3A_m">M</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="eigs_+3A_nev">nev</code></td>
<td>
<p>number of eigenvalues and eigenvectors to return</p>
</td></tr>
<tr><td><code id="eigs_+3A_sym">sym</code></td>
<td>
<p>A boolean indicating if matrix is symmetric or not.  Defaults to 
checking if this is the case or not.</p>
</td></tr>
<tr><td><code id="eigs_+3A_which">which</code></td>
<td>
<p>A character string indicating which eigenvalues to return. 
Defaults to &quot;LM&quot;, meaning largest magnitude eigenvalues. If not using 
<code><a href="igraph.html#topic+arpack">arpack</a></code>, then &quot;SM&quot; is also a possibility to return the
smallest magnitude eigenvalues. If using <code><a href="igraph.html#topic+arpack">arpack</a></code>, then
a number of options are possible, though they are not all guaranteed to 
work for all use cases. See that function for more details.</p>
</td></tr>
<tr><td><code id="eigs_+3A_use.arpack">use.arpack</code></td>
<td>
<p>Boolean determining if calculation is to be done with 
<code><a href="igraph.html#topic+arpack">arpack</a></code> function from the <a href="igraph.html#topic+igraph">igraph</a> 
package. This is much quicker for large matrices, but requires 
<a href="igraph.html#topic+igraph">igraph</a>. Defaults to TRUE, but will use eigen instead if 
<a href="igraph.html#topic+igraph">igraph</a> is not found.</p>
</td></tr>
<tr><td><code id="eigs_+3A_options.arpack">options.arpack</code></td>
<td>
<p>Additional options for <code><a href="igraph.html#topic+arpack">arpack</a></code>. 
See that function for details.  Not all options are compatible with this 
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with at least the following two items:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>A set of eigenvalues</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>A matrix of eigenvectors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="igraph.html#topic+arpack">arpack</a></code>
</p>

<hr>
<h2 id='gammaParamsConvert'>Gamma distribution shape and scale parameters from mean and standard 
deviation, or vice-versa</h2><span id='topic+gammaParamsConvert'></span>

<h3>Description</h3>

<p>Calculates shape and scale parameters for a gamma distribution from the mean 
and standard deviation of the distribution, or vice-versa.  One supplies 
either <code>mean</code> and <code>sd</code> or <code>shape</code> and <code>scale</code> and the 
function returns a list with all four parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaParamsConvert(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaParamsConvert_+3A_...">...</code></td>
<td>
<p>This function can be run either supplying <code>mean</code> and
<code>sd</code>, or supplying <code>shape</code> and <code>scale</code>, but not both pairs
of parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>mean</code>, <code>sd</code>, <code>shape</code> and <code>scale</code> 
parameters of the corresponding gamma distribution.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
mn &lt;- 1
sd &lt;- 0.4
l &lt;- gammaParamsConvert(mean=mn,sd=sd)
x &lt;- seq(0,2,length.out=50)

# Plot gamma and normal distributions - for sd &lt;&lt; mean, the two should be very close
plot(x,dgamma(x,l$shape,scale=l$scale),
     main="Normal versus Gamma distributions",type="l")
lines(x,dnorm(x,l$mean,l$sd),col="red")
</code></pre>

<hr>
<h2 id='hockeyStick'>Hockey-stick settler-recruit relationship</h2><span id='topic+hockeyStick'></span>

<h3>Description</h3>

<p>Calculates recruitment based on a settler-recruit relationship that increases
linearly until it reaches a maximum values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hockeyStick(S, slope = 1/0.35, Rmax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hockeyStick_+3A_s">S</code></td>
<td>
<p>a vector of settlement values, 1 for each site.</p>
</td></tr>
<tr><td><code id="hockeyStick_+3A_slope">slope</code></td>
<td>
<p>slope at the origin of the settler-recruit relationship.  Can be
a vector of same length as <code>S</code>.</p>
</td></tr>
<tr><td><code id="hockeyStick_+3A_rmax">Rmax</code></td>
<td>
<p>maximum recruitment value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slope</code> and <code>Rmax</code> can both either be scalars or vectors of the 
same length as <code>S</code>.
</p>


<h3>Value</h3>

<p>A vector of recruitment values.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan, D. M., Botsford, L. W., and Jorgensen, S. 2006. Dispersal
per recruit: An efficient method for assessing sustainability in marine 
reserve networks. Ecological Applications, 16: 2248-2263.
</p>

<hr>
<h2 id='laplacianConnMat'>Uniform Laplacian connectivity matrix</h2><span id='topic+laplacianConnMat'></span>

<h3>Description</h3>

<p>This function generates a connectivity matrix that is governed by a Laplacian
distribution: <code>D[i,j]=exp(abs(x[i]-y[i]-shift)/disp.dist)/2/disp.dist</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacianConnMat(num.sites, disp.dist, shift = 0, boundaries = "nothing")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacianConnMat_+3A_num.sites">num.sites</code></td>
<td>
<p>number of sites.  Sites are assumed to be aligned on a 
linear coastline.</p>
</td></tr>
<tr><td><code id="laplacianConnMat_+3A_disp.dist">disp.dist</code></td>
<td>
<p>dispersal distance in &quot;site&quot; units (i.e., 1 site = 1 unit of
distance)</p>
</td></tr>
<tr><td><code id="laplacianConnMat_+3A_shift">shift</code></td>
<td>
<p>advection distance in &quot;site&quot; units.  Defaults to 0.</p>
</td></tr>
<tr><td><code id="laplacianConnMat_+3A_boundaries">boundaries</code></td>
<td>
<p>string indicating what to do at boundaries.  Defaults to 
&quot;nothing&quot;.  Possible values include: &quot;nothing&quot;, &quot;conservative&quot; and
&quot;circular&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>boundary</code> argument can have the following different values: 
&quot;nothing&quot; meaning do nothing special with boundaries; &quot;conservative&quot; meaning force
columns of matrix to sum to 1; and &quot;circular&quot; meaning wrap edges.
</p>


<h3>Value</h3>

<p>A square connectivity matrix
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan, D. M., Botsford, L. W., and Jorgensen, S. 2006. Dispersal
per recruit: An efficient method for assessing sustainability in marine 
reserve networks. Ecological Applications, 16: 2248-2263.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+DispersalPerRecruitModel">DispersalPerRecruitModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
cm &lt;- laplacianConnMat(100,10,15,"circular")
image(cm)
</code></pre>

<hr>
<h2 id='localRetention'>Local retention of a connectivity matrix</h2><span id='topic+localRetention'></span>

<h3>Description</h3>

<p>Local retention is defined as the diagonal elements of the connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localRetention(conn.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localRetention_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(chile.loco)

sr &lt;- selfRecruitment(chile.loco)
lr &lt;- localRetention(chile.loco)
rlr &lt;- relativeLocalRetention(chile.loco)
</code></pre>

<hr>
<h2 id='mergeSubpops'>Merge subpopulations</h2><span id='topic+mergeSubpops'></span>

<h3>Description</h3>

<p>This function tries to merge random subopoulations, checking if the
result is a better soluton to the minimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeSubpops(subpops.lst, conn.mat, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeSubpops_+3A_subpops.lst">subpops.lst</code></td>
<td>
<p>A list whose elements are vectors of indices for each subpopulation.  See <code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code>.</p>
</td></tr>
<tr><td><code id="mergeSubpops_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.  This matrix has
typically been normalized and made symmetric prior to using this
function.</p>
</td></tr>
<tr><td><code id="mergeSubpops_+3A_beta">beta</code></td>
<td>
<p>Controls degree of splitting of connectivity matrix,
with larger values generating more subpopulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the same format as subpops.lst, but with
potentially fewer subpopulations.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson,
P. R. 2012. Identification of subpopulations from connectivity
matrices. Ecography, 35: 1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+optimalSplitConnMat">optimalSplitConnMat</a></code>,
</p>

<hr>
<h2 id='optim.rel.conn.dists'>Maximum-likelihood estimate for relative connectivity given two distributions
for scores for marked and unmarked individuals</h2><span id='topic+optim.rel.conn.dists'></span>

<h3>Description</h3>

<p>This function calculates the value for relative connectivity that best fits a
set of observed score values, a pair of distributions for marked and unmarked
individuals and an estimate of the fraction of eggs marked in the source 
population, <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim.rel.conn.dists(
  obs,
  d.unmarked,
  d.marked,
  p = 1,
  phi0 = 0.5,
  method = "Brent",
  lower = 0,
  upper = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim.rel.conn.dists_+3A_obs">obs</code></td>
<td>
<p>Vector of observed score values for potentially marked individuals</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_d.unmarked">d.unmarked</code></td>
<td>
<p>A function representing the PDF of unmarked individuals. 
Must be normalized so that it integrates to 1 for the function to work 
properly.</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_d.marked">d.marked</code></td>
<td>
<p>A function representing the PDF of marked individuals.  Must 
be normalized so that it integrates to 1 for the function to work properly.</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_p">p</code></td>
<td>
<p>Fraction of individuals (i.e., eggs) marked in the source population</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_phi0">phi0</code></td>
<td>
<p>Initial value for <code class="reqn">\phi</code>, the fraction of settlers at the 
destination population that originated at the source population, for 
<code><a href="stats.html#topic+optim">optim</a></code> function. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_method">method</code></td>
<td>
<p>Method variable for <code><a href="stats.html#topic+optim">optim</a></code> function. Defaults to 
<code>"Brent"</code>.</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_lower">lower</code></td>
<td>
<p>Lower limit for search for fraction of marked individuals. 
Defaults to 0.</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_upper">upper</code></td>
<td>
<p>Upper limit for search for fraction of marked individuals. 
Defaults to 1.</p>
</td></tr>
<tr><td><code id="optim.rel.conn.dists_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with results of optimization. Optimal fraction of marked 
individuals is in <code>phi</code> field. Negative log-likelihood is in the 
<code>neg.log.prob</code> field. See <code><a href="stats.html#topic+optim">optim</a></code> for other elements of
list.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+r.marked.egg.fraction">r.marked.egg.fraction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(damselfish.lods)

# Histograms of simulated LODs
l &lt;- seq(-1,30,0.5)
h.in &lt;- hist(damselfish.lods$in.group,breaks=l)
h.out &lt;- hist(damselfish.lods$out.group,breaks=l)

# PDFs for marked and unmarked individuals based on simulations
d.marked &lt;- stepfun.hist(h.in)
d.unmarked &lt;- stepfun.hist(h.out)

# Fraction of adults genotyped at source site
p.adults &lt;- 0.25

# prior.shape1=1 # Uniform prior
prior.shape1=0.5 # Jeffreys prior

# Fraction of eggs from one or more genotyped parents
p &lt;- dual.mark.transmission(p.adults)$p

# PDF for relative connectivity
D &lt;- d.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Estimate most probable value for relative connectivity
phi.mx &lt;- optim.rel.conn.dists(damselfish.lods$real.children,
                                    d.unmarked,d.marked,p)$phi

# Estimate 95% confidence interval for relative connectivity
Q &lt;- q.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Plot it up
phi &lt;- seq(0,1,0.001)
plot(phi,D(phi),type="l",
     xlim=c(0,0.1),
     main="PDF for relative connectivity",
     xlab=expression(phi),
     ylab="Probability density")

abline(v=phi.mx,col="green",lty="dashed")
abline(v=Q(c(0.025,0.975)),col="red",lty="dashed")
</code></pre>

<hr>
<h2 id='optimalSplitConnMat'>Iteratively, optimally split a connectivity matrix</h2><span id='topic+optimalSplitConnMat'></span>

<h3>Description</h3>

<p>Algorithm for iteratively determining subpopulations of
highly-connected sites.  Uses an iterative method described in
Jacobi et al. (2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimalSplitConnMat(
  conn.mat,
  normalize.cols = TRUE,
  make.symmetric = "mean",
  remove.diagonal = FALSE,
  cycles = 2,
  betas = betasVectorDefault(ifelse(normalize.cols, dim(conn.mat)[2],
    prod(dim(conn.mat))/sum(conn.mat)), steps),
  steps = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimalSplitConnMat_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_normalize.cols">normalize.cols</code></td>
<td>
<p>A boolean indicating if columns of conn.mat
should be normalized by the sum of all elements in the column.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_make.symmetric">make.symmetric</code></td>
<td>
<p>A string indicating how to force conn.mat to
be symmetric.  &quot;mean&quot; (the default) will replace C_ij by (C_ij +
C_ji)/2.  &quot;max&quot; will replace C_ij by the maximum of C_ij and C_ji.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_remove.diagonal">remove.diagonal</code></td>
<td>
<p>A boolean indicating if the diagonal
elements of conn.mat should be removed before determining the
subpopulations.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_cycles">cycles</code></td>
<td>
<p>Number of times to pass over values in betas.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_betas">betas</code></td>
<td>
<p>Vector of beta values to try.  If not given, will
default to <code><a href="#topic+betasVectorDefault">betasVectorDefault</a>(dim(conn.mat)[2],steps)</code>.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_steps">steps</code></td>
<td>
<p>Number of beta values to produce using
betasVectorDefault.  Ignored if betas argument is explicitly
given.</p>
</td></tr>
<tr><td><code id="optimalSplitConnMat_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+splitConnMat">splitConnMat</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>betas</code></td>
<td>
<p>Vector of all beta values tested</p>
</td></tr>
<tr><td><code>num.subpops</code></td>
<td>
<p>Vector of number of subpopulations found for
each value of beta</p>
</td></tr>
<tr><td><code>qualities</code></td>
<td>
<p>Vector of the quality statistic for each
subpopulation division</p>
</td></tr>
<tr><td><code>subpops</code></td>
<td>
<p>A matrix with dimensions dim(conn.mat)[2] X
length(betas) indicating which subpopulation each site belongs to</p>
</td></tr>
<tr><td><code>best.splits</code></td>
<td>
<p>A list indicating for each number of
subpopulations, which column of subpops contains the division with
the lowest quality statistic.  E.g.,
<code>best.splits[["4"]]$index</code> contains the column index of the
optimal division of the connectivity matrix into 4 subpopulations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In Jacobi et al. (2012) paper, the connectivity matrix is
oriented so that <code class="reqn">C_ij</code> is dispersal from i to j, whereas in this R
package, the connectivity matrix is oriented so that <code class="reqn">C_ij</code> is
dispersal from j to i.  This choice of orientation is arbitrary,
but one must always be consistent.  From j to i is more common in
population dynamics because it works well with matrix
multiplication (e.g., <code>settlers = conn.mat %*% eggs</code>).
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson,
P. R. 2012. Identification of subpopulations from connectivity
matrices. Ecography, 35: 1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+splitConnMat">splitConnMat</a></code>,
<code><a href="#topic+recSplitConnMat">recSplitConnMat</a></code>, <code><a href="#topic+mergeSubpops">mergeSubpops</a></code>,
<code><a href="#topic+qualitySubpops">qualitySubpops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(chile.loco)

num &lt;- prod(dim(chile.loco)) / sum(chile.loco)
betas &lt;- betasVectorDefault(n=num,steps=4)
chile.loco.split &lt;- optimalSplitConnMat(chile.loco,normalize.cols=FALSE,
                                        betas=betas)

# Extra 3rd division
print(paste("Examining split with",names(chile.loco.split$best.splits)[1],
            "subpopulations."))
pops &lt;- subpopsVectorToList(chile.loco.split$subpops[,chile.loco.split$best.splits[[1]]$index])

reduce.loco &lt;- reducedConnMat(pops,chile.loco)

sr &lt;- selfRecruitment(reduce.loco)
lr &lt;- localRetention(reduce.loco)
rlr &lt;- relativeLocalRetention(reduce.loco)
</code></pre>

<hr>
<h2 id='prob.marked'>Returns probability a set of observations correspond to marked individuals</h2><span id='topic+prob.marked'></span>

<h3>Description</h3>

<p>This function returns the probability each of a set of observations 
corresponds to a marked individual given the distribution of scores for 
unmarked and marked individuals and the fraction of individuals that are 
marked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.marked(obs, d.unmarked, d.marked, phi = 0.5, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob.marked_+3A_obs">obs</code></td>
<td>
<p>A vector of score values for a random sample of (marked and 
unmarked) individuals from the population</p>
</td></tr>
<tr><td><code id="prob.marked_+3A_d.unmarked">d.unmarked</code></td>
<td>
<p>A function representing the PDF of unmarked individuals. 
Must be normalized so that it integrates to 1 for the function to work 
properly.</p>
</td></tr>
<tr><td><code id="prob.marked_+3A_d.marked">d.marked</code></td>
<td>
<p>A function representing the PDF of marked individuals.  Must 
be normalized so that it integrates to 1 for the function to work properly.</p>
</td></tr>
<tr><td><code id="prob.marked_+3A_phi">phi</code></td>
<td>
<p>The fraction of settlers at the destination population that 
originated at the source population. Defaults to 0.5, which would
correspond to an even sample of marked and unmarked individuals.</p>
</td></tr>
<tr><td><code id="prob.marked_+3A_p">p</code></td>
<td>
<p>Fraction of individuals (i.e., eggs) marked in the source 
population. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same size as <code>obs</code> containing the probability 
that each individual is marked
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a></code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a></code>.
</p>

<hr>
<h2 id='protectedAreaSelection'>Function to select optimal network of protected areas based on connectivity</h2><span id='topic+protectedAreaSelection'></span>

<h3>Description</h3>

<p>This function finds the optimal network of protected areas based on 
connectivity using the eigenvalue perturbation approach described in Nilsson 
Jacobi &amp; Jonsson (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protectedAreaSelection(
  conn.mat,
  nev = dim(conn.mat)[1],
  delta = 0.1,
  theta = 0.05,
  M = 20,
  epsilon.lambda = 1e-04,
  epsilon.uv = 0.05,
  only.list = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protectedAreaSelection_+3A_conn.mat">conn.mat</code></td>
<td>
<p>a square connectivity matrix.</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_nev">nev</code></td>
<td>
<p>number of eigenvalues and associated eigenvectors to be 
calculated.</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_delta">delta</code></td>
<td>
<p>the effect of protecting site i (e.g. increase in survival or 
fecundity in protected areas relative to unprotected areas). Now a single 
value, in future it will be possible to specify site-specific values. The 
perturbation theory used in the construction of the algorithm assumes delta
to be small (e.g. delta=0.1). However, higher values give also good 
results.</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_theta">theta</code></td>
<td>
<p>the threshold of donor times recipient value that a site must 
have to be selected.</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_m">M</code></td>
<td>
<p>the maximal number of sites selected from each subpopulation even if
there are more sites above the threshold theta</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_epsilon.lambda">epsilon.lambda</code></td>
<td>
<p>Threshold for removing complex eigenvalues.</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_epsilon.uv">epsilon.uv</code></td>
<td>
<p>Threshold for removing eigenvectors with elements of 
opposite signs of comparable magnitude.</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_only.list">only.list</code></td>
<td>
<p>Logical, whether the function return only the list of 
selected sites or also the predicted impact of each selected site on the 
eigenvalues</p>
</td></tr>
<tr><td><code id="protectedAreaSelection_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code><a href="#topic+eigs">eigs</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If only.list is <code>TRUE</code>, just returns the list of selected sites.
If <code>FALSE</code>, then result will be a list containing selected sites and
predicted impact of each selected site on the eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Marco Andrello <a href="mailto:marco.andrello@gmail.com">marco.andrello@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., and Jonsson, P. R. 2011. Optimal networks of 
nature reserves can be found through eigenvalue perturbation theory of the 
connectivity matrix. Ecological Applications, 21: 1861-1870.
</p>

<hr>
<h2 id='qualitySubpops'>Quality measure for subpopulation division</h2><span id='topic+qualitySubpops'></span>

<h3>Description</h3>

<p>A measure of the leakage between subpopulations for a given division of the 
connectivity matrix into subpopulations.  This statistic is equal to 1 - 
mean(RLR) of the reduced connectivity matrix, where RLR=relative local 
retention (<code><a href="#topic+relativeLocalRetention">relativeLocalRetention</a></code>), i.e., the fraction of 
settling individuals that originated at their site of settlement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualitySubpops(subpops.lst, conn.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qualitySubpops_+3A_subpops.lst">subpops.lst</code></td>
<td>
<p>A list whose elements are vectors of indices for each 
subpopulation.  If a vector of integers is given, then 
<code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code> is applied to convert it to a list of 
subpopulations.</p>
</td></tr>
<tr><td><code id="qualitySubpops_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quality statistic.
</p>
<p>A smaller value of the quality statistic indicates less leakage.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson, P. R. 2012. 
Identification of subpopulations from connectivity matrices. Ecography, 35:
1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+optimalSplitConnMat">optimalSplitConnMat</a></code>, 
<code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code>, <code><a href="#topic+relativeLocalRetention">relativeLocalRetention</a></code>
</p>

<hr>
<h2 id='r.marked.egg.fraction'>Estimates of fraction of eggs marked accounting for variability in 
reproductive output</h2><span id='topic+r.marked.egg.fraction'></span>

<h3>Description</h3>

<p>This function estimates the fraction of eggs &quot;marked&quot; at a site (where the 
&quot;mark&quot; could be micro-chemical or genetic) taking into account uncertainty in
female (and potentially male in the case of dual genetic mark transmission) 
reproductive output. It generates a set of potential values for the fraction 
of eggs marked assuming that reproductive output of each marked or unmarked 
mature individual is given by a random variable drawn from a single 
probability distribution with known mean and standard deviation (or 
equivalently coefficient of variation) <strong>and</strong> that the numbers 
of marked and unmarked individuals are large enough that the central limit 
theorem applies and, therefore, their collective reproductive outputs are 
reasonably well described by a gamma distribution whose mean and standard 
deviation are appropriately scaled based on the number of individual 
reproducers.  The function also returns the total egg production 
corresponding to each fraction of marked eggs, needed for estimating absolute
connectivity values (i.e., elements of the connectivity matrix needed for 
assessing population persistence).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r.marked.egg.fraction(
  n,
  n.females,
  n.marked.females = round(n.females * p.marked.females),
  mean.female = 1,
  cv.female,
  dual = FALSE,
  male.uncert = FALSE,
  n.males = n.females,
  n.marked.males = tryCatch(round(n.males * p.marked.males), error = function(e)
    n.marked.females),
  mean.male = mean.female,
  cv.male = cv.female,
  p.marked.females,
  p.marked.males = p.marked.females
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r.marked.egg.fraction_+3A_n">n</code></td>
<td>
<p>Number of random values to estimates</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_n.females">n.females</code></td>
<td>
<p>Total number of mature females in the population</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_n.marked.females">n.marked.females</code></td>
<td>
<p>Number of marked females in population</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_mean.female">mean.female</code></td>
<td>
<p>Mean egg production of each mature female. Defaults to 1.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_cv.female">cv.female</code></td>
<td>
<p>Coefficient of variation of reproductive output of an 
individual mature female</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_dual">dual</code></td>
<td>
<p>Logical variable. If <code>TRUE</code>, then the fraction of marked 
eggs is calculated assuming dual (male and female) mark transmission. 
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_male.uncert">male.uncert</code></td>
<td>
<p>Logical variable. If <code>TRUE</code>, then variability in male
sperm output is also taken into account when estimating the number of 
marked eggs. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_n.males">n.males</code></td>
<td>
<p>Total number of mature males in the population. Only used if 
<code>dual=TRUE</code>. Defaults to being equal to <code>n.females</code>.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_n.marked.males">n.marked.males</code></td>
<td>
<p>Number of marked males in population. Only used if 
<code>dual=TRUE</code>. Defaults to being equal to <code>n.marked.females</code>.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_mean.male">mean.male</code></td>
<td>
<p>Mean sperm production of each mature male. Only used if 
<code>dual=TRUE</code> and <code>male.uncert=TRUE</code>. Defaults to being equal to 
<code>mean.female</code>.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_cv.male">cv.male</code></td>
<td>
<p>Coefficient of variation of reproductive output of an 
individual mature male. Only used if <code>dual=TRUE</code> and 
<code>male.uncert=TRUE</code>. Defaults to being equal to <code>cv.female</code>.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_p.marked.females">p.marked.females</code></td>
<td>
<p>Fraction of marked females in population. Can be 
supplied instead of <code>n.marked.females</code>. Ignored if 
<code>n.marked.females</code> is given.</p>
</td></tr>
<tr><td><code id="r.marked.egg.fraction_+3A_p.marked.males">p.marked.males</code></td>
<td>
<p>Fraction of marked males in population. Can be supplied
instead of <code>n.marked.males</code>. Only used if <code>dual=TRUE</code>. Ignored if
<code>n.marked.males</code> is given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements: </p>
<dl>
<dt>p</dt><dd><p>Vector of 
length <code>n</code> with estimates for fraction of marked 
eggs</p>
</dd><dt>eggs</dt><dd><p>Vector of length <code>n</code> with estimates for total egg 
production</p>
</dd><dt>marked.eggs</dt><dd><p>Vector of length <code>n</code> with estimates for 
total number of marked eggs produced</p>
</dd><dt>sperm</dt><dd><p>Only returned if 
<code>dual=TRUE</code>. If <code>male.uncert=FALSE</code>, then a scalar equal to 
<code>n.males</code>. Otherwise, a vector of length <code>n</code> with estimates for 
total sperm production</p>
</dd><dt>marked.sperm</dt><dd><p>Only returned if 
<code>dual=TRUE</code>. If <code>male.uncert=FALSE</code>, then a scalar equal to 
<code>n.marked.males</code>. Otherwise, a vector of length <code>n</code> with
estimates for total marked sperm production</p>
</dd></dl>



<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Kaplan DM, Cuif M, Fauvelot C, Vigliola L, Nguyen-Huu T, Tiavouane J and Lett C 
(in press) Uncertainty in empirical estimates of marine larval connectivity. 
ICES Journal of Marine Science. doi:10.1093/icesjms/fsw182.
</p>


<h3>See Also</h3>

<p>Other connectivity estimation: 
<code><a href="#topic+d.rel.conn.beta.prior">d.rel.conn.beta.prior</a>()</code>,
<code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a>()</code>,
<code><a href="#topic+d.rel.conn.finite.settlement">d.rel.conn.finite.settlement</a>()</code>,
<code><a href="#topic+d.rel.conn.multinomial.unnorm">d.rel.conn.multinomial.unnorm</a>()</code>,
<code><a href="#topic+d.rel.conn.multiple">d.rel.conn.multiple</a>()</code>,
<code><a href="#topic+d.rel.conn.unif.prior">d.rel.conn.unif.prior</a>()</code>,
<code><a href="#topic+dual.mark.transmission">dual.mark.transmission</a>()</code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)

n.females &lt;- 500
n.marked.females &lt;- 100
p.marked.females &lt;- n.marked.females/n.females
mn &lt;- 1
cv &lt;- 1
# Numbers of males and marked males and variance in male sperm production
# assumed the same as values for females

# Random values from distribution of pure female mark transmission
F=r.marked.egg.fraction(1000,n.females=n.females,n.marked.females=n.marked.females,
                        mean.female=mn,cv.female=cv)

# Random values from distribution of dual female-male mark transmission, but
# fraction of marked eggs only depends on fraction of marked males
Fm=r.marked.egg.fraction(1000,n.females=n.females,n.marked.females=n.marked.females,
                        mean.female=mn,cv.female=cv,dual=TRUE,male.uncert=FALSE)

# Random values from distribution of dual female-male mark transmission, with
# fraction of marked eggs depending on absolute marked and unmarked sperm output
FM=r.marked.egg.fraction(1000,n.females=n.females,n.marked.females=n.marked.females,
                         mean.female=mn,cv.female=cv,dual=TRUE,male.uncert=TRUE)

# Plot of pure female mark transmission
hist(F$p,50,main="Female mark transmission",
     xlab="Fraction of marked eggs",
     ylab="Frequency")

# Female+male mark transmission, but no variability in male mark transmission
h &lt;- hist(Fm$p,50,main="Female+male mark transmission, no male uncert.",
          xlab="Fraction of marked eggs",
          ylab="Frequency")
hh &lt;- hist((1-p.marked.females)*F$p + p.marked.females,
           breaks=c(-Inf,h$breaks,Inf),plot=FALSE)
lines(hh$mids,hh$counts,col="red")

# Plot of pure female mark transmission
h &lt;- hist(FM$p,50,plot=FALSE)
hh &lt;- hist(Fm$p,
           breaks=c(-Inf,h$breaks,Inf),plot=FALSE)
plot(h,ylim=c(0,1.1*max(hh$counts,h$counts)),
     main="Female+Male mark transmission, male uncert.",
     xlab="Fraction of marked eggs",
     ylab="Frequency")
lines(hh$mids,hh$counts,col="red")
</code></pre>

<hr>
<h2 id='recSplitConnMat'>Recursively subdivides a set of subpoplations</h2><span id='topic+recSplitConnMat'></span>

<h3>Description</h3>

<p>This funtion recursively splits each subpopulation of a list of
subpopulations until none of the subpopulations can be split
further to improve the minimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recSplitConnMat(subpops.lst, conn.mat, beta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recSplitConnMat_+3A_subpops.lst">subpops.lst</code></td>
<td>
<p>A list whose elements are vectors of indices for each subpopulation.  See <code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code>.</p>
</td></tr>
<tr><td><code id="recSplitConnMat_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.  This matrix has
typically been normalized and made symmetric prior to using this
function.</p>
</td></tr>
<tr><td><code id="recSplitConnMat_+3A_beta">beta</code></td>
<td>
<p>Controls degree of splitting of connectivity matrix,
with larger values generating more subpopulations.</p>
</td></tr>
<tr><td><code id="recSplitConnMat_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+splitConnMat">splitConnMat</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson,
P. R. 2012. Identification of subpopulations from connectivity
matrices. Ecography, 35: 1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+optimalSplitConnMat">optimalSplitConnMat</a></code>,
<code><a href="#topic+splitConnMat">splitConnMat</a></code>,
<code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code>
</p>

<hr>
<h2 id='reducedConnMat'>Reduced connectivity matrix according to a set of subpopulations</h2><span id='topic+reducedConnMat'></span>

<h3>Description</h3>

<p>Reduces a connectivity matrix based on a set of subpopulations.  If there are
N subpopulations, then the reduced matrix will have dimensions NxN.  The 
reduced matrix will be ordered according to the order of subpopulations in 
<code>subpops.lst</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reducedConnMat(subpops.lst, conn.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reducedConnMat_+3A_subpops.lst">subpops.lst</code></td>
<td>
<p>A list whose elements are vectors of indices for each 
subpopulation.  If a vector of integers is given, then 
<code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code> is applied to convert it to a list of 
subpopulations.</p>
</td></tr>
<tr><td><code id="reducedConnMat_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reduced connectivity matrix.  The sum of all elements of this
reduced connectivity matrix will be equal to the sum of all elements of the
original connectivity matrix.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson, P. R. 2012. 
Identification of subpopulations from connectivity matrices. Ecography, 35:
1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+qualitySubpops">qualitySubpops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(chile.loco)

num &lt;- prod(dim(chile.loco)) / sum(chile.loco)
betas &lt;- betasVectorDefault(n=num,steps=4)
chile.loco.split &lt;- optimalSplitConnMat(chile.loco,normalize.cols=FALSE,
                                        betas=betas)

# Extra 3rd division
print(paste("Examining split with",names(chile.loco.split$best.splits)[1],
            "subpopulations."))
pops &lt;- subpopsVectorToList(chile.loco.split$subpops[,chile.loco.split$best.splits[[1]]$index])

reduce.loco &lt;- reducedConnMat(pops,chile.loco)

sr &lt;- selfRecruitment(reduce.loco)
lr &lt;- localRetention(reduce.loco)
rlr &lt;- relativeLocalRetention(reduce.loco)
</code></pre>

<hr>
<h2 id='relativeLocalRetention'>Relative local retention of a connectivity matrix</h2><span id='topic+relativeLocalRetention'></span>

<h3>Description</h3>

<p>Relative local retention is defined as the diagonal elements of the
connectivity matrix divided by the sum of the corresponding column of the
connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relativeLocalRetention(conn.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relativeLocalRetention_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(chile.loco)

sr &lt;- selfRecruitment(chile.loco)
lr &lt;- localRetention(chile.loco)
rlr &lt;- relativeLocalRetention(chile.loco)
</code></pre>

<hr>
<h2 id='selfRecruitment'>Self recruitment of a connectivity matrix</h2><span id='topic+selfRecruitment'></span>

<h3>Description</h3>

<p>If egg production is uniform over sites, then self recruitment is defined as 
the diagonal elements of the connectivity matrix divided by the sum of the 
corresponding row of the connectivity matrix.  If not, then the elements of 
the dispersal matrix must be weighted by the number of eggs produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selfRecruitment(conn.mat, eggs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selfRecruitment_+3A_conn.mat">conn.mat</code></td>
<td>
<p>A square connectivity matrix.</p>
</td></tr>
<tr><td><code id="selfRecruitment_+3A_eggs">eggs</code></td>
<td>
<p>A vector of egg production values for each site.  Defaults to
<code>NULL</code>, equivalent to assuming all sites have equal egg production.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(chile.loco)

sr &lt;- selfRecruitment(chile.loco)
lr &lt;- localRetention(chile.loco)
rlr &lt;- relativeLocalRetention(chile.loco)
</code></pre>

<hr>
<h2 id='settlerRecruitSlopeCorrection'>Correction for slope of settler-recruit relationship</h2><span id='topic+settlerRecruitSlopeCorrection'></span>

<h3>Description</h3>

<p>This function corrects the slope of the settler-recruit curve so that the 
collapse point of the spatially-explicit population model corresponding to 
the connectivity matrix agrees with that of the global non-spatially-explicit
model.  Uses the method in White (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>settlerRecruitSlopeCorrection(
  conn.mat,
  slope = 1,
  natural.LEP = 1,
  critical.FLEP = 0.35,
  use.arpack = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="settlerRecruitSlopeCorrection_+3A_conn.mat">conn.mat</code></td>
<td>
<p>a square connectivity matrix.</p>
</td></tr>
<tr><td><code id="settlerRecruitSlopeCorrection_+3A_slope">slope</code></td>
<td>
<p>slope at the origin of the settler-recruit relationship.  Only 
interesting to fix this argument if it is a vector of length = 
<code>dim(conn.mat)[2]</code> (i.e., if the slope varies among sites and one
wants to globally scale all slopes so that the collapse point matches the
global collapse point).</p>
</td></tr>
<tr><td><code id="settlerRecruitSlopeCorrection_+3A_natural.lep">natural.LEP</code></td>
<td>
<p>value of lifetime-egg-production (LEP), also known as 
eggs-per-recruit, in the absence of fishing.  Can be a vector of length = 
<code>dim(conn.mat)[2]</code>.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="settlerRecruitSlopeCorrection_+3A_critical.flep">critical.FLEP</code></td>
<td>
<p>Fraction of natural.LEP at which collapse occurs. 
Defaults to 0.35.</p>
</td></tr>
<tr><td><code id="settlerRecruitSlopeCorrection_+3A_use.arpack">use.arpack</code></td>
<td>
<p>Boolean determining if calculation is to be done with 
<code><a href="igraph.html#topic+arpack">arpack</a></code> function from the <a href="igraph.html#topic+igraph">igraph</a> package. This is much 
quicker for large matrices, but requires <a href="igraph.html#topic+igraph">igraph</a>. Defaults to TRUE, 
but will use eigen instead if <a href="igraph.html#topic+igraph">igraph</a> is not found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The slope argument corrected so that collapse happens when LEP is 
critical.FLEP * natural.LEP.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>White, J. W. 2010. Adapting the steepness parameter from 
stock-recruit curves for use in spatially explicit models. Fisheries 
Research, 102: 330-334.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+eigs">eigs</a></code>, <code><a href="igraph.html#topic+arpack">arpack</a></code>
</p>

<hr>
<h2 id='splitConnMat'>Split connectivity matrix into subpopulations</h2><span id='topic+splitConnMat'></span>

<h3>Description</h3>

<p>This function tries to optimally split a given subpopulation into
two smaller subpopulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitConnMat(
  indices,
  conn.mat,
  beta,
  tries = 5,
  threshold = 1e-10,
  alpha = 0.1,
  maxit = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitConnMat_+3A_indices">indices</code></td>
<td>
<p>vector of indices of sites in a subpopulation</p>
</td></tr>
<tr><td><code id="splitConnMat_+3A_conn.mat">conn.mat</code></td>
<td>
<p>a square connectivity matrix.  This matrix has
typically been normalized and made symmetric prior to using this
function.</p>
</td></tr>
<tr><td><code id="splitConnMat_+3A_beta">beta</code></td>
<td>
<p>controls degree of splitting of connectivity matrix,
with larger values generating more subpopulations.</p>
</td></tr>
<tr><td><code id="splitConnMat_+3A_tries">tries</code></td>
<td>
<p>how many times to restart the optimization algorithm. Defaults to 5.</p>
</td></tr>
<tr><td><code id="splitConnMat_+3A_threshold">threshold</code></td>
<td>
<p>controls when to stop each &quot;try&quot;.  Defaults to 1e-10.</p>
</td></tr>
<tr><td><code id="splitConnMat_+3A_alpha">alpha</code></td>
<td>
<p>controls rate of convergence to solution</p>
</td></tr>
<tr><td><code id="splitConnMat_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to perform per &quot;try&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with one or two elements, each containing a vector of
indices of sites in a subpopulations
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>References</h3>

<p>Jacobi, M. N., Andre, C., Doos, K., and Jonsson,
P. R. 2012. Identification of subpopulations from connectivity
matrices. Ecography, 35: 1004-1016.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+optimalSplitConnMat">optimalSplitConnMat</a></code>,
<code><a href="#topic+recSplitConnMat">recSplitConnMat</a></code>,
<code><a href="#topic+subpopsVectorToList">subpopsVectorToList</a></code>
</p>

<hr>
<h2 id='stepfun.hist'>Create a probability density step function from a histogram object</h2><span id='topic+stepfun.hist'></span>

<h3>Description</h3>

<p>This function creates a step function from the bars in a <code>histogram</code> 
object. By default, the step function will be normalized so that it 
integrates to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepfun.hist(h, ..., normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepfun.hist_+3A_h">h</code></td>
<td>
<p>an object of type <code>histogram</code></p>
</td></tr>
<tr><td><code id="stepfun.hist_+3A_...">...</code></td>
<td>
<p>Additional arguments for the default <code><a href="stats.html#topic+stepfun">stepfun</a></code> 
function.</p>
</td></tr>
<tr><td><code id="stepfun.hist_+3A_normalize">normalize</code></td>
<td>
<p>Boolean indicating whether or not to normalize the output 
stepfun so that it integrates to 1. Defaults to <code>TRUE</code>.  If 
<code>FALSE</code>, then the function will integrate to <code>sum(h$counts)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function of class <code>stepfun</code>.  The height of the steps will be
divided by the distance between breaks and possibly the total count.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+d.rel.conn.dists.func">d.rel.conn.dists.func</a></code>,
<code><a href="#topic+optim.rel.conn.dists">optim.rel.conn.dists</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ConnMatTools)
data(damselfish.lods)

# Histograms of simulated LODs
l &lt;- seq(-1,30,0.5)
h.in &lt;- hist(damselfish.lods$in.group,breaks=l)
h.out &lt;- hist(damselfish.lods$out.group,breaks=l)

# PDFs for marked and unmarked individuals based on simulations
d.marked &lt;- stepfun.hist(h.in)
d.unmarked &lt;- stepfun.hist(h.out)

# Fraction of adults genotyped at source site
p.adults &lt;- 0.25

# prior.shape1=1 # Uniform prior
prior.shape1=0.5 # Jeffreys prior

# Fraction of eggs from one or more genotyped parents
p &lt;- dual.mark.transmission(p.adults)$p

# PDF for relative connectivity
D &lt;- d.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Estimate most probable value for relative connectivity
phi.mx &lt;- optim.rel.conn.dists(damselfish.lods$real.children,
                                    d.unmarked,d.marked,p)$phi

# Estimate 95% confidence interval for relative connectivity
Q &lt;- q.rel.conn.dists.func(damselfish.lods$real.children,
                           d.unmarked,d.marked,p,
                           prior.shape1=prior.shape1)

# Plot it up
phi &lt;- seq(0,1,0.001)
plot(phi,D(phi),type="l",
     xlim=c(0,0.1),
     main="PDF for relative connectivity",
     xlab=expression(phi),
     ylab="Probability density")

abline(v=phi.mx,col="green",lty="dashed")
abline(v=Q(c(0.025,0.975)),col="red",lty="dashed")
</code></pre>

<hr>
<h2 id='subpopsVectorToList'>Convert subpopulation vector to a list of indices</h2><span id='topic+subpopsVectorToList'></span>

<h3>Description</h3>

<p>A helper function to convert a vector of subpopulation identifications into a
list appropriate for <code><a href="#topic+recSplitConnMat">recSplitConnMat</a></code>,
<code><a href="#topic+qualitySubpops">qualitySubpops</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subpopsVectorToList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subpopsVectorToList_+3A_x">x</code></td>
<td>
<p>vector of subpopulation identifications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that subpopulations list will be ordered according to the numerical
order of the subpopulation indices in the original matrix, which will not
necessarily be that of the spatial order of sites in the original
connectivity matrix.
</p>


<h3>Value</h3>

<p>A list where each element is a vector of indices for a given 
subpopulation.
</p>


<h3>Author(s)</h3>

<p>David M. Kaplan <a href="mailto:dmkaplan2000@gmail.com">dmkaplan2000@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+recSplitConnMat">recSplitConnMat</a></code>, <code><a href="#topic+qualitySubpops">qualitySubpops</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
