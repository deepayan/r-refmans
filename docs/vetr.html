<!DOCTYPE html><html><head><title>Help for package vetr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vetr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vetr-package'><p>Trust, but Verify</p></a></li>
<li><a href='#abstract'><p>Turn S3 Objects Into Templates</p></a></li>
<li><a href='#abstract.ggplot'><p>Experimental Abstraction Method for GGPlot</p></a></li>
<li><a href='#alike'><p>Compare Object Structure</p></a></li>
<li><a href='#all_bw'><p>Verify Values in Vector are Between Two Others</p></a></li>
<li><a href='#bench_mark'><p>Lightweight Benchmarking Function</p></a></li>
<li><a href='#nullify'><p>Set Element to NULL Without Removing It</p></a></li>
<li><a href='#type_alike'><p>Compare Types of Objects</p></a></li>
<li><a href='#type_of'><p>A Fuzzier Version of <code>typeof()</code></p></a></li>
<li><a href='#vet'><p>Verify Objects Meet Structural Requirements</p></a></li>
<li><a href='#vet_token'><p>Vetting Tokens With Custom Error Messages</p></a></li>
<li><a href='#vetr'><p>Verify Function Arguments Meet Structural Requirements</p></a></li>
<li><a href='#vetr_settings'><p>Generate Control Settings For vetr and alike</p></a></li>
<li><a href='#vetr-interal'><p>Test Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Trust, but Verify</td>
</tr>
<tr>
<td>Description:</td>
<td>Declarative template-based framework for verifying that objects
  meet structural requirements, and auto-composing error messages when they do
  not.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.16</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/brodieG/vetr">https://github.com/brodieG/vetr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brodieG/vetr/issues">https://github.com/brodieG/vetr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, unitizer</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 00:54:39 UTC; bg</td>
</tr>
<tr>
<td>Author:</td>
<td>Brodie Gaslam [aut, cre],
  Paxdiablo [cph] (Hash table implementation in src/pfhash.h),
  R Core Team [cph] (Used/adapted several code snippets from R sources,
    see src/r-copied.c)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brodie Gaslam &lt;brodie.gaslam@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 03:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vetr-package'>Trust, but Verify</h2><span id='topic+vetr-package'></span>

<h3>Description</h3>

<p>Declarative template-based framework for verifying that objects meet
structural requirements, and auto-composing error messages when they do not.
</p>

<hr>
<h2 id='abstract'>Turn S3 Objects Into Templates</h2><span id='topic+abstract'></span><span id='topic+abstract.data.frame'></span><span id='topic+abstract.default'></span><span id='topic+abstract.array'></span><span id='topic+abstract.matrix'></span><span id='topic+abstract.list'></span><span id='topic+abstract.lm'></span><span id='topic+abstract.environment'></span><span id='topic+abstract.ts'></span>

<h3>Description</h3>

<p>Create templates for use by <code><a href="#topic+alike">alike</a></code>. Currently somewhat
experimental; behavior may change in future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abstract(x, ...)

## S3 method for class 'data.frame'
abstract(x, ...)

## Default S3 method:
abstract(x, ...)

## S3 method for class 'array'
abstract(x, ...)

## S3 method for class 'matrix'
abstract(x, ...)

## S3 method for class 'list'
abstract(x, ...)

## S3 method for class 'lm'
abstract(x, ...)

## S3 method for class 'environment'
abstract(x, ...)

## S3 method for class 'ts'
abstract(x, what = c("start", "end", "frequency"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abstract_+3A_x">x</code></td>
<td>
<p>the object to abstract</p>
</td></tr>
<tr><td><code id="abstract_+3A_...">...</code></td>
<td>
<p>arguments for methods that require further arguments</p>
</td></tr>
<tr><td><code id="abstract_+3A_what">what</code></td>
<td>
<p>for time series which portion of the <code>ts</code> attribute to
abstract, by default all three are abstracted, but you can select, any one,
two, or all</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>abstract</code> is intended to create templates for use by
<code><a href="#topic+alike">alike</a></code>.  The result of abstraction is often a partially
specified object.  This type of object may not be suited for use in typical
R computations and may cause errors (or worse) if you try to use them as
normal R objects.
</p>
<p>There is no guarantee that the <code>abstract</code>ed object is suitable for use
as a template to <code>alike</code> as is.  You may need to modify it further so
that it suits your purposes.
</p>
<p><code>abstract</code> is an S3 generic.  The default method will
dispatch on implicit classes, so if you attempt to <code>abstract</code> an object
without an explicit <code>abstract</code> method, it will get abstracted based on
its implicit class.  If you define your own <code>abstract</code> method and do not
wish further abstraction based on implicit classes do not use
<code><a href="base.html#topic+NextMethod">NextMethod</a></code>.
</p>
<p>S4 and RC objects are returned unchanged.
</p>


<h3>Value</h3>

<p>abstracted object
</p>


<h3>Time Series</h3>

<p><code><a href="#topic+alike">alike</a></code> will treat time series parameter components with zero in
them as wildcards.  This function allows you to create these wild card time
series attributes since R does not allow direct creation/modification of
<code>ts</code> attributes with zero values.
</p>
<p>Make sure you do not try to use the templates you create with this for
anything other than as <code><a href="#topic+alike">alike</a></code> templates since the result is
likely undefined given R expects non zero values for the <code>ts</code>
attribute and attempts to prevent such attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.tpl &lt;- abstract(iris)
alike(iris.tpl, iris[1:10, ])
alike(iris.tpl, transform(iris, Species=as.character(Species)))

abstract(1:10)
abstract(matrix(1:9, nrow=3))
abstract(list(1:9, runif(10)))
</code></pre>

<hr>
<h2 id='abstract.ggplot'>Experimental Abstraction Method for GGPlot</h2><span id='topic+abstract.ggplot'></span>

<h3>Description</h3>

<p>Not entirely sure this can ever work well since so much of <code>ggplot</code> is
done with <code>proto</code> objects and those do not really use meta data, which
makes <code>alike</code> rather useless.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggplot'
abstract(x, ...)
</code></pre>

<hr>
<h2 id='alike'>Compare Object Structure</h2><span id='topic+alike'></span>

<h3>Description</h3>

<p>Similar to <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>, but compares object structure rather than
value.  The <code>target</code> argument defines a template that the <code>current</code>
argument must match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alike(target, current, env = parent.frame(), settings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alike_+3A_target">target</code></td>
<td>
<p>the template to compare the object to</p>
</td></tr>
<tr><td><code id="alike_+3A_current">current</code></td>
<td>
<p>the object to determine alikeness of to the template</p>
</td></tr>
<tr><td><code id="alike_+3A_env">env</code></td>
<td>
<p>environment used internally when evaluating expressions; currently
used only when looking up functions to <code><a href="base.html#topic+match.call">match.call</a></code> when
testing language objects, note that this will be overridden by the
environment specified in <code>settings</code> if any, defaults to the parent
frame.</p>
</td></tr>
<tr><td><code id="alike_+3A_settings">settings</code></td>
<td>
<p>a list of settings generated using <code>vetr_settings</code>, NULL
for default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if target and current are alike, character(1L) describing why
they are not if they are not
</p>


<h3>alikeness</h3>

<p>Generally speaking two objects are alike if they are of the same type (as
determined by <code><a href="#topic+type_alike">type_alike</a></code>) and length.  Attributes on the
objects are required to be recursively <code>alike</code>, though the following
attributes are treated specially: <code>class</code>, <code>dim</code>, <code>dimnames</code>,
<code>names</code>, <code>row.names</code>, <code>levels</code>, <code>tsp</code>, and <code>srcref</code>.
</p>
<p>Exactly what makes two objects <code>alike</code> is complex, but should be
intuitive.  The best way to understand &quot;alikeness&quot; is to review the examples.
For a thorough exposition see <a href="../doc/alike.html">the vignette</a>.
</p>
<p>Note that the semantics of alikeness for language objects, formulas, and
functions may change in the future.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type_alike">type_alike</a></code>, <code><a href="#topic+type_of">type_of</a></code>,
<code><a href="#topic+abstract">abstract</a></code>, <code><a href="#topic+vetr_settings">vetr_settings</a></code> for more control of
settings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Type comparison
alike(1L, 1.0)         # TRUE, because 1.0 is integer-like
alike(1L, 1.1)         # FALSE, 1.1 is not integer-like
alike(1.1, 1L)         # TRUE, by default, integers are always considered real

alike(1:100, 1:100 + 0.0)  # TRUE

## We do not check numerics for integerness if longer than 100
alike(1:101, 1:101 + 0.0)

## Scalarness can now be checked at same time as type
alike(integer(1L), 1)            # integer-like and length 1?
alike(logical(1L), TRUE)         # logical and length 1?
alike(integer(1L), 1:3)
alike(logical(1L), c(TRUE, TRUE))

## Zero length match any length of same type
alike(integer(), 1:10)
alike(1:10, integer())   # but not the other way around

## Recursive objects compared recursively
alike(
  list(integer(), list(character(), logical(1L))),
  list(1:10, list(letters, TRUE))
)
alike(
  list(integer(), list(character(), logical(1L))),
  list(1:10, list(letters, c(TRUE, FALSE)))
)

## `NULL` is a wild card when nested within recursive objects
alike(list(NULL, NULL), list(iris, mtcars))
alike(NULL, mtcars)    # but not at top level

## Since `data.frame` are lists, we can compare them recursively:
iris.fake &lt;- transform(iris, Species=as.character(Species))
alike(iris, iris.fake)

## we even check attributes (factor levels must match)!
iris.fake2 &lt;- iris
levels(iris.fake2$Species) &lt;- c("setosa", "versicolor", "africana")
alike(iris, iris.fake2)

## We can use partially specified objects as templates
iris.tpl &lt;- abstract(iris)
str(iris.tpl)
alike(iris.tpl, iris)
## any row sample of iris matches our iris template
alike(iris.tpl, iris[sample(1:nrow(iris), 10), ])
## but column order matters
alike(iris.tpl, iris[c(2, 1, 3, 4, 5)])

## 3 x 3 integer
alike(matrix(integer(), 3, 3), matrix(1:9, nrow=3))
## 3 x 3, but not integer!
alike(matrix(integer(), 3, 3), matrix(runif(9), nrow=3))
## partial spec, any 3 row integer matrix
alike(matrix(integer(), 3), matrix(1:12, nrow=3))
alike(matrix(integer(), 3), matrix(1:12, nrow=4))
## Any logical matrix (but not arrays)
alike(matrix(logical()), array(rep(TRUE, 8), rep(2, 3)))

## In order for objects to be alike, they must share a family
## tree, not just a common class
obj.tpl &lt;- structure(TRUE, class=letters[1:3])
obj.cur.1 &lt;-  structure(TRUE, class=c("x", letters[1:3]))
obj.cur.2 &lt;-  structure(TRUE, class=c(letters[1:3], "x"))

alike(obj.tpl, obj.cur.1)
alike(obj.tpl, obj.cur.2)

## You can compare language objects; these are alike if they are self
## consistent; we don't care what the symbols are, so long as they are used
## consistently across target and current:

## TRUE, symbols are consistent (adding two different symbols)
alike(quote(x + y), quote(a + b))
## FALSE, different function
alike(quote(x + y), quote(a - b))
## FALSE, inconsistent symbols
alike(quote(x + y), quote(a + a))
</code></pre>

<hr>
<h2 id='all_bw'>Verify Values in Vector are Between Two Others</h2><span id='topic+all_bw'></span>

<h3>Description</h3>

<p>Similar to <code>isTRUE(all(x &gt;= lo &amp; x &lt;= hi))</code> with default settings,
except that it is substantially faster and returns a string describing the
first encountered violation rather than FALSE on failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_bw(x, lo = -Inf, hi = Inf, na.rm = FALSE, bounds = "[]")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_bw_+3A_x">x</code></td>
<td>
<p>vector logical (treated as integer), integer, numeric, or character.
Factors are treated as their underlying integer vectors.</p>
</td></tr>
<tr><td><code id="all_bw_+3A_lo">lo</code></td>
<td>
<p>scalar vector of type coercible to the type of <code>x</code>, cannot be NA,
use <code>-Inf</code> to indicate unbounded (default).</p>
</td></tr>
<tr><td><code id="all_bw_+3A_hi">hi</code></td>
<td>
<p>scalar vector of type coercible to the type of <code>x</code>, cannot be NA,
use <code>Inf</code> to indicate unbounded (default), must be greater than or equal to
<code>lo</code>.</p>
</td></tr>
<tr><td><code id="all_bw_+3A_na.rm">na.rm</code></td>
<td>
<p>TRUE, or FALSE (default), whether NAs are considered to be
in bounds.  Unlike with <code><a href="base.html#topic+all">all()</a></code>, for <code>all_bw</code> <code>na.rm=FALSE</code> returns an
error string if there are NAs instead of NA.  Arguably NA, but not NaN,
should be considered to be in <code style="white-space: pre;">&#8288;[-Inf,Inf]&#8288;</code>, but since <code>NA &lt; Inf</code> is NA we
treat them as always being out of bounds.</p>
</td></tr>
<tr><td><code id="all_bw_+3A_bounds">bounds</code></td>
<td>
<p><code>character(1L)</code> for values between <code>lo</code> and <code>hi</code>:
</p>

<ul>
<li> <p>&ldquo;[]&rdquo; include <code>lo</code> and <code>hi</code>
</p>
</li>
<li> <p>&ldquo;()&rdquo; exclude <code>lo</code> and <code>hi</code>
</p>
</li>
<li> <p>&ldquo;(]&rdquo; exclude <code>lo</code>, include <code>hi</code>
</p>
</li>
<li> <p>&ldquo;[)&rdquo; include <code>lo</code>, exclude <code>hi</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can modify the comparison to be strictly greater/less than via the
<code>bounds</code> parameter, and the treatment of NAs with <code>na.rm</code>.  Note that NAs are
considered to be out of bounds by default.  While technically incorrect
since we cannot know whether an NA value is in or out of bounds, this
assumption is both conservative and convenient.  Zero length <code>x</code> will always
succeed.
</p>
<p>If <code>x</code> and <code>lo</code>/<code>hi</code> are different types, <code>lo</code>/<code>hi</code> will be coerced to the
type of <code>x</code>.  When <code>lo</code>/<code>hi</code> are numeric and <code>x</code> is integer, if <code>lo</code>/<code>hi</code>
values are outside of the integer range then that side will be treated as if
you had used <code>-Inf</code>/<code>Inf</code>.  <code>-Inf</code> and <code>Inf</code> mean <code>lo</code> and <code>hi</code> will be
unbounded for all data types.
</p>


<h3>Value</h3>

<p>TRUE if all values in <code>x</code> conform to the specified bounds, a string
describing the first position that fails otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_bw(runif(100), 0, 1)
all_bw(runif(100) * 2, 0, 1)
all_bw(NA, 0, 1)              # This is does not return NA
all_bw(NA, 0, 1, na.rm=TRUE)

vec &lt;- c(runif(100, 0, 1e12), Inf, 0)
all_bw(vec, 0)      # All +ve numbers
all_bw(vec, hi=0)   # All -ve numbers
all_bw(vec, 0, bounds="(]") # All strictly +ve nums
all_bw(vec, 0, bounds="[)") # All finite +ve nums
</code></pre>

<hr>
<h2 id='bench_mark'>Lightweight Benchmarking Function</h2><span id='topic+bench_mark'></span>

<h3>Description</h3>

<p>Evaluates provided expression in a loop and reports mean evaluation time.
This is inferior to <code>microbenchmark</code> and other benchmarking tools in many
ways except that it has zero dependencies or suggests which helps with
package build and test times.  Used in vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bench_mark(..., times = 1000L, deparse.width = 40)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bench_mark_+3A_...">...</code></td>
<td>
<p>expressions to benchmark, are captured unevaluated</p>
</td></tr>
<tr><td><code id="bench_mark_+3A_times">times</code></td>
<td>
<p>how many times to loop, defaults to 1000</p>
</td></tr>
<tr><td><code id="bench_mark_+3A_deparse.width">deparse.width</code></td>
<td>
<p>how many characters to deparse for labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs <code><a href="base.html#topic+gc">gc()</a></code> before each expression is evaluated.  Expressions are evaluated
in the order provided.  Attempts to estimate the overhead of the loop by
running a loop that evaluates <code>NULL</code> the <code>times</code> times.
</p>
<p>Unfortunately because this computes the average of all iterations it is very
susceptible to outliers in small sample runs, particularly with fast running
code.  For that reason the default number of iterations is one thousand.
</p>


<h3>Value</h3>

<p>NULL, invisibly, reports timings as a side effect as screen output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bench_mark(runif(1000), Sys.sleep(0.001), times=10)
</code></pre>

<hr>
<h2 id='nullify'>Set Element to NULL Without Removing It</h2><span id='topic+nullify'></span><span id='topic+nullify.default'></span>

<h3>Description</h3>

<p>This function is required because there is no straightforward way to
over-write a value in a list with NULL without completely removing the entry
from the list as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullify(obj, index)

## Default S3 method:
nullify(obj, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nullify_+3A_obj">obj</code></td>
<td>
<p>the R object to NULL a value in</p>
</td></tr>
<tr><td><code id="nullify_+3A_index">index</code></td>
<td>
<p>an indexing vectors of values to NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns a copy of the object modified with null slots; it does
not modify the input argument.
</p>
<p>Default method will attempt to convert non-list objects to lists
with <code><a href="base.html#topic+as.list">as.list</a></code>, and then back to whatever they were by using a
function with name <code>paste0("as.", class(obj)[[1L]])</code>
if it exists and works.  If the object cannot be coerced back
to its original type the corresponding list will be returned.
</p>
<p>If this is not appropriate for your object type you can write an S3 method
for it.
</p>


<h3>Value</h3>

<p>object with selected values NULLified
</p>


<h3>Note</h3>

<p>attributes are copied from original object and re-applied to final
object before return, which may
not make sense in some circumstances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nullify(list(1, 2, 3), 2)
nullify(call("fun", 1, 2, 3), 2)
</code></pre>

<hr>
<h2 id='type_alike'>Compare Types of Objects</h2><span id='topic+type_alike'></span>

<h3>Description</h3>

<p>By default, checks <code><a href="#topic+type_of">type_of()</a></code> objects and two objects are
considered <code>type_alike</code> if they have the same type.  There is special
handling for integers, numerics, and functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_alike(target, current, settings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_alike_+3A_target">target</code></td>
<td>
<p>the object to test type alikeness against</p>
</td></tr>
<tr><td><code id="type_alike_+3A_current">current</code></td>
<td>
<p>the object to test the type alikeness of</p>
</td></tr>
<tr><td><code id="type_alike_+3A_settings">settings</code></td>
<td>
<p>NULL, or a list as produced by <code><a href="#topic+vetr_settings">vetr_settings()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For integers and numerics, if <code>current</code> is integer or integer-like
(e.g. 1.0) it will match real or integer <code>target</code> values.  Closures,
built-ins, and specials are all treated as type function.
</p>
<p>Specific behavior can be tuned with the <code>type.mode</code> parameter to the
<code><a href="#topic+vetr_settings">vetr_settings()</a></code> object passed as the <code>settings</code> parameter to this function.
</p>


<h3>See Also</h3>

<p>type_of, alike, <code><a href="#topic+vetr_settings">vetr_settings()</a></code>, in particular the section about
the <code>type.mode</code> parameter which affects how this function behaves.
</p>

<hr>
<h2 id='type_of'>A Fuzzier Version of <code><a href="base.html#topic+typeof">typeof()</a></code></h2><span id='topic+type_of'></span>

<h3>Description</h3>

<p>Numerics that are equivalent to integers (e.g <code>x == floor(x)</code>) are
classified as integers, and builtin and special functions are reported as
closures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_of(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_of_+3A_object">object</code></td>
<td>
<p>the object to check the type of</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character(1L) the type of the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
type_of(1.0001)          # numeric
type_of(1.0)             # integer (`typeof` returns numeric)
type_of(1)               # integer (`typeof` returns numeric)
type_of(sum)             # closure (`typeof` returns builtin)
type_of(`$`)             # closure (`typeof` returns special)
</code></pre>

<hr>
<h2 id='vet'>Verify Objects Meet Structural Requirements</h2><span id='topic+vet'></span><span id='topic+tev'></span>

<h3>Description</h3>

<p>Use vetting expressions to enforce structural requirements for objects.
<code>tev</code> is a version of <code>vet</code> compatible with <code>magrittr</code> pipes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vet(
  target,
  current,
  env = parent.frame(),
  format = "text",
  stop = FALSE,
  settings = NULL
)

tev(
  current,
  target,
  env = parent.frame(),
  format = "text",
  stop = FALSE,
  settings = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vet_+3A_target">target</code></td>
<td>
<p>a template, a vetting expression, or a compound expression</p>
</td></tr>
<tr><td><code id="vet_+3A_current">current</code></td>
<td>
<p>an object to vet</p>
</td></tr>
<tr><td><code id="vet_+3A_env">env</code></td>
<td>
<p>the environment to match calls and evaluate vetting expressions
in; will be ignored if an environment is also specified via
<code><a href="#topic+vetr_settings">vetr_settings()</a></code>.  Defaults to calling frame.</p>
</td></tr>
<tr><td><code id="vet_+3A_format">format</code></td>
<td>
<p>character(1L), controls the format of the return value for
<code>vet</code>, in case of failure.  One of:</p>

<ul>
<li><p> &quot;text&quot;: (default) character(1L) message for use elsewhere in code
</p>
</li>
<li><p> &quot;full&quot;: character(1L) the full error message used in &quot;stop&quot; mode,
but actually returned instead of thrown as an error
</p>
</li>
<li><p> &quot;raw&quot;: character(N) least processed version of the error message
with none of the formatting or surrounding verbiage
</p>
</li></ul>
</td></tr>
<tr><td><code id="vet_+3A_stop">stop</code></td>
<td>
<p>TRUE or FALSE whether to call <code><a href="base.html#topic+stop">stop()</a></code> on failure
or not (default)</p>
</td></tr>
<tr><td><code id="vet_+3A_settings">settings</code></td>
<td>
<p>a settings list as produced by <code><a href="#topic+vetr_settings">vetr_settings()</a></code>, or NULL to
use the default settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tev</code> just reverses the <code>target</code> and <code>current</code> arguments for better
integration with <code>magrittr</code>.  There are two major caveats:
</p>

<ul>
<li><p> error messages will be less useful since you will get <code>.</code> instead
of the deparsed call
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;x \\%&gt;\\% tev(y)&#8288;</code> is much slower than <code>vet(y, x)</code> (or even <code>tev(x, y)</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>TRUE if validation succeeds, otherwise varies according to value
chosen with parameter <code>stop</code>
</p>


<h3>Vetting Expressions</h3>

<p>Vetting expressions can be template tokens, standard tokens, or any
combination of template and standard tokens combined with <code>&amp;&amp;</code> and/or
<code>||</code>.  Template tokens are R objects that define the required structure,
much like the <code>FUN.VALUE</code> argument to <code><a href="base.html#topic+vapply">vapply()</a></code>.  Standard tokens are tokens
that contain the <code>.</code> symbol and are used to vet values.
</p>
<p>If you do use the <code>.</code> symbol in your vetting expressions in your
packages, you will need to include <code>utils::globalVariables(".")</code> as a
top-level call to avoid the &quot;no visible binding for global variable '.'&quot;'
R CMD check NOTE.
</p>
<p>See <code>vignette('vetr', package='vetr')</code> and examples for details on how
to craft vetting expressions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vetr">vetr()</a></code> for a version optimized to vet function arguments,
<code><a href="#topic+alike">alike()</a></code> for how templates are used, <code><a href="#topic+vet_token">vet_token()</a></code> for how to specify
custom error messages and also for predefined validation tokens for common
use cases, <code><a href="#topic+all_bw">all_bw()</a></code> for fast bounds checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## template vetting
vet(numeric(2L), runif(2))
vet(numeric(2L), runif(3))
vet(numeric(2L), letters)
try(vet(numeric(2L), letters, stop=TRUE))

## `tev` just reverses target and current for use with maggrittr
## Not run: 
if(require(magrittr)) {
  runif(2) %&gt;% tev(numeric(2L))
  runif(3) %&gt;% tev(numeric(2L))
}

## End(Not run)
## Zero length templates are wild cards
vet(numeric(), runif(2))
vet(numeric(), runif(100))
vet(numeric(), letters)

## This extends to data.frames
iris.tpl &lt;- iris[0,]   # zero row matches any # of rows
iris.1 &lt;- iris[1:10,]
iris.2 &lt;- iris[1:10, c(1,2,3,5,4)]  # change col order
vet(iris.tpl, iris.1)
vet(iris.tpl, iris.2)

## Short (&lt;100 length) integer-like numerics will
## pass for integer
vet(integer(), c(1, 2, 3))
vet(integer(), c(1, 2, 3) + 0.1)

## Nested templates; note, in packages you should consider
## defining templates outside of `vet` or `vetr` so that
## they are computed on load rather that at runtime
tpl &lt;- list(numeric(1L), matrix(integer(), 3))
val.1 &lt;- list(runif(1), rbind(1:10, 1:10, 1:10))
val.2 &lt;- list(runif(1), cbind(1:10, 1:10, 1:10))
vet(tpl, val.1)
vet(tpl, val.2)

## See `example(alike)` for more template examples

## Standard tokens allow you to check values
vet(. &gt; 0, runif(10))
vet(. &gt; 0, -runif(10))

## Zero length token results are considered TRUE,
## as is the case with `all(logical(0))`
vet(. &gt; 0, numeric())

## `all_bw` is like `isTRUE(all(. &gt;= x &amp; . &lt;= y))`, but
## ~10x faster for long vectors:
vet(all_bw(., 0, 1), runif(1e6) + .1)

## You can combine templates and standard tokens with
## `&amp;&amp;` and/or `||`
vet(numeric(2L) &amp;&amp; . &gt; 0, runif(2))
vet(numeric(2L) &amp;&amp; . &gt; 0, runif(10))
vet(numeric(2L) &amp;&amp; . &gt; 0, -runif(2))

## Using pre-defined tokens (see `?vet_token`)
vet(INT.1, 1)
vet(INT.1, 1:2)
vet(INT.1 &amp;&amp; . %in% 0:1 || LGL.1, TRUE)
vet(INT.1 &amp;&amp; . %in% 0:1 || LGL.1, 1)
vet(INT.1 &amp;&amp; . %in% 0:1 || LGL.1, NA)

## Vetting expressions can be assembled from previously
## defined tokens
scalar.num.pos &lt;- quote(numeric(1L) &amp;&amp; . &gt; 0)
foo.or.bar &lt;- quote(character(1L) &amp;&amp; . %in% c('foo', 'bar'))
vet.exp &lt;- quote(scalar.num.pos || foo.or.bar)

vet(vet.exp, 42)
vet(scalar.num.pos || foo.or.bar, 42)  # equivalently
vet(vet.exp, "foo")
vet(vet.exp, "baz")
</code></pre>

<hr>
<h2 id='vet_token'>Vetting Tokens With Custom Error Messages</h2><span id='topic+vet_token'></span><span id='topic+NO.NA'></span><span id='topic+NO.INF'></span><span id='topic+GTE.0'></span><span id='topic+LTE.0'></span><span id='topic+GT.0'></span><span id='topic+LT.0'></span><span id='topic+INT.1'></span><span id='topic+INT.1.POS'></span><span id='topic+INT.1.NEG'></span><span id='topic+INT.1.POS.STR'></span><span id='topic+INT.1.NEG.STR'></span><span id='topic+INT'></span><span id='topic+INT.POS'></span><span id='topic+INT.NEG'></span><span id='topic+INT.POS.STR'></span><span id='topic+INT.NEG.STR'></span><span id='topic+NUM.1'></span><span id='topic+NUM.1.POS'></span><span id='topic+NUM.1.NEG'></span><span id='topic+NUM'></span><span id='topic+NUM.POS'></span><span id='topic+NUM.NEG'></span><span id='topic+CHR.1'></span><span id='topic+CHR'></span><span id='topic+CPX'></span><span id='topic+CPX.1'></span><span id='topic+LGL'></span><span id='topic+LGL.1'></span>

<h3>Description</h3>

<p>Utility function to generate vetting tokens with attached error messages.
You should only need to use this if the error message produced naturally by
<code>vetr</code> is unclear.  Several predefined tokens created by this function
are also documented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vet_token(exp, err.msg = "%s")

NO.NA

NO.INF

GTE.0

LTE.0

GT.0

LT.0

INT.1

INT.1.POS

INT.1.NEG

INT.1.POS.STR

INT.1.NEG.STR

INT

INT.POS

INT.NEG

INT.POS.STR

INT.NEG.STR

NUM.1

NUM.1.POS

NUM.1.NEG

NUM

NUM.POS

NUM.NEG

CHR.1

CHR

CPX

CPX.1

LGL

LGL.1
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vet_token_+3A_exp">exp</code></td>
<td>
<p>an expression which will be captured but not evaluated.</p>
</td></tr>
<tr><td><code id="vet_token_+3A_err.msg">err.msg</code></td>
<td>
<p>character(1L) a message that tells the user what the
expected value should be, should contain a &quot;%s&quot; for <code>sprintf</code>
to use (e.g. &quot;%s should be greater than 2&quot;).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>call</code> of length 2.
</p>
<p>An object of class <code>call</code> of length 2.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>call</code> of length 3.
</p>


<h3>Details</h3>

<p>Allows you to supply error messages for vetting to use for each error
token.  Your token should not contain top level <code>&amp;&amp;</code> or <code>||</code>.  If
it does your error message will not be reported because <code>vetr</code> looks for
error messages attached to atomic tokens.  If your token must involve
top level <code>&amp;&amp;</code> or <code>||</code>, use <code>I(x &amp;&amp; y)</code> to ensure that
your error message is used by <code>vet</code>, but beware than in doing so you do
not use templates within the <code>I</code> call as everything therein will be
interpreted as a vetting expression rather than a template.
</p>
<p>Error messages are typically of the form &quot;%s should be XXX&quot;.
</p>
<p>This package ships with many predefined tokens for common use cases. They
are listed in the <code>Usage</code> section of this documentation.  The tokens
are named in format <code>TYPE[.LENGTH][.OTHER]</code>.  For example
<code>INT</code> will vet an integer vector, <code>INT.1</code> will vet a scalar integer
vector, and <code>INT.1.POS.STR</code> will vet a strictly positive integer vector.
At this time tokens are predefined for the basic types as scalars or
any-length vectors.  Some additional checks are available (e.g. positive only
values).
</p>
<p>Every one of the predefined vetting tokens documented here implicitly
disallows NAs.  Numeric tokens also disallow infinite values. If you wish
to allow NAs or infinite values just use a template object (e.g.
<code>integer(1L)</code>).
</p>


<h3>Value</h3>

<p>a quoted expressions with <code>err.msg</code> attribute set
</p>


<h3>Note</h3>

<p><strong>This will only work with standard tokens containing <code>.</code></strong>.  Anything
else will be interpreted as a template token.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vet">vet()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Predefined tokens:
vet(INT.1, 1:2)
vet(INT.1 || LGL, 1:2)
vet(INT.1 || LGL, c(TRUE, FALSE))

## Check squareness
mx &lt;- matrix(1:3)
SQR &lt;- vet_token(nrow(.) == ncol(.), "%s should be square")
vet(SQR, mx)

## Let `vetr` make up error message; note `quote` vs `vet_token`
## Often, `vetr` does fine without explictly specified err msg:
SQR.V2 &lt;- quote(nrow(.) == ncol(.))
vet(SQR.V2, mx)

## Combine some tokens, notice how we use `quote` at the combining
## step:
NUM.MX &lt;- vet_token(matrix(numeric(), 0, 0), "%s should be numeric matrix")
SQR.NUM.MX &lt;- quote(NUM.MX &amp;&amp; SQR)
vet(SQR.NUM.MX, mx)

## If instead we used `vet_token` the overall error message
## is not used; instead it falls back to the error message of
## the specific sub-token that fails:
NUM.MX &lt;- vet_token(matrix(numeric(), 0, 0), "%s should be numeric matrix")
SQR.NUM.MX.V2 &lt;-
  vet_token(NUM.MX &amp;&amp; SQR, "%s should be a square numeric matrix")
vet(SQR.NUM.MX.V2, mx)
</code></pre>

<hr>
<h2 id='vetr'>Verify Function Arguments Meet Structural Requirements</h2><span id='topic+vetr'></span>

<h3>Description</h3>

<p>Use vetting expressions to enforce structural requirements for function
arguments.  Works just like <code><a href="#topic+vet">vet()</a></code>, except that the formals of the
enclosing function automatically matched to the vetting expressions provided
in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vetr(..., .VETR_SETTINGS = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vetr_+3A_...">...</code></td>
<td>
<p>vetting expressions, each will be matched to the enclosing
function formals as with <code><a href="base.html#topic+match.call">match.call()</a></code> and will be used to validate the
value of the matching formal.</p>
</td></tr>
<tr><td><code id="vetr_+3A_.vetr_settings">.VETR_SETTINGS</code></td>
<td>
<p>a settings list as produced by <code><a href="#topic+vetr_settings">vetr_settings()</a></code>, or
NULL to use the default settings.  Note that this means you cannot use
<code>vetr</code> with a function that takes a <code>.VETR_SETTINGS</code> argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only named arguments may be vetted; in other words it is not possible to vet
arguments passed via <code>...</code>.
</p>


<h3>Value</h3>

<p>TRUE if validation succeeds, otherwise <code>stop</code> with error message
detailing nature of failure.
</p>


<h3>Vetting Expressions</h3>

<p>Vetting expressions can be template tokens, standard tokens, or any
combination of template and standard tokens combined with <code>&amp;&amp;</code> and/or
<code>||</code>.  Template tokens are R objects that define the required structure,
much like the <code>FUN.VALUE</code> argument to <code><a href="base.html#topic+vapply">vapply()</a></code>.  Standard tokens are tokens
that contain the <code>.</code> symbol and are used to vet values.
</p>
<p>If you do use the <code>.</code> symbol in your vetting expressions in your
packages, you will need to include <code>utils::globalVariables(".")</code> as a
top-level call to avoid the &quot;no visible binding for global variable '.'&quot;'
R CMD check NOTE.
</p>
<p>See <code>vignette('vetr', package='vetr')</code> and examples for details on how
to craft vetting expressions.
</p>


<h3>Note</h3>

<p><code>vetr</code> will force evaluation of any arguments that are being
checked (you may omit arguments that should not be evaluate from
<code>vetr</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vet">vet()</a></code>, in particular <code>example(vet)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun1 &lt;- function(x, y) {
  vetr(integer(), LGL.1)
  TRUE   # do some work
}
fun1(1:10, TRUE)
try(fun1(1:10, 1:10))

## only vet the second argument
fun2 &lt;- function(x, y) {
  vetr(y=LGL.1)
  TRUE   # do some work
}
try(fun2(letters, 1:10))

## Nested templates; note, in packages you should consider
## defining templates outside of `vet` or `vetr` so that
## they are computed on load rather that at runtime
tpl &lt;- list(numeric(1L), matrix(integer(), 3))
val.1 &lt;- list(runif(1), rbind(1:10, 1:10, 1:10))
val.2 &lt;- list(runif(1), cbind(1:10, 1:10, 1:10))
fun3 &lt;- function(x, y) {
  vetr(x=tpl, y=tpl &amp;&amp; ncol(.[[2]]) == ncol(x[[2]]))
  TRUE   # do some work
}
fun3(val.1, val.1)
try(fun3(val.1, val.2))
val.1.a &lt;- val.1
val.1.a[[2]] &lt;- val.1.a[[2]][, 1:8]
try(fun3(val.1, val.1.a))
</code></pre>

<hr>
<h2 id='vetr_settings'>Generate Control Settings For vetr and alike</h2><span id='topic+vetr_settings'></span>

<h3>Description</h3>

<p>Utility function to generate setting values.  We strongly recommend
that you generate the settings outside of function calls so that setting
generation does not become part of the <code>vet/vetr/alike</code> evaluation as
that could add noticeable overhead to the function evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vetr_settings(
  type.mode = 0L,
  attr.mode = 0L,
  lang.mode = 0L,
  fun.mode = 0L,
  rec.mode = 0L,
  suppress.warnings = FALSE,
  fuzzy.int.max.len = 100L,
  width = -1L,
  env.depth.max = 65535L,
  symb.sub.depth.max = 65535L,
  symb.size.max = 15000L,
  nchar.max = 65535L,
  track.hash.content.size = 63L,
  env = NULL,
  result.list.size.init = 64L,
  result.list.size.max = 1024L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vetr_settings_+3A_type.mode">type.mode</code></td>
<td>
<p>integer(1L) in 0:2, defaults to 0, determines how object
types (as in <code>typeof</code>) are compared: </p>

<ul>
<li><p> 0: integer like numerics (e.g. <code>1.0</code>) can match against
integer templates, and integers always match real templates; all
function types are considered of the same type
</p>
</li>
<li><p> 1: integers always match against numeric templates, but not vice
versa, and integer-like numerics are treated only as numerics;
functions only match same function type (i.e. closures only match
closures, builtins builtins, and specials specials)
</p>
</li>
<li><p> 2: types must be equal for all objects types (for functions, this
is unchanged from 1)
</p>
</li></ul>
</td></tr>
<tr><td><code id="vetr_settings_+3A_attr.mode">attr.mode</code></td>
<td>
<p>integer(1L) in 0:2, defaults to 0,  determines strictness of
attribute comparison: </p>

<ul>
<li> <p><code>0</code> only checks attributes that are present in target, and
uses special comparisons for the special attributes (<code>class</code>,
<code>dim</code>, <code>dimnames</code>, <code>names</code>, <code>row.names</code>,
<code>levels</code>, <code>srcref</code>, and <code>tsp</code>) while requiring other
attributes to be <code>alike</code>
</p>
</li>
<li> <p><code>1</code> is like <code>0</code>, except all atributes must be
<code>alike</code>
</p>
</li>
<li> <p><code>2</code> requires all attributes to be present in <code>target</code> and
<code>current</code> and to be alike
</p>
</li></ul>
</td></tr>
<tr><td><code id="vetr_settings_+3A_lang.mode">lang.mode</code></td>
<td>
<p>integer(1L) in 0:1, defaults to 0, controls language
matching, set to <code>1</code> to turn off use of <code><a href="base.html#topic+match.call">match.call()</a></code></p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_fun.mode">fun.mode</code></td>
<td>
<p>NOT IMPLEMENTED, controls how functions are compared</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_rec.mode">rec.mode</code></td>
<td>
<p>integer(1L) <code>0</code> currently unused, intended to control how
recursive structures (other than language objects) are compared</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_suppress.warnings">suppress.warnings</code></td>
<td>
<p>logical(1L) suppress warnings if TRUE</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_fuzzy.int.max.len">fuzzy.int.max.len</code></td>
<td>
<p>max length of numeric vectors to consider for
integer likeness (e.g. <code>c(1, 2)</code> can be considered &quot;integer&quot;, even
though it is numeric); currently we limit this check to vectors
shorter than 100 to avoid a potentially expensive computation on large
vectors, set to -1 to apply to all vectors irrespective of length</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_width">width</code></td>
<td>
<p>to use when deparsing expressions; default <code>-1</code>
equivalent to <code>getOption("width")</code></p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_env.depth.max">env.depth.max</code></td>
<td>
<p>integer(1L) maximum number of nested environments to
recurse through, defaults to 65535L; these are tracked to make sure we do
not get into an infinite recursion loop, but because they are tracked we
keep a limit on how many we will go through, set to -1 to allow unlimited
recursion depth.  You should not need to change this unless you are running
into the recursion limit.</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_symb.sub.depth.max">symb.sub.depth.max</code></td>
<td>
<p>integer(1L) maximum recursion depth when
recursively substituting symbols in vetting expression, defaults to 65535L</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_symb.size.max">symb.size.max</code></td>
<td>
<p>integer(1L) maximum number of characters that a symbol
is allowed to have in vetting expressions, defaults to 15000L.</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_nchar.max">nchar.max</code></td>
<td>
<p>integer(1L) defaults to 65535L, threshold after which
strings encountered in C code are truncated.  This is the read limit.  In
theory <code>vetr</code> can produce strings longer than that by combining multiple
shorter pieces.</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_track.hash.content.size">track.hash.content.size</code></td>
<td>
<p>integer(1L) (advanced) used to set the initial
size of the symbol tracking vector used with the hash table that detects
recursive symbol substitution.  If the tracking vector fills up it will be
grown by 2x.  This parameter is exposed mostly for developer use.</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_env">env</code></td>
<td>
<p>what environment to use to match calls and evaluate vetting
expressions, although typically you would specify this with the <code>env</code>
argument to <code>vet</code>; if NULL will use the calling frame to
<code>vet/vetr/alike</code>.</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_result.list.size.init">result.list.size.init</code></td>
<td>
<p>initial value for token tracking.   This will be
grown by a factor of two each time it fills up until we reach
<code>result.list.size.max</code>.</p>
</td></tr>
<tr><td><code id="vetr_settings_+3A_result.list.size.max">result.list.size.max</code></td>
<td>
<p>maximum number of tokens we keep track of,
intended mostly as a safeguard in case a logic error causes us to keep
allocating memory.  Set to 1024 as a default value since it should be
exceedingly rare to have vetting expressions with such a large number of
tokens, enough so that if we reach that number it is more likely something
went wrong.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Settings after <code>fuzzy.int.max.len</code> are fairly low level and exposed mostly
for testing purposes.  You should generally not need to use them.
</p>
<p>Note that a successful evaluation of this function does not guarantee a
correct settings list.  Those checks are carried out internally by
<code>vet/vetr/alike</code>.
</p>


<h3>Value</h3>

<p>list with all the setting values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+type_alike">type_alike</a></code>, <code><a href="#topic+alike">alike</a></code>, <code><a href="#topic+vetr">vetr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>type_alike(1L, 1.0, settings=vetr_settings(type.mode=2))
## better if you are going to re-use settings to reduce overhead
set &lt;- vetr_settings(type.mode=2)
type_alike(1L, 1.0, settings=set)
</code></pre>

<hr>
<h2 id='vetr-interal'>Test Objects</h2><span id='topic+vetr-interal'></span><span id='topic+vetr_bar-class'></span><span id='topic+vetr_baz-class'></span>

<h3>Description</h3>

<p>Objects used for testing purposes only.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
