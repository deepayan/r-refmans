<!DOCTYPE html><html><head><title>Help for package scoringTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scoringTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#augmentation'><p>Augmentation</p></a></li>
<li><a href='#chi2_iter'><p>Wrapper function for the chi2 function from the discretization package.</p></a></li>
<li><a href='#chiM_iter'><p>Wrapper function for the chiMerge function from the discretization package.</p></a></li>
<li><a href='#cut_dataset'><p>Randoming and sampling a dataset by its row numbers</p></a></li>
<li><a href='#discretization'><p>Class discretization</p></a></li>
<li><a href='#discretize'><p>Generic method &quot;discretize&quot; for discretization objects.</p></a></li>
<li><a href='#discretize_cutp'><p>Discretization of a test dataset when provided with an already discretized training set.</p></a></li>
<li><a href='#echi2_iter'><p>Wrapper function for the extended Chi2 function from the discretization package.</p></a></li>
<li><a href='#fuzzy_augmentation'><p>Fuzzy Augmentation</p></a></li>
<li><a href='#generate_data'><p>Generate data following different missingness mechanisms</p></a></li>
<li><a href='#get_cutp'><p>Getting cut-points of a discretization algorithm given the continuous and the discretized sets.</p></a></li>
<li><a href='#lendingClub'><p>Lending Club mortgages.</p></a></li>
<li><a href='#mdlp_iter'><p>Wrapper function for the mdlp function from the discretization package.</p></a></li>
<li><a href='#modChi2_iter'><p>Wrapper function for the modified Chi2 function from the discretization package.</p></a></li>
<li><a href='#normalizedGini'><p>Calculating the normalized Gini index</p></a></li>
<li><a href='#parcelling'><p>Parcelling</p></a></li>
<li><a href='#plot'><p>Different kinds of plots using either plotly (if available) or the standard plot (graphics package).</p></a></li>
<li><a href='#predict'><p>Prediction on a raw test set of the best logistic regression model on discretized data.</p></a></li>
<li><a href='#print.discretization'><p>Print for the discretization class.</p></a></li>
<li><a href='#reclassification'><p>Reclassification</p></a></li>
<li><a href='#reject_infered-class'><p>Class reject_infered</p></a></li>
<li><a href='#runDemo'><p>Launch the Shiny demo app.</p></a></li>
<li><a href='#scoringTools-package'><p>Credit Scoring Tools.</p></a></li>
<li><a href='#summary'><p>Summary</p></a></li>
<li><a href='#topdown_iter'><p>Wrapper function for the 3 topdown functions from the discretization package.</p></a></li>
<li><a href='#twins'><p>Twins</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Credit Scoring Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrien Ehrhardt &lt;adrien.ehrhardt@centraliens-lille.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Grouping essential tools for credit scoring. These statistical tools may be useful for other use-cases as well but were primarily designed for it. First, there are Reject Inference methods (Ehrhardt et al. (2017) &lt;<a href="https://arxiv.org/abs/1903.10855">arXiv:1903.10855</a>&gt;). Second, we build upon the already CRAN-available package 'discretization' to automate discretization of continuous features.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>discretization, sqldf, magrittr, dplyr, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, rpart, Rmixmod, mvtnorm, ggplot2, speedglm, knitr,
rmarkdown, plotly, pROC, shiny, DT, testthat, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://adimajo.github.io/scoringTools/">https://adimajo.github.io/scoringTools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adimajo/scoringTools/issues">https://github.com/adimajo/scoringTools/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'allClasses.R' 'allMethods.R' 'augmentation.R'
'check_consistency.R' 'chi2.R' 'chiM.R' 'cut.dataset.R'
'data.R' 'discretize.cutp.R' 'echi2.R' 'fuzzyAugmentation.R'
'generate_data.R' 'get_cutp.R' 'mdlp.R' 'methodsDisc.R'
'modChi2.R' 'model_f.R' 'normalizedGini.R' 'parcelling.R'
'reclassification.R' 'runDemo.R' 'scoringTools.R' 'topdown.R'
'twins.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 13:50:40 UTC; adrien</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrien Ehrhardt [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='augmentation'>Augmentation</h2><span id='topic+augmentation'></span>

<h3>Description</h3>

<p>This function performs Reject Inference using the Augmentation technique. Note that this technique is theoretically better than using the financed clients scorecard in the MAR and misspecified model case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augmentation(xf, xnf, yf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augmentation_+3A_xf">xf</code></td>
<td>
<p>The matrix of financed clients' characteristics to be used in the scorecard.</p>
</td></tr>
<tr><td><code id="augmentation_+3A_xnf">xnf</code></td>
<td>
<p>The matrix of not financed clients' characteristics to be used in the scorecard (must be the same features in the same order as xf!).</p>
</td></tr>
<tr><td><code id="augmentation_+3A_yf">yf</code></td>
<td>
<p>The matrix of financed clients' labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the Augmentation method on the data. When provided with labeled observations <code class="reqn">(x^\ell,y)</code>, it first fits the logistic regression model <code class="reqn">p_\theta</code> of
<code class="reqn">x^\ell</code> on <code class="reqn">y</code>, then reweighs labeled observations according to their probability of being sampled, i.e. calculates the predicted probabilities of <code class="reqn">p_\theta</code> on all observations, defines score-bands and calculates, in each of these score-bands, the probability of having been accepted as the proportion of labeled samples in that score-band.
It then refits a logistic regression model <code class="reqn">p_\eta</code> on the labeled samples.
</p>


<h3>Value</h3>

<p>List containing the model using financed clients only and the model produced using the Augmentation method.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
Ehrhardt, A., Biernacki, C., Vandewalle, V., Heinrich, P. and Beben, S. (2018), Reject Inference Methods in Credit Scoring: a rational review,
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate data from financed clients
df &lt;- generate_data(n = 100, d = 2)
xf &lt;- df[, -ncol(df)]
yf &lt;- df$y
# We simulate data from not financed clients (MCAR mechanism)
xnf &lt;- generate_data(n = 100, d = 2)[, -ncol(df)]
augmentation(xf, xnf, yf)
</code></pre>

<hr>
<h2 id='chi2_iter'>Wrapper function for the chi2 function from the discretization package.</h2><span id='topic+chi2_iter'></span>

<h3>Description</h3>

<p>This function discretizes a training set using the chi2 method and the user-provided parameters and chooses the best discretization scheme among them based on a user-provided criterion and eventually a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2_iter(
  predictors,
  labels,
  test = FALSE,
  validation = FALSE,
  proportions = c(0.3, 0.3),
  criterion = "gini",
  param = list(list(alp = 0.001, del = 0.5))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2_iter_+3A_predictors">predictors</code></td>
<td>
<p>The matrix array containing the numeric attributes to discretize.</p>
</td></tr>
<tr><td><code id="chi2_iter_+3A_labels">labels</code></td>
<td>
<p>The actual labels of the provided predictors (0/1).</p>
</td></tr>
<tr><td><code id="chi2_iter_+3A_test">test</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a test set on which to search for the best discretization scheme using the provided criterion (default: TRUE).</p>
</td></tr>
<tr><td><code id="chi2_iter_+3A_validation">validation</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a validation set on which to calculate the provided criterion using the best discretization scheme (chosen thanks to the provided criterion on either the test set (if true) or the training set (otherwise)) (default: TRUE).</p>
</td></tr>
<tr><td><code id="chi2_iter_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="chi2_iter_+3A_criterion">criterion</code></td>
<td>
<p>The criterion ('gini','aic','bic') to use to choose the best discretization scheme among the generated ones (default: 'gini'). Nota Bene: it is best to use 'gini' only when test is set to TRUE and 'aic' or 'bic' when it is not. When using 'aic' or 'bic' with a test set, the likelihood is returned as there is no need to penalize for generalization purposes.</p>
</td></tr>
<tr><td><code id="chi2_iter_+3A_param">param</code></td>
<td>
<p>List providing the parameters to test (see ?discretization::chi2, default=list(list(alp=0.001, del=0.5))).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
</p>
<p>HyunJi Kim (2012). discretization: Data preprocessing, discretization for classification. R package version 1.0-1. <a href="https://CRAN.R-project.org/package=discretization">https://CRAN.R-project.org/package=discretization</a>
</p>
<p>Liu, H. and Setiono, R. (1995). Chi2: Feature selection and discretization of numeric attributes, <em>Tools with Artificial Intelligence</em>, 388–391.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a discretized logit model
x &lt;- matrix(runif(300), nrow = 100, ncol = 3)
cuts &lt;- seq(0, 1, length.out = 4)
xd &lt;- apply(x, 2, function(col) as.numeric(cut(col, cuts)))
theta &lt;- t(matrix(c(0, 0, 0, 2, 2, 2, -2, -2, -2), ncol = 3, nrow = 3))
log_odd &lt;- rowSums(t(sapply(seq_along(xd[, 1]), function(row_id) {
  sapply(
    seq_along(xd[row_id, ]),
    function(element) theta[xd[row_id, element], element]
  )
})))
y &lt;- stats::rbinom(100, 1, 1 / (1 + exp(-log_odd)))

chi2_iter(x, y)
</code></pre>

<hr>
<h2 id='chiM_iter'>Wrapper function for the chiMerge function from the discretization package.</h2><span id='topic+chiM_iter'></span>

<h3>Description</h3>

<p>This function discretizes a training set using the chiMerge method and the user-provided parameters and chooses the best discretization scheme among them based on a user-provided criterion and eventually a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiM_iter(
  predictors,
  labels,
  test = FALSE,
  validation = FALSE,
  proportions = c(0.3, 0.3),
  criterion = "gini",
  param = list(alpha = 0.05)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chiM_iter_+3A_predictors">predictors</code></td>
<td>
<p>The matrix array containing the numeric attributes to discretize.</p>
</td></tr>
<tr><td><code id="chiM_iter_+3A_labels">labels</code></td>
<td>
<p>The actual labels of the provided predictors (0/1).</p>
</td></tr>
<tr><td><code id="chiM_iter_+3A_test">test</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a test set on which to search for the best discretization scheme using the provided criterion (default: TRUE).</p>
</td></tr>
<tr><td><code id="chiM_iter_+3A_validation">validation</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a validation set on which to calculate the provided criterion using the best discretization scheme (chosen thanks to the provided criterion on either the test set (if true) or the training set (otherwise)) (default: TRUE).</p>
</td></tr>
<tr><td><code id="chiM_iter_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="chiM_iter_+3A_criterion">criterion</code></td>
<td>
<p>The criterion ('gini','aic','bic') to use to choose the best discretization scheme among the generated ones (default: 'gini'). Nota Bene: it is best to use 'gini' only when test is set to TRUE and 'aic' or 'bic' when it is not. When using 'aic' or 'bic' with a test set, the likelihood is returned as there is no need to penalize for generalization purposes.</p>
</td></tr>
<tr><td><code id="chiM_iter_+3A_param">param</code></td>
<td>
<p>List providing the parameters to test (see ?discretization::chiM, default=list(alpha = 0.05)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes a dataset containing continuous features <code class="reqn">X</code> in a supervised way, i.e. knowing observations of a binomial random variable <code class="reqn">Y</code> which we would like to predict based on the discretization of <code class="reqn">X</code>.
To do so, the <code>ChiMerge</code> alorithm starts by putting each unique values of <code class="reqn">X</code> in a separate value of the ‘‘discretized&rdquo; categorical feature <code class="reqn">E</code>. It then tests if two adjacent values of <code class="reqn">E</code> are significantly different using the <code class="reqn">\chi^2</code>-test.
In the context of Credit Scoring, a logistic regression is fitted between the ‘‘discretized&rdquo; features <code class="reqn">E</code> and the response feature <code class="reqn">Y</code>. As a consequence, the output of this function is the discretized features <code class="reqn">E</code>, the logistic regression model of <code class="reqn">E</code> on <code class="reqn">Y</code> and the parameters used to get this fit.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
</p>
<p>HyunJi Kim (2012). discretization: Data preprocessing, discretization for classification. R package version 1.0-1. <a href="https://CRAN.R-project.org/package=discretization">https://CRAN.R-project.org/package=discretization</a>
</p>
<p>Kerber, R. (1992). ChiMerge : Discretization of numeric attributes, <em>In Proceedings of the Tenth National Conference on Artificial Intelligence</em>, 123–128.
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>, <code>discretization</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a discretized logit model
x &lt;- matrix(runif(300), nrow = 100, ncol = 3)
cuts &lt;- seq(0, 1, length.out = 4)
xd &lt;- apply(x, 2, function(col) as.numeric(cut(col, cuts)))
theta &lt;- t(matrix(c(0, 0, 0, 2, 2, 2, -2, -2, -2), ncol = 3, nrow = 3))
log_odd &lt;- rowSums(t(sapply(seq_along(xd[, 1]), function(row_id) {
  sapply(
    seq_along(xd[row_id, ]),
    function(element) theta[xd[row_id, element], element]
  )
})))
y &lt;- stats::rbinom(100, 1, 1 / (1 + exp(-log_odd)))

chiM_iter(x, y)
</code></pre>

<hr>
<h2 id='cut_dataset'>Randoming and sampling a dataset by its row numbers</h2><span id='topic+cut_dataset'></span>

<h3>Description</h3>

<p>This function chooses the rows of a dataset to be included in the train, test (optional) and validation (optional) datasets according to proportions specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_dataset(n, proportions, test = TRUE, validation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_dataset_+3A_n">n</code></td>
<td>
<p>The total number of rows to sample from.</p>
</td></tr>
<tr><td><code id="cut_dataset_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="cut_dataset_+3A_test">test</code></td>
<td>
<p>TRUE if a test dataset is wanted, FALSE otherwise (default=TRUE).</p>
</td></tr>
<tr><td><code id="cut_dataset_+3A_validation">validation</code></td>
<td>
<p>TRUE if a test dataset is wanted, FALSE otherwise (default=TRUE).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>

<hr>
<h2 id='discretization'>Class discretization</h2><span id='topic+discretization'></span>

<h3>Description</h3>

<p>An S4 class to represent a discretization scheme.
</p>


<h3>Slots</h3>


<dl>
<dt><code>method.name</code></dt><dd><p>The name of the used discretization method.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>The parameters associated with the used method.</p>
</dd>
<dt><code>best.disc</code></dt><dd><p>The best discretization scheme found by the method given its parameters.</p>
</dd>
<dt><code>performance</code></dt><dd><p>The performance obtained with the method given its parameters.</p>
</dd>
<dt><code>disc.data</code></dt><dd><p>The discretized data: test set if test is TRUE; if test is FALSE and validation is TRUE, then it provides the discretized validation set. Otherwise, it provides the discretized training set.</p>
</dd>
<dt><code>disc.data</code></dt><dd><p>The continuous data: test set if test is TRUE; if test is FALSE and validation is TRUE, then it provides the discretized validation set. Otherwise, it provides the discretized training set.</p>
</dd>
</dl>

<hr>
<h2 id='discretize'>Generic method &quot;discretize&quot; for discretization objects.</h2><span id='topic+discretize'></span><span id='topic+discretize+2Cdiscretization-method'></span>

<h3>Description</h3>

<p>This defines the generic method &quot;discretize&quot; which will discretize a new input dataset given a discretization scheme of S4 class discretization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(object, data)

## S4 method for signature 'discretization'
discretize(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_object">object</code></td>
<td>
<p>the S4 discretization object</p>
</td></tr>
<tr><td><code id="discretize_+3A_data">data</code></td>
<td>
<p>new data to discretize</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes a new data set using a previously learnt discretization scheme.
</p>

<hr>
<h2 id='discretize_cutp'>Discretization of a test dataset when provided with an already discretized training set.</h2><span id='topic+discretize_cutp'></span>

<h3>Description</h3>

<p>This function discretizes a dataset when provided with both continuous and discretized versions of a training dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize_cutp(cont_test_set, disc_train_set, cont_train_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_cutp_+3A_cont_test_set">cont_test_set</code></td>
<td>
<p>The matrix or dataframe of the dataset to discretize.</p>
</td></tr>
<tr><td><code id="discretize_cutp_+3A_disc_train_set">disc_train_set</code></td>
<td>
<p>The matrix or dataframe of the discretized training dataset.</p>
</td></tr>
<tr><td><code id="discretize_cutp_+3A_cont_train_set">cont_train_set</code></td>
<td>
<p>The matrix or dataframe of the continuous training dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>

<hr>
<h2 id='echi2_iter'>Wrapper function for the extended Chi2 function from the discretization package.</h2><span id='topic+echi2_iter'></span>

<h3>Description</h3>

<p>This function discretizes a training set using the extended Chi2 method and the user-provided parameters and chooses the best discretization scheme among them based on a user-provided criterion and eventually a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>echi2_iter(
  predictors,
  labels,
  test = FALSE,
  validation = FALSE,
  proportions = c(0.3, 0.3),
  criterion = "gini",
  param = list(alp = 0.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="echi2_iter_+3A_predictors">predictors</code></td>
<td>
<p>The matrix array containing the numeric attributes to discretize.</p>
</td></tr>
<tr><td><code id="echi2_iter_+3A_labels">labels</code></td>
<td>
<p>The actual labels of the provided predictors (0/1).</p>
</td></tr>
<tr><td><code id="echi2_iter_+3A_test">test</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a test set on which to search for the best discretization scheme using the provided criterion (default: TRUE).</p>
</td></tr>
<tr><td><code id="echi2_iter_+3A_validation">validation</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a validation set on which to calculate the provided criterion using the best discretization scheme (chosen thanks to the provided criterion on either the test set (if true) or the training set (otherwise)) (default: TRUE).</p>
</td></tr>
<tr><td><code id="echi2_iter_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="echi2_iter_+3A_criterion">criterion</code></td>
<td>
<p>The criterion ('gini','aic','bic') to use to choose the best discretization scheme among the generated ones (default: 'gini'). Nota Bene: it is best to use 'gini' only when test is set to TRUE and 'aic' or 'bic' when it is not. When using 'aic' or 'bic' with a test set, the likelihood is returned as there is no need to penalize for generalization purposes.</p>
</td></tr>
<tr><td><code id="echi2_iter_+3A_param">param</code></td>
<td>
<p>List providing the parameters to test (see ?discretization::extendChi2, default=list(alp = 0.5)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes a dataset containing continuous features <code class="reqn">X</code> in a supervised way, i.e. knowing observations of a binomial random variable <code class="reqn">Y</code> which we would like to predict based on the discretization of <code class="reqn">X</code>.
To do so, the <code>ExtendedChi2</code> alorithm starts by putting each unique values of <code class="reqn">X</code> in a separate value of the ‘‘discretized&rdquo; categorical feature <code class="reqn">E</code>. It then tests if two adjacent values of <code class="reqn">E</code> are significantly different using the <code class="reqn">\chi^2</code>-test.
In the context of Credit Scoring, a logistic regression is fitted between the ‘‘discretized&rdquo; features <code class="reqn">E</code> and the response feature <code class="reqn">Y</code>. As a consequence, the output of this function is the discretized features <code class="reqn">E</code>, the logistic regression model of <code class="reqn">E</code> on <code class="reqn">Y</code> and the parameters used to get this fit.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
</p>
<p>HyunJi Kim (2012). discretization: Data preprocessing, discretization for classification. R package version 1.0-1. <a href="https://CRAN.R-project.org/package=discretization">https://CRAN.R-project.org/package=discretization</a>
</p>
<p>Liu, H. and Setiono, R. (1995). Chi2: Feature selection and discretization of numeric attributes, <em>Tools with Artificial Intelligence</em>, 388–391.
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>, <code>discretization</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a discretized logit model
x &lt;- matrix(runif(300), nrow = 100, ncol = 3)
cuts &lt;- seq(0, 1, length.out = 4)
xd &lt;- apply(x, 2, function(col) as.numeric(cut(col, cuts)))
theta &lt;- t(matrix(c(0, 0, 0, 2, 2, 2, -2, -2, -2), ncol = 3, nrow = 3))
log_odd &lt;- rowSums(t(sapply(seq_along(xd[, 1]), function(row_id) {
  sapply(
    seq_along(xd[row_id, ]),
    function(element) theta[xd[row_id, element], element]
  )
})))
y &lt;- stats::rbinom(100, 1, 1 / (1 + exp(-log_odd)))

echi2_iter(x, y)
</code></pre>

<hr>
<h2 id='fuzzy_augmentation'>Fuzzy Augmentation</h2><span id='topic+fuzzy_augmentation'></span>

<h3>Description</h3>

<p>This function performs Reject Inference using the Fuzzy Augmentation technique. Note that this technique has no theoretical foundation and should produce (under the identifiability assumption) the same parameters' estimates than the financed clients scorecard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_augmentation(xf, xnf, yf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzy_augmentation_+3A_xf">xf</code></td>
<td>
<p>The matrix of financed clients' characteristics to be used in the scorecard.</p>
</td></tr>
<tr><td><code id="fuzzy_augmentation_+3A_xnf">xnf</code></td>
<td>
<p>The matrix of not financed clients' characteristics to be used in the scorecard (must be the same in the same order as xf!).</p>
</td></tr>
<tr><td><code id="fuzzy_augmentation_+3A_yf">yf</code></td>
<td>
<p>The matrix of financed clients' labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the Fuzzy Augmentation method on the data. When provided with labeled observations <code class="reqn">(x^\ell,y)</code>, it first fits the logistic regression model <code class="reqn">p_\theta</code> of
<code class="reqn">x^\ell</code> on <code class="reqn">y</code>, then labels the unlabelled samples <code class="reqn">x^{u}</code> with the predicted probabilities of <code class="reqn">p_\theta</code>, i.e. <code class="reqn">\hat{y}^{u} = p_\theta(y|x^{u})</code>
then refits a logistic regression model <code class="reqn">p_\eta</code> on the whole sample.
</p>


<h3>Value</h3>

<p>List containing the model using financed clients only and the model produced using the Fuzzy Augmentation method.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
Ehrhardt, A., Biernacki, C., Vandewalle, V., Heinrich, P. and Beben, S. (2018), Reject Inference Methods in Credit Scoring: a rational review,
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate data from financed clients
df &lt;- generate_data(n = 100, d = 2)
xf &lt;- df[, -ncol(df)]
yf &lt;- df$y
# We simulate data from not financed clients (MCAR mechanism)
xnf &lt;- generate_data(n = 100, d = 2)[, -ncol(df)]
fuzzy_augmentation(xf, xnf, yf)
</code></pre>

<hr>
<h2 id='generate_data'>Generate data following different missingness mechanisms</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p>This function performs generates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(n = 100, d = 3, type = "MAR well specified")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_data_+3A_n">n</code></td>
<td>
<p>The number of samples to return.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_d">d</code></td>
<td>
<p>The dimension of samples to return.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_type">type</code></td>
<td>
<p>The matrix of financed clients' labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates data from a uniform(0,1) distribution, and generates
labels y according to a logistic regression on this data with random -1/1
parameter for each coordinate (MAR well-specified), the square of this data
(MAR misspecified), or this data and some additional feature (from U(0,1) as
well - MNAR).
</p>


<h3>Value</h3>

<p>Dataframe containing features as x.1..d, labels as y.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Ehrhardt, A., Biernacki, C., Vandewalle, V., Heinrich, P. and Beben, S. (2018), Reject Inference Methods in Credit Scoring: a rational review,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate data from financed clients
generate_data(n = 100, d = 3, type = "MAR well specified")
</code></pre>

<hr>
<h2 id='get_cutp'>Getting cut-points of a discretization algorithm given the continuous and the discretized sets.</h2><span id='topic+get_cutp'></span>

<h3>Description</h3>

<p>This function returns the cut-points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cutp(disc_train_set, cont_train_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cutp_+3A_disc_train_set">disc_train_set</code></td>
<td>
<p>The matrix or dataframe of the discretized training dataset.</p>
</td></tr>
<tr><td><code id="get_cutp_+3A_cont_train_set">cont_train_set</code></td>
<td>
<p>The matrix or dataframe of the continuous training dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>

<hr>
<h2 id='lendingClub'>Lending Club mortgages.</h2><span id='topic+lendingClub'></span>

<h3>Description</h3>

<p>A dataset containing the information about Lending Club loans available online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lendingClub
</code></pre>


<h3>Format</h3>

<p>A data frame with 2167 rows and 16 variables.
</p>


<h3>Source</h3>

<p><a href="https://www.lendingclub.com/">https://www.lendingclub.com/</a>
</p>

<hr>
<h2 id='mdlp_iter'>Wrapper function for the mdlp function from the discretization package.</h2><span id='topic+mdlp_iter'></span>

<h3>Description</h3>

<p>This function discretizes a training set using the Minimum Description Length Principle method and the user-provided parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdlp_iter(
  predictors,
  labels,
  test = FALSE,
  validation = FALSE,
  proportions = c(0.3, 0.3),
  criterion = "gini"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdlp_iter_+3A_predictors">predictors</code></td>
<td>
<p>The matrix array containing the numeric attributes to discretize.</p>
</td></tr>
<tr><td><code id="mdlp_iter_+3A_labels">labels</code></td>
<td>
<p>The actual labels of the provided predictors (0/1).</p>
</td></tr>
<tr><td><code id="mdlp_iter_+3A_test">test</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a test set on which to search for the best discretization scheme using the provided criterion (default: TRUE).</p>
</td></tr>
<tr><td><code id="mdlp_iter_+3A_validation">validation</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a validation set on which to calculate the provided criterion using the best discretization scheme (chosen thanks to the provided criterion on either the test set (if true) or the training set (otherwise)) (default: TRUE).</p>
</td></tr>
<tr><td><code id="mdlp_iter_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="mdlp_iter_+3A_criterion">criterion</code></td>
<td>
<p>The criterion ('gini','aic','bic') to use to choose the best discretization scheme among the generated ones (default: 'gini'). Nota Bene: it is best to use 'gini' only when test is set to TRUE and 'aic' or 'bic' when it is not. When using 'aic' or 'bic' with a test set, the likelihood is returned as there is no need to penalize for generalization purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes a dataset containing continuous features <code class="reqn">X</code> in a supervised way, i.e. knowing observations of a binomial random variable <code class="reqn">Y</code> which we would like to predict based on the discretization of <code class="reqn">X</code>.
To do so, the <code>MDLP</code> alorithm dichotomizes <code class="reqn">X</code> and puts the subsequent two values in the ‘‘discretized&rdquo; categorical feature <code class="reqn">E</code>. It chooses the cut-off point so as to minimize the resulting entropy and goes on in the subsequent two sub-spaces it just created.
In the context of Credit Scoring, a logistic regression is fitted between the ‘‘discretized&rdquo; features <code class="reqn">E</code> and the response feature <code class="reqn">Y</code>. As a consequence, the output of this function is the discretized features <code class="reqn">E</code>, the logistic regression model of <code class="reqn">E</code> on <code class="reqn">Y</code> and the parameters used to get this fit.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
</p>
<p>HyunJi Kim (2012). discretization: Data preprocessing, discretization for classification. R package version 1.0-1. <a href="https://CRAN.R-project.org/package=discretization">https://CRAN.R-project.org/package=discretization</a>
</p>
<p>Fayyad, U. M. and Irani, K. B.(1993). Multi-interval discretization of continuous-valued attributes for classification learning, <em>Artificial intelligence</em>, <strong>13</strong>, 1022–1027.
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>, <code>discretization</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a discretized logit model
x &lt;- matrix(runif(300), nrow = 100, ncol = 3)
cuts &lt;- seq(0, 1, length.out = 4)
xd &lt;- apply(x, 2, function(col) as.numeric(cut(col, cuts)))
theta &lt;- t(matrix(c(0, 0, 0, 2, 2, 2, -2, -2, -2), ncol = 3, nrow = 3))
log_odd &lt;- rowSums(t(sapply(seq_along(xd[, 1]), function(row_id) {
  sapply(
    seq_along(xd[row_id, ]),
    function(element) theta[xd[row_id, element], element]
  )
})))
y &lt;- stats::rbinom(100, 1, 1 / (1 + exp(-log_odd)))

mdlp_iter(x, y)
</code></pre>

<hr>
<h2 id='modChi2_iter'>Wrapper function for the modified Chi2 function from the discretization package.</h2><span id='topic+modChi2_iter'></span>

<h3>Description</h3>

<p>This function discretizes a training set using the modified Chi2 method and the user-provided parameters and chooses the best discretization scheme among them based on a user-provided criterion and eventually a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modChi2_iter(
  predictors,
  labels,
  test = FALSE,
  validation = FALSE,
  proportions = c(0.3, 0.3),
  criterion = "gini",
  param = list(alp = 0.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modChi2_iter_+3A_predictors">predictors</code></td>
<td>
<p>The matrix array containing the numeric attributes to discretize.</p>
</td></tr>
<tr><td><code id="modChi2_iter_+3A_labels">labels</code></td>
<td>
<p>The actual labels of the provided predictors (0/1).</p>
</td></tr>
<tr><td><code id="modChi2_iter_+3A_test">test</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a test set on which to search for the best discretization scheme using the provided criterion (default: TRUE).</p>
</td></tr>
<tr><td><code id="modChi2_iter_+3A_validation">validation</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a validation set on which to calculate the provided criterion using the best discretization scheme (chosen thanks to the provided criterion on either the test set (if true) or the training set (otherwise)) (default: TRUE).</p>
</td></tr>
<tr><td><code id="modChi2_iter_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="modChi2_iter_+3A_criterion">criterion</code></td>
<td>
<p>The criterion ('gini','aic','bic') to use to choose the best discretization scheme among the generated ones (default: 'gini'). Nota Bene: it is best to use 'gini' only when test is set to TRUE and 'aic' or 'bic' when it is not. When using 'aic' or 'bic' with a test set, the likelihood is returned as there is no need to penalize for generalization purposes.</p>
</td></tr>
<tr><td><code id="modChi2_iter_+3A_param">param</code></td>
<td>
<p>List providing the parameters to test (see ?discretization::modChi2, default=list(alp = 0.5)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes a dataset containing continuous features <code class="reqn">X</code> in a supervised way, i.e. knowing observations of a binomial random variable <code class="reqn">Y</code> which we would like to predict based on the discretization of <code class="reqn">X</code>.
To do so, the <code>ModifiedChi2</code> alorithm starts by putting each unique values of <code class="reqn">X</code> in a separate value of the ‘‘discretized&rdquo; categorical feature <code class="reqn">E</code>. It then tests if two adjacent values of <code class="reqn">E</code> are significantly different using the <code class="reqn">\chi^2</code>-test.
In the context of Credit Scoring, a logistic regression is fitted between the ‘‘discretized&rdquo; features <code class="reqn">E</code> and the response feature <code class="reqn">Y</code>. As a consequence, the output of this function is the discretized features <code class="reqn">E</code>, the logistic regression model of <code class="reqn">E</code> on <code class="reqn">Y</code> and the parameters used to get this fit.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
</p>
<p>HyunJi Kim (2012). discretization: Data preprocessing, discretization for classification. R package version 1.0-1. <a href="https://CRAN.R-project.org/package=discretization">https://CRAN.R-project.org/package=discretization</a>
</p>
<p>Tay, F. E. H. and Shen, L. (2002). Modified Chi2 Algorithm for Discretization, <em>IEEE Transactions on knowledge and data engineering</em>, <strong>14</strong>, 666–670.
#' @examples
# Simulation of a discretized logit model
x = matrix(runif(300), nrow = 100, ncol = 3)
cuts = seq(0,1,length.out= 4)
xd = apply(x,2, function(col) as.numeric(cut(col,cuts)))
theta = t(matrix(c(0,0,0,2,2,2,-2,-2,-2),ncol=3,nrow=3))
log_odd = rowSums(t(sapply(seq_along(xd[,1]), function(row_id) sapply(seq_along(xd[row_id,]),
function(element) theta[xd[row_id,element],element]))))
y = stats::rbinom(100,1,1/(1+exp(-log_odd)))
</p>
<p>modchi2_iter(x,y)
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>, <code>discretization</code>
</p>

<hr>
<h2 id='normalizedGini'>Calculating the normalized Gini index</h2><span id='topic+normalizedGini'></span>

<h3>Description</h3>

<p>This function calculates the Gini index of a classification rule outputting probabilities. It is a classical metric in the context of Credit Scoring.
It is equal to 2 times the AUC (Area Under ROC Curve) minus 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizedGini(actual, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizedGini_+3A_actual">actual</code></td>
<td>
<p>The numeric binary vector of the actual labels observed.</p>
</td></tr>
<tr><td><code id="normalizedGini_+3A_predicted">predicted</code></td>
<td>
<p>The vector of the probabilities predicted by the classification rule.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>normalizedGini(c(1, 1, 1, 0, 0), c(0.7, 0.9, 0.5, 0.6, 0.3))
</code></pre>

<hr>
<h2 id='parcelling'>Parcelling</h2><span id='topic+parcelling'></span>

<h3>Description</h3>

<p>This function performs Reject Inference using the Parcelling technique. Note that this technique is theoretically good in the MNAR framework although coefficients must be chosen a priori.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parcelling(
  xf,
  xnf,
  yf,
  probs = seq(0, 1, 0.25),
  alpha = rep(1, length(probs) - 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parcelling_+3A_xf">xf</code></td>
<td>
<p>The matrix of financed clients' characteristics to be used in the scorecard.</p>
</td></tr>
<tr><td><code id="parcelling_+3A_xnf">xnf</code></td>
<td>
<p>The matrix of not financed clients' characteristics to be used in the scorecard (must be the same in the same order as xf!).</p>
</td></tr>
<tr><td><code id="parcelling_+3A_yf">yf</code></td>
<td>
<p>The matrix of financed clients' labels</p>
</td></tr>
<tr><td><code id="parcelling_+3A_probs">probs</code></td>
<td>
<p>The sequence of quantiles to use to make scorebands (see the vignette).</p>
</td></tr>
<tr><td><code id="parcelling_+3A_alpha">alpha</code></td>
<td>
<p>The user-defined coefficients to use with Parcelling (see the vignette).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the Parcelling method on the data. When provided with labeled observations <code class="reqn">(x^\ell,y)</code>, it first fits the logistic regression model <code class="reqn">p_\theta</code> of
<code class="reqn">x^\ell</code> on <code class="reqn">y</code>, then labels the unlabelled samples <code class="reqn">x^{u}</code> with the observed bad rate in user-defined classes of predicted probabilities of <code class="reqn">p_\theta</code> reweighted using user-supplied weights, i.e. <code class="reqn">\hat{y}^{u} = \alpha_k T(k)</code> where <code class="reqn">k</code> denotes the group (which depends on <code class="reqn">p_\theta</code>) and T(k) the observed bad rate of labeled observations in this group.
It then refits a logistic regression model <code class="reqn">p_\eta</code> on the whole sample.
</p>


<h3>Value</h3>

<p>List containing the model using financed clients only and the model produced using the Parcelling method.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
Ehrhardt, A., Biernacki, C., Vandewalle, V., Heinrich, P. and Beben, S. (2018), Reject Inference Methods in Credit Scoring: a rational review,
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate data from financed clients
df &lt;- generate_data(n = 100, d = 2)
xf &lt;- df[, -ncol(df)]
yf &lt;- df$y
# We simulate data from not financed clients (MCAR mechanism)
xnf &lt;- generate_data(n = 100, d = 2)[, -ncol(df)]
parcelling(xf, xnf, yf)
</code></pre>

<hr>
<h2 id='plot'>Different kinds of plots using either plotly (if available) or the standard plot (graphics package).</h2><span id='topic+plot'></span><span id='topic+plot.discretization'></span><span id='topic+plot+2Cdiscretization-method'></span>

<h3>Description</h3>

<p>This function aims at producing useful graphs in the context of credit scoring in order to simplify the validation process
of the produced credit score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)

## S3 method for class 'discretization'
plot(x, type)

## S4 method for signature 'discretization'
plot(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>S4 discretization object.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>(For standard plots only)</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>(For standard plots only)</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>Type of plot. For now only &quot;ROC&quot; is supported.</p>
</td></tr>
</table>

<hr>
<h2 id='predict'>Prediction on a raw test set of the best logistic regression model on discretized data.</h2><span id='topic+predict'></span><span id='topic+predict.discretization'></span><span id='topic+predict.reject_infered'></span><span id='topic+predict+2Cdiscretization-method'></span><span id='topic+predict+2Creject_infered-method'></span>

<h3>Description</h3>

<p>This function discretizes a user-provided test dataset given a discretization scheme provided by an S4 &quot;discretization&quot; object.
It then applies the learnt logistic regression model and outputs its prediction (see predict.glm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(object, ...)

## S3 method for class 'discretization'
predict(object, newdata)

## S3 method for class 'reject_infered'
predict(object, newdata, ...)

## S4 method for signature 'discretization'
predict(object, newdata)

## S4 method for signature 'reject_infered'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>The S4 reject_infered object.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass on to base predict.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>The test dataframe to discretize and for which we wish to have predictions.</p>
</td></tr>
</table>

<hr>
<h2 id='print.discretization'>Print for the discretization class.</h2><span id='topic+print.discretization'></span>

<h3>Description</h3>

<p>Print for the discretization class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'discretization'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.discretization_+3A_x">x</code></td>
<td>
<p>S4 discretization object.</p>
</td></tr>
<tr><td><code id="print.discretization_+3A_...">...</code></td>
<td>
<p>Other print options.</p>
</td></tr>
</table>

<hr>
<h2 id='reclassification'>Reclassification</h2><span id='topic+reclassification'></span>

<h3>Description</h3>

<p>This function performs Reject Inference using the Reclassification technique. Note that this technique has no theoretical foundation as it performs a one-step CEM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclassification(xf, xnf, yf, thresh = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclassification_+3A_xf">xf</code></td>
<td>
<p>The matrix of financed clients' characteristics to be used in the scorecard.</p>
</td></tr>
<tr><td><code id="reclassification_+3A_xnf">xnf</code></td>
<td>
<p>The matrix of not financed clients' characteristics to be used in the scorecard (must be the same in the same order as xf!).</p>
</td></tr>
<tr><td><code id="reclassification_+3A_yf">yf</code></td>
<td>
<p>The matrix of financed clients' labels</p>
</td></tr>
<tr><td><code id="reclassification_+3A_thresh">thresh</code></td>
<td>
<p>The threshold to use in the Classification step, i.e. the probability above which a not financed client is considered to have a label equal to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the Reclassification method on the data. When provided with labeled observations <code class="reqn">(x^\ell,y)</code>, it first fits the logistic regression model <code class="reqn">p_\theta</code> of
<code class="reqn">x^\ell</code> on <code class="reqn">y</code>, then considers that unlabeled observations are of the expected class given by the model <code class="reqn">p_\theta</code> (this is equivalent to a CEM algorithm).
It then refits a logistic regression model <code class="reqn">p_\eta</code> on the whole sample.
</p>


<h3>Value</h3>

<p>List containing the model using financed clients only and the model produced using the Reclassification method.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
Ehrhardt, A., Biernacki, C., Vandewalle, V., Heinrich, P. and Beben, S. (2018), Reject Inference Methods in Credit Scoring: a rational review,
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate data from financed clients
xf &lt;- matrix(runif(100 * 2), nrow = 100, ncol = 2)
theta &lt;- c(2, -2)
log_odd &lt;- apply(xf, 1, function(row) theta %*% row)
yf &lt;- rbinom(100, 1, 1 / (1 + exp(-log_odd)))
# We simulate data from not financed clients (MCAR mechanism)
xnf &lt;- matrix(runif(100 * 2), nrow = 100, ncol = 2)
reclassification(xf, xnf, yf)
</code></pre>

<hr>
<h2 id='reject_infered-class'>Class reject_infered</h2><span id='topic+reject_infered-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a reject inference technique.
</p>


<h3>Slots</h3>


<dl>
<dt><code>method_name</code></dt><dd><p>The name of the used reject inference method.</p>
</dd>
<dt><code>financed_model</code></dt><dd><p>The logistic regression model on financed clients.</p>
</dd>
<dt><code>acceptance_model</code></dt><dd><p>The acceptance model (if estimated by the given method).</p>
</dd>
<dt><code>infered_model</code></dt><dd><p>The logistic regression model resulting from the reject inference method.</p>
</dd>
</dl>

<hr>
<h2 id='runDemo'>Launch the Shiny demo app.</h2><span id='topic+runDemo'></span>

<h3>Description</h3>

<p>Launch the Shiny demo app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDemo()
</code></pre>

<hr>
<h2 id='scoringTools-package'>Credit Scoring Tools.</h2><span id='topic+scoringTools'></span><span id='topic+scoringTools-package'></span>

<h3>Description</h3>

<p>Refer to the package's vignette.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Adrien Ehrhardt <a href="mailto:adrien.ehrhardt@centraliens-lille.org">adrien.ehrhardt@centraliens-lille.org</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://adimajo.github.io/scoringTools/">https://adimajo.github.io/scoringTools/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/adimajo/scoringTools/issues">https://github.com/adimajo/scoringTools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='summary'>Summary</h2><span id='topic+summary'></span><span id='topic+summary.discretization'></span><span id='topic+summary+2Cdiscretization-method'></span>

<h3>Description</h3>

<p>Summary generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)

## S3 method for class 'discretization'
summary(object)

## S4 method for signature 'discretization'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>S4 discretization object.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Other parameters to <code>summary</code></p>
</td></tr>
</table>

<hr>
<h2 id='topdown_iter'>Wrapper function for the 3 topdown functions from the discretization package.</h2><span id='topic+topdown_iter'></span>

<h3>Description</h3>

<p>This function discretizes a training set using the user provided method(s) among the three topdown methods from the discretization package. Depending on the user providing a test and/or a validation set, the function returns the best discretization for logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topdown_iter(
  predictors,
  labels,
  test = F,
  validation = F,
  proportions = c(0.3, 0.3),
  criterion = "gini",
  param = list(1, 2, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topdown_iter_+3A_predictors">predictors</code></td>
<td>
<p>The matrix array containing the numeric attributes to discretize.</p>
</td></tr>
<tr><td><code id="topdown_iter_+3A_labels">labels</code></td>
<td>
<p>The actual labels of the provided predictors (0/1).</p>
</td></tr>
<tr><td><code id="topdown_iter_+3A_test">test</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a test set on which to search for the best discretization scheme using the provided criterion (default: TRUE).</p>
</td></tr>
<tr><td><code id="topdown_iter_+3A_validation">validation</code></td>
<td>
<p>Boolean : True if the algorithm should use predictors to construct a validation set on which to calculate the provided criterion using the best discretization scheme (chosen thanks to the provided criterion on either the test set (if true) or the training set (otherwise)) (default: TRUE).</p>
</td></tr>
<tr><td><code id="topdown_iter_+3A_proportions">proportions</code></td>
<td>
<p>The list of the (2) proportions wanted for test and validation set. Only the first is used when there is only one of either test or validation that is set to TRUE. Produces an error when the sum is greater to one. Useless if both test and validation are set to FALSE. Default: list(0.2,0.2).</p>
</td></tr>
<tr><td><code id="topdown_iter_+3A_criterion">criterion</code></td>
<td>
<p>The criterion ('gini','aic','bic') to use to choose the best discretization scheme among the generated ones (default: 'gini'). Nota Bene: it is best to use 'gini' only when test is set to TRUE and 'aic' or 'bic' when it is not. When using 'aic' or 'bic' with a test set, the likelihood is returned as there is no need to penalize for generalization purposes.</p>
</td></tr>
<tr><td><code id="topdown_iter_+3A_param">param</code></td>
<td>
<p>List providing the methods to test (from 1, 2 and 3, default: list(1,2,3)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function discretizes a dataset containing continuous features <code class="reqn">X</code> in a supervised way, i.e. knowing observations of a binomial random variable <code class="reqn">Y</code> which we would like to predict based on the discretization of <code class="reqn">X</code>.
To do so, the <code>Topdown</code> alorithms ...
In the context of Credit Scoring, a logistic regression is fitted between the ‘‘discretized&rdquo; features <code class="reqn">E</code> and the response feature <code class="reqn">Y</code>. As a consequence, the output of this function is the discretized features <code class="reqn">E</code>, the logistic regression model of <code class="reqn">E</code> on <code class="reqn">Y</code> and the parameters used to get this fit.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
</p>
<p>HyunJi Kim (2012). discretization: Data preprocessing, discretization for classification. R package version 1.0-1. <a href="https://CRAN.R-project.org/package=discretization">https://CRAN.R-project.org/package=discretization</a>
</p>
<p>Gonzalez-Abril, L., Cuberos, F. J., Velasco, F. and Ortega, J. A. (2009) Ameva: An autonomous discretization algorithm, <em>Expert Systems with Applications</em>, <strong>36</strong>, 5327–5332.
</p>
<p>Kurgan, L. A. and Cios, K. J. (2004). CAIM Discretization Algorithm, <em>IEEE Transactions on knowledge and data engineering</em>, <strong>16</strong>, 145–153.
</p>
<p>Tsai, C. J., Lee, C. I. and Yang, W. P. (2008). A discretization algorithm based on Class-Attribute Contingency Coefficient, <em>Information Sciences</em>, <strong>178</strong>, 714–731.
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>, <code>discretization</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a discretized logit model
x &lt;- matrix(runif(300), nrow = 100, ncol = 3)
cuts &lt;- seq(0, 1, length.out = 4)
xd &lt;- apply(x, 2, function(col) as.numeric(cut(col, cuts)))
theta &lt;- t(matrix(c(0, 0, 0, 2, 2, 2, -2, -2, -2), ncol = 3, nrow = 3))
log_odd &lt;- rowSums(t(sapply(seq_along(xd[, 1]), function(row_id) {
  sapply(
    seq_along(xd[row_id, ]),
    function(element) theta[xd[row_id, element], element]
  )
})))
y &lt;- stats::rbinom(100, 1, 1 / (1 + exp(-log_odd)))

topdown_iter(x, y)
</code></pre>

<hr>
<h2 id='twins'>Twins</h2><span id='topic+twins'></span>

<h3>Description</h3>

<p>This function performs Reject Inference using the Twins technique. Note that this technique has no theoretical foundation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twins(xf, xnf, yf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twins_+3A_xf">xf</code></td>
<td>
<p>The matrix of financed clients' characteristics to be used in the scorecard.</p>
</td></tr>
<tr><td><code id="twins_+3A_xnf">xnf</code></td>
<td>
<p>The matrix of not financed clients' characteristics to be used in the scorecard (must be the same in the same order as xf!).</p>
</td></tr>
<tr><td><code id="twins_+3A_yf">yf</code></td>
<td>
<p>The matrix of financed clients' labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the Twins method on the data. When provided with labeled observations <code class="reqn">(x^\ell,y)</code>, it first fits the logistic regression model <code class="reqn">p_\theta</code> of
<code class="reqn">x^\ell</code> on <code class="reqn">y</code>, then fits the logistic regression model <code class="reqn">p_\omega</code> of <code class="reqn">X</code> on the binomial random variable denoting the observation of the data <code class="reqn">Z</code>.
We use predictions of both models on the labeled observations to construct a &quot;meta&quot;-score based on logistic regression which predicted probabilities are used to reweight samples and construct the final score <code class="reqn">p_\eta</code>.
</p>


<h3>Value</h3>

<p>List containing the model using financed clients only, the model of acceptance and the model produced using the Twins method.
</p>


<h3>Author(s)</h3>

<p>Adrien Ehrhardt
</p>


<h3>References</h3>

<p>Enea, M. (2015), speedglm: Fitting Linear and Generalized Linear Models to Large Data Sets, <a href="https://CRAN.R-project.org/package=speedglm">https://CRAN.R-project.org/package=speedglm</a>
Ehrhardt, A., Biernacki, C., Vandewalle, V., Heinrich, P. and Beben, S. (2018), Reject Inference Methods in Credit Scoring: a rational review,
</p>


<h3>See Also</h3>

<p><code>glm</code>, <code>speedglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate data from financed clients
df &lt;- generate_data(n = 100, d = 2)
xf &lt;- df[, -ncol(df)]
yf &lt;- df$y
# We simulate data from not financed clients (MCAR mechanism)
xnf &lt;- generate_data(n = 100, d = 2)[, -ncol(df)]
twins(xf, xnf, yf)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
