<!DOCTYPE html><html><head><title>Help for package aphid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aphid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align'><p>Multiple sequence alignment in R.</p></a></li>
<li><a href='#aphid'><p>The <span class="pkg">aphid</span> package for analysis with profile hidden Markov models.</p></a></li>
<li><a href='#backward'><p>The backward algorithm.</p></a></li>
<li><a href='#casino'><p>Dishonest casino.</p></a></li>
<li><a href='#deriveHMM'><p>Derive a standard hidden Markov model from a set of sequences.</p></a></li>
<li><a href='#derivePHMM'><p>Derive a profile hidden Markov model from sequences.</p></a></li>
<li><a href='#forward'><p>The forward algorithm.</p></a></li>
<li><a href='#generate'><p>Generate random sequences from a model.</p></a></li>
<li><a href='#globins'><p>Globin protein alignment.</p></a></li>
<li><a href='#logsum'><p>Sum of logged probabilities.</p></a></li>
<li><a href='#map'><p>Optimized profile HMM construction.</p></a></li>
<li><a href='#plot.HMM'><p>Plot standard hidden Markov models.</p></a></li>
<li><a href='#plot.PHMM'><p>Plot profile hidden Markov models.</p></a></li>
<li><a href='#posterior'><p>Posterior decoding.</p></a></li>
<li><a href='#print'><p>Print summary methods.</p></a></li>
<li><a href='#readPHMM'><p>Import profile hidden Markov models into R.</p></a></li>
<li><a href='#substitution'><p>Substitution matrices.</p></a></li>
<li><a href='#train'><p>Iterative model refinement.</p></a></li>
<li><a href='#unalign'><p>Deconstruct an alignment.</p></a></li>
<li><a href='#Viterbi'><p>The Viterbi algorithm.</p></a></li>
<li><a href='#weight'><p>Sequence weighting.</p></a></li>
<li><a href='#writePHMM'><p>Export profile hidden Markov models as text.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis with Profile Hidden Markov Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Shaun Wilkinson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shaun Wilkinson &lt;shaunpwilkinson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed for the development and application of
    hidden Markov models and profile HMMs for biological sequence analysis. 
    Contains functions for multiple and pairwise sequence alignment, 
    model construction and parameter optimization, file import/export,
    implementation of the forward, backward and Viterbi algorithms for 
    conditional sequence probabilities, tree-based sequence weighting, 
    and sequence simulation. 
    Features a wide variety of potential applications including 
    database searching, gene-finding and annotation, phylogenetic 
    analysis and sequence classification.
    Based on the models and algorithms described in Durbin et 
    al (1998, ISBN: 9780521629713).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shaunpwilkinson/aphid">https://github.com/shaunpwilkinson/aphid</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shaunpwilkinson/aphid/issues">https://github.com/shaunpwilkinson/aphid/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, openssl, kmer (&ge; 1.0.0), Rcpp (&ge; 0.12.5), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape (&ge; 4.0), knitr, qpdf, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-04 01:59:59 UTC; shaun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 08:10:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='align'>Multiple sequence alignment in R.</h2><span id='topic+align'></span><span id='topic+align.DNAbin'></span><span id='topic+align.AAbin'></span><span id='topic+align.list'></span><span id='topic+align.default'></span>

<h3>Description</h3>

<p><code>align</code> performs a multiple alignment on a list of
sequences using profile hidden Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(x, ...)

## S3 method for class 'DNAbin'
align(
  x,
  model = NULL,
  progressive = FALSE,
  seeds = NULL,
  seqweights = "Henikoff",
  refine = "Viterbi",
  k = 5,
  maxiter = 100,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  threshold = 0.5,
  deltaLL = 1e-07,
  DI = FALSE,
  ID = FALSE,
  residues = NULL,
  gap = "-",
  pseudocounts = "background",
  qa = NULL,
  qe = NULL,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'AAbin'
align(
  x,
  model = NULL,
  progressive = FALSE,
  seeds = NULL,
  seqweights = "Henikoff",
  refine = "Viterbi",
  k = 5,
  maxiter = 100,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  threshold = 0.5,
  deltaLL = 1e-07,
  DI = FALSE,
  ID = FALSE,
  residues = NULL,
  gap = "-",
  pseudocounts = "background",
  qa = NULL,
  qe = NULL,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'list'
align(
  x,
  model = NULL,
  progressive = FALSE,
  seeds = NULL,
  seqweights = "Henikoff",
  k = 5,
  refine = "Viterbi",
  maxiter = 100,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  threshold = 0.5,
  deltaLL = 1e-07,
  DI = FALSE,
  ID = FALSE,
  residues = NULL,
  gap = "-",
  pseudocounts = "background",
  qa = NULL,
  qe = NULL,
  cores = 1,
  quiet = FALSE,
  ...
)

## Default S3 method:
align(
  x,
  model,
  pseudocounts = "background",
  residues = NULL,
  gap = "-",
  maxsize = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_x">x</code></td>
<td>
<p>a list of DNA, amino acid, or other character sequences
consisting of symbols emitted from the chosen residue alphabet.
The vectors can either be of mode &quot;raw&quot; (consistent with the &quot;DNAbin&quot;
or &quot;AAbin&quot; coding scheme set out in the <code><a href="ape.html#topic+ape">ape</a></code> package),
or &quot;character&quot;, in which case the alphabet should be specified in
the <code>residues</code> argument. This argument can alternatively be a
vector representing a single sequence. In this case, and if the
second argument is also a single sequence, a standard pairwise
alignment is returned.</p>
</td></tr>
<tr><td><code id="align_+3A_...">...</code></td>
<td>
<p>aditional arguments to be passed to <code>"Viterbi"</code> (if
<code>refine = "Viterbi"</code>) or <code>"forward"</code> (if
<code>refine = "BaumWelch"</code>).</p>
</td></tr>
<tr><td><code id="align_+3A_model">model</code></td>
<td>
<p>an optional profile hidden Markov model (a <code>"PHMM"</code>
object) to align the sequences to. If <code>NULL</code> a PHMM will
be derived from the list of sequences, and each sequence
will be aligned back to the model to produce the multiple sequence
alignment.</p>
</td></tr>
<tr><td><code id="align_+3A_progressive">progressive</code></td>
<td>
<p>logical indicating whether the alignment used
to derive the initial model parameters
should be built progressively (assuming input is a list of
unaligned sequences, ignored otherwise).
Defaults to FALSE, in which case the longest sequence or sequences
are used (faster, but possibly less accurate).</p>
</td></tr>
<tr><td><code id="align_+3A_seeds">seeds</code></td>
<td>
<p>optional integer vector indicating which sequences should
be used as seeds for building the guide tree for the progressive
alignment (assuming input is a list of unaligned sequences,
and <code>progressive = TRUE</code>, ignored otherwise).
Defaults to NULL, in which a set of log(n, 2)^2 non-identical
sequences are chosen from the list of sequences by k-means clustering.</p>
</td></tr>
<tr><td><code id="align_+3A_seqweights">seqweights</code></td>
<td>
<p>either NULL (all sequences are given weights
of 1), a numeric vector the same length as <code>x</code> representing
the sequence weights used to derive the model, or a character string giving
the method to derive the weights from the sequences
(see <code><a href="#topic+weight">weight</a></code>).</p>
</td></tr>
<tr><td><code id="align_+3A_refine">refine</code></td>
<td>
<p>the method used to iteratively refine the model parameters
following the initial progressive alignment and model derivation step.
Current supported options are <code>"Viterbi"</code> (Viterbi training;
the default option), <code>"BaumWelch"</code> (a modified version of the
Expectation-Maximization algorithm), and &quot;none&quot; (skips the model
refinement step).</p>
</td></tr>
<tr><td><code id="align_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size to be used in tree-based
sequence weighting (if applicable). Defaults to 5. Note that higher
values of k may be slow to compute and use excessive memory due to
the large numbers of calculations required.</p>
</td></tr>
<tr><td><code id="align_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of EM iterations or Viterbi training
iterations to carry out before the cycling process is terminated and
the partially trained model is returned. Defaults to 100.</p>
</td></tr>
<tr><td><code id="align_+3A_maxsize">maxsize</code></td>
<td>
<p>integer giving the upper bound on the number of modules
in the PHMM. If NULL no maximum size is enforced.</p>
</td></tr>
<tr><td><code id="align_+3A_inserts">inserts</code></td>
<td>
<p>character string giving the model construction method
in which alignment columns
are marked as either match or insert states. Accepted methods include
<code>"threshold"</code> (only columns with fewer than a specified
proportion of gaps form match states in the model), <code>"map"</code> (default;
match and insert columns are found using the maximum <em>a posteriori</em>
method outlined in Durbin et al (1998) chapter 5.7), <code>"inherited"</code>
(match and insert columns are inherited from the input alignment),
and <code>"none"</code> (all columns are assigned match states in the model).
Alternatively, insert columns can be
specified manually by providing a logical vector the same length
as the number of columns in the alignment, with <code>TRUE</code> for insert
columns and <code>FALSE</code> for match states.</p>
</td></tr>
<tr><td><code id="align_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter used to favour models with fewer match
states. Equivalent to the log of the prior probability of marking each
column (Durbin et al 1998, chapter 5.7). Only applicable when
<code>inserts = "map"</code>.</p>
</td></tr>
<tr><td><code id="align_+3A_threshold">threshold</code></td>
<td>
<p>the maximum proportion of gaps for an alignment column
to be considered for a match state in the PHMM (defaults to 0.5).
Only applicable when <code>inserts = "threshold"</code>.
Note that the maximum <em>a posteriori</em>
method works poorly for alignments with few sequences,
so the 'threshold' method is
automatically used when the number of sequences is less than 5.</p>
</td></tr>
<tr><td><code id="align_+3A_deltall">deltaLL</code></td>
<td>
<p>numeric, the maximum change in log likelihood between EM
iterations before the cycling procedure is terminated (signifying model
convergence). Defaults to 1E-07. Only applicable if
<code>method = "BaumWelch"</code>.</p>
</td></tr>
<tr><td><code id="align_+3A_di">DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="align_+3A_id">ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="align_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Furthermore, the default setting
<code>residues = NULL</code> will not detect rare residues that are not present
in the sequences, and thus will not assign them emission probabilities
in the model. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="align_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix.
Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects. Defaults to &quot;-&quot;
otherwise.</p>
</td></tr>
<tr><td><code id="align_+3A_pseudocounts">pseudocounts</code></td>
<td>
<p>character string, either &quot;background&quot;, Laplace&quot;
or &quot;none&quot;. Used to account for the possible absence of certain
transition and/or emission types in the input sequences.
If <code>pseudocounts = "background"</code> (default), pseudocounts
are calculated from the background transition and emission
frequencies in the sequences.
If <code>pseudocounts = "Laplace"</code> one of each possible transition
and emission type is added to the transition and emission counts.
If <code>pseudocounts = "none"</code> no pseudocounts are added (not
generally recommended, since low frequency transition/emission types
may be excluded from the model).
Alternatively this argument can be a two-element list containing
a matrix of transition pseudocounts
as its first element and a matrix of emission pseudocounts as its
second.</p>
</td></tr>
<tr><td><code id="align_+3A_qa">qa</code></td>
<td>
<p>an optional named 9-element vector of background transition
probabilities with <code>dimnames(qa) = c("DD", "DM", "DI", "MD", "MM",
"MI", "ID", "IM", "II")</code>, where M, I and D represent match, insert and
delete states, respectively. If <code>NULL</code>, background transition
probabilities are estimated from the sequences.</p>
</td></tr>
<tr><td><code id="align_+3A_qe">qe</code></td>
<td>
<p>an optional named vector of background emission probabilities
the same length as the residue alphabet (i.e. 4 for nucleotides and 20
for amino acids) and with corresponding names (i.e. <code>c("A", "T",
"G", "C")</code> for DNA). If <code>qe = NULL</code>, background emission probabilities
are automatically derived from the sequences.</p>
</td></tr>
<tr><td><code id="align_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of CPUs to parallelize the operation
over. Defaults to 1, and reverts to 1 if x is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be aligned, due to the extra time required to initialize
the cluster.</p>
</td></tr>
<tr><td><code id="align_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether feedback should be printed
to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds a multiple sequence alignment using profile
hidden Markov models. The default behaviour is to select the longest
sequence in the set that had the lowest sequence weight, derive a profile
HMM from the single sequence, and iteratively train the model
using the entire sequence set. Training can be achieved using either
the Baum Welch or Viterbi training algorithm, with the latter being
significantly faster, particularly when multi-threading is used.
Once the model parameters have converged (Baum Welch) or no variation
is seen in the sequential alignments (Viterbi training), the sequences
are aligned to the profile HMM to produce the alignment matrix.
The preceeding steps can be omitted if a pre-trained profile HMM
is passed to the function via the &quot;model&quot; argument.
</p>
<p>If <code>progressive = TRUE</code> the function alternatively uses a
progressive alignment procedure similar to the Clustal Omega algorithm
(Sievers et al 2011). The involves an initial progressive multiple
sequence alignment via a guide tree,
followed by the derivation of a profile hidden Markov model
from the alignment, an iterative model refinement step,
and finally the alignment of the sequences back to the model as above.
</p>
<p>If only two sequences are provided, a standard pairwise alignment
is carried out using the Needleman-Wunch or Smith-Waterman algorithm.
</p>


<h3>Value</h3>

<p>a matrix of aligned sequences, with the same mode and class as the
input sequence list.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Sievers F, Wilm A, Dineen D, Gibson TJ, Karplus K, Li W, Lopez R, McWilliam H,
Remmert M, Soding J, Thompson JD, Higgins DG (2011) Fast, scalable generation
of high-quality protein multiple sequence alignments using Clustal Omega.
<em>Molecular Systems Biology</em>, <strong>7</strong>, 539.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unalign">unalign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Protein pairwise alignment example from Durbin et al (1998) chapter 2.
  x &lt;- c("H", "E", "A", "G", "A", "W", "G", "H", "E", "E")
  y &lt;- c("P", "A", "W", "H", "E", "A", "E")
  sequences &lt;- list(x = x, y = y)
  glo &lt;- align(sequences, type = "global")
  sem &lt;- align(sequences, type = "semiglobal")
  loc &lt;- align(sequences, type = "local")
  glo
  sem
  loc

  ## Deconstruct the woodmouse alignment and re-align
  library(ape)
  data(woodmouse)
  tmp &lt;- unalign(woodmouse)
  x &lt;- align(tmp, windowspace = "WilburLipman")

</code></pre>

<hr>
<h2 id='aphid'>The <span class="pkg">aphid</span> package for analysis with profile hidden Markov models.</h2><span id='topic+aphid'></span>

<h3>Description</h3>

<p><span class="pkg">aphid</span> is an R package for the development and application of
hidden Markov models and profile HMMs for biological sequence analysis.
Functions are included for multiple and pairwise sequence alignment,
model construction and parameter optimization, calculation of conditional
probabilities (using the forward, backward and Viterbi algorithms),
tree-based sequence weighting, sequence simulation, and file import/export
compatible with the <a href="http://www.hmmer.org">HMMER</a> software package.
The package has a wide variety of uses including database searching,
gene-finding and annotation, phylogenetic analysis and sequence classification.
</p>


<h3>Details</h3>

<p>The <span class="pkg">aphid</span> package is based on the algorithms outlined in the book 'Biological
sequence analysis: probabilistic models of proteins and nucleic acids' by Richard Durbin,
Sean Eddy, Anders Krogh and Graeme Mitchison. This book is highly recommended
for those wishing to develop a better understanding of HMMs and PHMMs, regardless of
prior experience. Many of the examples in the function help pages are taken directly
from the book, so that readers can learn to use the package as they work through the
chapters.
</p>
<p>There are also excellent rescources available for those wishing to use profile hidden
Markov models outside of the R environment. The <span class="pkg">aphid</span> package maintains
compatibility with the <a href="http://www.hmmer.org">HMMER</a> software suite
through the file input and output functions <code><a href="#topic+readPHMM">readPHMM</a></code> and
<code><a href="#topic+writePHMM">writePHMM</a></code>.
</p>
<p>The <span class="pkg">aphid</span> package is designed to work in conjunction with the &quot;DNAbin&quot;
and &quot;AAbin&quot; object types produced by the <code><a href="ape.html#topic+ape">ape</a></code> package
(Paradis et al 2004, 2012). This is an essential piece of software for those
using R for biological sequence analysis, and provides a binary coding format
for nucleotides and amino acids that maximizes memory and speed efficiency.
While <span class="pkg">aphid</span> also works with standard character vectors and matrices,
it may not recognize the DNA and amino acid amibguity codes and therefore is not
guaranteed to treat them appropriately.
</p>
<p>To maximize speed, the low-level dynamic programming functions such
as <code><a href="#topic+Viterbi">Viterbi</a></code>, <code><a href="#topic+forward">forward</a></code> and <code><a href="#topic+backward">backward</a></code>
are written in C++ with the help of the <code><a href="Rcpp.html#topic+Rcpp">Rcpp</a></code>
package (Eddelbuettel &amp; Francois 2011).
Note that R versions of these functions are also maintained
for the purposes of debugging, experimentation and code interpretation.
</p>


<h3>Classes</h3>

<p>The <span class="pkg">aphid</span> package creates two primary object classes, <code>"HMM"</code>
(hidden Markov models) and <code>"PHMM"</code> (profile hidden Markov models)
with the functions <code><a href="#topic+deriveHMM">deriveHMM</a></code> and <code><a href="#topic+derivePHMM">derivePHMM</a></code>, respectively.
These objects are lists consisting of emission and transition probability matrices
(denoted E and A), vectors of non-position-specific background emission and transition
probabilies (denoted qe and qa) and other model metadata.
Objects of class <code>"DPA"</code> (dynammic programming array) are also generated
by the Viterbi and forward/backward functions.
These are primarily created for succinct console printing.
</p>


<h3>Functions</h3>

<p>A breif description of the primary <span class="pkg">aphid</span> functions are provided with links
to their help pages below.
</p>


<h3>File import and export</h3>


<ul>
<li> <p><code><a href="#topic+readPHMM">readPHMM</a></code> parses a <a href="http://www.hmmer.org">HMMER</a> text file
into R and creates an object of class <code>"PHMM"</code>
</p>
</li>
<li> <p><code><a href="#topic+writePHMM">writePHMM</a></code> writes a <code>"PHMM"</code> object to a text file in
<a href="http://www.hmmer.org">HMMER</a> v3 format
</p>
</li></ul>



<h3>Visualization</h3>


<ul>
<li> <p><code><a href="#topic+plot.HMM">plot.HMM</a></code> plots a <code>"PHMM"</code> object as a cyclic directed graph
</p>
</li>
<li> <p><code><a href="#topic+plot.PHMM">plot.PHMM</a></code> plots a <code>"PHMM"</code> object as a directed graph with
sequential modules consisting of match, insert and delete states
</p>
</li></ul>



<h3>Model building and training</h3>


<ul>
<li> <p><code><a href="#topic+deriveHMM">deriveHMM</a></code> builds a <code>"HMM"</code> object from a list of training
sequences
</p>
</li>
<li> <p><code><a href="#topic+derivePHMM">derivePHMM</a></code> builds a <code>"PHMM"</code> object from a multiple sequence
alignment or a list of non-aligned sequences
</p>
</li>
<li> <p><code><a href="#topic+map">map</a></code> optimizes profile hidden Markov model construction
using the maximum <em>a posteriori</em> algorithm
</p>
</li>
<li> <p><code><a href="#topic+train">train</a></code> optimizes the parameters of a <code>"HMM"</code> or
<code>"PHMM"</code> object using a list of training sequences
</p>
</li></ul>



<h3>Sequence alignment and weighting</h3>


<ul>
<li> <p><code><a href="#topic+align">align</a></code> performs a multiple sequence alignment
</p>
</li>
<li> <p><code><a href="#topic+weight">weight</a></code> assigns weights to sequences
</p>
</li></ul>



<h3>Conditional probabilities</h3>


<ul>
<li> <p><code><a href="#topic+Viterbi">Viterbi</a></code> finds the optimal path of a sequence through a HMM
or PHMM, and returns its log odds or probability given the model
</p>
</li>
<li> <p><code><a href="#topic+forward">forward</a></code> finds the full probability of a sequence
given a HMM or PHMM using the forward algorithm
</p>
</li>
<li> <p><code><a href="#topic+backward">backward</a></code> finds the full probability of a sequence
given a HMM or PHMM using the backward algorithm
</p>
</li>
<li> <p><code><a href="#topic+posterior">posterior</a></code> finds the position-specific posterior probability
of a sequence given a HMM or PHMM
</p>
</li></ul>



<h3>Sequence simulation</h3>


<ul>
<li> <p><code><a href="#topic+generate.HMM">generate.HMM</a></code> simulates a random sequence from an HMM
</p>
</li>
<li> <p><code><a href="#topic+generate.PHMM">generate.PHMM</a></code> simulates a random sequence from a PHMM
</p>
</li></ul>



<h3>Datasets</h3>


<ul>
<li> <p><code><a href="#topic+substitution">substitution</a></code> a collection of DNA and amino acid
substitution matrices from <a href="ftp://ftp.ncbi.nih.gov/blast/matrices/">NCBI</a>
including the PAM, BLOSUM, GONNET, DAYHOFF and NUC matrices
</p>
</li>
<li> <p><code><a href="#topic+casino">casino</a></code> data from the dishonest casino example of
Durbin et al (1998) chapter 3.2
</p>
</li>
<li> <p><code><a href="#topic+globins">globins</a></code> Small globin alignment data from
Durbin et al (1998) Figure 5.3
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Eddelbuettel D, Francois R (2011) Rcpp: seamless R and C++ integration.
<em>Journal of Statistical Software</em> <strong>40</strong>, 1-18.
</p>
<p>Finn RD, Clements J &amp; Eddy SR (2011) HMMER web server: interactive sequence
similarity searching.
<em>Nucleic Acids Research</em>. <strong>39</strong>, W29-W37. <a href="http://hmmer.org/">http://hmmer.org/</a>.
</p>
<p>HMMER: biosequence analysis using profile hidden Markov models.
<a href="http://www.hmmer.org">http://www.hmmer.org</a>.
</p>
<p>NCBI index of substitution matrices.
<a href="ftp://ftp.ncbi.nih.gov/blast/matrices/">ftp://ftp.ncbi.nih.gov/blast/matrices/</a>.
</p>
<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>

<hr>
<h2 id='backward'>The backward algorithm.</h2><span id='topic+backward'></span><span id='topic+backward.PHMM'></span><span id='topic+backward.HMM'></span>

<h3>Description</h3>

<p>This function calculates the full (log) probability or odds
of a sequence given a hidden Markov model or profile HMM using the
backward dynamic programming algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backward(x, y, ...)

## S3 method for class 'PHMM'
backward(
  x,
  y,
  qe = NULL,
  logspace = "autodetect",
  odds = TRUE,
  windowspace = "all",
  DI = FALSE,
  ID = FALSE,
  cpp = TRUE,
  ...
)

## S3 method for class 'HMM'
backward(x, y, logspace = "autodetect", cpp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backward_+3A_x">x</code></td>
<td>
<p>an object of class <code>PHMM</code> or <code>HMM</code>.</p>
</td></tr>
<tr><td><code id="backward_+3A_y">y</code></td>
<td>
<p>a vector of mode &quot;character&quot; or &quot;raw&quot; (a &quot;DNAbin&quot; or &quot;AAbin&quot;
object) representing a single sequence hypothetically emitted by
the model in <code>x</code>.</p>
</td></tr>
<tr><td><code id="backward_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="backward_+3A_qe">qe</code></td>
<td>
<p>an optional named vector of background residue frequencies (only
applicable if x is a PHMM). If <code>qe = NULL</code> the function looks for
a qe vector as an attribute of the PHMM. If these are not available
equal background residue frequencies are assumed.</p>
</td></tr>
<tr><td><code id="backward_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td></tr>
<tr><td><code id="backward_+3A_odds">odds</code></td>
<td>
<p>logical, indicates whether the returned scores
should be odds ratios (TRUE) or full logged probabilities (FALSE).</p>
</td></tr>
<tr><td><code id="backward_+3A_windowspace">windowspace</code></td>
<td>
<p>a two-element integer vector providing the search space for
dynamic programming (see Wilbur &amp; Lipman 1983 for details). The first element
should be negative, and represent the lowermost diagonal of the
dynammic programming array, and the second element should be positive,
representing the leftmost diagonal. Alternatively, if the the character
string &quot;all&quot; is passed (the default setting) the entire dynamic programming
array will be computed.</p>
</td></tr>
<tr><td><code id="backward_+3A_di">DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="backward_+3A_id">ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="backward_+3A_cpp">cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for a compiled C++ function that recursively
fills a dynamic programming matrix with logged probabilities, and
calculates the full (logged) probability of a sequence given a HMM or
PHMM.
For a thorough explanation of the backward, forward and Viterbi
algorithms, see Durbin et al (1998) chapters 3.2 (HMMs) and 5.4 (PHMMs).
</p>


<h3>Value</h3>

<p>an object of class <code>"DPA"</code>, which is a list
containing the score and dynamic programming array.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Wilbur WJ, Lipman DJ (1983) Rapid similarity searches of nucleic acid and
protein data banks. <em>Proc Natl Acad Sci USA</em>, <strong>80</strong>, 726-730.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forward">forward</a></code>, <code><a href="#topic+Viterbi">Viterbi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Backward algorithm for standard HMMs:
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino HMM")
  data(casino)
  backward(x, casino)
  ##
  ## Backward algorithm for profile HMMs:
  ## Small globin alignment data from Durbin et al (1998) Figure 5.3
  data(globins)
  ### Derive a profile hidden Markov model from the alignment
  globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  plot(globins.PHMM, main = "Profile hidden Markov model for globins")
  ### Simulate a random sequence from the model
  suppressWarnings(RNGversion("3.5.0"))
  set.seed(999)
  simulation &lt;- generate(globins.PHMM, size = 20)
  simulation ## "F" "S" "A" "N" "N" "D" "W" "E"
  ### Calculate the full (log) probability of the sequence given the model
  x &lt;- backward(globins.PHMM, simulation, odds = FALSE)
  x # -23.0586
  ### Show dynammic programming array
  x$array
</code></pre>

<hr>
<h2 id='casino'>Dishonest casino.</h2><span id='topic+casino'></span>

<h3>Description</h3>

<p>The 'dishonest casino' example from Durbin et al (1998) chapter 3.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>casino
</code></pre>


<h3>Format</h3>

<p>A named character vector showing the result of 300 rolls of a dice
that switches from &quot;Fair&quot; to &quot;Loaded&quot; with a probability
of 0.05 and back to &quot;Fair&quot; with a probability of 0.1. In the Fair
state each outcome from 1 to 6 has an equal probability of occurring,
while in the Loaded state the probability of rolling a 6 increases
to 0.5 (with the remaining five probabilities reduced to 0.1).
The elements of the vector are the outcomes of the 300 rolls
(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, or &quot;6&quot;) and the &quot;names&quot; attribute
represents the underlying Markov states (&quot;Fair&quot; or &quot;Loaded&quot;).
</p>


<h3>Source</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>

<hr>
<h2 id='deriveHMM'>Derive a standard hidden Markov model from a set of sequences.</h2><span id='topic+deriveHMM'></span>

<h3>Description</h3>

<p><code>deriveHMM</code> calculates the maximum likelihood hidden Markov model from
a list of training sequences, each a vector of residues named according
the state from which they were emitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriveHMM(
  x,
  seqweights = NULL,
  residues = NULL,
  states = NULL,
  modelend = FALSE,
  pseudocounts = "background",
  logspace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriveHMM_+3A_x">x</code></td>
<td>
<p>a list of named character vectors representing emissions
from the model. The 'names' attribute should represent the hidden state
from which each residue was emitted. &quot;DNAbin&quot; and &quot;AAbin&quot; list
objects are also supported for modeling DNA or amino acid sequences.</p>
</td></tr>
<tr><td><code id="deriveHMM_+3A_seqweights">seqweights</code></td>
<td>
<p>either NULL (all sequences are given
weights of 1) or a numeric vector the same length as <code>x</code> representing
the sequence weights used to derive the model.</p>
</td></tr>
<tr><td><code id="deriveHMM_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Furthermore, the default setting
<code>residues = NULL</code> will not detect rare residues that are not present
in the sequences, and thus will not assign them emission probabilities
in the model. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="deriveHMM_+3A_states">states</code></td>
<td>
<p>either NULL (default; the unique Markov states are
automatically detected from the 'names' attributes of the input
sequences), or a case sensitive character vector specifying the unique
Markov states (or a superset of the unique states) to appear in the
model. The latter option is recommended since it saves computation time
and ensures that all valid Markov states appear in the model,
regardless of their possible absence from the training dataset.</p>
</td></tr>
<tr><td><code id="deriveHMM_+3A_modelend">modelend</code></td>
<td>
<p>logical indicating whether transition probabilites
to the end state of the standard hidden Markov model should be
modeled (if applicable). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="deriveHMM_+3A_pseudocounts">pseudocounts</code></td>
<td>
<p>character string, either &quot;background&quot;, Laplace&quot;
or &quot;none&quot;. Used to account for the possible absence of certain
transition and/or emission types in the input sequences.
If <code>pseudocounts = "background"</code> (default), pseudocounts
are calculated from the background transition and emission
frequencies in the training dataset.
If <code>pseudocounts = "Laplace"</code> one of each possible transition
and emission type is added to the training dataset (default).
If <code>pseudocounts = "none"</code> no pseudocounts are added (not
usually recommended, since low frequency transition/emission types
may be excluded from the model).
Alternatively this argument can be a two-element list containing
a matrix of transition pseudocounts
as its first element and a matrix of emission pseudocounts as its
second. If this option is selected, both matrices must have row and column
names corresponding with the residues (column names of emission matrix)
and states (row and column names of the transition matrix and
row names of the emission matrix). For downstream applications
the first row and column of the transition matrix should be named
&quot;Begin&quot;.</p>
</td></tr>
<tr><td><code id="deriveHMM_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities in the returned model should be logged. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a standard hidden Markov model (object class:
<code>"HMM"</code>) using the method described in Durbin et al (1998) chapter
3.3. It assumes the state sequence is known
(as opposed to the <code><a href="#topic+train.HMM">train.HMM</a></code> function, which is used
when the state sequence is unknown) and provided as the names attribute(s)
of the input sequences. The output object is a simple list with elements
&quot;A&quot; (transition probability matrix) and &quot;E&quot; (emission probability matrix),
and the &quot;class&quot; attribute &quot;HMM&quot;. The emission matrix has the same number
of rows as the number of states, and the same number of columns as the
number of unique symbols that can be emitted (i.e. the residue alphabet).
The number of rows and columns in the transition probability matrix
should be one more the number of states, to include the silent &quot;Begin&quot;
state in the first row and column. Despite its name, this state is
also used when modeling transitions to the (silent)
end state, which are entered in the first column.
</p>


<h3>Value</h3>

<p>an object of class <code>"HMM"</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivePHMM">derivePHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(casino)
 deriveHMM(list(casino))
</code></pre>

<hr>
<h2 id='derivePHMM'>Derive a profile hidden Markov model from sequences.</h2><span id='topic+derivePHMM'></span><span id='topic+derivePHMM.DNAbin'></span><span id='topic+derivePHMM.AAbin'></span><span id='topic+derivePHMM.list'></span><span id='topic+derivePHMM.default'></span>

<h3>Description</h3>

<p><code>derivePHMM</code> generates a profile HMM from a given multiple sequence alignment
or a list of unaligned sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivePHMM(x, ...)

## S3 method for class 'DNAbin'
derivePHMM(
  x,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  threshold = 0.5,
  lambda = 0,
  DI = FALSE,
  ID = FALSE,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  progressive = FALSE,
  seeds = NULL,
  refine = "Viterbi",
  maxiter = 100,
  deltaLL = 1e-07,
  cpp = TRUE,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'AAbin'
derivePHMM(
  x,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  threshold = 0.5,
  lambda = 0,
  DI = FALSE,
  ID = FALSE,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  progressive = FALSE,
  seeds = NULL,
  refine = "Viterbi",
  maxiter = 100,
  deltaLL = 1e-07,
  cpp = TRUE,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'list'
derivePHMM(
  x,
  progressive = FALSE,
  seeds = NULL,
  refine = "Viterbi",
  maxiter = 100,
  deltaLL = 1e-07,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  DI = FALSE,
  ID = FALSE,
  threshold = 0.5,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  cpp = TRUE,
  cores = 1,
  quiet = FALSE,
  ...
)

## Default S3 method:
derivePHMM(
  x,
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  logspace = TRUE,
  qa = NULL,
  qe = NULL,
  maxsize = NULL,
  inserts = "map",
  lambda = 0,
  threshold = 0.5,
  DI = FALSE,
  ID = FALSE,
  omit.endgaps = FALSE,
  name = NULL,
  description = NULL,
  compo = FALSE,
  consensus = FALSE,
  alignment = FALSE,
  cpp = TRUE,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivePHMM_+3A_x">x</code></td>
<td>
<p>a matrix of aligned sequences or a list of unaligned sequences.
Accepted modes are &quot;character&quot; and &quot;raw&quot; (for &quot;DNAbin&quot; and &quot;AAbin&quot; objects).</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_...">...</code></td>
<td>
<p>aditional arguments to be passed to <code>"Viterbi"</code> (if
<code>refine = "Viterbi"</code>) or <code>"forward"</code> (if
<code>refine = "BaumWelch"</code>).</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_seqweights">seqweights</code></td>
<td>
<p>either NULL (all sequences are given weights
of 1), a numeric vector the same length as <code>x</code> representing
the sequence weights used to derive the model, or a character string giving
the method to derive the weights from the sequences
(see <code><a href="#topic+weight">weight</a></code>).</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_wfactor">wfactor</code></td>
<td>
<p>numeric. The factor to multiply the sequence weights by.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size to be used in tree-based
sequence weighting (if applicable). Defaults to 5. Note that higher
values of k may be slow to compute and use excessive memory due to
the large numbers of calculations required.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Furthermore, the default setting
<code>residues = NULL</code> will not detect rare residues that are not present
in the sequences, and thus will not assign them emission probabilities
in the model. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix.
Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects. Defaults to &quot;-&quot;
otherwise.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_endchar">endchar</code></td>
<td>
<p>the character used to represent unknown residues in
the alignment matrix (if applicable). Ignored for <code>"DNAbin"</code> or
<code>"AAbin"</code> objects. Defaults to &quot;?&quot; otherwise.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_pseudocounts">pseudocounts</code></td>
<td>
<p>character string, either &quot;background&quot;, Laplace&quot;
or &quot;none&quot;. Used to account for the possible absence of certain
transition and/or emission types in the input sequences.
If <code>pseudocounts = "background"</code> (default), pseudocounts
are calculated from the background transition and emission
frequencies in the sequences.
If <code>pseudocounts = "Laplace"</code> one of each possible transition
and emission type is added to the transition and emission counts.
If <code>pseudocounts = "none"</code> no pseudocounts are added (not
generally recommended, since low frequency transition/emission types
may be excluded from the model).
Alternatively this argument can be a two-element list containing
a matrix of transition pseudocounts
as its first element and a matrix of emission pseudocounts as its
second.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities in the returned model should be logged. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_qa">qa</code></td>
<td>
<p>an optional named 9-element vector of background transition
probabilities with <code>dimnames(qa) = c("DD", "DM", "DI", "MD", "MM",
"MI", "ID", "IM", "II")</code>, where M, I and D represent match, insert and
delete states, respectively. If <code>NULL</code>, background transition
probabilities are estimated from the sequences.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_qe">qe</code></td>
<td>
<p>an optional named vector of background emission probabilities
the same length as the residue alphabet (i.e. 4 for nucleotides and 20
for amino acids) and with corresponding names (i.e. <code>c("A", "T",
"G", "C")</code> for DNA). If <code>qe = NULL</code>, background emission probabilities
are automatically derived from the sequences.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_maxsize">maxsize</code></td>
<td>
<p>integer giving the upper bound on the number of modules
in the PHMM. If NULL (default) no maximum size is enforced.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_inserts">inserts</code></td>
<td>
<p>character string giving the model construction method
by which alignment columns
are marked as either match or insert states. Accepted methods include
<code>"threshold"</code> (only columns with fewer than a specified
proportion of gaps form match states in the model), <code>"map"</code> (default;
match and insert columns are found using the maximum <em>a posteriori</em>
method outlined in Durbin et al (1998) chapter 5.7), <code>"inherited"</code>
(match and insert columns are inherited from the input alignment),
and <code>"none"</code> (all columns are assigned
match states in the model). Alternatively, insert columns can be
specified manually by providing a logical vector the same length
as the number of columns in the alignment, with <code>TRUE</code> for insert
columns and <code>FALSE</code> for match states.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_threshold">threshold</code></td>
<td>
<p>the maximum proportion of gaps for an alignment column
to be considered for a match state in the PHMM (defaults to 0.5).
Only applicable when <code>inserts = "threshold"</code>.
Note that the maximum <em>a posteriori</em>
method works poorly for alignments with few sequences,
so the 'threshold' method is
automatically used when the number of sequences is less than 5.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter used to favour models with fewer match
states. Equivalent to the log of the prior probability of marking each
column (Durbin et al 1998, chapter 5.7). Only applicable when
<code>inserts = "map"</code>.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_di">DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_id">ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_omit.endgaps">omit.endgaps</code></td>
<td>
<p>logical. Should gap characters at each end of the
sequences be ignored when deriving the transition probabilities
of the model? Defaults to FALSE.
Set to TRUE if <code>x</code> is not a strict global alignment
(i.e. if the alignment contains partial sequences with missing
sections represented with gap characters).</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_name">name</code></td>
<td>
<p>an optional character string. The name of the
new profile hidden Markov model.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_description">description</code></td>
<td>
<p>an optional character string. The description of the
new profile hidden Markov model.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_compo">compo</code></td>
<td>
<p>logical indicating whether the average emission
probabilities of the model modules should be returned with the
PHMM object.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_consensus">consensus</code></td>
<td>
<p>placeholder. Consensus sequences will be available in
a future version.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_alignment">alignment</code></td>
<td>
<p>logical indicating whether the alignment used to
derive the final model (if applicable) should be included as an element of
the returned PHMM object. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_progressive">progressive</code></td>
<td>
<p>logical indicating whether the alignment used
to derive the initial model parameters
should be built progressively (assuming input is a list of
unaligned sequences, ignored otherwise).
Defaults to FALSE, in which case the
longest sequence or sequences are used (faster,
but possibly less accurate).</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_seeds">seeds</code></td>
<td>
<p>optional integer vector indicating which sequences should
be used as seeds for building the guide tree for the progressive
alignment (assuming input is a list of unaligned sequences,
and <code>progressive = TRUE</code>, ignored otherwise).
Defaults to NULL, in which a set of log(n, 2)^2 non-identical
sequences are chosen from the list of sequences by k-means clustering.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_refine">refine</code></td>
<td>
<p>the method used to iteratively refine the model parameters
following the initial progressive alignment and model derivation step.
Current supported options are <code>"Viterbi"</code> (Viterbi training;
the default option), <code>"BaumWelch"</code> (a modified version of the
Expectation-Maximization algorithm), and &quot;none&quot; (skips the model
refinement step).</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of EM iterations or Viterbi training
iterations to carry out before the cycling process is terminated and
the partially trained model is returned. Defaults to 100.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_deltall">deltaLL</code></td>
<td>
<p>numeric, the maximum change in log likelihood between EM
iterations before the cycling procedure is terminated (signifying model
convergence). Defaults to 1E-07. Only applicable if
<code>method = "BaumWelch"</code>.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_cpp">cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of CPUs to parallelize the operation
over. Defaults to 1, and reverts to 1 if x is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be aligned, due to the extra time required to initialize
the cluster.</p>
</td></tr>
<tr><td><code id="derivePHMM_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether feedback should be printed
to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a similar operation to the  <code>hmmbuild</code>
function in the <a href="http://www.hmmer.org">HMMER</a> package.
If the primary input argument is an alignment, the function creates a
profile hidden Markov model (object class:<code>"PHMM"</code>) using the
method described in Durbin et al (1998) chapter 5.3. Alternatively, if
a list of non-aligned sequences is passed, the sequences are first aligned
using the <code><a href="#topic+align">align</a></code> function before being used to derive the
model.
</p>
<p>The function outputs an object of class <code>"PHMM"</code>, which is a list
consisting of emission and transition probability matrices
(elements named &quot;E&quot; and &quot;A&quot;), vectors of non-position-specific
background emission and transition probabilities
(&quot;qe&quot; and &quot;qa&quot;, respectively) and other model metadata including
&quot;name&quot;, &quot;description&quot;, &quot;size&quot; (the number of modules in the model), and
&quot;alphabet&quot; (the set of symbols/residues emitted by the model).
</p>


<h3>Value</h3>

<p>an object of class <code>"PHMM"</code>
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deriveHMM">deriveHMM</a></code>, <code><a href="#topic+map">map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small globin alignment data from Durbin et al (1998) Figure 5.3
data(globins)
## derive a profile hidden Markov model from the alignment
globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
plot(globins.PHMM, main = "Profile HMM for small globin alignment")
##
## derive a profle HMM from the woodmouse dataset in the
## ape package and plot the first 5 modules
library(ape)
data(woodmouse)
woodmouse.PHMM &lt;- derivePHMM(woodmouse)
plot(woodmouse.PHMM, from = 0, to = 5, main = "Partial woodmouse profile HMM")
</code></pre>

<hr>
<h2 id='forward'>The forward algorithm.</h2><span id='topic+forward'></span><span id='topic+forward.PHMM'></span><span id='topic+forward.HMM'></span>

<h3>Description</h3>

<p>This function calculates the full (log) probability or odds
of a sequence given a hidden Markov model or profile HMM using the
forward dynamic programming algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward(x, y, ...)

## S3 method for class 'PHMM'
forward(
  x,
  y,
  qe = NULL,
  logspace = "autodetect",
  odds = TRUE,
  windowspace = "all",
  DI = FALSE,
  ID = FALSE,
  cpp = TRUE,
  ...
)

## S3 method for class 'HMM'
forward(x, y, logspace = "autodetect", cpp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_+3A_x">x</code></td>
<td>
<p>an object of class <code>PHMM</code> or <code>HMM</code>.</p>
</td></tr>
<tr><td><code id="forward_+3A_y">y</code></td>
<td>
<p>a vector of mode &quot;character&quot; or &quot;raw&quot; (a &quot;DNAbin&quot; or &quot;AAbin&quot;
object) representing a single sequence hypothetically emitted by
the model in <code>x</code>.</p>
</td></tr>
<tr><td><code id="forward_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="forward_+3A_qe">qe</code></td>
<td>
<p>an optional named vector of background residue frequencies (only
applicable if x is a PHMM). If <code>qe = NULL</code> the function looks for
a qe vector as an attribute of the PHMM. If these are not available
equal background residue frequencies are assumed.</p>
</td></tr>
<tr><td><code id="forward_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td></tr>
<tr><td><code id="forward_+3A_odds">odds</code></td>
<td>
<p>logical, indicates whether the returned scores
should be odds ratios (TRUE) or full logged probabilities (FALSE).</p>
</td></tr>
<tr><td><code id="forward_+3A_windowspace">windowspace</code></td>
<td>
<p>a two-element integer vector providing the search space for
dynamic programming (see Wilbur &amp; Lipman 1983 for details). The first element
should be negative, and represent the lowermost diagonal of the
dynammic programming array, and the second element should be positive,
representing the leftmost diagonal. Alternatively, if the the character
string &quot;all&quot; is passed (the default setting) the entire dynamic programming
array will be computed.</p>
</td></tr>
<tr><td><code id="forward_+3A_di">DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="forward_+3A_id">ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="forward_+3A_cpp">cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for a compiled C++ function that recursively
fills a dynamic programming matrix with logged probabilities, and
calculates the full (logged) probability of a sequence given a HMM or
PHMM.
</p>
<p>For a thorough explanation of the backward, forward and Viterbi
algorithms, see Durbin et al (1998) chapters 3.2 (HMMs) and 5.4 (PHMMs).
</p>


<h3>Value</h3>

<p>an object of class <code>"DPA"</code>, which is a list
containing the score and dynamic programming array.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Wilbur WJ, Lipman DJ (1983) Rapid similarity searches of nucleic acid and
protein data banks. <em>Proc Natl Acad Sci USA</em>, <strong>80</strong>, 726-730.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backward">backward</a></code>, <code><a href="#topic+Viterbi">Viterbi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Forward algorithm for standard HMMs:
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino HMM")
  ### Find full probability of the sequence given the model
  data(casino)
  forward(x, casino)
  ###
  ## Forward algorithm for profile HMMs:
  ## Small globin alignment data from Durbin et al (1998) Figure 5.3
  data(globins)
  ### Derive a profile HMM from the alignment
  globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  plot(globins.PHMM, main = "Profile hidden Markov model for globins")
  ### Simulate a random sequence from the model
  suppressWarnings(RNGversion("3.5.0"))
  set.seed(999)
  simulation &lt;- generate(globins.PHMM, size = 20)
  simulation ## "F" "S" "A" "N" "N" "D" "W" "E"
  ### Calculate the full (log) probability of the sequence given the model
  x &lt;- forward(globins.PHMM, simulation, odds = FALSE)
  x # -23.0586
  ### Show the dynammic programming array
  x$array
</code></pre>

<hr>
<h2 id='generate'>Generate random sequences from a model.</h2><span id='topic+generate'></span><span id='topic+generate.HMM'></span><span id='topic+generate.PHMM'></span>

<h3>Description</h3>

<p>The <code>generate</code> function outputs a random sequence from a HMM or PHMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate(x, size, ...)

## S3 method for class 'HMM'
generate(x, size, logspace = "autodetect", random = TRUE, ...)

## S3 method for class 'PHMM'
generate(
  x,
  size,
  logspace = "autodetect",
  gap = "-",
  random = TRUE,
  DNA = FALSE,
  AA = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_x">x</code></td>
<td>
<p>an object of class <code>'HMM'</code> or <code>'PHMM'</code>.</p>
</td></tr>
<tr><td><code id="generate_+3A_size">size</code></td>
<td>
<p>a non-negative integer representing the length of the output
sequence if x is a <code>"HMM"</code> object with zero probability of
transitioning to the begin/end state, or the maximum length of the
output sequence otherwise (this acts as a safeguard against overflow).</p>
</td></tr>
<tr><td><code id="generate_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="generate_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(the default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td></tr>
<tr><td><code id="generate_+3A_random">random</code></td>
<td>
<p>logical indicating whether residues should be emitted randomly
with probabilities defined by the emission probabilities in the model
(TRUE; default), or deterministically, whereby each residue is emitted
and each transition taken based on the maximum emission/transition
probability in the current state.</p>
</td></tr>
<tr><td><code id="generate_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps (delete states)
in the output sequence (only applicable for <code>PHMM</code> objects).</p>
</td></tr>
<tr><td><code id="generate_+3A_dna">DNA</code></td>
<td>
<p>logical indicating whether the returned sequence should be a
<code>"DNAbin"</code> object. Only applicable if the matrix of emission
probabilities in the model has four residues corresponding to the nucleotide
alphabet (A, T, G, and C).</p>
</td></tr>
<tr><td><code id="generate_+3A_aa">AA</code></td>
<td>
<p>logical indicating whether the returned sequence should be a
<code>"AAbin"</code> object. Only applicable if the matrix of emission
probabilities in the model has 20 residues corresponding to the amino acid
alphabet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple function generates a single sequence
from a HMM or profile HMM by recursively simulating a path through
the model. The function is fairly slow in its current state, but a
faster C++ function may be made available in a future version depending
on demand.
</p>


<h3>Value</h3>

<p>a named vector giving the sequence of residues emitted by the model,
with the &quot;names&quot; attribute representing the hidden states.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Generate a random sequence from a standard HMM
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino HMM")
  ### Generate a random sequence from the model
  generate(x, size = 300)
  ##
  ## Generate a random sequence from a profile HMM:
  ## Small globin alignment data from Durbin et al (1998) Figure 5.3
  data(globins)
  ### Derive a profile hidden Markov model from the alignment
  globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  plot(globins.PHMM, main = "Profile hidden Markov model for globins")
  ### Simulate a random sequence from the model
  suppressWarnings(RNGversion("3.5.0"))
  set.seed(999)
  simulation &lt;- generate(globins.PHMM, size = 20)
  simulation ## "F" "S" "A" "N" "N" "D" "W" "E"
  ### Names attribute indicates that all residues came from "match" states
</code></pre>

<hr>
<h2 id='globins'>Globin protein alignment.</h2><span id='topic+globins'></span>

<h3>Description</h3>

<p>The small globin protein alignment from figure 5.3 of
Durbin et al (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globins
</code></pre>


<h3>Format</h3>

<p>a 7 x 10 character matrix with ten columns of a multiple
alignment of globin amino acid sequences from Durbin et al (1998)
chapter 5.3.
</p>


<h3>Source</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>

<hr>
<h2 id='logsum'>Sum of logged probabilities.</h2><span id='topic+logsum'></span>

<h3>Description</h3>

<p><code>"logsum"</code> takes a vector of logged probabilities (neagtive values)
and returns its sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logsum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logsum_+3A_x">x</code></td>
<td>
<p>a numeric vector of logged probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple compiled function that exponentiates the values
in the input vector, finds their sum, and returns the log of that value.
</p>


<h3>Value</h3>

<p>returns a single numeric value representing the logged sum of the
values in the input vector.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>

<hr>
<h2 id='map'>Optimized profile HMM construction.</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Assigns match and insert states to alignment columns using the maximum
<em>a posteriori</em> algorithm outlined in Durbin et al (1998) chapter 5.7.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(
  x,
  seqweights = NULL,
  residues = NULL,
  gap = "-",
  endchar = "?",
  pseudocounts = "background",
  lambda = 0,
  qa = NULL,
  qe = NULL,
  cpp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_x">x</code></td>
<td>
<p>a matrix of aligned sequences. Accepted modes are &quot;character&quot;
and &quot;raw&quot; (the latter being used for &quot;DNAbin&quot; and &quot;AAbin&quot; objects).</p>
</td></tr>
<tr><td><code id="map_+3A_seqweights">seqweights</code></td>
<td>
<p>either NULL (default; all sequences are given
weights of 1) or a numeric vector the same length as <code>x</code> representing
the sequence weights used to derive the model.</p>
</td></tr>
<tr><td><code id="map_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Furthermore, the default setting
<code>residues = NULL</code> will not detect rare residues that are not present
in the sequences, and thus will not assign them emission probabilities
in the model. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="map_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="map_+3A_endchar">endchar</code></td>
<td>
<p>the character used to represent unknown residues in
the alignment matrix (if applicable). Ignored for <code>"DNAbin"</code> or
<code>"AAbin"</code> objects. Defaults to &quot;?&quot; otherwise.</p>
</td></tr>
<tr><td><code id="map_+3A_pseudocounts">pseudocounts</code></td>
<td>
<p>character string, either &quot;background&quot;, Laplace&quot;
or &quot;none&quot;. Used to account for the possible absence of certain
transition and/or emission types in the input sequences.
If <code>pseudocounts = "background"</code> (default), pseudocounts
are calculated from the background transition and emission
frequencies in the sequences.
If <code>pseudocounts = "Laplace"</code> one of each possible transition
and emission type is added to the transition and emission counts.
If <code>pseudocounts = "none"</code> no pseudocounts are added (not
generally recommended, since low frequency transition/emission types
may be excluded from the model).
Alternatively this argument can be a two-element list containing
a matrix of transition pseudocounts
as its first element and a matrix of emission pseudocounts as its
second.</p>
</td></tr>
<tr><td><code id="map_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter used to favour models with fewer match
states. Equivalent to the log of the prior probability of marking each
column (Durbin et al 1998, chapter 5.7).</p>
</td></tr>
<tr><td><code id="map_+3A_qa">qa</code></td>
<td>
<p>an optional named 9-element vector of background transition
probabilities with <code>dimnames(qa) = c("DD", "DM", "DI", "MD", "MM",
"MI", "ID", "IM", "II")</code>, where M, I and D represent match, insert and
delete states, respectively. If <code>NULL</code>, background transition
probabilities are estimated from the sequences.</p>
</td></tr>
<tr><td><code id="map_+3A_qe">qe</code></td>
<td>
<p>an optional named vector of background emission probabilities
the same length as the residue alphabet (i.e. 4 for nucleotides and 20
for amino acids) and with corresponding names (i.e. <code>c("A", "T",
"G", "C")</code> for DNA). If <code>qe = NULL</code>, background emission probabilities
are automatically derived from the sequences.</p>
</td></tr>
<tr><td><code id="map_+3A_cpp">cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see Durbin et al (1998) chapter 5.7 for details of
the maximum <em>a posteriori</em> algorithm for optial match and insert
state assignment.
</p>


<h3>Value</h3>

<p>a logical vector with length = ncol(x) indicating the columns to be
assigned as match states (<code>TRUE</code>) and those assigned as inserts
(<code>FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivePHMM">derivePHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Maximum a posteriori assignment of match states to the small
## alignment example in Figure 5.3, Durbin et al (1998)
data(globins)
map(globins)
</code></pre>

<hr>
<h2 id='plot.HMM'>Plot standard hidden Markov models.</h2><span id='topic+plot.HMM'></span>

<h3>Description</h3>

<p><code>plot.HMM</code> provides a visual representation of a standard hidden Markov
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMM'
plot(x, just = "center", arrexp = 1, textexp = 1, begin = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.HMM_+3A_x">x</code></td>
<td>
<p>an object of class <code>"HMM"</code>.</p>
</td></tr>
<tr><td><code id="plot.HMM_+3A_just">just</code></td>
<td>
<p>a character string giving the justfication of the plot relative
to the device. Accepted values are &quot;left&quot;, &quot;center&quot; and &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.HMM_+3A_arrexp">arrexp</code></td>
<td>
<p>the expansion factor to be applied to the arrows in the plot.</p>
</td></tr>
<tr><td><code id="plot.HMM_+3A_textexp">textexp</code></td>
<td>
<p>the expansion factor to be applied to the text in the plot.</p>
</td></tr>
<tr><td><code id="plot.HMM_+3A_begin">begin</code></td>
<td>
<p>logical indicating whether the begin/end state should be plotted.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.HMM_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"plot.HMM"</code> Plots a <code>"HMM"</code> object as a directed graph.
States (rectangles) are interconnected by directed
lines with line-weights proportional to the transition probabilities between
the states.
</p>


<h3>Value</h3>

<p>NULL (invisibly).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.PHMM">plot.PHMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## the dishonest casino example from Durbin et al (1998)
  states &lt;- c("Begin", "Fair", "Loaded")
  residues = paste(1:6)
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino hidden Markov model")
</code></pre>

<hr>
<h2 id='plot.PHMM'>Plot profile hidden Markov models.</h2><span id='topic+plot.PHMM'></span>

<h3>Description</h3>

<p><code>plot.PHMM</code> provides a visual representation of a profile hidden
Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PHMM'
plot(
  x,
  from = "start",
  to = "end",
  just = "center",
  arrexp = 1,
  textexp = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PHMM_+3A_x">x</code></td>
<td>
<p>an object of class <code>"PHMM"</code>.</p>
</td></tr>
<tr><td><code id="plot.PHMM_+3A_from">from</code></td>
<td>
<p>an integer giving the module number to start the plot
sequence from. Also accepts the chracter string &quot;start&quot; (module 0; default).</p>
</td></tr>
<tr><td><code id="plot.PHMM_+3A_to">to</code></td>
<td>
<p>an integer giving the module number to terminate the plot sequence.
Also accepts the chracter string &quot;end&quot; (default).</p>
</td></tr>
<tr><td><code id="plot.PHMM_+3A_just">just</code></td>
<td>
<p>a character string giving the justfication of the plot relative
to the device. Accepted values are &quot;left&quot;, &quot;center&quot; and &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.PHMM_+3A_arrexp">arrexp</code></td>
<td>
<p>the expansion factor to be applied to the arrows in the plot.</p>
</td></tr>
<tr><td><code id="plot.PHMM_+3A_textexp">textexp</code></td>
<td>
<p>the expansion factor to be applied to the text in the plot.</p>
</td></tr>
<tr><td><code id="plot.PHMM_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"plot.PHMM"</code> Plots a <code>"PHMM"</code> object as a directed graph
with sequential modules consisting of squares, diamonds and circles
representing match, insert and delete states, respectively.
Modules are interconnected by directed
lines with line-weights proportional to the transition probabilities between
the states. Since the plotted models are generally much longer than they are
high, it is usually better to output the plot to a PDF file as demonstrated
in the example below.
</p>


<h3>Value</h3>

<p>NULL (invisibly).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.HMM">plot.HMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Small globin alignment example from Durbin et al (1998) Figure 5.3
  data(globins)
  ## derive a profile hidden Markov model from the alignment
  globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  ## plot the PHMM
  plot(globins.PHMM, main = "Profile hidden Markov model for globins")
  ##
  ## derive a profile hidden Markov model from the woodmouse dataset in the
  ## ape package
  library(ape)
  data(woodmouse)
  woodmouse.PHMM &lt;- derivePHMM(woodmouse)
  ## plot partial model to viewer device
  plot(woodmouse.PHMM, from = 0, to = 5)
  ## plot the entire model to a PDF in the current working directory
  
  tmpf &lt;- tempfile(fileext = ".pdf")
  nr &lt;- ceiling((woodmouse.PHMM$size + 2)/10)
  pdf(file = tmpf, width = 8.27, height = nr * 2)
  par(mfrow = c(nr, 1), mar = c(0, 0, 0, 0) + 0.1)
  from &lt;- 0
  to &lt;- 10
  for(i in 1:nr){
    plot(woodmouse.PHMM, from = from, to = to, just = "left")
    from &lt;- from + 10
    to &lt;- min(to + 10, woodmouse.PHMM$size + 1)
  }
  dev.off()
  
</code></pre>

<hr>
<h2 id='posterior'>Posterior decoding.</h2><span id='topic+posterior'></span><span id='topic+posterior.HMM'></span><span id='topic+posterior.PHMM'></span>

<h3>Description</h3>

<p>Calculate the posterior probability of a sequence given a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(x, y, ...)

## S3 method for class 'HMM'
posterior(x, y, logspace = "autodetect", cpp = TRUE, ...)

## S3 method for class 'PHMM'
posterior(x, y, logspace = "autodetect", cpp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_+3A_x">x</code></td>
<td>
<p>an object of class <code>'HMM'</code> or <code>'PHMM'</code>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_y">y</code></td>
<td>
<p>a vector of mode &quot;character&quot; or &quot;raw&quot; (a &quot;DNAbin&quot; or &quot;AAbin&quot;
object) representing a single sequence hypothetically emitted by
the model in <code>x</code>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="posterior_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td></tr>
<tr><td><code id="posterior_+3A_cpp">cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The R version is primarily retained for bug-fixing and experimentation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Durbin et al (1998) chapter 3.2 for details on the calculation
and interpretation of posterior state probabilities.
Currently no method is available for profile HMMs, but this may be
included in a future version if required.
</p>


<h3>Value</h3>

<p>a vector, matrix or array of posterior probabilities.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forward">forward</a></code>, <code><a href="#topic+backward">backward</a></code>, <code><a href="#topic+Viterbi">Viterbi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Posterior decoding for standard hidden Markov models
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino HMM")
  ### Calculate posterior probabilities
  data(casino)
  casino.post &lt;- posterior(x, casino)
  plot(1:300, casino.post[1, ], type = "l", xlab = "Roll number",
       ylab = "Posterior probability of dice being fair",
       main = "The dishonest casino")
</code></pre>

<hr>
<h2 id='print'>Print summary methods.</h2><span id='topic+print'></span><span id='topic+print.PHMM'></span><span id='topic+print.HMM'></span><span id='topic+print.DPA'></span>

<h3>Description</h3>

<p>Print summary methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PHMM'
print(x, ...)

## S3 method for class 'HMM'
print(x, ...)

## S3 method for class 'DPA'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>object of various classes.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisibly)
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>

<hr>
<h2 id='readPHMM'>Import profile hidden Markov models into R.</h2><span id='topic+readPHMM'></span>

<h3>Description</h3>

<p>The <code>readPHMM</code> function parses a HMMER3 text file into R and creates
an object of class <code>"PHMM"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readPHMM(file = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readPHMM_+3A_file">file</code></td>
<td>
<p>the name of the file from which to read the model.</p>
</td></tr>
<tr><td><code id="readPHMM_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>"scan"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scans a HMMER3/f text file and creates an object of
class <code>"PHMM"</code> in R. Note that unlike HMMER, the <span class="pkg">aphid</span>
package does not currently support position-specific background
emission probabilities, and so only a single vector the same length
as the reside alphabet is included as an element of the returned
object. Also the function currently only parses the first profile
HMM encountered in the text file, with subsequent models ignored.
</p>


<h3>Value</h3>

<p>an object of class <code>"PHMM"</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Finn RD, Clements J &amp; Eddy SR (2011) HMMER web server: interactive sequence
similarity searching. <em>Nucleic Acids Research</em>. <strong>39</strong>, W29-W37.
<a href="http://hmmer.org/">http://hmmer.org/</a>.
</p>
<p>HMMER: biosequence analysis using profile hidden Markov models.
<a href="http://www.hmmer.org">http://www.hmmer.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writePHMM">writePHMM</a></code> for writing PHMM objects in HMMER3 text format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Derive a profile hidden Markov model from the small globin alignment
  data(globins)
  x &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  fl &lt;- tempfile()
  writePHMM(x, file = fl)
  readPHMM(fl)
</code></pre>

<hr>
<h2 id='substitution'>Substitution matrices.</h2><span id='topic+substitution'></span>

<h3>Description</h3>

<p>A dataset containing several popular substitution scoring matrices
for DNA and amino acids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitution
</code></pre>


<h3>Format</h3>

<p>A list of 71 matrices, most of which have 24 rows and 24 columns
corresponding to the 20-letter amino acid alphabet plus the ambiguity codes B, Z,
X and *:
</p>

<dl>
<dt>PAM</dt><dd><p>the PAM matrices from PAM10 to PAM500.</p>
</dd>
<dt>BLOSUM</dt><dd><p>the BLOSUM matrices from BLOSUM30 to BLOSUM100.</p>
</dd>
<dt>others</dt><dd><p>also included are the DAYHOFF, GONNET, IDENTITY
and MATCH substitution matrices for amino acids,
and the NUC.4.2 and NUC.4.4 substitution matrices for DNA.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="ftp://ftp.ncbi.nih.gov/blast/matrices/">ftp://ftp.ncbi.nih.gov/blast/matrices/</a>
</p>

<hr>
<h2 id='train'>Iterative model refinement.</h2><span id='topic+train'></span><span id='topic+train.PHMM'></span><span id='topic+train.HMM'></span>

<h3>Description</h3>

<p>Update model parameters using a list of training sequences, with either
the Viterbi training or Baum-Welch algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train(x, y, ...)

## S3 method for class 'PHMM'
train(
  x,
  y,
  method = "Viterbi",
  seqweights = "Henikoff",
  wfactor = 1,
  k = 5,
  logspace = "autodetect",
  maxiter = 100,
  limit = 1,
  deltaLL = 1e-07,
  pseudocounts = "background",
  gap = "-",
  fixqa = FALSE,
  fixqe = FALSE,
  maxsize = NULL,
  inserts = "map",
  threshold = 0.5,
  lambda = 0,
  alignment = FALSE,
  cores = 1,
  quiet = FALSE,
  ...
)

## S3 method for class 'HMM'
train(
  x,
  y,
  method = "Viterbi",
  seqweights = NULL,
  wfactor = 1,
  maxiter = 100,
  deltaLL = 1e-07,
  logspace = "autodetect",
  quiet = FALSE,
  modelend = FALSE,
  pseudocounts = "Laplace",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_+3A_x">x</code></td>
<td>
<p>an object of class <code>"HMM"</code> or <code>"PHMM"</code> specifying the
initial parameter values.</p>
</td></tr>
<tr><td><code id="train_+3A_y">y</code></td>
<td>
<p>a list of training sequences whose hidden states are unknown.
Accepted modes are &quot;character&quot; and &quot;raw&quot; (for &quot;DNAbin&quot; and &quot;AAbin&quot;
objects).</p>
</td></tr>
<tr><td><code id="train_+3A_...">...</code></td>
<td>
<p>aditional arguments to be passed to <code>"Viterbi"</code> (if
<code>method = "Viterbi"</code>) or <code>"forward"</code> (if
<code>method = "BaumWelch"</code>).</p>
</td></tr>
<tr><td><code id="train_+3A_method">method</code></td>
<td>
<p>a character string specifying the iterative model training
method to use. Accepted methods are <code>"Viterbi"</code> (the default)
and <code>"BaumWelch"</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_seqweights">seqweights</code></td>
<td>
<p>either NULL (all sequences are given weights
of 1), a numeric vector the same length as <code>y</code> representing
the sequence weights used to derive the model, or a character string giving
the method to derive the weights from the sequences
(see <code><a href="#topic+weight">weight</a></code>).</p>
</td></tr>
<tr><td><code id="train_+3A_wfactor">wfactor</code></td>
<td>
<p>numeric. The factor to multiply the sequence weights by.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="train_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size to be used in tree-based
sequence weighting (if applicable). Defaults to 5. Note that higher
values of k may be slow to compute and use excessive memory due to
the large numbers of calculations required.</p>
</td></tr>
<tr><td><code id="train_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td></tr>
<tr><td><code id="train_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of EM iterations or Viterbi training
iterations to carry out before the cycling process is terminated and
the partially trained model is returned. Defaults to 100.</p>
</td></tr>
<tr><td><code id="train_+3A_limit">limit</code></td>
<td>
<p>the proportion of alignment rows that must be identical
between subsequent iterations for the Viterbi training algorithm
to terminate. Defaults to 1.</p>
</td></tr>
<tr><td><code id="train_+3A_deltall">deltaLL</code></td>
<td>
<p>numeric, the maximum change in log likelihood between EM
iterations before the cycling procedure is terminated (signifying model
convergence). Defaults to 1E-07. Only applicable if
<code>method = "BaumWelch"</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_pseudocounts">pseudocounts</code></td>
<td>
<p>character string, either &quot;background&quot;, Laplace&quot;
or &quot;none&quot;. Used to account for the possible absence of certain
transition and/or emission types in the input sequences.
If <code>pseudocounts = "background"</code> (default), pseudocounts
are calculated from the background transition and emission
frequencies in the training dataset.
If <code>pseudocounts = "Laplace"</code> one of each possible transition
and emission type is added to the training dataset (default).
If <code>pseudocounts = "none"</code> no pseudocounts are added (not
usually recommended, since low frequency transition/emission types
may be excluded from the model).
Alternatively this argument can be a two-element list containing
a matrix of transition pseudocounts
as its first element and a matrix of emission pseudocounts as its
second. If this option is selected, both matrices must have row and column
names corresponding with the residues (column names of emission matrix)
and states (row and column names of the transition matrix and
row names of the emission matrix). For standard HMMs
the first row and column of the transition matrix should be named
&quot;Begin&quot;.</p>
</td></tr>
<tr><td><code id="train_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="train_+3A_fixqa">fixqa</code></td>
<td>
<p>logical. Should the background transition probabilities
be fixed (TRUE), or allowed to vary between iterations (FALSE)?
Defaults to FALSE. Only applicable if <code>method = "Viterbi"</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_fixqe">fixqe</code></td>
<td>
<p>logical. Should the background emission probabilities
be fixed (TRUE), or allowed to vary between iterations (FALSE)?
Defaults to FALSE. Only applicable if <code>method = "Viterbi"</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_maxsize">maxsize</code></td>
<td>
<p>integer giving the upper bound on the number of modules
in the PHMM. If NULL (default) no maximum size is enforced.</p>
</td></tr>
<tr><td><code id="train_+3A_inserts">inserts</code></td>
<td>
<p>character string giving the model construction method
by which alignment columns
are marked as either match or insert states. Accepted methods include
<code>"threshold"</code> (only columns with fewer than a specified
proportion of gaps form match states in the model), <code>"map"</code> (default;
match and insert columns are found using the maximum <em>a posteriori</em>
method outlined in Durbin et al (1998) chapter 5.7), <code>"inherited"</code>
(match and insert columns are inherited from the input alignment),
and <code>"none"</code> (all columns are assigned match states in the model).
Alternatively, insert columns can be
specified manually by providing a logical vector the same length
as the number of columns in the alignment, with <code>TRUE</code> for insert
columns and <code>FALSE</code> for match states.</p>
</td></tr>
<tr><td><code id="train_+3A_threshold">threshold</code></td>
<td>
<p>the maximum proportion of gaps for an alignment column
to be considered for a match state in the PHMM (defaults to 0.5).
Only applicable when <code>inserts = "threshold"</code>.
Note that the maximum <em>a posteriori</em>
method works poorly for alignments with few sequences,
so the 'threshold' method is
automatically used when the number of sequences is less than 5.</p>
</td></tr>
<tr><td><code id="train_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter used to favour models with fewer match
states. Equivalent to the log of the prior probability of marking each
column (Durbin et al 1998, chapter 5.7). Only applicable when
<code>inserts = "map"</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_alignment">alignment</code></td>
<td>
<p>logical indicating whether the alignment used to
derive the final model (if applicable) should be included as an element of
the returned PHMM object. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="train_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of CPUs to parallelize the operation
over. Defaults to 1, and reverts to 1 if x is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string &quot;autodetect&quot; is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores
available. Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be aligned, due to the extra time required to initialize
the cluster.
Only applicable if x is an object of class <code>"PHMM"</code>.</p>
</td></tr>
<tr><td><code id="train_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether feedback should be printed
to the console.</p>
</td></tr>
<tr><td><code id="train_+3A_modelend">modelend</code></td>
<td>
<p>logical indicating whether transition probabilites
to the end state of the standard hidden Markov model should be
modeled (if applicable). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimizes the parameters of a hidden Markov model
(object class: <code>"HMM"</code>) or profile hidden Markov model
(object class: <code>"PHMM"</code>) using the methods described in
Durbin et al (1998) chapters 3.3 and 6.5, respectively.
For standard HMMs, the function assumes the state sequence is unknown
(as opposed to the <code><a href="#topic+deriveHMM">deriveHMM</a></code> function, which is used
when the state sequence is known).
For profile HMMs, the input object is generally a list of non-aligned
sequences rather than an alignment (for which the <code><a href="#topic+derivePHMM">derivePHMM</a></code>
function may be more suitable).
</p>
<p>This function offers a choice of two model training methods,
Viterbi training (also known as the segmental
K-means algorithm (Juang &amp; Rabiner 1990)), and the Baum Welch algorithm,
a special case of the expectation-maximization (EM) algorithm that
iteratively finds the locally (but not necessarily globally) optimal
parameters of a HMM or PHMM.
</p>
<p>The Viterbi training method is generally much faster, particularly for
profile HMMs and when the multi-threading option is used
(see the <code>"cores"</code> argument). The comparison in accuracy will depend
on the nature of the problem, but personal experience suggests that
the methods are comparable for training profile HMMs for DNA and
amino acid sequences.
</p>


<h3>Value</h3>

<p>an object of class <code>"HMM"</code> or <code>"PHMM"</code>, depending
on the input model <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Juang B-H, Rabiner LR (1990) The segmental K-means
algorithm for estimating parameters of hidden Markov models.
<em>IEEE Transactions on Acoustics, Speech, and Signal Processing</em>,
<strong>38</strong>, 1639-1641.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deriveHMM">deriveHMM</a></code> and <code><a href="#topic+derivePHMM">derivePHMM</a></code> for
maximum-likelihood parameter estimation when the training sequence states
are known.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Baum Welch training for standard HMMs:
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  op &lt;- par(no.readonly = TRUE)
  par(mfrow = c(2, 1))
  plot(x, main = "Dishonest casino HMM before training")
  data(casino)
  x &lt;- train(x, list(casino), method = "BaumWelch", deltaLL = 0.001)
  plot(x, main = "Dishonest casino HMM after training")
  par(op)
</code></pre>

<hr>
<h2 id='unalign'>Deconstruct an alignment.</h2><span id='topic+unalign'></span>

<h3>Description</h3>

<p><code>unalign</code> deconstructs an alignment to a list of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unalign(x, gap = "-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unalign_+3A_x">x</code></td>
<td>
<p>a matrix of aligned sequences. Accepted modes are &quot;character&quot;
and &quot;raw&quot; (for &quot;DNAbin&quot; and &quot;AAbin&quot; objects).</p>
</td></tr>
<tr><td><code id="unalign_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix.
Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects. Defaults to &quot;-&quot;
otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unalign</code> works in the opposite way to <code><a href="#topic+align">align</a></code>,
reducing a matrix of aligned sequences to a list of sequences without gaps.
&quot;DNAbin&quot; and &quot;AAbin&quot; matrix objects are supported (and recommended for
biological sequence data)
</p>


<h3>Value</h3>

<p>a list of sequences of the same mode and class as the input alignment
(ie &quot;DNAbin&quot;, &quot;AAbin&quot;, or plain ASCII characters).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+align">align</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Convert the woodmouse alignment in the ape package to a list of
## unaligned sequences
library(ape)
data(woodmouse)
x &lt;- unalign(woodmouse)
</code></pre>

<hr>
<h2 id='Viterbi'>The Viterbi algorithm.</h2><span id='topic+Viterbi'></span><span id='topic+Viterbi.PHMM'></span><span id='topic+Viterbi.HMM'></span><span id='topic+Viterbi.default'></span>

<h3>Description</h3>

<p>The <code>Viterbi</code> function finds the optimal path of a sequence through a HMM
or PHMM and returns its full (log) probability or log-odds score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Viterbi(x, y, ...)

## S3 method for class 'PHMM'
Viterbi(
  x,
  y,
  qe = NULL,
  logspace = "autodetect",
  type = "global",
  odds = TRUE,
  offset = 0,
  windowspace = "all",
  DI = FALSE,
  ID = FALSE,
  cpp = TRUE,
  ...
)

## S3 method for class 'HMM'
Viterbi(x, y, logspace = "autodetect", cpp = TRUE, ...)

## Default S3 method:
Viterbi(
  x,
  y,
  type = "global",
  d = 8,
  e = 2,
  residues = NULL,
  S = NULL,
  windowspace = "all",
  offset = 0,
  cpp = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Viterbi_+3A_x">x</code></td>
<td>
<p>an object of class <code>HMM</code> or <code>PHMM</code>. Optionally, both x and
y can be sequences (character vectors or DNAbin/AAbin objects), in which
case the operation becomes either the Needleman-Wunch (global algnment) or
Smith-Waterman (local alignment) algorithm.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_y">y</code></td>
<td>
<p>a vector of mode &quot;character&quot; or &quot;raw&quot; (a &quot;DNAbin&quot; or &quot;AAbin&quot;
object) representing a single sequence hypothetically emitted by
the model in <code>x</code>. Optionally, both x and
y can be profile hidden Markov models (object class &quot;PHMM&quot;), in which
case the sum of log-odds algorithm of Soding (2005) is used.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_qe">qe</code></td>
<td>
<p>an optional named vector of background residue frequencies (only
applicable if x is a PHMM). If <code>qe = NULL</code> the function looks for
a qe vector as an attribute of the PHMM. If these are not available
equal background residue frequencies are assumed.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_logspace">logspace</code></td>
<td>
<p>logical indicating whether the emission and transition
probabilities of x are logged. If <code>logspace = "autodetect"</code>
(default setting), the function will automatically detect
if the probabilities are logged, returning an error if
inconsistencies are found. Note that choosing the latter option
increases the computational overhead; therefore specifying
<code>TRUE</code> or <code>FALSE</code> can reduce the running time.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_type">type</code></td>
<td>
<p>character string indicating whether insert and delete states
at the beginning and end of the path should count towards the final score
('global'; default), or not ('semiglobal'), or whether the highest scoring
sub-path should be returned ('local').</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_odds">odds</code></td>
<td>
<p>logical, indicates whether the returned scores
should be odds ratios (TRUE) or full logged probabilities (FALSE).</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_offset">offset</code></td>
<td>
<p>column score offset to specify level of greediness. Defaults to
-0.1 bits for PHMM x PHMM alignments (as recommended by Soding (2005)), and 0
otherwise.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_windowspace">windowspace</code></td>
<td>
<p>a two-element integer vector providing the search space for
dynamic programming (see Wilbur &amp; Lipman 1983 for details). The first element
should be negative, and represent the lowermost diagonal of the
dynammic programming array, and the second element should be positive,
representing the leftmost diagonal. Alternatively, if the the character
string &quot;all&quot; is passed (the default setting) the entire dynamic programming
array will be computed.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_di">DI</code></td>
<td>
<p>logical indicating whether delete-insert transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_id">ID</code></td>
<td>
<p>logical indicating whether insert-delete transitions should be
allowed in the profile hidden Markov model (if applicable). Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_cpp">cpp</code></td>
<td>
<p>logical, indicates whether the dynamic programming matrix
should be filled using compiled C++ functions (default; many times faster).
The FALSE option is primarily retained for bug fixing and experimentation.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_d">d</code></td>
<td>
<p>gap opening penalty (in bits) for sequence vs. sequence alignment.
Defaults to 8.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_e">e</code></td>
<td>
<p>gap extension penalty (in bits) for sequence vs. sequence alignment.
Defaults to 2.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors.</p>
</td></tr>
<tr><td><code id="Viterbi_+3A_s">S</code></td>
<td>
<p>an optional scoring matrix with rows and columns named according
to the residue alphabet. Only applicable when both x and y are sequences
(Needleman-Wunch or Smith-Waterman alignments).
Note that for Smith-Waterman local alignments, scores for
mismatches should generally take negative values to avoid spurious
alignments. If NULL default settings are used. Default scoring matrices are
'NUC.4.4' for For DNAbin objects, and 'MATCH' (matches are scored 1 and
mismatches are scored -1) for AAbin objects and character sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for a compiled C++ function that recursively
fills a dynamic programming matrix with probabilities, and
calculates the (logged) probability and optimal path of a sequence
through a HMM or PHMM.
</p>
<p>If x is a PHMM and y is a sequence, the path is represented as
an integer vector containing zeros, ones and twos, where a zero represents
a downward transition, a one represents a diagonal transition downwards and
left, and a two represents a left transition in the dynamic programming
matrix (see Durbin et al (1998) chapter 2.3). This translates to
0 = delete state, 1 = match state and 2 = insert state.
</p>
<p>If x and y are both sequences, the function implements the
Needleman-Wunch or Smith Waterman algorithm depending on
the type of alignment specified. In this case, a zero
in the path refers to x aligning to a gap in y, a one refers
to a match, and a two refers to y aligning to a gap in x.
</p>
<p>If x is a standard hidden Markov model (HMM) and y is a sequence,
each integer in the path represents a state in the model.
Note that the path elements can take values between 0 and
one less than number of states, as in the C/C++ indexing
style rather than R's.
</p>
<p>For a thorough explanation of the backward, forward and Viterbi
algorithms, see Durbin et al (1998) chapters 3.2 (HMMs) and 5.4 (PHMMs).
</p>


<h3>Value</h3>

<p>an object of class <code>"DPA"</code>, which is a list including the
score, the dynammic programming array, and the optimal path (an integer
vector, see details section).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Soding J (2005) Protein homology detection by HMM-HMM comparison.
<em>Bioinformatics</em>, <strong>21</strong>, 951-960.
</p>
<p>Wilbur WJ, Lipman DJ (1983) Rapid similarity searches of nucleic acid and
protein data banks. <em>Proc Natl Acad Sci USA</em>, <strong>80</strong>, 726-730.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backward">backward</a></code>, <code><a href="#topic+forward">forward</a></code>, <code><a href="#topic+align">align</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Viterbi algorithm for standard HMMs:
  ## The dishonest casino example from Durbin et al (1998) chapter 3.2
  states &lt;- c("Begin", "Fair", "Loaded")
  residues &lt;- paste(1:6)
  ### Define the transition probability matrix
  A &lt;- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
  dimnames(A) &lt;- list(from = states, to = states)
  ### Define the emission probability matrix
  E &lt;- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
  dimnames(E) &lt;- list(states = states[-1], residues = residues)
  ### Build and plot the HMM object
  x &lt;- structure(list(A = A, E = E), class = "HMM")
  plot(x, main = "Dishonest casino HMM")
  ### Find optimal path of sequence
  data(casino)
  casino.DPA &lt;- Viterbi(x, casino)
  casino.DPA$score # full (log) prob of sequence given model = -538.8109
  ### Show optinal path path as indices
  casino.DPA$path
  ### Show optimal path as character strings
  rownames(x$E)[casino.DPA$path + 1]
  ##
  ## Needleman-Wunch pairwise sequence alignment:
  ## Pairwise protein alignment example from Durbin et al (1998) chapter 2.3
  x &lt;- c("H", "E", "A", "G", "A", "W", "G", "H", "E", "E")
  y &lt;- c("P", "A", "W", "H", "E", "A", "E")
  Viterbi(x, y,  d = 8, e = 2, type = "global")
  ###
  ## Viterbi algorithm for profile HMMs:
  ## Small globin alignment data from Durbin et al (1998) Figure 5.3
  data(globins)
  ### Derive a profile hidden Markov model from the alignment
  globins.PHMM &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  plot(globins.PHMM, main = "Profile hidden Markov model for globins")
  ### Simulate a random sequence from the model
  suppressWarnings(RNGversion("3.5.0"))
  set.seed(999)
  simulation &lt;- generate(globins.PHMM, size = 20)
  simulation ## "F" "S" "A" "N" "N" "D" "W" "E"
  ### Calculate the odds of the optimal path of the sequence given the model
  x &lt;- Viterbi(globins.PHMM, simulation, odds = FALSE)
  x # -23.07173
  ### Show dynammic programming array
  x$array
  ### Show the optimal path as an integer vector
  x$path
  ### Show the optimal path as either delete states, matches or insert states
  c("D", "M", "I")[x$path + 1]
  ### Correctly predicted the actual path:
  names(simulation)
</code></pre>

<hr>
<h2 id='weight'>Sequence weighting.</h2><span id='topic+weight'></span><span id='topic+weight.DNAbin'></span><span id='topic+weight.AAbin'></span><span id='topic+weight.list'></span><span id='topic+weight.dendrogram'></span><span id='topic+weight.default'></span>

<h3>Description</h3>

<p>Weighting schemes for DNA and amino acid sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight(x, ...)

## S3 method for class 'DNAbin'
weight(x, method = "Henikoff", k = 5, ...)

## S3 method for class 'AAbin'
weight(x, method = "Henikoff", k = 5, ...)

## S3 method for class 'list'
weight(x, method = "Henikoff", k = 5, residues = NULL, gap = "-", ...)

## S3 method for class 'dendrogram'
weight(x, method = "Gerstein", ...)

## Default S3 method:
weight(x, method = "Henikoff", k = 5, residues = NULL, gap = "-", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_+3A_x">x</code></td>
<td>
<p>a list or matrix of sequences
(usually a &quot;DNAbin&quot; or &quot;AAbin&quot; object).
Alternatively x can be an object of class <code>"dendrogram"</code>
for tree-base weighting.</p>
</td></tr>
<tr><td><code id="weight_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="weight_+3A_method">method</code></td>
<td>
<p>a character string indicating the weighting method to be used.
Currently the only methods available are a modified version of the
maximum entropy weighting scheme proposed by
Henikoff and Henikoff (1994) (<code>method = "Henikoff"</code>)
and the tree-based weighting scheme of Gerstein et al (1994)
(<code>method = "Gerstein"</code>).</p>
</td></tr>
<tr><td><code id="weight_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size to be used.
Defaults to 5. Note that higher
values of k may be slow to compute and use excessive memory due to
the large numbers of calculations required.</p>
</td></tr>
<tr><td><code id="weight_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Furthermore, the default setting
<code>residues = NULL</code> will not detect rare residues that are not present
in the sequences, and thus will not assign them emission probabilities
in the model. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="weight_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
If <code>method = "Henikoff"</code> the sequences are weighted
using a modified version of the maximum entropy method proposed by
Henikoff and Henikoff (1994). In this case the
maximum entropy weights are calculated from a k-mer presence absence
matrix instead of an alignment as originally described by
Henikoff and Henikoff (1994).
If <code>method = "Gerstein"</code> the agglomerative method of
Gerstein et al (1994) is used to weight sequences based
on their relatedness as derived from a phylogenetic tree.
In this case a dendrogram is first derived using the
<code><a href="kmer.html#topic+cluster">cluster</a></code> function in the
<code><a href="kmer.html#topic+kmer">kmer</a></code> package.
Methods are available for
<code>"dendrogram"</code> objects, <code>"DNAbin"</code> and <code>"AAbin"</code>
sequence objects (as lists or matrices) and sequences in standard
character format provided either as lists or matrices.
</p>
<p>For further details on sequence weighting schemes see Durbin et al
(1998) chapter 5.8.
</p>


<h3>Value</h3>

<p>a named vector of weights, the sum of which is equal to
the total number of sequences (average weight = 1).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Gerstein M, Sonnhammer ELL, Chothia C (1994) Volume changes in protein evolution.
<em>Journal of Molecular Biology</em>, <strong>236</strong>, 1067-1078.
</p>
<p>Henikoff S, Henikoff JG (1994) Position-based sequence weights.
<em>Journal of Molecular Biology</em>, <strong>243</strong>, 574-578.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## weight the sequences in the woodmouse dataset from the ape package
  library(ape)
  data(woodmouse)
  woodmouse.weights &lt;- weight(woodmouse)
  woodmouse.weights
</code></pre>

<hr>
<h2 id='writePHMM'>Export profile hidden Markov models as text.</h2><span id='topic+writePHMM'></span>

<h3>Description</h3>

<p><code>writePHMM</code> takes an object of class <code>"PHMM"</code> and writes it to a
text file in HMMER3 format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writePHMM(x, file = "", append = FALSE, form = "HMMER3", vers = "f")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writePHMM_+3A_x">x</code></td>
<td>
<p>an object of class <code>"PHMM"</code>.</p>
</td></tr>
<tr><td><code id="writePHMM_+3A_file">file</code></td>
<td>
<p>the name of the file to write the model to.</p>
</td></tr>
<tr><td><code id="writePHMM_+3A_append">append</code></td>
<td>
<p>logical indicating whether the model text should be appended
below any existing text in the output file, or whether any existing text
should be overwritten. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="writePHMM_+3A_form">form</code></td>
<td>
<p>character string indicating the format in which to write the model.
Currently only HMMER3f is supported.</p>
</td></tr>
<tr><td><code id="writePHMM_+3A_vers">vers</code></td>
<td>
<p>character string indicating the version of version of the format
in which to write the model. Currently only &quot;f&quot; is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function writes an object of class <code>"PHMM"</code> to a
HMMER3/f text file. Note that unlike HMMER, the <span class="pkg">aphid</span>
package does not currently support position-specific background
emission probabilities.
</p>


<h3>Value</h3>

<p>NULL (invisibly)
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Finn, RD, Clements J &amp; Eddy SR (2011) HMMER web server: interactive sequence
similarity searching. <em>Nucleic Acids Research</em>. <strong>39</strong> W29-W37.
<a href="http://hmmer.org/">http://hmmer.org/</a>.
</p>
<p>HMMER: biosequence analysis using profile hidden Markov models.
<a href="http://www.hmmer.org">http://www.hmmer.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readPHMM">readPHMM</a></code> to parse a PHMM object from a HMMER3 text file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Derive a profile hidden Markov model from the small globin alignment
  data(globins)
  x &lt;- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
  x
  fl &lt;- tempfile()
  writePHMM(x, file = fl)
  readPHMM(fl)
  ##
  ## Derive a PHMM for the woodmouse data and write to file
  
    library(ape)
    data(woodmouse)
    woodmouse.PHMM &lt;- derivePHMM(woodmouse)
    tmpf &lt;- tempfile(fileext = ".hmm")
    writePHMM(woodmouse.PHMM, file = tmpf)
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
