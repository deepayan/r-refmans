<!DOCTYPE html><html lang="en"><head><title>Help for package qvirus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qvirus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qvirus-package'><p>qvirus: Quantum Computing for Analyzing CD4 Lymphocytes and Antiretroviral Therapy</p></a></li>
<li><a href='#cd_3'><p>Longitudinal CD4 Lymphocyte Counts for HIV Patients (2018-2024)</p></a></li>
<li><a href='#complex_check'><p>Check if Coefficients of a Qubit State Object are Complex Numbers</p></a></li>
<li><a href='#conjugate_transpose'><p>Calculate the Conjugate Transpose of a Quantum State</p></a></li>
<li><a href='#create_interactions'><p>Create Interactions from CD4 and Viral Load Data</p></a></li>
<li><a href='#estimate_payoffs'><p>Estimate Payoff Parameters for HIV Phenotype Interactions</p></a></li>
<li><a href='#InteractionClassification'><p>Interaction Classification for Viral Load and CD4 Differences</p></a></li>
<li><a href='#mse'><p>Mean Squared Errors for Interaction Classification</p></a></li>
<li><a href='#mse.InteractionClassification'><p>Mean Squared Errors method for the InteractionClassification class</p></a></li>
<li><a href='#nearest_payoff'><p>Find Nearest Payoff</p></a></li>
<li><a href='#normalize_check'><p>Normalize Check Function for qstate Class Object</p></a></li>
<li><a href='#payoffs_list'><p>Generate Payoff List Based on Quantum Gates and Parameters</p></a></li>
<li><a href='#phen_hiv'><p>Calculate Final State and Payoffs in Quantum Game</p></a></li>
<li><a href='#plot.interaction'><p>Plot Interaction Differences</p></a></li>
<li><a href='#plot.InteractionClassification'><p>Plot InteractionClassification Clusters</p></a></li>
<li><a href='#print.interaction'><p>Print Summary of CD4 and Viral Load Differences</p></a></li>
<li><a href='#print.InteractionClassification'><p>Print Method for InteractionClassification Objects</p></a></li>
<li><a href='#pure_qubit1'><p>Create a normalized pure quantum state for a 1-qubit system.</p></a></li>
<li><a href='#pure_qubit2'><p>Create a normalized pure quantum state for a 2-qubit system.</p></a></li>
<li><a href='#simulate_entanglement'><p>Simulate Entanglement Evolution</p></a></li>
<li><a href='#six_state'><p>Create Six Important States on the Bloch Sphere</p></a></li>
<li><a href='#summary.interaction'><p>Summary Method for Interaction Class Objects</p></a></li>
<li><a href='#summary.InteractionClassification'><p>Summarize Interaction Classification Results</p></a></li>
<li><a href='#summary.payoffs'><p>Summarize Payoffs</p></a></li>
<li><a href='#vl_3'><p>Longitudinal Viral Load Values for HIV Patients (2018-2024)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Quantum Computing for Analyzing CD4 Lymphocytes and
Antiretroviral Therapy</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Resources, tutorials, and code snippets dedicated to exploring the intersection of quantum computing and artificial intelligence (AI) in the context of analyzing Cluster of Differentiation 4 (CD4) lymphocytes and optimizing antiretroviral therapy (ART) for human immunodeficiency virus (HIV). With the emergence of quantum artificial intelligence and the development of small-scale quantum computers, there's an unprecedented opportunity to revolutionize the understanding of HIV dynamics and treatment strategies. This project leverages the R package 'qsimulatR' (Ostmeyer and Urbach, 2023, <a href="https://CRAN.R-project.org/package=qsimulatR">https://CRAN.R-project.org/package=qsimulatR</a>), a quantum computer simulator, to explore these applications in quantum computing techniques, addressing the challenges in studying CD4 lymphocytes and enhancing ART efficacy.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>baguette, bookdown, earth, kknn, knitr, qsimulatR, rmarkdown,
rules, testthat (&ge; 3.0.0), vdiffr, viralmodels, yardstick</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/juanv66x/qvirus">https://github.com/juanv66x/qvirus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/juanv66x/qvirus/issues">https://github.com/juanv66x/qvirus/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, factoextra, ggplot2, gridExtra, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-26 21:07:27 UTC; jp</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Pablo Acuña González
    <a href="https://orcid.org/0009-0003-6029-6560"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Pablo Acuña González &lt;acua6307@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-26 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qvirus-package'>qvirus: Quantum Computing for Analyzing CD4 Lymphocytes and Antiretroviral Therapy</h2><span id='topic+qvirus'></span><span id='topic+qvirus-package'></span>

<h3>Description</h3>

<p>Resources, tutorials, and code snippets dedicated to exploring the intersection of quantum computing and artificial intelligence (AI) in the context of analyzing Cluster of Differentiation 4 (CD4) lymphocytes and optimizing antiretroviral therapy (ART) for human immunodeficiency virus (HIV). With the emergence of quantum artificial intelligence and the development of small-scale quantum computers, there's an unprecedented opportunity to revolutionize the understanding of HIV dynamics and treatment strategies. This project leverages the R package 'qsimulatR' (Ostmeyer and Urbach, 2023, <a href="https://CRAN.R-project.org/package=qsimulatR">https://CRAN.R-project.org/package=qsimulatR</a>), a quantum computer simulator, to explore these applications in quantum computing techniques, addressing the challenges in studying CD4 lymphocytes and enhancing ART efficacy.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Juan Pablo Acuña González <a href="mailto:acua6307@gmail.com">acua6307@gmail.com</a> (<a href="https://orcid.org/0009-0003-6029-6560">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/juanv66x/qvirus">https://github.com/juanv66x/qvirus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/juanv66x/qvirus/issues">https://github.com/juanv66x/qvirus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cd_3'>Longitudinal CD4 Lymphocyte Counts for HIV Patients (2018-2024)</h2><span id='topic+cd_3'></span>

<h3>Description</h3>

<p>Contains longitudinal measurements of CD4 lymphocyte counts for
176 patients living with HIV, recorded over the period from 2018 to 2024.
CD4 counts are a critical indicator of immune function, used to monitor the
progression of HIV and the effectiveness of treatments. Measurements were
taken at various points throughout the study, with some missing values due
to unavailable data for specific patients at certain times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cd_3
</code></pre>


<h3>Format</h3>

<p>A data frame with 176 rows and 18 variables:
</p>

<dl>
<dt>ID</dt><dd><p>Unique identifier for each patient.</p>
</dd>
<dt>cd_2018_1</dt><dd><p>CD4 count for the first measurement in 2018.</p>
</dd>
<dt>cd_2018_2</dt><dd><p>CD4 count for the second measurement in 2018.</p>
</dd>
<dt>cd_2019_1</dt><dd><p>CD4 count for the first measurement in 2019.</p>
</dd>
<dt>cd_2019_2</dt><dd><p>CD4 count for the second measurement in 2019.</p>
</dd>
<dt>cd_2020_1</dt><dd><p>CD4 count for the first measurement in 2020.</p>
</dd>
<dt>cd_2021_1</dt><dd><p>CD4 count for the first measurement in 2021.</p>
</dd>
<dt>cd_2021_2</dt><dd><p>CD4 count for the second measurement in 2021.</p>
</dd>
<dt>cd_2021_3</dt><dd><p>CD4 count for the third measurement in 2021.</p>
</dd>
<dt>cd_2022_1</dt><dd><p>CD4 count for the first measurement in 2022.</p>
</dd>
<dt>cd_2022_2</dt><dd><p>CD4 count for the second measurement in 2022.</p>
</dd>
<dt>cd_2022_3</dt><dd><p>CD4 count for the third measurement in 2022.</p>
</dd>
<dt>cd_2023_1</dt><dd><p>CD4 count for the first measurement in 2023.</p>
</dd>
<dt>cd_2023_2</dt><dd><p>CD4 count for the second measurement in 2023.</p>
</dd>
<dt>cd_2023_3</dt><dd><p>CD4 count for the third measurement in 2023.</p>
</dd>
<dt>cd_2024_1</dt><dd><p>CD4 count for the first measurement in 2024.</p>
</dd>
<dt>cd_2024_2</dt><dd><p>CD4 count for the second measurement in 2024.</p>
</dd>
<dt>cd_2024_3</dt><dd><p>CD4 count for the third measurement in 2024.</p>
</dd>
</dl>



<h3>Details</h3>

<p>.
CD4 counts are used to monitor immune system health in individuals with
HIV. A lower CD4 count often indicates a weakened immune system, whereas
higher counts suggest a stronger immune response. Some values are missing,
indicating no measurement was taken for a particular patient at that time.
</p>


<h3>Source</h3>

<p>Clinical data from Hospital Vicente Guerrero, IMSS, HIV Clinic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the dataset
data(cd_3)

# Summarize CD4 counts for the year 2021
summary(cd_3[, c("cd_2021_1", "cd_2021_2", "cd_2021_3")])

</code></pre>

<hr>
<h2 id='complex_check'>Check if Coefficients of a Qubit State Object are Complex Numbers</h2><span id='topic+complex_check'></span>

<h3>Description</h3>

<p>This function returns the class of the coefficients of a given qubit state object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complex_check(qstate_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complex_check_+3A_qstate_obj">qstate_obj</code></td>
<td>
<p>A qubit state object created using the qsimulatR package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients class of given qubit state object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
ket1 &lt;- qstate(nbits = 1, coefs = c(0, 1))
complex_check(ket1)
</code></pre>

<hr>
<h2 id='conjugate_transpose'>Calculate the Conjugate Transpose of a Quantum State</h2><span id='topic+conjugate_transpose'></span>

<h3>Description</h3>

<p>This function calculates the conjugate transpose of a given quantum state represented by a qstate object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjugate_transpose(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conjugate_transpose_+3A_state">state</code></td>
<td>
<p>A qstate object for which the conjugate transpose is to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conjugate transpose of the input quantum state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
library(qvirus)
# Calculate the conjugate transpose of ket0
state &lt;- six_state(1)[[1]]
conjugate_transpose(state)
</code></pre>

<hr>
<h2 id='create_interactions'>Create Interactions from CD4 and Viral Load Data</h2><span id='topic+create_interactions'></span>

<h3>Description</h3>

<p>This function computes the differences in CD4 counts and viral load from the provided datasets.
It returns standardized values and logs transformed viral loads, enabling interaction analysis
for further modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_interactions(cd_data, vl_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_interactions_+3A_cd_data">cd_data</code></td>
<td>
<p>A data frame containing CD4 counts. Each row should represent an individual,
and each column should represent a different time point or measurement.</p>
</td></tr>
<tr><td><code id="create_interactions_+3A_vl_data">vl_data</code></td>
<td>
<p>A data frame containing viral load measurements. It should have the same
structure as <code>cd_data</code>, with rows for individuals and columns for time points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;interaction&quot; containing:
</p>

<dl>
<dt>cd_diff</dt><dd><p>A numeric vector of CD4 differences computed from the input <code>cd_data</code>.</p>
</dd>
<dt>cds_diff</dt><dd><p>A numeric vector of standardized CD4 differences.</p>
</dd>
<dt>vl_diff</dt><dd><p>A numeric vector of viral load differences computed from the input <code>vl_data</code>.</p>
</dd>
<dt>vlog_diff</dt><dd><p>A numeric vector of log-transformed viral load differences.</p>
</dd>
<dt>vlogs_diff</dt><dd><p>A numeric vector of standardized log-transformed viral load differences.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example data frames for CD4 counts and viral loads
data(cd_3)
data(vl_3)

# Create interactions
create_interactions(cd_3[, -1], vl_3[, -1])
</code></pre>

<hr>
<h2 id='estimate_payoffs'>Estimate Payoff Parameters for HIV Phenotype Interactions</h2><span id='topic+estimate_payoffs'></span>

<h3>Description</h3>

<p>This function estimates the payoff parameters for HIV phenotype interactions
based on the provided classification object and predictions from a viral
load model. It calculates the mean differences in viral loads and CD4 counts,
as well as the average payoffs for each classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_payoffs(class_obj, predictions_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_payoffs_+3A_class_obj">class_obj</code></td>
<td>
<p>An object of class <code>InteractionClassification</code> containing
the data on viral load differences and CD4 counts.</p>
</td></tr>
<tr><td><code id="estimate_payoffs_+3A_predictions_df">predictions_df</code></td>
<td>
<p>A data frame containing predictions of viral loads,
with a column named <code>predictions</code>. This data frame should align with the
classifications in <code>class_obj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A payoffs object containing the estimated payoff parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)
library(earth)
library(baguette)
library(rules)
library(kknn)
library(viralmodels)
# Load required data
data(vl_3)
data(cd_3)

# Create interaction object and classification
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)

# Prepare predictions
traindata &lt;- interaction_obj[c(2, 5)] |&gt; as_tibble()
target &lt;- "vlogs_diff"
predictions_df &lt;- viralpreds(target, 2, 1, 2, 123, traindata)

# Estimate payoffs
payoffs_results &lt;- estimate_payoffs(class_obj, predictions_df)

## End(Not run)
</code></pre>

<hr>
<h2 id='InteractionClassification'>Interaction Classification for Viral Load and CD4 Differences</h2><span id='topic+InteractionClassification'></span>

<h3>Description</h3>

<p>This function performs k-means clustering on viral load and CD4 count
differences to classify interactions into distinct groups. It returns
an S3 object containing the clustering results and means for each
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InteractionClassification(vl_diff, cd_diff, k = 4, ns = 100, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InteractionClassification_+3A_vl_diff">vl_diff</code></td>
<td>
<p>A numeric vector of viral load differences.</p>
</td></tr>
<tr><td><code id="InteractionClassification_+3A_cd_diff">cd_diff</code></td>
<td>
<p>A numeric vector of CD4 count differences.</p>
</td></tr>
<tr><td><code id="InteractionClassification_+3A_k">k</code></td>
<td>
<p>An integer specifying the number of clusters (default is 4).</p>
</td></tr>
<tr><td><code id="InteractionClassification_+3A_ns">ns</code></td>
<td>
<p>An integer specifying the number of random starts for the
k-means algorithm (default is 100).</p>
</td></tr>
<tr><td><code id="InteractionClassification_+3A_seed">seed</code></td>
<td>
<p>An integer seed for reproducibility of the clustering
results (default is 123).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class <code>InteractionClassification</code>, containing:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>A data frame with the original differences and their
corresponding cluster classifications.</p>
</td></tr>
<tr><td><code>kmeans_result</code></td>
<td>
<p>The result of the k-means clustering, including
cluster centers and within-cluster sum of squares.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>A matrix of the cluster centers.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The number of clusters used in the clustering.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(vl_3)
data(cd_3)
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)
</code></pre>

<hr>
<h2 id='mse'>Mean Squared Errors for Interaction Classification</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>Mean squared errors (MSE) for viral load differences
and CD4 count differences by comparing the actual values with the group means
from the classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mse_+3A_object">object</code></td>
<td>
<p>An object of class <code>InteractionClassification</code> containing
the classified data and clustering results.</p>
</td></tr>
<tr><td><code id="mse_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the MSE for viral load differences
(<code>vlogs_mse</code>) and CD4 count differences (<code>cds_mse</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vl_3)
data(cd_3)
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)
mse(class_obj)

</code></pre>

<hr>
<h2 id='mse.InteractionClassification'>Mean Squared Errors method for the InteractionClassification class</h2><span id='topic+mse.InteractionClassification'></span>

<h3>Description</h3>

<p>This method computes the mean squared errors (MSE) for viral load and CD4 differences
based on the classification results from an InteractionClassification object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InteractionClassification'
mse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mse.InteractionClassification_+3A_object">object</code></td>
<td>
<p>An object of class <code>InteractionClassification</code>.</p>
</td></tr>
<tr><td><code id="mse.InteractionClassification_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently not used).</p>
</td></tr>
</table>

<hr>
<h2 id='nearest_payoff'>Find Nearest Payoff</h2><span id='topic+nearest_payoff'></span>

<h3>Description</h3>

<p>This function computes the nearest simulated payoff from a given list of payoffs
based on a viral load difference (vl_diff). It returns both the nearest payoff value
and its corresponding payoff name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_payoff(vl_diff, payoffs_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearest_payoff_+3A_vl_diff">vl_diff</code></td>
<td>
<p>Numeric value representing the viral load difference for which the
nearest payoff will be found.</p>
</td></tr>
<tr><td><code id="nearest_payoff_+3A_payoffs_list">payoffs_list</code></td>
<td>
<p>A named list of payoff values, where the names correspond to
specific payoffs and the values are the associated payoff values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: <code>value</code> (the nearest payoff value) and <code>name</code>
(the name of the nearest payoff).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
library(dplyr)
library(qsimulatR)
data(vl_3)
data(cd_3)

# Create interaction object and classification
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)

# Define gates and parameters for payoffs
gates &lt;- list(
  T = Tgate(2),
  X = X(2),
  Id = Id(2),
  H = H(2),
  Z = Z(2),
  S = S(2),
  Y = Y(2)
)
alpha &lt;- -0.4518303; beta &lt;- -1.654192; gamma &lt;- -0.2638399; theta &lt;- -0.5619246
alpha2 &lt;- -0.04186888; beta2 &lt;- -3.01931; gamma2 &lt;- 0.3922753; theta2 &lt;-1.055114

# Generate the payoffs list
payoffs_list &lt;- payoffs_list(gates, alpha, beta, gamma, theta, alpha2, beta2, gamma2, theta2)

# Filtered data based on specific patient IDs
filtered_data &lt;- class_obj$data |&gt; 
  bind_cols(id = cd_3$ID) |&gt; 
  relocate(id) |&gt; 
  filter(id %in% c(37, 102, 148, 174, 180, 205))

# Apply the nearest_payoff function to each vl_diff in the filtered data
filtered_data &lt;- filtered_data |&gt;
  rowwise() |&gt;
  mutate(nearest = list(nearest_payoff(vl_diff, payoffs_list))) |&gt;
  mutate(nearest_payoff = nearest$value,
         payoff_name = nearest$name) |&gt;
  select(-nearest) # Remove the intermediate column

# Display the updated filtered data with nearest payoff and its name
print(filtered_data)
</code></pre>

<hr>
<h2 id='normalize_check'>Normalize Check Function for qstate Class Object</h2><span id='topic+normalize_check'></span>

<h3>Description</h3>

<p>Check the normalization of a qstate object created by qsimulatR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_check(qstate_obj, probs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_check_+3A_qstate_obj">qstate_obj</code></td>
<td>
<p>A quantum state object.</p>
</td></tr>
<tr><td><code id="normalize_check_+3A_probs">probs</code></td>
<td>
<p>Are probabilities required as output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the sum of the squared magnitudes of the coefficients of the qstate object or its probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
ket0 &lt;- qstate(nbits = 1) 
normalize_check(ket0)
</code></pre>

<hr>
<h2 id='payoffs_list'>Generate Payoff List Based on Quantum Gates and Parameters</h2><span id='topic+payoffs_list'></span>

<h3>Description</h3>

<p>This function generates a list of payoffs for different combinations of quantum gate matrices.
The payoffs are computed for two sets of parameters, where each set defines different values
for the phenotype payoffs (v and V) in the quantum game model. The names of the payoffs are
dynamically generated based on the provided gate names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>payoffs_list(gates, alpha, beta, gamma, theta, alpha2, beta2, gamma2, theta2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="payoffs_list_+3A_gates">gates</code></td>
<td>
<p>A named list of gate matrices. Each element of the list is a quantum gate matrix
(e.g., T, X, Id, H, Z, S, Y). The names of the list elements are used to create payoff names dynamically.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value for the first parameter set, defining payoff for v×v.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_beta">beta</code></td>
<td>
<p>Numeric value for the first parameter set, defining payoff for v×V.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_gamma">gamma</code></td>
<td>
<p>Numeric value for the first parameter set, defining payoff for V×v.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_theta">theta</code></td>
<td>
<p>Numeric value for the first parameter set, defining payoff for V×V.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_alpha2">alpha2</code></td>
<td>
<p>Numeric value for the second parameter set, defining payoff for v×v.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_beta2">beta2</code></td>
<td>
<p>Numeric value for the second parameter set, defining payoff for v×V.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_gamma2">gamma2</code></td>
<td>
<p>Numeric value for the second parameter set, defining payoff for V×v.</p>
</td></tr>
<tr><td><code id="payoffs_list_+3A_theta2">theta2</code></td>
<td>
<p>Numeric value for the second parameter set, defining payoff for V×V.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of payoffs where the list names correspond to the gate combinations,
and the values represent the computed payoffs based on the input parameters and gate matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
gates &lt;- list(
  T = Tgate(2),
  X = X(2),
  Id = Id(2),
  H = H(2),
  Z = Z(2),
  S = S(2),
  Y = Y(2)
)
alpha &lt;- 0.5; beta &lt;- 0.2; gamma &lt;- 0.3; theta &lt;- 0.1
alpha2 &lt;- 0.6; beta2 &lt;- 0.25; gamma2 &lt;- 0.35; theta2 &lt;- 0.15
payoffs_list &lt;- payoffs_list(gates, alpha, beta, gamma, theta, alpha2, beta2, gamma2, theta2)
print(payoffs_list)
</code></pre>

<hr>
<h2 id='phen_hiv'>Calculate Final State and Payoffs in Quantum Game</h2><span id='topic+phen_hiv'></span>

<h3>Description</h3>

<p>This function calculates the final quantum state and expected payoffs for two
players in a quantum game based on their strategies. The function uses quantum
gates and unitary transformations to simulate the game dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phen_hiv(strategy1, strategy2, alpha, beta, gamma, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phen_hiv_+3A_strategy1">strategy1</code></td>
<td>
<p>A 2x2 matrix representing the strategy of player 1.</p>
</td></tr>
<tr><td><code id="phen_hiv_+3A_strategy2">strategy2</code></td>
<td>
<p>A 2x2 matrix representing the strategy of player 2.</p>
</td></tr>
<tr><td><code id="phen_hiv_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value representing the payoff for outcome |00&gt;.</p>
</td></tr>
<tr><td><code id="phen_hiv_+3A_beta">beta</code></td>
<td>
<p>A numeric value representing the payoff for outcome |01&gt;.</p>
</td></tr>
<tr><td><code id="phen_hiv_+3A_gamma">gamma</code></td>
<td>
<p>A numeric value representing the payoff for outcome |10&gt;.</p>
</td></tr>
<tr><td><code id="phen_hiv_+3A_theta">theta</code></td>
<td>
<p>A numeric value representing the payoff for outcome |11&gt;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the final quantum state (<code>final_state</code>), the payoffs
for each basis state (<code>payoffs</code>), and the expected payoffs for player 1 (<code>pi_v</code>)
and player 2 (<code>pi_V</code>).
</p>


<h3>References</h3>

<p>Özlüer Başer, B. (2022). &quot;Analyzing the competition of HIV-1 phenotypes with quantum game theory&quot;.
Gazi University Journal of Science, 35(3), 1190&ndash;1198. <a href="https://doi.org/10.35378/gujs.772616">doi:10.35378/gujs.772616</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
strategy1 &lt;- diag(2) # Identity matrix for strategy 1
strategy2 &lt;- diag(2) # Identity matrix for strategy 2
alpha &lt;- 1
beta &lt;- 0.5
gamma &lt;- 2
theta &lt;- 0.1
result &lt;- phen_hiv(strategy1, strategy2, alpha, beta, gamma, theta)
print(result)

</code></pre>

<hr>
<h2 id='plot.interaction'>Plot Interaction Differences</h2><span id='topic+plot.interaction'></span>

<h3>Description</h3>

<p>This function generates histograms and QQ plots for the differences in CD4
and viral load values contained in an interaction object. Users can choose to
plot all differences or specify which type to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interaction'
plot(x, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.interaction_+3A_x">x</code></td>
<td>
<p>An interaction object containing the differences to be plotted.
This object should include fields for CD4 differences (raw and standardized)
and viral load differences (raw, log10-transformed, and log10-standardized).</p>
</td></tr>
<tr><td><code id="plot.interaction_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of plot to generate.
Options include: &quot;cd_diff&quot;, &quot;cds_diff&quot;, &quot;vl_diff&quot;, &quot;vlog_diff&quot;, &quot;vlogs_diff&quot;,
or &quot;all&quot; (the default) to plot all types of differences.</p>
</td></tr>
<tr><td><code id="plot.interaction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots histograms and QQ plots for the specified differences. If
<code>type</code> is &quot;all&quot;, all plots are arranged in a grid layout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("vl_3")
data("cd_3")
interaction_obj &lt;- create_interactions(cd_3, vl_3)
plot(interaction_obj, type = "cd_diff")    

</code></pre>

<hr>
<h2 id='plot.InteractionClassification'>Plot InteractionClassification Clusters</h2><span id='topic+plot.InteractionClassification'></span>

<h3>Description</h3>

<p>This function visualizes the clusters formed by the <code>InteractionClassification</code> object.
It displays the viral load differences (<code>vl_diff</code>) and CD4 count differences (<code>cd_diff</code>)
as points, with each point color-coded by its cluster. Cluster centers are shown as red stars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InteractionClassification'
plot(
  x,
  plot_clusters = TRUE,
  evaluate_clusters = FALSE,
  max_clusters = 10,
  n_clusters = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.InteractionClassification_+3A_x">x</code></td>
<td>
<p>An object of class <code>InteractionClassification</code> created using the
<code>InteractionClassification()</code> function. It contains the clustering results and cluster centers.</p>
</td></tr>
<tr><td><code id="plot.InteractionClassification_+3A_plot_clusters">plot_clusters</code></td>
<td>
<p>Logical. If TRUE, plots the cluster visualization. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.InteractionClassification_+3A_evaluate_clusters">evaluate_clusters</code></td>
<td>
<p>Logical. If TRUE, plots the WSS to evaluate the optimal number of clusters.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.InteractionClassification_+3A_max_clusters">max_clusters</code></td>
<td>
<p>Integer. The maximum number of clusters to evaluate if <code>evaluate_clusters</code>
is set to TRUE. Default is 10.</p>
</td></tr>
<tr><td><code id="plot.InteractionClassification_+3A_n_clusters">n_clusters</code></td>
<td>
<p>Integer. The number of clusters to suggest when plotting the elbow method.
It determines where the vertical line (xintercept) is drawn in the plot. Default is 4.</p>
</td></tr>
<tr><td><code id="plot.InteractionClassification_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additionally, it can evaluate the optimal number of clusters using the elbow method by plotting
the within-cluster sum of squares (WSS) using <code>fviz_nbclust</code>.
</p>


<h3>Value</h3>

<p>A ggplot object that visualizes the clusters and their centers, or the WSS plot to evaluate
the optimal number of clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vl_3)
data(cd_3)
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)
plot(class_obj)
</code></pre>

<hr>
<h2 id='print.interaction'>Print Summary of CD4 and Viral Load Differences</h2><span id='topic+print.interaction'></span>

<h3>Description</h3>

<p>This method prints a summary of the CD4 and viral load differences contained
in the interaction object. It provides both raw and standardized values for
CD4 differences, as well as raw, log10-transformed, and log10-standardized
values for viral load differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interaction'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.interaction_+3A_x">x</code></td>
<td>
<p>An object of class <code>interaction</code> containing CD4 and viral load
differences.</p>
</td></tr>
<tr><td><code id="print.interaction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return a value; it prints the summary
statistics directly to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("vl_3")
data("cd_3")
interaction_obj &lt;- create_interactions(cd_3, vl_3)
print(interaction_obj)
</code></pre>

<hr>
<h2 id='print.InteractionClassification'>Print Method for InteractionClassification Objects</h2><span id='topic+print.InteractionClassification'></span>

<h3>Description</h3>

<p>This method prints a summary of the InteractionClassification object,
including the number of clusters, the cluster means, and the sizes of
each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InteractionClassification'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.InteractionClassification_+3A_x">x</code></td>
<td>
<p>An object of class <code>InteractionClassification</code> containing
the results of the k-means clustering.</p>
</td></tr>
<tr><td><code id="print.InteractionClassification_+3A_...">...</code></td>
<td>
<p>Additional arguments that may be passed to the print method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not return a value; it prints the summary
information to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vl_3)
data(cd_3)
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)

# Print the summary of the classification
print(class_obj)
</code></pre>

<hr>
<h2 id='pure_qubit1'>Create a normalized pure quantum state for a 1-qubit system.</h2><span id='topic+pure_qubit1'></span>

<h3>Description</h3>

<p>Create a normalized pure quantum state for a 1-qubit system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pure_qubit1(theta, phi, spherical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pure_qubit1_+3A_theta">theta</code></td>
<td>
<p>The parameter theta in radians.</p>
</td></tr>
<tr><td><code id="pure_qubit1_+3A_phi">phi</code></td>
<td>
<p>The parameter phi in radians.</p>
</td></tr>
<tr><td><code id="pure_qubit1_+3A_spherical">spherical</code></td>
<td>
<p>Whether to return coordinates in spherical form (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A qstate object representing the normalized pure quantum state for a 1-qubit system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Quantum simulator
library(qsimulatR)
# Define the parameters
theta &lt;- pi/4
phi &lt;- pi/6
# Create the quantum state
psi_qubit1 &lt;- pure_qubit1(theta, phi)
psi_qubit1
</code></pre>

<hr>
<h2 id='pure_qubit2'>Create a normalized pure quantum state for a 2-qubit system.</h2><span id='topic+pure_qubit2'></span>

<h3>Description</h3>

<p>Create a normalized pure quantum state for a 2-qubit system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pure_qubit2(theta1, theta2, phi1, phi2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pure_qubit2_+3A_theta1">theta1</code></td>
<td>
<p>The parameter theta1 in radians for the first qubit.</p>
</td></tr>
<tr><td><code id="pure_qubit2_+3A_theta2">theta2</code></td>
<td>
<p>The parameter theta2 in radians for the second qubit.</p>
</td></tr>
<tr><td><code id="pure_qubit2_+3A_phi1">phi1</code></td>
<td>
<p>The phase parameter phi1 in radians for the first qubit.</p>
</td></tr>
<tr><td><code id="pure_qubit2_+3A_phi2">phi2</code></td>
<td>
<p>The phase parameter phi2 in radians for the second qubit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A qstate object representing the normalized pure quantum state for a 2-qubit system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' 
# Quantum simulator
library(qsimulatR)
# Define the parameters
theta1 &lt;- pi/3
theta2 &lt;- pi/4
phi1 &lt;- pi/6
phi2 &lt;- pi/5

# Create the quantum state
psi_qubit2 &lt;- pure_qubit2(theta1, theta2, phi1, phi2)
psi_qubit2
</code></pre>

<hr>
<h2 id='simulate_entanglement'>Simulate Entanglement Evolution</h2><span id='topic+simulate_entanglement'></span>

<h3>Description</h3>

<p>This function simulates the evolution of entanglement between two quantum states x1 and x2 using the CNOT gate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_entanglement(x1, x2, iterations, angle, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_entanglement_+3A_x1">x1</code></td>
<td>
<p>Quantum state for qubit 1, represented as a qstate object.</p>
</td></tr>
<tr><td><code id="simulate_entanglement_+3A_x2">x2</code></td>
<td>
<p>Quantum state for qubit 2, represented as a qstate object.</p>
</td></tr>
<tr><td><code id="simulate_entanglement_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations for the entanglement process.</p>
</td></tr>
<tr><td><code id="simulate_entanglement_+3A_angle">angle</code></td>
<td>
<p>Rotation angle for applying Rx gate.</p>
</td></tr>
<tr><td><code id="simulate_entanglement_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, prints detailed information to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the entangled quantum state x2 after each iteration and other relevant information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
library(qvirus)
x1 &lt;- qstate(1, coefs = as.complex(c(0.8, 0.6)))
x2 &lt;- qstate(1, coefs = as.complex(c(0.38, 0.92)))
results &lt;- simulate_entanglement(x1, x2, iterations = 3, angle = pi/4, verbose = TRUE)
print(results)
</code></pre>

<hr>
<h2 id='six_state'>Create Six Important States on the Bloch Sphere</h2><span id='topic+six_state'></span>

<h3>Description</h3>

<p>This function creates and returns six important states on the Bloch Sphere based on the specified vector numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>six_state(vec_num = c(1, 2, 3, 4, 5, 6))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="six_state_+3A_vec_num">vec_num</code></td>
<td>
<p>A numeric vector specifying the indices of the states to include. Valid indices are 1 to 6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the selected quantum states based on the input vector vec_num.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qsimulatR)
# Select and return states 1, 3, and 5
six_state(c(1, 3, 5))
</code></pre>

<hr>
<h2 id='summary.interaction'>Summary Method for Interaction Class Objects</h2><span id='topic+summary.interaction'></span>

<h3>Description</h3>

<p>This function provides a summary of various statistics for an interaction
object, including raw and standardized differences for CD4 lymphocyte counts
and viral loads. It returns a structured list of summary statistics, useful
for understanding the differences in immune response and viral suppression
between HIV phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interaction'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.interaction_+3A_object">object</code></td>
<td>
<p>An object of class <code>interaction</code> that contains CD4
lymphocyte and viral load differences (raw and log-transformed).</p>
</td></tr>
<tr><td><code id="summary.interaction_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>cd_diff_raw</code></dt><dd><p>Summary statistics for the raw differences in CD4 lymphocyte counts.</p>
</dd>
<dt><code>cd_diff_standardized</code></dt><dd><p>Summary statistics for the standardized CD4 lymphocyte differences.</p>
</dd>
<dt><code>vl_diff_raw</code></dt><dd><p>Summary statistics for the raw differences in viral loads.</p>
</dd>
<dt><code>vl_diff_log_transformed</code></dt><dd><p>Summary statistics for the log-transformed viral load differences.</p>
</dd>
<dt><code>vl_diff_log_standardized</code></dt><dd><p>Summary statistics for the standardized log-transformed viral load differences.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(cd_3)
data(vl_3)
interaction_obj &lt;- create_interactions(cd_3, vl_3)
summary(interaction_obj)
</code></pre>

<hr>
<h2 id='summary.InteractionClassification'>Summarize Interaction Classification Results</h2><span id='topic+summary.InteractionClassification'></span>

<h3>Description</h3>

<p>This function calculates and summarizes the mean viral load differences
and CD4 count differences for each classification in the Interaction
Classification object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'InteractionClassification'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.InteractionClassification_+3A_object">object</code></td>
<td>
<p>An object of class <code>InteractionClassification</code> containing
the classified data and clustering results.</p>
</td></tr>
<tr><td><code id="summary.InteractionClassification_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame summarizing the mean viral load differences and CD4
count differences for each classification, along with the count
of observations in each classification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vl_3)
data(cd_3)
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)
summary(class_obj)
</code></pre>

<hr>
<h2 id='summary.payoffs'>Summarize Payoffs</h2><span id='topic+summary.payoffs'></span>

<h3>Description</h3>

<p>This function summarizes the payoffs object by classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'payoffs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.payoffs_+3A_object">object</code></td>
<td>
<p>A payoffs object.</p>
</td></tr>
<tr><td><code id="summary.payoffs_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble summarizing the estimated payoffs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)
library(earth)
library(baguette)
library(rules)
library(kknn)
library(viralmodels)
# Load required data
data(vl_3)
data(cd_3)

# Create interaction object and classification
interaction_obj &lt;- create_interactions(cd_3[,-1], vl_3[,-1])
class_obj &lt;- InteractionClassification(interaction_obj$vlogs_diff, interaction_obj$cds_diff)

# Prepare predictions
traindata &lt;- interaction_obj[c(2, 5)] |&gt; as_tibble()
target &lt;- "vlogs_diff"
predictions_df &lt;- viralpreds(target, 2, 1, 2, 123, traindata)

# Estimate payoffs
payoffs_results &lt;- estimate_payoffs(class_obj, predictions_df)
summary(payoffs_results)

## End(Not run)
</code></pre>

<hr>
<h2 id='vl_3'>Longitudinal Viral Load Values for HIV Patients (2018-2024)</h2><span id='topic+vl_3'></span>

<h3>Description</h3>

<p>Contains longitudinal measurements of viral load for 176
patients from 2018 to 2024. Viral load is a critical marker used to monitor
the effectiveness of HIV treatment by measuring the amount of HIV RNA in the
blood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vl_3
</code></pre>


<h3>Format</h3>

<p>A data frame with 176 rows and 18 variables:
</p>

<dl>
<dt>ID</dt><dd><p>Unique identifier for each patient.</p>
</dd>
<dt>vl_2018_1</dt><dd><p>Viral load for the first measurement in 2018.</p>
</dd>
<dt>vl_2018_2</dt><dd><p>Viral load for the second measurement in 2018.</p>
</dd>
<dt>vl_2019_1</dt><dd><p>Viral load for the first measurement in 2019.</p>
</dd>
<dt>vl_2019_2</dt><dd><p>Viral load for the second measurement in 2019.</p>
</dd>
<dt>vl_2020_1</dt><dd><p>Viral load for the first measurement in 2020.</p>
</dd>
<dt>vl_2021_1</dt><dd><p>Viral load for the first measurement in 2021.</p>
</dd>
<dt>vl_2021_2</dt><dd><p>Viral load for the second measurement in 2021.</p>
</dd>
<dt>vl_2021_3</dt><dd><p>Viral load for the third measurement in 2021.</p>
</dd>
<dt>vl_2022_1</dt><dd><p>Viral load for the first measurement in 2022.</p>
</dd>
<dt>vl_2022_2</dt><dd><p>Viral load for the second measurement in 2022.</p>
</dd>
<dt>vl_2022_3</dt><dd><p>Viral load for the third measurement in 2022.</p>
</dd>
<dt>vl_2023_1</dt><dd><p>Viral load for the first measurement in 2023.</p>
</dd>
<dt>vl_2023_2</dt><dd><p>Viral load for the second measurement in 2023.</p>
</dd>
<dt>vl_2023_3</dt><dd><p>Viral load for the third measurement in 2023.</p>
</dd>
<dt>vl_2024_1</dt><dd><p>Viral load for the first measurement in 2024.</p>
</dd>
<dt>vl_2024_2</dt><dd><p>Viral load for the second measurement in 2024.</p>
</dd>
<dt>vl_2024_3</dt><dd><p>Viral load for the third measurement in 2024.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The viral load measurements provide insight into the patient's response to
antiretroviral therapy (ART). Lower viral load values, especially
undetectable levels, indicate better control of the infection. Missing
values indicate that no viral load measurement was available for that patient
at that specific time.
</p>


<h3>Source</h3>

<p>Clinical data from Hospital Vicente Guerrero, IMSS, HIV Clinic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the dataset
data(vl_3)

# Summarize viral loads for the year 2021
summary(vl_3[, c("cd_2021_1", "cd_2021_2", "cd_2021_3")])

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
