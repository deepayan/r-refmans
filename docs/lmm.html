<!DOCTYPE html><html><head><title>Help for package lmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ecmeml'>
<p>ECME algorithm for maximum-likelihood (ML) estimation in</p>
linear mixed models</a></li>
<li><a href='#ecmerml'>
<p>ECME algorithm for restricted maximum-likelihood (RML)</p>
estimation in linear mixed models</a></li>
<li><a href='#example'>
<p>lmm package example command file</p></a></li>
<li><a href='#fastmcmc'>
<p>Rapidly converging Markov chain Monte Carlo algorithm for</p>
Bayesian inference in linear mixed models</a></li>
<li><a href='#fastml'>
<p>Rapidly converging algorithm for maximum-likelihood (ML)</p>
estimation in linear mixed models</a></li>
<li><a href='#fastmode'>
<p>Rapidly converging algorithm for calculating posterior modes</p>
in linear mixed models</a></li>
<li><a href='#fastrml'>
<p>Rapidly converging algorithm for restricted maximum-likelihood</p>
(RML) estimation in linear mixed models</a></li>
<li><a href='#marijuana'><p>A pilot study of the clinical and psychological effects of maarijuana</p></a></li>
<li><a href='#mgibbs'>
<p>Modified Gibbs sampler for Bayesian inference in linear mixed</p>
models</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-8-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Mixed Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Original by Joseph L. Schafer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jing hua Zhao &lt;jinghuazhao@hotmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>Description:</td>
<td>It implements Expectation/Conditional Maximization Either (ECME)
             and rapidly converging algorithms as well as
             Bayesian inference for linear mixed models, 
             which is described in Schafer, J.L. (1998)
             "Some improved procedures for linear mixed models".
             Dept. of Statistics, The Pennsylvania State University.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jinghuazhao/R">https://github.com/jinghuazhao/R</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 19:14:17 UTC; jhz22</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 19:52:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='ecmeml'>
ECME algorithm for maximum-likelihood (ML) estimation in
linear mixed models
</h2><span id='topic+ecmeml'></span>

<h3>Description</h3>

<p>Computes ML estimates of parameters in linear mixed models
using the ECME procedure described by Schafer (1998). This
algorithm may be slow, requiring a large number of cycles
to converge. In most cases, &quot;fastml&quot; will perform better.
This function is provided mainly for comparison against 
&quot;fastml&quot;. 
</p>
<p>For a description of the model, see the &quot;Details&quot; section
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecmeml(y, subj, pred, xcol, zcol, vmax, occ, start, 
   maxits=1000, eps=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecmeml_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_start">start</code></td>
<td>

<p>optional starting values of the parameters. If this argument
is not given then the function chooses its own starting values.
This argument should be a list of three elements named
&quot;beta&quot;, &quot;psi&quot;, and &quot;sigma2&quot;. Note that &quot;beta&quot; should be a
vector of the same length as &quot;xcol&quot;, &quot;psi&quot; should be a
matrix of dimension c(length(zcol),length(zcol)), and
&quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of cycles to be performed.
The algorithm runs to convergence or until &quot;maxits&quot;
iterations, whichever comes first.
</p>
</td></tr>
<tr><td><code id="ecmeml_+3A_eps">eps</code></td>
<td>

<p>convergence criterion. The algorithm is considered to have
converged if the relative differences in all parameters from
one iteration to the next are less than eps&ndash;that is, if
all(abs(new-old)&lt;eps*abs(old)).
</p>
</td></tr></table>


<h3>Details</h3>

<p>For details of the algorithm, see Section 3 of Schafer (1998).
</p>
<p>The model, which is typically applied to longitudinal or
clustered responses, is 
</p>
<p>yi = Xi%*%beta + Zi%*%bi + ei ,    i=1,...,m,
</p>
<p>where
</p>
<p>yi    = (ni x 1) response vector for subject
or cluster i;
Xi    = (ni x p) matrix of covariates;
Zi    =	(ni x q) matrix of covariates;
beta  = (p x 1) vector of coefficients common to the
population (fixed effects);
bi    = (q x 1) vector of coefficients specific to
subject or cluster i (random effects); and
ei    = (ni x 1) vector of residual errors.
</p>
<p>The vector bi is assumed to be normally distributed
with mean zero and unstructured covariance matrix psi, 
</p>
<p>bi <code class="reqn">\sim</code>  N(0,psi) independently for i=1,...,m.
</p>
<p>The residual vector ei is assumed to be
</p>
<p>ei <code class="reqn">\sim</code> N(0,sigma2*Vi)
</p>
<p>where Vi is a known (ni x ni) matrix. In most applications,
Vi is the identity matrix.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>vector of same length as &quot;xcol&quot; containing estimated fixed
effects.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>estimate of residual error variance.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>matrix of dimension c(length(zcol),length(zcol)) containing
estimated variances and covariances of the random effects.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>T if the algorithm converged, F if it did not.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>number of iterations actually performed. Will be equal
to &quot;maxits&quot; if converged=F.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>vector of length &quot;iter&quot; reporting the value of the
loglikelihood at each iteration.
</p>
</td></tr>
<tr><td><code>cov.beta</code></td>
<td>

<p>matrix of dimension c(length(xcol),length(xcol)) containing
estimated variances and covariances for elements of &quot;beta&quot;.
These are conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their ML estimates.
</p>
</td></tr>
<tr><td><code>b.hat</code></td>
<td>

<p>a matrix with length(zcol) rows and m columns, where
b.hat[,i] is an empirical Bayes estimate of bi.
</p>
</td></tr>
<tr><td><code>cov.b</code></td>
<td>

<p>an array of dimension length(zcol) by length(zcol) by m,
where cov.b[,,i] is an empirical Bayes estimate of the
covariance matrix associated with bi. These are
conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their ML estimates.
(An improved version which incorporates variance-parameter
uncertainty is available from the function &quot;fastrml&quot;.)
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmerml">ecmerml</a></code>, <code><a href="#topic+fastml">fastml</a></code>,
<code><a href="#topic+fastrml">fastrml</a></code>, <code><a href="#topic+fastmode">fastmode</a></code>,
<code><a href="#topic+mgibbs">mgibbs</a></code>, <code><a href="#topic+fastmcmc">fastmcmc</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.

## End(Not run)</code></pre>

<hr>
<h2 id='ecmerml'>
ECME algorithm for restricted maximum-likelihood (RML)
estimation in linear mixed models
</h2><span id='topic+ecmerml'></span>

<h3>Description</h3>

<p>Computes RML estimates of parameters in linear mixed models
using the ECME procedure described by Schafer (1998). This
algorithm may be slow, requiring a large number of cycles
to converge. In most cases, &quot;fastrml&quot; will perform better.
This function is provided mainly for comparison against 
&quot;fastrml&quot;. 
</p>
<p>For a description of the model, see the &quot;Details&quot; section
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecmerml(y, subj, pred, xcol, zcol, vmax, occ, start,
   maxits=1000, eps=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecmerml_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_start">start</code></td>
<td>

<p>optional starting values of the parameters. If this argument
is not given then the function chooses its own starting values.
This argument should be a list of three elements named
&quot;beta&quot;, &quot;psi&quot;, and &quot;sigma2&quot;. Note that &quot;beta&quot; should be a
vector of the same length as &quot;xcol&quot;, &quot;psi&quot; should be a
matrix of dimension c(length(zcol),length(zcol)), and
&quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of cycles to be performed.
The algorithm runs to convergence or until &quot;maxits&quot;
iterations, whichever comes first.
</p>
</td></tr>
<tr><td><code id="ecmerml_+3A_eps">eps</code></td>
<td>

<p>convergence criterion. The algorithm is considered to have
converged if the relative differences in all parameters from
one iteration to the next are less than eps&ndash;that is, if
all(abs(new-old)&lt;eps*abs(old)).
</p>
</td></tr></table>


<h3>Details</h3>

<p>For details of the algorithm, see Section 3 of Schafer (1998).
</p>
<p>The model, which is typically applied to longitudinal or
clustered responses, is 
</p>
<p>yi = Xi%*%beta + Zi%*%bi + ei ,    i=1,...,m,
</p>
<p>where
</p>
<p>yi    = (ni x 1) response vector for subject
or cluster i;
Xi    = (ni x p) matrix of covariates;
Zi    =	(ni x q) matrix of covariates;
beta  = (p x 1) vector of coefficients common to the
population (fixed effects);
bi    = (q x 1) vector of coefficients specific to
subject or cluster i (random effects); and
ei    = (ni x 1) vector of residual errors.
</p>
<p>The vector bi is assumed to be normally distributed
with mean zero and unstructured covariance matrix psi, 
</p>
<p>bi <code class="reqn">\sim</code>  N(0,psi) independently for i=1,...,m.
</p>
<p>The residual vector ei is assumed to be
</p>
<p>ei <code class="reqn">\sim</code> N(0,sigma2*Vi)
</p>
<p>where Vi is a known (ni x ni) matrix. In most applications,
Vi is the identity matrix.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>vector of same length as &quot;xcol&quot; containing estimated fixed
effects.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>estimate of residual error variance.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>matrix of dimension c(length(zcol),length(zcol)) containing
estimated variances and covariances of the random effects.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>T if the algorithm converged, F if it did not.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>number of iterations actually performed. Will be equal
to &quot;maxits&quot; if converged=F.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>vector of length &quot;iter&quot; reporting the value of the
&quot;restricted&quot; loglikelihood at each iteration.
</p>
</td></tr>
<tr><td><code>cov.beta</code></td>
<td>

<p>matrix of dimension c(length(xcol),length(xcol)) containing
estimated variances and covariances for elements of &quot;beta&quot;.
These are conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their RML estimates.
</p>
</td></tr>
<tr><td><code>b.hat</code></td>
<td>

<p>a matrix with length(zcol) rows and m columns, where
b.hat[,i] is an empirical Bayes estimate of bi.
</p>
</td></tr>
<tr><td><code>cov.b</code></td>
<td>

<p>an array of dimension length(zcol) by length(zcol) by m,
where cov.b[,,i] is an empirical Bayes estimate of the
covariance matrix associated with bi. These are
conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their RML estimates.
(An improved version which incorporates variance-parameter
uncertainty is available from the function &quot;fastrml&quot;.)
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+fastml">fastml</a></code>,
<code><a href="#topic+fastrml">fastrml</a></code>, <code><a href="#topic+fastmode">fastmode</a></code>,
<code><a href="#topic+mgibbs">mgibbs</a></code>, <code><a href="#topic+fastmcmc">fastmcmc</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.


## End(Not run)</code></pre>

<hr>
<h2 id='example'>
lmm package example command file
</h2><span id='topic+example'></span>

<h3>Description</h3>

<p>The data as contained in <code><a href="#topic+marijuana">marijuana</a></code> is used to fit
a compound symmetry model with a fixed effect for each occasion and
a random intercept for each subject.
</p>
<p>Since the six measurements per subject were not clearly ordered in
time, instead of a model with time of measurement entered with linear
(or perhaps higher-order polynomial) effects, the model has an
intercept and five dummy codes to allow the population means for the
six occasions to be estimated freely. For a subject i with no missing
values, the covariate matrices will be
</p>
<p>Xi=(
1 1 0 0 0 0, 
1 0 1 0 0 0, 
1 0 0 1 0 0, 
1 0 0 0 1 0, 
1 0 0 0 0 1)
and Zi=(1,1,1,1,1,1)
</p>
<p>The Xi's and Zi's are combined into a single matrix called pred
(Zi is merely the first column of Xi), simply the matrices 
Xi (i=1,...,9), stacked upon each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+ecmerml">ecmerml</a></code>,
<code><a href="#topic+fastml">fastml</a></code>, <code><a href="#topic+fastrml">fastrml</a></code>,
<code><a href="#topic+fastmcmc">fastmcmc</a></code>, <code><a href="#topic+fastmode">fastmode</a></code>, 
<code><a href="#topic+mgibbs">mgibbs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Model specification ###
data(marijuana)
# To work only on those with complete data
marijuana &lt;- subset(marijuana,!is.na(y))
attach(marijuana)
pred &lt;- cbind(int,dummy1,dummy2,dummy3,dummy4,dummy5)
xcol &lt;- 1:6
zcol &lt;- 1

### ML Estimation ###
ecmeml.result &lt;- ecmeml(y,subj,pred,xcol,zcol)
fastml.result &lt;- fastml(y,subj,pred,xcol,zcol)
#
# which converged in 212 and 8 cycles, respectively. For example, the
# first elemenent of the ML estimate of the fixed effects (the intercept)
# estimates the mean for the last occasion and the other elements of beta
# estimate the differences in means between the first five occasions and
# the last one. So we can find the estimated means for the six occasions.
#
beta.hat &lt;- fastml.result$beta
muhat &lt;- c(beta.hat[2]+beta.hat[1], beta.hat[3]+beta.hat[1],
   beta.hat[4]+beta.hat[1], beta.hat[5]+beta.hat[1],
   beta.hat[6]+beta.hat[1], beta.hat[1]) 

### RML estimation ###
ecmerml.result &lt;- ecmerml(y,subj,pred,xcol,zcol)
fastrml.result &lt;- fastrml(y,subj,pred,xcol,zcol)

### Improved variance estimation in Section 4 ### 
b.hat &lt;- as.vector(fastrml.result$b.hat)
se.new &lt;- sqrt(as.vector(fastrml.result$cov.b.new))
se.old &lt;- sqrt(as.vector(fastrml.result$cov.b))
table2 &lt;- cbind(round(b.hat,3),round(cbind(b.hat-2*se.old,b.hat+2*se.old,
      b.hat-2*se.new,b.hat+2*se.new),2),round(100*(se.new-se.old)/se.old))
dimnames(table2) &lt;- list(paste("Subject",format(1:9)),
   c("Est.","Lower.old","Upper.old","Lower.new","Upper.new","Increase (%)"))
print(table2)
#
# which reproduces Table 2 and compares 95% interval estimates
# under the new method to conventional empirical Bayes intervals.

### MCMC in Section 5 ###
prior &lt;- list(a=3*100,b=3,c=3,Dinv=3*5)
gibbs.result &lt;- mgibbs(y,subj,pred,xcol,zcol,prior=prior,seed=1234,iter=5000)
fmcmc.result &lt;- fastmcmc(y,subj,pred,xcol,zcol,prior=prior,seed=2345,iter=5000)
#
# which run 5,000 cycles for each algorithm and generates Figure 1.
#
# library(ts)
par(mfrow=c(2,1))
acf(log(gibbs.result$psi.series[1,1,]),lag.max=10, ylim=0:1)
acf(log(fmcmc.result$psi.series[1,1,]),lag.max=10, ylim=0:1)
detach(marijuana)
</code></pre>

<hr>
<h2 id='fastmcmc'>
Rapidly converging Markov chain Monte Carlo algorithm for
Bayesian inference in linear mixed models
</h2><span id='topic+fastmcmc'></span>

<h3>Description</h3>

<p>Simulates posterior draws of parameters in linear mixed models
using the rapidly converging Markov chain Monte Carlo (MCMC)
procedure described by Schafer (1998), which combines a
Metropolis-Hastings algorithm with a modified Gibbs sampler.
</p>
<p>Prior to the MCMC simulation, the posterior mode of the
variance parameters is found using the algorithm of
&quot;fastmode&quot;. The results from a call to &quot;fastmode&quot; are
returned along with the MCMC results.
</p>
<p>For a description of the model and the prior distribution, see
the &quot;Details&quot; section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastmcmc(y, subj, pred, xcol, zcol, prior, seed, vmax,
   occ, start.mode, maxits=100, eps=0.0001, iter=1000, 
   start.mcmc, df=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastmcmc_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_prior">prior</code></td>
<td>

<p>A list with four components specifying the hyperparameters of
the prior distribution applied to sigma2 and psi. The
components must be named &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;Dinv&quot;. All are
scalars except for &quot;Dinv&quot;, which is a matrix of dimension
c(length(zcol),length(zcol)).
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_seed">seed</code></td>
<td>

<p>Seed for random number generator. This should be a positive
integer. 
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_start.mode">start.mode</code></td>
<td>

<p>optional starting values of the parameters for the
mode-finding procedure.  If this argument is not given then
the function chooses its own starting values.  This argument
should be a list of three elements named &quot;beta&quot;, &quot;psi&quot;, and
&quot;sigma2&quot;. Note that &quot;beta&quot; should be a vector of the same
length as &quot;xcol&quot;, &quot;psi&quot; should be a matrix of dimension
c(length(zcol),length(zcol)), and &quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of cycles of the mode-finding procedure. The
algorithm runs 	to convergence or until &quot;maxits&quot; iterations,
whichever comes first.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_eps">eps</code></td>
<td>

<p>convergence criterion for the mode-finding procedure. The
algorithm is considered to have converged if the relative
differences in all parameters from one iteration to the next
are less than eps&ndash;that is, if all(abs(new-old)&lt;eps*abs(old)).
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_iter">iter</code></td>
<td>

<p>number of cycles of the MCMC procedure to be performed.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_start.mcmc">start.mcmc</code></td>
<td>

<p>optional starting values of the parameters for the MCMC
procedure. If this argument is not given, then the procedure
is started at the posterior mode.
</p>
</td></tr>
<tr><td><code id="fastmcmc_+3A_df">df</code></td>
<td>

<p>degrees of freedom for the multivariate t approximation in the
Metropolis-Hastings algorithm.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The algorithm is described in Section 5 of Schafer (1998).
</p>
<p>The model, which is typically applied to longitudinal or
clustered responses, is 
</p>
<p>yi = Xi%*%beta + Zi%*%bi + ei ,    i=1,...,m,
</p>
<p>where
</p>
<p>yi    = (ni x 1) response vector for subject
or cluster i;
Xi    = (ni x p) matrix of covariates;
Zi    =	(ni x q) matrix of covariates;
beta  = (p x 1) vector of coefficients common to the
population (fixed effects);
bi    = (q x 1) vector of coefficients specific to
subject or cluster i (random effects); and
ei    = (ni x 1) vector of residual errors.
</p>
<p>The vector bi is assumed to be normally distributed
with mean zero and unstructured covariance matrix psi, 
</p>
<p>bi <code class="reqn">\sim</code>  N(0,psi) independently for i=1,...,m.
</p>
<p>The residual vector ei is assumed to be
</p>
<p>ei <code class="reqn">\sim</code> N(0,sigma2*Vi)
</p>
<p>where Vi is a known (ni x ni) matrix. In most applications,
Vi is the identity matrix.
</p>
<p>The prior distribution applied to the within-unit residual
variance is scaled inverted-chisquare,
</p>
<p>sigma2 <code class="reqn">\sim</code> a / chisq(b),
</p>
<p>where chisq(b) denotes a chisquare random variable with b
degrees of freedom, and a and b are user-defined
hyperparameters. Values for the hyperparmeters may be chosen
by regarding a/b as a rough prior guess for sigma2, and as
the imaginary degrees of freedom on which this guess is based.
</p>
<p>The prior distribution applied to the between-unit covariance
matrix is inverted Wishart,
</p>
<p>psiinv <code class="reqn">\sim</code> W(c,D),
</p>
<p>where psiinv is the inverse of the between-unit covariance
matrix psi, and W(c,D) denotes a Wishart distribution with
degrees of freedom c and scale matrix D. Values for the
hyperparameters may be chosen by regarding Dinv/c (the inverse
of D divided by c) as a rough prior guess for psi, and c as
the imaginary degrees of freedom on which this guess is based.
</p>
<p>An improper uniform prior density function is applied to
the fixed effects beta.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>simulated value of coefficients beta after &quot;iter&quot; cycles of
the MCMC algorithm. This is a vector of the same length as
xcol.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>simulated value of the residual variance sigma2 after &quot;iter&quot;
cycles of the MCMC algorithm.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>simulated value of the between-unit covariance matrix psi
after &quot;iter&quot; cycles of the MCMC algorithm.
</p>
</td></tr>
<tr><td><code>sigma2.series</code></td>
<td>

<p>vector of length &quot;iter&quot; containing the entire history of
simulated values of sigma2. That is, sigma2.series[t] contains
the value of sigma2 at cycle t.
</p>
</td></tr>
<tr><td><code>psi.series</code></td>
<td>

<p>array of dimension c(length(zcol),length(zcol),iter)
containing the entire history of simulated values of psi. That
is, psi.series[,,t] contains the value of psi at cycle t.
</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>

<p>vector of length &quot;iter&quot; containing the entire history of
acceptance ratios from the Metropolis-Hastings algorithm.
These ratios diagnose the quality of the multivariate t
approximation. If the approximation were perfect, all of these
ratios would be equal to one.
</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>

<p>logical vector of length &quot;iter&quot; indicating, for each cycle of
the algorithm, whether the Metropolis-Hastings candidate was
accepted (T) or rejected (F).
</p>
</td></tr>
<tr><td><code>mode.list</code></td>
<td>

<p>a list containing the results of the mode-finding procedure.
The contents of this list are identical to those produced by
&quot;fastmode&quot;. For more information, see the help file for
&quot;fastmode&quot;. 
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+ecmerml">ecmerml</a></code>,
<code><a href="#topic+fastml">fastml</a></code>, <code><a href="#topic+fastrml">fastrml</a></code>,
<code><a href="#topic+fastmode">fastmode</a></code>, <code><a href="#topic+mgibbs">mgibbs</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.


## End(Not run)</code></pre>

<hr>
<h2 id='fastml'>
Rapidly converging algorithm for maximum-likelihood (ML)
estimation in linear mixed models
</h2><span id='topic+fastml'></span>

<h3>Description</h3>

<p>Computes ML estimates of parameters in linear mixed models
using the rapidly converging procedure described by Schafer
(1998), which combines Fisher scoring with an ECME algorithm.
</p>
<p>For a description of the model, see the &quot;Details&quot; section
below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastml(y, subj, pred, xcol, zcol, vmax, occ, start,
   maxits=50, eps=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastml_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="fastml_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="fastml_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="fastml_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="fastml_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="fastml_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="fastml_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="fastml_+3A_start">start</code></td>
<td>

<p>optional starting values of the parameters. If this argument
is not given then the function chooses its own starting values.
This argument should be a list of three elements named
&quot;beta&quot;, &quot;psi&quot;, and &quot;sigma2&quot;. Note that &quot;beta&quot; should be a
vector of the same length as &quot;xcol&quot;, &quot;psi&quot; should be a
matrix of dimension c(length(zcol),length(zcol)), and
&quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="fastml_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of cycles to be performed.
The algorithm runs to convergence or until &quot;maxits&quot;
iterations, whichever comes first.
</p>
</td></tr>
<tr><td><code id="fastml_+3A_eps">eps</code></td>
<td>

<p>convergence criterion. The algorithm is considered to have
converged if the relative differences in all parameters from
one iteration to the next are less than eps&ndash;that is, if
all(abs(new-old)&lt;eps*abs(old)).
</p>
</td></tr></table>


<h3>Details</h3>

<p>A full description of the algorithm is given in Section 3 of
Schafer (1998). Scoring is carried out on log(sigma2) and the
nonredundant elements of the inverse of psi/sigma2, taking
logs of the diagonal elements.
</p>
<p>The model, which is typically applied to longitudinal or
clustered responses, is 
</p>
<p>yi = Xi%*%beta + Zi%*%bi + ei ,    i=1,...,m,
</p>
<p>where
</p>
<p>yi    = (ni x 1) response vector for subject
or cluster i;
Xi    = (ni x p) matrix of covariates;
Zi    =	(ni x q) matrix of covariates;
beta  = (p x 1) vector of coefficients common to the
population (fixed effects);
bi    = (q x 1) vector of coefficients specific to
subject or cluster i (random effects); and
ei    = (ni x 1) vector of residual errors.
</p>
<p>The vector bi is assumed to be normally distributed
with mean zero and unstructured covariance matrix psi, 
</p>
<p>bi <code class="reqn">\sim</code>  N(0,psi) independently for i=1,...,m.
</p>
<p>The residual vector ei is assumed to be
</p>
<p>ei <code class="reqn">\sim</code> N(0,sigma2*Vi)
</p>
<p>where Vi is a known (ni x ni) matrix. In most applications,
Vi is the identity matrix.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>vector of same length as &quot;xcol&quot; containing estimated fixed
effects.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>estimate of residual error variance.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>matrix of dimension c(length(zcol),length(zcol)) containing
estimated variances and covariances of the random effects.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>T if the algorithm converged, F if it did not.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>number of iterations actually performed. Will be equal
to &quot;maxits&quot; if converged=F.
</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>

<p>a logical vector of length iter indicating, for each
iteration, whether the scoring estimates were rejected
and replaced by ECME estimates (T), or whether the scoring
estimates were accepted (F). Scoring estimates are rejected
if they do not increase the loglikelihood.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>vector of length &quot;iter&quot; reporting the value of the
loglikelihood at each iteration.
</p>
</td></tr>
<tr><td><code>cov.beta</code></td>
<td>

<p>matrix of dimension c(length(xcol),length(xcol)) containing
estimated variances and covariances for elements of &quot;beta&quot;.
These are conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their ML estimates.
</p>
</td></tr>
<tr><td><code>b.hat</code></td>
<td>

<p>a matrix with length(zcol) rows and m columns, where
b.hat[,i] is an empirical Bayes estimate of bi.
</p>
</td></tr>
<tr><td><code>cov.b</code></td>
<td>

<p>an array of dimension length(zcol) by length(zcol) by m,
where cov.b[,,i] is an empirical Bayes estimate of the
covariance matrix associated with bi. These are
conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their ML estimates.
(An improved version which incorporates variance-parameter
uncertainty is available from the function &quot;fastrml&quot;.)
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+ecmerml">ecmerml</a></code>,
<code><a href="#topic+fastrml">fastrml</a></code>, <code><a href="#topic+fastmode">fastmode</a></code>,
<code><a href="#topic+mgibbs">mgibbs</a></code>, <code><a href="#topic+fastmcmc">fastmcmc</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.

## End(Not run)</code></pre>

<hr>
<h2 id='fastmode'>
Rapidly converging algorithm for calculating posterior modes
in linear mixed models
</h2><span id='topic+fastmode'></span>

<h3>Description</h3>

<p>Computes the marginal posterior mode of the variance
parameters in linear mixed models using a rapidly converging
procedure described by Schafer (1998), which combines Fisher
scoring with an ECME algorithm. The method is a minor
modification of the restricted maximum-likelihood (RML)
procedure used in &quot;fastrml&quot;. The model is identical to
that of &quot;fastrml&quot; with the addition of prior
distributions for the variance parameters.
</p>
<p>For a description of the prior distribution, see the &quot;Details&quot;
section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastmode(y, subj, pred, xcol, zcol, prior, vmax, occ, start,
   maxits=100, eps=0.0001)
</code></pre>


<h3>Arguments</h3>

<p>Identical to those for the function &quot;fastrml&quot;, with one
additional required argument:
</p>
<table>
<tr><td><code id="fastmode_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_prior">prior</code></td>
<td>

<p>A list with four components specifying the hyperparameters of
the prior distribution applied to sigma2 and psi. The
components must be named &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;Dinv&quot;. All are
scalars except for &quot;Dinv&quot;, which is a matrix of dimension
c(length(zcol),length(zcol)).
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_start">start</code></td>
<td>

<p>optional starting values of the parameters. If this argument
is not given then the function chooses its own starting values.
This argument should be a list of three elements named
&quot;beta&quot;, &quot;psi&quot;, and &quot;sigma2&quot;. Note that &quot;beta&quot; should be a
vector of the same length as &quot;xcol&quot;, &quot;psi&quot; should be a
matrix of dimension c(length(zcol),length(zcol)), and
&quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of cycles to be performed.
The algorithm runs to convergence or until &quot;maxits&quot;
iterations, whichever comes first.
</p>
</td></tr>
<tr><td><code id="fastmode_+3A_eps">eps</code></td>
<td>

<p>convergence criterion. The algorithm is considered to have
converged if the relative differences in all parameters from
one iteration to the next are less than eps&ndash;that is, if
all(abs(new-old)&lt;eps*abs(old)).
</p>
</td></tr></table>


<h3>Details</h3>

<p>The algorithm is described in the appendix of Schafer (1998).
Scoring is carried out on log(sigma2) and the nonredundant
elements of the inverse of psi/sigma2, taking logs of the
diagonal elements. Upon convergence, the estimates  represent
the mode of the joint posterior density of 1/sigma2 and the
inverse of psi, marginalized (i.e. integrated) over beta.
</p>
<p>The prior distribution applied to the within-unit residual
variance is scaled inverted-chisquare,
</p>
<p>sigma2 <code class="reqn">\sim</code> a / chisq(b),
</p>
<p>where chisq(b) denotes a chisquare random variable with b
degrees of freedom, and a and b are user-defined
hyperparameters. Values for the hyperparmeters may be chosen
by regarding a/b as a rough prior guess for sigma2, and as
the imaginary degrees of freedom on which this guess is based.
</p>
<p>The prior distribution applied to the between-unit covariance
matrix is inverted Wishart,
</p>
<p>psiinv <code class="reqn">\sim</code> W(c,D),
</p>
<p>where psiinv is the inverse of the between-unit covariance
matrix psi, and W(c,D) denotes a Wishart distribution with
degrees of freedom c and scale matrix D. Values for the
hyperparameters may be chosen by regarding Dinv/c (the inverse
of D divided by c) as a rough prior guess for psi, and c as
the imaginary degrees of freedom on which this guess is based.
</p>
<p>An improper uniform prior density function is applied to
the fixed effects beta.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>vector of same length as &quot;xcol&quot; containing estimated fixed
effects. This estimate represents the posterior mean for beta,
conditional upon the estimated values of the variance
parameters sigma2 and psi.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>estimate of residual error variance. 
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>matrix of dimension c(length(zcol),length(zcol)) containing
estimated variances and covariances of the random effects.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>T if the algorithm converged, F if it did not.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>number of iterations actually performed. Will be equal
to &quot;maxits&quot; if converged=F.
</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>

<p>a logical vector of length iter indicating, for each
iteration, whether the scoring estimates were rejected
and replaced by ECME estimates (T), or whether the scoring
estimates were accepted (F). Scoring estimates are rejected
if they do not increase the log-posterior density.
</p>
</td></tr>
<tr><td><code>logpost</code></td>
<td>

<p>vector of length &quot;iter&quot; reporting the value of the
log-posterior density at each iteration.
</p>
</td></tr>
<tr><td><code>cov.beta</code></td>
<td>

<p>matrix of dimension c(length(xcol),length(xcol)) containing
estimated variances and covariances for elements of &quot;beta&quot;.
These are conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their estimated
values. 
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+ecmerml">ecmerml</a></code>,
<code><a href="#topic+fastml">fastml</a></code>, <code><a href="#topic+fastrml">fastrml</a></code>,
<code><a href="#topic+mgibbs">mgibbs</a></code>, <code><a href="#topic+fastmcmc">fastmcmc</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.


## End(Not run)</code></pre>

<hr>
<h2 id='fastrml'>
Rapidly converging algorithm for restricted maximum-likelihood
(RML) estimation in linear mixed models
</h2><span id='topic+fastrml'></span>

<h3>Description</h3>

<p>Computes RML estimates of parameters in linear mixed models
using the rapidly converging procedure described by Schafer
(1998), which combines Fisher scoring with an ECME algorithm.
</p>
<p>For a description of the model, see the &quot;Details&quot; section
below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastrml(y, subj, pred, xcol, zcol, vmax, occ, start,
   maxits=50, eps=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastrml_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_start">start</code></td>
<td>

<p>optional starting values of the parameters. If this argument
is not given then the function chooses its own starting values.
This argument should be a list of three elements named
&quot;beta&quot;, &quot;psi&quot;, and &quot;sigma2&quot;. Note that &quot;beta&quot; should be a
vector of the same length as &quot;xcol&quot;, &quot;psi&quot; should be a
matrix of dimension c(length(zcol),length(zcol)), and
&quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of cycles to be performed. The algorithm runs
to convergence or until &quot;maxits&quot; iterations, whichever comes
first.
</p>
</td></tr>
<tr><td><code id="fastrml_+3A_eps">eps</code></td>
<td>

<p>convergence criterion. The algorithm is considered to have
converged if the relative differences in all parameters from
one iteration to the next are less than eps&ndash;that is, if
all(abs(new-old)&lt;eps*abs(old)).
</p>
</td></tr></table>


<h3>Details</h3>

<p>A full description of the algorithm is given in Section 3 of
Schafer (1998). Scoring is carried out on log(sigma2) and the
nonredundant elements of the inverse of psi/sigma2, taking
logs of the diagonal elements. Improved estimates of variances
and covariances are described in Section 4.
</p>
<p>The model, which is typically applied to longitudinal or
clustered responses, is 
</p>
<p>yi = Xi%*%beta + Zi%*%bi + ei ,    i=1,...,m,
</p>
<p>where
</p>
<p>yi    = (ni x 1) response vector for subject
or cluster i;
Xi    = (ni x p) matrix of covariates;
Zi    =	(ni x q) matrix of covariates;
beta  = (p x 1) vector of coefficients common to the
population (fixed effects);
bi    = (q x 1) vector of coefficients specific to
subject or cluster i (random effects); and
ei    = (ni x 1) vector of residual errors.
</p>
<p>The vector bi is assumed to be normally distributed
with mean zero and unstructured covariance matrix psi, 
</p>
<p>bi <code class="reqn">\sim</code>  N(0,psi) independently for i=1,...,m.
</p>
<p>The residual vector ei is assumed to be
</p>
<p>ei <code class="reqn">\sim</code> N(0,sigma2*Vi)
</p>
<p>where Vi is a known (ni x ni) matrix. In most applications,
Vi is the identity matrix.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>vector of same length as &quot;xcol&quot; containing estimated fixed
effects.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>estimate of residual error variance.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>matrix of dimension c(length(zcol),length(zcol)) containing
estimated variances and covariances of the random effects.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>T if the algorithm converged, F if it did not.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>number of iterations actually performed. Will be equal
to &quot;maxits&quot; if converged=F.
</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>

<p>a logical vector of length iter indicating, for each
iteration, whether the scoring estimates were rejected
and replaced by ECME estimates (T), or whether the scoring
estimates were accepted (F). Scoring estimates are rejected
if they do not increase the loglikelihood.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>vector of length &quot;iter&quot; reporting the value of the
loglikelihood at each iteration.
</p>
</td></tr>
<tr><td><code>cov.beta</code></td>
<td>

<p>matrix of dimension c(length(xcol),length(xcol)) containing
estimated variances and covariances for elements of &quot;beta&quot;.
These are conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their RML estimates.
</p>
</td></tr>
<tr><td><code>b.hat</code></td>
<td>

<p>a matrix with length(zcol) rows and m columns, where
b.hat[,i] is an empirical Bayes estimate of bi.
</p>
</td></tr>
<tr><td><code>cov.b</code></td>
<td>

<p>an array of dimension length(zcol) by length(zcol) by m,
where cov.b[,,i] is an empirical Bayes estimate of the
covariance matrix associated with bi. These are
conventional estimates which regard the variance
parameters (sigma2 and psi) as fixed at their RML estimates.
</p>
</td></tr>
<tr><td><code>cov.beta.new</code></td>
<td>

<p>matrix of dimension c(length(xcol),length(xcol)) containing
estimated variances and covariances for elements of &quot;beta&quot;.
These are improved estimates which account for uncertainty
in estimating the variance parameters (sigma2 and psi).
</p>
</td></tr>
<tr><td><code>cov.b.new</code></td>
<td>

<p>an array of dimension length(zcol) by length(zcol) by m,
where cov.b.new[,,i] is an estimated covariance matrix 
for bi. These are improved estimates which account for
uncertainty in estimating the variance parameters (sigma2
and psi).
</p>
</td></tr>
<tr><td><code>cov.b.beta.new</code></td>
<td>

<p>an array of dimension length(zcol) by length(xcol) by m,
where cov.b.beta.new[,,i] contains the estimated covariances
bewteen bi and beta. These are improved estimates which account
for uncertainty in estimating the variance parameters (sigma2
and psi). Note that conventional estimates which regard
sigma2 and psi as fixed assume zero covariance between
each bi and beta.
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+ecmerml">ecmerml</a></code>,
<code><a href="#topic+fastml">fastml</a></code>, <code><a href="#topic+fastmode">fastmode</a></code>,
<code><a href="#topic+mgibbs">mgibbs</a></code>, <code><a href="#topic+fastmcmc">fastmcmc</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.


## End(Not run)</code></pre>

<hr>
<h2 id='marijuana'>A pilot study of the clinical and psychological effects of maarijuana</h2><span id='topic+marijuana'></span>

<h3>Description</h3>

<p>Nine male subjects were given three treatments in the form of low-dose, high-dose,
and placebo cigarettes. The order of treatments within subjects was balanced in a
replicated 3 x 3 Latin square, but because the order for each subject was not
reported in the article, (I shall proceed as if) the order effects are negligible.
Changes in heart rate were recorded 15 and 90 minutes after marijuana use, and
five of the 54 data values are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(marijuana)</code></pre>


<h3>Format</h3>

<p>A data frame</p>


<h3>Source</h3>

<p>Wei AT, Zinberg NE, Nelson JM. Clinical and psychological effects of 
marijuana in man. Science 1968; 162:1234-1242</p>

<hr>
<h2 id='mgibbs'>
Modified Gibbs sampler for Bayesian inference in linear mixed
models
</h2><span id='topic+mgibbs'></span>

<h3>Description</h3>

<p>Simulates posterior draws of parameters in linear mixed models
using a Markov chain Monte Carlo (MCMC) procedure, the
modified Gibbs sampler described by Schafer (1998). This algorithm
may be slow, requiring a large number of cycles to achieve
stationarity. In most cases, &quot;fastmcmc&quot; will perform
better. This algorithm is provided mainly for comparison
against &quot;fastmcmc&quot;.
</p>
<p>For a description of the model and the prior distribution, see
the &quot;Details&quot; section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgibbs(y, subj, pred, xcol, zcol, prior, seed, vmax, occ,
   start, iter=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgibbs_+3A_y">y</code></td>
<td>

<p>vector of responses. This is simply the individual yi vectors
stacked upon one another. Each element of y represents the 
observed response for a particular subject-occasion, or for a
particular unit within a cluster.
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_subj">subj</code></td>
<td>

<p>vector of same length as y, giving the subject (or cluster)
indicators i for the elements of y. For example, suppose 
that y is c(y1,y2,y3,y4) where length(y1)=2, length(y2)=3,
length(y3)=2, and length(y4)=7. Then subj should be
c(1,1,2,2,2,3,3,4,4,4,4,4,4,4).
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_pred">pred</code></td>
<td>

<p>matrix of covariates used to predict y. The number of rows
should be length(y). The first column will typically be
constant (one), and the remaining columns correspond to other
variables appearing in Xi and Zi.
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_xcol">xcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Xi. That is, pred[,xcol] is the Xi matrices (stacked
upon one another.
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_zcol">zcol</code></td>
<td>

<p>vector of integers indicating which columns of pred will be
used in Zi. That is, pred[,zcol] is the Zi matrices (stacked
upon one another).
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_prior">prior</code></td>
<td>

<p>A list with four components specifying the hyperparameters of
the prior distribution applied to sigma2 and psi. The
components must be named &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;Dinv&quot;. All are
scalars except for &quot;Dinv&quot;, which is a matrix of dimension
c(length(zcol),length(zcol)).
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_seed">seed</code></td>
<td>

<p>Seed for random number generator. This should be a positive
integer. 
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_vmax">vmax</code></td>
<td>

<p>optional matrix of dimension c(max(occ),max(occ)) from which
the Vi matrices will be extracted. In a longitudinal dataset, 
vmax would represent the Vi matrix for an individual with
responses at all possible occasions 1,2,...,nmax=max(occ);
for individuals with responses at only a subset of these
occasions, the Vi will be obtained by extracting the rows
and columns of vmax for those occasions. If no vmax is
specified by the user, an identity matrix is used. In most
applications of this model one will want to have Vi =
identity, so most of the time this argument can be omitted.
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_occ">occ</code></td>
<td>

<p>vector of same length as y indicating the &quot;occasions&quot; for the
elements of y. This argument is relevant only if a
non-identity vmax is specified. In a longitudinal dataset
where each individual is measured on at most nmax distinct
occasions, each element of y corresponds to one
subject-occasion, and the elements of occ should be coded as
1,2,...,nmax to indicate these occasion labels. (You should
label the occasions as 1,2,...,nmax even if they are not
equally spaced in time; the actual times of measurement will
be incorporated into the matrix &quot;pred&quot;.) 
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_start">start</code></td>
<td>

<p>optional starting values of the parameters. If this argument
is not given then the function chooses its own starting values.
This argument should be a list of three elements named
&quot;beta&quot;, &quot;psi&quot;, and &quot;sigma2&quot;. Note that &quot;beta&quot; should be a
vector of the same length as &quot;xcol&quot;, &quot;psi&quot; should be a
matrix of dimension c(length(zcol),length(zcol)), and
&quot;sigma2&quot; should be a scalar.
</p>
</td></tr>
<tr><td><code id="mgibbs_+3A_iter">iter</code></td>
<td>

<p>number of cycles of the modified Gibbs sampler to be
performed. 
</p>
</td></tr></table>


<h3>Details</h3>

<p>The algorithm is described in Section 5 of Schafer (1998).
</p>
<p>The model, which is typically applied to longitudinal or
clustered responses, is 
</p>
<p>yi = Xi%*%beta + Zi%*%bi + ei ,    i=1,...,m,
</p>
<p>where
</p>
<p>yi    = (ni x 1) response vector for subject
or cluster i;
Xi    = (ni x p) matrix of covariates;
Zi    =	(ni x q) matrix of covariates;
beta  = (p x 1) vector of coefficients common to the
population (fixed effects);
bi    = (q x 1) vector of coefficients specific to
subject or cluster i (random effects); and
ei    = (ni x 1) vector of residual errors.
</p>
<p>The vector bi is assumed to be normally distributed
with mean zero and unstructured covariance matrix psi, 
</p>
<p>bi <code class="reqn">\sim</code> N(0,psi) independently for i=1,...,m.
</p>
<p>The residual vector ei is assumed to be
</p>
<p>ei <code class="reqn">\sim</code> N(0,sigma2*Vi)
</p>
<p>where Vi is a known (ni x ni) matrix. In most applications,
Vi is the identity matrix.
</p>
<p>The prior distribution applied to the within-unit residual
variance is scaled inverted-chisquare,
</p>
<p>sigma2 <code class="reqn">\sim</code> a / chisq(b),
</p>
<p>where chisq(b) denotes a chisquare random variable with b
degrees of freedom, and a and b are user-defined
hyperparameters. Values for the hyperparmeters may be chosen
by regarding a/b as a rough prior guess for sigma2, and as
the imaginary degrees of freedom on which this guess is based.
</p>
<p>The prior distribution applied to the between-unit covariance
matrix is inverted Wishart,
</p>
<p>psiinv <code class="reqn">\sim</code> W(c,D),
</p>
<p>where psiinv is the inverse of the between-unit covariance
matrix psi, and W(c,D) denotes a Wishart distribution with
degrees of freedom c and scale matrix D. Values for the
hyperparameters may be chosen by regarding Dinv/c (the inverse
of D divided by c) as a rough prior guess for psi, and c as
the imaginary degrees of freedom on which this guess is based.
</p>
<p>An improper uniform prior density function is applied to
the fixed effects beta.
</p>


<h3>Value</h3>

<p>a list containing the following components.
</p>
<table>
<tr><td><code>beta</code></td>
<td>

<p>simulated value of coefficients beta after &quot;iter&quot; cycles of
the modified Gibbs sampler. This is a vector of the same
length as xcol.
</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>

<p>simulated value of the residual variance sigma2 after &quot;iter&quot;
cycles of the modified Gibbs sampler.
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>simulated value of the between-unit covariance matrix psi
after &quot;iter&quot; cycles of the modified Gibbs sampler.
</p>
</td></tr>
<tr><td><code>sigma2.series</code></td>
<td>

<p>vector of length &quot;iter&quot; containing the entire history of
simulated values of sigma2. That is, sigma2.series[t] contains
the value of sigma2 at cycle t.
</p>
</td></tr>
<tr><td><code>psi.series</code></td>
<td>

<p>array of dimension c(length(zcol),length(zcol),iter)
containing the entire history of simulated values of psi. That
is, psi.series[,,t] contains the value of psi at cycle t.
</p>
</td></tr></table>


<h3>References</h3>

<p>Schafer, J.L. (1998) Some improved procedures for linear mixed
models. Submitted to Journal of the American Statistical
Association.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ecmeml">ecmeml</a></code>, <code><a href="#topic+ecmerml">ecmerml</a></code>,
<code><a href="#topic+fastml">fastml</a></code>, <code><a href="#topic+fastrml">fastrml</a></code>,
<code><a href="#topic+fastmode">fastmode</a></code>, <code><a href="#topic+fastmcmc">fastmcmc</a></code>,
<code><a href="#topic+example">example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
For a detailed example, see the file "example.R" distributed
with this library.


## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
