<!DOCTYPE html><html lang="en"><head><title>Help for package epikit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epikit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#epikit-package'><p>epikit: Miscellaneous Helper Tools for Epidemiologists</p></a></li>
<li><a href='#add_weights_cluster'><p>Add a column of cluster survey weights to a data frame.</p></a></li>
<li><a href='#add_weights_strata'><p>Add a column of stratified survey weights to a data frame.</p>
For use in surveys where you took a sample population out of a larger
source population, with a simple-random or stratified survey design.</a></li>
<li><a href='#age_categories'><p>Create an age group variable</p></a></li>
<li><a href='#attack_rate'><p>Rates and Ratios</p></a></li>
<li><a href='#dots_to_charlist'><p>Convert dots to a list of character vectors</p></a></li>
<li><a href='#fac_from_num'><p>create factors from numbers</p></a></li>
<li><a href='#find_breaks'><p>Automatically calculate breaks for a number</p></a></li>
<li><a href='#find_date_cause'><p>Find the first date beyond a cutoff in several columns</p></a></li>
<li><a href='#fmt_ci'><p>Helper to format confidence interval for text</p></a></li>
<li><a href='#fmt_count'><p>Counts and proportions inline</p></a></li>
<li><a href='#gen_polygon'><p>Fake spatial data as polygons</p>
This function returns a polygon which is split in to regions based on a
supplied vector of names</a></li>
<li><a href='#gen_population'><p>Generate population counts from estimated population age breakdowns.</p></a></li>
<li><a href='#rename_redundant'><p>Cosmetically relabel all columns that contains a certain pattern</p></a></li>
<li><a href='#unite_ci'><p>Unite estimates and confidence intervals</p></a></li>
<li><a href='#zcurve'><p>Create a curve comparing observed Z-scores to the WHO standard.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Miscellaneous Helper Tools for Epidemiologists</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains tools for formatting inline code, renaming redundant
  columns, aggregating age categories, adding survey weights, finding the earliest
  date of an event, plotting z-curves, generating population counts and 
  calculating proportions with confidence intervals. This is part of the 
  'R4Epis' project <a href="https://r4epis.netlify.app/">https://r4epis.netlify.app/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>binom, scales, dplyr (&ge; 1.0.2), rlang, forcats, tidyr (&ge;
1.0.0), tibble (&ge; 3.0.0), glue, tidyselect, ggplot2, sf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), outbreaks, epidict, covr, knitr,
magrittr, rmarkdown</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://r4epi.github.io/drat">https://r4epi.github.io/drat</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/R4EPI/epikit">https://github.com/R4EPI/epikit</a>, <a href="https://r4epis.netlify.app">https://r4epis.netlify.app</a>,
<a href="https://r4epi.github.io/epikit/">https://r4epi.github.io/epikit/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/R4EPI/epikit/issues">https://github.com/R4EPI/epikit/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>R4EPI/epidict</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-22 23:59:15 UTC; zhian</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Spina <a href="https://orcid.org/0000-0001-8425-1867"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dirk Schumacher [aut],
  Kate Doyle [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhian N. Kamvar &lt;zkamvar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 07:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='epikit-package'>epikit: Miscellaneous Helper Tools for Epidemiologists</h2><span id='topic+epikit'></span><span id='topic+epikit-package'></span>

<h3>Description</h3>

<p>Contains tools for formatting inline code, renaming redundant columns, aggregating age categories, adding survey weights, finding the earliest date of an event, plotting z-curves, generating population counts and calculating proportions with confidence intervals. This is part of the 'R4Epis' project <a href="https://r4epis.netlify.app/">https://r4epis.netlify.app/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zhian N. Kamvar <a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a> (<a href="https://orcid.org/0000-0003-1458-7108">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Alexander Spina <a href="mailto:aspina@appliedepi.org">aspina@appliedepi.org</a> (<a href="https://orcid.org/0000-0001-8425-1867">ORCID</a>)
</p>
</li>
<li><p> Dirk Schumacher <a href="mailto:mai@dirk-schumacher.net">mai@dirk-schumacher.net</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kate Doyle [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/R4EPI/epikit">https://github.com/R4EPI/epikit</a>
</p>
</li>
<li> <p><a href="https://r4epis.netlify.app">https://r4epis.netlify.app</a>
</p>
</li>
<li> <p><a href="https://r4epi.github.io/epikit/">https://r4epi.github.io/epikit/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/R4EPI/epikit/issues">https://github.com/R4EPI/epikit/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_weights_cluster'>Add a column of cluster survey weights to a data frame.</h2><span id='topic+add_weights_cluster'></span>

<h3>Description</h3>

<p>For use in surveys where you took a sample population out of a larger
source population, with a cluster survey design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_weights_cluster(
  x,
  cl,
  eligible,
  interviewed,
  cluster_x = NULL,
  cluster_cl = NULL,
  household_x = NULL,
  household_cl = NULL,
  ignore_cluster = TRUE,
  ignore_household = TRUE,
  surv_weight = "surv_weight",
  surv_weight_ID = "surv_weight_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_weights_cluster_+3A_x">x</code></td>
<td>
<p>a data frame of survey data</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_cl">cl</code></td>
<td>
<p>a data frame containing a list of clusters and the number of
households in each.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_eligible">eligible</code></td>
<td>
<p>the column in <code>x</code> which specifies the number of people
eligible for being interviewed in that household. (e.g. the total number of
children)</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_interviewed">interviewed</code></td>
<td>
<p>the column in <code>x</code> which specifies the number of people
actually interviewed in that household.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_cluster_x">cluster_x</code></td>
<td>
<p>the column in <code>x</code> that indicates which cluster rows belong
to. Ignored if <code>ignore_cluster</code> is TRUE.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_cluster_cl">cluster_cl</code></td>
<td>
<p>the column in <code>cl</code> that lists all possible clusters.
Ignored if <code>ignore_cluster</code> is TRUE.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_household_x">household_x</code></td>
<td>
<p>the column in <code>x</code> that indicates a unique household
identifier. Ignored if <code>ignore_household</code> is TRUE.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_household_cl">household_cl</code></td>
<td>
<p>the column in <code>cl</code> that lists the number of households
per cluster.  Ignored if <code>ignore_household</code> is TRUE.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_ignore_cluster">ignore_cluster</code></td>
<td>
<p>If TRUE (default), set the weight for clusters to be 1.
This assumes that your sample was taken in a way which is a close
approximation of a simple random sample. Ignores inputs from <code>cluster_cl</code>
as well as <code>cluster_x</code>.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_ignore_household">ignore_household</code></td>
<td>
<p>If TRUE (default), set the weight for households to
be 1. This assumes that your sample of households was takenin a way which
is a close approximation of a simple random sample. Ignores inputs from
<code>household_cl</code> and <code>household_x</code>.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_surv_weight">surv_weight</code></td>
<td>
<p>the name of the new column to store the weights. Defaults
to &quot;surv_weight&quot;.</p>
</td></tr>
<tr><td><code id="add_weights_cluster_+3A_surv_weight_id">surv_weight_ID</code></td>
<td>
<p>the name of the new ID column to be created. Defaults
to &quot;surv_weight_ID&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will multiply the inverse chances of a cluster being selected, a household
being selected within a cluster, and an individual being selected within a
household.
</p>
<p>As follows:
</p>
<div class="sourceCode"><pre>((clusters available) / (clusters surveyed)) *
((households in each cluster) / (households surveyed in each cluster)) *
((individuals eligible in each household) / (individuals interviewed))
</pre></div>
<p>In the case where both ignore_cluster and ignore_household are TRUE, this
will simply be:
</p>
<div class="sourceCode"><pre>1 * 1 * (individuals eligible in each household) / (individuals interviewed)
</pre></div>


<h3>Author(s)</h3>

<p>Alex Spina, Zhian N. Kamvar, Lukas Richter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# define a fake dataset of survey data
# including household and individual information
x &lt;- data.frame(stringsAsFactors=FALSE,
         cluster = c("Village A", "Village A", "Village A", "Village A",
                     "Village A", "Village B", "Village B", "Village B"),
    household_id = c(1, 1, 1, 1, 2, 2, 2, 2),
      eligible_n = c(6, 6, 6, 6, 6, 3, 3, 3),
      surveyed_n = c(4, 4, 4, 4, 4, 3, 3, 3),
   individual_id = c(1, 2, 3, 4, 4, 1, 2, 3),
         age_grp = c("0-10", "20-30", "30-40", "50-60", "50-60", "20-30",
                     "50-60", "30-40"),
             sex = c("Male", "Female", "Male", "Female", "Female", "Male",
                     "Female", "Female"),
         outcome = c("Y", "Y", "N", "N", "N", "N", "N", "Y")
)

# define a fake dataset of cluster listings
# including cluster names and number of households
cl &lt;- tibble::tribble(
     ~cluster, ~n_houses,
  "Village A",        23,
  "Village B",        42,
  "Village C",        56,
  "Village D",        38
)


# add weights to a cluster sample
# include weights for cluster, household and individual levels
add_weights_cluster(x, cl = cl,
                    eligible = eligible_n,
                    interviewed = surveyed_n,
                    cluster_cl = cluster, household_cl = n_houses,
                    cluster_x = cluster,  household_x = household_id,
                    ignore_cluster = FALSE, ignore_household = FALSE)


# add weights to a cluster sample
# ignore weights for cluster and household level (set equal to 1)
# only include weights at individual level
add_weights_cluster(x, cl = cl,
                    eligible = eligible_n,
                    interviewed = surveyed_n,
                    cluster_cl = cluster, household_cl = n_houses,
                    cluster_x = cluster,  household_x = household_id,
                    ignore_cluster = TRUE, ignore_household = TRUE)

</code></pre>

<hr>
<h2 id='add_weights_strata'>Add a column of stratified survey weights to a data frame.
For use in surveys where you took a sample population out of a larger
source population, with a simple-random or stratified survey design.</h2><span id='topic+add_weights_strata'></span>

<h3>Description</h3>

<p>Creates weight based on dividing stratified population counts from the source
population by surveyed counts in the sample population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_weights_strata(
  x,
  p,
  ...,
  population = population,
  surv_weight = "surv_weight",
  surv_weight_ID = "surv_weight_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_weights_strata_+3A_x">x</code></td>
<td>
<p>a data frame of survey data</p>
</td></tr>
<tr><td><code id="add_weights_strata_+3A_p">p</code></td>
<td>
<p>a data frame containing population data for groups in <code>...</code></p>
</td></tr>
<tr><td><code id="add_weights_strata_+3A_...">...</code></td>
<td>
<p>shared grouping columns across both <code>x</code> and <code>p</code>. These are used
to match the weights to the correct subset of the population.</p>
</td></tr>
<tr><td><code id="add_weights_strata_+3A_population">population</code></td>
<td>
<p>the column in <code>p</code> that defines the population numbers</p>
</td></tr>
<tr><td><code id="add_weights_strata_+3A_surv_weight">surv_weight</code></td>
<td>
<p>the name of the new column to store the weights. Defaults to
&quot;surv_weight&quot;.</p>
</td></tr>
<tr><td><code id="add_weights_strata_+3A_surv_weight_id">surv_weight_ID</code></td>
<td>
<p>the name of the new ID column to be created. Defaults to
&quot;surv_weight_ID&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar Alex Spina Lukas Richter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define a fake dataset of survey data
# including household and individual information
x &lt;- data.frame(stringsAsFactors=FALSE,
         cluster = c("Village A", "Village A", "Village A", "Village A",
                     "Village A", "Village B", "Village B", "Village B"),
    household_id = c(1, 1, 1, 1, 2, 2, 2, 2),
     eligibile_n = c(6, 6, 6, 6, 6, 3, 3, 3),
      surveyed_n = c(4, 4, 4, 4, 4, 3, 3, 3),
   individual_id = c(1, 2, 3, 4, 4, 1, 2, 3),
         age_grp = c("0-10", "20-30", "30-40", "50-60", "50-60", "20-30",
                     "50-60", "30-40"),
             sex = c("Male", "Female", "Male", "Female", "Female", "Male",
                     "Female", "Female"),
         outcome = c("Y", "Y", "N", "N", "N", "N", "N", "Y")
)

# define a fake population data set
# including age group, sex, counts and proportions
p &lt;- epikit::gen_population(total = 10000,
  groups = c("0-10", "10-20", "20-30", "30-40", "40-50", "50-60"),
  proportions = c(0.1, 0.2, 0.3, 0.4, 0.2, 0.1))

  # make sure col names match survey dataset
p &lt;- dplyr::rename(p, age_grp = groups, sex = strata, population = n)

# add weights to a stratified simple random sample
# weight based on age group and sex
add_weights_strata(x, p = p, age_grp, sex, population = population)

</code></pre>

<hr>
<h2 id='age_categories'>Create an age group variable</h2><span id='topic+age_categories'></span><span id='topic+group_age_categories'></span>

<h3>Description</h3>

<p>Create an age group variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_categories(
  x,
  breakers = NULL,
  lower = 0,
  upper = NULL,
  by = 10,
  separator = "-",
  ceiling = FALSE,
  above.char = "+"
)

group_age_categories(
  dat,
  years = NULL,
  months = NULL,
  weeks = NULL,
  days = NULL,
  one_column = TRUE,
  drop_empty_overlaps = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_categories_+3A_x">x</code></td>
<td>
<p>Your age variable</p>
</td></tr>
<tr><td><code id="age_categories_+3A_breakers">breakers</code></td>
<td>
<p>A string. Age category breaks you can define within c().
Alternatively use &quot;lower&quot;, &quot;upper&quot; and &quot;by&quot; to set these breaks based on a
sequence.</p>
</td></tr>
<tr><td><code id="age_categories_+3A_lower">lower</code></td>
<td>
<p>A number. The lowest age value you want to consider (default is 0)</p>
</td></tr>
<tr><td><code id="age_categories_+3A_upper">upper</code></td>
<td>
<p>A number. The highest age value you want to consider</p>
</td></tr>
<tr><td><code id="age_categories_+3A_by">by</code></td>
<td>
<p>A number. The number of years you want between groups</p>
</td></tr>
<tr><td><code id="age_categories_+3A_separator">separator</code></td>
<td>
<p>A character that you want to have between ages in group
names. The default is &quot;-&quot; producing e.g. 0-10.</p>
</td></tr>
<tr><td><code id="age_categories_+3A_ceiling">ceiling</code></td>
<td>
<p>A TRUE/FALSE variable. Specify whether you would like the
highest value in your breakers, or alternatively the upper value specified,
to be the endpoint. This would produce the highest group of &quot;70-80&quot; rather
than &quot;80+&quot;. The default is FALSE (to produce a group of 80+).</p>
</td></tr>
<tr><td><code id="age_categories_+3A_above.char">above.char</code></td>
<td>
<p>Only considered when ceiling == FALSE.  A character that
you want to have after your highest age group. The default is &quot;+&quot; producing
e.g. 80+</p>
</td></tr>
<tr><td><code id="age_categories_+3A_dat">dat</code></td>
<td>
<p>a data frame with at least one column defining an age category</p>
</td></tr>
<tr><td><code id="age_categories_+3A_years">years</code>, <code id="age_categories_+3A_months">months</code>, <code id="age_categories_+3A_weeks">weeks</code>, <code id="age_categories_+3A_days">days</code></td>
<td>
<p>the bare name of the column defining years,
months, weeks, or days (or NULL if the column doesn't exist)</p>
</td></tr>
<tr><td><code id="age_categories_+3A_one_column">one_column</code></td>
<td>
<p>if <code>TRUE</code> (default), the categories will be joined into a
single column called &quot;age_category&quot; that appends the type of age category
used. If <code>FALSE</code>, there will be one column with the grouped age categories
called &quot;age_category&quot; and a second column indicating age unit called
&quot;age_unit&quot;.</p>
</td></tr>
<tr><td><code id="age_categories_+3A_drop_empty_overlaps">drop_empty_overlaps</code></td>
<td>
<p>if <code>TRUE</code>, unused levels are dropped if they have
been replaced by a more fine-grained definition and are empty. Practically,
this means that the first level for years, months, and weeks are in
consideration for being removed via <code><a href="forcats.html#topic+fct_drop">forcats::fct_drop()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor representing age ranges, open at the upper end of the range.
</p>
<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive() &amp;&amp; require("dplyr") &amp;&amp; require("epidict")) {
withAutoprint({
set.seed(50)
dat &lt;- epidict::gen_data("Cholera", n = 100, org = "MSF")
ages &lt;- dat %&gt;%
  select(starts_with("age")) %&gt;%
  mutate(age_years = age_categories(age_years, breakers = c(0, 5, 10, 15, 20))) %&gt;%
  mutate(age_months = age_categories(age_months, breakers = c(0, 5, 10, 15, 20))) %&gt;%
  mutate(age_days = age_categories(age_days, breakers = c(0, 5, 15)))

ages %&gt;%
  group_age_categories(years = age_years, months = age_months, days = age_days) %&gt;%
  pull(age_category) %&gt;%
  table()
})
}
</code></pre>

<hr>
<h2 id='attack_rate'>Rates and Ratios</h2><span id='topic+attack_rate'></span><span id='topic+case_fatality_rate'></span><span id='topic+case_fatality_rate_df'></span><span id='topic+mortality_rate'></span>

<h3>Description</h3>

<p>Calculate attack rate, case fatality rate, and mortality rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attack_rate(
  cases,
  population,
  conf_level = 0.95,
  multiplier = 100,
  mergeCI = FALSE,
  digits = 2
)

case_fatality_rate(
  deaths,
  population,
  conf_level = 0.95,
  multiplier = 100,
  mergeCI = FALSE,
  digits = 2
)

case_fatality_rate_df(
  x,
  deaths,
  group = NULL,
  conf_level = 0.95,
  multiplier = 100,
  mergeCI = FALSE,
  digits = 2,
  add_total = FALSE
)

mortality_rate(
  deaths,
  population,
  conf_level = 0.95,
  multiplier = 10^4,
  mergeCI = FALSE,
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attack_rate_+3A_cases">cases</code>, <code id="attack_rate_+3A_deaths">deaths</code></td>
<td>
<p>number of cases or deaths in a population. For <code style="white-space: pre;">&#8288;_df&#8288;</code>
functions, this can be the name of a logical column OR an evaluated
logical expression (see examples).</p>
</td></tr>
<tr><td><code id="attack_rate_+3A_population">population</code></td>
<td>
<p>the number of individuals in the population.</p>
</td></tr>
<tr><td><code id="attack_rate_+3A_conf_level">conf_level</code></td>
<td>
<p>a number representing the confidence level for which to
calculate the confidence interval. Defaults to 0.95, representing a 95%
confidence interval using <code><a href="binom.html#topic+binom.confint">binom::binom.wilson()</a></code></p>
</td></tr>
<tr><td><code id="attack_rate_+3A_multiplier">multiplier</code></td>
<td>
<p>The base by which to multiply the output:
</p>

<ul>
<li> <p><code>multiplier = 1</code>: ratio between 0 and 1
</p>
</li>
<li> <p><code>multiplier = 100</code>: proportion
</p>
</li>
<li> <p><code>multiplier = 10^4</code>: x per 10,000 people
</p>
</li></ul>
</td></tr>
<tr><td><code id="attack_rate_+3A_mergeci">mergeCI</code></td>
<td>
<p>Whether or not to put the confidence intervals in one column (default is FALSE)</p>
</td></tr>
<tr><td><code id="attack_rate_+3A_digits">digits</code></td>
<td>
<p>if <code>mergeCI = TRUE</code>, this determines how many digits are printed</p>
</td></tr>
<tr><td><code id="attack_rate_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="attack_rate_+3A_group">group</code></td>
<td>
<p>the bare name of a column to use for stratifying the output</p>
</td></tr>
<tr><td><code id="attack_rate_+3A_add_total">add_total</code></td>
<td>
<p>if <code>group</code> is not NULL, then this will add a row containing
the total value across all groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with five columns that represent the numerator,
denominator, rate, lower bound, and upper bound.
</p>

<ul>
<li> <p><code>attack_rate()</code>: cases, population, ar, lower, upper
</p>
</li>
<li> <p><code>case_fatality_rate()</code>: deaths, population, cfr, lower, upper
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Attack rates can be calculated with just two numbers
print(ar &lt;- attack_rate(10, 50), digits = 4) # 20% attack rate

# print them inline using `fmt_ci_df()`
fmt_ci_df(ar)

# Alternatively, if you want one column for the CI, use `mergeCI = TRUE`
attack_rate(10, 50, mergeCI = TRUE, digits = 2) # 20% attack rate

print(cfr &lt;- case_fatality_rate(1, 100), digits = 2) # CFR of 1%
fmt_ci_df(cfr)

# using a data frame
if (require("outbreaks")) {
  withAutoprint({
  e &lt;- outbreaks::ebola_sim$linelist
  case_fatality_rate_df(e,
    outcome == "Death",
    group = gender,
    add_total = TRUE,
    mergeCI = TRUE
  )
  })
}
</code></pre>

<hr>
<h2 id='dots_to_charlist'>Convert dots to a list of character vectors</h2><span id='topic+dots_to_charlist'></span>

<h3>Description</h3>

<p>This function is intended to allow the user to use NSE within their dot
calls for the express purpose of renaming functions. This function is
intended for internal use to be passed to other MSF packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots_to_charlist(parent = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dots_to_charlist_+3A_parent">parent</code></td>
<td>
<p>the level of the parent function. Defaults to 1, which
selects the dots from the immediate parent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of character vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- function(...) {
  dots_to_charlist()
}
x(a = 1, b = TRUE, c = three)
</code></pre>

<hr>
<h2 id='fac_from_num'>create factors from numbers</h2><span id='topic+fac_from_num'></span>

<h3>Description</h3>

<p>If the number of unique numbers is five or fewer, then they will simply
be converted to factors in order, otherwise, they will be passed to cut and
pretty, preserving the lowest value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac_from_num(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fac_from_num_+3A_x">x</code></td>
<td>
<p>a vector of integers or numerics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fac_from_num(1:100)
fac_from_num(sample(100, 5))
</code></pre>

<hr>
<h2 id='find_breaks'>Automatically calculate breaks for a number</h2><span id='topic+find_breaks'></span>

<h3>Description</h3>

<p>Automatically calculate breaks for a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_breaks(n, breaks = 4, snap = 1, ceiling = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_breaks_+3A_n">n</code></td>
<td>
<p>a number to calcluate breaks for</p>
</td></tr>
<tr><td><code id="find_breaks_+3A_breaks">breaks</code></td>
<td>
<p>the maximum number of segments you want to have</p>
</td></tr>
<tr><td><code id="find_breaks_+3A_snap">snap</code></td>
<td>
<p>the number defining where to snap to the nearest factor</p>
</td></tr>
<tr><td><code id="find_breaks_+3A_ceiling">ceiling</code></td>
<td>
<p>if <code>TRUE</code>, n is included in the breaks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of integers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# find four breaks from 1 to 100
find_breaks(100)

# find four breaks from 1 to 123, rounding to the nearest 20
find_breaks(123, snap = 20)

# note that there are only three breaks here because of the rounding
find_breaks(123, snap = 25)

# Include the value itself
find_breaks(123, snap = 25, ceiling = TRUE)
</code></pre>

<hr>
<h2 id='find_date_cause'>Find the first date beyond a cutoff in several columns</h2><span id='topic+find_date_cause'></span><span id='topic+find_start_date'></span><span id='topic+find_end_date'></span><span id='topic+constrain_dates'></span><span id='topic+assert_positive_timespan'></span>

<h3>Description</h3>

<p>This function will find the first date in an orderd series of columns that
is either before or after a cutoff date, inclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_date_cause(
  x,
  ...,
  period_start = NULL,
  period_end = NULL,
  datecol = "start_date",
  datereason = "start_date_reason",
  na_fill = "start"
)

find_start_date(
  x,
  ...,
  period_start = NULL,
  period_end = NULL,
  datecol = "start_date",
  datereason = "start_date_reason"
)

find_end_date(
  x,
  ...,
  period_start = NULL,
  period_end = NULL,
  datecol = "end_date",
  datereason = "end_date_reason"
)

constrain_dates(i, period_start, period_end, boundary = "both")

assert_positive_timespan(x, date_start, date_end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_date_cause_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_...">...</code></td>
<td>
<p>an ordered series of date columns (i.e. the most important date
to be considered first).</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_period_start">period_start</code>, <code id="find_date_cause_+3A_period_end">period_end</code></td>
<td>
<p>for the find_ functions, this should be the
name of a column in <code>x</code> that contains the start/end of the recall period.
For <code>constrain_dates</code>, this should be a vector of dates.</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_datecol">datecol</code></td>
<td>
<p>the name of the new column to contain the dates</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_datereason">datereason</code></td>
<td>
<p>the name of the column to contain the name of the column
from which the date came.</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_na_fill">na_fill</code></td>
<td>
<p>one of either &quot;before&quot; or &quot;after&quot; indicating that the new
column should only contain dates before or after the cutoff date.</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_i">i</code></td>
<td>
<p>a vector of dates</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_boundary">boundary</code></td>
<td>
<p>one of &quot;both&quot;, &quot;start&quot;, or &quot;end&quot;. Dates outside of the
boundary will be set to NA.</p>
</td></tr>
<tr><td><code id="find_date_cause_+3A_date_start">date_start</code>, <code id="find_date_cause_+3A_date_end">date_end</code></td>
<td>
<p>column name of a date vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  s1 = c(as.Date("2013-01-01") + 0:10, as.Date(c("2012-01-01", "2014-01-01"))),
  s2 = c(as.Date("2013-02-01") + 0:10, as.Date(c("2012-01-01", "2014-01-01"))),
  s3 = c(as.Date("2013-01-10") - 0:10, as.Date(c("2012-01-01", "2014-01-01"))),
  ps = as.Date("2012-12-31"),
  pe = as.Date("2013-01-09")
)
print(dd &lt;- find_date_cause(d, s1, s2, s3, period_start = ps, period_end = pe))
print(bb &lt;- find_date_cause(d, s1, s2, s3, period_start = ps, period_end = pe,
                            na_fill = "end", 
                            datecol = "enddate",
                            datereason = "endcause"))
find_date_cause(d, s3, s2, s1, period_start = ps, period_end = pe)

# works
assert_positive_timespan(dd, start_date, pe)

# returns a warning because the last date isn't later than the start_date
assert_positive_timespan(dd, start_date, s2)


with(d, constrain_dates(s1, ps, pe))
with(d, constrain_dates(s2, ps, pe))
with(d, constrain_dates(s3, ps, pe))

</code></pre>

<hr>
<h2 id='fmt_ci'>Helper to format confidence interval for text</h2><span id='topic+fmt_ci'></span><span id='topic+fmt_pci'></span><span id='topic+fmt_pci_df'></span><span id='topic+fmt_ci_df'></span>

<h3>Description</h3>

<p>This function is mainly used for placing in the text fields of Rmarkdown
reports. You can use it by writing it in something like this:
The CFR for Bamako is <code>`r fmt_ci_df(case_fatality_rate(10, 50))`</code> which
will render like this:
&quot;The CFR for Bamako is 20.00% (CI 11.24-33.04)&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt_ci(
  e = numeric(),
  l = numeric(),
  u = numeric(),
  digits = 2,
  percent = TRUE,
  separator = "-"
)

fmt_pci(
  e = numeric(),
  l = numeric(),
  u = numeric(),
  digits = 2,
  percent = TRUE,
  separator = "-"
)

fmt_pci_df(
  x,
  e = 3,
  l = e + 1,
  u = e + 2,
  digits = 2,
  percent = TRUE,
  separator = "-"
)

fmt_ci_df(
  x,
  e = 3,
  l = e + 1,
  u = e + 2,
  digits = 2,
  percent = TRUE,
  separator = "-"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmt_ci_+3A_e">e</code></td>
<td>
<p>the column of the estimate (defaults to the third column). Otherwise, a number</p>
</td></tr>
<tr><td><code id="fmt_ci_+3A_l">l</code></td>
<td>
<p>the column of the lower bound (defaults to the fourth column). Otherwise, a number</p>
</td></tr>
<tr><td><code id="fmt_ci_+3A_u">u</code></td>
<td>
<p>the column of the upper bound (defaults to the fifth column), otherwise, a number</p>
</td></tr>
<tr><td><code id="fmt_ci_+3A_digits">digits</code></td>
<td>
<p>the number of digits to show</p>
</td></tr>
<tr><td><code id="fmt_ci_+3A_percent">percent</code></td>
<td>
<p>if <code>TRUE</code> (default), converts the number to percent, otherwise
it's treated as a raw value</p>
</td></tr>
<tr><td><code id="fmt_ci_+3A_separator">separator</code></td>
<td>
<p>what to separate lower and upper confidence intervals with,
default is &quot;-&quot;</p>
</td></tr>
<tr><td><code id="fmt_ci_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a text string in the format of &quot;e\
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cfr &lt;- data.frame(x = 1, y = 2, est = 0.5, lower = 0.25, upper = 0.75)
fmt_pci_df(cfr)

# If the data starts at a different column, specify a different number
fmt_pci_df(cfr[-1], 2, d = 1)

# It's also possible to provide numbers directly and remove the percent sign.
fmt_ci(pi, pi - runif(1), pi + runif(1), percent = FALSE)
</code></pre>

<hr>
<h2 id='fmt_count'>Counts and proportions inline</h2><span id='topic+fmt_count'></span>

<h3>Description</h3>

<p>These functions will give proportions for different variables inline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt_count(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmt_count_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="fmt_count_+3A_...">...</code></td>
<td>
<p>an expression or series of expressions to pass to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-element character vector of the format &quot;n (%)&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fmt_count(mtcars, cyl &gt; 3, hp &lt; 100)
fmt_count(iris, Species == "virginica")
</code></pre>

<hr>
<h2 id='gen_polygon'>Fake spatial data as polygons
This function returns a polygon which is split in to regions based on a
supplied vector of names</h2><span id='topic+gen_polygon'></span>

<h3>Description</h3>

<p>Fake spatial data as polygons
This function returns a polygon which is split in to regions based on a
supplied vector of names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_polygon(regions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_polygon_+3A_regions">regions</code></td>
<td>
<p>A string of names for each region to label the polygon with</p>
</td></tr>
</table>


<h3>References</h3>

<p>The coordinates used for the polygon are of Vienna, Austria.
based off government data (see <a href="https://www.data.gv.at/katalog/dataset/stadt-wien_bezirksgrenzenwien">metadata</a>)
</p>

<hr>
<h2 id='gen_population'>Generate population counts from estimated population age breakdowns.</h2><span id='topic+gen_population'></span>

<h3>Description</h3>

<p>This generates based on predefined age groups and proportions,
however you could also define these yourself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_population(
  total_pop = 1000,
  groups = c("0-4", "5-14", "15-29", "30-44", "45+"),
  strata = c("Male", "Female"),
  proportions = c(0.079, 0.134, 0.139, 0.082, 0.066),
  counts = NULL,
  tibble = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_population_+3A_total_pop">total_pop</code></td>
<td>
<p>The overal population count of interest - the default is
1000 people</p>
</td></tr>
<tr><td><code id="gen_population_+3A_groups">groups</code></td>
<td>
<p>A character vector of groups - the default is set for age
groups: c(&quot;0-4&quot;,&quot;5-14&quot;,&quot;15-29&quot;,&quot;30-44&quot;,&quot;45+&quot;)</p>
</td></tr>
<tr><td><code id="gen_population_+3A_strata">strata</code></td>
<td>
<p>A character vector for stratifying groups -
the default is set for gender: c(&quot;Male&quot;, &quot;Female&quot;)</p>
</td></tr>
<tr><td><code id="gen_population_+3A_proportions">proportions</code></td>
<td>
<p>A numeric vector specifying the proportions (as decimals)
for each group of the total_pop.
The default repeats c(0.079, 0.134, 0.139, 0.082, 0.067)
for strata.  However you can change this manually, make sure to
have the length equal to groups times strata (or half thereof).
These defaults are based of MSF general emergency intervention standard
values.</p>
</td></tr>
<tr><td><code id="gen_population_+3A_counts">counts</code></td>
<td>
<p>A numeric vector specifying the counts for each group.
The default is NULL - as most often proportions above will be used.
If is not NULL then total_pop and proportions will be ignored.
Make sure the length of this vector is equal to groups times strata (or if it
is half then it will repeat for each strata).
For reference, the MSF general emergency intervention standard values
are c(7945, 13391, 13861, 8138, 6665) based on above
groups for a 100,000 person population.</p>
</td></tr>
<tr><td><code id="gen_population_+3A_tibble">tibble</code></td>
<td>
<p>Return data as a tidyverse tibble (default is TRUE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get population counts based on proportion, unstratified
gen_population(groups = c(1, 2, 3, 4), 
               strata = NULL, 
               proportions = c(0.3, 0.2, 0.4, 0.1))

# get population counts based on proportion, stratified
gen_population(groups = c(1, 2, 3, 4), 
               strata = c("a", "b"), 
               proportions = c(0.3, 0.2, 0.4, 0.1))

# get population counts based on counts, unstratified
gen_population(groups = c(1, 2, 3, 4), 
               strata = NULL, 
               counts = c(20, 10, 30, 40))

# get population counts based on counts, stratified
gen_population(groups = c(1, 2, 3, 4), 
               strata = c("a", "b"), 
               counts = c(20, 10, 30, 40))

# get population counts based on counts, stratified - type out counts
# for each group and strata
gen_population(groups = c(1, 2, 3, 4), 
               strata = c("a", "b"), 
               counts = c(20, 10, 30, 40, 40, 30, 20, 20))
</code></pre>

<hr>
<h2 id='rename_redundant'>Cosmetically relabel all columns that contains a certain pattern</h2><span id='topic+rename_redundant'></span><span id='topic+augment_redundant'></span>

<h3>Description</h3>

<p>These function are only to be used cosmetically before kable and will
likely return a data frame with duplicate names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_redundant(x, ...)

augment_redundant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename_redundant_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="rename_redundant_+3A_...">...</code></td>
<td>
<p>a series of keys and values to replace columns that match specific
patterns.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> rename_redundant fully replaces any column names matching the keys
</p>
</li>
<li><p> augment_redundant will take a regular expression and rename columns
via <code><a href="base.html#topic+gsub">gsub()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>a data frame.
</p>


<h3>Author(s)</h3>

<p>Zhian N. Kamvar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  x = letters[1:10],
  `a n` = 1:10,
  `a prop` = (1:10) / 10,
  `a deff` = round(pi, 2),
  `b n` = 10:1,
  `b prop` = (10:1) / 10,
  `b deff` = round(pi * 2, 2),
  check.names = FALSE
)
df
print(df &lt;- rename_redundant(df, "%" = "prop", "Design Effect" = "deff"))
print(df &lt;- augment_redundant(df, " (n)" = " n$"))
</code></pre>

<hr>
<h2 id='unite_ci'>Unite estimates and confidence intervals</h2><span id='topic+unite_ci'></span><span id='topic+merge_ci_df'></span><span id='topic+merge_pci_df'></span>

<h3>Description</h3>

<p>create a character column by combining estimate, lower and upper columns.
This is similar to <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite_ci(
  x,
  col = NULL,
  ...,
  remove = TRUE,
  digits = 2,
  m100 = TRUE,
  percent = FALSE,
  ci = FALSE,
  separator = "-"
)

merge_ci_df(x, e = 3, l = e + 1, u = e + 2, digits = 2, separator = "-")

merge_pci_df(x, e = 3, l = e + 1, u = e + 2, digits = 2, separator = "-")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unite_ci_+3A_x">x</code></td>
<td>
<p>a data frame with at least three columns defining an estimate, lower
bounds, and upper bounds.</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_col">col</code></td>
<td>
<p>the quoted name of the replacement column to create</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_...">...</code></td>
<td>
<p>three columns to bind together in the order of Estimate, Lower, and
Upper.</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_remove">remove</code></td>
<td>
<p>if <code>TRUE</code> (default), the three columns in <code>...</code> will be replaced by <code>col</code></p>
</td></tr>
<tr><td><code id="unite_ci_+3A_digits">digits</code></td>
<td>
<p>the number of digits to retain for the confidence interval.</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_m100">m100</code></td>
<td>
<p><code>TRUE</code> if the result should be multiplied by 100</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_percent">percent</code></td>
<td>
<p><code>TRUE</code> if the result should have a percent symbol added.</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_ci">ci</code></td>
<td>
<p><code>TRUE</code> if the result should include &quot;CI&quot; within the braces (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_separator">separator</code></td>
<td>
<p>what to separate lower and upper confidence intervals with,
default is &quot;-&quot;</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_e">e</code></td>
<td>
<p>the column of the estimate (defaults to the third column). Otherwise, a number</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_l">l</code></td>
<td>
<p>the column of the lower bound (defaults to the fourth column). Otherwise, a number</p>
</td></tr>
<tr><td><code id="unite_ci_+3A_u">u</code></td>
<td>
<p>the column of the upper bound (defaults to the fifth column), otherwise, a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified data frame with merged columns or one additional column
representing the estimate and confidence interval
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- lm(100/mpg ~ disp + hp + wt + am, data = mtcars)
df  &lt;- data.frame(v = names(coef(fit)), e = coef(fit), confint(fit), row.names = NULL)
names(df) &lt;- c("variable", "estimate", "lower", "upper")
print(df)
unite_ci(df, "slope (CI)", estimate, lower, upper, m100 = FALSE, percent = FALSE)

</code></pre>

<hr>
<h2 id='zcurve'>Create a curve comparing observed Z-scores to the WHO standard.</h2><span id='topic+zcurve'></span>

<h3>Description</h3>

<p>Create a curve comparing observed Z-scores to the WHO standard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zcurve(x, zscore)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zcurve_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="zcurve_+3A_zscore">zscore</code></td>
<td>
<p>bare name of a numeric vector containing computed zscores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object that is customisable via the ggplot2 package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("ggplot2")
set.seed(9)
dat &lt;- data.frame(observed = rnorm(204) + runif(1),
                  skewed   = rnorm(204) + runif(1, 0.5)
                 ) # slightly skewed
zcurve(dat, observed) +
  labs(title = "Weight-for-Height Z-scores") +
  theme_classic()

zcurve(dat, skewed) +
  labs(title = "Weight-for-Height Z-scores") +
  theme_classic()

# Including different groups to facet
dat &lt;- data.frame(
  observed = c(rnorm(204) + runif(1), rnorm(204) + runif(1, 0.5)),
  groups   = rep(c("A", "B"), each = 204),
  treat    = sample(c('up', 'down'), 408, replace = TRUE)
                 )
zcurve(dat, observed) +
  facet_grid(treat~groups)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
