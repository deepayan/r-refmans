<!DOCTYPE html><html><head><title>Help for package ADAPTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ADAPTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AugmentSigMatrix'><p>Make an augmented signature matrix</p></a></li>
<li><a href='#buildSeed'><p>Build a deconvolution seed matrix, add the proportional option</p></a></li>
<li><a href='#buildSpilloverMat'><p>Build a spillover matrix</p></a></li>
<li><a href='#calcAcc'><p>Calculate prediction accuracy</p></a></li>
<li><a href='#clustWspillOver'><p>Cluster with spillover</p></a></li>
<li><a href='#collapseCellTypes'><p>Collapse cell types</p></a></li>
<li><a href='#estCellCounts.nPass'><p>Deconvolve with an n-pass spillover matrix</p></a></li>
<li><a href='#estCellPercent'><p>Wrapper for deconvolution methods</p></a></li>
<li><a href='#estCellPercent.DCQ'><p>DCQ Deconvolution</p></a></li>
<li><a href='#estCellPercent.DeconRNASeq'><p>DeconRNASeq deconvolution</p></a></li>
<li><a href='#estCellPercent.nnls'><p>Non-negative least squares deconvolution</p></a></li>
<li><a href='#estCellPercent.proportionsInAdmixture'><p>WGCNA::proportionsInAdmixture deconvolution</p></a></li>
<li><a href='#estCellPercent.spillOver'><p>Estimate cell percentage from spillover</p></a></li>
<li><a href='#estCellPercent.svmdecon'><p>SVMDECON deconvolution</p></a></li>
<li><a href='#findConvergenceIter'><p>Find out at which iteration the results converge, i.e. the mean results are stable.</p></a></li>
<li><a href='#getF1mcc'><p>Get f1 / mcc</p></a></li>
<li><a href='#getLM22cells'><p>LM22 look up table</p></a></li>
<li><a href='#gListFromRF'><p>Build a gList using random forest</p></a></li>
<li><a href='#hierarchicalClassify'><p>Hierarchical Deconvolution</p></a></li>
<li><a href='#hierarchicalSplit'><p>Build hierarchical cell clusters.</p></a></li>
<li><a href='#Licenses'>
<p>Licenses required by Celgene legal</p></a></li>
<li><a href='#LM22'>
<p>Leukocyte 22 data matrix</p></a></li>
<li><a href='#loadMGSM27'><p>Load MGSM27</p></a></li>
<li><a href='#loadModMap'><p>LM22 to xCell LUT</p></a></li>
<li><a href='#loopTillConvergence'><p>Loop testAllSigMatrices until convergence</p></a></li>
<li><a href='#matrixToGenelist'><p>Make a GSVA genelist</p></a></li>
<li><a href='#meanResults'><p>A meta analysis for the results from multiple iterations</p></a></li>
<li><a href='#MGSM27'>
<p>Myeloma Genome Signature Matrix 27</p></a></li>
<li><a href='#missForest.par'><p>Use parallel missForest to impute missing values.</p></a></li>
<li><a href='#plotKappas'><p>Plot condition numbers</p></a></li>
<li><a href='#rankByT'><p>Rank genes for each cell type</p></a></li>
<li><a href='#remakeLM22p'><p>Make an Augmented Signature Matrix</p></a></li>
<li><a href='#scSample'><p>Build groupSize pools according to cellIDs</p></a></li>
<li><a href='#shrinkByKappa'><p>Calculate conditions numbers for signature subsets</p></a></li>
<li><a href='#shrinkSigMatrix'><p>Shrink a signature matrix</p></a></li>
<li><a href='#spillToConvergence'><p>Spillover to convergence</p></a></li>
<li><a href='#splitSCdata'><p>Split a single cell dataset into multiple sets</p></a></li>
<li><a href='#SVMDECON'><p>Support vector machine deconvolution</p></a></li>
<li><a href='#testAllSigMatrices'><p>Generate all the signature matrices one time with the option to leave out half of the data as a test set</p></a></li>
<li><a href='#weightNorm'><p>SVMDECONV helper function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automated Deconvolution Augmentation of Profiles for Tissue
Specific Cells</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.22</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel A Danziger</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel A Danziger &lt;sam.danziger@gmail.com&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Bristol-Myers Squibb</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to construct (or add to) cell-type signature matrices using flow sorted or single cell samples and deconvolve bulk gene expression data.
    Useful for assessing the quality of single cell RNAseq experiments, estimating the accuracy of signature matrices, and determining cell-type spillover. 
    Please cite: Danziger SA et al. (2019) ADAPTS: Automated Deconvolution Augmentation of Profiles for Tissue Specific cells &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0224693">doi:10.1371/journal.pone.0224693</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>missForest, e1071, ComICS, pheatmap, doParallel, utils,
quantmod, preprocessCore, pcaMethods, foreach, nnls, ranger</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, DeconRNASeq, WGCNA</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-14 02:37:08 UTC; sdanzige</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-14 06:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='AugmentSigMatrix'>Make an augmented signature matrix</h2><span id='topic+AugmentSigMatrix'></span>

<h3>Description</h3>

<p>Build an augmented signature matrix from an initial signature matrix, source data, and a list of 
differentially expressed genes (gList).  The user might want to modify gList to make certain that particular 
genes are included in the matrix.  The algorithm will be to add one additional gene from each new cell type
Record the condition number, and plot those.  Will only consider adding rows shared by fullData and newData
</p>
<p>newMatData &lt;- AugmentSigMatrix(origMatrix, fullData, newData, gList)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AugmentSigMatrix(
  origMatrix,
  fullData,
  newData,
  gList,
  nGenes = 1:100,
  plotToPDF = TRUE,
  imputeMissing = TRUE,
  condTol = 1.01,
  postNorm = FALSE,
  minSumToRem = NA,
  addTitle = NULL,
  autoDetectMin = FALSE,
  calcSpillOver = FALSE,
  pdfDir = tempdir(),
  plotIt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AugmentSigMatrix_+3A_origmatrix">origMatrix</code></td>
<td>
<p>The original signature matrix</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_fulldata">fullData</code></td>
<td>
<p>The full data for the signature matrix</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_newdata">newData</code></td>
<td>
<p>The new data to add signatures from</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_glist">gList</code></td>
<td>
<p>The ordered list of genes from running rankByT() on newData. NOTE: best genes at the bottom!!</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_ngenes">nGenes</code></td>
<td>
<p>The number of additional genes to consider (DEFAULT: 1:100)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_plottopdf">plotToPDF</code></td>
<td>
<p>Plot the output condition numbers to a pdf file. (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_imputemissing">imputeMissing</code></td>
<td>
<p>Set to TRUE to impute missing values. NOTE: adds stoachasiticity (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_condtol">condTol</code></td>
<td>
<p>Setting higher tolerances will result in smaller numbers extra genes. 1.00 minimizes compliment number (DEFAULT: 1.00)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_postnorm">postNorm</code></td>
<td>
<p>Set to TRUE to normalize new signatures to match old signatures.  (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_minsumtorem">minSumToRem</code></td>
<td>
<p>Set to non-NA to remove any row with the sum(abs(row)) &lt; minSumToRem (DEFAULT: NA)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_addtitle">addTitle</code></td>
<td>
<p>An optional string to add to the plot and savefile (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_autodetectmin">autoDetectMin</code></td>
<td>
<p>Set to true to automatically detect the first local minima. GOOD PRELIMINARY RESULTS (DEAFULT: FALSE)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_calcspillover">calcSpillOver</code></td>
<td>
<p>Use the training data to calculate a spillover matrix (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_pdfdir">pdfDir</code></td>
<td>
<p>A fold to write the pdf file to if plotToPDF=TRUE (DEFAULT: tempdir())</p>
</td></tr>
<tr><td><code id="AugmentSigMatrix_+3A_plotit">plotIt</code></td>
<td>
<p>Set to FALSE to suppress non-PDF plotting (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an augmented cell type signature matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example treats the LM22 deconvolution matrix as if it were all of the data
#  For a real example, look at the vignette or comments in exprData, fullLM22, small LM22
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:200, 1:8]
#Make a fake signature matrix out of 100 genes and the first 8 cell types
smallLM22 &lt;- fullLM22[1:100, 1:8] 

#Make fake data representing two replicates of purified Mast.cells 
exprData &lt;- ADAPTS::LM22[1:200, c("Mast.cells.resting","Mast.cells.activated")]
colnames(exprData) &lt;- c("Mast.cells", "Mast.cells")

#Fake source data with replicates for all purified cell types.
#  Note in this fake data set, many cell types have exactly one replicate
fakeAllData &lt;- cbind(fullLM22, as.data.frame(exprData)) 
gList &lt;- rankByT(geneExpr = fakeAllData, qCut=0.3, oneCore=TRUE)

newSig &lt;- AugmentSigMatrix(origMatrix=smallLM22, fullData=fullLM22, newData=exprData, 
    gList=gList, plotToPDF=FALSE)
</code></pre>

<hr>
<h2 id='buildSeed'>Build a deconvolution seed matrix, add the proportional option</h2><span id='topic+buildSeed'></span>

<h3>Description</h3>

<p>Use ranger to select features and build a genesInSeed gene matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSeed(
  trainSet,
  genesInSeed = 200,
  groupSize = 30,
  randomize = TRUE,
  num.trees = 1000,
  plotIt = TRUE,
  trainSet.3sam = NULL,
  trainSet.30sam = NULL,
  proportional = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildSeed_+3A_trainset">trainSet</code></td>
<td>
<p>Each row is a gene, and each column is an example of a particular cell type, ie from single cell data</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_genesinseed">genesInSeed</code></td>
<td>
<p>The maximum number of genes in the returned seed matrix (DEFAULT: 200)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_groupsize">groupSize</code></td>
<td>
<p>The number of groups to break the trainSet into by ADAPTS::scSample (DEFAULT: 30)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_randomize">randomize</code></td>
<td>
<p>Set to TRUE randomize the sets selected by ADAPTS::scSample (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_num.trees">num.trees</code></td>
<td>
<p>The number of trees to be used by ranger (DEFAULT: 1000)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_plotit">plotIt</code></td>
<td>
<p>Set to TRUE to plot (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_trainset.3sam">trainSet.3sam</code></td>
<td>
<p>Optional pre-calculated ADAPTS::scSample(trainSet, groupSize = 3) (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_trainset.30sam">trainSet.30sam</code></td>
<td>
<p>Optional pre-calculated ADAPTS::scSample(trainSet, groupSize=groupSize, randomize=randomize) (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="buildSeed_+3A_proportional">proportional</code></td>
<td>
<p>Set to true to make the training set cell type proportional.  Ignores group size (DEFAULT: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with condition numbers and gene lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ADAPTS)
ct1 &lt;- runif(1000, 0, 100)
ct2 &lt;- runif(1000, 0, 100)
dataMat &lt;- cbind(ct1, ct1, ct1, ct1, ct1, ct1, ct2, ct2, ct2, ct2)
rownames(dataMat) &lt;- make.names(rep('gene', nrow(dataMat)), unique=TRUE)
noise &lt;- matrix(runif(nrow(dataMat)*ncol(dataMat), -2, 2), nrow = nrow(dataMat), byrow = TRUE)
dataMat &lt;- dataMat + noise
newSigMat &lt;- buildSeed(trainSet=dataMat)

</code></pre>

<hr>
<h2 id='buildSpilloverMat'>Build a spillover matrix</h2><span id='topic+buildSpilloverMat'></span>

<h3>Description</h3>

<p>Build a spillover matrix, i.e. what do purified samples deconvolve as?
</p>
<p>spillExpr &lt;- buildSpilloverMat(refExpr, geneExpr, method='DCQ')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildSpilloverMat(refExpr, geneExpr, method = "DCQ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildSpilloverMat_+3A_refexpr">refExpr</code></td>
<td>
<p>The deconvolution matrix, e.g. LM22 or MGSM27</p>
</td></tr>
<tr><td><code id="buildSpilloverMat_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The full gene expression for purified cell types.  Multiple columns (examples) for each column in the reference expr.</p>
</td></tr>
<tr><td><code id="buildSpilloverMat_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spillover matrix showing how purified cell types deconvolve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

spillover &lt;- buildSpilloverMat(refExpr=smallLM22, geneExpr=fullLM22, method='DCQ')
</code></pre>

<hr>
<h2 id='calcAcc'>Calculate prediction accuracy</h2><span id='topic+calcAcc'></span>

<h3>Description</h3>

<p>Calculate correlation coeffifients, p-Values, MAE, RMSE for deconvolution predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAcc(estimates, reference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAcc_+3A_estimates">estimates</code></td>
<td>
<p>The estimated cell percentages</p>
</td></tr>
<tr><td><code id="calcAcc_+3A_reference">reference</code></td>
<td>
<p>The reference cell percentages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a multiple sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>estimates &lt;- sample(c(runif(8), 0 ,0))
estimates &lt;- 100 * estimates / sum(estimates)
reference &lt;- sample(c(runif(7), 0 , 0, 0))
reference &lt;- 100 * reference / sum(reference)
calcAcc(estimates, reference)

</code></pre>

<hr>
<h2 id='clustWspillOver'>Cluster with spillover</h2><span id='topic+clustWspillOver'></span>

<h3>Description</h3>

<p>Build clusters based on n-pass spillover matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustWspillOver(
  sigMatrix,
  geneExpr,
  nPasses = 100,
  deconMatrices = NULL,
  method = "DCQ"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustWspillOver_+3A_sigmatrix">sigMatrix</code></td>
<td>
<p>The deconvolution matrix, e.g. LM22 or MGSM27</p>
</td></tr>
<tr><td><code id="clustWspillOver_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The source gene expression matrix used to calculate sigMatrix.</p>
</td></tr>
<tr><td><code id="clustWspillOver_+3A_npasses">nPasses</code></td>
<td>
<p>The maximum number of iterations for spillToConvergence (DEFAULT: 100)</p>
</td></tr>
<tr><td><code id="clustWspillOver_+3A_deconmatrices">deconMatrices</code></td>
<td>
<p>Optional pre-computed results from spillToConvergence (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="clustWspillOver_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cell types grouped by cluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

clusters &lt;- clustWspillOver(sigMatrix=smallLM22, geneExpr=fullLM22, nPasses=10)
</code></pre>

<hr>
<h2 id='collapseCellTypes'>Collapse cell types</h2><span id='topic+collapseCellTypes'></span>

<h3>Description</h3>

<p>Collapse the cell types (in rows) to super-classes
Including MGSM36 cell types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseCellTypes(cellCounts, method = "Pheno4")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseCellTypes_+3A_cellcounts">cellCounts</code></td>
<td>
<p>A matrix with cell counts</p>
</td></tr>
<tr><td><code id="collapseCellTypes_+3A_method">method</code></td>
<td>
<p>The method for combining cell types ('Default: 'Pheno2')
Pheno1: Original cell-type based combinations
Pheno2: Original cell-type based combinations, omitting Macrophages
Pheno3: Alt Phenotype definitions based on WMB deconvolution correlations
Pheno4: Consensus cell types
Pheno5: Consensus cell types, combined myeloma &amp; plasma
Spillover1: Empirical combinations based on compToLM22source
Spillover2: More agressive combination based on empirical combinations based on compToLM22source
Spillover3: Combinations determined by spillToConvergence on 36 cell types</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cell estimate matrix with the names changed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellEst &lt;- estCellPercent.DCQ(refExpr=smallLM22, geneExpr=fullLM22)
collapseCounts &lt;- collapseCellTypes(cellCounts=cellEst)
</code></pre>

<hr>
<h2 id='estCellCounts.nPass'>Deconvolve with an n-pass spillover matrix</h2><span id='topic+estCellCounts.nPass'></span>

<h3>Description</h3>

<p>curExpr &lt;- estCellCounts.nPass(sigMatrix, deconMatrices)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellCounts.nPass(geneExpr, deconMatrices, method = "DCQ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellCounts.nPass_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The gene expression matrix</p>
</td></tr>
<tr><td><code id="estCellCounts.nPass_+3A_deconmatrices">deconMatrices</code></td>
<td>
<p>The results from spillToConvergence()</p>
</td></tr>
<tr><td><code id="estCellCounts.nPass_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of cell counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

deconMatrices &lt;- spillToConvergence(sigMatrix=smallLM22, geneExpr=fullLM22, nPasses=10)
cellCounts &lt;- estCellCounts.nPass(geneExpr=fullLM22, deconMatrices=deconMatrices, method='DCQ')
</code></pre>

<hr>
<h2 id='estCellPercent'>Wrapper for deconvolution methods</h2><span id='topic+estCellPercent'></span>

<h3>Description</h3>

<p>A wrapper function to call any of the estCellPercent functions
Modified on June 16th 2021 to quantile normalize the geneExpr data to match refExpr
Set preNormalize to FALSE for previous behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent(
  refExpr,
  geneExpr,
  preNormalize = TRUE,
  verbose = TRUE,
  method = "DCQ",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent_+3A_prenormalize">preNormalize</code></td>
<td>
<p>Set to TRUE to quantile normalize geneExpr to match refExpr (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="estCellPercent_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE to echo the results of parameters (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="estCellPercent_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
<tr><td><code id="estCellPercent_+3A_...">...</code></td>
<td>
<p>Parameters for estCellPercent.X (e.g. number_of_repeats for .DCQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellEst &lt;- estCellPercent(refExpr=smallLM22, geneExpr=fullLM22, preNormalize=FALSE, verbose=TRUE)

</code></pre>

<hr>
<h2 id='estCellPercent.DCQ'>DCQ Deconvolution</h2><span id='topic+estCellPercent.DCQ'></span>

<h3>Description</h3>

<p>Use DCQ to estimate the cell count percentage
Requires installation of package 'ComICS'
To Do: Also report the standard deviation as a confidence metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent.DCQ(
  refExpr,
  geneExpr,
  marker_set = NULL,
  number_of_repeats = 10,
  alpha = 0.05,
  lambda = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent.DCQ_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.DCQ_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.DCQ_+3A_marker_set">marker_set</code></td>
<td>
<p>data frames of one column, that includes a preselected list of genes that likely discriminate well between the immune-cell types given in the reference data. (DEFAULT: NULL, i.e. one for each gene in the refExpr)</p>
</td></tr>
<tr><td><code id="estCellPercent.DCQ_+3A_number_of_repeats">number_of_repeats</code></td>
<td>
<p>using one repeat will generate only one output model. Using many repeats, DCQ calculates a collection of models, and outputs the average and standard deviation for each predicted relative cell quantity. (DEFAULT: 1)</p>
</td></tr>
<tr><td><code id="estCellPercent.DCQ_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with 0 &lt;= alpha &lt;= 1. alpha=1 is the lasso penalty, and alpha=0 the ridge penalty. (DEFAULT: 0.05)</p>
</td></tr>
<tr><td><code id="estCellPercent.DCQ_+3A_lambda">lambda</code></td>
<td>
<p>A minimum value for the elastic net lambda parameter (DEFAULT: 0.2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellEst &lt;- estCellPercent.DCQ(refExpr=smallLM22, geneExpr=fullLM22)
</code></pre>

<hr>
<h2 id='estCellPercent.DeconRNASeq'>DeconRNASeq deconvolution</h2><span id='topic+estCellPercent.DeconRNASeq'></span>

<h3>Description</h3>

<p>Use DeconRNASeq to estimate the cell count percentage
Performs with similar effectiveness as DCQ, but identifies different proportions of cell-types
Requires installation of package 'DeconRNASeq':
source(&quot;https://bioconductor.org/biocLite.R&quot;)
biocLite(&quot;DeconRNASeq&quot;)
</p>
<p>&lt;joseph.szustakowski@novartis.com&gt; TGJDS (2013). DeconRNASeq: Deconvolution of Heterogeneous Tissue Samples for mRNA-Seq data. R package version 1.18.0.
</p>
<p>cellEst &lt;- estCellPercent.DeconRNASeq(refExpr,  geneExpr, marker_set=NULL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent.DeconRNASeq(refExpr, geneExpr, marker_set = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent.DeconRNASeq_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.DeconRNASeq_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.DeconRNASeq_+3A_marker_set">marker_set</code></td>
<td>
<p>data frames of one column, that includes a preselected list of genes that likely discriminate well between the immune-cell types given in the reference data. (DEFAULT: NULL, i.e. one for each gene in the refExpr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#This toy example, donttest due to performance issues in windows development build 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellEst &lt;- estCellPercent.DeconRNASeq(refExpr=smallLM22, geneExpr=fullLM22)

</code></pre>

<hr>
<h2 id='estCellPercent.nnls'>Non-negative least squares deconvolution</h2><span id='topic+estCellPercent.nnls'></span>

<h3>Description</h3>

<p>Use non-negative least squares regression to deconvolve a sample
This is going to be to simple to be useful
This might be more interesting if I used non-positive least squares to detect 'other'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent.nnls(refExpr, geneExpr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent.nnls_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.nnls_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellEst &lt;- estCellPercent.nnls(refExpr=smallLM22, geneExpr=fullLM22)
</code></pre>

<hr>
<h2 id='estCellPercent.proportionsInAdmixture'>WGCNA::proportionsInAdmixture deconvolution</h2><span id='topic+estCellPercent.proportionsInAdmixture'></span>

<h3>Description</h3>

<p>Use R function proportionsInAdmixture to estimate the cell count percentage
Uses the 'WGCNA' package
</p>
<p>cellEst &lt;- estCellPercent.proportionsInAdmixture(refExpr)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent.proportionsInAdmixture(refExpr, geneExpr, marker_set = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent.proportionsInAdmixture_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.proportionsInAdmixture_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.proportionsInAdmixture_+3A_marker_set">marker_set</code></td>
<td>
<p>data frames of one column, that includes a preselected list of genes that likely discriminate well between the immune-cell types given in the reference data. (DEFAULT: NULL, i.e. one for each gene in the refExpr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellEst &lt;- estCellPercent.proportionsInAdmixture(refExpr=smallLM22, geneExpr=fullLM22)

</code></pre>

<hr>
<h2 id='estCellPercent.spillOver'>Estimate cell percentage from spillover</h2><span id='topic+estCellPercent.spillOver'></span>

<h3>Description</h3>

<p>Use a spillover matrix to deconvolve a samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent.spillOver(spillExpr, refExpr, geneExpr, method = "DCQ", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent.spillOver_+3A_spillexpr">spillExpr</code></td>
<td>
<p>A spill over matrix, as calculated by buildSpilloverMat(). (e.g. LM22.spillover.csv.gz)</p>
</td></tr>
<tr><td><code id="estCellPercent.spillOver_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.spillOver_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.spillOver_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
<tr><td><code id="estCellPercent.spillOver_+3A_...">...</code></td>
<td>
<p>Parameters for estCellPercent.X (e.g. number_of_repeats for .DCQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of estimate cell type percentages in samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

spillover &lt;- buildSpilloverMat(refExpr=smallLM22, geneExpr=fullLM22) 
cellEst &lt;- estCellPercent.spillOver(spillExpr=spillover, refExpr=smallLM22, geneExpr=fullLM22)
</code></pre>

<hr>
<h2 id='estCellPercent.svmdecon'>SVMDECON deconvolution</h2><span id='topic+estCellPercent.svmdecon'></span>

<h3>Description</h3>

<p>Use SVMDECON to estimate the cell count percentage
Performs considerably worse in deconvolution than DCQ
</p>
<p>cellEst &lt;- estCellPercent.svmdecon(refExpr,  geneExpr)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estCellPercent.svmdecon(
  refExpr,
  geneExpr,
  marker_set = NULL,
  useOldVersion = F,
  progressBar = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estCellPercent.svmdecon_+3A_refexpr">refExpr</code></td>
<td>
<p>a data frame representing immune cell expression profiles. Each row represents an expression of a gene, and each column represents a different immune cell type. colnames contains the name of each immune cell type and the rownames includes the genes' symbol. The names of each immune cell type and the symbol of each gene should be unique. Any gene with missing expression values must be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.svmdecon_+3A_geneexpr">geneExpr</code></td>
<td>
<p>a data frame representing RNA-seq or microarray gene-expression profiles of a given complex tissue. Each row represents an expression of a gene, and each column represents a different experimental sample. colnames contain the name of each sample and rownames includes the genes' symbol. The name of each individual sample and the symbol of each gene should be unique. Any gene with missing expression values should be excluded.</p>
</td></tr>
<tr><td><code id="estCellPercent.svmdecon_+3A_marker_set">marker_set</code></td>
<td>
<p>data frames of one column, that includes a preselected list of genes that likely discriminate well between the immune-cell types given in the reference data. (DEFAULT: NULL, i.e. one for each gene in the refExpr)</p>
</td></tr>
<tr><td><code id="estCellPercent.svmdecon_+3A_useoldversion">useOldVersion</code></td>
<td>
<p>Set the TRUE to 2^ the data (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="estCellPercent.svmdecon_+3A_progressbar">progressBar</code></td>
<td>
<p>Set to TRUE to show a progress bar  (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 
</p>
<p>cellEst &lt;- estCellPercent.svmdecon(refExpr=smallLM22, geneExpr=fullLM22)
</p>

<hr>
<h2 id='findConvergenceIter'>Find out at which iteration the results converge, i.e. the mean results are stable.</h2><span id='topic+findConvergenceIter'></span>

<h3>Description</h3>

<p>Find out at which iteration the results converge, i.e. the mean results are stable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findConvergenceIter(curSeq, changePer = 1, winSize = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findConvergenceIter_+3A_curseq">curSeq</code></td>
<td>
<p>A sequence of results that generated from each iteration of the loop</p>
</td></tr>
<tr><td><code id="findConvergenceIter_+3A_changeper">changePer</code></td>
<td>
<p>The maximum percentage of change allowed</p>
</td></tr>
<tr><td><code id="findConvergenceIter_+3A_winsize">winSize</code></td>
<td>
<p>The window size for mean calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The minimum number of iterations needed for the results to converge
</p>

<hr>
<h2 id='getF1mcc'>Get f1 / mcc</h2><span id='topic+getF1mcc'></span>

<h3>Description</h3>

<p>Get f1 / mcc and other accuracy measurements for binary predictions.  
Provide either an estimate and reference vector
e.g. getF1mcc(estimate, reference)
Or TPs, FPs, etc.
e.g. getF1mcc(tps=3, fps=4, tns=7, fns=2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF1mcc(
  estimate = NULL,
  reference = NULL,
  tps = NULL,
  fps = NULL,
  tns = NULL,
  fns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF1mcc_+3A_estimate">estimate</code></td>
<td>
<p>A binary vector of predictions</p>
</td></tr>
<tr><td><code id="getF1mcc_+3A_reference">reference</code></td>
<td>
<p>a binary vector of actual values</p>
</td></tr>
<tr><td><code id="getF1mcc_+3A_tps">tps</code></td>
<td>
<p>The number of TPs</p>
</td></tr>
<tr><td><code id="getF1mcc_+3A_fps">fps</code></td>
<td>
<p>The number of FPs</p>
</td></tr>
<tr><td><code id="getF1mcc_+3A_tns">tns</code></td>
<td>
<p>The number of TNs</p>
</td></tr>
<tr><td><code id="getF1mcc_+3A_fns">fns</code></td>
<td>
<p>The number of FNs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with sensitivity, specificity, fpr, fdr, f1, agreement, p.value, mcc, and mcc.p
</p>


<h3>Examples</h3>

<pre><code class='language-R'>estimates &lt;- sample(c(runif(8), 0 ,0))
reference &lt;- sample(c(runif(7), 0 , 0, 0))
accuracyStats &lt;- getF1mcc(estimate=estimates&gt;0, reference=reference&gt;0)
</code></pre>

<hr>
<h2 id='getLM22cells'>LM22 look up table</h2><span id='topic+getLM22cells'></span>

<h3>Description</h3>

<p>Load a map of cell type names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLM22cells()
</code></pre>


<h3>Value</h3>

<p>a map of cell types names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cellMap &lt;- getLM22cells()
</code></pre>

<hr>
<h2 id='gListFromRF'>Build a gList using random forest</h2><span id='topic+gListFromRF'></span>

<h3>Description</h3>

<p>Use ranger to select features and build a genesInSeed gene matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gListFromRF(trainSet, oneCore = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gListFromRF_+3A_trainset">trainSet</code></td>
<td>
<p>Each row is a gene, and each column is an example of a particular cell type, e.g. ADAPTS::scSample(trainSet, groupSize=30)</p>
</td></tr>
<tr><td><code id="gListFromRF_+3A_onecore">oneCore</code></td>
<td>
<p>SEt to TRUE to disable multicore (DEFAULT: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cell specific geneList for ADAPTS::AugmentSigMatrix()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ADAPTS)
ct1 &lt;- runif(1000, 0, 100)
ct2 &lt;- runif(1000, 0, 100)
dataMat &lt;- cbind(ct1, ct1, ct1, ct1, ct1, ct1, ct2, ct2, ct2, ct2)
rownames(dataMat) &lt;- make.names(rep('gene', nrow(dataMat)), unique=TRUE)
noise &lt;- matrix(runif(nrow(dataMat)*ncol(dataMat), -2, 2), nrow = nrow(dataMat), byrow = TRUE)
dataMat &lt;- dataMat + noise
gList &lt;- gListFromRF(trainSet=dataMat, oneCore=TRUE)

</code></pre>

<hr>
<h2 id='hierarchicalClassify'>Hierarchical Deconvolution</h2><span id='topic+hierarchicalClassify'></span>

<h3>Description</h3>

<p>Deconvolve cell types based on clusters detected by an n-pass spillover matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchicalClassify(
  sigMatrix,
  geneExpr,
  toPred,
  hierarchData = NULL,
  pdfDir = tempdir(),
  oneCore = FALSE,
  nPasses = 100,
  remZinf = TRUE,
  method = "DCQ",
  useRF = TRUE,
  incNonCluster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchicalClassify_+3A_sigmatrix">sigMatrix</code></td>
<td>
<p>The deconvolution matrix, e.g. LM22 or MGSM27</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The source gene expression matrix used to calculate sigMatrix</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_topred">toPred</code></td>
<td>
<p>The gene expression to ultimately deconvolve</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_hierarchdata">hierarchData</code></td>
<td>
<p>The results of hierarchicalSplit OR hierarchicalSplit.sc (DEFAULT: NULL, ie hierarchicalSplit)</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_pdfdir">pdfDir</code></td>
<td>
<p>A fold to write the pdf file to (DEFAULT: tempdir())</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_onecore">oneCore</code></td>
<td>
<p>Set to TRUE to disable parallelization (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_npasses">nPasses</code></td>
<td>
<p>The maximum number of iterations for spillToConvergence (DEFAULT: 100)</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_remzinf">remZinf</code></td>
<td>
<p>Set to TRUE to remove any ratio with zero or infinity when generating gList (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_userf">useRF</code></td>
<td>
<p>Set to TRUE to use ranger random forests to build the seed matrix (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="hierarchicalClassify_+3A_incnoncluster">incNonCluster</code></td>
<td>
<p>Set to TRUE to include a 'nonCluster' in each of the sub matrices (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of cell counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

cellCounts &lt;- hierarchicalClassify(sigMatrix=smallLM22, geneExpr=fullLM22, toPred=fullLM22, 
    oneCore=TRUE, nPasses=10, method='DCQ')
</code></pre>

<hr>
<h2 id='hierarchicalSplit'>Build hierarchical cell clusters.</h2><span id='topic+hierarchicalSplit'></span>

<h3>Description</h3>

<p>Attempt to deconvolve cell types by building a hierarchy of cell types using
spillToConvergence to determine cell types that are not signficantly different.
First deconvolve those clusters of cell types.
Deconvolution matrices are then built to separate the cell types that formerly could
not be separated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchicalSplit(
  sigMatrix,
  geneExpr,
  oneCore = FALSE,
  nPasses = 100,
  deconMatrices = NULL,
  remZinf = TRUE,
  method = "DCQ",
  useRF = TRUE,
  incNonCluster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchicalSplit_+3A_sigmatrix">sigMatrix</code></td>
<td>
<p>The deconvolution matrix, e.g. LM22 or MGSM27</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The source gene expression matrix used to calculate sigMatrix</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_onecore">oneCore</code></td>
<td>
<p>Set to TRUE to disable parallelization (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_npasses">nPasses</code></td>
<td>
<p>The maximum number of iterations for spillToConvergence (DEFAULT: 100)</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_deconmatrices">deconMatrices</code></td>
<td>
<p>Optional pre-computed results from spillToConvergence (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_remzinf">remZinf</code></td>
<td>
<p>Set to TRUE to remove any ratio with zero or infinity when generating gList (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_userf">useRF</code></td>
<td>
<p>Set to TRUE to use ranger random forests to build the seed matrix (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="hierarchicalSplit_+3A_incnoncluster">incNonCluster</code></td>
<td>
<p>Set to TRUE to include a 'nonCluster' in each of the sub matrices (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clusters and a list of signature matrices for breaking those clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

clusters &lt;- hierarchicalSplit(sigMatrix=smallLM22, geneExpr=fullLM22, oneCore=TRUE, nPasses=10,
    deconMatrices=NULL, remZinf=TRUE, method='DCQ', useRF=TRUE, incNonCluster=TRUE)
</code></pre>

<hr>
<h2 id='Licenses'>
Licenses required by Celgene legal
</h2><span id='topic+Licenses'></span>

<h3>Description</h3>

<p>This software is covered by the MIT license.  Celgene legal thought it was wise to break the license up into the two license files included in this list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Licenses")</code></pre>


<h3>Format</h3>

<p>A data frame with 0 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://www.r-project.org/Licenses/MIT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Licenses)
str(Licenses)
</code></pre>

<hr>
<h2 id='LM22'>
Leukocyte 22 data matrix
</h2><span id='topic+LM22'></span>

<h3>Description</h3>

<p>Newman et al.'s 2015 22 leukocyte signature matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LM22")</code></pre>


<h3>Format</h3>

<p>A data frame with 547 observations on the following 22 variables.
</p>

<dl>
<dt><code>B.cells.naive</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>B.cells.memory</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Plasma.cells</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD4.naive</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD4.memory.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD4.memory.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.follicular.helper</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.regulatory..Tregs.</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.gamma.delta</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>NK.cells.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>NK.cells.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Monocytes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Macrophages.M0</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Macrophages.M1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Macrophages.M2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Dendritic.cells.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Dendritic.cells.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mast.cells.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mast.cells.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Eosinophils</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Neutrophils</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Newman, A. M. et al. Robust enumeration of cell subsets from tissue expression profiles. Nat. Methods 12, 453–457 (2015).
https://media.nature.com/original/nature-assets/nmeth/journal/v12/n5/extref/nmeth.3337-S2.xls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LM22)
heatmap(as.matrix(LM22))
</code></pre>

<hr>
<h2 id='loadMGSM27'>Load MGSM27</h2><span id='topic+loadMGSM27'></span>

<h3>Description</h3>

<p>Load the MGSM27 signature matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMGSM27()
</code></pre>


<h3>Value</h3>

<p>The MGSM27 signature matrix from Identifying a High-risk Cellular Signature in the Multiple Myeloma Bone Marrow Microenvironment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MGSM27 &lt;- loadMGSM27()
</code></pre>

<hr>
<h2 id='loadModMap'>LM22 to xCell LUT</h2><span id='topic+loadModMap'></span>

<h3>Description</h3>

<p>Load the LM22 xCell map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadModMap()
</code></pre>


<h3>Value</h3>

<p>A map between xCell cell type names and LM22 cell type names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xcellMap &lt;- loadModMap()
</code></pre>

<hr>
<h2 id='loopTillConvergence'>Loop testAllSigMatrices until convergence</h2><span id='topic+loopTillConvergence'></span>

<h3>Description</h3>

<p>Iteratively call testAllSigMatrices numLoops times with the option to fast stop 
if correlation, correlation spear, mae and rmse all converge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loopTillConvergence(
  numLoops,
  fastStop,
  exprData,
  changePer,
  handMetaCluster,
  testOnHalf,
  condTol = 1.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopTillConvergence_+3A_numloops">numLoops</code></td>
<td>
<p>The number of iterations. Set to null to loop until results converge.</p>
</td></tr>
<tr><td><code id="loopTillConvergence_+3A_faststop">fastStop</code></td>
<td>
<p>Set to TRUE to break the loop when correlation, correlation spear, mae and rmse all converge</p>
</td></tr>
<tr><td><code id="loopTillConvergence_+3A_exprdata">exprData</code></td>
<td>
<p>The single cell matrix</p>
</td></tr>
<tr><td><code id="loopTillConvergence_+3A_changeper">changePer</code></td>
<td>
<p>The maximum percentage of change allowed for convergence</p>
</td></tr>
<tr><td><code id="loopTillConvergence_+3A_handmetacluster">handMetaCluster</code></td>
<td>
<p>A List of pre-defined meta clusters. Set to NULL to automatically group indistinguishable 
cells into same cluster use clustWspillOver (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="loopTillConvergence_+3A_testonhalf">testOnHalf</code></td>
<td>
<p>Set to TRUE to leave half the data as a test set to validate all the matrices</p>
</td></tr>
<tr><td><code id="loopTillConvergence_+3A_condtol">condTol</code></td>
<td>
<p>The tolerance in the reconstruction algorithm.  1.0 = no tolerance, 1.05 = 5% tolerance (DEFAULT: 1.01)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results generated from all the iterative calls of testAllSigMatrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct1 &lt;- runif(1000, 0, 100)
ct2 &lt;- runif(1000, 0, 100)
ct3 &lt;- runif(1000, 0, 100)
ct4 &lt;- runif(1000, 0, 100)
dataMat &lt;- cbind(ct1, ct1, ct1, ct1, ct1, ct1, ct2, ct2, ct2, ct2, ct3, ct3, ct3,ct3,ct4,ct4)
rownames(dataMat) &lt;- make.names(rep('gene', nrow(dataMat)), unique=TRUE)
noise &lt;- matrix(runif(nrow(dataMat)*ncol(dataMat), -2, 2), nrow = nrow(dataMat), byrow = TRUE)
dataMat &lt;- dataMat + noise
#options(mc.cores=2)
#  This is a meta-function that calls other functions, 
#  The execution speed is too slow for the CRAN automated check
#loopTillConvergence(numLoops=10, fastStop=TRUE, exprData=dataMat, 
#    changePer=10,handMetaCluster=NULL, testOnHalf=TRUE)
</code></pre>

<hr>
<h2 id='matrixToGenelist'>Make a GSVA genelist</h2><span id='topic+matrixToGenelist'></span>

<h3>Description</h3>

<p>Provide a gList and signature matrix with matched cell types to get signatures
gene lists for GSVA and similar algorithms.
gList=NULL select highest genes for each cell type, minimum of 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToGenelist(sigMat, gList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixToGenelist_+3A_sigmat">sigMat</code></td>
<td>
<p>A signature matrix such as from ADAPTS::AugmentSigMatrix()</p>
</td></tr>
<tr><td><code id="matrixToGenelist_+3A_glist">gList</code></td>
<td>
<p>A list of prioritized genes such as from ADAPTS::gListFromRF() (DEFAULT:NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of genes for each cell types musually in sigMat and gList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ADAPTS)
ct1 &lt;- runif(1000, 0, 100)
ct2 &lt;- runif(1000, 0, 100)
dataMat &lt;- cbind(ct1, ct1, ct1, ct1, ct1, ct1, ct2, ct2, ct2, ct2)
rownames(dataMat) &lt;- make.names(rep('gene', nrow(dataMat)), unique=TRUE)
noise &lt;- matrix(runif(nrow(dataMat)*ncol(dataMat), -2, 2), nrow = nrow(dataMat), byrow = TRUE)
dataMat &lt;- dataMat + noise
gList &lt;- ADAPTS::gListFromRF(trainSet=dataMat, oneCore=TRUE)
newSigMat &lt;- ADAPTS::buildSeed(trainSet=dataMat, plotIt=FALSE)
geneLists &lt;- matrixToGenelist(sigMat=newSigMat, gList=gList)

</code></pre>

<hr>
<h2 id='meanResults'>A meta analysis for the results from multiple iterations</h2><span id='topic+meanResults'></span>

<h3>Description</h3>

<p>Calculate the mean and the standard deviation of the results from all the iterations, and also 
test for convergence by 
</p>
<p>Calculate the mean and the standard deviation of the results from all the iterations, and also 
test for convergence by 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanResults(allResList, changePer = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanResults_+3A_allreslist">allResList</code></td>
<td>
<p>A list of results generated from all the iterative calls of testAllSigMatrices</p>
</td></tr>
<tr><td><code id="meanResults_+3A_changeper">changePer</code></td>
<td>
<p>The maximum percentage of change allowed for convergence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean and standard deviation of all the results, along with the number of iterations needed for the results to converge.
A meta analysis for the results from multiple iterations
</p>
<p>The mean and standard deviation of all the results, along with the number of iterations needed for the results to converge.
</p>

<hr>
<h2 id='MGSM27'>
Myeloma Genome Signature Matrix 27
</h2><span id='topic+MGSM27'></span>

<h3>Description</h3>

<p>Newman et al's 2015 plus 5 myeloma specific cell types. Osteoclasts, Adipocytes, Osteoblasts, Multiple Myeloma Plasma Cells, and Plasma Memory Cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MGSM27")</code></pre>


<h3>Format</h3>

<p>A data frame with 601 observations on the following 27 variables.
</p>

<dl>
<dt><code>B.cells.naive</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>B.cells.memory</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Plasma.cells</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD4.naive</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD4.memory.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.CD4.memory.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.follicular.helper</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.regulatory..Tregs.</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>T.cells.gamma.delta</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>NK.cells.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>NK.cells.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Monocytes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Macrophages.M0</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Macrophages.M1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Macrophages.M2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Dendritic.cells.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Dendritic.cells.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mast.cells.resting</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Mast.cells.activated</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Eosinophils</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Neutrophils</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>MM.plasma.cell</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>osteoblast</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>osteoclast</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>PlasmaMemory</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>adipocyte</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>MGSM27 as constructed for Identifying a High-risk Cellular Signature in the Multiple Myeloma Bone Marrow Microenvironment.
</p>


<h3>Source</h3>

<p>https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-3732/
https://www.ebi.ac.uk/arrayexpress/experiments/E-MEXP-3711/
https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4152/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MGSM27)
heatmap(as.matrix(MGSM27))
</code></pre>

<hr>
<h2 id='missForest.par'>Use parallel missForest to impute missing values.</h2><span id='topic+missForest.par'></span>

<h3>Description</h3>

<p>This wrapper is helpful because missForest crashes if you have more cores than variables.
This will default to no parellelization for Windows
</p>
<p>newMatrix &lt;- missForest.par(dataMat)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missForest.par(dataMat, parallelize = "variables")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missForest.par_+3A_datamat">dataMat</code></td>
<td>
<p>Columns are features, Rows examples. The data with NA values.  'xmis' in missForest</p>
</td></tr>
<tr><td><code id="missForest.par_+3A_parallelize">parallelize</code></td>
<td>
<p>split on 'forests' or 'variables' (DEFAULT: 'variables')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including imputed values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ADAPTS)
LM22 &lt;- ADAPTS::LM22
LM22[2,3] &lt;- as.numeric(NA) #Make some missing data to impute
LM22.imp &lt;- missForest.par(LM22)
</code></pre>

<hr>
<h2 id='plotKappas'>Plot condition numbers</h2><span id='topic+plotKappas'></span>

<h3>Description</h3>

<p>Plot the condition numbers during the growing and shrinking of signature matrices.
</p>
<p>bonusPoints &lt;- data.frame(legText = c('Unagumented Signature Matrix', 'Minimum Smoothed Condition Number', 'Best Augmented Signature Matrix'), 
pchs = c('o', 'x', 'x'), 
cols = c('red', 'purple', 'blue'), 
kappa = c(10, 15, 20), 
nGene = c(5, 10, 15))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotKappas(
  kappas,
  nGenes,
  smData = NULL,
  titleStr = "Shrink Signature Matrix",
  bonusPoints = NULL,
  maxCond = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotKappas_+3A_kappas">kappas</code></td>
<td>
<p>The condition numbers to plot</p>
</td></tr>
<tr><td><code id="plotKappas_+3A_ngenes">nGenes</code></td>
<td>
<p>The number of genes associated with each kapp</p>
</td></tr>
<tr><td><code id="plotKappas_+3A_smdata">smData</code></td>
<td>
<p>Smoothed data to plot as a green line (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="plotKappas_+3A_titlestr">titleStr</code></td>
<td>
<p>The title of the plot (DEFAULT: 'Shrink Signature Matrix')</p>
</td></tr>
<tr><td><code id="plotKappas_+3A_bonuspoints">bonusPoints</code></td>
<td>
<p>Set to plot additional points on the plot, see description (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="plotKappas_+3A_maxcond">maxCond</code></td>
<td>
<p>Cap the condition number to maxCond (DEFAULT: 100)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including imputed values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nGenes &lt;- 1:300
kappas &lt;- log(abs(nGenes-250))
kappas[is.infinite(kappas)] &lt;- 0
kappas &lt;- kappas+runif(300, 0, 1)
smData &lt;- stats::smooth(kappas)
bonusPoints &lt;- data.frame(legText = 'Minimum Smoothed ', pchs='x', cols='purple', 
kappa=min(smData), nGenes=nGenes[which.min(smData)])
plotKappas(kappas=kappas, nGenes=nGenes, smData=smData, bonusPoints=bonusPoints, maxCond=100)

</code></pre>

<hr>
<h2 id='rankByT'>Rank genes for each cell type</h2><span id='topic+rankByT'></span>

<h3>Description</h3>

<p>Use a t-test to rank to features for each cell type
</p>
<p>gList &lt;- rankByT(geneExpr, qCut=0.3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankByT(
  geneExpr,
  qCut = 0.3,
  oneCore = FALSE,
  secondPval = TRUE,
  remZinf = FALSE,
  reqRatGT1 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankByT_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The gene expression data</p>
</td></tr>
<tr><td><code id="rankByT_+3A_qcut">qCut</code></td>
<td>
<p>(DEFAULT: 0.3)</p>
</td></tr>
<tr><td><code id="rankByT_+3A_onecore">oneCore</code></td>
<td>
<p>Set to TRUE to disable paralellization (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="rankByT_+3A_secondpval">secondPval</code></td>
<td>
<p>Set to TRUE to use p-Values as a second sort criteria (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="rankByT_+3A_remzinf">remZinf</code></td>
<td>
<p>Set to TRUE to remove any ratio with zero or infinity.  Good for scRNAseq. (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="rankByT_+3A_reqratgt1">reqRatGT1</code></td>
<td>
<p>Set to TRUE to remove any gene with a ratio with less than 1.  Good for scRNAseq. (DEFAULT: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of cell types with data frames ranking genes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example treats the LM22 deconvolution matrix as if it were all of the data
#  For a real example, look at the vignette or comments in exprData, fullLM22, small LM22
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:200, 1:8]
#Make a fake signature matrix out of 100 genes and the first 8 cell types
smallLM22 &lt;- fullLM22[1:100, 1:8] 

#Make fake data representing two replicates of purified Mast.cells 
exprData &lt;- ADAPTS::LM22[1:200, c("Mast.cells.resting","Mast.cells.activated")]
colnames(exprData) &lt;- c("Mast.cells", "Mast.cells")

#Fake source data with replicates for all purified cell types.
#  Note in this fake data set, many cell types have exactly one replicate
fakeAllData &lt;- cbind(fullLM22, as.data.frame(exprData)) 
gList &lt;- rankByT(geneExpr = fakeAllData, qCut=0.3, oneCore=TRUE, reqRatGT1=FALSE)
</code></pre>

<hr>
<h2 id='remakeLM22p'>Make an Augmented Signature Matrix</h2><span id='topic+remakeLM22p'></span>

<h3>Description</h3>

<p>With the ADAPTSdata packge, it will use the full LM22 data matrix and add a few 
additional genes to cover osteoblasts, osteoclasts, Plasma.memory, MM.  In many ways this is 
just a convenient wrapper for AugmentSigMatrix that calculates and caches a gList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remakeLM22p(
  exprData,
  fullLM22,
  smallLM22 = NULL,
  plotToPDF = TRUE,
  condTol = 1.01,
  postNorm = TRUE,
  autoDetectMin = FALSE,
  pdfDir = tempdir(),
  oneCore = FALSE,
  cache_gList = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remakeLM22p_+3A_exprdata">exprData</code></td>
<td>
<p>The gene express data to use to augment LM22, e.g. ADAPTSdata::addMGSM27</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_fulllm22">fullLM22</code></td>
<td>
<p>LM22 data with all genes.  Available in ADAPTSdata2::fullLM22</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_smalllm22">smallLM22</code></td>
<td>
<p>The small LM22 matrix, if it includes new cell types in exprData those will not be overwritten (DEFAULT: NULL, i.e. buildLM22plus(useLM22genes = TRUE)</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_plottopdf">plotToPDF</code></td>
<td>
<p>TRUE: pdf, FALSE: standard display (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_condtol">condTol</code></td>
<td>
<p>The tolerance in the reconstruction algorithm.  1.0 = no tolerance, 1.05 = 5% tolerance (DEFAULT: 1.01)</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_postnorm">postNorm</code></td>
<td>
<p>Set to TRUE to normalize new signatures to match old signatures.  To Do: Redo Kappa curve? (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_autodetectmin">autoDetectMin</code></td>
<td>
<p>Set to true to automatically detect the first local minima. GOOD PRELIMINARY RESULTS (DEAFULT: FALSE)</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_pdfdir">pdfDir</code></td>
<td>
<p>A fold to write the pdf file to if plotToPDF=TRUE (DEFAULT: tempdir())</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_onecore">oneCore</code></td>
<td>
<p>Set to TRUE to disable parallelization (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="remakeLM22p_+3A_cache_glist">cache_gList</code></td>
<td>
<p>Set to TRUE to cache slow gList calculations (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cell type signature matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example treats the LM22 deconvolution matrix as if it were all of the data
#  For a real example, look at the vignette or comments in exprData, fullLM22, small LM22
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:200, 1:8]
#Make a fake signature matrix out of 100 genes and the first 8 cell types
smallLM22 &lt;- fullLM22[1:100, 1:8] 

#Make fake data representing two replicates of purified Mast.cells types 
exprData &lt;- ADAPTS::LM22[1:200, c("Mast.cells.resting","Mast.cells.activated")]
colnames(exprData) &lt;- c("Mast.cells", "Mast.cells")
newSig &lt;- remakeLM22p(exprData=exprData, fullLM22=fullLM22, smallLM22=smallLM22, 
    plotToPDF=FALSE, oneCore=TRUE, cache_gList=FALSE)
</code></pre>

<hr>
<h2 id='scSample'>Build groupSize pools according to cellIDs</h2><span id='topic+scSample'></span>

<h3>Description</h3>

<p>This function is intended to collapse many single cells into 3 (groupsize) groups
with the average count across all cells in each of the groups.  These groups can then be used to perform a 
t-test (for example) between the 3 groups of CellX with 3 groups of CellY
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scSample(
  RNAcounts,
  cellIDs = colnames(RNAcounts),
  groupSize = 3,
  randomize = TRUE,
  mc.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scSample_+3A_rnacounts">RNAcounts</code></td>
<td>
<p>The single cell matrix</p>
</td></tr>
<tr><td><code id="scSample_+3A_cellids">cellIDs</code></td>
<td>
<p>A vector will cell types for each column in scCountMatrix (DEFAULT: colnames(RNAcounts))</p>
</td></tr>
<tr><td><code id="scSample_+3A_groupsize">groupSize</code></td>
<td>
<p>The number of sets to break it up into (DEFAULT: 3)</p>
</td></tr>
<tr><td><code id="scSample_+3A_randomize">randomize</code></td>
<td>
<p>Set to TRUE to randomize the sets (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="scSample_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use (DEFAULT: 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a multiple sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNAcounts &lt;- matrix(0, nrow=10, ncol=100)
rownames(RNAcounts) &lt;- make.names(rep('Gene', nrow(RNAcounts)), unique=TRUE)
colnames(RNAcounts) &lt;- make.names(c('CellX', rep('CellY', 39), 
rep('CellZ', 30), rep('CellB', 30)), unique=TRUE)
RNAcounts[, grepl('CellY', colnames(RNAcounts))] &lt;- 1
RNAcounts[, grepl('CellZ', colnames(RNAcounts))] &lt;- 2
RNAcounts[, grepl('CellB', colnames(RNAcounts))] &lt;- 3
scSample(RNAcounts, groupSize=3)

</code></pre>

<hr>
<h2 id='shrinkByKappa'>Calculate conditions numbers for signature subsets</h2><span id='topic+shrinkByKappa'></span>

<h3>Description</h3>

<p>Remove genes by chunks by picking those the most improve the condition number.  
Will set any infinite condition numbers to max(kappas[!is.infinite(kappas)])+1
Return the condition numbers with their gene lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkByKappa(
  sigMatrix,
  numChunks = NULL,
  verbose = TRUE,
  plotIt = TRUE,
  singleCore = FALSE,
  fastStop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrinkByKappa_+3A_sigmatrix">sigMatrix</code></td>
<td>
<p>The original signature matrix</p>
</td></tr>
<tr><td><code id="shrinkByKappa_+3A_numchunks">numChunks</code></td>
<td>
<p>The number of groups of genes to remove (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="shrinkByKappa_+3A_verbose">verbose</code></td>
<td>
<p>Print out the current chunk as is it's being calculated (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="shrinkByKappa_+3A_plotit">plotIt</code></td>
<td>
<p>The title of the plot (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="shrinkByKappa_+3A_singlecore">singleCore</code></td>
<td>
<p>Set to FALSE to use multiple cores to calculate condition numbers (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="shrinkByKappa_+3A_faststop">fastStop</code></td>
<td>
<p>Halt early when the condition number changes by less than 1 for 3 iterations (DEFAULT: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with condition numbers and gene lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ADAPTS)
LM22 &lt;- ADAPTS::LM22
sigGenesList &lt;- shrinkByKappa(sigMatrix=LM22[1:100,1:5], numChunks=4, 
verbose=FALSE, plotIt=FALSE, singleCore=TRUE, fastStop=TRUE)

</code></pre>

<hr>
<h2 id='shrinkSigMatrix'>Shrink a signature matrix</h2><span id='topic+shrinkSigMatrix'></span>

<h3>Description</h3>

<p>Use shrinkByKappa and automatic minima detection to reduce a signature matrix.
Select the new signature matrix with the minima and the maximum number of genes.  There is an
inherent difficult in that the condition number will tend to have a second peak at a relatively
small number of genes, and then crash so that smallest condition number has more or less one gene.
</p>
<p>By default, the algorithm will tend to pick the detected minima with the largest nubmer of genes.
aggressiveMin=TRUE will try to find the minimum number of genes that has more genes than the 
maxima at the smallest number of genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkSigMatrix(
  sigMatrix,
  numChunks = 100,
  verbose = FALSE,
  plotIt = FALSE,
  aggressiveMin = TRUE,
  sigGenesList = NULL,
  singleCore = FALSE,
  fastStop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrinkSigMatrix_+3A_sigmatrix">sigMatrix</code></td>
<td>
<p>The original signature matrix</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_numchunks">numChunks</code></td>
<td>
<p>The number of groups of genes to remove. NULL is all genes (DEFAULT: 100)</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Print out the current chunk as is it's being calculated (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_plotit">plotIt</code></td>
<td>
<p>Set to TRUE to plot (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_aggressivemin">aggressiveMin</code></td>
<td>
<p>Set to TRUE to aggresively seek the smallest number of genes (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_siggeneslist">sigGenesList</code></td>
<td>
<p>Set to use precomputed results from shrinkByKappa (DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_singlecore">singleCore</code></td>
<td>
<p>Set to FALSE to use multiple cores to calculate condition numbers (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="shrinkSigMatrix_+3A_faststop">fastStop</code></td>
<td>
<p>Halt early when the condition number changes by less than 1 for 3 iterations (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with condition numbers and gene lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ADAPTS)
LM22 &lt;- ADAPTS::LM22
newSigMat &lt;- shrinkSigMatrix(sigMatrix=LM22[1:100,1:5], numChunks=4, verbose=FALSE, 
plotIt=FALSE, aggressiveMin=TRUE, sigGenesList=NULL, singleCore=TRUE, fastStop=FALSE)

</code></pre>

<hr>
<h2 id='spillToConvergence'>Spillover to convergence</h2><span id='topic+spillToConvergence'></span>

<h3>Description</h3>

<p>Build an n-pass spillover matrix, continuing until the results converge into clusters of cell types
</p>
<p>deconMatrices &lt;- spillToConvergence(sigMatrix, geneExpr, 100, FALSE, TRUE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spillToConvergence(
  sigMatrix,
  geneExpr,
  nPasses = 100,
  plotIt = FALSE,
  imputNAs = FALSE,
  method = "DCQ"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spillToConvergence_+3A_sigmatrix">sigMatrix</code></td>
<td>
<p>The deconvolution matrix, e.g. LM22 or MGSM27</p>
</td></tr>
<tr><td><code id="spillToConvergence_+3A_geneexpr">geneExpr</code></td>
<td>
<p>The source gene expression matrix used to calculate sigMatrix</p>
</td></tr>
<tr><td><code id="spillToConvergence_+3A_npasses">nPasses</code></td>
<td>
<p>The maximum number of iterations (DEFAULT: 100)</p>
</td></tr>
<tr><td><code id="spillToConvergence_+3A_plotit">plotIt</code></td>
<td>
<p>Set to TRUE to plot it (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="spillToConvergence_+3A_imputnas">imputNAs</code></td>
<td>
<p>Set to TRUE to imput genes with missing values &amp; cache the imputed.  FALSE will just remove them (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="spillToConvergence_+3A_method">method</code></td>
<td>
<p>One of 'DCQ', 'SVMDECON', 'DeconRNASeq', 'proportionsInAdmixture', 'nnls' (DEFAULT: DCQ)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of signature matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This toy example 
library(ADAPTS)
fullLM22 &lt;- ADAPTS::LM22[1:30, 1:4]
smallLM22 &lt;- fullLM22[1:25,] 

deconMatrices &lt;- spillToConvergence(sigMatrix=smallLM22, geneExpr=fullLM22, nPasses=10, plotIt=TRUE)
</code></pre>

<hr>
<h2 id='splitSCdata'>Split a single cell dataset into multiple sets</h2><span id='topic+splitSCdata'></span>

<h3>Description</h3>

<p>Take a matrix of single cell data with genes as rows and each column corresponding
to a single cells. Break it up into rougly equal subsets, taking care to make sure that each cell type is represented
in each set if possible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitSCdata(
  RNAcounts,
  cellIDs = colnames(RNAcounts),
  numSets = 3,
  verbose = TRUE,
  randomize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitSCdata_+3A_rnacounts">RNAcounts</code></td>
<td>
<p>The single cell matrix</p>
</td></tr>
<tr><td><code id="splitSCdata_+3A_cellids">cellIDs</code></td>
<td>
<p>A vector will cell types for each column in scCountMatrix (DEFAULT: colnames(RNAcounts))</p>
</td></tr>
<tr><td><code id="splitSCdata_+3A_numsets">numSets</code></td>
<td>
<p>The number of sets to break it up into (DEFAULT: 3)</p>
</td></tr>
<tr><td><code id="splitSCdata_+3A_verbose">verbose</code></td>
<td>
<p>Set to TRUE to print cell counts as it goes (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="splitSCdata_+3A_randomize">randomize</code></td>
<td>
<p>Set to TRUE to randomize the sets (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a multiple sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RNAcounts &lt;- matrix(0, nrow=10, ncol=30)
rownames(RNAcounts) &lt;- make.names(rep('Gene', nrow(RNAcounts)), unique=TRUE)
colnames(RNAcounts) &lt;- make.names(c('CellX', rep('CellY', 9), 
rep('CellZ', 10), rep('CellB', 10)), unique=TRUE)
RNAcounts[, grepl('CellY', colnames(RNAcounts))] &lt;- 1
RNAcounts[, grepl('CellZ', colnames(RNAcounts))] &lt;- 2
RNAcounts[, grepl('CellB', colnames(RNAcounts))] &lt;- 3
splitSCdata(RNAcounts, numSets=3)

</code></pre>

<hr>
<h2 id='SVMDECON'>Support vector machine deconvolution</h2><span id='topic+SVMDECON'></span>

<h3>Description</h3>

<p>Use SVMDECONV to estimate the cell count percentage
David L Gibbs, dgibbs@systemsbiology.org
June 9, 2017
</p>
<p>v-SVR is applied with a linear kernel to solve for f,
and the best result from three values of v = 0.25, 0.5, 0.75
is saved, where ‘best’ is defined as the lowest root mean squared error
between m and the deconvolution result, f x B.
</p>
<p>Our current implementation executes v-SVR using the
‘svm’ function in the R package, ‘e1071’.
</p>
<p>w2 &lt;- SVMDECON(m, B)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVMDECON(m, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVMDECON_+3A_m">m</code></td>
<td>
<p>a matrix represenging the mixture (genes X 1 sample)</p>
</td></tr>
<tr><td><code id="SVMDECON_+3A_b">B</code></td>
<td>
<p>a matrix representing the references (genes X cells), m should be subset to match B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with cell type estimates for each samples
</p>

<hr>
<h2 id='testAllSigMatrices'>Generate all the signature matrices one time with the option to leave out half of the data as a test set</h2><span id='topic+testAllSigMatrices'></span>

<h3>Description</h3>

<p>This wrapper is helpful for repetitively matrix generation. It generates seed matrix, all-gene matrix, augmented matrix, shrunk matrix,
and all the clustered matrices in one call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testAllSigMatrices(
  exprData,
  randomize = TRUE,
  skipShrink = FALSE,
  proportional = FALSE,
  handMetaCluster = NULL,
  testOnHalf = TRUE,
  condTol = 1.01,
  numChunks = 100,
  plotIt = TRUE,
  fastStop = TRUE,
  singleCore = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testAllSigMatrices_+3A_exprdata">exprData</code></td>
<td>
<p>The gene express data. Each row is a gene, and each column is an example of a particular cell type.</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_randomize">randomize</code></td>
<td>
<p>Set to to TRUE randomize the sets selected by ADAPTS::scSample (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_skipshrink">skipShrink</code></td>
<td>
<p>Set to TRUE to skip shrinking the signatrure matrix (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_proportional">proportional</code></td>
<td>
<p>Set to true to make the training set cell type proportional.  Ignores group size (DEFAULT: FALSE)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_handmetacluster">handMetaCluster</code></td>
<td>
<p>A List of pre-defined meta clusters.Set to NULL to automatically group indistinguishable cells 
into same cluster using clustWspillOver.(DEFAULT: NULL)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_testonhalf">testOnHalf</code></td>
<td>
<p>Set to TRUE to leave half the data as a test set</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_condtol">condTol</code></td>
<td>
<p>The tolerance in the reconstruction algorithm.  1.0 = no tolerance, 1.05 = 5% tolerance (DEFAULT: 1.01)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_numchunks">numChunks</code></td>
<td>
<p>The number of groups of genes to remove while shrinking (DEFAULT: NULL, i.e. 1)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_plotit">plotIt</code></td>
<td>
<p>Set to FALSE to suppress plots (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_faststop">fastStop</code></td>
<td>
<p>Halt early when the condition number changes by less than 1 for 3 iterations (DEFAULT: TRUE)</p>
</td></tr>
<tr><td><code id="testAllSigMatrices_+3A_singlecore">singleCore</code></td>
<td>
<p>TRUE for a single core (DEFAULT: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results including prediction accuracy and cell enrichment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct1 &lt;- runif(1000, 0, 100)
ct2 &lt;- runif(1000, 0, 100)
ct3 &lt;- runif(1000, 0, 100)
ct4 &lt;- runif(1000, 0, 100)
dataMat &lt;- cbind(ct1, ct1, ct1, ct1, ct1, ct1, ct2, ct2, ct2, ct2, ct3, ct3, ct3,ct3,ct4,ct4)
rownames(dataMat) &lt;- make.names(rep('gene', nrow(dataMat)), unique=TRUE)
noise &lt;- matrix(runif(nrow(dataMat)*ncol(dataMat), -2, 2), nrow = nrow(dataMat), byrow = TRUE)
dataMat &lt;- dataMat + noise
metaList &lt;- list()
colnames(dataMat) &lt;- sub('\\..*','', colnames(dataMat))
metaList[[1]] &lt;- c(unique(colnames(dataMat))[1])  #Cell Type 1
metaList[[2]] &lt;- c(unique(colnames(dataMat))[2])  #Cell Type 2
metaList[[3]] &lt;- c(unique(colnames(dataMat))[3])  #Cell Type 3
metaList[[4]] &lt;- c(unique(colnames(dataMat))[4:length(unique(colnames(dataMat)))])  #Cell Type 4
#options(mc.cores=2)
#  This is a meta-function that calls other functions, 
#  The execution speed is too slow for the CRAN automated check
#testAllSigMatrices(exprData=dataMat, randomize = TRUE, skipShrink=FALSE, 
#    proportional=FALSE, handMetaCluster=metaList, testOnHalf=TRUE, numChunks=NULL)
</code></pre>

<hr>
<h2 id='weightNorm'>SVMDECONV helper function</h2><span id='topic+weightNorm'></span>

<h3>Description</h3>

<p>Use weightNorm to normalize the SVM weights.  Used for SVMDECONV
</p>
<p>w1 &lt;- weightNorm(w)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightNorm(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightNorm_+3A_w">w</code></td>
<td>
<p>The weight vector from fitting an SVM, something like something like t(fit1$coefs) %*% fit1$SV, where fit comes from  &lt;- svm(m~B, nu=0.25, kernel=&quot;linear&quot;))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a weight vector
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
