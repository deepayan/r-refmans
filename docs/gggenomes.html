<!DOCTYPE html><html lang="en"><head><title>Help for package gggenomes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gggenomes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_feats'><p>Add different types of tracks</p></a></li>
<li><a href='#add_seqs'><p>Add seqs</p></a></li>
<li><a href='#as_feats'><p>Compute a layout for feat data</p></a></li>
<li><a href='#as_links'><p>Compute a layout for link data</p></a></li>
<li><a href='#as_seqs'><p>Compute a layout for sequence data</p></a></li>
<li><a href='#as_subfeats'><p>Compute a layout for subfeat data</p></a></li>
<li><a href='#as_sublinks'><p>Compute a layout for links linking feats</p></a></li>
<li><a href='#check_strand'><p>Check strand</p></a></li>
<li><a href='#combine_strands'><p>Combine strands</p></a></li>
<li><a href='#def_formats'><p>Defined file formats and extensions</p></a></li>
<li><a href='#def_names'><p>Default column names and types for defined formats</p></a></li>
<li><a href='#dim.gggenomes_layout'><p><code>ggplot2::facet_null</code> checks data with <code>empty(df)</code> using <code>dim</code>. This causes</p>
an error because dim(gggenome_layout) is undefined. Return dim of primary
table instead</a></li>
<li><a href='#drop_feat_layout'><p>Drop feature layout</p></a></li>
<li><a href='#drop_layout'><p>Drop a genome layout</p></a></li>
<li><a href='#drop_link_layout'><p>Drop a link layout</p></a></li>
<li><a href='#drop_seq_layout'><p>Drop a seq layout</p></a></li>
<li><a href='#emale_ava'><p>All-versus-all whole genome alignments of 6 EMALE genomes</p></a></li>
<li><a href='#emale_cogs'><p>Clusters of orthologs of 6 EMALE proteomes</p></a></li>
<li><a href='#emale_gc'><p>Relative GC-content along 6 EMALE genomes</p></a></li>
<li><a href='#emale_genes'><p>Gene annotations if 6 EMALE genomes (endogenous virophages)</p></a></li>
<li><a href='#emale_ngaros'><p>Integrated Ngaro retrotransposons of 6 EMALE genomes</p></a></li>
<li><a href='#emale_prot_ava'><p>All-versus-all alignments 6 EMALE proteomes</p></a></li>
<li><a href='#emale_seqs'><p>Sequence index of 6 EMALE genomes (endogenous virophages)</p></a></li>
<li><a href='#emale_tirs'><p>Terminal inverted repeats of 6 EMALE genomes</p></a></li>
<li><a href='#ex'><p>Get path to gggenomes example files</p></a></li>
<li><a href='#feats'><p>Use tracks inside and outside <code style="white-space: pre;">&#8288;geom_*&#8288;</code> calls</p></a></li>
<li><a href='#flip'><p>Flip bins and sequences</p></a></li>
<li><a href='#flip_strand'><p>Flip strand</p></a></li>
<li><a href='#focus'><p>Show features and regions of interest</p></a></li>
<li><a href='#geom_bin_label'><p>Draw bin labels</p></a></li>
<li><a href='#geom_coverage'><p>Draw wiggle ribbons or lines</p></a></li>
<li><a href='#geom_feat'><p>Draw feats</p></a></li>
<li><a href='#geom_feat_text'><p>Add text to genes, features, etc.</p></a></li>
<li><a href='#geom_gene'><p>Draw gene models</p></a></li>
<li><a href='#geom_gene_label'><p>Draw feat/link labels</p></a></li>
<li><a href='#geom_link'><p>Draw links between genomes</p></a></li>
<li><a href='#geom_seq'><p>draw seqs</p></a></li>
<li><a href='#geom_seq_break'><p>Decorate truncated sequences</p></a></li>
<li><a href='#geom_seq_label'><p>Draw seq labels</p></a></li>
<li><a href='#geom_variant'><p>Draw place of mutation</p></a></li>
<li><a href='#GeomFeatText'><p>Geom for feature text</p></a></li>
<li><a href='#get_seqs'><p>Get/set the seqs track</p></a></li>
<li><a href='#gggenomes'><p>Plot genomes, features and synteny maps</p></a></li>
<li><a href='#ggplot.gggenomes_layout'><p>ggplot.default tries to <code>fortify(data)</code> and we don't want that here</p></a></li>
<li><a href='#has_vars'><p>Check if variables exist in object</p></a></li>
<li><a href='#if_reverse'><p>Vectorised if_else based on strandedness</p></a></li>
<li><a href='#in_range'><p>Do numeric values fall into specified ranges?</p></a></li>
<li><a href='#introduce'><p>Introduce non-existing columns</p></a></li>
<li><a href='#is_reverse'><p>Check whether strand is reverse</p></a></li>
<li><a href='#layout'><p>Re-layout a genome layout</p></a></li>
<li><a href='#layout_genomes'><p>Layout genomes</p></a></li>
<li><a href='#layout_seqs'><p>Layout sequences</p></a></li>
<li><a href='#pick'><p>Pick bins and seqs by name or position</p></a></li>
<li><a href='#position_strand'><p>Stack features</p></a></li>
<li><a href='#position_variant'><p>Plot types of mutations with different offsets</p></a></li>
<li><a href='#qw'><p>Create a vector from unquoted words.</p></a></li>
<li><a href='#read_alitv'><p>Read AliTV .json file</p></a></li>
<li><a href='#read_bed'><p>Read a BED file</p></a></li>
<li><a href='#read_blast'><p>Read BLAST tab-separated output</p></a></li>
<li><a href='#read_context'><p>Read files in different contexts</p></a></li>
<li><a href='#read_gbk'><p>Read genbank files</p></a></li>
<li><a href='#read_gff3'><p>Read features from GFF3 (and with some limitations GFF2/GTF) files</p></a></li>
<li><a href='#read_paf'><p>Read a .paf file (minimap/minimap2).</p></a></li>
<li><a href='#read_seq_len'><p>Read sequence index</p></a></li>
<li><a href='#read_tracks'><p>Read files in various standard formats (FASTA, GFF3, GBK, BED, BLAST, ...) into track tables</p></a></li>
<li><a href='#read_vcf'><p>Read a VCF file</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#require_vars'><p>Require variables in an object</p></a></li>
<li><a href='#scale_color_variant'><p>Default colors and shapes for mutation types.</p></a></li>
<li><a href='#scale_x_bp'><p>X-scale for genomic data</p></a></li>
<li><a href='#set_class'><p>Modify object class attriutes</p></a></li>
<li><a href='#shift'><p>Shift bins left/right</p></a></li>
<li><a href='#split_by'><p>Split by key preserving order</p></a></li>
<li><a href='#strand_chr'><p>Convert strand to character</p></a></li>
<li><a href='#strand_int'><p>Convert strand to integer</p></a></li>
<li><a href='#strand_lgl'><p>Convert strand to logical</p></a></li>
<li><a href='#swap_if'><p>Swap values of two columns based on a condition</p></a></li>
<li><a href='#swap_query'><p>Swap query and subject in blast-like feature tables</p></a></li>
<li><a href='#theme_gggenomes_clean'><p>gggenomes default theme</p></a></li>
<li><a href='#track_ids'><p>Named vector of track ids and types</p></a></li>
<li><a href='#track_info'><p>Basic info on tracks in a gggenomes object</p></a></li>
<li><a href='#unnest_exons'><p>Unnest exons</p></a></li>
<li><a href='#vars_track'><p>Tidyselect track variables</p></a></li>
<li><a href='#width'><p>The width of a range</p></a></li>
<li><a href='#write_gff3'><p>Write a gff3 file from a tidy table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Grammar of Graphics for Comparative Genomics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An extension of 'ggplot2' for creating complex genomic
 maps. It builds on the power of 'ggplot2' and 'tidyverse' adding new 'ggplot2'-style
 geoms &amp; positions and 'dplyr'-style verbs to manipulate the underlying data. It
 implements a layout concept inspired by 'ggraph' and introduces tracks to bring
 tidiness to the mess that is genomics data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/thackl/gggenomes">https://github.com/thackl/gggenomes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thackl/gggenomes/issues">https://github.com/thackl/gggenomes/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.2), ggplot2 (&ge; 3.5.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>vctrs, rlang, dplyr, tidyr, readr (&ge; 2.0.0), purrr, tibble,
stringr, grid, jsonlite, snakecase, magrittr, scales,
tidyselect, colorspace, methods, utils, ellipsis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ggtree, patchwork, Hmisc, knitr, ggrepel, IRanges,</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-30 11:05:40 UTC; thackl</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Hackl [aut, cre],
  Markus J. Ankenbrand [aut],
  Bart van Adrichem [aut],
  Kristina Haslinger [ctb, sad]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Hackl &lt;t.hackl@rug.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-30 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_feats'>Add different types of tracks</h2><span id='topic+add_feats'></span><span id='topic+add_links'></span><span id='topic+add_subfeats'></span><span id='topic+add_sublinks'></span><span id='topic+add_clusters'></span><span id='topic+add_tracks'></span>

<h3>Description</h3>

<p>Add different types of tracks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_feats(x, ...)

add_links(x, ..., .adjacent_only = TRUE)

add_subfeats(x, ..., .track_id = "genes", .transform = "aa2nuc")

add_sublinks(x, ..., .track_id = "genes", .transform = "aa2nuc")

add_clusters(x, ..., .track_id = "genes")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_feats_+3A_x">x</code></td>
<td>
<p>object to add the tracks to (e.g. gggenomes, gggenomes_layout)</p>
</td></tr>
<tr><td><code id="add_feats_+3A_...">...</code></td>
<td>
<p>named data.frames, i.e. genes=gene_df, snps=snp_df</p>
</td></tr>
<tr><td><code id="add_feats_+3A_.adjacent_only">.adjacent_only</code></td>
<td>
<p>indicate whether links should be drawn only between vertically adjacent tracks</p>
</td></tr>
<tr><td><code id="add_feats_+3A_.track_id">.track_id</code></td>
<td>
<p>track_id of the feats that subfeats, sublinks or clusters map to.</p>
</td></tr>
<tr><td><code id="add_feats_+3A_.transform">.transform</code></td>
<td>
<p>one of &quot;aa2nuc&quot;, &quot;none&quot;, &quot;nuc2aa&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gggenomes object with added features
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>add_feats()</code>: Add feature annotations to sequences
</p>
</li>
<li> <p><code>add_links()</code>: Add links connecting sequences, such as whole-genome
alignment data.
</p>
</li>
<li> <p><code>add_subfeats()</code>: Add features of features, such as gene/protein
domains, blast hits to genes/proteins, etc.
</p>
</li>
<li> <p><code>add_sublinks()</code>: Add links that connect features, such as
protein-protein alignments connecting genes.
</p>
</li>
<li> <p><code>add_clusters()</code>: Add gene clusters or other feature groups. Takes a
data.frame with at least two required columns <code>cluster_id</code> and <code>feat_id</code>. The
data.frame is converted to a link track connecting features belonging to the
same cluster over their entire length. Additionally, the data.frame is joined
to the parent feature track, adding <code>cluster_id</code> and all additional columns
to the parent table.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Add some repeat annotations
gggenomes(seqs = emale_seqs) %&gt;%
  add_feats(repeats = emale_tirs) +
  geom_seq() + geom_feat()

# Add all-vs-all whole-genome alignments
gggenomes(seqs = emale_seqs) %&gt;%
  add_links(links = emale_ava) +
  geom_seq() + geom_link()

# Add domains to genes
genes &lt;- tibble::tibble(seq_id = "A", start = 100, end = 200, feat_id = "gene1")
domains &lt;- tibble::tibble(feat_id = "gene1", start = 40, end = 80)
gggenomes(genes = genes) %&gt;% add_subfeats(domains, .transform = "none") +
  geom_gene() + geom_feat()

# Add protein-protein alignments
gggenomes(emale_genes) %&gt;%
  add_sublinks(emale_prot_ava) +
  geom_gene() + geom_link()

# add clusters
gggenomes(emale_genes, emale_seqs) %&gt;%
  add_clusters(emale_cogs) %&gt;%
  sync() + # works because clusters
  geom_link() + # become links
  geom_seq() +
  # works because cluster info is joined to gene track
  geom_gene(aes(fill = ifelse(is.na(cluster_id), NA,
    stringr::str_glue("{cluster_id} [{cluster_size}]")
  ))) +
  scale_fill_discrete("COGs")

</code></pre>

<hr>
<h2 id='add_seqs'>Add seqs</h2><span id='topic+add_seqs'></span>

<h3>Description</h3>

<p>Add seqs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_seqs(x, seqs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_seqs_+3A_x">x</code></td>
<td>
<p>a gggenomes or gggenomes_layout objekt</p>
</td></tr>
<tr><td><code id="add_seqs_+3A_seqs">seqs</code></td>
<td>
<p>the sequences to add</p>
</td></tr>
<tr><td><code id="add_seqs_+3A_...">...</code></td>
<td>
<p>pass through to <code>as_seqs()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a gggenomes or gggenomes_layout object with added seqs
</p>

<hr>
<h2 id='as_feats'>Compute a layout for feat data</h2><span id='topic+as_feats'></span>

<h3>Description</h3>

<p>Read feat data such as genes into a tidy dataframe and augment it with
layout information based on a sequence layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_feats(x, seqs, ..., everything = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_feats_+3A_x">x</code></td>
<td>
<p>feat data convertible to a feat layout</p>
</td></tr>
<tr><td><code id="as_feats_+3A_seqs">seqs</code></td>
<td>
<p>the sequence layout the feat map onto.</p>
</td></tr>
<tr><td><code id="as_feats_+3A_...">...</code></td>
<td>
<p>passed on to <code>layout_seqs()</code></p>
</td></tr>
<tr><td><code id="as_feats_+3A_everything">everything</code></td>
<td>
<p>set to FALSE to drop optional columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obligatory columns are <code>seq_id</code>, <code>start</code> and <code>end</code>. Also recognized are
<code>strand</code> and <code>bin_id</code>.
</p>
<p>Note <code>start</code> and <code>end</code> for every record will be coerced so that <code>start &lt; end</code>. If no <code>strand</code> was provided, <code>strand</code> will added and set to &quot;+&quot; for
records that initially had <code>start &lt; end</code> and &quot;-&quot; for <code>end &lt; start</code> inputs. If
<code>strand</code> was provided, <code>start</code> and <code>end</code> will be ordered without any
additional effect.
</p>


<h3>Value</h3>

<p>a tbl_df with plot coordinates
</p>

<hr>
<h2 id='as_links'>Compute a layout for link data</h2><span id='topic+as_links'></span>

<h3>Description</h3>

<p>Read link data of pairwise sequence or feat comparisons, such as
similarity searches into a tidy dataframe and augment it with layout
information based on a sequence layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_links(x, seqs, ..., everything = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_links_+3A_x">x</code></td>
<td>
<p>link data convertible to a link layout</p>
</td></tr>
<tr><td><code id="as_links_+3A_seqs">seqs</code></td>
<td>
<p>the sequence layout the feat map onto.</p>
</td></tr>
<tr><td><code id="as_links_+3A_...">...</code></td>
<td>
<p>passed on to <code>layout_seqs()</code></p>
</td></tr>
<tr><td><code id="as_links_+3A_everything">everything</code></td>
<td>
<p>set to FALSE to drop optional columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obligatory columns are <code>seq_id</code> and <code>seq_id2</code>. Also recognized are
<code>start</code>, <code>end</code>,<code>start2</code>,<code>end2</code>,<code>strand</code>, bin_id<code>and</code>bin_id2.
</p>
<p>During layouting, seq_id,start,end will be projected to x,xend,y, while
seq_id2,start2,end2 will be projected to xmin,xmax,yend. gggenomes uses these
maybe a bit odd names for the variables here, is so that they play nice with
ggplots native transformation functions for position aesthetics. Those only
work well with a specific set of predefined var names, which include those
used above.
</p>


<h3>Value</h3>

<p>a link layout
</p>

<hr>
<h2 id='as_seqs'>Compute a layout for sequence data</h2><span id='topic+as_seqs'></span><span id='topic+as_seqs.tbl_df'></span>

<h3>Description</h3>

<p>Read sequence data of multiple genomes (contigs, chromosomes, ...) into a
tidy dataframe and augment it with layout information necessary for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_seqs(x, ...)

## S3 method for class 'tbl_df'
as_seqs(x, everything = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_seqs_+3A_x">x</code></td>
<td>
<p>an object convertible to a sequence layout</p>
</td></tr>
<tr><td><code id="as_seqs_+3A_...">...</code></td>
<td>
<p>pass through to <code>layout_seqs()</code></p>
</td></tr>
<tr><td><code id="as_seqs_+3A_everything">everything</code></td>
<td>
<p>set to FALSE to drop optional columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obligatory columns are <code>seq_id</code>, <code>bin_id</code> and <code>length</code>.
</p>


<h3>Value</h3>

<p>an tbl_df with plot coordinates
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as_seqs(tbl_df)</code>: Convert a list of tibbles into a seq layout
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>chr &lt;- tibble::tibble(
  seq_id = c("a1", "b1", "b2"),
  bin_id = c(rep("A", 1), rep("B", 2)),
  length = c(5000, 3000, 1400)
)

as_seqs(chr)
</code></pre>

<hr>
<h2 id='as_subfeats'>Compute a layout for subfeat data</h2><span id='topic+as_subfeats'></span><span id='topic+as_subfeats.tbl_df'></span>

<h3>Description</h3>

<p>Read subfeat data such as domains or blast hits on genes into a tidy
dataframe. Subfeats need to be associated with an already added feat
track. The subfeat track itself is internally converted into a new,
regular feat track by mapping the <code>start</code> and <code>end</code> coordinates provided
relative to their parent feat into coordinates relative to the sequences
underlying the parent feats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_subfeats(x, seqs, feats, ..., everything = TRUE)

## S3 method for class 'tbl_df'
as_subfeats(
  x,
  seqs,
  feats,
  ...,
  everything = TRUE,
  transform = c("none", "aa2nuc", "nuc2aa")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_subfeats_+3A_x">x</code></td>
<td>
<p>subfeat data convertible to a feat layout</p>
</td></tr>
<tr><td><code id="as_subfeats_+3A_seqs">seqs</code></td>
<td>
<p>the sequence layout the parent feats map onto.</p>
</td></tr>
<tr><td><code id="as_subfeats_+3A_feats">feats</code></td>
<td>
<p>the parent feats the subfeats map onto.</p>
</td></tr>
<tr><td><code id="as_subfeats_+3A_...">...</code></td>
<td>
<p>passed on to <code>layout_seqs()</code>
spaces, i.e. if matching nucleotide-level annotations to protein level
annotations, e.g. genes and protein blast results.</p>
</td></tr>
<tr><td><code id="as_subfeats_+3A_everything">everything</code></td>
<td>
<p>set to FALSE to drop optional columns</p>
</td></tr>
<tr><td><code id="as_subfeats_+3A_transform">transform</code></td>
<td>
<p>use if feats and subfeats are in different coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obligatory columns are <code>feat_id</code>, <code>start</code> and <code>end</code>. Also recognized are
<code>strand</code> and <code>bin_id</code>.
</p>
<p>Note <code>start</code> and <code>end</code> for every record will be coerced so that <code>start &lt; end</code>. If no <code>strand</code> was provided, <code>strand</code> will be added and set to &quot;+&quot; for
records that initially had <code>start &lt; end</code> and &quot;-&quot; for <code>end &lt; start</code> inputs. If
<code>strand</code> was provided, <code>start</code> and <code>end</code> will be reorganized to conform with
<code>start &lt; end</code> without any additional effect.
</p>


<h3>Value</h3>

<p>a tbl_df with plot coordinates
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as_subfeats(tbl_df)</code>: Convert a list of tibbles into a feat layout
</p>
</li></ul>

<hr>
<h2 id='as_sublinks'>Compute a layout for links linking feats</h2><span id='topic+as_sublinks'></span><span id='topic+as_sublinks.tbl_df'></span>

<h3>Description</h3>

<p>Reads sublinks connecting feats such as all-vs-all protein blasts into a
tidy dataframe. sublinks need to be associated with an already added feat
track. The sublinks are internally converted into a regular link track by
mapping the feat-based <code>start</code> and <code>end</code> coordinates to coordinates
relative to the sequences underlying the linked feats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sublinks(x, seqs, feats, ..., everything = TRUE)

## S3 method for class 'tbl_df'
as_sublinks(
  x,
  seqs,
  feats,
  ...,
  everything = TRUE,
  transform = c("none", "aa2nuc", "nuc2aa"),
  compute_layout = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sublinks_+3A_x">x</code></td>
<td>
<p>sublink data convertible to a link layout</p>
</td></tr>
<tr><td><code id="as_sublinks_+3A_seqs">seqs</code></td>
<td>
<p>the sequence layout the linked feats map onto.</p>
</td></tr>
<tr><td><code id="as_sublinks_+3A_feats">feats</code></td>
<td>
<p>the feats the sublinks map onto.</p>
</td></tr>
<tr><td><code id="as_sublinks_+3A_...">...</code></td>
<td>
<p>passed on to <code>layout_seqs()</code>
spaces, i.e. if matching nucleotide-level annotations to protein level
annotations, e.g. genes and protein blast results.</p>
</td></tr>
<tr><td><code id="as_sublinks_+3A_everything">everything</code></td>
<td>
<p>set to FALSE to drop optional columns</p>
</td></tr>
<tr><td><code id="as_sublinks_+3A_transform">transform</code></td>
<td>
<p>use if feats and sublinks are in different coordinate</p>
</td></tr>
<tr><td><code id="as_sublinks_+3A_compute_layout">compute_layout</code></td>
<td>
<p>set to FALSE to skip layout computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only obligatory columns are <code>feat_id</code> &amp; <code>feat_id2</code>. Also
recognized are <code>start/end</code>, <code>start2/end2</code> and <code>strand</code>.
</p>
<p>Note <code>start</code> and <code>end</code> for every record will be coerced so that <code>start &lt; end</code>. If no <code>strand</code> was provided, <code>strand</code> will be added and set to &quot;+&quot; for
records that initially had <code style="white-space: pre;">&#8288;start &lt; end == start2 &lt; end2&#8288;</code> and &quot;-&quot;
otherwise. If <code>strand</code> was provided, <code>start</code> and <code>end</code> will be reorganized to
conform with <code>start &lt; end</code> without any additional effect.
</p>


<h3>Value</h3>

<p>a tbl_df with plot coordinates
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as_sublinks(tbl_df)</code>: Convert a list of tibbles into a link layout
</p>
</li></ul>

<hr>
<h2 id='check_strand'>Check strand</h2><span id='topic+check_strand'></span>

<h3>Description</h3>

<p>Check strand
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_strand(strand, na)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_strand_+3A_strand">strand</code></td>
<td>
<p>some representation for strandedness</p>
</td></tr>
<tr><td><code id="check_strand_+3A_na">na</code></td>
<td>
<p>what to use for <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>strand vector with unknown values replaced by <code>na</code>
</p>

<hr>
<h2 id='combine_strands'>Combine strands</h2><span id='topic+combine_strands'></span>

<h3>Description</h3>

<p>Combine strands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_strands(strand, strand2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_strands_+3A_strand">strand</code></td>
<td>
<p>first strand</p>
</td></tr>
<tr><td><code id="combine_strands_+3A_strand2">strand2</code></td>
<td>
<p>second strand</p>
</td></tr>
<tr><td><code id="combine_strands_+3A_...">...</code></td>
<td>
<p>more strands</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the combined strand
</p>

<hr>
<h2 id='def_formats'>Defined file formats and extensions</h2><span id='topic+def_formats'></span>

<h3>Description</h3>

<p>For seamless reading of different file formats, gggenomes uses a mapping of
known formats to associated file extensions and contexts in which the
different formats can be read. The notion of context allows one to read
different information from the same format/extension. For example, a gbk file
holds both feature and sequence information. If read in &quot;feats&quot; context
<code>read_feats("*.gbk")</code> it will return a feature table, if read in &quot;seqs&quot;
context <code>read_seqs("*.gbk")</code>, a sequence index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_formats(
  file = NULL,
  ext = NULL,
  context = NULL,
  parser = NULL,
  allow_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="def_formats_+3A_file">file</code></td>
<td>
<p>a vector of file names</p>
</td></tr>
<tr><td><code id="def_formats_+3A_ext">ext</code></td>
<td>
<p>a vector of file extensions</p>
</td></tr>
<tr><td><code id="def_formats_+3A_context">context</code></td>
<td>
<p>a vector of file contexts defined in
<code>gggenomes_global$def_formats</code></p>
</td></tr>
<tr><td><code id="def_formats_+3A_parser">parser</code></td>
<td>
<p>a vector of file parsers defined in
<code>gggenomes_global$def_formats</code></p>
</td></tr>
<tr><td><code id="def_formats_+3A_allow_na">allow_na</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dictionarish vector of file formats with recognized extensions as
names
</p>


<h3>Defined formats, extensions, contexts, and parsers</h3>

<pre>
      format                           ext            context                                              parser
1  ambigious                 txt, tsv, csv                 NA                                      read_ambigious
2      fasta fa, fas, fasta, ffn, fna, faa               seqs                                        read_seq_len
3        fai                           fai               seqs                                            read_fai
4       gff3          gff, gff3, gff2, gtf        feats, seqs                             read_gff3, read_seq_len
5        gbk           gbk, gb, gbff, gpff        feats, seqs                              read_gbk, read_seq_len
6        bed                           bed              feats                                            read_bed
7      blast                    m8, o6, o7       feats, links                              read_blast, read_blast
8        paf                           paf       feats, links                                  read_paf, read_paf
9      alitv                          json feats, seqs, links read_alitv_genes, read_alitv_seqs, read_alitv_links
10       vcf                           vcf              feats                                            read_vcf
</pre>


<h3>Examples</h3>

<pre><code class='language-R'># vector of defined zip formats and recognized extensions as names
# format of file
def_formats("foo.fa")

# formats associated with each extension
def_formats(ext = c("fa", "gff"))

# all formats/extensions that can be read in seqs context; includes formats
# that are defined for context=NA, i.e. that can be read in any context.
def_formats(context = "seqs")
</code></pre>

<hr>
<h2 id='def_names'>Default column names and types for defined formats</h2><span id='topic+def_names'></span><span id='topic+def_types'></span>

<h3>Description</h3>

<p>Intended to be used in <code><a href="readr.html#topic+read_delim">readr::read_tsv()</a></code>-like functions that accept a
<code>col_names</code> and a <code>col_types</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_names(format)

def_types(format)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="def_names_+3A_format">format</code></td>
<td>
<p>specify a format known to gggenomes, such as <code>gff3</code>, <code>gbk</code>, ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with default column names for the given format
</p>
<p>a vector with default column types for the given format
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>def_names()</code>: default column names for defined formats
</p>
</li>
<li> <p><code>def_types()</code>: default column types for defined formats
</p>
</li></ul>


<h3>Defined formats, column types and names</h3>

<pre>
  gff3       ccciicccc       seq_id,source,type,start,end,score,strand,phase,attributes
  paf        ciiicciiiiid    seq_id,length,start,end,strand,seq_id2,length2,start2,end2,map_match,map_length,map_quality
  blast      ccdiiiiiiidd    seq_id,seq_id2,pident,length,mismatch,gapopen,start,end,start2,end2,evalue,bitscore
  bed        ciicdc          seq_id,start,end,name,score,strand
  fai        ci---           seq_id,seq_desc,length
  seq_len    cci             seq_id,seq_desc,length
  vcf        cicccdccc       seq_id,start,feat_id,ref,alt,qual,filter,info,format
</pre>


<h3>Examples</h3>

<pre><code class='language-R'># read a blast-tabular file with read_tsv
readr::read_tsv(ex("emales/emales-prot-ava.o6"), col_names = def_names("blast"))
</code></pre>

<hr>
<h2 id='dim.gggenomes_layout'><code>ggplot2::facet_null</code> checks data with <code>empty(df)</code> using <code>dim</code>. This causes
an error because dim(gggenome_layout) is undefined. Return dim of primary
table instead</h2><span id='topic+dim.gggenomes_layout'></span>

<h3>Description</h3>

<p><code>ggplot2::facet_null</code> checks data with <code>empty(df)</code> using <code>dim</code>. This causes
an error because dim(gggenome_layout) is undefined. Return dim of primary
table instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gggenomes_layout'
dim(x)
</code></pre>


<h3>Value</h3>

<p>dim of primary table
</p>

<hr>
<h2 id='drop_feat_layout'>Drop feature layout</h2><span id='topic+drop_feat_layout'></span>

<h3>Description</h3>

<p>Drop feature layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_feat_layout(x, keep = "strand")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_feat_layout_+3A_x">x</code></td>
<td>
<p>feat_layout</p>
</td></tr>
<tr><td><code id="drop_feat_layout_+3A_keep">keep</code></td>
<td>
<p>features to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>feat_layout without unwanted features
</p>

<hr>
<h2 id='drop_layout'>Drop a genome layout</h2><span id='topic+drop_layout'></span>

<h3>Description</h3>

<p>Drop a genome layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_layout(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_layout_+3A_data">data</code></td>
<td>
<p>layout</p>
</td></tr>
<tr><td><code id="drop_layout_+3A_...">...</code></td>
<td>
<p>additional data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gggenomes object without layout
</p>

<hr>
<h2 id='drop_link_layout'>Drop a link layout</h2><span id='topic+drop_link_layout'></span>

<h3>Description</h3>

<p>Drop a link layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_link_layout(x, keep = "strand")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_link_layout_+3A_x">x</code></td>
<td>
<p>link_layout</p>
</td></tr>
<tr><td><code id="drop_link_layout_+3A_keep">keep</code></td>
<td>
<p>features to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>link_layout without unwanted features
</p>

<hr>
<h2 id='drop_seq_layout'>Drop a seq layout</h2><span id='topic+drop_seq_layout'></span>

<h3>Description</h3>

<p>Drop a seq layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_seq_layout(x, keep = "strand")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_seq_layout_+3A_x">x</code></td>
<td>
<p>seq_layout</p>
</td></tr>
<tr><td><code id="drop_seq_layout_+3A_keep">keep</code></td>
<td>
<p>features to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>seq_layout without unwanted features
</p>

<hr>
<h2 id='emale_ava'>All-versus-all whole genome alignments of 6 EMALE genomes</h2><span id='topic+emale_ava'></span>

<h3>Description</h3>

<p>One row per alignment block. Alignments were computed with minimap2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_ava
</code></pre>


<h3>Format</h3>

<p>A data frame with 125 rows and 23 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>seq_id</dt><dd><p>identifier of the sequence the feature appears on</p>
</dd>
<dt>length</dt><dd><p>length of the sequence</p>
</dd>
<dt>start</dt><dd><p>start of the feature on the sequence</p>
</dd>
<dt>end</dt><dd><p>end of the feature on the sequence</p>
</dd>
<dt>strand</dt><dd><p>orientation of the feature relative to the sequence (+ or -)</p>
</dd>
<dt>seq_id2</dt><dd><p>identifier of the sequence the feature appears on</p>
</dd>
<dt>length2</dt><dd><p>length of the sequence</p>
</dd>
<dt>start2</dt><dd><p>start of the feature on the sequence</p>
</dd>
<dt>end2</dt><dd><p>end of the feature on the sequence</p>
</dd>
<dt>map_match, map_length, map_quality, NM, ms, AS, nn, tp, cm, s1, de, rl, cg</dt><dd><p>see <a href="https://github.com/lh3/miniasm/blob/master/PAF.md">https://github.com/lh3/miniasm/blob/master/PAF.md</a> for additional columns</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales.paf")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_cogs'>Clusters of orthologs of 6 EMALE proteomes</h2><span id='topic+emale_cogs'></span>

<h3>Description</h3>

<p>One row per feature. Clusters are based on manual curation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_cogs
</code></pre>


<h3>Format</h3>

<p>A data frame with 48 rows and 3 columns
</p>

<dl>
<dt>cluster_id</dt><dd><p>identifier of the cluster</p>
</dd>
<dt>feat_id</dt><dd><p>identifer of the gene</p>
</dd>
<dt>cluster_size</dt><dd><p>number of features in the cluster</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales-cogs.tsv")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_gc'>Relative GC-content along 6 EMALE genomes</h2><span id='topic+emale_gc'></span>

<h3>Description</h3>

<p>One row per 50 bp window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_gc
</code></pre>


<h3>Format</h3>

<p>A data frame with 2856 rows and 6 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>seq_id</dt><dd><p>identifier of the sequence the feature appears on</p>
</dd>
<dt>start</dt><dd><p>start of the feature on the sequence</p>
</dd>
<dt>end</dt><dd><p>end of the feature on the sequence</p>
</dd>
<dt>name</dt><dd><p>name of the feature</p>
</dd>
<dt>score</dt><dd><p>relative GC-content of the window</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales-gc.bed")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_genes'>Gene annotations if 6 EMALE genomes (endogenous virophages)</h2><span id='topic+emale_genes'></span>

<h3>Description</h3>

<p>A data set containing gene feature annotations for 6 endogenous virophages
found in the genomes of the marine protist <em>Cafeteria burkhardae</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_genes
</code></pre>


<h3>Format</h3>

<p>A data frame with 143 rows and 17 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>seq_id</dt><dd><p>identifier of the sequence the feature appears on</p>
</dd>
<dt>start</dt><dd><p>start of the feature on the sequence</p>
</dd>
<dt>end</dt><dd><p>end of the feature on the sequence</p>
</dd>
<dt>strand</dt><dd><p>reading orientation relative to sequence (+ or -)</p>
</dd>
<dt>type</dt><dd><p>feature type (CDS, mRNA, gene, ...)</p>
</dd>
<dt>feat_id</dt><dd><p>unique identifier of the feature</p>
</dd>
<dt>introns</dt><dd><p>a list column with internal intron start/end positions</p>
</dd>
<dt>parent_ids</dt><dd><p>a list column with parent IDs - feat_id's of parent features</p>
</dd>
<dt>source</dt><dd><p>source of the annotation</p>
</dd>
<dt>score</dt><dd><p>score of the annotation</p>
</dd>
<dt>phase</dt><dd><p>For &quot;CDS&quot; features indicates where the next codon begins relative to the 5' start</p>
</dd>
<dt>width</dt><dd><p>width of the feature</p>
</dd>
<dt>gc_content</dt><dd><p>relative GC-content of the feature</p>
</dd>
<dt>name</dt><dd><p>name of the feature</p>
</dd>
<dt>Note</dt><dd></dd>
<dt>geom_id</dt><dd><p>an identifier telling the which features should be plotted as on items (usually CDS and mRNA of same gene)</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Publication: <a href="https://doi.org/10.1101/2020.11.30.404863">doi:10.1101/2020.11.30.404863</a>
</p>
</li>
<li><p> Raw data: <a href="https://github.com/thackl/cb-emales">https://github.com/thackl/cb-emales</a>
</p>
</li>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales.gff")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_ngaros'>Integrated Ngaro retrotransposons of 6 EMALE genomes</h2><span id='topic+emale_ngaros'></span>

<h3>Description</h3>

<p>Integrated Ngaro retrotransposons of 6 EMALE genomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_ngaros
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 14 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>seq_id</dt><dd><p>identifier of the sequence the feature appears on</p>
</dd>
<dt>start</dt><dd><p>start of the feature on the sequence</p>
</dd>
<dt>end</dt><dd><p>end of the feature on the sequence</p>
</dd>
<dt>strand</dt><dd><p>orientation of the feature relative to the sequence (+ or -)</p>
</dd>
<dt>type</dt><dd><p>feature type (CDS, mRNA, gene, ...)</p>
</dd>
<dt>feat_id</dt><dd><p>unique identifier of the feature</p>
</dd>
<dt>introns</dt><dd><p>a list column with internal intron start/end positions</p>
</dd>
<dt>parent_ids</dt><dd><p>a list column with parent IDs - feat_id's of parent features</p>
</dd>
<dt>source</dt><dd><p>source of the annotation</p>
</dd>
<dt>score</dt><dd><p>score of the annotation</p>
</dd>
<dt>phase</dt><dd><p>For &quot;CDS&quot; features indicates where the next codon begins relative to the 5' start</p>
</dd>
<dt>name</dt><dd><p>name of the feature</p>
</dd>
<dt>geom_id</dt><dd><p>an identifier telling the which features should be plotted as on items (usually CDS and mRNA of same gene)</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Publication: <a href="https://doi.org/10.1101/2020.11.30.404863">doi:10.1101/2020.11.30.404863</a>
</p>
</li>
<li><p> Raw data: <a href="https://github.com/thackl/cb-emales">https://github.com/thackl/cb-emales</a>
</p>
</li>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales-ngaros.gff")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_prot_ava'>All-versus-all alignments 6 EMALE proteomes</h2><span id='topic+emale_prot_ava'></span>

<h3>Description</h3>

<p>One row per alignment. Alignments were computed with mmseqs2 (blast-like).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_prot_ava
</code></pre>


<h3>Format</h3>

<p>A data frame with 827 rows and 13 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>feat_id</dt><dd><p>identifier of the first feature in the alignment</p>
</dd>
<dt>feat_id2</dt><dd><p>identifier of the second feature in the alignment</p>
</dd>
<dt>pident, length, mismatch, gapopen, start, end, start2, end2, evalue, bitscore</dt><dd><p>see <a href="https://github.com/seqan/lambda/wiki/BLAST-Output-Formats">https://github.com/seqan/lambda/wiki/BLAST-Output-Formats</a> for BLAST-tabular format columns</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales-prot-ava.o6")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_seqs'>Sequence index of 6 EMALE genomes (endogenous virophages)</h2><span id='topic+emale_seqs'></span>

<h3>Description</h3>

<p>A data set containing the sequence information on 6 endogenous virophages
found in the genomes of the marine protist <em>Cafeteria burkhardae</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_seqs
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows and 4 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>seq_id</dt><dd><p>sequence identifier</p>
</dd>
<dt>seq_desc</dt><dd><p>sequence description</p>
</dd>
<dt>length</dt><dd><p>length of the sequence</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Publication: <a href="https://doi.org/10.1101/2020.11.30.404863">doi:10.1101/2020.11.30.404863</a>
</p>
</li>
<li><p> Raw data: <a href="https://github.com/thackl/cb-emales">https://github.com/thackl/cb-emales</a>
</p>
</li>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales.fna")</code>
</p>
</li></ul>


<hr>
<h2 id='emale_tirs'>Terminal inverted repeats of 6 EMALE genomes</h2><span id='topic+emale_tirs'></span>

<h3>Description</h3>

<p>Terminal inverted repeats of 6 EMALE genomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emale_tirs
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 14 columns
</p>

<dl>
<dt>file_id</dt><dd><p>name of the file the data was read from</p>
</dd>
<dt>seq_id</dt><dd><p>identifier of the sequence the feature appears on</p>
</dd>
<dt>start</dt><dd><p>start of the feature on the sequence</p>
</dd>
<dt>end</dt><dd><p>end of the feature on the sequence</p>
</dd>
<dt>strand</dt><dd><p>reading orientation relative to sequence (+ or -)</p>
</dd>
<dt>type</dt><dd><p>feature type (CDS, mRNA, gene, ...)</p>
</dd>
<dt>feat_id</dt><dd><p>unique identifier of the feature</p>
</dd>
<dt>introns</dt><dd><p>a list column with internal intron start/end positions</p>
</dd>
<dt>parent_ids</dt><dd><p>a list column with parent IDs - feat_id's of parent features</p>
</dd>
<dt>source</dt><dd><p>source of the annotation</p>
</dd>
<dt>score</dt><dd><p>score of the annotation</p>
</dd>
<dt>phase</dt><dd><p>For &quot;CDS&quot; features indicates where the next codon begins relative to the 5' start</p>
</dd>
<dt>name</dt><dd><p>name of the feature</p>
</dd>
<dt>width</dt><dd><p>end-start+1</p>
</dd>
<dt>geom_id</dt><dd><p>an identifier telling the which features should be plotted as on items (usually CDS and mRNA of same gene)</p>
</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p> Publication: <a href="https://doi.org/10.1101/2020.11.30.404863">doi:10.1101/2020.11.30.404863</a>
</p>
</li>
<li><p> Raw data: <a href="https://github.com/thackl/cb-emales">https://github.com/thackl/cb-emales</a>
</p>
</li>
<li><p> Derived &amp; bundled data: <code>ex("emales/emales-tirs.gff")</code>
</p>
</li></ul>


<hr>
<h2 id='ex'>Get path to gggenomes example files</h2><span id='topic+ex'></span>

<h3>Description</h3>

<p>Get path to gggenomes example files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_+3A_file">file</code></td>
<td>
<p>name of example file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>path to example file
</p>

<hr>
<h2 id='feats'>Use tracks inside and outside <code style="white-space: pre;">&#8288;geom_*&#8288;</code> calls</h2><span id='topic+feats'></span><span id='topic+feats0'></span><span id='topic+genes'></span><span id='topic+links'></span><span id='topic+seqs'></span><span id='topic+bins'></span><span id='topic+track'></span><span id='topic+pull_feats'></span><span id='topic+pull_genes'></span><span id='topic+pull_links'></span><span id='topic+pull_seqs'></span><span id='topic+pull_bins'></span><span id='topic+pull_bins.gggenomes_layout'></span><span id='topic+pull_track'></span>

<h3>Description</h3>

<p>Track selection works like <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> and supports unquoted ids and
positional arguments. <code>...</code> can be used to subset the data in
<code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> fashion. <code>pull</code>-prefixed variants return the specified
track from a gggenome object. Unprefixed variants work inside <code style="white-space: pre;">&#8288;geom_*&#8288;</code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feats(.track_id = 1, ..., .ignore = "genes", .geneify = FALSE)

feats0(.track_id = 1, ..., .ignore = NA, .geneify = FALSE)

genes(..., .gene_types = c("CDS", "mRNA", "tRNA", "tmRNA", "ncRNA", "rRNA"))

links(.track_id = 1, ..., .ignore = NULL, .adjacent_only = NULL)

seqs(...)

bins(..., .group = vars())

track(.track_id = 1, ..., .track_type = NULL, .ignore = NULL)

pull_feats(.x, .track_id = 1, ..., .ignore = "genes", .geneify = FALSE)

pull_genes(
  .x,
  ...,
  .gene_types = c("CDS", "mRNA", "tRNA", "tmRNA", "ncRNA", "rRNA")
)

pull_links(.x, .track_id = 1, ..., .ignore = NULL, .adjacent_only = NULL)

pull_seqs(.x, ...)

pull_bins(.x, ..., .group = vars())

## S3 method for class 'gggenomes_layout'
pull_bins(.x, ..., .group = vars())

pull_track(.x, .track_id = 1, ..., .track_type = NULL, .ignore = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feats_+3A_.track_id">.track_id</code></td>
<td>
<p>The track to pull out, either as a literal variable name or
as a positive/negative integer giving the position from the left/right.</p>
</td></tr>
<tr><td><code id="feats_+3A_...">...</code></td>
<td>
<p>Logical predicates passed on to <a href="dplyr.html#topic+filter">dplyr::filter</a>. &quot;seqs&quot;, &quot;feats&quot;,
&quot;links&quot;. Affects position-based selection.</p>
</td></tr>
<tr><td><code id="feats_+3A_.ignore">.ignore</code></td>
<td>
<p>track names to ignore when selecting by position.
Default is &quot;genes&quot;, if using <code>feats0</code> this defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="feats_+3A_.geneify">.geneify</code></td>
<td>
<p>add dummy type, introns and geom_id column to play nicely
with geoms supporting multi-level and spliced gene models.</p>
</td></tr>
<tr><td><code id="feats_+3A_.gene_types">.gene_types</code></td>
<td>
<p>return only feats of this type (<code>type %in% .gene_types</code>)</p>
</td></tr>
<tr><td><code id="feats_+3A_.adjacent_only">.adjacent_only</code></td>
<td>
<p>filter for links connecting direct neighbors
(<code style="white-space: pre;">&#8288;abs(y-yend)==1)&#8288;</code>)</p>
</td></tr>
<tr><td><code id="feats_+3A_.group">.group</code></td>
<td>
<p>what variables to use in grouping of bins from seqs in addition
to <code>y</code> and <code>bin_id</code>. Use this to get additional shared variables from the
seqs table into the bins table.</p>
</td></tr>
<tr><td><code id="feats_+3A_.track_type">.track_type</code></td>
<td>
<p>restrict to these types of tracks - any combination of
&quot;seqs&quot;, &quot;feats&quot;, &quot;links&quot;.</p>
</td></tr>
<tr><td><code id="feats_+3A_.x">.x</code></td>
<td>
<p>A gggenomes or gggenomes_layout object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that pulls the specified track from a gggenomes object.
</p>
<p>A function that pulls the specified track from a gggenomes object.
</p>
<p>A function that pulls the specified track from a gggenomes object.
</p>
<p>A function that pulls the specified track from a gggenomes object.
</p>
<p>A function that pulls the specified track from a gggenomes object.
</p>
<p>A function that pulls the specified track from a gggenomes object.
</p>
<p>A function that pulls the specified track from a gggenomes object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>feats()</code>: by default pulls out the first feat track not named
&quot;genes&quot;.
</p>
</li>
<li> <p><code>feats0()</code>: by default pulls out the first feat track.
</p>
</li>
<li> <p><code>genes()</code>: pulls out the first feat track (genes), filtering
for records with <code>type=="CDS"</code>, and adding a dummy <code>gene_id</code> column if missing
to play nice with multi-exon <code>geom</code>s.
</p>
</li>
<li> <p><code>links()</code>: by default pulls out the first link track.
</p>
</li>
<li> <p><code>seqs()</code>: pulls out the seqs track (there is only one).
</p>
</li>
<li> <p><code>bins()</code>: pulls out a binwise summary table of the seqs data powering
<code style="white-space: pre;">&#8288;geom_bin_*()&#8288;</code> calls. The bin table is not a real track, but recomputed
on-the-fly.
</p>
</li>
<li> <p><code>track()</code>: pulls from all tracks in order seqs, feats, links.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
gg &lt;- gggenomes(emale_genes, emale_seqs, emale_tirs, emale_ava)
gg %&gt;% track_info() # info about track ids, positions and types

# get first feat track that isn't "genes" (all equivalent)
gg %&gt;% pull_feats() # easiest
gg %&gt;% pull_feats(feats) # by id
gg %&gt;% pull_feats(1) # by position
gg %&gt;% pull_feats(2, .ignore = NULL) # default .ignore="genes"

# get "seqs" track (always track #1)
gg %&gt;% pull_seqs()

# plot integrated transposons and GC content for some viral genomes
gg &lt;- gggenomes(seqs = emale_seqs, feats = list(emale_ngaros, GC = emale_gc))
gg + geom_seq() +
  geom_feat(color = "skyblue") + # defaults to data=feats()
  geom_line(aes(x, y + score - .6, group = y), data = feats(GC), color = "gray60")
</code></pre>

<hr>
<h2 id='flip'>Flip bins and sequences</h2><span id='topic+flip'></span><span id='topic+flip_seqs'></span><span id='topic+sync'></span>

<h3>Description</h3>

<p><code>flip</code> and <code>flip_seqs</code> reverse-complement specified bins or individual
sequences and their features. <code>sync</code> automatically flips bins using a
heuristic that maximizes the amount of forward strand links between
neighboring bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip(x, ..., .bin_track = seqs)

flip_seqs(x, ..., .bins = everything(), .seq_track = seqs, .bin_track = seqs)

sync(x, link_track = 1, min_support = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flip_+3A_x">x</code></td>
<td>
<p>a gggenomes object</p>
</td></tr>
<tr><td><code id="flip_+3A_...">...</code></td>
<td>
<p>bins or sequences to flip in dplyr::select like syntax (numeric
position or unquoted expressions)</p>
</td></tr>
<tr><td><code id="flip_+3A_.bin_track">.bin_track</code>, <code id="flip_+3A_.seq_track">.seq_track</code></td>
<td>
<p>when using a function as selector such as
<code><a href="tidyselect.html#topic+where">tidyselect::where()</a></code>, this specifies the track in which context the
function is evaluated.</p>
</td></tr>
<tr><td><code id="flip_+3A_.bins">.bins</code></td>
<td>
<p>preselection of bins with sequences to flip. Useful if selecting
by numeric position. It sets the context for selection, for example the
11th sequences of the total set might more easily described as the 2nd
sequences of the 3rd bin: <code>flip_seqs(2, .bins=3)</code>.</p>
</td></tr>
<tr><td><code id="flip_+3A_link_track">link_track</code></td>
<td>
<p>the link track to use for flipping bins nicely</p>
</td></tr>
<tr><td><code id="flip_+3A_min_support">min_support</code></td>
<td>
<p>only flip a bin if at least this many more nucleotides
support an inversion over the given orientation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see the help vignette:
<code>vignette("flip", package = "gggenomes")</code>
</p>


<h3>Value</h3>

<p>a gggenomes object with flipped bins or sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(patchwork)
p &lt;- gggenomes(genes = emale_genes) +
  geom_seq(aes(color = strand), arrow = TRUE) +
  geom_link(aes(fill = strand)) +
  expand_limits(color = c("-")) +
  labs(caption = "not flipped")

# nothing flipped
p0 &lt;- p %&gt;% add_links(emale_ava)

# flip manually
p1 &lt;- p %&gt;%
  add_links(emale_ava) %&gt;%
  flip(4:6) + labs(caption = "manually")

# flip automatically based on genome-genome links
p2 &lt;- p %&gt;%
  add_links(emale_ava) %&gt;%
  sync() + labs(caption = "genome alignments")

# flip automatically based on protein-protein links
p3 &lt;- p %&gt;%
  add_sublinks(emale_prot_ava) %&gt;%
  sync() + labs(caption = "protein alignments")

# flip automatically based on genes linked implicitly by belonging
# to the same clusters of orthologs (or any grouping of your choice)
p4 &lt;- p %&gt;%
  add_clusters(emale_cogs) %&gt;%
  sync() + labs(caption = "shared orthologs")

p0 + p1 + p2 + p3 + p4 + plot_layout(nrow = 1, guides = "collect")
</code></pre>

<hr>
<h2 id='flip_strand'>Flip strand</h2><span id='topic+flip_strand'></span>

<h3>Description</h3>

<p>Flip strand
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip_strand(strand, na = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flip_strand_+3A_strand">strand</code></td>
<td>
<p>some representation for strandedness</p>
</td></tr>
<tr><td><code id="flip_strand_+3A_na">na</code></td>
<td>
<p>what to use for <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the strand flipped
</p>

<hr>
<h2 id='focus'>Show features and regions of interest</h2><span id='topic+focus'></span><span id='topic+locate'></span>

<h3>Description</h3>

<p>Show loci containing features of interest. Loci can either be provided
as predefined regions directly (<code style="white-space: pre;">&#8288;loci=&#8288;</code>), or are constructed automatically
based on pre-selected features (via <code>...</code>). Features within <code>max_dist</code> are
greedily combined into the same locus. <code>locate()</code> adds these loci as new
track so that they can be easily visualized. <code>focus()</code> extracts those loci
from their parent sequences making them the new sequence set. These sequences
will have their <code>locus_id</code> as their new <code>seq_id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focus(
  x,
  ...,
  .track_id = 2,
  .max_dist = 10000,
  .expand = 5000,
  .overhang = c("drop", "trim", "keep"),
  .locus_id = str_glue("{seq_id}_lc{row_number()}"),
  .locus_id_group = seq_id,
  .locus_bin = c("bin", "seq", "locus"),
  .locus_score = n(),
  .locus_filter = TRUE,
  .loci = NULL
)

locate(
  x,
  ...,
  .track_id = 2,
  .max_dist = 10000,
  .expand = 5000,
  .locus_id = str_glue("{seq_id}_lc{row_number()}"),
  .locus_id_group = .data$seq_id,
  .locus_bin = c("bin", "seq", "locus"),
  .locus_score = n(),
  .locus_filter = TRUE,
  .locus_track = "loci"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focus_+3A_x">x</code></td>
<td>
<p>A gggenomes object</p>
</td></tr>
<tr><td><code id="focus_+3A_...">...</code></td>
<td>
<p>Logical predicates defined in terms of the variables in the track
given by <code>.track_id</code>. Multiple conditions are combined with &amp;. Only rows
where the condition evaluates to TRUE are kept.
</p>
<p>The arguments in ... are automatically quoted and evaluated in the
context of the data frame. They support unquoting and splicing. See
vignette(&quot;programming&quot;) for an introduction to these concepts.</p>
</td></tr>
<tr><td><code id="focus_+3A_.track_id">.track_id</code></td>
<td>
<p>the track to filter from - defaults to first feature track,
usually &quot;genes&quot;. Can be a quoted or unquoted string or a positional
argument giving the index of a track among all tracks (seqs, feats &amp;
links).</p>
</td></tr>
<tr><td><code id="focus_+3A_.max_dist">.max_dist</code></td>
<td>
<p>Maximum distance between adjacent features to be included
into the same locus, default 10kb.</p>
</td></tr>
<tr><td><code id="focus_+3A_.expand">.expand</code></td>
<td>
<p>The amount to nucleotides to expand the focus around the
target features. Default 2kb. Give two values for different up- and
downstream expansions.</p>
</td></tr>
<tr><td><code id="focus_+3A_.overhang">.overhang</code></td>
<td>
<p>How to handle features overlapping the locus boundaries
(including expand). Options are to &quot;keep&quot; them, &quot;trim&quot; them exactly at the
boundaries, or &quot;drop&quot; all features not fully included within the
boundaries.</p>
</td></tr>
<tr><td><code id="focus_+3A_.locus_id">.locus_id</code>, <code id="focus_+3A_.locus_id_group">.locus_id_group</code></td>
<td>
<p>How to generate the ids for the new loci
which will eventually become their new <code>seq_id</code>s.</p>
</td></tr>
<tr><td><code id="focus_+3A_.locus_bin">.locus_bin</code></td>
<td>
<p>What bin to assign new locus to. Defaults to keeping the
original binning, but can be set to the &quot;seq&quot; to bin all loci originating
from the same parent sequence, or to &quot;locus&quot; to separate all loci into
individual bins.</p>
</td></tr>
<tr><td><code id="focus_+3A_.locus_score">.locus_score</code></td>
<td>
<p>An expression evaluated in the context of all features
that are combined into a new locus. Results are stored in the column
<code>locus_score</code>. Defaults to the <code>n()</code>, i.e. the number of features per
locus. Set, for example, to <code>sum(bitscore)</code> to sum over all blast hit
bitscore of per locus. Usually used in conjunction with <code>.locus_filter</code>.</p>
</td></tr>
<tr><td><code id="focus_+3A_.locus_filter">.locus_filter</code></td>
<td>
<p>An predicate expression used to post-filter identified
loci. Set <code>.locus_filter=locus_score &gt;= 3</code> to only return loci comprising
at least 3 target features.</p>
</td></tr>
<tr><td><code id="focus_+3A_.loci">.loci</code></td>
<td>
<p>A data.frame specifying loci directly. Required columns are
<code style="white-space: pre;">&#8288;seq_id,start,end&#8288;</code>. Supersedes <code>...</code>.</p>
</td></tr>
<tr><td><code id="focus_+3A_.locus_track">.locus_track</code></td>
<td>
<p>The name of the new track containing the identified loci.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gggenomes object focused on the desired loci
</p>
<p>A gggenomes object with the new loci track added
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>focus()</code>: Identify regions of interest and zoom in on them
</p>
</li>
<li> <p><code>locate()</code>: Identify regions of interest and add them as new feature track
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's hunt some defense systems in marine SAGs
# read the genomes
s0 &lt;- read_seqs(ex("gorg/gorg.fna.fai"))
s1 &lt;- s0 %&gt;%
  # strip trailing number from contigs to get bins
  dplyr::mutate(bin_id = stringr::str_remove(seq_id, "_\\d+$"))
# gene annotations from prokka
g0 &lt;- read_feats(ex("gorg/gorg.gff.xz"))

# best hits to the PADS Arsenal database of prokaryotic defense-system genes
# $ mmseqs easy-search gorg.fna pads-arsenal-v1-prf gorg-pads-defense.o6 /tmp \
#     --greedy-best-hits
f0 &lt;- read_feats(ex("gorg/gorg-pads-defense.o6"))
f1 &lt;- f0 %&gt;%
  # parser system/gene info
  tidyr::separate(seq_id2, into = c("seq_id2", "system", "gene"), sep = ",") %&gt;%
  dplyr::filter(
    evalue &lt; 1e-10, # get rid of some spurious hits
    # and let's focus just on a few systems for this example
    system %in% c("CRISPR-CAS", "DISARM", "GABIJA", "LAMASSU", "THOERIS")
  )

# plot the distribution of hits across full genomes
gggenomes(g0, s1, f1, wrap = 2e5) +
  geom_seq() + geom_bin_label() +
  scale_color_brewer(palette = "Dark2") +
  geom_point(aes(x = x, y = y, color = system), data = feats())

# hilight the regions containing hits
gggenomes(g0, s1, f1, wrap = 2e5) %&gt;%
  locate(.track_id = feats) %&gt;%
  identity() +
  geom_seq() + geom_bin_label() +
  scale_color_brewer(palette = "Dark2") +
  geom_feat(data = feats(loci), color = "plum3") +
  geom_point(aes(x = x, y = y, color = system), data = feats())

# zoom in on loci
gggenomes(g0, s1, f1, wrap = 5e4) %&gt;%
  focus(.track_id = feats) +
  geom_seq() + geom_bin_label() +
  geom_gene() +
  geom_feat(aes(color = system)) +
  geom_feat_tag(aes(label = gene)) +
  scale_color_brewer(palette = "Dark2")
</code></pre>

<hr>
<h2 id='geom_bin_label'>Draw bin labels</h2><span id='topic+geom_bin_label'></span>

<h3>Description</h3>

<p>Put bin labels left of the sequences. <code>nudge_left</code> adds space relative to the
total bin width between the label and the seqs, by default 5%. <code>expand_left</code>
expands the plot to the left by 20% to make labels visible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_bin_label(
  mapping = NULL,
  data = bins(),
  hjust = 1,
  size = 3,
  nudge_left = 0.05,
  expand_left = 0.2,
  expand_x = NULL,
  expand_aes = NULL,
  yjust = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_bin_label_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_hjust">hjust</code></td>
<td>
<p>Moves the text horizontally</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_size">size</code></td>
<td>
<p>of the label</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_nudge_left">nudge_left</code></td>
<td>
<p>by this much relative to the widest bin</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_expand_left">expand_left</code></td>
<td>
<p>by this much relative to the widest bin</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_expand_x">expand_x</code></td>
<td>
<p>expand the plot to include this absolute x value</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_expand_aes">expand_aes</code></td>
<td>
<p>provide custom aes mappings for the expansion (advanced)</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_yjust">yjust</code></td>
<td>
<p>for multiline bins set to 0.5 to center labels on bins, and 1 to
align labels to the bottom.</p>
</td></tr>
<tr><td><code id="geom_bin_label_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Set <code>x</code> and <code>expand_x</code> to an absolute position to align all labels at a
specific location
</p>


<h3>Value</h3>

<p>Bin labels are added as a text layer/component to the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s0 &lt;- read_seqs(list.files(ex("cafeteria"), "Cr.*\\.fa.fai$", full.names = TRUE))
s1 &lt;- s0 %&gt;% dplyr::filter(length &gt; 5e5)

gggenomes(emale_genes) + geom_seq() + geom_gene() +
  geom_bin_label()

# make larger labels and extra room on the canvas
gggenomes(emale_genes) + geom_seq() + geom_gene() +
  geom_bin_label(size = 7, expand_left = .4)

# align labels for wrapped bins:
# top
gggenomes(seqs = s1, infer_bin_id = file_id, wrap = 5e6) +
  geom_seq() + geom_bin_label() + geom_seq_label()

# center
gggenomes(seqs = s1, infer_bin_id = file_id, wrap = 5e6) +
  geom_seq() + geom_bin_label(yjust = .5) + geom_seq_label()

# bottom
gggenomes(seqs = s1, infer_bin_id = file_id, wrap = 5e6) +
  geom_seq() + geom_bin_label(yjust = 1) + geom_seq_label()
</code></pre>

<hr>
<h2 id='geom_coverage'>Draw wiggle ribbons or lines</h2><span id='topic+geom_coverage'></span><span id='topic+geom_wiggle'></span>

<h3>Description</h3>

<p>Visualize data that varies along sequences as ribbons, lines, lineranges,
etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_coverage(
  mapping = NULL,
  data = feats(),
  stat = "coverage",
  geom = "ribbon",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  offset = 0,
  height = 0.2,
  max = base::max,
  ...
)

geom_wiggle(
  mapping = NULL,
  data = feats(),
  stat = "wiggle",
  geom = "ribbon",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  offset = 0,
  height = 0.8,
  bounds = Hmisc::smedian.hilow,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_coverage_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_coverage_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_coverage_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_coverage_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_offset">offset</code></td>
<td>
<p>distance between seq center and wiggle mid/start.</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_height">height</code></td>
<td>
<p>distance in plot between lowest and highest point of the wiggle data.</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_max">max</code></td>
<td>
<p>geom_coverage uses the function <a href="base.html#topic+Extremes">base::max</a> by default, which plots data in positive direction.
(<a href="base.html#topic+Extremes">base::min</a> Can also be called here when the input data )</p>
</td></tr>
<tr><td><code id="geom_coverage_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_coverage_+3A_bounds">bounds</code></td>
<td>
<p>geom_wiggle uses mid, low and high boundary values for plotting wiggle data. Can
be both a function or a vector returning those three values. Defaults to
<a href="Hmisc.html#topic+smean.sd">Hmisc::smedian.hilow</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geom_wiggle plots the wiggle data in both directions around the median.
Geom_coverage plots the data only in positive direction.
Both functions use data from the feats' track.
</p>


<h3>Value</h3>

<p>A ggplot2 layer with coverage information.
</p>


<h3>Aesthetics</h3>

<p><code>geom_wiggle()</code> and <code>geom_coverage()</code> understand aesthetics depending on the
chosen underlying ggplot geom, by default <code><a href="ggplot2.html#topic+geom_ribbon">ggplot2::geom_ribbon()</a></code>. Other
options that play well are for example <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>,
<code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_linerange()</a></code>, <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>. The only required
aesthetic is:
</p>

<ul>
<li> <p><strong>z</strong>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Plotting data with geom_coverage with increased height.
gggenomes(seqs = emale_seqs, feats = emale_gc) +
  geom_coverage(aes(z = score), height = 0.5) +
  geom_seq()

# In opposite direction by calling base::min and taking the negative values of "score"
gggenomes(seqs = emale_seqs, feats = emale_gc) +
  geom_coverage(aes(z = -score), max = base::min, height = 0.5) +
  geom_seq()

# GC-content plotted as points with variable color in geom_coverage
gggenomes(seqs = emale_seqs, feats = emale_gc) +
  geom_coverage(aes(z = score, color = score), height = 0.5, geom = "point") +
  geom_seq()
# Plot varying GC-content along sequences as ribbon
gggenomes(seqs = emale_seqs, feats = emale_gc) +
  geom_wiggle(aes(z = score)) +
  geom_seq()

# customize color and position
gggenomes(genes = emale_genes, seqs = emale_seqs, feats = emale_gc) +
  geom_wiggle(aes(z = score), fill = "lavenderblush3", offset = -.3, height = .5) +
  geom_seq() + geom_gene()

# GC-content as line and with variable color
gggenomes(seqs = emale_seqs, feats = emale_gc) +
  geom_wiggle(aes(z = score, color = score), geom = "line", bounds = c(.5, 0, 1)) +
  geom_seq() +
  scale_colour_viridis_b(option = "A")

# or as lineranges
gggenomes(seqs = emale_seqs, feats = emale_gc) +
  geom_wiggle(aes(z = score, color = score), geom = "linerange") +
  geom_seq() +
  scale_colour_viridis_b(option = "A")
</code></pre>

<hr>
<h2 id='geom_feat'>Draw feats</h2><span id='topic+geom_feat'></span>

<h3>Description</h3>

<p><code>geom_feat()</code> allows the user to draw (additional) features to the plot/graph.
For example, specific regions within a sequence (e.g. transposons, introns, mutation hotspots)
can be highlighted by color, size, etc..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_feat(
  mapping = NULL,
  data = feats(),
  stat = "identity",
  position = "pile",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_feat_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_feat_+3A_data">data</code></td>
<td>
<p>feat_layout: Uses first data frame stored in the <code>feats</code> track by default.</p>
</td></tr>
<tr><td><code id="geom_feat_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_feat_+3A_position">position</code></td>
<td>
<p>describes how the position of different plotted features are adjusted. By default it uses <code>"pile"</code>,
but different ggplot2 position adjustments, such as <code style="white-space: pre;">&#8288;"identity&#8288;</code> or <code>"jitter"</code> can be used as well.</p>
</td></tr>
<tr><td><code id="geom_feat_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_feat_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_feat_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_feat_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_feat</code> uses <code>ggplot2::geom_segment</code> under the hood. As a result,
different aesthetics such as <em>alpha</em>, <em>linewidth</em>, <em>color</em>, etc.
can be called upon to modify the visualization of the data.
</p>
<p><em>By default, the function uses the first feature track.</em>
</p>


<h3>Value</h3>

<p>A ggplot2 layer with features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting data from the feats' track with adjusted linewidth and color
gggenomes(seqs = emale_seqs, feats = emale_ngaros) +
  geom_seq() +
  geom_feat(linewidth = 5, color = "darkred")

# Geom_feat can be called several times as well, when specified what data should be used
gggenomes(seqs = emale_seqs, feats = list(emale_ngaros, emale_tirs)) +
  geom_seq() +
  geom_feat(linewidth = 5, color = "darkred") + # uses first feature track
  geom_feat(data = feats(emale_tirs))

# Additional notes to feats can be added with functions such as: geom_feat_note / geom_feat_text
gggenomes(seqs = emale_seqs, feats = list(emale_ngaros, emale_tirs)) +
  geom_seq() +
  geom_feat(color = "darkred") +
  geom_feat(data = feats(emale_tirs), color = "darkblue") +
  geom_feat_note(data = feats(emale_ngaros), label = "repeat region", size = 4)

# Different position adjustments with a simple dataset
exampledata &lt;- tibble::tibble(
  seq_id = c(rep("A", 3), rep("B", 3), rep("C", 3)),
  start = c(0, 30, 15, 40, 80, 20, 30, 50, 70),
  end = c(30, 90, 60, 60, 100, 80, 60, 90, 120)
)

gggenomes(feats = exampledata) +
  geom_feat(position = "identity", alpha = 0.5, linewidth = 0.5) +
  geom_bin_label()
</code></pre>

<hr>
<h2 id='geom_feat_text'>Add text to genes, features, etc.</h2><span id='topic+geom_feat_text'></span><span id='topic+geom_feat_tag'></span><span id='topic+geom_feat_note'></span><span id='topic+geom_gene_text'></span><span id='topic+geom_gene_tag'></span><span id='topic+geom_gene_note'></span>

<h3>Description</h3>

<p>The functions below are useful for labeling features/genes in plots.
Users have to call on <code>aes(label = ...)</code> or <code>(label = ...) </code>to define label's text
Based on the function, the label will be placed at a specific location:
</p>

<ul>
<li> <p><code>geom_..._text()</code> will plot <strong>text in the middle of the feature</strong>.
</p>
</li>
<li> <p><code>geom_..._tag()</code>  will plot <strong>text on top of the feature, with a 45 degree angle</strong>.
</p>
</li>
<li> <p><code>geom_..._note()</code> will plot <strong>text under the feature at the left side</strong>.
</p>
</li></ul>

<p><em>The <code>...</code> can be either replaced with <code>feat</code> or <code>gene</code> depending on which</em>
<em>track the user wants to label.</em>
</p>
<p>With arguments such as <code>hjust</code>, <code>vjust</code>, <code>angle</code>, and <code>nudge_y</code>, the user
can also manually change the position of the text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_feat_text(
  mapping = NULL,
  data = feats(),
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_feat_tag(
  mapping = NULL,
  data = feats(),
  stat = "identity",
  position = "identity",
  hjust = 0,
  vjust = 0,
  angle = 45,
  nudge_y = 0.03,
  xjust = 0.5,
  strandwise = TRUE,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_feat_note(
  mapping = NULL,
  data = feats(),
  stat = "identity",
  position = "identity",
  hjust = 0,
  vjust = 1,
  nudge_y = -0.03,
  xjust = 0,
  strandwise = FALSE,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_gene_text(
  mapping = NULL,
  data = genes(),
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_gene_tag(
  mapping = NULL,
  data = genes(),
  stat = "identity",
  position = "identity",
  hjust = 0,
  vjust = 0,
  angle = 45,
  nudge_y = 0.03,
  xjust = 0.5,
  strandwise = TRUE,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_gene_note(
  mapping = NULL,
  data = genes(),
  stat = "identity",
  position = "identity",
  hjust = 0,
  vjust = 1,
  nudge_y = -0.03,
  xjust = 0,
  strandwise = FALSE,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_feat_text_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer.
Cannot be jointy specified with <code>nudge_x</code> or <code>nudge_y</code>. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
</p>
</li>
<li><p> A string nameing the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_hjust">hjust</code></td>
<td>
<p>Moves the text horizontally</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_vjust">vjust</code></td>
<td>
<p>Moves the text vertically</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_angle">angle</code></td>
<td>
<p>Defines the angle in which the text will be placed. *Note</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Moves the text vertically an entire contig/sequence.
(e.g. <code>nudge_y = 1</code> places the text to the contig above)</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_xjust">xjust</code></td>
<td>
<p>Move text in x direction</p>
</td></tr>
<tr><td><code id="geom_feat_text_+3A_strandwise">strandwise</code></td>
<td>
<p>plotting of feature tags</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These labeling functions use <code>ggplot2::geom_text()</code> under the hood.
Any changes to the aesthetics of the text can be performed in a ggplot2 manner.
</p>


<h3>Value</h3>

<p>A ggplot2 layer with gene text.
</p>
<p>A ggplot2 layer with feature tags.
</p>
<p>A ggplot2 layer with feature notes.
</p>
<p>A ggplot2 layer with gene text.
</p>
<p>A ggplot2 layer with gene tags.
</p>
<p>A ggplot2 layer with gene notes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
genes &lt;- tibble::tibble(
  seq_id = c("A", "A", "A", "B", "B", "C"),
  start = c(20, 40, 80, 30, 10, 60),
  end = c(30, 70, 85, 40, 15, 90),
  feat_id = c("A1", "A2", "A3", "B1", "B2", "C1"),
  type = c("CDS", "CDS", "CDS", "CDS", "CDS", "CDS"),
  name = c("geneA", "geneB", "geneC", "geneA", "geneC", "geneB")
)

seqs &lt;- tibble::tibble(
  seq_id = c("A", "B", "C"),
  start = c(0, 0, 0),
  end = c(100, 100, 100),
  length = c(100, 100, 100)
)

# basic plot creation
plot &lt;- gggenomes(seqs = seqs, genes = genes) +
  geom_bin_label() +
  geom_gene()

# geom_..._text
plot + geom_gene_text(aes(label = name))

# geom_..._tag
plot + geom_gene_tag(aes(label = name))

# geom_..._note
plot + geom_gene_note(aes(label = name))

# with horizontal adjustment (`hjust`), vertical adjustment (`vjust`)
plot + geom_gene_text(aes(label = name), vjust = -2, hjust = 1)

# using `nudge_y` and and `angle` adjustment
plot + geom_gene_text(aes(label = name), nudge_y = 1, angle = 10)

# labeling with manual input
plot + geom_gene_text(label = c("This", "is", "an", "example", "test", "test"))
</code></pre>

<hr>
<h2 id='geom_gene'>Draw gene models</h2><span id='topic+geom_gene'></span>

<h3>Description</h3>

<p>Draw coding sequences, mRNAs and other non-coding features. Supports
multi-exon features. CDS and mRNAs in the same group are plotted together.
They can therefore also be positioned as a single unit using the <code>position</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_gene(
  mapping = NULL,
  data = genes(),
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  size = 2,
  rna_size = size,
  shape = size,
  rna_shape = shape,
  intron_shape = size,
  intron_types = c("CDS", "mRNA", "tRNA", "tmRNA", "ncRNA", "rRNA"),
  cds_aes = NULL,
  rna_aes = NULL,
  intron_aes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_gene_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_gene_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_gene_+3A_na.rm">na.rm</code></td>
<td>
<p>remove na values</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_size">size</code>, <code id="geom_gene_+3A_rna_size">rna_size</code></td>
<td>
<p>the size of the gene model, aka the height of the
polygons. <code>rna_size</code> only applies to non-coding parts of the gene model,
defaults to size.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_shape">shape</code>, <code id="geom_gene_+3A_rna_shape">rna_shape</code></td>
<td>
<p>vector of height and width of the arrow tip, defaults
to size. If only one value is provided it is recycled. Set '0' to
deactivates arrow-shaped tips. <code>rna_shape</code> only applies to non-coding parts
of the gene model, defaults to shape.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_intron_shape">intron_shape</code></td>
<td>
<p>single value controlling the kink of the intron line.
Defaults to size. Set 0 for straight lines between exons.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_intron_types">intron_types</code></td>
<td>
<p>introns will only be computed/drawn for features with
types listed here. Set to &quot;CDS&quot; to plot mRNAs as continous features, and
set to NA to completely ignore introns.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_cds_aes">cds_aes</code>, <code id="geom_gene_+3A_rna_aes">rna_aes</code>, <code id="geom_gene_+3A_intron_aes">intron_aes</code></td>
<td>
<p>overwrite aesthetics for different model
parts. Need to be wrapped in <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>. NOTE: These remappings are
applied after the data has been transformed and mapped by the plot scales
(see <code><a href="ggplot2.html#topic+aes_eval">ggplot2::after_scale()</a></code>). So you need to map between aesthetic names
(not data columns) and with standardized names, i.e. British English
spelling. These mappings can be used to dynamically change parts of the
gene model. For example, to change the color of introns from a hard-coded
&quot;black&quot; to the same color used to fill the CDS you could specify
<code>intron_aes=aes(colour = fill)</code>. By default, <code>rna_aes</code> is remapped with
<code>aes(fill=colorspace::lighten(fill, .5), colour=colorspace::lighten(colour, .5))</code> to give it a lighter appearence than the corresponding CDS but in the
same color.</p>
</td></tr>
<tr><td><code id="geom_gene_+3A_...">...</code></td>
<td>
<p>passed to layer params</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer with genes.
</p>


<h3>Aesthetics</h3>

<p><code>geom_gene()</code> understands the following aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code><a href="ggplot2.html#topic+aes_position">x</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="ggplot2.html#topic+aes_position">xend</a></code></strong>
</p>
</li>
<li> <p><strong><code><a href="ggplot2.html#topic+aes_position">y</a></code></strong>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code>introns</code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li></ul>

<p>Learn more about setting these aesthetics in <code>vignette("ggplot2-specs")</code>.
</p>
<p>'type' and 'group' (mapped to 'type' and 'geom_id' by default) power the
proper recognition of CDS and their corresponding mRNAs so that they can be
drawn as one composite object. Overwrite 'group' to plot CDS and mRNAs
independently.
</p>
<p>'introns' (mapped to 'introns') is used to compute intron/exon boundaries.
Use the parameter <code>intron_types</code> if you want to disable introns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gggenomes(genes = emale_genes) +
  geom_gene()

gggenomes(genes = emale_genes) +
  geom_gene(aes(fill = as.numeric(gc_content)), position = "strand") +
  scale_fill_viridis_b()

g0 &lt;- read_gff3(ex("eden-utr.gff"))
gggenomes(genes = g0) +
  # all features in the "genes" regardless of type
  geom_feat(data = feats(genes)) +
  annotate("text", label = "geom_feat", x = -15, y = .9) + xlim(-20, NA) +
  # only features in the "genes" of geneish type (implicit `data=genes()`)
  geom_gene() +
  geom_gene_tag(aes(label = ifelse(is.na(type), "&lt;NA&gt;", type)), data = genes(.gene_types = NULL)) +
  annotate("text", label = "geom_gene", x = -15, y = 1) +
  # control which types are returned from the track
  geom_gene(aes(y = 1.1), data = genes(.gene_types = c("CDS", "misc_RNA"))) +
  annotate("text", label = "gene_types", x = -15, y = 1.1) +
  # control which types can have introns
  geom_gene(
    aes(y = 1.2, yend = 1.2),
    data = genes(.gene_types = c("CDS", "misc_RNA")),
    intron_types = "misc_RNA"
  ) +
  annotate("text", label = "intron_types", x = -15, y = 1.2)

# spliced genes
library(patchwork)
gg &lt;- gggenomes(genes = g0)
gg + geom_gene(position = "pile") +
  gg + geom_gene(aes(fill = type),
    position = "pile",
    shape = 0, intron_shape = 0, color = "white"
  ) +
  # some fine-control on cds/rna/intron after_scale aesthetics
  gg + geom_gene(aes(fill = geom_id),
    position = "pile",
    size = 2, shape = c(4, 3), rna_size = 2, intron_shape = 4, stroke = 0,
    cds_aes = aes(fill = "black"), rna_aes = aes(fill = fill),
    intron_aes = aes(colour = fill, stroke = 2)
  ) +
  scale_fill_viridis_d() +
  # fun with introns
  gg + geom_gene(aes(fill = geom_id), position = "pile", size = 3, shape = c(4, 4)) +
  gg + geom_gene(aes(fill = geom_id),
    position = "pile", size = 3, shape = c(4, 4),
    intron_types = c()
  ) +
  gg + geom_gene(aes(fill = geom_id),
    position = "pile", size = 3, shape = c(4, 4),
    intron_types = "CDS"
  )
</code></pre>

<hr>
<h2 id='geom_gene_label'>Draw feat/link labels</h2><span id='topic+geom_gene_label'></span><span id='topic+geom_feat_label'></span><span id='topic+geom_link_label'></span>

<h3>Description</h3>

<p>These <code>geom_..._label()</code> functions able the user to plot labels/text at individual features and/or links.
Users have to indicate how to label the features/links by specifying <code>label = ...</code> or <code style="white-space: pre;">&#8288;aes(label = ...&#8288;</code>
</p>
<p>Position of labels can be adjusted with arguments such as <code>vjust</code>, <code>hjust</code>, <code>angle</code>, <code>nudge_y</code>, etc.
Also check out <code><a href="#topic+geom_bin_label">geom_bin_label()</a></code>, <code><a href="#topic+geom_seq_label">geom_seq_label()</a></code> or <code><a href="#topic+geom_feat_text">geom_feat_text()</a></code> given their resemblance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_gene_label(
  mapping = NULL,
  data = genes(),
  angle = 45,
  hjust = 0,
  nudge_y = 0.1,
  size = 6,
  ...
)

geom_feat_label(
  mapping = NULL,
  data = feats(),
  angle = 45,
  hjust = 0,
  nudge_y = 0.1,
  size = 6,
  ...
)

geom_link_label(
  mapping = NULL,
  data = links(),
  angle = 0,
  hjust = 0.5,
  vjust = 0.5,
  size = 4,
  repel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_gene_label_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_angle">angle</code></td>
<td>
<p>Defines the angle in which the text will be placed. *Note</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_hjust">hjust</code></td>
<td>
<p>Moves the text horizontally</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Moves the text vertically an entire contig/sequence.
(e.g. <code>nudge_y = 1</code> places the text to the contig above)</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_size">size</code></td>
<td>
<p>of the label</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_vjust">vjust</code></td>
<td>
<p>Moves the text vertically</p>
</td></tr>
<tr><td><code id="geom_gene_label_+3A_repel">repel</code></td>
<td>
<p>use ggrepel to avoid overlaps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These labeling functions use <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> under the hood.
Any changes to the aesthetics of the text can be performed in a ggplot2 manner.
</p>


<h3>Value</h3>

<p>Gene labels are added as a text layer/component to the plot.
</p>

<hr>
<h2 id='geom_link'>Draw links between genomes</h2><span id='topic+geom_link'></span><span id='topic+geom_link_line'></span>

<h3>Description</h3>

<p>Draws connections between genomes, such as genome/gene/protein
alignments and gene/protein clusters. <code>geom_link()</code> draws links as filled
polygons, <code>geom_link_line()</code> draws a single connecting line.
</p>
<p>Note that by default only links between adjacent genomes are computed and
shown. To compute and show all links between all genomes, set
<code>gggenomes(..., adjacent_only=FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_link(
  mapping = NULL,
  data = links(),
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  offset = 0.15,
  ...
)

geom_link_line(
  mapping = NULL,
  data = links(),
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_link_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_link_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_link_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_link_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_link_+3A_offset">offset</code></td>
<td>
<p>distance between seq center and link start. Use two values
<code style="white-space: pre;">&#8288;c(&lt;offset_top&gt;, &lt;offset_bottom&gt;)&#8288;</code> for different top and bottom offsets</p>
</td></tr>
<tr><td><code id="geom_link_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls upon the data stored within the <code>link</code> track.
Data frames added to this track have <code>seq_id</code> and <code>seq_id2</code> as required
variables. Optional and recommended variables include <code>start</code>, <code>start2</code>,
<code>end</code>, <code>end2</code>, <code>bin_id</code>, <code>bin_id2</code> and <code>strand</code>.
</p>
<p>Note, when start/end is not specified, links will be created between the
entire contigs of <code>seq_id</code> and <code>seq_id2</code>.
</p>


<h3>Value</h3>

<p>A ggplot2 layer with links.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0 &lt;- gggenomes(seqs = emale_seqs, links = emale_ava) + geom_seq()

# default links
p1 &lt;- p0 + geom_link()

# change offset from seqs and color
p2 &lt;- p0 + geom_link(aes(fill = de, color = de), offset = 0.05) +
  scale_fill_viridis_b() + scale_colour_viridis_b()

# combine with flip
p3 &lt;- p0 |&gt; flip(3, 4, 5) +
  geom_link()

# compute &amp; show all links among all genomes
# usually not useful and not recommended for large dataset
p4 &lt;- gggenomes(links = emale_ava, adjacent_only = FALSE) + geom_link()

library(patchwork) # combine plots in one figure
p1 + p2 + p3 + p4 + plot_layout(nrow = 1)
q0 &lt;- gggenomes(emale_genes, emale_seqs) |&gt;
  add_clusters(emale_cogs) +
  geom_seq() + geom_gene()

# link gene clusters with polygon
q1 &lt;- q0 + geom_link(aes(fill = cluster_id))

# link gene clusters with lines
q2 &lt;- q0 + geom_link_line(aes(color = cluster_id))

q1 + q2 + plot_layout(nrow = 1, guides = "collect")

</code></pre>

<hr>
<h2 id='geom_seq'>draw seqs</h2><span id='topic+geom_seq'></span>

<h3>Description</h3>

<p><code>geom_seq()</code> draws contigs for each sequence/chromosome supplied in the <code>seqs</code> track.
Several sequences belonging to the same bin will be plotted next to one another.
</p>
<p>If <code>seqs</code> track is empty, sequences are inferred from the <code>feats</code> or <code>links</code> track respectively.
</p>
<p>(<em>The length of sequences can be deduced from the axis and is typically indicated in base pairs.</em>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_seq(mapping = NULL, data = seqs(), arrow = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_seq_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_seq_+3A_data">data</code></td>
<td>
<p>seq_layout: Uses the first data frame stored in the <code>seqs</code> track, by default.</p>
</td></tr>
<tr><td><code id="geom_seq_+3A_arrow">arrow</code></td>
<td>
<p>set to non-NULL to generate default arrows</p>
</td></tr>
<tr><td><code id="geom_seq_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>geom_seq()</code> uses <code>ggplot2::geom_segment()</code> under the hood. As a result,
different aesthetics such as <em>alpha</em>, <em>linewidth</em>, <em>color</em>, etc.
can be called upon to modify the visualization of the data.
</p>
<p>Note: The <code>seqs</code> track indicates the length/region of the sequence/contigs that will be plotted.
<em>Feats</em> or <em>links</em> data that falls outside of this region are ignored!
</p>


<h3>Value</h3>

<p>Sequence data drawn as contigs is added as a layer/component to the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example of geom_seq
gggenomes(seqs = emale_seqs) +
  geom_seq() + # creates contigs
  geom_bin_label() # labels bins/sequences

# No sequence information supplied, will inform/warn that seqs are inferred from feats.
gggenomes(genes = emale_genes) +
  geom_seq() + # creates contigs
  geom_gene() + # draws genes on top of contigs
  geom_bin_label() # labels bins/sequences

# Sequence data controls what sequences and/or regions will be plotted.
# Here one sequence is filtered out, Notice that the genes of the removed
# sequence are silently ignored and thus not plotted.
missing_seqs &lt;- emale_seqs |&gt;
  dplyr::filter(seq_id != "Cflag_017B") |&gt;
  dplyr::arrange(seq_id) # `arrange` to restore alphabetical order.

gggenomes(seqs = missing_seqs, genes = emale_genes) +
  geom_seq() + # creates contigs
  geom_gene() + # draws genes on top of contigs
  geom_bin_label() # labels bins/sequences

# Several sequences belonging to the same *bin* are plotted next to one another
seqs &lt;- tibble::tibble(
  bin_id = c("A", "A", "A", "B", "B", "B", "B", "C", "C"),
  seq_id = c("A1", "A2", "A3", "B1", "B2", "B3", "B4", "C1", "C2"),
  start = c(0, 100, 200, 0, 50, 150, 250, 0, 400),
  end = c(100, 200, 400, 50, 100, 250, 300, 300, 500),
  length = c(100, 100, 200, 50, 50, 100, 50, 300, 100)
)

gggenomes(seqs = seqs) +
  geom_seq() +
  geom_bin_label() + # label bins
  geom_seq_label() # label individual sequences

# Wrap bins uptill a certain amount.
gggenomes(seqs = seqs, wrap = 300) +
  geom_seq() +
  geom_bin_label() + # label bins
  geom_seq_label() # label individual sequences

# Change the space between sequences belonging to one bin
gggenomes(seqs = seqs, spacing = 100) +
  geom_seq() +
  geom_bin_label() + # label bins
  geom_seq_label() # label individual sequences
</code></pre>

<hr>
<h2 id='geom_seq_break'>Decorate truncated sequences</h2><span id='topic+geom_seq_break'></span>

<h3>Description</h3>

<p><code>geom_seq_break()</code> adds decorations to the ends of truncated sequences. These
could arise from zooming onto sequence loci with <code>focus()</code>, or manually
annotating sequences with start &gt; 1 and/or end &lt; length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_seq_break(
  mapping_start = NULL,
  mapping_end = NULL,
  data_start = seqs(start &gt; 1),
  data_end = seqs(end &lt; length),
  label = "/",
  size = 4,
  hjust = 0.75,
  family = "sans",
  stat = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_seq_break_+3A_mapping_start">mapping_start</code></td>
<td>
<p>optional start mapping</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_mapping_end">mapping_end</code></td>
<td>
<p>optional end mapping</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_data_start">data_start</code></td>
<td>
<p>seq_layout of sequences for which to decorate the start.
default: <code>seqs(start &gt;1)</code></p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_data_end">data_end</code></td>
<td>
<p>seq_layout of sequences for which to decorate the end.
default: <code>seqs(end &lt; length)</code></p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_label">label</code></td>
<td>
<p>the character to decorate ends with. Provide two values for
different start and end decorations, e.g. <code>label=c("]", "[")</code>.</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_size">size</code></td>
<td>
<p>of the text</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_hjust">hjust</code></td>
<td>
<p>Moves the text horizontally</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_family">family</code></td>
<td>
<p>font family of the text</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_seq_break_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer with sequence breaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># decorate breaks created with focus()
gggenomes(emale_genes, emale_seqs) |&gt;
  focus(.expand = 1e3, .max_dist = 1e3) +
  geom_seq() + geom_gene() +
  geom_seq_break()

# customize decorations
gggenomes(emale_genes, emale_seqs) |&gt;
  focus(.expand = 1e3, .max_dist = 1e3) +
  geom_seq() + geom_gene() +
  geom_seq_break(label = c("[", "]"), size = 3, color = "#1b9e77")

# decorate manually truncated sequences
s0 &lt;- tibble::tribble(
  # start/end define regions, i.e. truncated contigs
  ~bin_id, ~seq_id, ~length, ~start, ~end,
  "complete_genome", "chromosome_1_long_trunc_2side", 1e5, 1e4, 2.1e4,
  "fragmented_assembly", "contig_1_trunc_1side", 1.3e4, .9e4, 1.3e4,
  "fragmented_assembly", "contig_2_short_complete", 0.3e4, 1, 0.3e4,
  "fragmented_assembly", "contig_3_trunc_2sides", 2e4, 1e4, 1.4e4
)

l0 &lt;- tibble::tribble(
  ~seq_id, ~start, ~end, ~seq_id2, ~start2, ~end2,
  "chromosome_1_long_trunc_2side", 1.1e4, 1.4e4,
  "contig_1_trunc_1side", 1e4, 1.3e4,
  "chromosome_1_long_trunc_2side", 1.4e4, 1.7e4,
  "contig_2_short_complete", 1, 0.3e4,
  "chromosome_1_long_trunc_2side", 1.7e4, 2e4,
  "contig_3_trunc_2sides", 1e4, 1.3e4
)

gggenomes(seqs = s0, links = l0) +
  geom_seq() + geom_link() +
  geom_seq_label(nudge_y = -.05) +
  geom_seq_break()
</code></pre>

<hr>
<h2 id='geom_seq_label'>Draw seq labels</h2><span id='topic+geom_seq_label'></span>

<h3>Description</h3>

<p>This function will put labels at each individual sequence.
By default it will plot the <code>seq_id</code> as label, but users are able to change this manually.
</p>
<p>Position of the label/text can be adjusted with the different arguments (e.g. <code>vjust</code>, <code>hjust</code>, <code>angle</code>, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_seq_label(
  mapping = NULL,
  data = seqs(),
  hjust = 0,
  vjust = 1,
  nudge_y = -0.15,
  size = 2.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_seq_label_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_seq_label_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_seq_label_+3A_hjust">hjust</code></td>
<td>
<p>Moves the text horizontally</p>
</td></tr>
<tr><td><code id="geom_seq_label_+3A_vjust">vjust</code></td>
<td>
<p>Moves the text vertically</p>
</td></tr>
<tr><td><code id="geom_seq_label_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Moves the text vertically an entire contig/sequence.
(e.g. <code>nudge_y = 1</code> places the text to the contig above)</p>
</td></tr>
<tr><td><code id="geom_seq_label_+3A_size">size</code></td>
<td>
<p>of the label</p>
</td></tr>
<tr><td><code id="geom_seq_label_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This labeling function uses <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> under the hood.
Any changes to the aesthetics of the text can be performed in a ggplot2 manner.
</p>


<h3>Value</h3>

<p>Sequence labels are added as a text layer/component to the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
seqs &lt;- tibble::tibble(
  bin_id = c("A", "A", "A", "B", "B", "B", "B", "C", "C"),
  seq_id = c("A1", "A2", "A3", "B1", "B2", "B3", "B4", "C1", "C2"),
  start = c(0, 100, 200, 0, 50, 150, 250, 0, 400),
  end = c(100, 200, 400, 50, 100, 250, 300, 300, 500),
  length = c(100, 100, 200, 50, 50, 100, 50, 300, 100)
)

# example plot using geom_seq_label
gggenomes(seqs = seqs) +
  geom_seq() +
  geom_seq_label()

# changing default label to `length` column
gggenomes(seqs = seqs) +
  geom_seq() +
  geom_seq_label(aes(label = length))

# with horizontal adjustment
gggenomes(seqs = seqs) +
  geom_seq() +
  geom_seq_label(hjust = -5)

# with wrapping at 300
gggenomes(seqs = seqs, wrap = 300) +
  geom_seq() +
  geom_seq_label()
</code></pre>

<hr>
<h2 id='geom_variant'>Draw place of mutation</h2><span id='topic+geom_variant'></span>

<h3>Description</h3>

<p>geom_variant allows the user to draw points at locations where a mutation has occured.
Data on SNPs, Insertions, Deletions and more (often stored in a variant call format (VCF)) can easily be visualized this way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_variant(
  mapping = NULL,
  data = feats(),
  stat = "identity",
  position = "identity",
  geom = "variant",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  offset = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_variant_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_data">data</code></td>
<td>
<p>Data from the first feats track is used for this function by default. When several feats tracks are present within the gggenomes track system,
make sure that the wanted data is used by calling <code style="white-space: pre;">&#8288;data = feats(*df*)&#8288;</code> within the <code>geom_variant</code> function.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_stat">stat</code></td>
<td>
<p>Describes what statistical transformation is used for this layer. By default it uses <code>"identity"</code>, indicating no statistical transformation.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_position">position</code></td>
<td>
<p>Describes how the position of different plotted features are adjusted. By default it uses <code>"identity"</code>,
but different position adjustments, such as <strong><code>position_variant()</code></strong>, ggplot2' <code>"jitter"</code> or <code>"pile"</code> can be used as well.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_geom">geom</code></td>
<td>
<p>Describes what geom is called upon by the function for plotting. By default the function uses <code>"variant"</code>, a modified geom_point object.
For larger sequences with abundant mutations/variations, it is recommended to use <code>"ticks"</code> (a modified geom_point object with different default shape and alpha, which plots the points as small &quot;ticks&quot;),
but in theory any other ggplot2 geom can be called here as well.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_offset">offset</code></td>
<td>
<p>Numeric value describing how far the points will be drawn from the base/sequence. By default it is set on <code>offset = 0</code>.</p>
</td></tr>
<tr><td><code id="geom_variant_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>geom_variant uses <code>ggplot2::geom_point</code> under the hood. As a result, different aesthetics such as <code>alpha</code>, <code>size</code>, <code>color</code>, etc.
can be called upon to modify the data visualization.
</p>
<p>#' the function <code>gggenomes::read_feats</code> is able to read VCF files and converts them into a format that is applicable within the gggenomes' track system.
<em>Keep in mind: The function uses data from the feats' track.</em>
</p>


<h3>Value</h3>

<p>A ggplot2 layer with variant information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of example data.
# (Note: These are mere examples and do not fully resemble data from VCF-files)
## Small example data set
f1 &lt;- tibble::tibble(
  seq_id = c(rep(c("A", "B"), 4)), start = c(1, 10, 15, 15, 30, 40, 40, 50),
  end = c(2, 11, 20, 16, 31, 41, 50, 51), length = end - start,
  type = c("SNP", "SNP", "Insertion", "Deletion", "Deletion", "SNP", "Insertion", "SNP"),
  ALT = c("A", "T", "CAT", ".", ".", "G", "GG", "G"),
  REF = c("C", "G", "C", "A", "A", "C", "G", "T")
)
s1 &lt;- tibble::tibble(seq_id = c("A", "B"), start = c(0, 0), end = c(55, 55), length = end - start)

## larger example data set
f2 &lt;- tibble::tibble(
  seq_id = c(rep("A", 667)),
  start = c(
    seq(from = 1, to = 500, by = 2),
    seq(from = 500, to = 2500, by = 50),
    seq(from = 2500, to = 4000, by = 4)
  ),
  end = start + 1, length = end - start,
  type = c(
    rep("SNP", 100),
    rep("Deletion", 20),
    rep("SNP", 180),
    rep("Deletion", 67),
    rep("SNP", 100),
    rep("Insertion", 50),
    rep("SNP", 150)
  ),
  ALT = c(
    sample(x = c("A", "C", "G", "T"), size = 100, replace = TRUE),
    rep(".", 20), sample(x = c("A", "C", "G", "T"), size = 180, replace = TRUE),
    rep(".", 67), sample(x = c("A", "C", "G", "T"), size = 100, replace = TRUE),
    sample(x = c(
      "AA", "AC", "AG", "AT", "CA", "CC", "CG", "CT", "GA", "GC",
      "GG", "GT", "TA", "TC", "TG", "TT"
    ), size = 50, replace = TRUE),
    sample(x = c("A", "C", "G", "T"), size = 150, replace = TRUE)
  )
)

# Basic example plot with geom_variant
gggenomes(seqs = s1, feats = f1) +
  geom_seq() +
  geom_variant()

# Improving plot elements, by changing shape and adding bin_label
gggenomes(seqs = s1, feats = f1) +
  geom_seq() +
  geom_variant(aes(shape = type), offset = -0.1) +
  scale_shape_variant() +
  geom_bin_label()

# Positional adjustment based on type of mutation: position_variant
gggenomes(seqs = s1, feats = f1) +
  geom_seq() +
  geom_variant(
    aes(shape = type),
    position = position_variant(offset = c(Insertion = -0.2, Deletion = -0.2, SNP = 0))
  ) +
  scale_shape_variant() +
  geom_bin_label()

# Plotting larger example data set with Changing default geom to
# `geom = "ticks"` using positional adjustment based on type (`position_variant`)
gggenomes(feats = f2) +
  geom_variant(aes(color = type), geom = "ticks", alpha = 0.4, position = position_variant()) +
  geom_bin_label()

# Changing geom to `"text"`, to plot ALT nucleotides
gggenomes(seqs = s1, feats = f1) +
  geom_seq() +
  geom_variant(aes(shape = type), offset = -0.1) +
  scale_shape_variant() +
  geom_variant(aes(label = ALT), geom = "text", offset = -0.25) +
  geom_bin_label()

</code></pre>

<hr>
<h2 id='GeomFeatText'>Geom for feature text</h2><span id='topic+GeomFeatText'></span>

<h3>Description</h3>

<p>Geom for feature text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomFeatText
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomFeatText</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>

<hr>
<h2 id='get_seqs'>Get/set the seqs track</h2><span id='topic+get_seqs'></span><span id='topic+set_seqs'></span>

<h3>Description</h3>

<p>Get/set the seqs track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_seqs(x)

set_seqs(x, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_seqs_+3A_x">x</code></td>
<td>
<p>a gggenomes or gggenomes_layout objekt</p>
</td></tr>
<tr><td><code id="get_seqs_+3A_value">value</code></td>
<td>
<p>to set for seqs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a gggenomes_layout track tibble
</p>

<hr>
<h2 id='gggenomes'>Plot genomes, features and synteny maps</h2><span id='topic+gggenomes'></span>

<h3>Description</h3>

<p><code>gggenomes()</code> initializes a gggenomes-flavored ggplot object.
It is used to declare the input data for gggenomes' track system.
</p>
<p>(<em>See for more details on the track system, gggenomes vignette or the Details/Arguments section</em>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gggenomes(
  genes = NULL,
  seqs = NULL,
  feats = NULL,
  links = NULL,
  .id = "file_id",
  spacing = 0.05,
  wrap = NULL,
  adjacent_only = TRUE,
  infer_bin_id = seq_id,
  infer_start = min(start, end),
  infer_end = max(start, end),
  infer_length = max(start, end),
  theme = c("clean", NULL),
  .layout = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gggenomes_+3A_genes">genes</code>, <code id="gggenomes_+3A_feats">feats</code></td>
<td>
<p>A data.frame, a list of data.frames, or a character vector
with paths to files containing gene data. Each item is added as feature
track.
</p>
<p>For a single data.frame the track_id will be &quot;genes&quot; and &quot;feats&quot;,
respectively. For a list, track_ids are parsed from the list names, or if
names are missing from the name of the variable containing each data.frame.
Data columns:
</p>

<ul>
<li><p> required: <code style="white-space: pre;">&#8288;seq_id,start,end&#8288;</code>
</p>
</li>
<li><p> recognized: <code style="white-space: pre;">&#8288;strand,bin_id,feat_id,introns&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="gggenomes_+3A_seqs">seqs</code></td>
<td>
<p>A data.frame or a character vector with paths to files containing
sequence data. Data columns:
</p>

<ul>
<li><p> required: <code style="white-space: pre;">&#8288;seq_id,length&#8288;</code>
</p>
</li>
<li><p> recognized: <code style="white-space: pre;">&#8288;bin_id,start,end,strand&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="gggenomes_+3A_links">links</code></td>
<td>
<p>A data.frame or a character vector with paths to files
containing link data. Each item is added as links track. Data columns:
</p>

<ul>
<li><p> required: <code style="white-space: pre;">&#8288;seq_id,seq_id2&#8288;</code>
</p>
</li>
<li><p> recognized: <code style="white-space: pre;">&#8288;start,end,bin_id,start2,end2,bin_id2,strand&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="gggenomes_+3A_.id">.id</code></td>
<td>
<p>The name of the column for file labels that are created when
reading directly from files. Defaults to &quot;file_id&quot;. Set to &quot;bin_id&quot; if
every file represents a different bin.</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_spacing">spacing</code></td>
<td>
<p>between sequences in bases (&gt;1) or relative to longest bin (&lt;1)</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_wrap">wrap</code></td>
<td>
<p>wrap bins into multiple lines with at most this many nucleotides
per lin.</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_adjacent_only">adjacent_only</code></td>
<td>
<p>Indicates whether links should be created between adjacent sequences/chromosomes only.
By default it is set to <code>adjacent_only = TRUE</code>. If <code>FALSE</code>, links will be created between all sequences
</p>
<p>(<em>not recommended for large data sets</em>)</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_infer_length">infer_length</code>, <code id="gggenomes_+3A_infer_start">infer_start</code>, <code id="gggenomes_+3A_infer_end">infer_end</code>, <code id="gggenomes_+3A_infer_bin_id">infer_bin_id</code></td>
<td>
<p>used to infer pseudo
seqs if only feats or links are provided, or if no bin_id column was
provided. The expressions are evaluated in the context of the first feat
or link track.
</p>
<p>By default subregions of sequences from the first to the last feat/link
are generated. Set <code>infer_start</code> to 0 to show all sequences from their
true beginning.</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_theme">theme</code></td>
<td>
<p>choose a gggenomes default theme, NULL to omit.</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_.layout">.layout</code></td>
<td>
<p>a pre-computed layout from <code><a href="#topic+layout_genomes">layout_genomes()</a></code>. Useful for
developmental purposes.</p>
</td></tr>
<tr><td><code id="gggenomes_+3A_...">...</code></td>
<td>
<p>additional parameters, passed to layout</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gggenomes::gggenomes()</code> resembles the functionality of <code>ggplot2::ggplot()</code>.
It is used to construct the initial plot object, and is often followed by &quot;+&quot; to add components to the plot (<em>e.g. &quot;+ geom_gene()&quot;</em>).
</p>
<p>A big difference between the two is that gggenomes has a multi-track setup (<em><code>'seqs'</code>, <code>'feats'</code>, <code>'genes'</code> and <code>'links'</code></em>).
<code>gggenomes()</code> pre-computes a layout and adds coordinates (<code style="white-space: pre;">&#8288;y,x,xend&#8288;</code>) to each data frame prior to the actual plot construction.
This has some implications for the usage of gggenomes:
</p>

<ul>
<li> <p><strong>Data frames for tracks have required variables.</strong> These predefined variables are used during import
to compute x/y coordinates (<em>see arguments</em>).
</p>
</li>
<li> <p><strong>gggenomes' geoms can often be used without explicit <code>aes()</code> mappings</strong>  This works because
we always know the names of the plot variables ahead of time: they originate from the pre-computed layout,
and we can use that information to set sensible default aesthetic mappings for most cases.
</p>
</li></ul>



<h3>Value</h3>

<p>gggenomes-flavored ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare the genomic organization of three viral elements
# EMALEs: endogenous mavirus-like elements (example data shipped with gggenomes)
gggenomes(emale_genes, emale_seqs, emale_tirs, emale_ava) +
  geom_seq() + geom_bin_label() + # chromosomes and labels
  geom_feat(size = 8) + # terminal inverted repeats
  geom_gene(aes(fill = strand), position = "strand") + # genes
  geom_link(offset = 0.15) # synteny-blocks

# with some more information
gggenomes(emale_genes, emale_seqs, emale_tirs, emale_ava) %&gt;%
  add_feats(emale_ngaros, emale_gc) %&gt;%
  add_clusters(emale_cogs) %&gt;%
  sync() +
  geom_link(offset = 0.15, color = "white") + # synteny-blocks
  geom_seq() + geom_bin_label() + # chromosomes and labels
  # thistle4, salmon4, burlywood4
  geom_feat(size = 6, position = "identity") + # terminal inverted repeats
  geom_feat(
    data = feats(emale_ngaros), color = "turquoise4", alpha = .3,
    position = "strand", size = 16
  ) +
  geom_feat_note(aes(label = type),
    data = feats(emale_ngaros),
    position = "strand", nudge_y = .3
  ) +
  geom_gene(aes(fill = cluster_id), position = "strand") + # genes
  geom_wiggle(aes(z = score, linetype = "GC-content"), feats(emale_gc),
    fill = "lavenderblush4", position = position_nudge(y = -.2), height = .2
  ) +
  scale_fill_brewer("Conserved genes", palette = "Dark2", na.value = "cornsilk3")

# initialize plot directly from files
gggenomes(
  ex("emales/emales.gff"),
  ex("emales/emales.gff"),
  ex("emales/emales-tirs.gff"),
  ex("emales/emales.paf")
) + geom_seq() + geom_gene() + geom_feat() + geom_link()

# multi-contig genomes wrap to fixed width
s0 &lt;- read_seqs(list.files(ex("cafeteria"), "Cr.*\\.fa.fai$", full.names = TRUE))
s1 &lt;- s0 %&gt;% dplyr::filter(length &gt; 5e5)
gggenomes(seqs = s1, infer_bin_id = file_id, wrap = 5e6) +
  geom_seq() + geom_bin_label() + geom_seq_label()
</code></pre>

<hr>
<h2 id='ggplot.gggenomes_layout'>ggplot.default tries to <code>fortify(data)</code> and we don't want that here</h2><span id='topic+ggplot.gggenomes_layout'></span>

<h3>Description</h3>

<p>ggplot.default tries to <code>fortify(data)</code> and we don't want that here
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gggenomes_layout'
ggplot(data, mapping = aes(), ..., environment = parent.frame())
</code></pre>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='has_vars'>Check if variables exist in object</h2><span id='topic+has_vars'></span>

<h3>Description</h3>

<p>Returns TRUE if all variables exists. If <code>any=TRUE</code> returns TRUE if at least
one variable exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_vars(x, vars, any = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_vars_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="has_vars_+3A_vars">vars</code></td>
<td>
<p>variables to test</p>
</td></tr>
<tr><td><code id="has_vars_+3A_any">any</code></td>
<td>
<p>if TRUE not all but at least one variable has to exists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE
</p>

<hr>
<h2 id='if_reverse'>Vectorised if_else based on strandedness</h2><span id='topic+if_reverse'></span>

<h3>Description</h3>

<p>Vectorised if_else based on strandedness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_reverse(strand, reverse, forward)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if_reverse_+3A_strand">strand</code></td>
<td>
<p>vector with strandedness information</p>
</td></tr>
<tr><td><code id="if_reverse_+3A_reverse">reverse</code></td>
<td>
<p>value to use for reverse elements</p>
</td></tr>
<tr><td><code id="if_reverse_+3A_forward">forward</code></td>
<td>
<p>value to use for forward elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with values based on strandedness
</p>

<hr>
<h2 id='in_range'>Do numeric values fall into specified ranges?</h2><span id='topic+in_range'></span>

<h3>Description</h3>

<p>Do numeric values fall into specified ranges?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_range(x, left, right, closed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="in_range_+3A_x">x</code></td>
<td>
<p>a numeric vector of values</p>
</td></tr>
<tr><td><code id="in_range_+3A_left">left</code>, <code id="in_range_+3A_right">right</code></td>
<td>
<p>boundary values or vectors of same length as x</p>
</td></tr>
<tr><td><code id="in_range_+3A_closed">closed</code></td>
<td>
<p>wether to include (<code>TRUE</code>) or exclude (<code>FALSE</code>) the
endpoints. Provide 2 values for different behaviors for lower and upper
boundary, e.g. <code>c(TRUE, FALSE)</code> to include only the lower boundary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector of the same length as the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>in_range(1:5, 2, 4)
in_range(1:5, 2, 4, closed = c(FALSE, TRUE)) # left-open
in_range(1:5, 6:2, 3) # vector of boundaries, single values recycle


# plays nicely with dplyr
df &lt;- tibble::tibble(x = rep(4, 5), left = 1:5, right = 3:7)
dplyr::mutate(df,
  closed = in_range(x, left, right, TRUE),
  open = in_range(x, left, right, FALSE)
)
</code></pre>

<hr>
<h2 id='introduce'>Introduce non-existing columns</h2><span id='topic+introduce'></span>

<h3>Description</h3>

<p>Works like <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> but without changing existing columns, but only
adding new ones. Useful to add possibly missing columns with default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>introduce(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="introduce_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="introduce_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with new columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ensure columns "y" and "z" exist
tibble::tibble(x = 1:3) %&gt;%
  introduce(y = "a", z = paste0(y, dplyr::row_number()))
# ensure columns "y" and "z" exist, but do not overwrite "y"
tibble::tibble(x = 1:3, y = c("c", "d", "e")) %&gt;%
  introduce(y = "a", z = paste0(y, dplyr::row_number()))
</code></pre>

<hr>
<h2 id='is_reverse'>Check whether strand is reverse</h2><span id='topic+is_reverse'></span>

<h3>Description</h3>

<p>Check whether strand is reverse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_reverse(strand, na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_reverse_+3A_strand">strand</code></td>
<td>
<p>some representation for strandedness</p>
</td></tr>
<tr><td><code id="is_reverse_+3A_na">na</code></td>
<td>
<p>what to use for <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector indicating whether the strand is reverse
</p>

<hr>
<h2 id='layout'>Re-layout a genome layout</h2><span id='topic+layout'></span>

<h3>Description</h3>

<p>Re-layout the tracks and update the scales after seqs have been modified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_+3A_x">x</code></td>
<td>
<p>layout</p>
</td></tr>
<tr><td><code id="layout_+3A_...">...</code></td>
<td>
<p>additional data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>layout with updated scales
</p>

<hr>
<h2 id='layout_genomes'>Layout genomes</h2><span id='topic+layout_genomes'></span>

<h3>Description</h3>

<p>Layout genomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_genomes(
  seqs = NULL,
  genes = NULL,
  feats = NULL,
  links = NULL,
  infer_bin_id = seq_id,
  infer_start = min(start, end),
  infer_end = max(start, end),
  infer_length = max(start, end),
  adjacent_only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_genomes_+3A_seqs">seqs</code></td>
<td>
<p>A data.frame or a character vector with paths to files containing
sequence data. Data columns:
</p>

<ul>
<li><p> required: <code style="white-space: pre;">&#8288;seq_id,length&#8288;</code>
</p>
</li>
<li><p> recognized: <code style="white-space: pre;">&#8288;bin_id,start,end,strand&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="layout_genomes_+3A_genes">genes</code>, <code id="layout_genomes_+3A_feats">feats</code></td>
<td>
<p>A data.frame, a list of data.frames, or a character vector
with paths to files containing gene data. Each item is added as feature
track.
</p>
<p>For a single data.frame the track_id will be &quot;genes&quot; and &quot;feats&quot;,
respectively. For a list, track_ids are parsed from the list names, or if
names are missing from the name of the variable containing each data.frame.
Data columns:
</p>

<ul>
<li><p> required: <code style="white-space: pre;">&#8288;seq_id,start,end&#8288;</code>
</p>
</li>
<li><p> recognized: <code style="white-space: pre;">&#8288;strand,bin_id,feat_id,introns&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="layout_genomes_+3A_links">links</code></td>
<td>
<p>A data.frame or a character vector with paths to files
containing link data. Each item is added as links track. Data columns:
</p>

<ul>
<li><p> required: <code style="white-space: pre;">&#8288;seq_id,seq_id2&#8288;</code>
</p>
</li>
<li><p> recognized: <code style="white-space: pre;">&#8288;start,end,bin_id,start2,end2,bin_id2,strand&#8288;</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="layout_genomes_+3A_infer_length">infer_length</code>, <code id="layout_genomes_+3A_infer_start">infer_start</code>, <code id="layout_genomes_+3A_infer_end">infer_end</code>, <code id="layout_genomes_+3A_infer_bin_id">infer_bin_id</code></td>
<td>
<p>used to infer pseudo
seqs if only feats or links are provided, or if no bin_id column was
provided. The expressions are evaluated in the context of the first feat
or link track.
</p>
<p>By default subregions of sequences from the first to the last feat/link
are generated. Set <code>infer_start</code> to 0 to show all sequences from their
true beginning.</p>
</td></tr>
<tr><td><code id="layout_genomes_+3A_adjacent_only">adjacent_only</code></td>
<td>
<p>Indicates whether links should be created between adjacent sequences/chromosomes only.
By default it is set to <code>adjacent_only = TRUE</code>. If <code>FALSE</code>, links will be created between all sequences
</p>
<p>(<em>not recommended for large data sets</em>)</p>
</td></tr>
<tr><td><code id="layout_genomes_+3A_...">...</code></td>
<td>
<p>additional parameters, passed to layout</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gggenomes_layout object
</p>

<hr>
<h2 id='layout_seqs'>Layout sequences</h2><span id='topic+layout_seqs'></span>

<h3>Description</h3>

<p>Layout sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_seqs(
  x,
  spacing = 0.05,
  wrap = NULL,
  spacing_style = c("regular", "center", "spread"),
  keep = "strand"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_seqs_+3A_x">x</code></td>
<td>
<p>seq_layout</p>
</td></tr>
<tr><td><code id="layout_seqs_+3A_spacing">spacing</code></td>
<td>
<p>between sequences in bases (&gt;1) or relative to longest bin (&lt;1)</p>
</td></tr>
<tr><td><code id="layout_seqs_+3A_wrap">wrap</code></td>
<td>
<p>wrap bins into multiple lines with at most this many nucleotides
per lin.</p>
</td></tr>
<tr><td><code id="layout_seqs_+3A_spacing_style">spacing_style</code></td>
<td>
<p>one of &quot;regular&quot;, &quot;center&quot;, &quot;spread&quot;</p>
</td></tr>
<tr><td><code id="layout_seqs_+3A_keep">keep</code></td>
<td>
<p>keys to keep (default: &quot;strand&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tbl_df with plot coordinates
</p>

<hr>
<h2 id='pick'>Pick bins and seqs by name or position</h2><span id='topic+pick'></span><span id='topic+pick_seqs'></span><span id='topic+pick_seqs_within'></span><span id='topic+pick_by_tree'></span>

<h3>Description</h3>

<p>Pick which bins and seqs to show and in what order. Uses
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>-like syntax, which means unquoted genome names, positional
arguments and <a href="https://tidyselect.r-lib.org/reference/language.html">selection helpers</a>, such as
<code><a href="tidyselect.html#topic+starts_with">tidyselect::starts_with()</a></code> are supported. Renaming is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick(x, ...)

pick_seqs(x, ..., .bins = everything())

pick_seqs_within(x, ..., .bins = everything())

pick_by_tree(x, tree, infer_bin_id = .data$label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_+3A_x">x</code></td>
<td>
<p>gggenomes object</p>
</td></tr>
<tr><td><code id="pick_+3A_...">...</code></td>
<td>
<p>bins/seqs to pick, select-like expression.</p>
</td></tr>
<tr><td><code id="pick_+3A_.bins">.bins</code></td>
<td>
<p>scope for positional arguments, select-like expression, enclose
multiple arguments with <code>c()</code>!</p>
</td></tr>
<tr><td><code id="pick_+3A_tree">tree</code></td>
<td>
<p>a phylogenetic tree in <a href="ggtree.html#topic+ggtree">ggtree::ggtree</a> or <code><a href="ape.html#topic+ape-package">ape::ape-package</a></code>-&quot;phylo&quot; format.</p>
</td></tr>
<tr><td><code id="pick_+3A_infer_bin_id">infer_bin_id</code></td>
<td>
<p>an expression to extract bin_ids from the tree data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the dots to select bins or sequences (depending on function suffix), and
the <code>.bins</code> argument to set the scope for positional arguments. For example,
<code>pick_seqs(1)</code> will pick the first sequence from the first bin, while
<code>pick_seqs(1, .bins=3)</code> will pick the first sequence from the third bin.
</p>


<h3>Value</h3>

<p>gggenomes object with selected bins and seqs.
</p>
<p>gggenomes object with selected seqs.
</p>
<p>gggenomes object with selected seqs.
</p>
<p>gggenomes object with seqs selected by tree order.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pick()</code>: pick bins by bin_id, positional argument (start at top)
or select-helper.
</p>
</li>
<li> <p><code>pick_seqs()</code>: pick individual seqs seq_id, positional argument (start at
top left) or select-helper.
</p>
</li>
<li> <p><code>pick_seqs_within()</code>: pick individual seqs but only modify bins containing those
seqs, keep rest as is.
</p>
</li>
<li> <p><code>pick_by_tree()</code>: align bins with the leaves in a given phylogenetic tree.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>s0 &lt;- tibble::tibble(
  bin_id = c("A", "B", "B", "B", "C", "C", "C"),
  seq_id = c("a1", "b1", "b2", "b3", "c1", "c2", "c3"),
  length = c(1e4, 6e3, 2e3, 1e3, 3e3, 3e3, 3e3)
)

p &lt;- gggenomes(seqs = s0) + geom_seq(aes(color = bin_id), size = 3) +
  geom_bin_label() + geom_seq_label() +
  expand_limits(color = c("A", "B", "C"))
p

# remove
p %&gt;% pick(-B)

# select and reorder, by ID and position
p %&gt;% pick(C, 1)

# use helper function
p %&gt;% pick(starts_with("B"))

# pick just some seqs
p %&gt;% pick_seqs(1, c3)

# pick with .bin scope
p %&gt;% pick_seqs(3:1, .bins = C)

# change seqs in some bins, but keep rest as is
p %&gt;% pick_seqs_within(3:1, .bins = B)

# same w/o scope, unaffected bins remain as is
p %&gt;% pick_seqs_within(b3, b2, b1)

# Align sequences with and plot next to a phylogenetic tree
library(patchwork) # arrange multiple plots
library(ggtree) # plot phylogenetic trees

# load and plot a phylogenetic tree
emale_mcp_tree &lt;- read.tree(ex("emales/emales-MCP.nwk"))
t &lt;- ggtree(emale_mcp_tree) + geom_tiplab(align = TRUE, size = 3) +
  xlim(0, 0.05) # make room for labels

p &lt;- gggenomes(seqs = emale_seqs, genes = emale_genes) +
  geom_seq() + geom_seq() + geom_bin_label()

# plot next to each other, but with
# different order in tree and genomes
t + p + plot_layout(widths = c(1, 5))

# reorder genomes to match tree order
# with a warning caused by mismatch in y-scale expansions
t + p %&gt;% pick_by_tree(t) + plot_layout(widths = c(1, 5))

# extra genomes are dropped with a notification
emale_seqs_more &lt;- emale_seqs
emale_seqs_more[7, ] &lt;- emale_seqs_more[6, ]
emale_seqs_more$seq_id[7] &lt;- "One more genome"
p &lt;- gggenomes(seqs = emale_seqs_more, genes = emale_genes) +
  geom_seq() + geom_seq() + geom_bin_label()
t + p %&gt;% pick_by_tree(t) + plot_layout(widths = c(1, 5))

try({
  # no shared ids will cause an error
  p &lt;- gggenomes(seqs = tibble::tibble(seq_id = "foo", length = 1)) +
    geom_seq() + geom_seq() + geom_bin_label()
  t + p %&gt;% pick_by_tree(t) + plot_layout(widths = c(1, 5))

  # extra leafs in tree will cause an error
  emale_seqs_fewer &lt;- slice_head(emale_seqs, n = 4)
  p &lt;- gggenomes(seqs = emale_seqs_fewer, genes = emale_genes) +
    geom_seq() + geom_seq() + geom_bin_label()
  t + p %&gt;% pick_by_tree(t) + plot_layout(widths = c(1, 5))
})

</code></pre>

<hr>
<h2 id='position_strand'>Stack features</h2><span id='topic+position_strand'></span><span id='topic+position_pile'></span><span id='topic+position_strandpile'></span><span id='topic+position_sixframe'></span><span id='topic+PositionStrandpile'></span><span id='topic+PositionPile'></span><span id='topic+PositionStrand'></span><span id='topic+PositionSixframe'></span>

<h3>Description</h3>

<p><code>position_strand()</code> offsets forward feats upward and reverse feats downward.
<code>position_pile()</code> stacks overlapping feats upward. <code>position_strandpile()</code>
stacks overlapping feats up-/downward based on their strand.
<code>position_sixframe()</code> offsets the feats based on their strand and reading
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_strand(offset = 0.1, flip = FALSE, grouped = NULL, base = offset/2)

position_pile(offset = 0.1, gap = 1, flip = FALSE, grouped = NULL, base = 0)

position_strandpile(
  offset = 0.1,
  gap = 1,
  flip = FALSE,
  grouped = NULL,
  base = offset * 1.5
)

position_sixframe(offset = 0.1, flip = FALSE, grouped = NULL, base = offset/2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_strand_+3A_offset">offset</code></td>
<td>
<p>Shift overlapping feats up/down this much on the y-axis. The
y-axis distance between two sequences is 1, so this is usually a small
fraction, such as 0.1.</p>
</td></tr>
<tr><td><code id="position_strand_+3A_flip">flip</code></td>
<td>
<p>stack downward, and for stranded versions reverse upward.</p>
</td></tr>
<tr><td><code id="position_strand_+3A_grouped">grouped</code></td>
<td>
<p>if TRUE feats in the same group are stacked as a single
feature. Useful to move CDS and mRNA as one unit. If NULL (default) set to
TRUE if data appears to contain gene-ish features.</p>
</td></tr>
<tr><td><code id="position_strand_+3A_base">base</code></td>
<td>
<p>How to align the stack relative to the sequence. 0 to center the
lowest stack level on the sequence, 1 to put forward/reverse sequence one
half offset above/below the sequence line.</p>
</td></tr>
<tr><td><code id="position_strand_+3A_gap">gap</code></td>
<td>
<p>If two feats are closer together than this, they will be stacked.
Can be negative to allow small overlaps. NA disables stacking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object to be used in <code>geom_gene()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(patchwork)
p &lt;- gggenomes(emale_genes) %&gt;%
  pick(3:4) + geom_seq()

f0 &lt;- tibble::tibble(
  seq_id = pull_seqs(p)$seq_id[1],
  start = 1:20 * 1000,
  end = start + 2500,
  strand = rep(c("+", "-"), length(start) / 2)
)

sixframe &lt;- function(x, strand) as.character((x %% 3 + 1) * strand_int(strand))

p1 &lt;- p + geom_gene()
p2 &lt;- p + geom_gene(aes(fill = strand), position = "strand")
p3 &lt;- p + geom_gene(aes(fill = strand), position = position_strand(flip = TRUE, base = 0.2))
p4 &lt;- p + geom_gene(aes(fill = sixframe(x, strand)), position = "sixframe")
p5 &lt;- p %&gt;% add_feats(f0) + geom_gene() + geom_feat(aes(color = strand))
p6 &lt;- p %&gt;% add_feats(f0) + geom_gene() + geom_feat(aes(color = strand), position = "strandpile")
p1 + p2 + p3 + p4 + p5 + p6 + plot_layout(ncol = 3, guides = "collect") &amp; ylim(2.5, 0.5)

</code></pre>

<hr>
<h2 id='position_variant'>Plot types of mutations with different offsets</h2><span id='topic+position_variant'></span>

<h3>Description</h3>

<p><code>position_variant()</code> allows the user to plot the different mutation types (e.g. del, ins, snps) at different offsets from the base.
This can especially be useful to highlight in which regions certain types of mutations have higher prevalence.
This position adjustment is most relevant for the analysis/visualization of VCF files with the function <code>geom_variant()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_variant(offset = c(del = 0.1, snp = 0, ins = -0.1), base = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_variant_+3A_offset">offset</code></td>
<td>
<p>Shifts the data up/down based on the type of mutation.
By default <code>offset = c(del=0.1, snp=0, ins=-0.1)</code>.
The user can supply an own vector to <code>offset</code> to indicate at which offsets the different mutation types should be plotted.
<em>Types of mutations that have not been specified within the vector, will be plotted with an offset of 0.</em></p>
</td></tr>
<tr><td><code id="position_variant_+3A_base">base</code></td>
<td>
<p>How to align the offsets relative to the sequence. At base = 0, plotting of the offsets starts
from the sequence. <code>base</code> thus moves the entire feature up/down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object to be used in <code>geom_variant()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of example data.
testposition &lt;- tibble::tibble(
  type = c("ins", "snp", "snp", "del", "del", "snp", "snp", "ins", "snp", "ins", "snp"),
  start = c(10, 20, 30, 35, 40, 60, 65, 90, 90, 100, 120),
  end = start + 1,
  seq_id = c(rep("A", 11))
)
testseq &lt;- tibble::tibble(
  seq_id = "A",
  start = 0,
  end = 150,
  length = end - start
)

p &lt;- gggenomes(seqs = testseq, feats = testposition)

# This first plot shows what is being plotted when only geom_variant is called
p + geom_variant()

# Next lets use position_variant, and change the shape aesthetic by column `type`
p + geom_variant(aes(shape = type), position = position_variant())

# Now lets create a plot with different offsets by inserting a self-created vector.
p + geom_variant(
  aes(shape = type),
  position = position_variant(c(del = 0.4, ins = -0.4))
) + scale_shape_variant()

# Changing the base will shift all points up/down relatively from the sequence.
p + geom_variant(
  aes(shape = type),
  position = position_variant(base = 0.5)
) + geom_seq()

</code></pre>

<hr>
<h2 id='qw'>Create a vector from unquoted words.</h2><span id='topic+qw'></span><span id='topic+qc'></span>

<h3>Description</h3>

<p>Similar to perls <code>qw()</code>, however, in R spaces between args in function call
always cause an error, so <code style="white-space: pre;">&#8288;qw(foo bar)&#8288;</code> wouldn't work. Workaround is either a
single string split at spaces, or unquoted elements, separated by commas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qw(x)

qc(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qw_+3A_x">x</code></td>
<td>
<p>A single string of elements to be split at whitespace chars.</p>
</td></tr>
<tr><td><code id="qw_+3A_...">...</code></td>
<td>
<p>Unquated words, separated by comma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Took inspiration from
<a href="https://stackoverflow.com/questions/520810/does-r-have-quote-like-operators-like-perls-qw">stackoverflow/qw</a>
and <a href="https://github.com/jebyrnes/multifunc/blob/master/R/qw.R">github/Jarrett Byrnes</a>
</p>


<h3>Value</h3>

<p>A vector of quoted words.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qw("foo bar") # with a strsplit
qc(foo, bar) # or unquoted, but with commas
</code></pre>

<hr>
<h2 id='read_alitv'>Read AliTV .json file</h2><span id='topic+read_alitv'></span>

<h3>Description</h3>

<p>this file contains sequences, links and (optionally) genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_alitv(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_alitv_+3A_file">file</code></td>
<td>
<p>path to json</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with seqs, genes, and links
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ali &lt;- read_alitv("https://alitvteam.github.io/AliTV/d3/data/chloroplasts.json")
gggenomes(ali$genes, ali$seqs, links = ali$links) +
  geom_seq() +
  geom_bin_label() +
  geom_gene(aes(fill = class)) +
  geom_link()
p &lt;- gggenomes(ali$genes, ali$seqs, links = ali$links) +
  geom_seq() +
  geom_bin_label() +
  geom_gene(aes(color = class)) +
  geom_link(aes(fill = identity)) +
  scale_fill_distiller(palette = "RdYlGn", direction = 1)
p %&gt;%
  flip_seqs(5) %&gt;%
  pick_seqs(1, 3, 2, 4, 5, 6, 7, 8)
</code></pre>

<hr>
<h2 id='read_bed'>Read a BED file</h2><span id='topic+read_bed'></span>

<h3>Description</h3>

<p>BED files use 0-based coordinate starts, while gggenomes uses 1-based start
coordinates. BED file coordinates are therefore transformed into 1-based
coordinates during import.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bed(file, col_names = def_names("bed"), col_types = def_types("bed"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_bed_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_col_names">col_names</code></td>
<td>
<p>column names to use. Defaults to <code>def_names("bed")</code>
compatible with canonical bed files. <code><a href="#topic+def_names">def_names()</a></code> can easily be
combined with extra columns: <code>col_names = c(def_names("bed"), "more", "things")</code>.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_col_types">col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code><a href="readr.html#topic+cols">cols()</a></code> specification, or
a string. See <code>vignette("readr")</code> for more details.
</p>
<p>If <code>NULL</code>, all column types will be inferred from <code>guess_max</code> rows of the
input, interspersed throughout the file. This is convenient (and fast),
but not robust. If the guessed types are wrong, you'll need to increase
<code>guess_max</code> or supply the correct types yourself.
</p>
<p>Column specifications created by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="readr.html#topic+cols">cols()</a></code> must contain
one column specification for each column. If you only want to read a
subset of the columns, use <code><a href="readr.html#topic+cols_only">cols_only()</a></code>.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
</p>

<ul>
<li><p> c = character
</p>
</li>
<li><p> i = integer
</p>
</li>
<li><p> n = number
</p>
</li>
<li><p> d = double
</p>
</li>
<li><p> l = logical
</p>
</li>
<li><p> f = factor
</p>
</li>
<li><p> D = date
</p>
</li>
<li><p> T = date time
</p>
</li>
<li><p> t = time
</p>
</li>
<li><p> ? = guess
</p>
</li>
<li><p> _ or - = skip
</p>
</li></ul>

<p>By default, reading a file without a column specification will print a
message showing what <code>readr</code> guessed they were. To remove this message,
set <code>show_col_types = FALSE</code> or set <code>options(readr.show_col_types = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_...">...</code></td>
<td>
<p>additional parameters, passed to <code>read_tsv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>

<hr>
<h2 id='read_blast'>Read BLAST tab-separated output</h2><span id='topic+read_blast'></span>

<h3>Description</h3>

<p>Read BLAST tab-separated output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_blast(
  file,
  col_names = def_names("blast"),
  col_types = def_types("blast"),
  comment = "#",
  swap_query = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_blast_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_blast_+3A_col_names">col_names</code></td>
<td>
<p>column names to use. Defaults to <code>def_names("blast")</code>
compatible with blast tabular output (<code style="white-space: pre;">&#8288;--outfmt 6/7&#8288;</code> in blast++ and <code>-m8</code>
in blast-legacy). <code><a href="#topic+def_names">def_names()</a></code> can easily be combined with extra
columns: <code>col_names = c(def_names("blast"), "more", "things")</code>.</p>
</td></tr>
<tr><td><code id="read_blast_+3A_col_types">col_types</code></td>
<td>
<p>column types to use. Defaults to <code>def_types("gff3")</code> (see <code><a href="#topic+def_types">def_types</a></code>).</p>
</td></tr>
<tr><td><code id="read_blast_+3A_comment">comment</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="read_blast_+3A_swap_query">swap_query</code></td>
<td>
<p>if TRUE swap query and subject columns using <code><a href="#topic+swap_query">swap_query()</a></code>
on import.</p>
</td></tr>
<tr><td><code id="read_blast_+3A_...">...</code></td>
<td>
<p>additional parameters, passed to <code>read_tsv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with the BLAST output
</p>

<hr>
<h2 id='read_context'>Read files in different contexts</h2><span id='topic+read_context'></span>

<h3>Description</h3>

<p>Powers <code><a href="#topic+read_seqs">read_seqs()</a></code>, <code><a href="#topic+read_feats">read_feats()</a></code>, <code><a href="#topic+read_links">read_links()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_context(
  files,
  context,
  .id = "file_id",
  format = NULL,
  parser = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_context_+3A_files">files</code></td>
<td>
<p>files to reads. Should all be of same format. In many cases,
compressed files (<code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code>) are supported.
Similarly, automatic download of remote files starting with <code style="white-space: pre;">&#8288;http(s)://&#8288;</code> or
<code style="white-space: pre;">&#8288;ftp(s)://&#8288;</code> works in most cases.</p>
</td></tr>
<tr><td><code id="read_context_+3A_context">context</code></td>
<td>
<p>the context (&quot;seqs&quot;, &quot;feats&quot;, &quot;links&quot;) in which a given format
should be read.</p>
</td></tr>
<tr><td><code id="read_context_+3A_.id">.id</code></td>
<td>
<p>the column with the name of the file a record was read from.
Defaults to &quot;file_id&quot;. Set to &quot;bin_id&quot; if every file represents a different
bin.</p>
</td></tr>
<tr><td><code id="read_context_+3A_format">format</code></td>
<td>
<p>specify a format known to gggenomes, such as <code>gff3</code>, <code>gbk</code>, ...
to overwrite automatic determination based on the file extension (see
<code><a href="#topic+def_formats">def_formats()</a></code> for full list).</p>
</td></tr>
<tr><td><code id="read_context_+3A_parser">parser</code></td>
<td>
<p>specify the name of an R function to overwrite automatic
determination based on format, e.g. <code>parser="read_tsv"</code>.</p>
</td></tr>
<tr><td><code id="read_context_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to the format-specific read
function called down the line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with the combined data from all files
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>read_context()</code>: bla keywords internal
</p>
</li></ul>

<hr>
<h2 id='read_gbk'>Read genbank files</h2><span id='topic+read_gbk'></span>

<h3>Description</h3>

<p>Genbank flat files (.gb/.gbk/.gbff) and their ENA and DDBJ equivalents have a
particularly gruesome format. That's why <code><a href="#topic+read_gbk">read_gbk()</a></code> is just a wrapper
around a Perl-based <code>gb2gff</code> converter and <code><a href="#topic+read_gff3">read_gff3()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gbk(file, sources = NULL, types = NULL, infer_cds_parents = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_gbk_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_gbk_+3A_sources">sources</code></td>
<td>
<p>only return features from these sources</p>
</td></tr>
<tr><td><code id="read_gbk_+3A_types">types</code></td>
<td>
<p>only return features of these types, e.g. gene, CDS, ...</p>
</td></tr>
<tr><td><code id="read_gbk_+3A_infer_cds_parents">infer_cds_parents</code></td>
<td>
<p>infer the mRNA parent for CDS features based on
overlapping coordinates. Default TRUE for gff2/gtf, FALSE for gff3. In most
GFFs this is properly set, but sometimes this information is missing.
Generally, this is not a problem, however, geom_gene calls parse the parent
information to determine which CDS and mRNAs are part of the same gene
model. Without the parent info, mRNA and CDS are plotted as individual
features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>

<hr>
<h2 id='read_gff3'>Read features from GFF3 (and with some limitations GFF2/GTF) files</h2><span id='topic+read_gff3'></span>

<h3>Description</h3>

<p>Files with <code style="white-space: pre;">&#8288;##FASTA&#8288;</code> section work but result in parsing problems for all
lines of the fasta section. Just ignore those warnings, or strip the fasta
section ahead of time from the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gff3(
  file,
  sources = NULL,
  types = NULL,
  infer_cds_parents = is_gff2,
  sort_exons = TRUE,
  col_names = def_names("gff3"),
  col_types = def_types("gff3"),
  keep_attr = FALSE,
  fix_augustus_cds = TRUE,
  is_gff2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_gff3_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_sources">sources</code></td>
<td>
<p>only return features from these sources</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_types">types</code></td>
<td>
<p>only return features of these types, e.g. gene, CDS, ...</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_infer_cds_parents">infer_cds_parents</code></td>
<td>
<p>infer the mRNA parent for CDS features based on
overlapping coordinates. Default TRUE for gff2/gtf, FALSE for gff3. In most
GFFs this is properly set, but sometimes this information is missing.
Generally, this is not a problem, however, geom_gene calls parse the parent
information to determine which CDS and mRNAs are part of the same gene
model. Without the parent info, mRNA and CDS are plotted as individual
features.</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_sort_exons">sort_exons</code></td>
<td>
<p>make sure that exons/introns appear sorted. Default TRUE.
Set to FALSE to read CDS/exon order exactly as present in the file, which
is less robust, but faster and allows non-canonical splicing
(exon1-exon3-exon2).</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_col_names">col_names</code></td>
<td>
<p>column names to use. Defaults to <code>def_names("gff3")</code> (see <code><a href="#topic+def_names">def_names</a></code>).</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_col_types">col_types</code></td>
<td>
<p>column types to use. Defaults to <code>def_types("gff3")</code> (see <code><a href="#topic+def_types">def_types</a></code>).</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_keep_attr">keep_attr</code></td>
<td>
<p>keep the original attributes column also after parsing
tag=value pairs into tidy columns.</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_fix_augustus_cds">fix_augustus_cds</code></td>
<td>
<p>If true, assume Augustus gff with bad CDS IDs that
need fixing</p>
</td></tr>
<tr><td><code id="read_gff3_+3A_is_gff2">is_gff2</code></td>
<td>
<p>set if file is in gff2 format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>

<hr>
<h2 id='read_paf'>Read a .paf file (minimap/minimap2).</h2><span id='topic+read_paf'></span>

<h3>Description</h3>

<p>Read a minimap/minimap2 .paf file including optional tagged extra fields. The
optional fields will be parsed into a tidy format, one column per tag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_paf(
  file,
  max_tags = 20,
  col_names = def_names("paf"),
  col_types = def_types("paf"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_paf_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_paf_+3A_max_tags">max_tags</code></td>
<td>
<p>maximum number of optional fields to include</p>
</td></tr>
<tr><td><code id="read_paf_+3A_col_names">col_names</code></td>
<td>
<p>column names to use. Defaults to <code>def_names("gff3")</code> (see <code><a href="#topic+def_names">def_names</a></code>).</p>
</td></tr>
<tr><td><code id="read_paf_+3A_col_types">col_types</code></td>
<td>
<p>column types to use. Defaults to <code>def_types("gff3")</code> (see <code><a href="#topic+def_types">def_types</a></code>).</p>
</td></tr>
<tr><td><code id="read_paf_+3A_...">...</code></td>
<td>
<p>additional parameters, passed to <code>read_tsv</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>readr::read_tsv</code> expects a fixed number of columns, but in .paf the
number of optional fields can differ among records, <code>read_paf</code> tries to read
at least as many columns as the longest record has (<code>max_tags</code>). The
resulting warnings for each record with fewer fields of the form &quot;32 columns
expected, only 22 seen&quot; should thus be ignored.
</p>
<p>From the minimap2 manual
</p>
<p>+&mdash;-+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|Col |  Type  |                       Description                       |
+&mdash;-+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|  1 | string | Query sequence name                                     |
|  2 |  int   | Query sequence length                                   |
|  3 |  int   | Query start coordinate (0-based)                        |
|  4 |  int   | Query end coordinate (0-based)                          |
|  5 |  char  | + if query/target on the same strand; - if opposite |
|  6 | string | Target sequence name                                    |
|  7 |  int   | Target sequence length                                  |
|  8 |  int   | Target start coordinate on the original strand          |
|  9 |  int   | Target end coordinate on the original strand            |
| 10 |  int   | Number of matching bases in the mapping                 |
| 11 |  int   | Number bases, including gaps, in the mapping            |
| 12 |  int   | Mapping quality (0-255 with 255 for missing)            |
+&mdash;-+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
</p>
<p>+&mdash;-+&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
|Tag | Type |                      Description                      |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
| tp |  A   | Type of aln: P/primary, S/secondary and I,i/inversion |
| cm |  i   | Number of minimizers on the chain                     |
| s1 |  i   | Chaining score                                        |
| s2 |  i   | Chaining score of the best secondary chain            |
| NM |  i   | Total number of mismatches and gaps in the alignment  |
| MD |  Z   | To generate the ref sequence in the alignment         |
| AS |  i   | DP alignment score                                    |
| ms |  i   | DP score of the max scoring segment in the alignment  |
| nn |  i   | Number of ambiguous bases in the alignment            |
| ts |  A   | Transcript strand (splice mode only)                  |
| cg |  Z   | CIGAR string (only in PAF)                            |
| cs |  Z   | Difference string                                     |
| dv |  f   | Approximate per-base sequence divergence              |
+&mdash;-+&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
</p>
<p>From https://samtools.github.io/hts-specs/SAMtags.pdf
type may be one of A (character), B (general array), f (real number),
H (hexadecimal array), i (integer), or Z (string).
</p>


<h3>Value</h3>

<p>tibble
</p>

<hr>
<h2 id='read_seq_len'>Read sequence index</h2><span id='topic+read_seq_len'></span><span id='topic+read_fai'></span>

<h3>Description</h3>

<p>Read sequence index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_seq_len(file)

read_fai(file, col_names = def_names("fai"), col_types = def_types("fai"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_seq_len_+3A_file">file</code></td>
<td>
<p>with sequence length information</p>
</td></tr>
<tr><td><code id="read_seq_len_+3A_col_names">col_names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector
of column names.
</p>
<p>If <code>TRUE</code>, the first row of the input will be used as the column
names, and will not be included in the data frame. If <code>FALSE</code>, column
names will be generated automatically: X1, X2, X3 etc.
</p>
<p>If <code>col_names</code> is a character vector, the values will be used as the
names of the columns, and the first row of the input will be read into
the first row of the output data frame.
</p>
<p>Missing (<code>NA</code>) column names will generate a warning, and be filled
in with dummy names <code>...1</code>, <code>...2</code> etc. Duplicate column names
will generate a warning and be made unique, see <code>name_repair</code> to control
how this is done.</p>
</td></tr>
<tr><td><code id="read_seq_len_+3A_col_types">col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code><a href="readr.html#topic+cols">cols()</a></code> specification, or
a string. See <code>vignette("readr")</code> for more details.
</p>
<p>If <code>NULL</code>, all column types will be inferred from <code>guess_max</code> rows of the
input, interspersed throughout the file. This is convenient (and fast),
but not robust. If the guessed types are wrong, you'll need to increase
<code>guess_max</code> or supply the correct types yourself.
</p>
<p>Column specifications created by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="readr.html#topic+cols">cols()</a></code> must contain
one column specification for each column. If you only want to read a
subset of the columns, use <code><a href="readr.html#topic+cols_only">cols_only()</a></code>.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
</p>

<ul>
<li><p> c = character
</p>
</li>
<li><p> i = integer
</p>
</li>
<li><p> n = number
</p>
</li>
<li><p> d = double
</p>
</li>
<li><p> l = logical
</p>
</li>
<li><p> f = factor
</p>
</li>
<li><p> D = date
</p>
</li>
<li><p> T = date time
</p>
</li>
<li><p> t = time
</p>
</li>
<li><p> ? = guess
</p>
</li>
<li><p> _ or - = skip
</p>
</li></ul>

<p>By default, reading a file without a column specification will print a
message showing what <code>readr</code> guessed they were. To remove this message,
set <code>show_col_types = FALSE</code> or set <code>options(readr.show_col_types = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="read_seq_len_+3A_...">...</code></td>
<td>
<p>additional parameters, passed to <code>read_tsv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with sequence information
</p>
<p>tibble with sequence information
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>read_seq_len()</code>: read seqs from a single file_name in fasta, gbk or gff3 format.
</p>
</li>
<li> <p><code>read_fai()</code>: read seqs from a single file in seqkit/samtools fai format.
</p>
</li></ul>

<hr>
<h2 id='read_tracks'>Read files in various standard formats (FASTA, GFF3, GBK, BED, BLAST, ...) into track tables</h2><span id='topic+read_tracks'></span><span id='topic+read_feats'></span><span id='topic+read_subfeats'></span><span id='topic+read_links'></span><span id='topic+read_sublinks'></span><span id='topic+read_seqs'></span>

<h3>Description</h3>

<p>Convenience functions to read sequences, features or links from various
bioinformatics file formats, such as FASTA, GFF3, Genbank, BLAST tabular
output, etc. See <code><a href="#topic+def_formats">def_formats()</a></code> for full list. File formats and the
corresponding read-functions are automatically determined based on file
extensions. All these functions can read multiple files in the same format at
once, and combine them into a single table - useful, for example, to read a
folder of gff-files with each file containing genes of a different genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_feats(files, .id = "file_id", format = NULL, parser = NULL, ...)

read_subfeats(files, .id = "file_id", format = NULL, parser = NULL, ...)

read_links(files, .id = "file_id", format = NULL, parser = NULL, ...)

read_sublinks(files, .id = "file_id", format = NULL, parser = NULL, ...)

read_seqs(
  files,
  .id = "file_id",
  format = NULL,
  parser = NULL,
  parse_desc = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_tracks_+3A_files">files</code></td>
<td>
<p>files to reads. Should all be of same format. In many cases,
compressed files (<code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code>) are supported.
Similarly, automatic download of remote files starting with <code style="white-space: pre;">&#8288;http(s)://&#8288;</code> or
<code style="white-space: pre;">&#8288;ftp(s)://&#8288;</code> works in most cases.</p>
</td></tr>
<tr><td><code id="read_tracks_+3A_.id">.id</code></td>
<td>
<p>the column with the name of the file a record was read from.
Defaults to &quot;file_id&quot;. Set to &quot;bin_id&quot; if every file represents a different
bin.</p>
</td></tr>
<tr><td><code id="read_tracks_+3A_format">format</code></td>
<td>
<p>specify a format known to gggenomes, such as <code>gff3</code>, <code>gbk</code>, ...
to overwrite automatic determination based on the file extension (see
<code><a href="#topic+def_formats">def_formats()</a></code> for full list).</p>
</td></tr>
<tr><td><code id="read_tracks_+3A_parser">parser</code></td>
<td>
<p>specify the name of an R function to overwrite automatic
determination based on format, e.g. <code>parser="read_tsv"</code>.</p>
</td></tr>
<tr><td><code id="read_tracks_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to the format-specific read
function called down the line.</p>
</td></tr>
<tr><td><code id="read_tracks_+3A_parse_desc">parse_desc</code></td>
<td>
<p>turn <code style="white-space: pre;">&#8288;key=some value&#8288;</code> pairs from <code>seq_desc</code> into <code>key</code>-named
columns and remove them from <code>seq_desc</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gggenomes-compatible sequence, feature or link tibble
</p>
<p>tibble with features
</p>
<p>tibble with features
</p>
<p>tibble with links
</p>
<p>tibble with links
</p>
<p>tibble with sequence information
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>read_feats()</code>: read files as features mapping onto
sequences.
</p>
</li>
<li> <p><code>read_subfeats()</code>: read files as subfeatures mapping onto other features
</p>
</li>
<li> <p><code>read_links()</code>: read files as links connecting sequences
</p>
</li>
<li> <p><code>read_sublinks()</code>: read files as sublinks connecting features
</p>
</li>
<li> <p><code>read_seqs()</code>: read sequence ID, description and length.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># read genes/features from a gff file
read_feats(ex("eden-utr.gff"))


# read all gff files from a directory
read_feats(list.files(ex("emales/"), "*.gff$", full.names = TRUE))


# read remote files

gbk_phages &lt;- c(
  PSSP7 = paste0(
    "ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/",
    "000/858/745/GCF_000858745.1_ViralProj15134/",
    "GCF_000858745.1_ViralProj15134_genomic.gff.gz"
  ),
  PSSP3 = paste0(
    "ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/",
    "000/904/555/GCF_000904555.1_ViralProj195517/",
    "GCF_000904555.1_ViralProj195517_genomic.gff.gz"
  )
)
read_feats(gbk_phages)


# read sequences from a fasta file.
read_seqs(ex("emales/emales.fna"), parse_desc = FALSE)

# read sequence info from a fasta file with `parse_desc=TRUE` (default). `key=value`
# pairs are removed from `seq_desc` and parsed into columns with `key` as name
read_seqs(ex("emales/emales.fna"))

# read sequence info from samtools/seqkit style index
read_seqs(ex("emales/emales.fna.seqkit.fai"))

# read sequence info from multiple gff file
read_seqs(c(ex("emales/emales.gff"), ex("emales/emales-tirs.gff")))

</code></pre>

<hr>
<h2 id='read_vcf'>Read a VCF file</h2><span id='topic+read_vcf'></span>

<h3>Description</h3>

<p>VCF (Variant Call Format) file format is used to store variation data and its metadata.
Based on the used analysis program (e.g. GATK, freebayes, etc...), details within the VCF file can slightly differ.
For example, type of mutation is not mentioned as output for certain variant analysis programs.
the &quot;read_vcf&quot; function, ignores the first header/metadata lines and directly converts the data into a tidy dataframe.
The function will extract the type of mutation. By absence, it will derive the type of mutation from the &quot;ref&quot; and &quot;alt&quot; column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vcf(
  file,
  parse_info = FALSE,
  col_names = def_names("vcf"),
  col_types = def_types("vcf")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_vcf_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_parse_info">parse_info</code></td>
<td>
<p>if set to 'TRUE', the read_vcf function will split all the metadata stored in the &quot;info&quot; column and stores it into separate columns.
By default it is set to 'FALSE'.</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_col_names">col_names</code></td>
<td>
<p>column names to use. Defaults to <code>def_names("vcf")</code> (see <code><a href="#topic+def_names">def_names</a></code>).</p>
</td></tr>
<tr><td><code id="read_vcf_+3A_col_types">col_types</code></td>
<td>
<p>column types to use. Defaults to <code>def_types("vcf")</code> (see <code><a href="#topic+def_types">def_types</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic++25+3C+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+compound">%&lt;&gt;%</a></code>, <code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='require_vars'>Require variables in an object</h2><span id='topic+require_vars'></span>

<h3>Description</h3>

<p>Require variables in an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require_vars(x, vars, warn_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="require_vars_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="require_vars_+3A_vars">vars</code></td>
<td>
<p>required variables</p>
</td></tr>
<tr><td><code id="require_vars_+3A_warn_only">warn_only</code></td>
<td>
<p>don't die on missing vars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original tibble if all vars are present or warning only
</p>

<hr>
<h2 id='scale_color_variant'>Default colors and shapes for mutation types.</h2><span id='topic+scale_color_variant'></span><span id='topic+scale_shape_variant'></span>

<h3>Description</h3>

<p>The user can call upon an convenient function called <code>scale_color_variant</code>,
which changes the color of (SNP) points, based on their nucleotides (A, C, G, T).
By default the function uses a colorblind friendly palette, but users can manually overwrite these colors.
<em>(Within the plotting function (e.g. <code>geom_variant</code>), coloring of the column should still be mentioned (<code>aes(color = ...)</code>).</em>
</p>
<p>The function <code>scale_shape_variant</code> changes the shape of plotted points based on the type of mutation.
The user can also manually decide which shape, each specific type of mutation should have.
By default, SNPs are diamond shaped, Deletions triangle downwards and Insertions triangle upwards.
(These default settings make most sense when using <code>geom_variant(offset = -0.2)</code>).
<em>(User should still manually call which column is used for the shape aesthetic)</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_color_variant(
  values = c(A = "#e66101", C = "#b2abd2", G = "#5e3c99", T = "#fdb863"),
  na.value = "white",
  ...
)

scale_shape_variant(
  values = c(SNP = 23, Deletion = 25, Insertion = 24),
  na.value = 1,
  characters = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_color_variant_+3A_values">values</code></td>
<td>
<p>A vector indicating how to color/shape different variables.
The functions <code>scale_color_variant()</code> and <code>scale_shape_variant()</code> have a default setting, which can be overwritten.</p>
</td></tr>
<tr><td><code id="scale_color_variant_+3A_na.value">na.value</code></td>
<td>
<p>The aesthetic value (color/shape/etc.) to use for non matching values.</p>
</td></tr>
<tr><td><code id="scale_color_variant_+3A_...">...</code></td>
<td>
<p>Additional parameters, passed to scale_color_manual</p>
</td></tr>
<tr><td><code id="scale_color_variant_+3A_characters">characters</code></td>
<td>
<p>When <code>TRUE</code>, it changes the default shapes of <code>scale_shape_variant()</code> to become the letters of the nucleotides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 scale object for color or shape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of example data.
testposition &lt;- tibble::tibble(
  type = c(
    "Insertion", "SNP", "SNP", "Deletion",
    "Deletion", "SNP", "SNP", "Insertion", "SNP", "Insertion", "SNP"
  ),
  start = c(10, 20, 30, 35, 40, 60, 65, 90, 90, 100, 120),
  ALT = c("AT", "G", "C", ".", ".", "T", "C", "CAT", "G", "TC", "A"),
  REF = c("A", "T", "G", "A", "A", "G", "A", "C", "A", "T", "G"),
  end = start + 1,
  seq_id = c(rep("A", 11))
)

testseq &lt;- tibble::tibble(
  seq_id = "A",
  start = 0,
  end = 150,
  length = end - start
)

p1 &lt;- gggenomes(seqs = testseq, feats = testposition)
p2 &lt;- p1 + geom_seq()

## Scale_color_variant()
# Changing the color aesthetics in geom_variant: colors all mutations
# (In this example, All ALT (alternative) nucleotides are being colored)
p1 + geom_variant(aes(color = ALT))

# Color all SNPs with default colors using scale_color_variant().
# (SNPs are 1 nucleotide long, other mutations such as Insertions
# and Deletions have either more ore less nucleotides within the
# ALT column and are thus not plotted)
p1 + geom_variant(aes(color = ALT)) +
  scale_color_variant()

# Manually changing colors with scale_color_variant()
p1 + geom_variant(aes(color = ALT)) +
  scale_color_variant(values = c(A = "purple", T = "darkred", TC = "black", AT = "pink"))

## Scale_shape_variant()
# Changing the `shape` aesthetics in geom_variant
p2 + geom_variant(aes(shape = type), offset = -0.1)

# Calling upon scale_shape_variant() to change shapes
p2 + geom_variant(aes(shape = type), offset = -0.1) +
  scale_shape_variant()

# Manually changing shapes with scale_shape_variant()
p2 + geom_variant(aes(shape = type), offset = -0.1) +
  scale_shape_variant(values = c(SNP = 14, Deletion = 18, Insertion = 21))

# Plotting (nucleotides) characters instead of shapes
p2 + geom_variant(aes(shape = ALT), offset = -0.1, size = 3) +
  scale_shape_variant(characters = TRUE)

# Alternative way to plot nucleotides (of ALT) by using `geom=text` within `geom_variant()`
gggenomes(seqs = testseq, feats = testposition) +
  geom_seq() +
  geom_variant(aes(shape = type), offset = -0.1) +
  scale_shape_variant() +
  geom_variant(aes(label = ALT), geom = "text", offset = -0.25) +
  geom_bin_label()

# Combining scale_color_variant() and scale_shape_variant()
p2 + geom_variant(aes(shape = ALT, color = ALT), offset = -0.1, size = 3, show.legend = FALSE) +
  geom_variant(aes(color = ALT)) +
  scale_color_variant(na.value = "black") +
  scale_shape_variant(characters = TRUE)

</code></pre>

<hr>
<h2 id='scale_x_bp'>X-scale for genomic data</h2><span id='topic+scale_x_bp'></span><span id='topic+label_bp'></span>

<h3>Description</h3>

<p><code>scale_x_bp()</code> is the default scale for genomic x-axis. It wraps
<code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code> using <code>label_bp()</code> as default labeller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_bp(..., suffix = "", sep = "", accuracy = 1)

label_bp(suffix = "", sep = "", accuracy = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_x_bp_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code></p>
</td></tr>
<tr><td><code id="scale_x_bp_+3A_suffix">suffix</code></td>
<td>
<p>unit suffix e.g. &quot;bp&quot;</p>
</td></tr>
<tr><td><code id="scale_x_bp_+3A_sep">sep</code></td>
<td>
<p>between number and unit prefix+suffix</p>
</td></tr>
<tr><td><code id="scale_x_bp_+3A_accuracy">accuracy</code></td>
<td>
<p>A number to round to. Use (e.g.) <code>0.01</code> to show 2 decimal
places of precision. If <code>NULL</code>, the default, uses a heuristic that should
ensure breaks have the minimum number of digits needed to show the
difference between adjacent values.
</p>
<p>Applied to rescaled data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 scale object with bp labels
</p>
<p>A labeller function for genomic data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># scale_x_bp invoked by default
gggenomes(emale_genes) + geom_gene()

# customize labels
gggenomes(emale_genes) + geom_gene() +
  scale_x_bp(suffix = "bp", sep = " ")

# Note: xlim will overwrite scale_x_bp() with ggplot2::scale_x_continuous()
gggenomes(emale_genes) + geom_gene() +
  xlim(0, 3e4)

# set limits explicitly with scale_x_bp() to avoid overwrite
gggenomes(emale_genes) + geom_gene() +
  scale_x_bp(limits = c(0, 3e4))
</code></pre>

<hr>
<h2 id='set_class'>Modify object class attriutes</h2><span id='topic+set_class'></span><span id='topic+add_class'></span><span id='topic+strip_class'></span>

<h3>Description</h3>

<p>Set class of an object. Optionally append or prepend to exiting class
attributes. <code>add_class</code> is short for <code>set_class(x, class, "prepend")</code>.
<code>strip_class</code> removes matching class strings from the class attribute vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_class(x, class, add = c("overwrite", "prepend", "append"))

add_class(x, class)

strip_class(x, class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_class_+3A_x">x</code></td>
<td>
<p>Object to assign new class to.</p>
</td></tr>
<tr><td><code id="set_class_+3A_class">class</code></td>
<td>
<p>Class value to add/strip.</p>
</td></tr>
<tr><td><code id="set_class_+3A_add">add</code></td>
<td>
<p>Possible values: &quot;overwrite&quot;, &quot;prepend&quot;, &quot;append&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object x as class value.
</p>

<hr>
<h2 id='shift'>Shift bins left/right</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>Shift bins along the x-axis, i.e. left or right in the default plot
layout. This is useful to align feats of interest in different bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(x, bins = everything(), by = 0, center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>gggenomes object</p>
</td></tr>
<tr><td><code id="shift_+3A_bins">bins</code></td>
<td>
<p>to shift left/right, select-like expression</p>
</td></tr>
<tr><td><code id="shift_+3A_by">by</code></td>
<td>
<p>shift each bin by this many bases. Single value or vector of the
same length as bins.</p>
</td></tr>
<tr><td><code id="shift_+3A_center">center</code></td>
<td>
<p>horizontal centering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gggenomes object with shifted seqs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0 &lt;- gggenomes(emale_genes, emale_seqs) +
  geom_seq() + geom_gene()

# Slide one bin left and one bin right
p1 &lt;- p0 |&gt; shift(2:3, by = c(-8000, 10000))

# align all bins to a target gene
mcp &lt;- emale_genes |&gt;
  dplyr::filter(name == "MCP") |&gt;
  dplyr::group_by(seq_id) |&gt;
  dplyr::slice_head(n = 1) # some have fragmented MCP gene, keep only first

p2 &lt;- p0 |&gt; shift(all_of(mcp$seq_id), by = -mcp$start) +
  geom_gene(data = genes(name == "MCP"), fill = "#01b9af")

library(patchwork)
p0 + p1 + p2
</code></pre>

<hr>
<h2 id='split_by'>Split by key preserving order</h2><span id='topic+split_by'></span>

<h3>Description</h3>

<p>Split by key column while preserving order according to the first
occurence. R base split converts keys to factors, changing default order to
alphanumeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by(.data, key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_by_+3A_key">key</code></td>
<td>
<p>variable to split by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of tibbles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tibble::tibble(x = c(1, 1, 1, 2), y = c("B", "A", "B", "B"), z = "foo") %&gt;%
  split_by(x)
</code></pre>

<hr>
<h2 id='strand_chr'>Convert strand to character</h2><span id='topic+strand_chr'></span>

<h3>Description</h3>

<p>Convert strand to character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strand_chr(strand, na = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strand_chr_+3A_strand">strand</code></td>
<td>
<p>some representation for strandedness</p>
</td></tr>
<tr><td><code id="strand_chr_+3A_na">na</code></td>
<td>
<p>what to use for <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>strand vector as character
</p>

<hr>
<h2 id='strand_int'>Convert strand to integer</h2><span id='topic+strand_int'></span>

<h3>Description</h3>

<p>Convert strand to integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strand_int(strand, na = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strand_int_+3A_strand">strand</code></td>
<td>
<p>some representation for strandedness</p>
</td></tr>
<tr><td><code id="strand_int_+3A_na">na</code></td>
<td>
<p>what to use for <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>strand vector as integer
</p>

<hr>
<h2 id='strand_lgl'>Convert strand to logical</h2><span id='topic+strand_lgl'></span>

<h3>Description</h3>

<p>Convert strand to logical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strand_lgl(strand, na = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strand_lgl_+3A_strand">strand</code></td>
<td>
<p>some representation for strandedness</p>
</td></tr>
<tr><td><code id="strand_lgl_+3A_na">na</code></td>
<td>
<p>what to use for <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>strand vector as logical
</p>

<hr>
<h2 id='swap_if'>Swap values of two columns based on a condition</h2><span id='topic+swap_if'></span>

<h3>Description</h3>

<p>Swap values of two columns based on a condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_if(x, condition, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_if_+3A_x">x</code></td>
<td>
<p>a tibble</p>
</td></tr>
<tr><td><code id="swap_if_+3A_condition">condition</code></td>
<td>
<p>an expression to be evaluated in data context returning a
TRUE/FALSE vector</p>
</td></tr>
<tr><td><code id="swap_if_+3A_...">...</code></td>
<td>
<p>the two columns bewteen which values are to be swapped in
dplyr::select-like syntax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with conditionally swapped start and end
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tibble(start = c(10, 100), end = c(30, 50))
# ensure start of a range is always smaller than the end
swap_if(x, start &gt; end, start, end)
</code></pre>

<hr>
<h2 id='swap_query'>Swap query and subject in blast-like feature tables</h2><span id='topic+swap_query'></span>

<h3>Description</h3>

<p>Swap query and subject columns in a table read with <code><a href="#topic+read_feats">read_feats()</a></code> or
<code><a href="#topic+read_links">read_links()</a></code>, for example, from blast searches. Swaps columns with
name/name2, such as 'seq_id/seq_id2', 'start/start2', ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_query(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swap_query_+3A_x">x</code></td>
<td>
<p>tibble with query and subject columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble with swapped query/subject columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>feats &lt;- tibble::tribble(
  ~seq_id, ~seq_id2, ~start, ~end, ~strand, ~start2, ~end2, ~evalue,
  "A", "B", 100, 200, "+", 10000, 10200, 1e-5
)
# make B the query
swap_query(feats)
</code></pre>

<hr>
<h2 id='theme_gggenomes_clean'>gggenomes default theme</h2><span id='topic+theme_gggenomes_clean'></span>

<h3>Description</h3>

<p>gggenomes default theme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_gggenomes_clean(
  base_size = 12,
  base_family = "",
  base_line_size = base_size/30,
  base_rect_size = base_size/30
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theme_gggenomes_clean_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="theme_gggenomes_clean_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="theme_gggenomes_clean_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements</p>
</td></tr>
<tr><td><code id="theme_gggenomes_clean_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 theme with gggenomes defaults
</p>

<hr>
<h2 id='track_ids'>Named vector of track ids and types</h2><span id='topic+track_ids'></span>

<h3>Description</h3>

<p>Named vector of track ids and types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_ids(x, track_type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track_ids_+3A_x">x</code></td>
<td>
<p>A gggenomes or gggenomes_layout object</p>
</td></tr>
<tr><td><code id="track_ids_+3A_track_type">track_type</code></td>
<td>
<p>restrict to any combination of &quot;seqs&quot;, &quot;feats&quot; and &quot;links&quot;.</p>
</td></tr>
<tr><td><code id="track_ids_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of track ids and types
</p>

<hr>
<h2 id='track_info'>Basic info on tracks in a gggenomes object</h2><span id='topic+track_info'></span>

<h3>Description</h3>

<p>Use <code>track_info()</code> to call on a gggenomes or gggenomes_layout object to return a short tibble
with ids, types, index and size of the loaded tracks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_info(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track_info_+3A_x">x</code></td>
<td>
<p>A gggenomes or gggenomes_layout object</p>
</td></tr>
<tr><td><code id="track_info_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The short tibble contains basic information on the tracks within the entered gggenomes object.
</p>

<ul>
<li> <p><strong>id</strong> : Shows original name of inputted data frame (only when more than one data frames are present in a track).
</p>
</li>
<li> <p><strong>type</strong> : The track in which the data frame is present.
</p>
</li>
<li> <p><strong>i</strong> (index) : The chronological order of data frames in a specific track.
</p>
</li>
<li> <p><strong>n</strong> (size) : Amount of objects <strong>plotted</strong> from the data frame.
(<strong>not</strong> the amount of objects <em>in</em> the inputted data frame)
</p>
</li></ul>



<h3>Value</h3>

<p>Short tibble with ids, types, index and size of loaded tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gggenomes(
  seqs = emale_seqs,
  feats = list(emale_genes, emale_tirs, emale_ngaros),
  links = emale_ava
) |&gt;
  track_info()
</code></pre>

<hr>
<h2 id='unnest_exons'>Unnest exons</h2><span id='topic+unnest_exons'></span>

<h3>Description</h3>

<p>Unnest exons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_exons(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnest_exons_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with unnested exons
</p>

<hr>
<h2 id='vars_track'>Tidyselect track variables</h2><span id='topic+vars_track'></span>

<h3>Description</h3>

<p>Based on <code>tidyselect::vars_pull</code>. Powers track selection in <code>pull_track()</code>.
Catches and modifies errors from vars_pull to track-relevant info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_track(
  x,
  track_id,
  track_type = c("seqs", "feats", "links"),
  ignore = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_track_+3A_x">x</code></td>
<td>
<p>A gggenomes or gggenomes_layout object</p>
</td></tr>
<tr><td><code id="vars_track_+3A_track_id">track_id</code></td>
<td>
<p>a quoted or unquoted name or as positive/negative integer
giving the position from the left/right.</p>
</td></tr>
<tr><td><code id="vars_track_+3A_track_type">track_type</code></td>
<td>
<p>restrict to these types of tracks - affects position-based
selection</p>
</td></tr>
<tr><td><code id="vars_track_+3A_ignore">ignore</code></td>
<td>
<p>names of tracks to ignore when selecting by position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The selected track_id as an unnamed string
</p>

<hr>
<h2 id='width'>The width of a range</h2><span id='topic+width'></span><span id='topic+width0'></span>

<h3>Description</h3>

<p>Always returns a positive value, even if start &gt; end. <code>width0</code> is a short
handle for <code>width(..., base=0)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>width(start, end, base = 1)

width0(start, end, base = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="width_+3A_start">start</code>, <code id="width_+3A_end">end</code></td>
<td>
<p>start and end of the range</p>
</td></tr>
<tr><td><code id="width_+3A_base">base</code></td>
<td>
<p>the base of the coordinate system, usually 1 or 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>

<hr>
<h2 id='write_gff3'>Write a gff3 file from a tidy table</h2><span id='topic+write_gff3'></span>

<h3>Description</h3>

<p>Write a gff3 file from a tidy table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gff3(
  feats,
  file,
  seqs = NULL,
  type = NULL,
  source = ".",
  score = ".",
  strand = ".",
  phase = ".",
  id_var = "feat_id",
  parent_var = "parent_ids",
  head = "##gff-version 3",
  ignore_attr = c("introns", "geom_id")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_gff3_+3A_feats">feats</code></td>
<td>
<p>tidy feat table</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_file">file</code></td>
<td>
<p>name of output file</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_seqs">seqs</code></td>
<td>
<p>a tidy sequence table to generate optional <code style="white-space: pre;">&#8288;##sequence-region&#8288;</code>
directives in the header</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_type">type</code></td>
<td>
<p>if no type column exists, use this as the default type</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_source">source</code></td>
<td>
<p>if no source column exists, use this as the default source</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_score">score</code></td>
<td>
<p>if no score column exists, use this as the default score</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_strand">strand</code></td>
<td>
<p>if no strand column exists, use this as the default strand</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_phase">phase</code></td>
<td>
<p>if no phase column exists, use this as the default phase</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_id_var">id_var</code></td>
<td>
<p>the name of the column to use as the GFF3 <code>ID</code> tag</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_parent_var">parent_var</code></td>
<td>
<p>the name of the column to use as GFF3 <code>Parent</code> tag</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_head">head</code></td>
<td>
<p>additional information to add to the header section</p>
</td></tr>
<tr><td><code id="write_gff3_+3A_ignore_attr">ignore_attr</code></td>
<td>
<p>attributes not to be included in GFF3 tag list. Defaults
to internals: <code style="white-space: pre;">&#8288;introns, geom_id&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, writes to file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename &lt;- tempfile(fileext = ".gff")
write_gff3(emale_genes, filename, emale_seqs, id_var = "feat_id")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
