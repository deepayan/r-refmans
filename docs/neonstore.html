<!DOCTYPE html><html lang="en-US"><head><title>Help for package neonstore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {neonstore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#neon_citation'><p>Generate the appropriate citation for your data</p></a></li>
<li><a href='#neon_cloud'><p>neon cloud</p></a></li>
<li><a href='#neon_data'><p>Query the NEON API for URLs of matching data products</p>
Repeated requests will be cached</a></li>
<li><a href='#neon_db'><p>Cache-able duckdb database connection</p></a></li>
<li><a href='#neon_db_dir'><p>Default directory for persistent NEON database</p></a></li>
<li><a href='#neon_delete_db'><p>delete the local NEON database</p></a></li>
<li><a href='#neon_dir'><p>Default directory for persistent NEON file store</p></a></li>
<li><a href='#neon_disconnect'><p>Disconnect from the neon database</p></a></li>
<li><a href='#neon_download'><p>Download NEON data products into a local store</p></a></li>
<li><a href='#neon_export'><p>export local neon store as a zip archive</p></a></li>
<li><a href='#neon_export_db'><p>Export NEON database to parquet</p></a></li>
<li><a href='#neon_filename_parser'><p>NEON filename parser</p></a></li>
<li><a href='#neon_import'><p>Import a previously exported zip archive of raw NEON files</p></a></li>
<li><a href='#neon_import_db'><p>Import a NEON database exported from neon_export_db()</p></a></li>
<li><a href='#neon_index'><p>Show information about all files downloaded to the local store</p></a></li>
<li><a href='#neon_pane'><p>Open NEON database connection pane in RStudio</p></a></li>
<li><a href='#neon_products'><p>Table of all NEON Data Products</p></a></li>
<li><a href='#neon_read'><p>read in neon tabular data</p></a></li>
<li><a href='#neon_remote'><p>neon_remote</p>
</p>
<p>select a table from the remote connection</p></a></li>
<li><a href='#neon_remote_db'><p>Establish a remote database connection using <code>arrow</code></p></a></li>
<li><a href='#neon_sites'><p>Table of all NEON sites</p></a></li>
<li><a href='#neon_store'><p>import neon data into a local database</p></a></li>
<li><a href='#neon_sync_db'><p>sync local parquet export to an S3 database</p></a></li>
<li><a href='#neon_table'><p>Return a neon table from the database</p></a></li>
<li><a href='#show_deprecated_data'><p>show deprecated data</p></a></li>
<li><a href='#standardize_export_names'><p>standardize export names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>NEON Data Store</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The National Ecological Observatory Network (NEON) provides access
  to its numerous data products through its REST API, 
  <a href="https://data.neonscience.org/data-api/">https://data.neonscience.org/data-api/</a>. This package provides a
  high-level user interface for downloading and storing NEON data products.
  Unlike 'neonUtilities', this package will avoid repeated downloading,
  provides persistent storage, and improves performance.  'neonstore' can also
  construct a local 'duckdb' database of stacked tables, making it possible
  to work with tables that are far to big to fit into memory.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI, duckdb (&ge; 0.2.3), httr, progress, R.utils, thor, vroom
(&ge; 1.5.1), zip, duckdbfs, memoise, cachem, glue</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tibble, jsonlite, testthat, covr, xml2, spelling, rstudioapi,
neonUtilities, rhdf5, curl, openssl, digest, arrow, dplyr,
R.methodsS3, R.oo, storr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-07 19:04:02 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Boettiger <a href="https://orcid.org/0000-0002-1642-628X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Quinn Thomas <a href="https://orcid.org/0000-0003-1282-7825"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christine Laney <a href="https://orcid.org/0000-0002-4944-2083"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Claire Lunch <a href="https://orcid.org/0000-0001-8753-6593"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Noam Ross <a href="https://orcid.org/0000-0002-2136-0000"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Boettiger &lt;cboettig@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 07:22:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='neon_citation'>Generate the appropriate citation for your data</h2><span id='topic+neon_citation'></span>

<h3>Description</h3>

<p>Generate the appropriate citation for your data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_citation(product = NULL, download_date = Sys.Date(), dir = neon_dir())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_citation_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_citation_+3A_download_date">download_date</code></td>
<td>
<p>Date of download to be included in citation.
default is today's date, see details.</p>
</td></tr>
<tr><td><code id="neon_citation_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>neon_download()</code> does not record download date for each file.
Citing a single product download date is after all rather meaningless, as
parts of a products may not have all been downloaded on different dates.
Indeed, <code>neon_download()</code> is designed in precisely this way, to allow easy
updating of downloads without re-downloading older data.
</p>


<h3>Value</h3>

<p>returns a <a href="utils.html#topic+bibentry">utils::bibentry</a> object, which can be used as text
or formatted for bibtex.
</p>


<h3>References</h3>

<p>https://www.neonscience.org/data-samples/data-policies-citation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # may be slow
neon_citation("DP1.10003.001")

## or the citation for all products in store:
neon_citation()

## as bibtex
format(neon_citation("DP1.10003.001"), "bibtex")


</code></pre>

<hr>
<h2 id='neon_cloud'>neon cloud</h2><span id='topic+neon_cloud'></span>

<h3>Description</h3>

<p>neon cloud
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_cloud(
  table,
  product,
  start_date = NA,
  end_date = NA,
  site = NA,
  type = "basic",
  release = NA,
  quiet = FALSE,
  api = "https://data.neonscience.org/api/v0",
  unify_schemas = FALSE,
  .token = Sys.getenv("NEON_TOKEN")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_cloud_+3A_table">table</code></td>
<td>
<p>NEON table name</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_release">release</code></td>
<td>
<p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_quiet">quiet</code></td>
<td>
<p>Should download progress be displayed?</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_api">api</code></td>
<td>
<p>the URL to the NEON API, leave as default.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_unify_schemas">unify_schemas</code></td>
<td>
<p>if cloud-read fails to collect data due to miss-matched
schemas, set this to <code>TRUE</code>. Warning: Results in much slower reads and may
demand more memory due to parsing the schema of each file, especially when
many files are involved.</p>
</td></tr>
<tr><td><code id="neon_cloud_+3A_.token">.token</code></td>
<td>
<p>an authentication token from NEON. A token is not
required but will allow access to a higher number of requests before
rate limiting applies, see
<a href="https://data.neonscience.org/data-api/rate-limiting/#api-tokens">https://data.neonscience.org/data-api/rate-limiting/#api-tokens</a>.
Note that once files are downloaded once, <code>neonstore</code> provides persistent
access to them without further interaction required with the API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lazy data frame
</p>

<hr>
<h2 id='neon_data'>Query the NEON API for URLs of matching data products
Repeated requests will be cached</h2><span id='topic+neon_data'></span>

<h3>Description</h3>

<p>Query the NEON API for URLs of matching data products
Repeated requests will be cached
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_data(
  product,
  start_date = NA,
  end_date = NA,
  site = NA,
  type = NA,
  release = NA,
  quiet = FALSE,
  api = "https://data.neonscience.org/api/v0",
  .token = Sys.getenv("NEON_TOKEN")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_data_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_release">release</code></td>
<td>
<p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_quiet">quiet</code></td>
<td>
<p>Should download progress be displayed?</p>
</td></tr>
<tr><td><code id="neon_data_+3A_api">api</code></td>
<td>
<p>the URL to the NEON API, leave as default.</p>
</td></tr>
<tr><td><code id="neon_data_+3A_.token">.token</code></td>
<td>
<p>an authentication token from NEON. A token is not
required but will allow access to a higher number of requests before
rate limiting applies, see
<a href="https://data.neonscience.org/data-api/rate-limiting/#api-tokens">https://data.neonscience.org/data-api/rate-limiting/#api-tokens</a>.
Note that once files are downloaded once, <code>neonstore</code> provides persistent
access to them without further interaction required with the API.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing the name, filesize (in bytes),
checksums (columns md5, crc32, or crc32c, though each product will use
only one of these), url, and release status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- neon_data("DP1.10003.001") 
x &lt;- neon_data("DP1.10003.001", release="RELEASE-2021") 

</code></pre>

<hr>
<h2 id='neon_db'>Cache-able duckdb database connection</h2><span id='topic+neon_db'></span>

<h3>Description</h3>

<p>Cache-able duckdb database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_db(
  dir = neon_db_dir(),
  read_only = TRUE,
  memory_limit = getOption("duckdb_memory_limit", NA),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_db_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
<tr><td><code id="neon_db_+3A_read_only">read_only</code></td>
<td>
<p>allow concurrent connections by enforcing read_only.
See details.</p>
</td></tr>
<tr><td><code id="neon_db_+3A_memory_limit">memory_limit</code></td>
<td>
<p>Set a memory limit for duckdb, in GB.  This can
also be set for the session by using options, e.g.
<code>options(duckdb_memory_limit=10)</code> for a limit of 10GB.  On most systems
duckdb will automatically set a limit to 80% of machine capacity if not
set explicitly.</p>
</td></tr>
<tr><td><code id="neon_db_+3A_...">...</code></td>
<td>
<p>additional arguments to dbConnect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a connection to a permanent duckdb database
instance in the provided directory (see <code><a href="#topic+neon_dir">neon_dir()</a></code>).  This
connection is also cached, so that code which repeatedly calls
<code style="white-space: pre;">&#8288;[neon_db]&#8288;</code> will not stall or hang.  Only <code>read_only</code> connections
will be cached.
</p>
<p>NOTE: <code style="white-space: pre;">&#8288;[duckdb::duckdb()]&#8288;</code> can only support a single read-write connection
at a time.  The default option of <code>read_only = TRUE</code> allows
multiple connections. <code style="white-space: pre;">&#8288;[neon_store()]&#8288;</code> will automatically set this to
<code>FALSE</code> to allow data import.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# tempfile used for illustration only
neon_db(tempfile())

</code></pre>

<hr>
<h2 id='neon_db_dir'>Default directory for persistent NEON database</h2><span id='topic+neon_db_dir'></span>

<h3>Description</h3>

<p>Use <code>neon_db_dir()</code> to view or access the currently active database
directory. By default, this uses the appropriate application directory
for your operating system, see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>.
This location can be overridden by setting
the environmental variable <code>NEONSTORE_DB</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_db_dir()
</code></pre>


<h3>Value</h3>

<p>the active <code>neonstore</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
neon_db_dir()

## Override with an environmental variable:
Sys.setenv(NEONSTORE_DB = tempdir())
neon_db_dir()
## Unset
Sys.unsetenv("NEONSTORE_DB")

</code></pre>

<hr>
<h2 id='neon_delete_db'>delete the local NEON database</h2><span id='topic+neon_delete_db'></span>

<h3>Description</h3>

<p>delete the local NEON database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_delete_db(db_dir = neon_db_dir(), ask = interactive())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_delete_db_+3A_db_dir">db_dir</code></td>
<td>
<p>neon database location (configurable with the NEONSTORE_DB
environmental variable)</p>
</td></tr>
<tr><td><code id="neon_delete_db_+3A_ask">ask</code></td>
<td>
<p>Ask for confirmation first?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just a helper function that deletes the NEON database
files, which are found under <code>file.path(neon_dir(), "database")</code>.
This does not delete downloaded raw data, which can easily be
re-loaded with <code>neon_store()</code>.  Usually unnecessary but can be
helpful in resetting a corrupt database.
</p>
<p>If you want to delete all raw data files downloaded by neonstore
as well, simply delete the entire directory given by <code><a href="#topic+neon_dir">neon_dir()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a db
dir &lt;- tempfile()
db &lt;- neon_db(dir)

# Delete it
neon_delete_db(dir, ask = FALSE)


</code></pre>

<hr>
<h2 id='neon_dir'>Default directory for persistent NEON file store</h2><span id='topic+neon_dir'></span>

<h3>Description</h3>

<p>Use <code>neon_dir()</code> to view or access the currently active local store.
By default, <code><a href="#topic+neon_download">neon_download()</a></code> downloads files into the <code>neon_dir()</code>,
which uses an appropriate application directory for your operating system,
see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>.  This location can be overridden by setting
the environmental variable <code>NEONSTORE_HOME</code>.  <code>neonstore</code> functions
(e.g. <code><a href="#topic+neon_index">neon_index()</a></code>, and <code><a href="#topic+neon_read">neon_read()</a></code>) look for files in
the <code>neon_dir()</code> directory by default.  (All functions can also take
a one-off argument to <code>dir</code> in the function call in place of the calling
<code>neon_dir()</code> to access the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_dir()
</code></pre>


<h3>Value</h3>

<p>the active <code>neonstore</code> directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
neon_dir()

## Override with an environmental variable:
Sys.setenv(NEONSTORE_HOME = tempdir())
neon_dir()
## Unset
Sys.unsetenv("NEONSTORE_HOME")

</code></pre>

<hr>
<h2 id='neon_disconnect'>Disconnect from the neon database</h2><span id='topic+neon_disconnect'></span>

<h3>Description</h3>

<p>Disconnect from the neon database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_disconnect(db = neon_db())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_disconnect_+3A_db">db</code></td>
<td>
<p>link to an existing database connection</p>
</td></tr>
</table>

<hr>
<h2 id='neon_download'>Download NEON data products into a local store</h2><span id='topic+neon_download'></span>

<h3>Description</h3>

<p>Download NEON data products into a local store
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_download(
  product,
  table = NA,
  site = NA,
  start_date = NA,
  end_date = NA,
  type = "basic",
  release = NA,
  quiet = FALSE,
  verify = TRUE,
  unique = TRUE,
  dir = neon_dir(),
  get_zip = FALSE,
  unzip = FALSE,
  api = "https://data.neonscience.org/api/v0",
  .token = Sys.getenv("NEON_TOKEN")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_download_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_table">table</code></td>
<td>
<p>Include only files matching this table name (or regex pattern).
(optional).</p>
</td></tr>
<tr><td><code id="neon_download_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_release">release</code></td>
<td>
<p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_quiet">quiet</code></td>
<td>
<p>Should download progress be displayed?</p>
</td></tr>
<tr><td><code id="neon_download_+3A_verify">verify</code></td>
<td>
<p>Should downloaded files be compared against the MD5 hash
reported by the NEON API to verify integrity? (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="neon_download_+3A_unique">unique</code></td>
<td>
<p>Should we skip downloads of files we already have?  Note: file
comparisons are based on file hash, which will omit files that have identical
content but different names.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_get_zip">get_zip</code></td>
<td>
<p>should we attempt to download .zip archive versions of files?
default <code>FALSE</code>, as zip archives are being deprecated from NEON API starting
in early 2021.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_unzip">unzip</code></td>
<td>
<p>should we extract .zip files? (default <code>TRUE</code>). Note: .zip
files are preserved in the store to avoid repeated downloads. Use of .zip
files in NEON API is now deprecated in favor of requesting individual files.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_api">api</code></td>
<td>
<p>the URL to the NEON API, leave as default.</p>
</td></tr>
<tr><td><code id="neon_download_+3A_.token">.token</code></td>
<td>
<p>an authentication token from NEON. A token is not
required but will allow access to a higher number of requests before
rate limiting applies, see
<a href="https://data.neonscience.org/data-api/rate-limiting/#api-tokens">https://data.neonscience.org/data-api/rate-limiting/#api-tokens</a>.
Note that once files are downloaded once, <code>neonstore</code> provides persistent
access to them without further interaction required with the API.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each NEON data product consists of a collection of
objects (e.g. tables), which are in turn broken into individual files by
site and sampling month.  Additionally, many NEON products have been
expanded, including some additional columns. Consequently, users must
specify if they want the &quot;basic&quot; or &quot;expanded&quot; version of this data.
</p>
<p>In the products table (see <a href="#topic+neon_products">neon_products</a>), the <code>productHasExpanded</code>
column indicates if the data
product has expanded, and the columns <code>productHasBasicDescription</code> and
<code>productHasExpandedDescription</code> provide a detailed explanation of the
differences between the <code>"expanded"</code> and <code>"basic"</code> versions of that
particular product.
</p>
<p>The API allows users to request component files directly.
By default, <code>neon-download()</code> will download all available
extensions.  Users can request only products of a certain format
(e.g. <code>.csv</code> or <code>.h5</code>) by altering the <code>file_regex</code> argument
(see examples).
</p>
<p>Prior to 2021, the API provided
access to a <code>.zip</code> file containing all the component objects
(e.g. tables) for that product at that site and sampling month.
</p>
<p><code>neon_download()</code> will avoid downloading metadata files which are bitwise
identical to other files in the same download request, as indicated by the
crc32 hash reported by the API.  These typically include metadata that are
shared across the product as a whole, but are for some reason included in
each sampling month for each site &ndash; potentially thousands of duplicates.
These duplicates are also packaged within the <code>.zip</code> downloads where it
is not possible to exclude them from the download.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 
 ## Omit dir=tempfile() to use persistent storage
 neon_download("DP1.10003.001", 
               start_date = "2018-01-01", 
               end_date = "2019-01-01",
               site = "YELL",
               dir = tempfile())
               
 ## Advanced use: filter for a particular table in the product
 neon_download(product = "DP1.10003.001",
               start_date = "2018-01-01",
               end_date = "2019-01-01",
               site = "YELL",
               table = "countdata",
               dir = tempfile())


</code></pre>

<hr>
<h2 id='neon_export'>export local neon store as a zip archive</h2><span id='topic+neon_export'></span>

<h3>Description</h3>

<p>Export all or select files from your neon store as a zip archive.
This can be useful if you want to bypass accessing the API, such as for
archiving the files required for your analysis so that they can be
re-created by other users without an API key, or without waiting for
the individual download, or any other tiem you want to share or
distribute your local store.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_export(
  archive = paste(Sys.Date(), "neonstore.zip", sep = "-"),
  product = NA,
  table = NA,
  site = NA,
  start_date = NA,
  end_date = NA,
  type = NA,
  ext = NA,
  timestamp = NA,
  hash = NULL,
  dir = neon_dir()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_export_+3A_archive">archive</code></td>
<td>
<p>path to the zip archive to be created.#'</p>
</td></tr>
<tr><td><code id="neon_export_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_export_+3A_table">table</code></td>
<td>
<p>Include only files matching this table name (or regex pattern).
(optional).</p>
</td></tr>
<tr><td><code id="neon_export_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_export_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="neon_export_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="neon_export_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="neon_export_+3A_ext">ext</code></td>
<td>
<p>only match files with this file extension(s)</p>
</td></tr>
<tr><td><code id="neon_export_+3A_timestamp">timestamp</code></td>
<td>
<p>only match timestamps prior this. See details in <code><a href="#topic+neon_index">neon_index()</a></code>.
Should be a datetime POSIXct object (or coerce-able string)</p>
</td></tr>
<tr><td><code id="neon_export_+3A_hash">hash</code></td>
<td>
<p>name of a hashing algorithm to check file integrity. Can be
<code>"md5"</code>, <code>"sha1"</code>, or <code>"sha256"</code> currently; or set to <a href="base.html#topic+NULL">NULL</a> (default)
to skip hash computation.</p>
</td></tr>
<tr><td><code id="neon_export_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table of selected files and metadata, from <code><a href="#topic+neon_index">neon_index()</a></code>, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neon_import">neon_import()</a></code>, <code><a href="#topic+neon_citation">neon_citation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
archive &lt;- tempfile()
dir &lt;- tempdir()
neon_export(archive, dir = dir)

</code></pre>

<hr>
<h2 id='neon_export_db'>Export NEON database to parquet</h2><span id='topic+neon_export_db'></span>

<h3>Description</h3>

<p>Export your current database. This can be important to (1)
archive and share your database files with another user or machine,
(2) expose your database using an S3 bucket using neon_remote_db(),
(3) assist in upgrading your duckdb version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_export_db(dir = file.path(neon_dir(), "parquet"), db = neon_db())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_export_db_+3A_dir">dir</code></td>
<td>
<p>directory to which parquet export is written.</p>
</td></tr>
<tr><td><code id="neon_export_db_+3A_db">db</code></td>
<td>
<p>Connection to your local NEON database</p>
</td></tr>
</table>

<hr>
<h2 id='neon_filename_parser'>NEON filename parser</h2><span id='topic+neon_filename_parser'></span>

<h3>Description</h3>

<p>Parse filenames into their component metadata.  See details for
definition of each metadata field, or consult the NEON documentation
linked below. <a href="https://data.neonscience.org/file-naming-conventions">https://data.neonscience.org/file-naming-conventions</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_filename_parser(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_filename_parser_+3A_x">x</code></td>
<td>
<p>vector of NEON filenames</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Metadata components:</h4>


<ul>
<li><p> NEON 	A four-character alphanumeric code, denoting the organizational
origin of the data product and identifying the product as
operational; data collected as part of a special data collection
exercise are designated by a separate, unique alphanumeric code
created by the PI.
</p>
</li>
<li><p> DOM 	A three-character alphanumeric code, referring to the domain of data
acquisition (D01 - D20).
</p>
</li>
<li><p> SITE  A four-character alphanumeric code, referring to the site of data
acquisition; all sites are designated by a standardized
four-character alphabetic code.
</p>
</li>
<li><p> DPL 	A three-character alphanumeric code, referring to data product
processing level.
</p>
</li>
<li><p> PRNUM 	A five-character numeric code, referring to the data product
number (see the Data Product Catalog at
http://data.neonscience.org/data-product-catalog).
</p>
</li>
<li><p> REV 	A three-digit designation, referring to the revision number of
the data product. The REV value is incremented by 1 each time a
major change is made in instrumentation, data collection protocol,
or data processing such that data from the preceding revision is
not directly comparable to the new.
</p>
</li>
<li><p> HOR 	A three-character alphanumeric code for Spatial Index #1.
Refers to measurement locations within one horizontal plane.
For example, if five surface measurements were taken, one
at each of the five soil array plots, the number in the HOR
field would range from 001-005.
</p>
</li>
<li><p> VER 	A three-character alphanumeric code for Spatial Index #2.
Refers to measurement locations within one vertical plane.
For example, if eight temperature measurements are collected,
one at each tower vertical level, the number in the VER field
would range from 010-080.
</p>
</li>
<li><p> TMI 	A three-character alphanumeric code for the Temporal Index.
Refers to the temporal representation, averaging period, or
coverage of the data product (e.g., minute, hour, month, year,
sub-hourly, day, lunar month, single instance, seasonal, annual,
multi-annual). 000 = native resolution, 001 = native resolution
or 1 minute, 002 = 2 minute, 005 = 5 minute, 015 = 15 minute,
030 = 30 minute, 060 = 60 minutes or 1 hour, 101-103 = native
resolution of replicate sensor 1, 2, and 3 respectively,
999 = Sensor conducts measurements at varied interval depending on air mass.
</p>
</li>
<li><p> DESC 	An abbreviated description of the data file or table.
</p>
</li>
<li><p> YYYY-MM 	Represents the year and month of the data in the file.
</p>
</li>
<li><p> PKGTYPE 	The type of data package downloaded. Options are 'basic',
representing the basic download package, or 'expanded', representing
the expanded download package (see more information below).
</p>
</li>
<li><p> GENTIME 	The date-time stamp when the file was generated, in UTC.
The format of the date-time stamp is YYYYMMDDTHHmmSSZ.
</p>
</li></ul>




<h4>AOP Products Only  (Airborne Observation Platform):</h4>


<ul>
<li><p> FLHTDATE 	Date of flight, YYYYMMDD
</p>
</li>
<li><p> FLIGHTSTRT 	Start time of flight, YYYYMMDDHH
</p>
</li>
<li><p> FLHTSTRT 	Start time of flight, YYMMDDHH
</p>
</li>
<li><p> IMAGEDATETIME 	Date and time of image capture, YYYYMMDDHHmmSS
</p>
</li>
<li><p> CCCCCC 	Digital camera serial number
</p>
</li>
<li><p> NNNN 	Sequential number for indexing files
</p>
</li>
<li><p> NNN 	Planned flightline number
</p>
</li>
<li><p> R 	Repeat number
</p>
</li>
<li><p> FFFFFF 	Numeric code for an individual flightline
</p>
</li>
<li><p> EEEEEE 	UTM easting of lower left corner
</p>
</li>
<li><p> NNNNNNN 	UTM northing of lower left corner
</p>
</li></ul>




<h3>Value</h3>

<p>a data frame in which filenames have been split into metadata
components.  Column names indicate the metadata field code, see details
section for complete descriptions.
</p>


<h3>References</h3>

<p>https://data.neonscience.org/file-naming-conventions
</p>

<hr>
<h2 id='neon_import'>Import a previously exported zip archive of raw NEON files</h2><span id='topic+neon_import'></span>

<h3>Description</h3>

<p><code><a href="#topic+neon_import">neon_import()</a></code> only reads in previously saved archives from <code><a href="#topic+neon_export">neon_export()</a></code>.
This can be useful in cases where
see <code><a href="#topic+neon_download">neon_download()</a></code> to download data directly from NEON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_import(archive, overwrite = TRUE, dir = neon_dir())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_import_+3A_archive">archive</code></td>
<td>
<p>path to the zip archive to be imported</p>
</td></tr>
<tr><td><code id="neon_import_+3A_overwrite">overwrite</code></td>
<td>
<p>should we overwrite any existing files?</p>
</td></tr>
<tr><td><code id="neon_import_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+neon_export">neon_export()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## tempfiles for example purposes only!
archive &lt;- tempfile()
neondir &lt;- tempdir() 


neon_export(archive, dir = neondir)
neon_import(archive)

</code></pre>

<hr>
<h2 id='neon_import_db'>Import a NEON database exported from neon_export_db()</h2><span id='topic+neon_import_db'></span>

<h3>Description</h3>

<p>Import a NEON database exported from neon_export_db()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_import_db(
  dir = file.path(neon_dir(), "parquet"),
  db = neon_db(read_only = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_import_db_+3A_dir">dir</code></td>
<td>
<p>directory to which parquet export is written.</p>
</td></tr>
<tr><td><code id="neon_import_db_+3A_db">db</code></td>
<td>
<p>Connection to your local NEON database</p>
</td></tr>
</table>

<hr>
<h2 id='neon_index'>Show information about all files downloaded to the local store</h2><span id='topic+neon_index'></span>

<h3>Description</h3>

<p>NEON products consist of several individual components, which are in turn
broken up by site and sampling month. By storing these individual files,
neonstore enables more reproducible workflows that can be traced back to
original, unaltered input data.  These atomized files can be quickly and easily
combined into unified tables, see <a href="#topic+neon_read">neon_read</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_index(
  product = NA,
  table = NA,
  site = NA,
  start_date = NA,
  end_date = NA,
  type = NA,
  ext = NA,
  timestamp = NA,
  release = NA,
  hash = NULL,
  dir = neon_dir(),
  deprecated = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_index_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_table">table</code></td>
<td>
<p>Include only files matching this table name (or regex pattern).
(optional).</p>
</td></tr>
<tr><td><code id="neon_index_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_ext">ext</code></td>
<td>
<p>only match files with this file extension(s)</p>
</td></tr>
<tr><td><code id="neon_index_+3A_timestamp">timestamp</code></td>
<td>
<p>only match timestamps prior this. See details in <code><a href="#topic+neon_index">neon_index()</a></code>.
Should be a datetime POSIXct object (or coerce-able string)</p>
</td></tr>
<tr><td><code id="neon_index_+3A_release">release</code></td>
<td>
<p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_hash">hash</code></td>
<td>
<p>name of a hashing algorithm to check file integrity. Can be
<code>"md5"</code>, <code>"sha1"</code>, or <code>"sha256"</code> currently; or set to <a href="base.html#topic+NULL">NULL</a> (default)
to skip hash computation.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
<tr><td><code id="neon_index_+3A_deprecated">deprecated</code></td>
<td>
<p>Should the index include files that have since been deprecated by
more recent downloads?  logical, default <a href="base.html#topic+TRUE">TRUE</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>File names include metadata such as the file productCode,
table name, site, and sampling month, as well as timestamp of creation.
<code>neon_index()</code> parses this metadata from the file name string and returns
the information in a convenient table, along with a path to each file.
</p>
<p><strong>Regarding timestamps:</strong>  NEON will occasionally publish new versions of
previously-released raw data files (which may or may not actually differ).
The NEON download API, and hence <code><a href="#topic+neon_download">neon_download()</a></code>, only serve the most recent
of such files, but earlier versions may still exist in your local <code>neonstore</code>
if you downloaded them before the updated files were released.  By default,
<code><a href="#topic+neon_read">neon_read()</a></code> will always select the most recent of such files, thus avoiding
duplication and providing the most updated data.  For reproducibility however,
it may be necessary to access older version instead. Setting the timestamp
argument allows the user to filter out newer files and select the original
ones instead.  Unfortunately, at this time users cannot request the outdated
data files from NEON API.  For strict reproducibility, users should also
archive their local store.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neon_download">neon_download()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


neon_index()

## Just bird survey product
neon_index("DP1.10003.001")



</code></pre>

<hr>
<h2 id='neon_pane'>Open NEON database connection pane in RStudio</h2><span id='topic+neon_pane'></span>

<h3>Description</h3>

<p>This function launches the RStudio &quot;Connection&quot; pane to interactively
explore the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_pane()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>if (!is.null(getOption("connectionObserver"))) neon_pane()
</code></pre>

<hr>
<h2 id='neon_products'>Table of all NEON Data Products</h2><span id='topic+neon_products'></span>

<h3>Description</h3>

<p>Return a table of all NEON Data Products, including product descriptions
and the productCode needed for <a href="#topic+neon_download">neon_download</a>.
(including list-columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_products(
  api = "https://data.neonscience.org/api/v0",
  .token = Sys.getenv("NEON_TOKEN")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_products_+3A_api">api</code></td>
<td>
<p>the URL to the NEON API, leave as default.</p>
</td></tr>
<tr><td><code id="neon_products_+3A_.token">.token</code></td>
<td>
<p>an authentication token from NEON. A token is not
required but will allow access to a higher number of requests before
rate limiting applies, see
<a href="https://data.neonscience.org/data-api/rate-limiting/#api-tokens">https://data.neonscience.org/data-api/rate-limiting/#api-tokens</a>.
Note that once files are downloaded once, <code>neonstore</code> provides persistent
access to them without further interaction required with the API.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+neon_download">neon_download</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

products &lt;- neon_products()

# Or search for a keyword
i &lt;- grepl("bird", products$keywords)
products[i, c("productCode", "productName")]

</code></pre>

<hr>
<h2 id='neon_read'>read in neon tabular data</h2><span id='topic+neon_read'></span>

<h3>Description</h3>

<p>read in neon tabular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_read(
  table = NA,
  product = NA,
  site = NA,
  start_date = NA,
  end_date = NA,
  ext = NA,
  timestamp = NA,
  release = NA,
  dir = neon_dir(),
  files = NULL,
  sensor_metadata = TRUE,
  keep_filename = FALSE,
  altrep = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_read_+3A_table">table</code></td>
<td>
<p>the name of a downloaded NEON table in the store,
see <a href="#topic+neon_index">neon_index</a></p>
</td></tr>
<tr><td><code id="neon_read_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_ext">ext</code></td>
<td>
<p>only match files with this file extension(s)</p>
</td></tr>
<tr><td><code id="neon_read_+3A_timestamp">timestamp</code></td>
<td>
<p>only match timestamps prior this. See details in <code><a href="#topic+neon_index">neon_index()</a></code>.
Should be a datetime POSIXct object (or coerce-able string)</p>
</td></tr>
<tr><td><code id="neon_read_+3A_release">release</code></td>
<td>
<p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_files">files</code></td>
<td>
<p>optionally, specify a vector of file paths directly (e.g. as
provided from <a href="#topic+neon_index">neon_index</a>) and specify <code>table</code> argument as NULL.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_sensor_metadata">sensor_metadata</code></td>
<td>
<p>logical, default TRUE. Should we add
metadata fields from file names of sensor data into the table?  Adds
DomainID, SiteID, horizontalPosition, verticalPosition, and publicationDate.
Results in slower parsing.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_keep_filename">keep_filename</code></td>
<td>
<p>Should we include a column indicating the original
file name for each row?  Can be a useful source of additional metadata that
NEON may omit from the raw files (i.e. <code>siteID</code>), but will also result in
slower parsing.  Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_altrep">altrep</code></td>
<td>
<p>enable or disable altrep.  Logical, default <code>FALSE</code>. Setting to
<code>TRUE</code> can speed up reading, but may cause <a href="vroom.html#topic+vroom">vroom::vroom</a> to throw
<code style="white-space: pre;">&#8288;mapping error: Too many open files&#8288;</code>.</p>
</td></tr>
<tr><td><code id="neon_read_+3A_...">...</code></td>
<td>
<p>additional arguments to <a href="vroom.html#topic+vroom">vroom::vroom</a>, can usually be omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NEON's tabular data files are separated out into separate .csv
files for each site for each month of sampling.  In principle,
each file has identical columns.  <a href="vroom.html#topic+vroom">vroom::vroom</a> can read in a
data table that has been sharded into many files like this much
much faster than other parsers can read in each table iteratively,
(and thus can greatly out-perform the 'stacking&quot; methods in <code>neonUtilities</code>).
</p>
<p>When reading in very large numbers of files, it may be helpful to set
<code>altrep = FALSE</code> to opt out of <code>vroom</code>'s fast altrep mechanism, which
can cause <code><a href="#topic+neon_read">neon_read()</a></code> to fail when stacking thousands of files.
</p>
<p>Unfortunately, not all datasets are entirely consistent in their use
of columns.  <code>neon_read</code> works around this by parsing such tables in
groups of matching schema, which is still reasonably fast.
</p>
<p>NEON sensor data products currently do not include important metadata columns
containing DomainID, SiteID, horizontalPosition, verticalPosition, and
publicationDate in the data files themselves, but only encode this in the
in the raw file names. All though these values are shared across a raw
data file, this information is lost when stacking the tables unless explicit
columns are added to the data.  This requires us to parse the files
one-by-one, which is much slower.  By default this information is added to
the table, altering the stacked table schema from that of the raw table.
Disable this behavior by setting <code>sensor_metadata = FALSE</code>.  Future
NEON sensor data products may start including this information in
the raw data files, as is already the case for observational data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

neon_read("brd_countdata-expanded")

## Sensor inputs will add metadata columns by default
neon_read("waq_instantaneous", site = c("CRAM","SUGG"))


</code></pre>

<hr>
<h2 id='neon_remote'>neon_remote
select a table from the remote connection</h2><span id='topic+neon_remote'></span>

<h3>Description</h3>

<p>neon_remote
</p>
<p>select a table from the remote connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_remote(table = "", product = "", type = "", db = neon_remote_db())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_remote_+3A_table">table</code></td>
<td>
<p>table name (pattern match regex)</p>
</td></tr>
<tr><td><code id="neon_remote_+3A_product">product</code></td>
<td>
<p>product code</p>
</td></tr>
<tr><td><code id="neon_remote_+3A_type">type</code></td>
<td>
<p>basic or extended (if necessary to distinguish)</p>
</td></tr>
<tr><td><code id="neon_remote_+3A_db">db</code></td>
<td>
<p>a <a href="#topic+neon_remote_db">neon_remote_db</a> connection.  If not provided, one will be created,
but it is faster to pass this on for re-use in multiple <code>neon_remote</code> calls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a arrow::FileSystemDataset object, or a named list of such
objects if multiple matches are found.  This table is not downloaded
but remains on the remote storage location, but can be filtered
with dplyr functions like filter and select, and can also be
grouped and summarised, all without ever downloading the whole table.
Use <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code> to download the (possibly filtered) table into
and pull into memory.
</p>

<hr>
<h2 id='neon_remote_db'>Establish a remote database connection using <code>arrow</code></h2><span id='topic+neon_remote_db'></span>

<h3>Description</h3>

<p>Establish a remote database connection using <code>arrow</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_remote_db(
  bucket = arrow::s3_bucket("neon4cast-targets/neon", endpoint_override =
    "data.ecoforecast.org")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_remote_db_+3A_bucket">bucket</code></td>
<td>
<p>an <code style="white-space: pre;">&#8288;[arrow::s3_bucket]&#8288;</code> connection or other
<a href="arrow.html#topic+FileSystem">arrow::SubTreeFileSystem</a> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

db &lt;- neon_remote_db()

</code></pre>

<hr>
<h2 id='neon_sites'>Table of all NEON sites</h2><span id='topic+neon_sites'></span>

<h3>Description</h3>

<p>Returns a table of all NEON sites by making a single API call
to the <code style="white-space: pre;">&#8288;/sites&#8288;</code> endpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_sites(
  api = "https://data.neonscience.org/api/v0",
  .token = Sys.getenv("NEON_TOKEN")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_sites_+3A_api">api</code></td>
<td>
<p>the URL to the NEON API, leave as default.</p>
</td></tr>
<tr><td><code id="neon_sites_+3A_.token">.token</code></td>
<td>
<p>an authentication token from NEON. A token is not
required but will allow access to a higher number of requests before
rate limiting applies, see
<a href="https://data.neonscience.org/data-api/rate-limiting/#api-tokens">https://data.neonscience.org/data-api/rate-limiting/#api-tokens</a>.
Note that once files are downloaded once, <code>neonstore</code> provides persistent
access to them without further interaction required with the API.</p>
</td></tr>
</table>

<hr>
<h2 id='neon_store'>import neon data into a local database</h2><span id='topic+neon_store'></span>

<h3>Description</h3>

<p>import neon data into a local database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_store(
  table = NA,
  product = NA,
  type = NA,
  dir = neon_dir(),
  db = neon_db(neon_db_dir(), read_only = FALSE),
  n = 500L,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_store_+3A_table">table</code></td>
<td>
<p>Include only files matching this table name (or regex pattern).
(optional).</p>
</td></tr>
<tr><td><code id="neon_store_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_store_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="neon_store_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
<tr><td><code id="neon_store_+3A_db">db</code></td>
<td>
<p>A connection to a write-able relational database backend,
see <code><a href="#topic+neon_db">neon_db()</a></code>.</p>
</td></tr>
<tr><td><code id="neon_store_+3A_n">n</code></td>
<td>
<p>number of files that should be read per iteration</p>
</td></tr>
<tr><td><code id="neon_store_+3A_quiet">quiet</code></td>
<td>
<p>show progress?</p>
</td></tr>
<tr><td><code id="neon_store_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+neon_read">neon_read</a></code>
</p>

<dl>
<dt><code>sensor_metadata</code></dt><dd><p>logical, default TRUE. Should we add
metadata fields from file names of sensor data into the table?  Adds
DomainID, SiteID, horizontalPosition, verticalPosition, and publicationDate.
Results in slower parsing.</p>
</dd>
<dt><code>keep_filename</code></dt><dd><p>Should we include a column indicating the original
file name for each row?  Can be a useful source of additional metadata that
NEON may omit from the raw files (i.e. <code>siteID</code>), but will also result in
slower parsing.  Default <code>FALSE</code>.</p>
</dd>
<dt><code>altrep</code></dt><dd><p>enable or disable altrep.  Logical, default <code>FALSE</code>. Setting to
<code>TRUE</code> can speed up reading, but may cause <a href="vroom.html#topic+vroom">vroom::vroom</a> to throw
<code style="white-space: pre;">&#8288;mapping error: Too many open files&#8288;</code>.</p>
</dd>
<dt><code>files</code></dt><dd><p>optionally, specify a vector of file paths directly (e.g. as
provided from <a href="#topic+neon_index">neon_index</a>) and specify <code>table</code> argument as NULL.</p>
</dd>
<dt><code>ext</code></dt><dd><p>only match files with this file extension(s)</p>
</dd>
<dt><code>timestamp</code></dt><dd><p>only match timestamps prior this. See details in <code><a href="#topic+neon_index">neon_index()</a></code>.
Should be a datetime POSIXct object (or coerce-able string)</p>
</dd>
<dt><code>start_date</code></dt><dd><p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</dd>
<dt><code>end_date</code></dt><dd><p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</dd>
<dt><code>site</code></dt><dd><p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</dd>
<dt><code>release</code></dt><dd><p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>the index of files read in (invisibly)
</p>

<hr>
<h2 id='neon_sync_db'>sync local parquet export to an S3 database</h2><span id='topic+neon_sync_db'></span>

<h3>Description</h3>

<p>sync local parquet export to an S3 database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_sync_db(s3, dir = file.path(neon_dir(), "parquet"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_sync_db_+3A_s3">s3</code></td>
<td>
<p>an <code style="white-space: pre;">&#8288;[arrow::SubTreeFileSystem]&#8288;</code>, such as a remote connection to
an S3 bucket from <code style="white-space: pre;">&#8288;[arrow::s3_bucket()]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="neon_sync_db_+3A_dir">dir</code></td>
<td>
<p>directory to which parquet export is written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remote files are named according to the table name (including
product id, not according to the 'sanitized' file name duckdb uses
when generating exports.)
</p>

<hr>
<h2 id='neon_table'>Return a neon table from the database</h2><span id='topic+neon_table'></span>

<h3>Description</h3>

<p>Return a neon table from the database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neon_table(
  table,
  product = NA,
  type = NA,
  site = NA,
  db = neon_db(),
  lazy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neon_table_+3A_table">table</code></td>
<td>
<p>the name of a downloaded NEON table in the store,
see <a href="#topic+neon_index">neon_index</a></p>
</td></tr>
<tr><td><code id="neon_table_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="neon_table_+3A_type">type</code></td>
<td>
<p>filter for basic or expanded. Can be omitted unless you have
imported both types a given table into your database.</p>
</td></tr>
<tr><td><code id="neon_table_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="neon_table_+3A_db">db</code></td>
<td>
<p>a connection to the database, see <code style="white-space: pre;">&#8288;[neon_db()]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="neon_table_+3A_lazy">lazy</code></td>
<td>
<p>logical, default FALSE. Should we return a remote dplyr
connection to the table in duckdb? This can substantially improve
performance and avoid out-of-memory errors when working with very large
tables. However, not all R operations can be performed on a remote table,
only (most) functions from <code>dplyr</code> and <code>tidyr</code>, as these can be
translated automatically to SQL language used by the remote database.
Use <code>dplyr</code> functions like <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>, <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, and
<code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> to subset
the data appropriately within the remote table before calling
<code style="white-space: pre;">&#8288;[dplyr::collect()]&#8288;</code> to import the data fully into R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We cannot filter on start_date or end_date since these
come only from the filename metadata and are only added
to instrument tables, not observation tables etc.
</p>

<hr>
<h2 id='show_deprecated_data'>show deprecated data</h2><span id='topic+show_deprecated_data'></span>

<h3>Description</h3>

<p>Show the file information for any raw data files which have been deprecated by
the release of modified historical data to the NEON API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_deprecated_data(
  product = NA,
  table = NA,
  site = NA,
  start_date = NA,
  end_date = NA,
  type = NA,
  ext = NA,
  timestamp = NA,
  release = NA,
  dir = neon_dir()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_deprecated_data_+3A_product">product</code></td>
<td>
<p>A NEON <code>productCode</code> or list of product codes, see examples.</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_table">table</code></td>
<td>
<p>Include only files matching this table name (or regex pattern).
(optional).</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_site">site</code></td>
<td>
<p>4-letter site code(s) to filter on. Leave as <code>NA</code> to search all.</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_start_date">start_date</code></td>
<td>
<p>Download only files as recent as (<code>YYYY-MM-DD</code>). Leave
as <code>NA</code> to download up to the most recent available data.</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_end_date">end_date</code></td>
<td>
<p>Download only files up to end_date (<code>YYYY-MM-DD</code>). Leave as
<code>NA</code> to download all prior data.</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_type">type</code></td>
<td>
<p>Should we prefer the basic or expanded version of this product?
Note that not all products have expanded formats.</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_ext">ext</code></td>
<td>
<p>only match files with this file extension(s)</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_timestamp">timestamp</code></td>
<td>
<p>only match timestamps prior this. See details in <code><a href="#topic+neon_index">neon_index()</a></code>.
Should be a datetime POSIXct object (or coerce-able string)</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_release">release</code></td>
<td>
<p>Select only data files associated with a particular release tag,
see <a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases">https://www.neonscience.org/data-samples/data-management/data-revisions-releases</a>,
e.g. &quot;RELEASE-2021&quot;.  Releases are associated with a specific DOI and the promise that
files associated with a particular release will not change.</p>
</td></tr>
<tr><td><code id="show_deprecated_data_+3A_dir">dir</code></td>
<td>
<p>Location where files should be downloaded. By default will
use the appropriate applications directory for your system
(see <code><a href="tools.html#topic+userdir">tools::R_user_dir()</a></code>).  This default also be configured by
setting the environmental variable <code>NEONSTORE_HOME</code>, see <a href="base.html#topic+Sys.setenv">Sys.setenv</a> or
<a href="base.html#topic+Renviron">Renviron</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NEON data files are sometimes updated to correct errors.  Old files are
removed from access from the API, but may be present in your local store
from an earlier download.  <code>neonstore</code> stacking functions (<code style="white-space: pre;">&#8288;[neon_read()]&#8288;</code>
and <code>neon_store()</code>) automatically exclude these deprecated files, though
<code>neon_read()</code> can be instructed to use older files by passing a file list.
</p>
<p>A data file is identified as deprecated whenever the local file store contains
a second data file with the same product, table, site, month, and position
(sensor products only) information, but having an updated timestamp.  If such
a change occurs in a file with a non-missing &quot;month&quot; code, it may indicate a
data file has been updated.  This could result in changes to the results of
any previous analyses.
</p>
<p>Note that metadata files, (readme, variables, positions) are 'pre-stacked':
the metadata file in a given product-site-month set contains metadata going back
to the start and not just for that month.  As a result, each new version deprecates
the old metadata file, but the old files are always available from the NEON API
and always present in the store.  Users will only need to care about the most recent
ones, and the presence of old files is no cause for concern. This function will
only show data files that have changed, and not metadata files.  This can
help pinpoint specific altered data.
</p>


<h3>See Also</h3>

<p>neon_index, neon_read
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
show_deprecated_data()




</code></pre>

<hr>
<h2 id='standardize_export_names'>standardize export names</h2><span id='topic+standardize_export_names'></span>

<h3>Description</h3>

<p>standardize export names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_export_names(dir = file.path(neon_dir(), "parquet"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardize_export_names_+3A_dir">dir</code></td>
<td>
<p>directory to which parquet export is written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DUCKDB clobbers database filenames to avoid potentially incompatible characters.
This is pretty unnecessary, so we can restore the original table names for
use with S3-based remote access which assumes parquet files map to the
desired table names (i.e. including product numbers.)
</p>
<p>However, note that <code style="white-space: pre;">&#8288;[neon_import_db()]&#8288;</code> uses native duckdb functions
that assume the original mangled names.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
