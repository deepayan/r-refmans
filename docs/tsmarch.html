<!DOCTYPE html><html lang="en"><head><title>Help for package tsmarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsmarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsmarch-package'><p>tsmarch: Multivariate ARCH Models</p></a></li>
<li><a href='#bread.cgarch.estimate'><p>Bread Method</p></a></li>
<li><a href='#cgarch_modelspec'><p>Generic Methods for the Copula GARCH model specification</p></a></li>
<li><a href='#cgarch_modelspec.tsgarch.multi_estimate'><p>Copula GARCH model specification</p></a></li>
<li><a href='#coef.cgarch.estimate'><p>Extract Model Coefficients</p></a></li>
<li><a href='#combn_fast'><p>Fast combination of n elements, taken m at a time</p></a></li>
<li><a href='#dcc_modelspec'><p>Generic Methods for the DCC GARCH model specification</p></a></li>
<li><a href='#dcc_modelspec.tsgarch.multi_estimate'><p>DCC GARCH model specification</p></a></li>
<li><a href='#dfft'><p>FFT density, distribution and quantile method</p></a></li>
<li><a href='#dji30retw'><p>Dow Jones 30 Constituents Closing Value log Weekly Return</p></a></li>
<li><a href='#estfun.cgarch.estimate'><p>Score Method</p></a></li>
<li><a href='#estimate.cgarch.spec'><p>Estimates a model given a specification.</p></a></li>
<li><a href='#expected_shortfall'><p>Expected Shortfall (ES) method for predicted and simulated objects</p></a></li>
<li><a href='#fitted.cgarch.estimate'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#globalindices'><p>Global Financial Indices Closing Value log Weekly Return</p></a></li>
<li><a href='#gogarch_modelspec'><p>GOGARCH Model specification</p></a></li>
<li><a href='#logLik.cgarch.estimate'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#newsimpact.cgarch.estimate'><p>News Impact Surface</p></a></li>
<li><a href='#pit.gogarch.fft'><p>Probability Integral Transform (PIT) for weighted FFT densities</p></a></li>
<li><a href='#plot.dcc.estimate'><p>Dynamic Correlation Model Plots</p></a></li>
<li><a href='#plot.tsmarch.newsimpact'><p>News Impact Surface Plot</p></a></li>
<li><a href='#predict.cgarch.estimate'><p>Model Prediction</p></a></li>
<li><a href='#print.summary.cgarch.estimate'><p>Model Estimation Summary Print method</p></a></li>
<li><a href='#radical'><p>The Robust Accurate, Direct ICA ALgorithm (RADICAL)</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.cgarch.estimate'><p>Extract Model Residuals</p></a></li>
<li><a href='#simulate.cgarch.estimate'><p>Model Simulation</p></a></li>
<li><a href='#summary.cgarch.estimate'><p>Model Estimation Summary</p></a></li>
<li><a href='#tsaggregate.cgarch.estimate'><p>Weighted Moments Aggregation</p></a></li>
<li><a href='#tscokurt.gogarch.estimate'><p>Cokurtosis Extractor</p></a></li>
<li><a href='#tsconvolve.gogarch.estimate'><p>Convolution</p></a></li>
<li><a href='#tscor.cgarch.estimate'><p>Correlation Extractor</p></a></li>
<li><a href='#tscoskew.gogarch.estimate'><p>Coskewness Extractor</p></a></li>
<li><a href='#tscov.cgarch.estimate'><p>Covariance Extractor</p></a></li>
<li><a href='#tsfilter.cgarch.estimate'><p>Model Filtering</p></a></li>
<li><a href='#value_at_risk'><p>Value at Risk (VaR) method for predicted and simulated objects</p></a></li>
<li><a href='#vcov.cgarch.estimate'><p>The Covariance Matrix of the Estimated Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate ARCH Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Feasible Multivariate Generalized Autoregressive Conditional Heteroscedasticity (GARCH) models including Dynamic Conditional Correlation (DCC), Copula GARCH and Generalized Orthogonal GARCH with Generalized Hyperbolic distribution. A review of some of these models can be found in Boudt, Galanos, Payseur and Zivot (2019) &lt;<a href="https://doi.org/10.1016%2Fbs.host.2019.01.001">doi:10.1016/bs.host.2019.01.001</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexios Galanos &lt;alexios@4dscape.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods, tsmethods (&ge; 1.0.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.10.6), RcppArmadillo, RcppParallel, RcppBessel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RcppParallel, tsgarch (&ge; 1.0.3), tsdistributions (&ge;
1.0.2), RcppBessel, Rsolnp, nloptr, numDeriv, abind, shape,
Rdpack, xts, zoo, lubridate, sandwich, future.apply, future,
stats, utils, data.table</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tsmodels/tsmarch/issues">https://github.com/tsmodels/tsmarch/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tsmodels/tsmarch">https://github.com/tsmodels/tsmarch</a>, <a href="https://www.nopredict.com">https://www.nopredict.com</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), tstests</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-15 10:33:37 UTC; alexios</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexios Galanos <a href="https://orcid.org/0009-0000-9308-0457"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-18 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tsmarch-package'>tsmarch: Multivariate ARCH Models</h2><span id='topic+tsmarch'></span><span id='topic+tsmarch-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Feasible Multivariate Generalized Autoregressive Conditional Heteroscedasticity (GARCH) models including Dynamic Conditional Correlation (DCC), Copula GARCH and Generalized Orthogonal GARCH with Generalized Hyperbolic distribution. A review of some of these models can be found in Boudt, Galanos, Payseur and Zivot (2019) <a href="https://doi.org/10.1016/bs.host.2019.01.001">doi:10.1016/bs.host.2019.01.001</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexios Galanos <a href="mailto:alexios@4dscape.com">alexios@4dscape.com</a> (<a href="https://orcid.org/0009-0000-9308-0457">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tsmodels/tsmarch">https://github.com/tsmodels/tsmarch</a>
</p>
</li>
<li> <p><a href="https://www.nopredict.com">https://www.nopredict.com</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tsmodels/tsmarch/issues">https://github.com/tsmodels/tsmarch/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bread.cgarch.estimate'>Bread Method</h2><span id='topic+bread.cgarch.estimate'></span><span id='topic+bread.dcc.estimate'></span>

<h3>Description</h3>

<p>Bread Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
bread(x, ...)

## S3 method for class 'dcc.estimate'
bread(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bread.cgarch.estimate_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="bread.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse of the numerical hessian of the model.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='cgarch_modelspec'>Generic Methods for the Copula GARCH model specification</h2><span id='topic+cgarch_modelspec'></span>

<h3>Description</h3>

<p>Generic Methods for the Copula GARCH model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgarch_modelspec(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgarch_modelspec_+3A_object">object</code></td>
<td>
<p>a valid object.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec_+3A_...">...</code></td>
<td>
<p>additional parameters specific to the method implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of some class.
</p>

<hr>
<h2 id='cgarch_modelspec.tsgarch.multi_estimate'>Copula GARCH model specification</h2><span id='topic+cgarch_modelspec.tsgarch.multi_estimate'></span>

<h3>Description</h3>

<p>Copula GARCH model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsgarch.multi_estimate'
cgarch_modelspec(
  object,
  dynamics = c("constant", "dcc", "adcc"),
  dcc_order = c(1, 1),
  transformation = c("parametric", "empirical", "spd"),
  copula = c("mvn", "mvt"),
  constant_correlation = c("pearson", "kendall", "spearman"),
  cond_mean = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;tsgarch.multi_estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_dynamics">dynamics</code></td>
<td>
<p>the type of correlation dynamics to use.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_dcc_order">dcc_order</code></td>
<td>
<p>the order of the dynamics in case of &ldquo;dcc&rdquo; or &ldquo;adcc&rdquo;
correlation models.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_transformation">transformation</code></td>
<td>
<p>the copula transformation to apply.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_copula">copula</code></td>
<td>
<p>the copula distribution.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_constant_correlation">constant_correlation</code></td>
<td>
<p>the constant correlation estimator to use. In the
case of the &ldquo;mvt&rdquo; copula, only Kendall's tau is a valid choice.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_cond_mean">cond_mean</code></td>
<td>
<p>an optional matrix of the conditional mean for the series.</p>
</td></tr>
<tr><td><code id="cgarch_modelspec.tsgarch.multi_estimate_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code><a href="tsdistributions.html#topic+spd_modelspec">spd_modelspec</a></code>
function in the case of the &ldquo;spd&rdquo; transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &ldquo;cgarch.spec&rdquo;.
</p>

<hr>
<h2 id='coef.cgarch.estimate'>Extract Model Coefficients</h2><span id='topic+coef.cgarch.estimate'></span><span id='topic+coef'></span><span id='topic+coef.dcc.estimate'></span><span id='topic+coef.gogarch.estimate'></span>

<h3>Description</h3>

<p>Extract the estimated coefficients of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
coef(object, ...)

## S3 method for class 'dcc.estimate'
coef(object, ...)

## S3 method for class 'gogarch.estimate'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an estimated object from one of the models in the package.</p>
</td></tr>
<tr><td><code id="coef.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>none</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric named vector of estimated coefficients.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='combn_fast'>Fast combination of n elements, taken m at a time</h2><span id='topic+combn_fast'></span>

<h3>Description</h3>

<p>Fast combination of n elements, taken m at a time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combn_fast(x, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combn_fast_+3A_x">x</code></td>
<td>
<p>integer vector source for combinations</p>
</td></tr>
<tr><td><code id="combn_fast_+3A_m">m</code></td>
<td>
<p>number of elements to choose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a significantly faster version of <code><a href="utils.html#topic+combn">combn</a></code>. For
an integer vector x of length 1000 and m of 3 which results in a matrix of size
3 x 166,167,000, the speed improvement is about 9 times (11 secs vs 99 secs).
This code is written using Armadillo C++ and 64 bit unsingned integers.
</p>


<h3>Value</h3>

<p>a matrix with m rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.equal(combn(1:10, 3), combn_fast(1:10,3))
</code></pre>

<hr>
<h2 id='dcc_modelspec'>Generic Methods for the DCC GARCH model specification</h2><span id='topic+dcc_modelspec'></span>

<h3>Description</h3>

<p>Generic Methods for the DCC GARCH model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcc_modelspec(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcc_modelspec_+3A_object">object</code></td>
<td>
<p>a valid object.</p>
</td></tr>
<tr><td><code id="dcc_modelspec_+3A_...">...</code></td>
<td>
<p>additional parameters specific to the method implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of some class.
</p>

<hr>
<h2 id='dcc_modelspec.tsgarch.multi_estimate'>DCC GARCH model specification</h2><span id='topic+dcc_modelspec.tsgarch.multi_estimate'></span>

<h3>Description</h3>

<p>DCC GARCH model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsgarch.multi_estimate'
dcc_modelspec(
  object,
  dynamics = c("constant", "dcc", "adcc"),
  dcc_order = c(1, 1),
  distribution = c("mvn", "mvt"),
  cond_mean = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcc_modelspec.tsgarch.multi_estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;tsgarch.multi_estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="dcc_modelspec.tsgarch.multi_estimate_+3A_dynamics">dynamics</code></td>
<td>
<p>the type of correlation dynamics to use.</p>
</td></tr>
<tr><td><code id="dcc_modelspec.tsgarch.multi_estimate_+3A_dcc_order">dcc_order</code></td>
<td>
<p>the order of the dynamics in case of &ldquo;dcc&rdquo; or &ldquo;adcc&rdquo;
correlation models.</p>
</td></tr>
<tr><td><code id="dcc_modelspec.tsgarch.multi_estimate_+3A_distribution">distribution</code></td>
<td>
<p>the multivariate distribution. If using the &ldquo;mvt&rdquo;,
then the first stage univariate models should use the normal distribution.</p>
</td></tr>
<tr><td><code id="dcc_modelspec.tsgarch.multi_estimate_+3A_cond_mean">cond_mean</code></td>
<td>
<p>an optional matrix of the conditional mean for the series.</p>
</td></tr>
<tr><td><code id="dcc_modelspec.tsgarch.multi_estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &ldquo;dcc.spec&rdquo;.
</p>

<hr>
<h2 id='dfft'>FFT density, distribution and quantile method</h2><span id='topic+dfft'></span><span id='topic+pfft'></span><span id='topic+qfft'></span><span id='topic+dfft.gogarch.fft'></span><span id='topic+pfft.gogarch.fft'></span><span id='topic+qfft.gogarch.fft'></span><span id='topic+dfft.gogarch.fftsim'></span><span id='topic+pfft.gogarch.fftsim'></span><span id='topic+qfft.gogarch.fftsim'></span>

<h3>Description</h3>

<p>FFT density, distribution and quantile method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfft(object, ...)

pfft(object, ...)

qfft(object, ...)

## S3 method for class 'gogarch.fft'
dfft(object, index = 1, ...)

## S3 method for class 'gogarch.fft'
pfft(object, index = 1, ...)

## S3 method for class 'gogarch.fft'
qfft(object, index = 1, ...)

## S3 method for class 'gogarch.fftsim'
dfft(object, index = 1, sim = 1, ...)

## S3 method for class 'gogarch.fftsim'
pfft(object, index = 1, sim = 1, ...)

## S3 method for class 'gogarch.fftsim'
qfft(object, index = 1, sim = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfft_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;gogarch.fft&rdquo; formed by calling
the <code><a href="#topic+tsconvolve">tsconvolve</a></code> method.</p>
</td></tr>
<tr><td><code id="dfft_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the method.</p>
</td></tr>
<tr><td><code id="dfft_+3A_index">index</code></td>
<td>
<p>the time index on which to generate the function.</p>
</td></tr>
<tr><td><code id="dfft_+3A_sim">sim</code></td>
<td>
<p>the simulation draw on which to generate the function (for the
predict and simulate objects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods generate smooth approximation to the distribution
functions, returning in turn a function object which can be further called
with additional arguments expected from the density, distribution and quantile
functions. Random number generation can be achieved through the use of uniform
random variates and the quantile function (inverse CDF method).
</p>


<h3>Value</h3>

<p>an function object which can then be called to calculate the density
distribution or quantile for a particular instance (or time point),
</p>

<hr>
<h2 id='dji30retw'>Dow Jones 30 Constituents Closing Value log Weekly Return</h2><span id='topic+dji30retw'></span>

<h3>Description</h3>

<p>Dow Jones 30 Constituents closing value weekly (Friday) log returns
from 1987-03-16 to 2009-02-03 from Yahoo Finance. Note that AIG was
replaced by KFT (Kraft Foods) on September 22, 2008. This is not reflected
in this data set as that would bring the starting date of the data to 2001.
When data was not available for a Friday, the closest previous close for
which data was available was used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dji30retw
</code></pre>


<h3>Format</h3>



<h4><code>dji30retw</code></h4>

<p>A data frame with 1131 rows and 30 columns, with row names being the
YYYY-mm-dd date.
</p>



<h3>Source</h3>

<p>Yahoo Finance
</p>

<hr>
<h2 id='estfun.cgarch.estimate'>Score Method</h2><span id='topic+estfun.cgarch.estimate'></span><span id='topic+estfun.dcc.estimate'></span>

<h3>Description</h3>

<p>Score Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
estfun(x, ...)

## S3 method for class 'dcc.estimate'
estfun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estfun.cgarch.estimate_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="estfun.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the numerical scores of the negative of the
log likelihood at the optimal solution. These are used in the calculation
of sandwich estimators.
</p>


<h3>Value</h3>

<p>The score matrix
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='estimate.cgarch.spec'>Estimates a model given a specification.</h2><span id='topic+estimate.cgarch.spec'></span><span id='topic+estimate'></span><span id='topic+estimate.dcc.spec'></span><span id='topic+estimate.gogarch.spec'></span>

<h3>Description</h3>

<p>Method for estimating one of the models in the package given a specification object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.spec'
estimate(
  object,
  solver = "solnp",
  control = list(trace = 0),
  return_hessian = TRUE,
  ...
)

## S3 method for class 'dcc.spec'
estimate(
  object,
  solver = "solnp",
  control = list(trace = 0),
  return_hessian = TRUE,
  ...
)

## S3 method for class 'gogarch.spec'
estimate(object, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.cgarch.spec_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;cgarch.spec&rdquo;, &ldquo;dcc.spec&rdquo; or
&ldquo;gogarch.spec&rdquo;.</p>
</td></tr>
<tr><td><code id="estimate.cgarch.spec_+3A_solver">solver</code></td>
<td>
<p>the solver to use for the second stage estimation of the multivariate
dynamics. Valid choices are <code><a href="Rsolnp.html#topic+solnp">solnp</a></code>, <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>
and <code><a href="stats.html#topic+optim">optim</a></code>, with the latter using the &ldquo;L-BFGS-B&rdquo; method.
This option is inactive for the GOGARCH model which uses the default solver in
package &ldquo;tsgarch&rdquo; for the estimation of the independent factors.</p>
</td></tr>
<tr><td><code id="estimate.cgarch.spec_+3A_control">control</code></td>
<td>
<p>solver control parameters.</p>
</td></tr>
<tr><td><code id="estimate.cgarch.spec_+3A_return_hessian">return_hessian</code></td>
<td>
<p>whether to calculate and return the partitioned hessian
of the model (see details). Not applicable in the case of the GOGARCH model.</p>
</td></tr>
<tr><td><code id="estimate.cgarch.spec_+3A_...">...</code></td>
<td>
<p>for the GOGARCH model, additional options passed to the <code><a href="#topic+radical">radical</a></code>
function.</p>
</td></tr>
<tr><td><code id="estimate.cgarch.spec_+3A_trace">trace</code></td>
<td>
<p>whether to print tracing information for the GOGARCH model estimation.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>DCC and Copula Models</h4>

<p>Estimation assumes a 2-stage approach whereby the pre-estimated
GARCH models (first stage) are used to estimate the Copula or DCC dynamics. In
the case of the constant correlation Gaussian model, there are no parameters to estimate.
Whilst this 2-stage approach results in a very fast estimation, the calculation
of the standard errors based on the partitioned hessian is quite expensive. The
user can create a futures <code><a href="future.html#topic+plan">plan</a></code> to take advantage of parallel
functionality which for large dimensional problems leads to a large speedup.
Additionally, the option of not calculating the hessian (&ldquo;return_hessian&rdquo;)
is available. In that case, the scores are still calculated and the resulting
standard errors will be based on the outer product of gradients.
</p>



<h4>GOGARCH Model</h4>

<p>The independent factors are calculated by first pre-whitening the data (PCA),
selecting the number of factors, and then solving for the rotation matrix. A
GARCH model is then estimated on each factor. A minimal amount of information
is retained in the estimation object and most of the heavy lifting related to
co-moment matrices, weighted moments etc is done through dedicated methods.
The estimation method makes use of parallel processing for the independent
factor GARCH models which can be setup using <code><a href="future.html#topic+plan">plan</a></code>.
Additionally, the RADICAL algorithm benefits from part parallelization which
can be controlled using <code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code>.
</p>



<h3>Value</h3>

<p>An estimated object of one of either &ldquo;cgarch.estimate&rdquo;,
&ldquo;dcc.estimate&rdquo; or &ldquo;gogarch.estimate&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='expected_shortfall'>Expected Shortfall (ES) method for predicted and simulated objects</h2><span id='topic+expected_shortfall'></span><span id='topic+expected_shortfall.gogarch.predict'></span><span id='topic+expected_shortfall.dcc.predict'></span><span id='topic+expected_shortfall.cgarch.predict'></span><span id='topic+expected_shortfall.gogarch.simulate'></span><span id='topic+expected_shortfall.dcc.simulate'></span><span id='topic+expected_shortfall.cgarch.simulate'></span>

<h3>Description</h3>

<p>Expected Shortfall (ES) method for predicted and simulated objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected_shortfall(object, ...)

## S3 method for class 'gogarch.predict'
expected_shortfall(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'dcc.predict'
expected_shortfall(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'cgarch.predict'
expected_shortfall(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'gogarch.simulate'
expected_shortfall(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'dcc.simulate'
expected_shortfall(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'cgarch.simulate'
expected_shortfall(object, weights = NULL, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected_shortfall_+3A_object">object</code></td>
<td>
<p>an object generated from the predict or simulate methods.</p>
</td></tr>
<tr><td><code id="expected_shortfall_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="expected_shortfall_+3A_weights">weights</code></td>
<td>
<p>a vector of weights of length equal to the number of series. If
NULL then an equal weight vector is used.</p>
</td></tr>
<tr><td><code id="expected_shortfall_+3A_alpha">alpha</code></td>
<td>
<p>the quantile level for the value at risk.
for the GOGARCH model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the expected shortfall. For predict type input objects this will be an xts
matrix with index the forecast dates.
</p>

<hr>
<h2 id='fitted.cgarch.estimate'>Extract Model Fitted Values</h2><span id='topic+fitted.cgarch.estimate'></span><span id='topic+fitted'></span><span id='topic+fitted.cgarch.simulate'></span><span id='topic+fitted.cgarch.predict'></span><span id='topic+fitted.dcc.estimate'></span><span id='topic+fitted.dcc.simulate'></span><span id='topic+fitted.dcc.predict'></span><span id='topic+fitted.gogarch.estimate'></span><span id='topic+fitted.gogarch.predict'></span><span id='topic+fitted.gogarch.simulate'></span>

<h3>Description</h3>

<p>Extract the fitted values from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
fitted(object, ...)

## S3 method for class 'cgarch.simulate'
fitted(object, ...)

## S3 method for class 'cgarch.predict'
fitted(object, ...)

## S3 method for class 'dcc.estimate'
fitted(object, ...)

## S3 method for class 'dcc.simulate'
fitted(object, ...)

## S3 method for class 'dcc.predict'
fitted(object, ...)

## S3 method for class 'gogarch.estimate'
fitted(object, ...)

## S3 method for class 'gogarch.predict'
fitted(object, ...)

## S3 method for class 'gogarch.simulate'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object from one of the estimated, simulated or predicted
model classes in the package.</p>
</td></tr>
<tr><td><code id="fitted.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For an estimated object an &ldquo;xts&rdquo; matrix of the fitted values (either
zero or a constant), else for simulated or predicted objects a horizon x n_series x n_draws
array of the distributional values. The array output includes attributes such as the
date index (for the predicted object), horizon, n_draws and series names.
</p>

<hr>
<h2 id='globalindices'>Global Financial Indices Closing Value log Weekly Return</h2><span id='topic+globalindices'></span>

<h3>Description</h3>

<p>A selection of the log weekly returns (Friday) of 34 global financial indices
from Yahoo Finance starting on 1991-12-13 and ending on 2024-06-21.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalindices
</code></pre>


<h3>Format</h3>



<h4><code>globalindices</code></h4>

<p>A data frame with 1698 rows and 34 columns, with row names being the
YYYY-mm-dd date.
</p>



<h3>Source</h3>

<p>Yahoo Finance
</p>

<hr>
<h2 id='gogarch_modelspec'>GOGARCH Model specification</h2><span id='topic+gogarch_modelspec'></span>

<h3>Description</h3>

<p>GOGARCH Model specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarch_modelspec(
  y,
  distribution = c("norm", "nig", "gh"),
  model = "garch",
  order = c(1, 1),
  ica = "radical",
  components = NCOL(y),
  lambda_range = c(-5, 5),
  shape_range = c(0.1, 25),
  cond_mean = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarch_modelspec_+3A_y">y</code></td>
<td>
<p>an xts matrix of pre-filtered (residuals) stationary data.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_distribution">distribution</code></td>
<td>
<p>a choice for the component distributions. Valid choices are
normal, normal inverse gaussian or generalized hyperbolic distribution.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_model">model</code></td>
<td>
<p>the GARCH model to use for each factor.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_order">order</code></td>
<td>
<p>the GARCH model order.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_ica">ica</code></td>
<td>
<p>the Independent Component Analysis algorithm. Current only the
RADICAL algorithm is available.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_components">components</code></td>
<td>
<p>the number of components to extract in the pre-whitening
phase,</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_lambda_range">lambda_range</code></td>
<td>
<p>for the generalized hyperbolic distribution, the range of
the lambda parameter.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_shape_range">shape_range</code></td>
<td>
<p>for the generalized hyperbolic distribution, the range of
the shape parameter (zeta).</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_cond_mean">cond_mean</code></td>
<td>
<p>an optional matrix of the conditional mean for the series.</p>
</td></tr>
<tr><td><code id="gogarch_modelspec_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code><a href="#topic+radical">radical</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &ldquo;gogarch.spec&rdquo;.
</p>

<hr>
<h2 id='logLik.cgarch.estimate'>Extract Log-Likelihood</h2><span id='topic+logLik.cgarch.estimate'></span><span id='topic+logLik'></span><span id='topic+logLik.dcc.estimate'></span><span id='topic+logLik.gogarch.estimate'></span>

<h3>Description</h3>

<p>Extract the log likelihood of the model at the estimated optimal parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
logLik(object, ...)

## S3 method for class 'dcc.estimate'
logLik(object, ...)

## S3 method for class 'gogarch.estimate'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an estimated object from one of the models in the package.</p>
</td></tr>
<tr><td><code id="logLik.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all models in the package, the log-likelihood is a combination of the univariate
log-likelihood and the multivariate log-likelihood. For the GOGARCH model, being an
independent factor model, this is the sum of the univariate GARCH log-likelihoods
plus a term for the mixing matrix. The number of parameters in the GOGARCH model
reported (&ldquo;df&rdquo;) represents the univariate independent factor parameters
plus the number of parameters in the rotation matrix U of the ICA algorithm.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;logLik&rdquo; with attributes for “nobs” and &ldquo;df&rdquo;.
The latter is equal to the number of estimated parameters, whilst the former is the
number of timesteps (i.e. the number of observations per series).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='newsimpact.cgarch.estimate'>News Impact Surface</h2><span id='topic+newsimpact.cgarch.estimate'></span><span id='topic+newsimpact.dcc.estimate'></span><span id='topic+newsimpact.gogarch.estimate'></span>

<h3>Description</h3>

<p>News impact surface of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
newsimpact(object, epsilon = NULL, pair = c(1, 2), type = "correlation", ...)

## S3 method for class 'dcc.estimate'
newsimpact(object, epsilon = NULL, pair = c(1, 2), type = "correlation", ...)

## S3 method for class 'gogarch.estimate'
newsimpact(
  object,
  epsilon = NULL,
  pair = c(1, 2),
  factor = c(1, 1),
  type = "correlation",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newsimpact.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of one of the estimated model classes in the package.</p>
</td></tr>
<tr><td><code id="newsimpact.cgarch.estimate_+3A_epsilon">epsilon</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="newsimpact.cgarch.estimate_+3A_pair">pair</code></td>
<td>
<p>the pair of series for which to generate the news impact surface.</p>
</td></tr>
<tr><td><code id="newsimpact.cgarch.estimate_+3A_type">type</code></td>
<td>
<p>either &ldquo;correlation&rdquo; or &ldquo;covariance&rdquo;.</p>
</td></tr>
<tr><td><code id="newsimpact.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the method.</p>
</td></tr>
<tr><td><code id="newsimpact.cgarch.estimate_+3A_factor">factor</code></td>
<td>
<p>the pair of factors for which to generate the news impact surface for the GOGARCH model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;tsmarch.newsimpact&rdquo; which has a plot method.
</p>

<hr>
<h2 id='pit.gogarch.fft'>Probability Integral Transform (PIT) for weighted FFT densities</h2><span id='topic+pit.gogarch.fft'></span>

<h3>Description</h3>

<p>Probability Integral Transform (PIT) for weighted FFT densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gogarch.fft'
pit(object, actual, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pit.gogarch.fft_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;gogarch.fft&rdquo; or &ldquo;gogarch.fftsim&rdquo;.</p>
</td></tr>
<tr><td><code id="pit.gogarch.fft_+3A_actual">actual</code></td>
<td>
<p>a vector of realized values representing the weighted values of the
series for the period under consideration.</p>
</td></tr>
<tr><td><code id="pit.gogarch.fft_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix.
</p>

<hr>
<h2 id='plot.dcc.estimate'>Dynamic Correlation Model Plots</h2><span id='topic+plot.dcc.estimate'></span><span id='topic+plot.cgarch.estimate'></span>

<h3>Description</h3>

<p>Dynamic Correlation Model Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dcc.estimate'
plot(
  x,
  y = NULL,
  series = NULL,
  index_format = "%Y",
  labels = FALSE,
  cex_labels = 0.8,
  ...
)

## S3 method for class 'cgarch.estimate'
plot(
  x,
  y = NULL,
  series = NULL,
  index_format = "%Y",
  labels = FALSE,
  cex_labels = 0.8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dcc.estimate_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;dcc.estimate&rdquo; or &ldquo;cgarch.estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.dcc.estimate_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="plot.dcc.estimate_+3A_series">series</code></td>
<td>
<p>for the constant correlation a vector of length 2 indicating the
series numbers to use for the pairwise correlation plot. For the dynamic
correlation model, if NULL will include all series, else a vector of integers
of the series to include.</p>
</td></tr>
<tr><td><code id="plot.dcc.estimate_+3A_index_format">index_format</code></td>
<td>
<p>for the dynamic correlation plot the x-axis label formatting.</p>
</td></tr>
<tr><td><code id="plot.dcc.estimate_+3A_labels">labels</code></td>
<td>
<p>whether to include y-axis labels. For a large number of series
it is best to leave this as FALSE.</p>
</td></tr>
<tr><td><code id="plot.dcc.estimate_+3A_cex_labels">cex_labels</code></td>
<td>
<p>the shrink factor for the y-axis labels if included.</p>
</td></tr>
<tr><td><code id="plot.dcc.estimate_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots of the correlation.
</p>

<hr>
<h2 id='plot.tsmarch.newsimpact'>News Impact Surface Plot</h2><span id='topic+plot.tsmarch.newsimpact'></span>

<h3>Description</h3>

<p>Plot method for newsimpact class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsmarch.newsimpact'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tsmarch.newsimpact_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;tsmarch.newsimpact&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.tsmarch.newsimpact_+3A_y">y</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="plot.tsmarch.newsimpact_+3A_...">...</code></td>
<td>
<p>not currently supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the newsimpact surface
</p>

<hr>
<h2 id='predict.cgarch.estimate'>Model Prediction</h2><span id='topic+predict.cgarch.estimate'></span><span id='topic+predict'></span><span id='topic+predict.dcc.estimate'></span><span id='topic+predict.gogarch.estimate'></span>

<h3>Description</h3>

<p>Prediction function for estimated objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
predict(
  object,
  h = 1,
  nsim = 1000,
  sim_method = c("parametric", "bootstrap"),
  forc_dates = NULL,
  cond_mean = NULL,
  seed = NULL,
  ...
)

## S3 method for class 'dcc.estimate'
predict(
  object,
  h = 1,
  nsim = 1000,
  sim_method = c("parametric", "bootstrap"),
  forc_dates = NULL,
  cond_mean = NULL,
  seed = NULL,
  ...
)

## S3 method for class 'gogarch.estimate'
predict(
  object,
  h = 1,
  nsim = 1000,
  sim_method = c("parametric", "bootstrap"),
  forc_dates = NULL,
  cond_mean = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an estimated object from one of the models in the package.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_h">h</code></td>
<td>
<p>the forecast horizon.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_nsim">nsim</code></td>
<td>
<p>the number of sample paths to generate.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_sim_method">sim_method</code></td>
<td>
<p>white noise method for generating random sample for the
multivariate distribution. The default &ldquo;parametric&rdquo; samples random normal
variates whilst the &ldquo;bootstrap&rdquo; samples from the whitened innovations
of the fitted model.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_forc_dates">forc_dates</code></td>
<td>
<p>an optional vector of forecast dates equal to h. If NULL will
use the implied periodicity of the data to generate a regular sequence of dates
after the last available date in the data.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_cond_mean">cond_mean</code></td>
<td>
<p>an optional matrix (h x n_series) of the predicted conditional
mean for the series which is used to recenter the simulated predictive distribution.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_seed">seed</code></td>
<td>
<p>an integer that will be used in a call to set.seed before simulating.</p>
</td></tr>
<tr><td><code id="predict.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>no additional arguments currently supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Copula GARCH model, the prediction is based on simulation due to the
nonlinear transformation present in the model.
</p>


<h3>Value</h3>

<p>A prediction class object for which methods exists for extracting
relevant statistics such as the correlation, covariance, etc.
</p>

<hr>
<h2 id='print.summary.cgarch.estimate'>Model Estimation Summary Print method</h2><span id='topic+print.summary.cgarch.estimate'></span><span id='topic+print.summary.tsmarch.estimate'></span><span id='topic+print.summary.dcc.estimate'></span><span id='topic+print.summary.gogarch.estimate'></span>

<h3>Description</h3>

<p>Print method for class &ldquo;summary.cgarch.estimate&rdquo; or
&ldquo;summary.dcc.estimate&rdquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.cgarch.estimate'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'summary.dcc.estimate'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'summary.gogarch.estimate'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.cgarch.estimate_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;summary.cgarch.estimate&rdquo; or
&ldquo;summary.dcc.estimate&rdquo;</p>
</td></tr>
<tr><td><code id="print.summary.cgarch.estimate_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting. Optionally, to avoid
scientific notation, set &lsquo;options(scipen=999)&rsquo;.</p>
</td></tr>
<tr><td><code id="print.summary.cgarch.estimate_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If TRUE, ‘significance stars’ are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="print.summary.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original summary object.
</p>

<hr>
<h2 id='radical'>The Robust Accurate, Direct ICA ALgorithm (RADICAL)</h2><span id='topic+radical'></span>

<h3>Description</h3>

<p>The ICA algorithm of Learned-Miller (2003), is based on an efficient entropy
estimator (due to Vasicek (1976)) which is robust to outliers and requires
no strong characterization assumptions about the data generating process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radical(
  X,
  components = NCOL(X),
  demean = TRUE,
  pca_cov = c("ML", "LW", "EWMA"),
  k = 150,
  augment = FALSE,
  replications = 30,
  sigma = 0.175,
  first_eigen = NULL,
  last_eigen = NULL,
  E = NULL,
  D = NULL,
  Z = NULL,
  K = NULL,
  L = NULL,
  seed = NULL,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radical_+3A_x">X</code></td>
<td>
<p>the data matrix (n x m) where n is the number of samples and m is the number of signals.</p>
</td></tr>
<tr><td><code id="radical_+3A_components">components</code></td>
<td>
<p>the number of independent components to extract.</p>
</td></tr>
<tr><td><code id="radical_+3A_demean">demean</code></td>
<td>
<p>whether to demean the data.</p>
</td></tr>
<tr><td><code id="radical_+3A_pca_cov">pca_cov</code></td>
<td>
<p>the method used to calculate the covariance matrix for PCA. Options are
&ldquo;ML&rdquo; (maximum likelihood), &ldquo;LW&rdquo; (Ledoit-Wolf) shrinkage method and
&ldquo;EWMA&rdquo; (exponentially weighted moving average).</p>
</td></tr>
<tr><td><code id="radical_+3A_k">k</code></td>
<td>
<p>the number of angles at which to evaluate the contrast function. The
contrast function will be evaluated at K evenly spaced rotations from -Pi/4 to Pi/4.</p>
</td></tr>
<tr><td><code id="radical_+3A_augment">augment</code></td>
<td>
<p>whether to augment the data (as explained in paper). For large
datasets of &gt;10,000 points this should be set to FALSE.</p>
</td></tr>
<tr><td><code id="radical_+3A_replications">replications</code></td>
<td>
<p>the number of replicated points for each original point if
augment is set to TRUE. The larger the number of points in the data set,
the smaller this value can be. For data sets of 10,000 points or more, point
replication should be de-activated by setting augment to FALSE.</p>
</td></tr>
<tr><td><code id="radical_+3A_sigma">sigma</code></td>
<td>
<p>the standard deviation (noise) of the replicated points when using
the augmentation option (which sets the standard deviation for the random normal
generator).</p>
</td></tr>
<tr><td><code id="radical_+3A_first_eigen">first_eigen</code></td>
<td>
<p>This and <code>last_eigen</code> specify the range for eigenvalues
that are retained, <code>first_eigen</code> is the index of largest eigenvalue to be
retained. Making use of this option overwrites <code>components</code>.</p>
</td></tr>
<tr><td><code id="radical_+3A_last_eigen">last_eigen</code></td>
<td>
<p>the index of the last (smallest) eigenvalue to be retained
and overwrites <code>component</code> argument.</p>
</td></tr>
<tr><td><code id="radical_+3A_e">E</code></td>
<td>
<p>(optional) Eigen vector from the PCA decomposition. If this
is provided then <code>D</code> must also be provided.</p>
</td></tr>
<tr><td><code id="radical_+3A_d">D</code></td>
<td>
<p>(optional) Eigen values from the PCA decomposition.</p>
</td></tr>
<tr><td><code id="radical_+3A_z">Z</code></td>
<td>
<p>(optional) provided whitened signal matrix. If this is provided then
both <code>K</code> and <code>L</code> must also be provided.</p>
</td></tr>
<tr><td><code id="radical_+3A_k">K</code></td>
<td>
<p>(optional) whitening matrix.</p>
</td></tr>
<tr><td><code id="radical_+3A_l">L</code></td>
<td>
<p>(optional) de-whitening matrix.</p>
</td></tr>
<tr><td><code id="radical_+3A_seed">seed</code></td>
<td>
<p>the random seed for the random number generator.</p>
</td></tr>
<tr><td><code id="radical_+3A_trace">trace</code></td>
<td>
<p>whether to print out progress information.</p>
</td></tr>
<tr><td><code id="radical_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the covariance matrix calculation.
For arguments passed to the &ldquo;EWMA&rdquo; method, it optionally takes an additional argument
<code>lambda</code> which is the exponential decay parameter (default is 0.96).
The &ldquo;LW&rdquo; takes an additional argument <code>shrink</code> which is the
shrinkage parameter (default is to calculate this).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Steps to the general algorithm are as follows (see P.1284 of
Learned-Miller (2003) for specific details of RADICAL implementation):
</p>

<ol>
<li><p> Demean the data if required: <code class="reqn">M = X - \mu</code>
</p>
</li>
<li><p> Calculate the covariance matrix <code class="reqn">\Sigma</code>  using one of the
methods provided.
</p>
</li>
<li><p> Use an eigen decomposition to calculate the eigenvalues and eigenvectors
of the covariance matrix: <code class="reqn">\Sigma = E D E'</code>
</p>
</li>
<li><p> Select the range of eigenvalues to retain (dimensionality reduction).
</p>
</li>
<li><p> Calculate the whitening matrix <code class="reqn">K = D^{-1/2}E'</code> and the dewhitening
matrix <code class="reqn">L = E D^{1/2}</code>.
</p>
</li>
<li><p> Whiten the data: <code class="reqn">Z = M K'</code>. Unwhitening is done by <code class="reqn">M = Z L'</code>.
</p>
</li>
<li><p> Run the RADICAL algorithm to calculate the rotation matrix <code class="reqn">U</code>,
the mixing matrix: <code class="reqn">A = U^{-1} L</code> and the unmixing matrix <code class="reqn">W = K' U</code>.
</p>
</li>
<li><p> Calculate the independent components: <code class="reqn">S = M W + \bold{1}\mu W </code> where
<b>1</b> is a matrix of ones with dimension (samples x 1).
</p>
</li></ol>

<p>Notice that in calculating the mixing (A) and unmixing (W) matrices we have combined
the whitening (K) and un-whitening (L) matrices with the rotation matrix <code class="reqn">U</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>the mixing matrix</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the unmixing matrix</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>the independent components</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>the rotation matrix</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the whitening matrix</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>the dewhitening matrix</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>the covariance matrix</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the whitened signal</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the mean of the mixed signal (X)</p>
</td></tr>
<tr><td><code>elapsed</code></td>
<td>
<p>the time taken to run the algorithm</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Replications carries a significant computational cost. The algorithm
is written in C++ and uses &ldquo;RcppParallel&rdquo; for the most expensive
calculations. See <code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code> for setting
the number of threads to use.
</p>


<h3>References</h3>

<p>Learned-Miller EG, Fisher III JW (2003).
&ldquo;ICA using spacings estimates of entropy.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>4</b>, 1271&ndash;1295.
Ledoit O, Wolf M (2004).
&ldquo;A well-conditioned estimator for large-dimensional covariance matrices.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>88</b>, 365&ndash;411.
Vasicek O (1976).
&ldquo;A test for normality based on sample entropy.&rdquo;
<em>Journal of the Royal Statistical Society Series B: Statistical Methodology</em>, <b>38</b>(1), 54&ndash;59.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+bread'></span><span id='topic+estfun'></span><span id='topic+newsimpact'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>sandwich</dt><dd><p><code><a href="sandwich.html#topic+bread">bread</a></code>, <code><a href="sandwich.html#topic+estfun">estfun</a></code></p>
</dd>
<dt>tsgarch</dt><dd><p><code><a href="tsgarch.html#topic+newsimpact">newsimpact</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.cgarch.estimate'>Extract Model Residuals</h2><span id='topic+residuals.cgarch.estimate'></span><span id='topic+residuals'></span><span id='topic+residuals.dcc.estimate'></span><span id='topic+residuals.gogarch.estimate'></span>

<h3>Description</h3>

<p>Extract the residuals of the estimated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
residuals(object, standardize = FALSE, type = "standard", ...)

## S3 method for class 'dcc.estimate'
residuals(object, standardize = FALSE, type = "standard", ...)

## S3 method for class 'gogarch.estimate'
residuals(object, standardize = FALSE, type = "standard", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;cgarch.estimate&rdquo;,
&ldquo;dcc.estimate&rdquo; or &ldquo;gogarch.estimate&rdquo;</p>
</td></tr>
<tr><td><code id="residuals.cgarch.estimate_+3A_standardize">standardize</code></td>
<td>
<p>logical. Whether to standardize the residuals by the
conditional volatility (only valid for the &ldquo;standard&rdquo; type).</p>
</td></tr>
<tr><td><code id="residuals.cgarch.estimate_+3A_type">type</code></td>
<td>
<p>a choice of &ldquo;standard&rdquo; (default), &ldquo;model&rdquo;, or
&ldquo;whitened&rdquo; residuals. The first choice is the default and represents
the residuals from the first stage univariate GARCH models. The second choice
is only useful for the copula model and represents the residuals from the copula
after the transformation. In the case of the DCC model this will return the
standard type residuals (since they are the same). The last choice represents the
whitened (ZCA based) residuals which are the standard residuals multiplied by the inverse
of the square root of the conditional covariance matrix.</p>
</td></tr>
<tr><td><code id="residuals.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An xts matrix.
</p>


<h3>Note</h3>

<p>In the case of the GOGARCH model, the residuals are calculated as
<code class="reqn">\varepsilon  A</code>, where A is the mixing matrix applied
to the independent component residuals. These will be equal to the residuals
of the original series only if there is no dimensionality reduction.
</p>

<hr>
<h2 id='simulate.cgarch.estimate'>Model Simulation</h2><span id='topic+simulate.cgarch.estimate'></span><span id='topic+simulate'></span><span id='topic+simulate.dcc.estimate'></span><span id='topic+simulate.gogarch.estimate'></span>

<h3>Description</h3>

<p>Simulates paths of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  h = 100,
  burn = 0,
  Q_init = NULL,
  Z_init = NULL,
  init_method = c("start", "end"),
  cond_mean = NULL,
  sim_method = c("parametric", "bootstrap"),
  ...
)

## S3 method for class 'dcc.estimate'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  h = 100,
  burn = 0,
  Q_init = NULL,
  Z_init = NULL,
  init_method = c("start", "end"),
  cond_mean = NULL,
  sim_method = c("parametric", "bootstrap"),
  ...
)

## S3 method for class 'gogarch.estimate'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  h = 100,
  burn = 0,
  cond_mean = NULL,
  sim_method = c("parametric", "bootstrap"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an estimated object from one of the models in the package.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_nsim">nsim</code></td>
<td>
<p>the number of sample paths to generate.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_seed">seed</code></td>
<td>
<p>an integer that will be used in a call to set.seed before simulating.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_h">h</code></td>
<td>
<p>the number of time steps to simulate paths for.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_burn">burn</code></td>
<td>
<p>burn in. Will be discarded before returning the output.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_q_init">Q_init</code></td>
<td>
<p>an optional array of matrices of dimension
n_series x n_series x maxpq for initializing the DCC model (not relevant in
the constant correlation case), where maxpq is the maximum DCC model order.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_z_init">Z_init</code></td>
<td>
<p>an optional matrix of size maxpq x m of initialization values for the
standardized innovations of the DCC model. For this copula model, care should be
taken as these represent the DCC copula standardized innovations, not the
univariate GARCH innovations.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_init_method">init_method</code></td>
<td>
<p>method to initialize the DCC and GARCH recursion (unless
&ldquo;Q_init&rdquo; and &ldquo;Z_init&rdquo; are not NULL in which case those take
priority for those inputs). The &ldquo;start&rdquo; method initializes the recursion
with the same values used during estimation, whereas the &ldquo;end&rdquo; method
uses the last values of the estimated model to initialize the recursion. In
the constant correlation case, only the the GARCH initialization is relevant.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_cond_mean">cond_mean</code></td>
<td>
<p>an optional matrix (h x n_series) of the simulated conditional
mean for the series which is used to recenter the simulated distribution.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_sim_method">sim_method</code></td>
<td>
<p>white noise method for generating random sample for the
multivariate distribution. The default &ldquo;parametric&rdquo; samples random
variates from the underlying error distribution whilst the &ldquo;bootstrap&rdquo;
samples from the whitened innovations of the fitted model.</p>
</td></tr>
<tr><td><code id="simulate.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>no additional arguments currently supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Part of the code makes use of parallel functionality via
the &ldquo;future&rdquo; package (see <code><a href="future.html#topic+plan">plan</a></code>). The dimension
the parallel execution operates on is the number of series (for the
individual GARCH series simulation), so unless you have more than 100 series
then it is possible that using a parallel back-end may actually result in
slower execution due to the overhead involved.
</p>


<h3>Value</h3>

<p>A simulation class object for which methods exists for extracting
relevant statistics such as the correlation, covariance, etc.
</p>

<hr>
<h2 id='summary.cgarch.estimate'>Model Estimation Summary</h2><span id='topic+summary.cgarch.estimate'></span><span id='topic+summary'></span><span id='topic+summary.dcc.estimate'></span><span id='topic+summary.gogarch.estimate'></span>

<h3>Description</h3>

<p>Summary method for class &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
summary(object, vcov_type = "OP", ...)

## S3 method for class 'dcc.estimate'
summary(object, vcov_type = "OP", ...)

## S3 method for class 'gogarch.estimate'
summary(object, vcov_type = "OP", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="summary.cgarch.estimate_+3A_vcov_type">vcov_type</code></td>
<td>
<p>the type of standard errors based on the vcov estimate (see <code><a href="#topic+vcov">vcov</a></code>).</p>
</td></tr>
<tr><td><code id="summary.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with summary information of class &ldquo;summary.cgarch.estimate&rdquo; or
&ldquo;summary.dcc.estimate&rdquo;.
</p>

<hr>
<h2 id='tsaggregate.cgarch.estimate'>Weighted Moments Aggregation</h2><span id='topic+tsaggregate.cgarch.estimate'></span><span id='topic+tsaggregate'></span><span id='topic+tsaggregate.cgarch.simulate'></span><span id='topic+tsaggregate.cgarch.predict'></span><span id='topic+tsaggregate.dcc.estimate'></span><span id='topic+tsaggregate.dcc.simulate'></span><span id='topic+tsaggregate.dcc.predict'></span><span id='topic+tsaggregate.gogarch.estimate'></span><span id='topic+tsaggregate.gogarch.predict'></span><span id='topic+tsaggregate.gogarch.simulate'></span>

<h3>Description</h3>

<p>Calculates and returns the weighted moments of the
estimated, simulated or predicted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
tsaggregate(object, weights = NULL, ...)

## S3 method for class 'cgarch.simulate'
tsaggregate(object, weights = NULL, distribution = TRUE, ...)

## S3 method for class 'cgarch.predict'
tsaggregate(object, weights = NULL, distribution = TRUE, ...)

## S3 method for class 'dcc.estimate'
tsaggregate(object, weights = NULL, ...)

## S3 method for class 'dcc.simulate'
tsaggregate(object, weights = NULL, distribution = TRUE, ...)

## S3 method for class 'dcc.predict'
tsaggregate(object, weights = NULL, distribution = TRUE, ...)

## S3 method for class 'gogarch.estimate'
tsaggregate(object, weights = NULL, ...)

## S3 method for class 'gogarch.predict'
tsaggregate(object, weights = NULL, distribution = TRUE, ...)

## S3 method for class 'gogarch.simulate'
tsaggregate(object, weights = NULL, distribution = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsaggregate.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of one of the model classes in the package.</p>
</td></tr>
<tr><td><code id="tsaggregate.cgarch.estimate_+3A_weights">weights</code></td>
<td>
<p>an optional weighting vector. If NULL will use an equal weight vector.
It is also possible to pass a time varying weighting matrix with time along the
row dimension and equal to the number of time points or horizon.</p>
</td></tr>
<tr><td><code id="tsaggregate.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
<tr><td><code id="tsaggregate.cgarch.estimate_+3A_distribution">distribution</code></td>
<td>
<p>for the predicted and simulated objects whether to return
the simulated distribution of the weighted moments else the average.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the weighted moments. For an estimated object class these
will be xts vectors whilst for the simulated and predicted class these will be
objects of class &ldquo;tsmodel.distribution&rdquo; capturing the distributional
uncertainty and for which a default plot method exists, unless argument
&ldquo;distribution&rdquo; is set to FALSE.
</p>

<hr>
<h2 id='tscokurt.gogarch.estimate'>Cokurtosis Extractor</h2><span id='topic+tscokurt.gogarch.estimate'></span><span id='topic+tscokurt'></span><span id='topic+tscokurt.gogarch.predict'></span><span id='topic+tscokurt.gogarch.simulate'></span>

<h3>Description</h3>

<p>Extracts the conditional cokurtosis matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gogarch.estimate'
tscokurt(
  object,
  index = NULL,
  distribution = FALSE,
  standardize = TRUE,
  folded = TRUE,
  ...
)

## S3 method for class 'gogarch.predict'
tscokurt(
  object,
  index = NULL,
  distribution = FALSE,
  standardize = TRUE,
  folded = TRUE,
  ...
)

## S3 method for class 'gogarch.simulate'
tscokurt(
  object,
  index = NULL,
  distribution = FALSE,
  standardize = TRUE,
  folded = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscokurt.gogarch.estimate_+3A_object">object</code></td>
<td>
<p>an object class from one of the models in the package.</p>
</td></tr>
<tr><td><code id="tscokurt.gogarch.estimate_+3A_index">index</code></td>
<td>
<p>the time index (integer) from which to extract a subset of the
cokurtosis array rather than the whole time series.</p>
</td></tr>
<tr><td><code id="tscokurt.gogarch.estimate_+3A_distribution">distribution</code></td>
<td>
<p>whether to return the full simulated cokurtosis distribution
for the predicted and simulated objects, else the average cokurtosis across each
horizon.</p>
</td></tr>
<tr><td><code id="tscokurt.gogarch.estimate_+3A_standardize">standardize</code></td>
<td>
<p>whether to standardize the 4th co-moment so that it represents
the cokurtosis.</p>
</td></tr>
<tr><td><code id="tscokurt.gogarch.estimate_+3A_folded">folded</code></td>
<td>
<p>whether to return the result as a folded or unfolded array. The folded
array is n_series x n_series x n_series x n_series x horizon (x simulation if
predicted or simulated object). The unfolded array is a n_series x (n_series^3) x
horizon array. Calculations such as weighted co-moments are based on the unfolded
array using the Kronecker operator.</p>
</td></tr>
<tr><td><code id="tscokurt.gogarch.estimate_+3A_...">...</code></td>
<td>
<p>none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the cokurtosis array from the independent factors is very
expensive in terms of memory footprint as well as computation time.
While it does take advantage of multiple threads if required (see
<code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code>), in the case of many series this
will quickly become difficult for systems low RAM. Because of this, there is
the option to extract a specific point in time output using the <code>index</code>
argument.
</p>


<h3>Value</h3>

<p>the cokurtosis (see details).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='tsconvolve.gogarch.estimate'>Convolution</h2><span id='topic+tsconvolve.gogarch.estimate'></span><span id='topic+tsconvolve'></span><span id='topic+tsconvolve.gogarch.predict'></span><span id='topic+tsconvolve.gogarch.simulate'></span>

<h3>Description</h3>

<p>Generates the weighted density of the GOGARCH NIG or GH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gogarch.estimate'
tsconvolve(
  object,
  weights = NULL,
  fft_step = 0.001,
  fft_by = 1e-04,
  fft_support = c(-1, 1),
  ...
)

## S3 method for class 'gogarch.predict'
tsconvolve(
  object,
  weights = NULL,
  fft_step = 0.001,
  fft_by = 1e-04,
  fft_support = c(-1, 1),
  distribution = FALSE,
  ...
)

## S3 method for class 'gogarch.simulate'
tsconvolve(
  object,
  weights = NULL,
  fft_step = 0.001,
  fft_by = 1e-04,
  fft_support = c(-1, 1),
  distribution = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;gogarch.estimate&rdquo;, &ldquo;gogarch.predict&rdquo;
or &ldquo;gogarch.simulate&rdquo;.</p>
</td></tr>
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_weights">weights</code></td>
<td>
<p>A vector of weights of length equal to the number of series. If
NULL then an equal weight vector is used. A time varying matrix of weights is
also allowed with the correct number of rows (time points or horizon).</p>
</td></tr>
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_fft_step">fft_step</code></td>
<td>
<p>determines the step size for tuning the characteristic function inversion.</p>
</td></tr>
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_fft_by">fft_by</code></td>
<td>
<p>determines the resolution for the equally spaced support given by <code>fft_support</code>.</p>
</td></tr>
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_fft_support">fft_support</code></td>
<td>
<p>allows either a fixed support range to be given for the inversion else this is
calculated (if NULL) by examining the upper and lower quantiles of each independent factor modeled.
For the Generalized Hyperbolic distribution, it is not recommended to leave this as NULL since
it is quite expensive to calculate the quantiles and will significantly slow down execution time.</p>
</td></tr>
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_...">...</code></td>
<td>
<p>not currently supported.</p>
</td></tr>
<tr><td><code id="tsconvolve.gogarch.estimate_+3A_distribution">distribution</code></td>
<td>
<p>for the simulated and predicted object, whether to apply to each draw or on the
average across draws (for the predicted object this is the analytic solution rather than the
average).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fast Fourier Transformation (FFT) is used to approximate the weighted
density based on its characteristic function. The weighted density is based
on the convolution of the scaled densities of the independent factors, by using
the Jacobian transformation (for more details see the vignette).
The returned object will be a list with the convoluted density for each time point (or each
time point and draw). This can then be passed to the <code><a href="#topic+dfft">dfft</a></code>, <code><a href="#topic+pfft">pfft</a></code> or
<code><a href="#topic+qfft">qfft</a></code> methods which create smooth distributional functions.
</p>


<h3>Value</h3>

<p>an object of class &ldquo;gogarch.fft&rdquo; or &ldquo;gogarch.fftsim&rdquo;.
</p>

<hr>
<h2 id='tscor.cgarch.estimate'>Correlation Extractor</h2><span id='topic+tscor.cgarch.estimate'></span><span id='topic+tscor'></span><span id='topic+tscor.cgarch.simulate'></span><span id='topic+tscor.cgarch.predict'></span><span id='topic+tscor.dcc.estimate'></span><span id='topic+tscor.dcc.simulate'></span><span id='topic+tscor.dcc.predict'></span><span id='topic+tscor.gogarch.estimate'></span><span id='topic+tscor.gogarch.predict'></span><span id='topic+tscor.gogarch.simulate'></span>

<h3>Description</h3>

<p>Extracts the conditional correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'cgarch.simulate'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'cgarch.predict'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'dcc.estimate'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'dcc.simulate'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'dcc.predict'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'gogarch.estimate'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'gogarch.predict'
tscor(object, distribution = TRUE, ...)

## S3 method for class 'gogarch.simulate'
tscor(object, distribution = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscor.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object class from one of the models in the package.</p>
</td></tr>
<tr><td><code id="tscor.cgarch.estimate_+3A_distribution">distribution</code></td>
<td>
<p>whether to return the full simulated correlation distribution
for the predicted and simulated objects, else the average covariance across each
horizon.</p>
</td></tr>
<tr><td><code id="tscor.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>none</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Estimation Object</h4>

<p>An array of correlation matrices with time as the third dimension.
The returned object has attributes &lsquo;index&rsquo; representing the datetime
and &lsquo;series&rsquo; representing the series names.
</p>



<h4>Simulation and Prediction Objects</h4>

<p>A 4-d array of dimensions (n_series x n_series x horizon x n_draws). If
<code>distribution</code> is FALSE, then the average covariance across all draws, an
array of dimensions (n_series x n_series x horizon).
</p>



<h3>Value</h3>

<p>the correlation (see details).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='tscoskew.gogarch.estimate'>Coskewness Extractor</h2><span id='topic+tscoskew.gogarch.estimate'></span><span id='topic+tscoskew'></span><span id='topic+tscoskew.gogarch.predict'></span><span id='topic+tscoskew.gogarch.simulate'></span>

<h3>Description</h3>

<p>Extracts the conditional coskewness matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gogarch.estimate'
tscoskew(
  object,
  index = NULL,
  distribution = FALSE,
  standardize = TRUE,
  folded = TRUE,
  ...
)

## S3 method for class 'gogarch.predict'
tscoskew(
  object,
  index = NULL,
  distribution = FALSE,
  standardize = TRUE,
  folded = TRUE,
  ...
)

## S3 method for class 'gogarch.simulate'
tscoskew(
  object,
  index = NULL,
  distribution = FALSE,
  standardize = TRUE,
  folded = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscoskew.gogarch.estimate_+3A_object">object</code></td>
<td>
<p>an object class from one of the models in the package.</p>
</td></tr>
<tr><td><code id="tscoskew.gogarch.estimate_+3A_index">index</code></td>
<td>
<p>the time index (integer) from which to extract a subset of the
coskewness array rather than the whole time series.</p>
</td></tr>
<tr><td><code id="tscoskew.gogarch.estimate_+3A_distribution">distribution</code></td>
<td>
<p>whether to return the full simulated coskewness distribution
for the predicted and simulated objects.</p>
</td></tr>
<tr><td><code id="tscoskew.gogarch.estimate_+3A_standardize">standardize</code></td>
<td>
<p>whether to standardize the 3th co-moment so that it represents
the coskewness.</p>
</td></tr>
<tr><td><code id="tscoskew.gogarch.estimate_+3A_folded">folded</code></td>
<td>
<p>whether to return the result as a folded or unfolded array. The folded
array is n_series x n_series x n_series x horizon (x simulation if predicted or simulated
object). The unfolded array is a n_series x (n_series^2) x horizon array. Calculations
such as weighted co-moments are based on the unfolded array using the Kronecker operator.</p>
</td></tr>
<tr><td><code id="tscoskew.gogarch.estimate_+3A_...">...</code></td>
<td>
<p>none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the coskewness array from the independent factors is very
expensive in terms of memory footprint as well as computation time.
While it does take advantage of multiple threads if required (see
<code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code>), in the case of many series this
will quickly become difficult for systems low RAM. Because of this, there is
the option to extract a specific point in time output using the <code>index</code> argument.
</p>


<h3>Value</h3>

<p>the coskewness (see details).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='tscov.cgarch.estimate'>Covariance Extractor</h2><span id='topic+tscov.cgarch.estimate'></span><span id='topic+tscov'></span><span id='topic+tscov.cgarch.simulate'></span><span id='topic+tscov.cgarch.predict'></span><span id='topic+tscov.dcc.estimate'></span><span id='topic+tscov.dcc.simulate'></span><span id='topic+tscov.dcc.predict'></span><span id='topic+tscov.gogarch.estimate'></span><span id='topic+tscov.gogarch.predict'></span><span id='topic+tscov.gogarch.simulate'></span>

<h3>Description</h3>

<p>Extracts the conditional covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'cgarch.simulate'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'cgarch.predict'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'dcc.estimate'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'dcc.simulate'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'dcc.predict'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'gogarch.estimate'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'gogarch.predict'
tscov(object, distribution = TRUE, ...)

## S3 method for class 'gogarch.simulate'
tscov(object, distribution = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tscov.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object class from one of the models in the package.</p>
</td></tr>
<tr><td><code id="tscov.cgarch.estimate_+3A_distribution">distribution</code></td>
<td>
<p>whether to return the full simulated covariance distribution
for the predicted and simulated objects, else the average covariance across each
horizon.</p>
</td></tr>
<tr><td><code id="tscov.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>none</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Estimation Object</h4>

<p>An array of covariance matrices with time as the third dimension.
The returned object has attributes &lsquo;index&rsquo; representing the datetime
and &lsquo;series&rsquo; representing the series names.
</p>



<h4>Simulation and Prediction Objects</h4>

<p>A 4-d array of dimensions (n_series x n_series x horizon x n_draws). If
<code>distribution</code> is FALSE, then the average covariance across all draws, an
array of dimensions (n_series x n_series x horizon).
</p>



<h3>Value</h3>

<p>the covariance (see details).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='tsfilter.cgarch.estimate'>Model Filtering</h2><span id='topic+tsfilter.cgarch.estimate'></span><span id='topic+tsfilter'></span><span id='topic+tsfilter.dcc.estimate'></span><span id='topic+tsfilter.gogarch.estimate'></span>

<h3>Description</h3>

<p>Filters new data based on an already estimated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
tsfilter(
  object,
  y = NULL,
  newxreg = NULL,
  update = TRUE,
  cond_mean = NULL,
  ...
)

## S3 method for class 'dcc.estimate'
tsfilter(
  object,
  y = NULL,
  newxreg = NULL,
  update = TRUE,
  cond_mean = NULL,
  ...
)

## S3 method for class 'gogarch.estimate'
tsfilter(object, y = NULL, newxreg = NULL, cond_mean = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsfilter.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="tsfilter.cgarch.estimate_+3A_y">y</code></td>
<td>
<p>an xts matrix of new values to filter.</p>
</td></tr>
<tr><td><code id="tsfilter.cgarch.estimate_+3A_newxreg">newxreg</code></td>
<td>
<p>not used in these models.</p>
</td></tr>
<tr><td><code id="tsfilter.cgarch.estimate_+3A_update">update</code></td>
<td>
<p>whether to update certain values using the most recent information
less than the new data (see details).</p>
</td></tr>
<tr><td><code id="tsfilter.cgarch.estimate_+3A_cond_mean">cond_mean</code></td>
<td>
<p>an optional matrix of the filtered conditional mean values.</p>
</td></tr>
<tr><td><code id="tsfilter.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>additional arguments for future expansion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method filters new data and updates the object with this new information
so that it can be called recursively as new data arrives. The &ldquo;update&rdquo; argument
allows values such as the intercept matrices and transformation estimates (for the
&ldquo;spd&rdquo; and &ldquo;empirical&rdquo; methods) in the dynamic case, and the constant
correlation in the constant case, to use information up to and include time T, where
T is the time stamp just preceding the new y timestamps. In this way, the filter
method can be called recursively and the user can selectively choose to either use the
updating scheme or use the original estimated values. Whatever the case, this ensures
that there is no look-ahead bias when filtering new information.
</p>


<h3>Value</h3>

<p>A &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo; object with updated
information. All values in the object are updated with the exception of the hessian
and scores which remain at their estimation set values.
</p>

<hr>
<h2 id='value_at_risk'>Value at Risk (VaR) method for predicted and simulated objects</h2><span id='topic+value_at_risk'></span><span id='topic+value_at_risk.gogarch.predict'></span><span id='topic+value_at_risk.dcc.predict'></span><span id='topic+value_at_risk.cgarch.predict'></span><span id='topic+value_at_risk.gogarch.simulate'></span><span id='topic+value_at_risk.dcc.simulate'></span><span id='topic+value_at_risk.cgarch.simulate'></span>

<h3>Description</h3>

<p>Value at Risk (VaR) method for predicted and simulated objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_at_risk(object, ...)

## S3 method for class 'gogarch.predict'
value_at_risk(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'dcc.predict'
value_at_risk(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'cgarch.predict'
value_at_risk(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'gogarch.simulate'
value_at_risk(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'dcc.simulate'
value_at_risk(object, weights = NULL, alpha = 0.05, ...)

## S3 method for class 'cgarch.simulate'
value_at_risk(object, weights = NULL, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_at_risk_+3A_object">object</code></td>
<td>
<p>an object generated from the predict or simulate methods.</p>
</td></tr>
<tr><td><code id="value_at_risk_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="value_at_risk_+3A_weights">weights</code></td>
<td>
<p>a vector of weights of length equal to the number of series. If
NULL then an equal weight vector is used.</p>
</td></tr>
<tr><td><code id="value_at_risk_+3A_alpha">alpha</code></td>
<td>
<p>the quantile level for the value at risk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the value at risk. For predict type input objects this will be an xts
matrix with index the forecast dates.
</p>

<hr>
<h2 id='vcov.cgarch.estimate'>The Covariance Matrix of the Estimated Parameters</h2><span id='topic+vcov.cgarch.estimate'></span><span id='topic+vcov'></span><span id='topic+vcov.dcc.estimate'></span>

<h3>Description</h3>

<p>The Covariance Matrix of the Estimated Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cgarch.estimate'
vcov(object, adjust = FALSE, type = c("H", "OP", "QMLE", "NW"), ...)

## S3 method for class 'dcc.estimate'
vcov(object, adjust = FALSE, type = c("H", "OP", "QMLE", "NW"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.cgarch.estimate_+3A_object">object</code></td>
<td>
<p>an object of class &ldquo;cgarch.estimate&rdquo; or &ldquo;dcc.estimate&rdquo;.</p>
</td></tr>
<tr><td><code id="vcov.cgarch.estimate_+3A_adjust">adjust</code></td>
<td>
<p>logical. Should a finite sample adjustment be made? This amounts
to multiplication with n/(n-k) where n is the number of observations and k
the number of estimated parameters.</p>
</td></tr>
<tr><td><code id="vcov.cgarch.estimate_+3A_type">type</code></td>
<td>
<p>valid choices are &ldquo;H&rdquo; for using the numerical hessian
for the bread, &ldquo;OP&rdquo; for the outer product of gradients, &ldquo;QMLE&rdquo;
for the Quasi-ML sandwich estimator (Huber-White), and &ldquo;NW&rdquo; for the Newey-West
adjusted sandwich estimator (a HAC estimator).</p>
</td></tr>
<tr><td><code id="vcov.cgarch.estimate_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the Newey-West bandwidth function to
determine the optimal lags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance-covariance matrix of the estimated parameters.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
