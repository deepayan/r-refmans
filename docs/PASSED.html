<!DOCTYPE html><html lang="en"><head><title>Help for package PASSED</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PASSED}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#power_Beta'><p>Power Calculations for Test of Two Beta Means</p></a></li>
<li><a href='#power_Binomial'><p>Power Calculations for Two-Sample Test for Proportions</p></a></li>
<li><a href='#power_Gamma'><p>Power Calculations for Test of Two Gamma Means</p></a></li>
<li><a href='#power_Geometric'><p>Power Calculation for Comparing Two Geometric Rates.</p></a></li>
<li><a href='#power_NegativeBinomial'><p>Power Calculation for Comparing Two Negative Binomial Rates</p></a></li>
<li><a href='#power_Normal'><p>Power Calculations for One and Two Sample T-tests</p></a></li>
<li><a href='#power_Poisson'><p>Power Calculations for Test of Two Poisson Ratios</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Calculate Power and Sample Size for Two Sample Mean Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Power calculations are a critical component of any research study to determine the 
	minimum sample size necessary to detect differences between multiple groups. Here we 
	present an 'R' package, 'PASSED', that performs power and sample size calculations for 
	the test of two-sample means or ratios with data following beta, 
	gamma (Chang et al. (2011), &lt;<a href="https://doi.org/10.1007%2Fs00180-010-0209-1">doi:10.1007/s00180-010-0209-1</a>&gt;), normal, 
	Poisson (Gu et al. (2008), &lt;<a href="https://doi.org/10.1002%2Fbimj.200710403">doi:10.1002/bimj.200710403</a>&gt;), binomial, geometric, and 
	negative binomial (Zhu and Lakkis (2014), &lt;<a href="https://doi.org/10.1002%2Fsim.5947">doi:10.1002/sim.5947</a>&gt;) distributions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>betareg, stats, rootSolve</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, MKmisc</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-16 01:29:11 UTC; Castle</td>
</tr>
<tr>
<td>Author:</td>
<td>Jinpu Li [aut, cre],
  Ryan Knigge [aut],
  Emily Leary [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jinpu Li &lt;lijinp@health.missouri.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-16 04:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='power_Beta'>Power Calculations for Test of Two Beta Means</h2><span id='topic+power_Beta'></span>

<h3>Description</h3>

<p>Compute the power for a test of two sample means with beta distributions, or determine the minimum sample size to obtain a target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Beta(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05, 
mu1 = NULL, sd1 = NULL, mu2 = NULL, equal.sample = TRUE,
trials = 100, equal.precision = TRUE, sd2 = NULL, 
link.type = c("logit", "probit", "cloglog", "cauchit", "log", "loglog"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Beta_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if <code>equal.sample = TRUE</code></p>
</td></tr>
<tr><td><code id="power_Beta_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_mu1">mu1</code></td>
<td>
<p>sample mean of group 1</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_sd1">sd1</code></td>
<td>
<p>standard deviation for group 1</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_mu2">mu2</code></td>
<td>
<p>sample mean of group 2</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_trials">trials</code></td>
<td>
<p>number of trials in simulation</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_equal.precision">equal.precision</code></td>
<td>
<p>equal dispersion parameter assumption in simulation</p>
</td></tr>
<tr><td><code id="power_Beta_+3A_sd2">sd2</code></td>
<td>
<p>standard deviation for group 2. Only applicable when <code>equal.precision = FALSE</code></p>
</td></tr>
<tr><td><code id="power_Beta_+3A_link.type">link.type</code></td>
<td>
<p>type of link used in the beta regression, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code> and <code>power</code> must be passed as NULL, and that parameter is determined from the others.<br /><br />
This function allows you to set the number of trials in the simulation to control the result accuracy, 
and type of link used in the beta regression. You can choose one of the following: &quot;logit&quot;, &quot;probit&quot;, &quot;cloglog&quot;, &quot;cauchit&quot;, &quot;log&quot;, &quot;loglog&quot;.
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with method and note elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate power
power_Beta(mu1 = 0.5, mu2 = 0.80, sd1 = 0.25, n1 = 60)
# calculate sample size for both groups
power_Beta(mu1 = 0.5, mu2 = 0.80, sd1 = 0.25, power=0.8)
</code></pre>

<hr>
<h2 id='power_Binomial'>Power Calculations for Two-Sample Test for Proportions</h2><span id='topic+power_Binomial'></span>

<h3>Description</h3>

<p>Compute power of test, or determine parameters to obtain target power for equal and unequal sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Binomial(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05,
p1 = 0.5, p2 = 0.5, equal.sample = TRUE, alternative = c("two.sided", "one.sided"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Binomial_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if equal.sample = TRUE</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_p1">p1</code></td>
<td>
<p>probability in group 1</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_p2">p2</code></td>
<td>
<p>probability in group 2</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Binomial_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code>, <code>p1</code>, <code>p2</code>, <code>power</code>, and <code>sig.level</code> must be passed as NULL, and that parameter is determined from the others.
Notice that <code>p1</code>, <code>p2</code>, <code>sig.level</code> have non-NULL defaults, so NULL must be explicitly expressed if you want to compute them.<br /><br />
If <code>equal.sample = TRUE</code> is used, N in output will denote the number in each group.<br /><br />
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with note and method elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate power, equal sizes
power_Binomial(n1 = 100, p1 = 0.5, p2 = 0.7)
# calculate power, unequal sizes
power_Binomial(n1 = 150, n2 = 100, p1 = 0.5, p2 = 0.7)
# calculate n2
power_Binomial(n1 = 100, p1 = 0.5, p2 = 0.7, power = 0.9, equal.sample = FALSE)
</code></pre>

<hr>
<h2 id='power_Gamma'>Power Calculations for Test of Two Gamma Means</h2><span id='topic+power_Gamma'></span>

<h3>Description</h3>

<p>Compute the power for a test of two sample means with Gamma distributions, or determine parameters to obtain a target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Gamma(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05, 
mu1 = NULL, mu2 = NULL, gmu1 = NULL, gmu2 = NULL, trials = 100, 
M = 10000, equal.sample = TRUE, equal.shape = NULL, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Gamma_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if equal.sample = TRUE</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_mu1">mu1</code></td>
<td>
<p>arithmetic mean of group 1</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_mu2">mu2</code></td>
<td>
<p>arithmetic mean of group 2</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_gmu1">gmu1</code></td>
<td>
<p>geometric mean of group 1</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_gmu2">gmu2</code></td>
<td>
<p>geometric mean of group 2</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_trials">trials</code></td>
<td>
<p>number of trials in simulation</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_m">M</code></td>
<td>
<p>number of simulations used in CAT method, see Chang (2011)</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_equal.shape">equal.shape</code></td>
<td>
<p>assume the shape parameters are equal for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Gamma_+3A_trace">trace</code></td>
<td>
<p>if positive, sample size and power are printed during the running of each simulation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code>, and <code>power</code> must be passed as NULL, and that parameter is determined from the others.
Notice that <code>sig.level</code> has non-NULL defaults, so NULL must be explicitly passed if you want to compute it.<br /><br />
If <code>equal.sample = TRUE</code> is used, N in output will denote the number in each group.<br /><br />
The equal shape parameter assumption will be tested automatically; otherwise it could be set manually with <code>equal.shape</code>.
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with method element.
</p>


<h3>References</h3>

<p>Chang et al. (2011). Testing the equality of several gamma means: a parametric bootstrap method with applications. <em>Computational Statistics</em>, <b>26</b>:55-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate power, equal sizes
power_Gamma(n1 = 50, mu1 = 1, mu2 = 1.5, gmu1 = 0.6, gmu2 = 0.6, M = 100)
</code></pre>

<hr>
<h2 id='power_Geometric'>Power Calculation for Comparing Two Geometric Rates.</h2><span id='topic+power_Geometric'></span>

<h3>Description</h3>

<p>Compute sample size or power for comparing two geometric rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Geometric(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05,
mu1 = NULL, mu2 = NULL, duration = 1, equal.sample = TRUE, 
alternative = c("two.sided", "one.sided"), approach = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Geometric_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if <code>equal.sample = TRUE</code></p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_mu1">mu1</code></td>
<td>
<p>expected rate of events per time unit for group 1</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_mu2">mu2</code></td>
<td>
<p>expected rate of events per time unit for group 2</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_duration">duration</code></td>
<td>
<p>(average) treatment duration</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="power_Geometric_+3A_approach">approach</code></td>
<td>
<p>1, 2, or 3; see Zhu and Lakkis (2014).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code>, and <code>power</code> must be passed as NULL, and that parameter is determined from the others.<br /><br />
If <code>equal.sample = TRUE</code> is used, N in output will denote the number in each group.<br /><br />
Since the geometric distribution is a special case of negative binomial distribution, we used the algorithm for negative binomial distribution with setting theta = 1. See <a href="MKmisc.html#topic+power.nb.test">power.nb.test</a> for more details.
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with note and method elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate power, equal sizes
power_Geometric(n1 = 100, mu1 = 0.3, mu2 = 0.6)
# calculate power, unequal sizes
power_Geometric(n1 = 180, n2 = 140, mu1 = 0.3, mu2 = 0.5)
# calculate n
power_Geometric( mu1 = 0.3, mu2 = 0.4, power = 0.8)
</code></pre>

<hr>
<h2 id='power_NegativeBinomial'>Power Calculation for Comparing Two Negative Binomial Rates</h2><span id='topic+power_NegativeBinomial'></span>

<h3>Description</h3>

<p>Compute sample size or power for comparing two negative binomial rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_NegativeBinomial(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05,
mu1 = NULL, mu2 = NULL, duration = 1, theta = NULL, equal.sample = TRUE, 
alternative = c("two.sided", "one.sided"), approach = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_NegativeBinomial_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if <code>equal.sample = TRUE</code></p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_mu1">mu1</code></td>
<td>
<p>expected rate of events per time unit for group 1</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_mu2">mu2</code></td>
<td>
<p>expected rate of events per time unit for group 2</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_duration">duration</code></td>
<td>
<p>(average) treatment duration</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_theta">theta</code></td>
<td>
<p>theta parameter of negative binomial distribution; see <a href="MASS.html#topic+rnegbin">rnegbin</a></p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="power_NegativeBinomial_+3A_approach">approach</code></td>
<td>
<p>1, 2, or 3; see Zhu and Lakkis (2014).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code>, and <code>power</code> must be passed as NULL, and that parameter is determined from the others.<br /><br />
If <code>equal.sample = TRUE</code> is used, N in output will denote the number in each group.<br /><br />
The computations are based on the formulas given in Zhu and Lakkis (2014). See <a href="MKmisc.html#topic+power.nb.test">power.nb.test</a> for more details.
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with note and method elements.
</p>


<h3>References</h3>

<p>H. Zhu and H. Lakkis (2014). Sample size calculation for comparing two negative binomial rates. <em>Statistics in Medicine</em>, <b>33</b>:376-387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate power, equal sizes
power_NegativeBinomial(n1 = 20, mu1 = 1, mu2 = 2, theta = 0.8)
# calculate power, unequal sizes
power_NegativeBinomial(n1 = 80, n2 = 40, mu1 = 1, mu2 = 2, theta = 0.8)
# calculate n
power_NegativeBinomial( mu1 = 1, mu2 = 2, theta = 0.8, power = 0.8)
</code></pre>

<hr>
<h2 id='power_Normal'>Power Calculations for One and Two Sample T-tests</h2><span id='topic+power_Normal'></span>

<h3>Description</h3>

<p>Compute power of t test, or determine parameters to obtain target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Normal(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05,
delta = NULL, sd1 = 1, sd2 = 1, equal.sample = TRUE,
alternative = c("two.sided", "one.sided"),
type = c("two.sample", "one.sample", "paired"),
df.method = c("welch", "classical"), strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Normal_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if equal.sample = TRUE</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_delta">delta</code></td>
<td>
<p>true difference in means</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_sd1">sd1</code></td>
<td>
<p>standard deviation for group 1</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_sd2">sd2</code></td>
<td>
<p>standard deviation for group 2</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_type">type</code></td>
<td>
<p>Type of t test</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_df.method">df.method</code></td>
<td>
<p>Method for calculating the degrees of default. Possibilities are welch (the default) or classical.</p>
</td></tr>
<tr><td><code id="power_Normal_+3A_strict">strict</code></td>
<td>
<p>Use strict interpretation in two-sided case</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code>, <code>delta</code>, <code>sd1</code>, <code>sd2</code>, <code>power</code>, and <code>sig.level</code> must be passed as NULL, and that parameter is determined from the others.
Notice that <code>sd1</code>, <code>sd2</code>, <code>sig.level</code> have non-NULL defaults, so NULL must be explicitly expressed if you want to compute them.<br /><br />
If <code>equal.sample = TRUE</code> is used, N in output will denote the number in each group.<br /><br />
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with note and method elements.
</p>


<h3>Note</h3>

<p>'uniroot' is used to solve power equation for unknowns, 
so you may see errors from it, notably about inability to bracket the root when invalid arguments are given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate power, equal sizes
power_Normal(n1 = 150, delta = 5, sd1 = 20, sd2 = 10)
# Calculate power, unequal sizes
power_Normal(n1 = 150, delta = 5, n2 = 120, sd1 = 10)
# Calculate n1, equal sizes 
power_Normal(delta = 5,  power = 0.9, sd1 = 10, sd2 = 12)
</code></pre>

<hr>
<h2 id='power_Poisson'>Power Calculations for Test of Two Poisson Ratios</h2><span id='topic+power_Poisson'></span>

<h3>Description</h3>

<p>Compute the power for a test of two sample means with Poisson distributions, or determine parameters to obtain a target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_Poisson(n1 = NULL, n2 = NULL, power = NULL, sig.level = 0.05,
lambda1 = NULL, lambda2 = NULL, t1 = 1, t2 = 1, RR0 = 1,
equal.sample = TRUE, alternative = c("two.sided", "one.sided"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_Poisson_+3A_n1">n1</code></td>
<td>
<p>sample size in group 1, or sample size in each group if <code>equal.sample = TRUE</code></p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_n2">n2</code></td>
<td>
<p>sample size in group 2</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_lambda1">lambda1</code></td>
<td>
<p>Poisson rate for group 1</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_lambda2">lambda2</code></td>
<td>
<p>Poisson rate for group 2</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_t1">t1</code></td>
<td>
<p>observed time period for group 1</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_t2">t2</code></td>
<td>
<p>observed time period for group 2</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_rr0">RR0</code></td>
<td>
<p>the ratio of lambda2 and lambda1 under null hypothesis</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_equal.sample">equal.sample</code></td>
<td>
<p>equal sample sizes for two groups, see details</p>
</td></tr>
<tr><td><code id="power_Poisson_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n1</code>, <code>n2</code>, <code>lambda1</code>, <code>lambda2</code>, <code>power</code>, and <code>sig.level</code> must be passed as NULL, and that parameter is determined from the others.
Notice that <code>sig.level</code> has non-NULL defaults, so NULL must be explicitly passed if you want to compute them.<br /><br />
If <code>equal.sample = TRUE</code> is used, <code>n2</code> would be ignored and N in output denotes the number in each group.
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments (including the computed one) augmented with method element.
</p>


<h3>Note</h3>

<p>'uniroot' is used to solve power equation for unknowns, 
so you may see errors from it, notably about inability to bracket the root when invalid arguments are given.
</p>


<h3>References</h3>

<p>Gu et al. (2008). Testing the ratio of two poisson rates. <em>Biometrical Journal: Journal of Mathematical Methods in Biosciences</em>. <b>50</b>:283-298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate power, equal sizes
power_Poisson(lambda1 = 0.0005, lambda2 = 0.003, n1 = 2000, t1 = 2, t2 = 2)
# Calculate sample size, equal sizes
power_Poisson(lambda1 = 0.0005, lambda2 = 0.003, power = 0.8, t1 = 2, t2 = 2)
# Calculate sample size for group 2, unequal sizes
power_Poisson(n1 = 2000, lambda1 = 0.0005, lambda2 = 0.003, power = 0.8, 
t1 = 2, t2 = 2, equal.sample = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
