<!DOCTYPE html><html><head><title>Help for package acebayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {acebayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ace'>
<p>Approximate Coordinate Exchange (ACE) Algorithm</p></a></li>
<li><a href='#acebayes-package'>
<p>Optimal Bayesian Experimental Design using the Approximate Coordinate Exchange (ACE) Algorithm</p></a></li>
<li><a href='#aceglm'>
<p>Approximate Coordinate Exchange (ACE) Algorithm for Generalised Linear Models</p></a></li>
<li><a href='#acenlm'>
<p>Approximate Coordinate Exchange (ACE) Algorithm for Non-Linear Models</p></a></li>
<li><a href='#aceobjects'>
<p>Print and Summary of <code>ace</code> and <code>pace</code> Objects</p></a></li>
<li><a href='#assess'>
<p>Compares two designs under the approximate expected utility</p></a></li>
<li><a href='#assessobjects'>
<p>Print and Summary of <code>assess</code> Objects</p></a></li>
<li><a href='#overstallwoods'>
<p>Functions implementing the examples of Overstall &amp; Woods (2017).</p></a></li>
<li><a href='#plot.ace'>
<p>Plot <code>ace</code> Objects</p></a></li>
<li><a href='#plot.assess'>
<p>Plot <code>assess</code> Objects</p></a></li>
<li><a href='#utilities'>
<p>Approximate expected utility function for generalised linear models and non-linear regression models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Bayesian Experimental Design using the ACE Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Antony M. Overstall, David C. Woods, Maria Adamou &amp; Damianos Michaelides</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antony M. Overstall &lt;A.M.Overstall@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimal Bayesian experimental design using the approximate coordinate exchange (ACE) algorithm. See &lt;<a href="https://doi.org/10.18637%2Fjss.v095.i13">doi:10.18637/jss.v095.i13</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), lhs</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.9), compare, randtoolbox, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.9.100.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-04 08:29:40 UTC; amo105</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-05 08:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ace'>
Approximate Coordinate Exchange (ACE) Algorithm
</h2><span id='topic+ace'></span><span id='topic+pace'></span><span id='topic+acephase1'></span><span id='topic+acephase2'></span>

<h3>Description</h3>

<p>These functions implement the approximate coordinate exchange (ACE) algorithm (Overstall &amp; Woods, 2017) for finding optimal Bayesian experimental designs by maximising an approximation to an intractable expected utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ace(utility, start.d, B, Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
limits = NULL, progress = FALSE, binary = FALSE, deterministic = FALSE)

acephase1(utility, start.d, B, Q = 20, N1 = 20, lower, upper, limits = NULL, 
progress = FALSE, binary = FALSE, deterministic = FALSE)

acephase2(utility, start.d, B, N2 = 100, progress = FALSE, binary = FALSE, 
deterministic = FALSE)

pace(utility, start.d, B, Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
limits = NULL, binary = FALSE, deterministic = FALSE, mc.cores = 1, 
n.assess = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ace_+3A_utility">utility</code></td>
<td>

<p>A function with two arguments: <code>d</code> and <code>B</code>. 
</p>
<p>For a Monte Carlo approximation (<code>deterministic = FALSE</code>), it should return a <em><b>vector</b></em> of length <code>B</code> where each element gives the value of the utility function for design <code>d</code>, for a value generated from the joint distribution of all unknown quantities. The mean of the elements of this vector provides a Monte Carlo approximation to the expected utility for design <code>d</code>.
</p>
<p>For a deterministic approximation (<code>deterministic = TRUE</code>), it should return a <em><b>scalar</b></em> giving the approximate value of the expected utility for design <code>d</code>. In this latter case, the argument <code>B</code> can be a list containing tuning parameters for the deterministic approximation. If <code>B</code> is not required, the utility function must still accept the argument.
</p>
</td></tr>
<tr><td><code id="ace_+3A_start.d">start.d</code></td>
<td>

<p>For <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>, an <code>n</code> by <code>k</code> matrix specifying the initial design for the ACE algorithm.
</p>
<p>For <code>pace</code>, a list with each element being an <code>n</code> by <code>k</code> matrix specifying the initial design for each repetition of the ACE algorithm.
</p>
</td></tr>
<tr><td><code id="ace_+3A_b">B</code></td>
<td>

<p>An argument for controlling the approximation to the expected utility.
</p>
<p>For a Monte Carlo approximation (<code>deterministic = FALSE</code>), a vector of length two specifying the size of the Monte Carlo samples, generated from the joint distribution of unknown quantities. The first sample size, <code>B[1]</code>, gives the sample size to use in the comparison procedures, and the second sample size, <code>B[2]</code>, gives the sample size to use for the evaluations of Monte Carlo integration that are used to fit the Gaussian process emulator. If missing when <code>deterministic = FALSE</code>, the default value is <code>c(20000,1000)</code>. 
</p>
<p>For a deterministic approximation (<code>deterministic = TRUE</code>), then <code>B</code> may be a list of length two containing any necessary tuning parameters for the expected utility calculations for the comparison and emulation steps.
</p>
</td></tr>
<tr><td><code id="ace_+3A_q">Q</code></td>
<td>

<p>An integer specifying the number of evaluations of the approximate expected utility that are used to fit the Gaussian process emulator. The default value is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="ace_+3A_n1">N1</code></td>
<td>

<p>An integer specifying the number of iterations of Phase I of the ACE algorithm (the coordinate exchange phase). 
The default value is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="ace_+3A_n2">N2</code></td>
<td>

<p>An integer specifying the number of iterations of Phase II of the ACE algorithm (the point exchange phase).
The default value is <code>100</code>. 
</p>
</td></tr>
<tr><td><code id="ace_+3A_lower">lower</code></td>
<td>

<p>An argument specifying the bounds on the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the lower limits of all coordinates of the design space. The default value is -1.
</p>
</td></tr>
<tr><td><code id="ace_+3A_upper">upper</code></td>
<td>

<p>An argument specifying the bounds on the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the upper limits of all coordinates of the design space. The default value is 1.
</p>
</td></tr>
<tr><td><code id="ace_+3A_limits">limits</code></td>
<td>

<p>An argument specifying the grid over which to maximise the Gaussian process emulator for the expected utility function. It should be a function with three arguments: <code>i</code>, <code>j</code> and <code>d</code> which generates a one-dimensional grid for the <code>ij</code>th coordinate of the design when the current design is <code>d</code>. The default value is NULL which generates values uniformly on the interval <code>(lower[i,j],upper[i,j])</code> or <code>(lower,upper)</code> depending on whether the arguments <code>lower</code> and <code>upper</code> are matrices or scalars, respectively.
</p>
</td></tr>
<tr><td><code id="ace_+3A_progress">progress</code></td>
<td>

<p>A logical argument indicating whether the iteration number and other information detailing the progress of the algorithm should be printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="ace_+3A_binary">binary</code></td>
<td>

<p>A logical argument indicating whether the utility function has binary or continuous output. In some cases, the utility function is an indicator function of some event giving binary output. The expected utility function will then be the expected posterior probability of the event. Utility functions such as Shannon information gain and negative squared error loss give continuous output. The type of output guides the choice of comparison procedure used in the ACE algorithm. The default value is <code>FALSE</code>, indicating the utility function has continuous output.
</p>
</td></tr>
<tr><td><code id="ace_+3A_deterministic">deterministic</code></td>
<td>

<p>A logical argument indicating if a Monte Carlo (<code>FALSE</code>, default) or deterministic (<code>TRUE</code>) approximation to the expected utility is being used. 		
</p>
</td></tr>
<tr><td><code id="ace_+3A_mc.cores">mc.cores</code></td>
<td>

<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one (the default), and parallelisation requires at least two cores. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for more information and warnings for <code>mc.cores</code> &gt; 1. 	
</p>
</td></tr>
<tr><td><code id="ace_+3A_n.assess">n.assess</code></td>
<td>

<p>If <code>deterministic = FALSE</code>, the approximate expected utility for the design from each repetition of the ACE algorithm will be calculated <code>n.assess</code> times. The terminal design returned will be the design with the largest mean approximate expected utility calculated over the <code>n.assess</code> approximations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finding an optimal Bayesian experimental design (Chaloner &amp; Verdinelli, 1995) involves maximising 
an objective function given by the expectation of some appropriately chosen utility 
function with respect to the joint distribution of unknown quantities (including responses). This objective 
function is usually not available in closed form and the design space can be continuous and of high 
dimensionality.
</p>
<p>Overstall &amp; Woods (2017) proposed the approximate coordinate exchange (ACE) algorithm 
to approximately maximise the expectation of the utility function. ACE consists of
two phases.
</p>
<p>Phase I uses a continuous version of the coordinate exchange algorithm (Meyer &amp; 
Nachtsheim, 1995) to maximise an approximation to the expected utility. Very briefly, 
the approximate expected utility is sequentially maximised over each one-dimensional element
of the design space. The approximate expected utility is given by the predictive mean of a 
Gaussian process (GP) regression model (also known as an emulator or surrogate) fitted 
to a 'small' number (argument <code>Q</code>) of evaluations of either a Monte Carlo (MC) or deterministic (e.g. quadrature) approximation to the expected utility (the MC sample size or arguments for the deterministic approximation are given by <code>B</code>). A GP 
emulator is a statistical model and, similar to all statistical models, can be an 
inadequate representation of the underlying process (i.e. the expected utility). 
Instead of automatically accepting the new design given by the value that maximises 
the GP emulator, for MC approximations a Bayesian hypothesis test, independent of the GP emulator, is 
performed to assess whether the expected utility of the new design is larger than the 
current design. For deterministic approximations, the approximate expected utility is calculated for the new design, and compared to that for the current design.
</p>
<p>Phase I tends to produce clusters of design points. This is where, for example, two
design points are separated by small Euclidean distance. Phase II allows these points 
to be consolidated into a single repeated design point by using a point exchange 
algorithm (e.g Gotwalt et al., 2009) with a candidate set given by the final design 
from Phase I. In the same way as Phase I, comparisons of the expected loss between 
two designs is made on the basis of either a Bayesian hypothesis test or a direct comparison of deterministic approximations.
</p>
<p>The original Bayesian hypothesis test proposed by Overstall &amp; Woods (2017) is 
appropriate for utility functions with continuous output. Overstall et al. (2017) 
extended the idea to utility functions with binary output, e.g. the utility 
function is an indicator function for some event. The type of test can be specified by
the argument <code>binary</code>.
</p>
<p>Similar to all coordinate exchange algorithms, ACE should be repeated from different initial designs. The function 
<code>pace</code> will implement this where the initial designs are given by a list via the argument <code>start.d</code>. On the completion 
of the repetitions of ACE, <code>pace</code> will approximate the expected utility for all final designs and return the design (the terminal design) with the 
largest approximate expected utility.
</p>


<h3>Value</h3>

<p>The function will return an object of class <code>"ace"</code> (for functions <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>) or <code>"pace"</code> (for function <code>"pace"</code>) which is a list with the following components:
</p>
<table>
<tr><td><code>utility</code></td>
<td>

<p>The argument <code>utility</code>.
</p>
</td></tr>
<tr><td><code>start.d</code></td>
<td>

<p>The argument <code>start.d</code>.
</p>
</td></tr>
<tr><td><code>phase1.d</code></td>
<td>

<p>The design found from Phase I of the ACE algorithm (only for <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>).
</p>
</td></tr>
<tr><td><code>phase2.d</code></td>
<td>

<p>The design found from Phase II of the ACE algorithm (only for <code>ace</code>, <code>acephase1</code> and <code>acephase2</code>)..
</p>
</td></tr>
<tr><td><code>phase1.trace</code></td>
<td>

<p>A vector containing the approximated expected utility of the current design at each stage of Phase I of the ACE algorithm. This can be used to assess convergence for MC approximations.
If <code>deterministic = FALSE</code>, this will be the mean of a call to <code>utility</code> with <code>d</code> being the current design and <code>B</code> being equal to the argument <code>B[1]</code>. If <code>deterministic = TRUE</code>, 
this will be a call to <code>utility</code> with <code>d</code> being the current design.
</p>
<p>For <code>pace</code>, this will be <code>phase1.trace</code> for the terminal design.
</p>
</td></tr>
<tr><td><code>phase2.trace</code></td>
<td>

<p>A vector containing the approximated expected utility of the current design at each stage of Phase II of the ACE algorithm. This can be used to assess convergence for MC approximations.
If <code>deterministic = FALSE</code>, this will be the mean of a call to <code>utility</code> with <code>d</code> being the current design and <code>B</code> being equal to the argument <code>B[1]</code>. If <code>deterministic = TRUE</code>, 
this will be a call to <code>utility</code> with <code>d</code> being the current design.
</p>
<p>For <code>pace</code>, this will be <code>phase2.trace</code> for the terminal design.
</p>
</td></tr>
<tr><td><code>B</code></td>
<td>

<p>The argument <code>B</code>.	
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>

<p>The argument <code>Q</code>.
</p>
</td></tr>
<tr><td><code>N1</code></td>
<td>

<p>The argument <code>N1</code>.
</p>
</td></tr>
<tr><td><code>N2</code></td>
<td>

<p>The argument <code>N2</code>.
</p>
</td></tr>
<tr><td><code>glm</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>nlm</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>"NA"</code>.
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>If the object is a result of a direct call to <code>ace</code> then this is <code>"NA"</code>.
</p>
</td></tr>
<tr><td><code>time</code></td>
<td>

<p>Computational time (in seconds) to run the ACE algorithm.
</p>
</td></tr>
<tr><td><code>binary</code></td>
<td>

<p>The argument <code>binary</code>.
</p>
</td></tr>
<tr><td><code>deterministic</code></td>
<td>

<p>The argument <code>deterministic</code>.	
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>The terminal design (<code>pace</code> only).
</p>
</td></tr>
<tr><td><code>eval</code></td>
<td>

<p>If <code>deterministic = FALSE</code>, a vector containing <code>n.assess</code> approximations to the expected utility for the terminal design (<code>pace</code> only).
</p>
<p>If <code>deterministic = TRUE</code>, a scalar giving the approximate expected utility for the terminal design (<code>pace</code> only).
</p>
</td></tr>
<tr><td><code>final.d</code></td>
<td>

<p>A list of the same length as the argument <code>start.d</code>, where each element is the final design (i.e. <code>phase2.d</code>) for each repetition of the ACE algorithm (<code>pace</code> only).
</p>
</td></tr>
<tr><td><code>besti</code></td>
<td>

<p>A scalar indicating which repetition of the ACE algorithm resulted in the terminal design (<code>pace</code> only).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For more details on the <code>R</code> implementation of the utility function used in the <b>Examples</b> section, see <code><a href="#topic+utilcomp18bad">utilcomp18bad</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian Experimental Design: A Review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C., Jones, B. &amp; Steinberg, D. (2009). Fast Computation of Designs Robust to Parameter
Uncertainty for Nonlinear Settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The Coordinate Exchange Algorithm for Constructing Exact
Optimal Experimental Designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>
<p>Overstall, A.M., McGree, J.M. &amp; Drovandi, C.C. (2018). An approach for finding fully Bayesian optimal designs using normal-based approximations to loss functions. <em>Statistics and Computing</em>, <b>28</b>(2), 343-358.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Set seed for reproducibility.

## This example involves finding a pseudo-Bayesian D-optimal design for a 
## compartmental model with n = 18 runs. There are three parameters. 
## Two parameters have uniform priors and the third has a prior 
## point mass. For more details see Overstall &amp; Woods (2017).

start.d&lt;-optimumLHS(n = 18, k = 1)
## Create an initial design.

## Using a MC approximation
example1&lt;-ace(utility = utilcomp18bad, start.d = start.d, N1 = 1, N2 = 2, B = c(100, 20))
## Implement the ACE algorithm with 1 Phase I iterations and 2 Phase II
## iterations. The Monte Carlo sample sizes are 100 (for comparison) and 20 for
## fitting the GP emulator.

example1
## Produce a short summary.

#User-defined model &amp; utility 
#
#Number of runs = 18
#
#Number of factors = 1
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 2
#
#Computer time = 00:00:00

mean(utilcomp18bad(d = example1$phase2.d, B = 100))
## Calculate an approximation to the expected utility for the final design.
## Should get:

#[1] 9.254198

## Not run: 
plot(example1)
## Produces a trace plot of the current value of the expected utility. This
## can be used to assess convergence.

## End(Not run)

</code></pre>

<hr>
<h2 id='acebayes-package'>
Optimal Bayesian Experimental Design using the Approximate Coordinate Exchange (ACE) Algorithm
</h2><span id='topic+acebayes-package'></span><span id='topic+acebayes'></span>

<h3>Description</h3>

<p>Finding an optimal Bayesian experimental design (Chaloner &amp; Verdinelli, 1995) involves maximising 
an objective function given by the expectation of some appropriately chosen utility 
function with respect to the joint distribution of unknown quantities (including responses). This objective 
function is usually not available in closed form and the design space can be continuous and of high 
dimensionality.
</p>
<p>The <code>acebayes</code> package uses Approximate Coordinate Exchange (ACE; Overstall 
&amp; Woods, 2017) to maximise an approximation to the expectation of the utility function. 
In Phase I of the algorithm, a continuous version of the coordinate exchange 
algorithm (Meyer &amp; Nachtsheim, 1995) is used to maximise an approximation to 
expected utility. The approximation is given by the predictive mean of a Gaussian 
process (GP) emulator constructing using a 'small' number of approximate
evaluations of the expected utility function. In Phase II a point exchange 
algorithm is used to consolidate clusters of design points into repeated design 
points.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> acebayes</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.10</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-10-04</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-02-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The most important functions are as follows.
</p>

<ol>
<li>
<p><code><a href="#topic+ace">ace</a></code>
</p>
</li>
<li>
<p><code><a href="#topic+pace">pace</a></code>
</p>
</li>
<li>
<p><code><a href="#topic+aceglm">aceglm</a></code>
</p>
</li>
<li>
<p><code><a href="#topic+paceglm">paceglm</a></code>
</p>
</li>
<li>
<p><code><a href="#topic+acenlm">acenlm</a></code>
</p>
</li>
<li>
<p><code><a href="#topic+pacenlm">pacenlm</a></code>
</p>
</li></ol>

<p>The function <code><a href="#topic+ace">ace</a></code> implements both phases of the ACE algorithm. It has two mandatory arguments: <code>utility</code> (a function specifying the chosen utility function incorporating the joint distribution of unknown quantities) and <code>start.d</code> (the initial design). The function will return the final design from the algorithm, along with information to assess convergence. The function <code><a href="#topic+pace">pace</a></code> implements repetitions of the ACE algorithm from different starting designs (as specified by the <code>start.d</code> argument).
</p>
<p>The computational time of <code><a href="#topic+ace">ace</a></code> (and <code><a href="#topic+pace">pace</a></code>) is highly dependent on the computational time required to evaluate the user-supplied function <code>utility</code>. Therefore it is recommended that users take advantage of <code>R</code> packages such as <code>Rcpp</code> (Eddelbuettel &amp; Francois, 2011), <code>RcppArmadillo</code> (Eddelbuettel &amp; Sanderson, 2014), or <code>RcppEigen</code> (Bates &amp; Eddelbuettel, 2013), that provide convenient interfaces to compiled programming languages.
</p>
<p>The functions <code><a href="#topic+aceglm">aceglm</a></code> and <code><a href="#topic+acenlm">acenlm</a></code> are user-friendly wrapper functions for <code><a href="#topic+ace">ace</a></code> which use the ACE algorithm to find Bayesian optimal experimental designs for generalised linear models and non-linear models, respectively. As special cases, both of these functions can find pseudo-Bayesian optimal designs. The functions <code><a href="#topic+paceglm">paceglm</a></code> and <code><a href="#topic+pacenlm">pacenlm</a></code> implement repetitions of the ACE algorithm from different starting designs (as specified by the <code>start.d</code> argument) for generalised linear models and non-linear models, respectively.
</p>
<p>For more details on the underpinning methodology, see Overstall &amp; Woods (2017), and for more information on the <code>acebayes</code> package, see Overstall et al (2020).
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>
<p>Maintainer: Antony. M.Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>
</p>


<h3>References</h3>

<p>Bates, D. &amp; Eddelbuettel, D. (2013). Fast and Elegant Numerical Linear Algebra Using the 
RcppEigen Package. <em>Journal of Statistical Software</em>, <b>52(5)</b>, 1-24. 
<a href="https://www.jstatsoft.org/v52/i05/">https://www.jstatsoft.org/v52/i05/</a>
</p>
<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian Experimental Design: A Review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Eddelbuettel, D. &amp; Francois, R. (2011). Rcpp: Seamless R and C++ Integration. 
<em>Journal of Statistical Software</em>, <b>40(8)</b>, 1-18. <a href="https://www.jstatsoft.org/v40/i08/">https://www.jstatsoft.org/v40/i08/</a>
</p>
<p>Eddelbuettel, D. &amp; Sanderson, C. (2014). RcppArmadillo: Accelerating R with high-performance 
C++ linear algebra. <em>Computational Statistics and Data Analysis</em>, <b>71</b>, 1054-1063.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The Coordinate Exchange Algorithm for Constructing Exact
Optimal Experimental Designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>
<p>Overstall, A.M., Woods, D.C. &amp; Adamou, M. (2020). acebayes: An R Package for Bayesian Optimal Design of Experiments via Approximate Coordinate Exchange. <em>Journal of Statistical Software</em>, <b>95</b> (13), 1-33 <a href="https://www.jstatsoft.org/v095/i13/">https://www.jstatsoft.org/v095/i13/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example uses aceglm to find a pseudo-Bayesian D-optimal design for a 
## first-order logistic regression model with 6 runs 4 factors (i.e. 5 parameters).
## The priors are those used by Overstall &amp; Woods (2017), i.e. a uniform prior 
## distribution is assumed for each parameter. The design space for each coordinate 
## is [-1, 1].

set.seed(1)
## Set seed for reproducibility.

n&lt;-6
## Specify the sample size (number of runs).

start.d&lt;-matrix(2 * randomLHS(n = n,k = 4) - 1, nrow = n, ncol = 4,
dimnames = list(as.character(1:n), c("x1", "x2", "x3", "x4")))
## Generate an initial design of appropriate dimension. The initial design is a 
## Latin hypercube sample.

low&lt;-c(-3, 4, 5, -6, -2.5)
upp&lt;-c(3, 10, 11, 0, 3.5)
## Lower and upper limits of the uniform prior distributions.

prior&lt;-function(B){
t(t(6*matrix(runif(n = 5*B), ncol = 5)) + low)}
## Create a function which specifies the prior. This function will return a 
## B by 5 matrix where each row gives a value generated from the prior 
## distribution for the model parameters.

example&lt;-aceglm(formula = ~ x1 + x2 + x3 + x4,  start.d = start.d, family = binomial, 
prior = prior , criterion = "D", method= "MC", B = c(1000,1000), N1 = 1, N2 = 0, 
upper = 1)
## Call the aceglm function which implements the ACE algorithm requesting 
## only one iteration of Phase I and zero iterations of Phase II (chosen for 
## illustrative purposes). The Monte Carlo sample size for the comparison 
## procedure (B[1]) is set to 1000 (chosen again for illustrative purposes).

example
## Print out a short summary. 

#Generalised Linear Model
#Criterion = Bayesian D-optimality 
#
#Number of runs = 6
#
#Number of factors = 4
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 0
#
#Computer time = 00:00:02

## The final design found is:

example$phase2.d

#          x1          x2          x3         x4
#1 -0.4735783  0.12870470 -0.75064318  1.0000000
#2 -0.7546841  0.78864527  0.58689270  0.2946728
#3 -0.7463834  0.33548985 -0.93497463 -0.9573198
#4  0.4446617 -0.29735212  0.74040030  0.2182800
#5  0.8459424 -0.41734194 -0.07235575 -0.4823212
#6  0.6731941  0.05742842  1.00000000 -0.1742566
</code></pre>

<hr>
<h2 id='aceglm'>
Approximate Coordinate Exchange (ACE) Algorithm for Generalised Linear Models
</h2><span id='topic+aceglm'></span><span id='topic+paceglm'></span>

<h3>Description</h3>

<p>Functions implementing the approximate coordinate exchange (ACE) algorithm (Overstall &amp; Woods, 2017) for finding Bayesian optimal experimental designs for generalised linear models (GLMs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aceglm(formula, start.d, family, prior, B, 
criterion = c("D", "A", "E", "SIG", "NSEL", "SIG-Norm", "NSEL-Norm"),
method = c("quadrature", "MC"), Q = 20, N1 = 20, N2 = 100, lower = -1, 
upper = 1, progress = FALSE, limits = NULL)

paceglm(formula, start.d, family, prior, B, 
criterion = c("D", "A", "E", "SIG", "NSEL", "SIG-Norm", "NSEL-Norm"),
method = c("quadrature", "MC"), Q = 20, N1 = 20, N2 = 100, lower = -1, 
upper = 1, limits = NULL, mc.cores = 1, n.assess = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aceglm_+3A_formula">formula</code></td>
<td>

<p>An object of class <code>"formula"</code>: a symbolic description of the model. The terms should correspond to the column names of the argument <code>start.d</code>.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_start.d">start.d</code></td>
<td>

<p>For <code>aceglm</code>, an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for the ACE algorithm.
</p>
<p>For <code>paceglm</code>, a list with each element being an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for each repetition of the ACE algorithm.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_family">family</code></td>
<td>

<p>A description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_prior">prior</code></td>
<td>

<p>An argument specifying the prior distribution.  	
</p>
<p>For <code>method = "MC"</code>, a function with one argument: <code>B</code>; a scalar integer. This function should return a <code>B</code> by <code>p</code> matrix, with <code>p</code> the number of model parameters, containing a random sample from the prior distribution of the parameters. The value of <code>p</code> should correspond to the number of terms specified by the <code>formula</code> argument.
</p>
<p>For <code>method = "quadrature"</code>, a list specifying a normal or uniform prior for the model parameters. For a normal prior distribution, the list should have named entries <code>mu</code> and <code>sigma2</code> specifying the prior mean and variance-covariance matrix. The prior mean may be specified as a scalar, which will then be replicated to form an vector of common prior means, or a vector of length <code>p</code>. The prior variance-covariance matrix may be specified as either a scalar common variance or a vector of length <code>p</code> of variances (for independent prior distributions) or as a <code>p</code> by <code>p</code> matrix. For a uniform prior distribution, the list should have a named entry <code>support</code>, a <code>2</code> by <code>p</code> matrix with each column giving the lower and upper limits of the support of the independent continuous uniform distribution for the corresponding parameter.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_b">B</code></td>
<td>

<p>An optional argument for controlling the approximation to the expected utility. It should be a vector of length two. 
</p>
<p>For <code>method = "MC"</code>, it specifies the size of the Monte Carlo samples, generated from the joint distribution of unknown quantities. The first sample size, <code>B[1]</code>, gives the sample size to use in the comparison procedures, and the second sample size, <code>B[2]</code>, gives the sample size to use for the evaluations of Monte Carlo integration that are used to fit the Gaussian process emulator. If left unspecified, the default value is <code>c(20000,1000)</code>.
</p>
<p>For <code>method = "quadrature"</code>, it specifies the tuning parameters (numbers of radial abscissas and random rotations) for the implemented quadrature method; see <b>Details</b> for more information. If left unspecified, the default value is <code>c(2, 8)</code>.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_criterion">criterion</code></td>
<td>

<p>An optional character argument specifying the utility function. There are currently seven utility functions implemented as follows:
</p>

<ol>
<li>
<p><b>pseudo-Bayesian D-optimality</b> (<code>criterion = "D"</code>);
</p>
</li>
<li>
<p><b>pseudo-Bayesian A-optimality</b> (<code>criterion = "A"</code>);
</p>
</li>
<li>
<p><b>pseudo-Bayesian E-optimality</b> (<code>criterion = "E"</code>).
</p>
</li>
<li>
<p><b>Shannon information gain</b> with Monte Carlo (MC) approximation to marginal likelihood (<code>criterion = "SIG"</code>);
</p>
</li>
<li>
<p><b>Shannon information gain</b> with normal-based Laplace approximation to marginal likelihood (<code>criterion = "SIG-Norm"</code>);
</p>
</li>
<li>
<p><b>negative squared error loss</b> with importance sampling approximation to posterior mean (<code>criterion = "NSEL"</code>);
</p>
</li>
<li>
<p><b>negative squared error loss</b> with normal-based approximation to posterior mean (<code>criterion = "NSEL-Norm"</code>);
</p>
</li></ol>

<p>If left unspecified, the default is <code>"D"</code> denoting pseudo-Bayesian D-optimality. See <b>Details</b> for more information. 
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_method">method</code></td>
<td>

<p>An optional character argument specifying the method of approximating the expected utility function. Current choices are <code>method = "quadrature"</code> for a deterministic quadrature approximation and <code>method = "MC"</code> for a stochastic Monte Carlo approximation. The first of these choices is <b>only</b> available when the argument <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code>. The second choice is available for all possible values of the argument <code>criterion</code>. If left unspecified, the argument defaults to <code>"quadrature"</code> for <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code> and to <code>"MC"</code> otherwise. See <b>Details</b> for more information. 
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_q">Q</code></td>
<td>

<p>An integer specifying the number of evaluations of the approximate expected utility that are used to fit the Gaussian process emulator. The default value is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_n1">N1</code></td>
<td>

<p>An integer specifying the number of iterations of Phase I of the ACE algorithm (the coordinate exchange phase). 
The default value is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_n2">N2</code></td>
<td>

<p>An integer specifying the number of iterations of Phase II of the ACE algorithm (the point exchange phase).
The default value is <code>100</code>. 
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_lower">lower</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the lower limits of all coordinates of the design space. The default value is -1.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_upper">upper</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the upper limits of all coordinates of the design space. The default value is 1.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_progress">progress</code></td>
<td>

<p>A logical argument indicating whether the iteration number and other information detailing the progress of the algorithm should be printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_limits">limits</code></td>
<td>

<p>An argument specifying the grid over which to maximise the Gaussian process emulator for the expected utility function. It should be a function with three arguments: <code>i</code>, <code>j</code> and <code>d</code> which generates a one-dimensional grid for the <code>ij</code>th coordinate of the design when the current design is <code>d</code>. The default value is NULL which generates values uniformly on the interval <code>(lower[i,j],upper[i,j])</code> or <code>(lower,upper)</code> depending on whether the arguments <code>lower</code> and <code>upper</code> are matrices or scalars, respectively.
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_mc.cores">mc.cores</code></td>
<td>

<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one (the default), and parallelisation requires at least two cores. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for more information and warnings for <code>mc.cores</code> &gt; 1. 	
</p>
</td></tr>
<tr><td><code id="aceglm_+3A_n.assess">n.assess</code></td>
<td>

<p>If <code>method = "MC"</code>, the approximate expected utility for the design from each repetition of the ACE algorithm will be calculated <code>n.assess</code> times. The terminal design returned will be the design with the largest mean approximate expected utility calculated over the <code>n.assess</code> approximations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>aceglm</code> function implements the ACE algorithm to find designs for the class of generalised linear models (GLMs) for certain cases of utility function meaning the user does not have to write their own utility function.
</p>
<p>Two utility functions are implemented.
</p>

<ol>
<li>
<p><b>Shannon information gain (SIG)</b> 
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{SIG}(d) = \pi(\theta|y,d) - \pi(\theta),</code>
</p>

<p>where <code class="reqn">\pi(\theta|y,d)</code> and <code class="reqn">\pi(\theta)</code> denote the posterior and prior densities of the parameters <code class="reqn">\theta</code>, respectively.
</p>
</li>
<li>
<p><b>Negative squared error loss (NSEL)</b>
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{NSEL}(d) = - \left(\theta - E(\theta |y,d)\right)^T \left(\theta - E(\theta |y,d)\right),</code>
</p>

<p>where <code class="reqn">E(\theta | y,d)</code> denotes the posterior mean of <code class="reqn">\theta</code>.
</p>
</li></ol>

<p>In both cases the utility function is not available in closed form due to the analytical intractability of either the posterior distribution (for SIG) or the posterior mean (for NSEL). The <code>acebayes</code> package implements two approximations to both utility functions. If <code>criterion = "SIG"</code> or <code>criterion = "NSEL"</code> then sampling-based Monte Carlo or importance sampling approximations will be employed. This was the original approach used by Overstall &amp; Woods (2017). If <code>criterion = "SIG-Norm"</code> or <code>criterion = "NSEL-Norm"</code> then approximations based on approximate normality of the posterior (Overstall et al., 2017) will be used.
</p>
<p>The normal approximation to the posterior can be taken further leading to the approximation by some scalar function of the Fisher information matrix, <code class="reqn">\mathcal{I} (\theta;d)</code>, which only depends on <code class="reqn">\theta</code> (Chaloner &amp; Verdinelli, 1995). In the case of SIG, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^{D}(d) = \log \vert \mathcal{I} (\theta;d) \vert,</code>
</p>

<p>and the resulting design is typically called pseudo-Bayesian D-optimal. For NSEL, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^A(d) = - \mathrm{tr} \left\{ \mathcal{I} (\theta;d)^{-1} \right\} </code>
</p>

<p>with the resulting design termed pseudo-Bayesian A-optimal. These designs are often used under the frequentist approach to optimal experimental design and so to complete the usual set, the following utility for finding a pseudo-Bayesian E-optimal design is also implemented:
</p>
<p style="text-align: center;"><code class="reqn">u^E(d) = \mathrm{min} \mbox{ } e\left(\mathcal{I} (\theta;d) \right),</code>
</p>

<p>where <code class="reqn">e()</code> denotes the function that calculates the eigenvalues of its argument.
</p>
<p>The expected utilities can be approximated using Monte Carlo methods (<code>method = "MC"</code> for all criteria) or using a deterministic quadrature method (<code>method = "quadrature"</code>, implemented for the D, A and E criteria). The former approach approximates the expected utility via sampling from the prior. The latter approach uses a radial-spherical integration rule (Monahan and Genz, 1997) and <code>B[1]</code> specifies the number, <code class="reqn">n_r</code>, of radial abscissas and <code>B[2]</code> specifies the number,  <code class="reqn">n_q</code>, of random rotations. Larger values of  <code class="reqn">n_r</code> will produce more accurate, but also more computationally expensive, approximations. See Gotwalt et al. (2009) for further details.   
</p>
<p>Note that the utility functions for SIG and NSEL are currently only implemented for logistic regression, i.e. <code>family = binomial</code>, or Poisson regression, i.e. <code>family = poisson(link="log")</code>, whereas the utility functions for pseudo-Bayesian designs are implemented for generic GLM families.
</p>
<p>Similar to all coordinate exchange algorithms, ACE should be repeated from different initial designs. The function 
<code>paceglm</code> will implement this where the initial designs are given by a list via the argument <code>start.d</code>. On the completion 
of the repetitions of ACE, <code>paceglm</code> will approximate the expected utility for all final designs and return the design (the terminal design) with the 
largest approximate expected utility.
</p>
<p>For more details on the ACE algorithm, see Overstall &amp; Woods (2017).
</p>


<h3>Value</h3>

<p>The function will return an object of class <code>"ace"</code> (for <code>aceglm</code>) or <code>"pace"</code> (for <code>paceglm</code>)  which is a list with the following components:
</p>
<table>
<tr><td><code>utility</code></td>
<td>

<p>The utility function resulting from the choice of arguments.
</p>
</td></tr>
<tr><td><code>start.d</code></td>
<td>

<p>The argument <code>start.d</code>.
</p>
</td></tr>
<tr><td><code>phase1.d</code></td>
<td>

<p>The design found from Phase I of the ACE algorithm.
</p>
</td></tr>
<tr><td><code>phase2.d</code></td>
<td>

<p>The design found from Phase II of the ACE algorithm.
</p>
</td></tr>
<tr><td><code>phase1.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase I of the ACE algorithm. This can be used to assess convergence.
</p>
</td></tr>
<tr><td><code>phase2.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase II of the ACE algorithm. This can be used to assess convergence.
</p>
</td></tr>
<tr><td><code>B</code></td>
<td>

<p>The argument <code>B</code>.	
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>

<p>The argument <code>Q</code>.
</p>
</td></tr>
<tr><td><code>N1</code></td>
<td>

<p>The argument <code>N1</code>.
</p>
</td></tr>
<tr><td><code>N2</code></td>
<td>

<p>The argument <code>N2</code>.
</p>
</td></tr>
<tr><td><code>glm</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>nlm</code></td>
<td>

<p>This will be <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>criterion</code>.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>method</code>.	
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>prior</code>.
</p>
</td></tr>
<tr><td><code>family</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>family</code>.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>formula</code>.	
</p>
</td></tr>
<tr><td><code>time</code></td>
<td>

<p>Computational time (in seconds) to run the ACE algorithm.
</p>
</td></tr>
<tr><td><code>binary</code></td>
<td>

<p>The argument <code>binary</code>. Will be <code>FALSE</code> for the utility functions currently implemented.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>The terminal design (<code>paceglm</code> only).
</p>
</td></tr>
<tr><td><code>eval</code></td>
<td>

<p>If <code>deterministic = "MC"</code>, a vector containing <code>n.assess</code> approximations to the expected utility for the terminal design (<code>paceglm</code> only).
</p>
<p>If <code>deterministic = "quadrature"</code>, a scalar giving the approximate expected utility for the terminal design (<code>paceglm</code> only).
</p>
</td></tr>
<tr><td><code>final.d</code></td>
<td>

<p>A list of the same length as the argument <code>start.d</code>, where each element is the final design (i.e. <code>phase2.d</code>) for each repetition of the ACE algorithm (<code>paceglm</code> only).
</p>
</td></tr>
<tr><td><code>besti</code></td>
<td>

<p>A scalar indicating which repetition of the ACE algorithm resulted in the terminal design (<code>paceglm</code> only).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These are wrapper functions for <code><a href="#topic+ace">ace</a></code> and <code><a href="#topic+pace">pace</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian experimental design: a review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C. M., Jones, B. A.  &amp; Steinberg, D. M. (2009). Fast computation of designs robust to parameter uncertainty for nonlinear settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The coordinate exchange algorithm for constructing exact
optimal experimental designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Monahan, J. and Genz, A. (1997). Spherical-radial integration rules for
Bayesian computation,” Journal of the American Statistical Association, 92, 664–674.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>
<p>Overstall, A.M., McGree, J.M. &amp; Drovandi, C.C. (2018). An approach for finding fully Bayesian optimal designs using normal-based approximations to loss functions. <em>Statistics and Computing</em>, <b>28</b>(2), 343-358.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+acenlm">acenlm</a></code>, <code><a href="#topic+pace">pace</a></code>, <code><a href="#topic+pacenlm">pacenlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example uses aceglm to find a Bayesian D-optimal design for a 
## first order logistic regression model with 6 runs 4 factors. The priors are 
## those used by Overstall &amp; Woods (2017), with each of the five
## parameters having a uniform prior. The design space for each coordinate is [-1, 1].

set.seed(1)
## Set seed for reproducibility.

n&lt;-6
## Specify the sample size (number of runs).

start.d&lt;-matrix(2 * randomLHS(n = n,k = 4) - 1,nrow = n,ncol = 4,
dimnames = list(as.character(1:n), c("x1", "x2", "x3", "x4")))
## Generate an initial design of appropriate dimension. The initial design is a 
## Latin hypercube sample.

low&lt;-c(-3, 4, 5, -6, -2.5)
upp&lt;-c(3, 10, 11, 0, 3.5)
## Lower and upper limits of the uniform prior distributions.

prior&lt;-function(B){
t(t(6*matrix(runif(n = 5 * B),ncol = 5)) + low)}
## Create a function which specifies the prior. This function will return a 
## B by 5 matrix where each row gives a value generated from the prior 
## distribution for the model parameters.

example1&lt;-aceglm(formula=~x1+x2+x3+x4, start.d = start.d, family = binomial, 
prior = prior, method = "MC", N1 = 1, N2 = 0, B = c(1000, 1000))
## Call the aceglm function which implements the ACE algorithm requesting 
## only one iteration of Phase I and zero iterations of Phase II. The Monte
## Carlo sample size for the comparison procedure (B[1]) is set to 100.

example1
## Print out a short summary.

#Generalised Linear Model 
#Criterion = Bayesian D-optimality 
#Formula: ~x1 + x2 + x3 + x4
#
#Family: binomial 
#Link function: logit 
#
#Method:  MC 
#
#B:  1000 1000 
#
#Number of runs = 6
#
#Number of factors = 4
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 0
#
#Computer time = 00:00:01

example1$phase2.d
## Look at the final design.

#          x1          x2          x3         x4
#1 -0.4735783  0.12870470 -0.75064318  1.0000000
#2 -0.7546841  0.78864527  0.58689270  0.2946728
#3 -0.7463834  0.33548985 -0.93497463 -0.9573198
#4  0.4446617 -0.29735212  0.74040030  0.2182800
#5  0.8459424 -0.41734194 -0.07235575 -0.4823212
#6  0.6731941  0.05742842  1.00000000 -0.1742566

prior2 &lt;- list(support = rbind(low, upp))
## A list specifying the parameters of the uniform prior distribution

example2&lt;-aceglm(formula = ~ x1 +x2 + x3 + x4, start.d = start.d, family = binomial, 
prior = prior2, N1 = 1, N2 = 0)
## Call the aceglm function with the default method of "quadrature"

example2$phase2.d
## Final design

#          x1          x2          x3         x4
#1 -0.4647271  0.07880018 -0.94648750  1.0000000
#2 -0.7102715  0.79827332  0.59848578  0.5564422
#3 -0.7645090  0.39778176 -0.74342036 -1.0000000
#4  0.4514632 -0.33687477  0.55066110  0.3994593
#5  0.7913559 -0.41856994  0.01321035 -0.8848135
#6  0.6337306  0.11578522  1.00000000  1.0000000

mean(example1$utility(d = example1$phase2.d, B = 20000))
#[1] -11.61105
mean(example2$utility(d = example2$phase2.d, B = 20000))
#[1] -11.19737
## Compare the two designs using the Monte Carlo approximation
</code></pre>

<hr>
<h2 id='acenlm'>
Approximate Coordinate Exchange (ACE) Algorithm for Non-Linear Models
</h2><span id='topic+acenlm'></span><span id='topic+pacenlm'></span>

<h3>Description</h3>

<p>Functions implementing the approximate coordinate exchange algorithm (Overstall &amp; Woods, 2017) for finding optimal Bayesian designs for non-linear regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acenlm(formula, start.d, prior, B, criterion = c("D", "A", "E", "SIG", "NSEL"), 
method = c("quadrature", "MC"),  Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
progress = FALSE, limits = NULL)

pacenlm(formula, start.d, prior, B, criterion = c("D", "A", "E", "SIG", "NSEL"), 
method = c("quadrature", "MC"),  Q = 20, N1 = 20, N2 = 100, lower = -1, upper = 1, 
limits = NULL, mc.cores = 1, n.assess = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acenlm_+3A_formula">formula</code></td>
<td>

<p>An object of class <code>"formula"</code>: a symbolic description of the model. The terms should correspond to the column names of the argument <code>start.d</code> and the argument <code>prior</code>.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_start.d">start.d</code></td>
<td>

<p>For <code>aceglm</code>, an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for the ACE algorithm.
</p>
<p>For <code>paceglm</code>, a list with each element, an <code>n</code> by <code>k</code> matrix, with column names used by the argument <code>formula</code>, specifying the initial design for each repetition of the ACE algorithm.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_prior">prior</code></td>
<td>

<p>An argument specifying the prior distribution.  	
</p>
<p>For <code>method = "MC"</code>, a function with one argument: <code>B</code>; a scalar integer. This function should return a <code>B</code> by <code>p</code> matrix (or <code>p+1</code> for <code>criterion = "SIG"</code> or <code>criterion = "NSEL"</code>), with <code>p</code> the number of model parameters, containing a random sample from the prior distribution of the parameters. The value of <code>p</code> should correspond to the number of terms specified by the <code>formula</code> argument. The column names must match the names of parameters in the <code>formula</code> argument. For <code>criterion="SIG"</code> or <code>criterion="NSEL"</code>, an extra column (named <code>sig2</code>) should contain a sample from the prior distribution of the error variance.
</p>
<p>For <code>method = "quadrature"</code>, a list specifying a normal or uniform prior for the model parameters. For a normal prior distribution, the list should have named entries <code>mu</code> and <code>sigma2</code> specifying the prior mean and variance-covariance matrix. The prior mean may be specified as a scalar, which will then be replicated to form an vector of common prior means, or a vector of length <code>p</code>. The prior variance-covariance matrix may be specified as either a scalar common variance or a vector of length <code>p</code> of variances (for independent prior distributions) or as a <code>p</code> by <code>p</code> matrix. The names attribute of <code>mu</code> must match the names of the parameters in the <code>formula</code> argument. For a uniform prior distribution, the list should have a named entry <code>support</code>, a <code>2</code> by <code>p</code> matrix with each column giving the lower and upper limits of the support of the independent continuous uniform distribution for the corresponding parameter. The column names of <code>support</code> must match the names of parameters in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_b">B</code></td>
<td>

<p>An optional argument for controlling the approximation to the expected utility. It should be a vector of length two. 
</p>
<p>For <code>criterion = "MC"</code>, it specifies the size of the Monte Carlo samples, generated from the joint distribution of unknown quantities. The first sample size, <code>B[1]</code>, gives the sample size to use in the comparison procedures, and the second sample size, <code>B[2]</code>, gives the sample size to use for the evaluations of Monte Carlo integration that are used to fit the Gaussian process emulator. If left unspecified, the default value is <code>c(20000,1000)</code>.
</p>
<p>For <code>criterion = "quadrature"</code>, it specifies the tuning parameters (numbers of radial abscissas and random rotations) for the implemented quadrature method; see <b>Details</b> for more information. If left unspecified, the default value is <code>c(2, 8)</code>.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_criterion">criterion</code></td>
<td>

<p>An optional character argument specifying the utility function. There are currently five utility functions implemented consisting of 
</p>

<ol>
<li>
<p><b>pseudo-Bayesian D-optimality</b> (<code>criterion = "D"</code>); 
</p>
</li>
<li>
<p><b>pseudo-Bayesian A-optimality</b> (<code>criterion = "A"</code>); 
</p>
</li>
<li>
<p><b>pseudo-Bayesian E-optimality</b> (<code>criterion = "E"</code>); 
</p>
</li>
<li>
<p><b>Shannon information gain</b> (<code>criterion = "SIG"</code>); 
</p>
</li>
<li>
<p><b>negative squared error loss</b> (<code>criterion = "NSEL"</code>). 
</p>
</li></ol>

<p>The default value is <code>"D"</code> denoting pseudo-Bayesian D-optimality. See <b>Details</b> for more information. 
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_method">method</code></td>
<td>

<p>An optional character argument specifying the method of approximating the expected utility function. Current choices are <code>method = "quadrature"</code> for a deterministic quadrature approximation and <code>method = "MC"</code> for a stochastic Monte Carlo approximation. The first of these choices is <b>only</b> available when the argument <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code>. The second choice is available for all possible values of the argument <code>criterion</code>. If left unspecified, the argument defaults to <code>"quadrature"</code> for <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code> and to <code>"MC"</code> otherwise. See <b>Details</b> for more information. 
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_q">Q</code></td>
<td>

<p>An integer specifying the number of evaluations of the approximate expected utility that are used to fit the Gaussian process emulator. The default value is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_n1">N1</code></td>
<td>

<p>An integer specifying the number of iterations of Phase I of the ACE algorithm (the coordinate exchange phase). 
The default value is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_n2">N2</code></td>
<td>

<p>An integer specifying the number of iterations of Phase II of the ACE algorithm (the point exchange phase).
The default value is <code>100</code>. 
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_lower">lower</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the lower limits of all coordinates of the design space. The default value is -1.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_upper">upper</code></td>
<td>

<p>An argument specifying the design space. This argument can either be a scalar or a matrix of the same dimension as the argument <code>start.d</code> which specifies the upper limits of all coordinates of the design space. The default value is 1.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_progress">progress</code></td>
<td>

<p>A logical argument indicating whether the iteration number should be printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_limits">limits</code></td>
<td>

<p>An argument specifying the grid over which to maximise the Gaussian process emulator for the expected utility function. It should be a function with three arguments: <code>i</code>, <code>j</code> and <code>d</code> which generates a one-dimensional grid for the <code>ij</code>th coordinate of the design when the current design is <code>d</code>. The default value is NULL which generates values uniformly on the interval <code>(lower[i,j],upper[i,j])</code> or <code>(lower,upper)</code> depending on whether the arguments <code>lower</code> and <code>upper</code> are matrices or scalars, respectively.
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_mc.cores">mc.cores</code></td>
<td>

<p>The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one (the default), and parallelisation requires at least two cores. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for more information and warnings for <code>mc.cores</code> &gt; 1. 	
</p>
</td></tr>
<tr><td><code id="acenlm_+3A_n.assess">n.assess</code></td>
<td>

<p>If <code>method = "MC"</code>, the approximate expected utility for the design from each repetition of the ACE algorithm will be calculated <code>n.assess</code> times. The terminal design returned will be the design with the largest mean approximate expected utility calculated over the <code>n.assess</code> approximations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>acenlm</code> function implements the ACE algorithm to find designs for general classes of nonlinear regression models with identically and independently normally distributed errors meaning the user does not have to write their own utility function.
</p>
<p>Two utility functions are implemented.
</p>

<ol>
<li>
<p><b>Shannon information gain (SIG)</b> 
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{SIG}(d) = \pi(\theta|y,d) - \pi(\theta),</code>
</p>

<p>where <code class="reqn">\pi(\theta|y,d)</code> and <code class="reqn">\pi(\theta)</code> denote the posterior and prior densities of the parameters <code class="reqn">\theta</code>, respectively.
</p>
</li>
<li>
<p><b>Negative squared error loss (NSEL)</b>
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{NSEL}(d) = - \left(\theta - E(\theta |y,d)\right)^T \left(\theta - E(\theta |y,d)\right),</code>
</p>

<p>where <code class="reqn">E(\theta | y,d)</code> denotes the posterior mean of <code class="reqn">\theta</code>.
</p>
</li></ol>

<p>In both cases the utility function is not available in closed form due to the analytical intractability of either the posterior distribution (for SIG) or the posterior mean (for NSEL). Sampling-based Monte Carlo or importance sampling approximations will be employed. This was the original approach used by Overstall &amp; Woods (2017). 
</p>
<p>A normal approximation to the posterior can be taken leading to the approximation by some scalar function of the Fisher information matrix, <code class="reqn">\mathcal{I} (\theta;d)</code>, which only depends on <code class="reqn">\theta</code> (Chaloner &amp; Verdinelli, 1995). In the case of SIG, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^{D}(d) = \log \vert \mathcal{I} (\theta;d) \vert,</code>
</p>

<p>and the resulting design is typically called pseudo-Bayesian D-optimal. For NSEL, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^A(d) = - \mathrm{tr} \left\{ \mathcal{I} (\theta;d)^{-1} \right\} </code>
</p>

<p>with the resulting design termed pseudo-Bayesian A-optimal. These designs are often used under the frequentist approach to optimal experimental design and so to complete the usual set, the following utility for finding a pseudo-Bayesian E-optimal design is also implemented:
</p>
<p style="text-align: center;"><code class="reqn">u^E(d) = \mathrm{min} \mbox{ } e\left(\mathcal{I} (\theta;d) \right),</code>
</p>

<p>where <code class="reqn">e()</code> denotes the function that calculates the eigenvalues of its argument.
</p>
<p>The expected utilities can be approximated using Monte Carlo methods (<code>method = "MC"</code> for all criteria) or using a deterministic quadrature method (<code>method = "quadrature"</code>, implemented for the D, A and E criteria). The former approach approximates the expected utility via sampling from the prior. The latter approach uses a radial-spherical integration rule (Monahan and Genz, 1997) and <code>B[1]</code> specifies the number, <code class="reqn">n_r</code>, of radial abscissas and <code>B[2]</code> specifies the number,  <code class="reqn">n_q</code>, of random rotations. Larger values of  <code class="reqn">n_r</code> will produce more accurate, but also more computationally expensive, approximations. See Gotwalt et al. (2009) for further details.   
</p>
<p>Similar to all coordinate exchange algorithms, ACE should be repeated from different initial designs. The function 
<code>pacenlm</code> will implement this where the initial designs are given by a list via the argument <code>start.d</code>. On the completion 
of the repetitions of ACE, <code>pacenlm</code> will approximate the expected utility for all final designs and return the design (the terminal design) with the 
largest approximate expected utility.
</p>
<p>For more details on the ACE algorithm, see Overstall &amp; Woods (2017).
</p>


<h3>Value</h3>

<p>The function will return an object of class <code>"ace"</code> (for <code>acenlm</code>) or <code>"pace"</code> (for <code>pacenlm</code>)  which is a list with the following components:
</p>
<table>
<tr><td><code>utility</code></td>
<td>

<p>The utility function resulting from the choice of arguments.
</p>
</td></tr>
<tr><td><code>start.d</code></td>
<td>

<p>The argument <code>start.d</code>.
</p>
</td></tr>
<tr><td><code>phase1.d</code></td>
<td>

<p>The design found from Phase I of the ACE algorithm.
</p>
</td></tr>
<tr><td><code>phase2.d</code></td>
<td>

<p>The design found from Phase II of the ACE algorithm.
</p>
</td></tr>
<tr><td><code>phase1.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase I of the ACE algorithm. This can be used to assess convergence.
</p>
</td></tr>
<tr><td><code>phase2.trace</code></td>
<td>

<p>A vector containing the evaluations of the approximate expected utility of the current design at each stage of Phase II of the ACE algorithm. This can be used to assess convergence.
</p>
</td></tr>
<tr><td><code>B</code></td>
<td>

<p>The argument <code>B</code>.	
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>

<p>The argument <code>Q</code>.
</p>
</td></tr>
<tr><td><code>N1</code></td>
<td>

<p>The argument <code>N1</code>.
</p>
</td></tr>
<tr><td><code>N2</code></td>
<td>

<p>The argument <code>N2</code>.
</p>
</td></tr>
<tr><td><code>glm</code></td>
<td>

<p>This will be <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code>nlm</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>criterion</code>.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>method</code>.	
</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>

<p>If the object is a result of a direct call to <code>aceglm</code> then this is the argument <code>prior</code>.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>If the object is a result of a direct call to <code>acenlm</code> then this is the argument <code>formula</code>.	
</p>
</td></tr>
<tr><td><code>time</code></td>
<td>

<p>Computational time (in seconds) to run the ACE algorithm.
</p>
</td></tr>
<tr><td><code>binary</code></td>
<td>

<p>The argument <code>binary</code>. Will be <code>FALSE</code> for the utility functions currently implemented.
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>The terminal design (<code>pacenlm</code> only).
</p>
</td></tr>
<tr><td><code>eval</code></td>
<td>

<p>If <code>deterministic = "MC"</code>, a vector containing <code>n.assess</code> approximations to the expected utility for the terminal design (<code>pacenlm</code> only).
</p>
<p>If <code>deterministic = "quadrature"</code>, a scalar giving the approximate expected utility for the terminal design (<code>pacenlm</code> only).
</p>
</td></tr>
<tr><td><code>final.d</code></td>
<td>

<p>A list of the same length as the argument <code>start.d</code>, where each element is the final design (i.e. <code>phase2.d</code>) for each repetition of the ACE algorithm (<code>pacenlm</code> only).
</p>
</td></tr>
<tr><td><code>besti</code></td>
<td>

<p>A scalar indicating which repetition of the ACE algorithm resulted in the terminal design (<code>pacenlm</code> only).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These are wrapper functions for <code><a href="#topic+ace">ace</a></code> and <code><a href="#topic+pace">pace</a></code>.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian experimental design: a review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C. M., Jones, B. A.  &amp; Steinberg, D. M. (2009). Fast computation of designs robust to parameter uncertainty for nonlinear settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Meyer, R. &amp; Nachtsheim, C. (1995). The coordinate exchange algorithm for constructing exact
optimal experimental designs. <em>Technometrics</em>, <b>37</b>, 60-69.
</p>
<p>Monahan, J. and Genz, A. (1997). Spherical-radial integration rules for
Bayesian computation,” Journal of the American Statistical Association, 92, 664–674.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+aceglm">aceglm</a></code>, <code><a href="#topic+pace">pace</a></code>, <code><a href="#topic+paceglm">paceglm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example uses aceglm to find a Bayesian D-optimal design for a 
## compartmental model with 6 runs 1 factor. The priors are 
## those used by Overstall &amp; Woods (2017). The design space for each 
## coordinate is [0, 24] hours.

set.seed(1)
## Set seed for reproducibility.

n&lt;-6
## Specify the sample size (number of runs).

start.d&lt;-matrix(24 * randomLHS(n = n, k = 1), nrow = n, ncol = 1,
dimnames = list(as.character(1:n), c("t")))
## Generate an initial design of appropriate dimension. The initial design is a 
## Latin hypercube sample.

low&lt;-c(0.01884, 0.298, 21.8)
upp&lt;-c(0.09884, 8.298, 21.8)
## Lower and upper limits of the support of the uniform prior distributions. Note that the prior
## for the third element is a point mass.

prior&lt;-function(B){
out&lt;-cbind(runif(n = B, min = low[1], max = upp[1]), runif(n = B, min = low[2],max = upp[2]),
runif(n = B, min = low[3], max = upp[3]))
colnames(out)&lt;-c("a", "b", "c")
out}

## Create a function which specifies the prior. This function will return a 
## B by 3 matrix where each row gives a value generated from the prior 
## distribution for the model parameters.

example1&lt;-acenlm(formula = ~ c*(exp( - a * t) - exp( - b * t)), start.d = start.d, prior = prior, 
N1 = 1, N2 = 0, B = c(1000, 1000), lower = 0, upper = 24, method = "MC")
## Call the acenlm function which implements the ACE algorithm requesting 
## only one iteration of Phase I and zero iterations of Phase II. The Monte
## Carlo sample size for the comparison procedure (B[1]) is set to 1000.

example1
## Print out a short summary.

#Non Linear Model 
#Criterion = Bayesian D-optimality 
#Formula: ~c * (exp(-a * t) - exp(-b * t))
#Method:  MC 
#
#B:  1000 1000 
#
#Number of runs = 6
#
#Number of factors = 1
#
#Number of Phase I iterations = 1
#
#Number of Phase II iterations = 0
#
#Computer time = 00:00:00

example1$phase2.d
## Look at the final design.

#           t
#1 19.7787011
#2  2.6431912
#3  0.2356938
#4  8.2471451
#5  1.4742319
#6 12.7062270

prior2 &lt;- list(support = cbind(rbind(low, upp)))
colnames(prior2$support) &lt;- c("a", "b", "c")
example2 &lt;- acenlm(formula = ~ c * (exp( - a * t) - exp( - b *t)), start.d = start.d, 
prior = prior2, lower = 0, upper = 24, N1 = 1, N2 = 0 )
## Call the acenlm function with the default method of "quadrature"

example2$phase2.d
## Final design

#           t
#1  0.5167335
#2  2.3194434
#3  1.5365409
#4  8.2471451
#5 21.9402670
#6 12.7062270

utility &lt;- utilitynlm(formula = ~c * (exp( - a * t) - exp( - b *t)), prior = prior, 
                            desvars = "t", method = "MC" )$utility
## create a utility function to compare designs

mean(utility(example1$phase1.d, B = 20000))
#[1] 12.13773
mean(utility(example2$phase1.d, B = 20000))
#[1] 11.19745
## Compare the two designs using the Monte Carlo approximation
</code></pre>

<hr>
<h2 id='aceobjects'>
Print and Summary of <code>ace</code> and <code>pace</code> Objects
</h2><span id='topic+print.ace'></span><span id='topic+summary.ace'></span><span id='topic+print.pace'></span><span id='topic+summary.pace'></span>

<h3>Description</h3>

<p>These functions print and summarise objects of class <code>"ace"</code> or <code>"pace"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ace'
print(x, ...)
## S3 method for class 'ace'
summary(object, ...)

## S3 method for class 'pace'
print(x, ...)
## S3 method for class 'pace'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aceobjects_+3A_x">x</code></td>
<td>

<p>An object of class <code>"ace"</code> or <code>"pace"</code>.
</p>
</td></tr>
<tr><td><code id="aceobjects_+3A_object">object</code></td>
<td>

<p>An object of class <code>"ace"</code> or <code>"pace"</code>.
</p>
</td></tr>
<tr><td><code id="aceobjects_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to and from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the object is a result of a direct call to <code><a href="#topic+aceglm">aceglm</a></code>, <code><a href="#topic+acenlm">acenlm</a></code>, <code><a href="#topic+paceglm">paceglm</a></code>, or <code><a href="#topic+pacenlm">pacenlm</a></code>, then the argument <code>criterion</code> will be printed, otherwise the statement <code>User-defined utility</code> will be printed.
</p>
<p>Also printed are the number of repetitions (<code>"pace"</code> objects only), runs, factors, Phase I and II iterations of the ACE algorithm and the computational time required.
</p>
<p>For more details on the ACE algorithm, see Overstall &amp; Woods (2017).
</p>


<h3>Note</h3>

<p>For examples see <code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+aceglm">aceglm</a></code>, and <code><a href="#topic+acenlm">acenlm</a></code>.</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+aceglm">aceglm</a></code>, <code><a href="#topic+acenlm">acenlm</a></code>, <code><a href="#topic+pace">pace</a></code>, <code><a href="#topic+paceglm">paceglm</a></code>, <code><a href="#topic+pacenlm">pacenlm</a></code>.
</p>

<hr>
<h2 id='assess'>
Compares two designs under the approximate expected utility
</h2><span id='topic+assess'></span><span id='topic+assess.ace'></span><span id='topic+assess.pace'></span>

<h3>Description</h3>

<p>Calculates approximations to the expected utility for two designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
assess(d1, d2, ...)

## S3 method for class 'ace'
assess(d1, d2, B = NULL, n.assess = 20, relative = TRUE, ...)

## S3 method for class 'pace'
assess(d1, d2, B = NULL, n.assess = 20, relative = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_+3A_d1">d1</code>, <code id="assess_+3A_d2">d2</code></td>
<td>

<p><code>d1</code> should be an object of class <code>"ace"</code> or <code>"pace"</code> and <code>d2</code> should be an object of class <code>"ace"</code>, <code>"pace"</code> or <code>"matrix"</code>. 
</p>
</td></tr>
<tr><td><code id="assess_+3A_b">B</code></td>
<td>

<p>An optional argument for controlling the approximation to the expected utility (see <code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+aceglm">aceglm</a></code> and <code><a href="#topic+acenlm">acenlm</a></code>). If left unspecified, the value is inherited from the argument <code>d1</code>.
</p>
</td></tr>
<tr><td><code id="assess_+3A_n.assess">n.assess</code></td>
<td>

<p>If <code>d1</code> was generated from a call to <code>(p)ace</code> with argument <code>deterministic = FALSE</code> or from a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>method</code> being <code>"MC"</code>, then <code>n.assess</code> is an optional argument giving the number of evaluations of the stochastic approximation to the expected utility. 
</p>
</td></tr>
<tr><td><code id="assess_+3A_relative">relative</code></td>
<td>

<p>An optional argument, for when <code>d1</code> was generated as a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>criterion</code> being <code>"A"</code>, <code>"D"</code> or <code>"E"</code>, controlling whether the measure of relative efficiency is calculated for <code>d1</code> relative to <code>d2</code> (<code>TRUE</code>; the default) or for <code>d2</code> relative to <code>d1</code> (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="assess_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to and from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of when <code>d1</code> was generated from a call to <code>(p)ace</code> with argument <code>deterministic = FALSE</code> or from a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>method</code> being <code>"MC"</code>, <code>n.assess</code> evaluations of the stochastic approximation to the expected utility will be calculated for each of the designs from <code>d1</code> and <code>d2</code>. Otherwise, one evaluation of the deterministic approximation to the expected utility will be calculated for each of the designs from <code>d1</code> and <code>d2</code>.
</p>
<p>In the case when <code>d1</code> was generated as a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>criterion</code> being <code>"A"</code>, <code>"D"</code> or <code>"E"</code>, the relative D-, E-, or A-efficiency of the two designs will be calculated. The direction of the relative efficiency can be controlled by the <code>relative</code> argument.
</p>


<h3>Value</h3>

<p>The function will an object of class <code>"assess"</code> which is a list with the following components:
</p>
<table>
<tr><td><code>U1</code></td>
<td>

<p>In the case of when <code>d1</code> was generated from a call to <code>(p)ace</code> with argument <code>deterministic = FALSE</code> or from a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>method</code> being <code>"MC"</code>, <code>U1</code> will be a vector of <code>n.assess</code> evaluations of the stochastic approximation to the expected utility for design <code>d1</code>. Otherwise, <code>U1</code> will be a scalar of one evaluation of the deterministic approximation to the expected utility for design <code>d1</code>.
</p>
</td></tr>
<tr><td><code>U2</code></td>
<td>

<p>In the case of when <code>d1</code> was generated from a call to <code>(p)ace</code> with argument <code>deterministic = FALSE</code> or from a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>method</code> being <code>"MC"</code>, <code>U2</code> will be a vector of <code>n.assess</code> evaluations of the stochastic approximation to the expected utility for design <code>d2</code>. Otherwise, <code>U2</code> will be a scalar of one evaluation of the deterministic approximation to the expected utility for design <code>d2</code>.
</p>
</td></tr>
<tr><td><code>eff</code></td>
<td>

<p>In the case when <code>d1</code> was generated as a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>criterion</code> being <code>"A"</code>, <code>"D"</code> or <code>"E"</code>, <code>eff</code> is a scalar of the relative D-, E-, or A-efficiency of the two designs. Otherwise it will be <code>NULL</code>. 
</p>
</td></tr>
<tr><td><code>d1</code></td>
<td>

<p>The argument <code>d1</code>.
</p>
</td></tr>
<tr><td><code>d2</code></td>
<td>

<p>The argument <code>d2</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+pace">pace</a></code>, <code><a href="#topic+aceglm">aceglm</a></code>, <code><a href="#topic+acenlm">acenlm</a></code>, <code><a href="#topic+paceglm">paceglm</a></code>, <code><a href="#topic+pacenlm">pacenlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example involves finding a Bayesian D-optimal design for a 
## compartmental model with n = 18 runs. There are three parameters. 
## Two parameters have uniform priors and the third has a prior 
## point mass. 

n &lt;- 18
k &lt;- 1
p &lt;- 3
set.seed(1)
start.d &lt;- randomLHS(n = n, k = k) * 24
colnames(start.d) &lt;- c("t")

a1&lt;-c(0.01884, 0.298)
a2&lt;-c(0.09884, 8.298)

prior &lt;- list(support = cbind(rbind(a1, a2), c(21.8, 21.8)))
colnames(prior[[1]]) &lt;- c("theta1", "theta2", "theta3") 

example &lt;- acenlm(formula = ~ theta3 * (exp( - theta1 * t) - exp( - theta2 * t)), 
start.d = start.d, prior = prior, lower = 0, upper = 24, N1 = 2, N2 = 0)

## Compute efficiency of final design compared to starting design.
assess(d1 = example, d2 = start.d)

## Should get 

# Approximate expected utility of d1 = 15.40583 
# Approximate expected utility of d2 = 11.26968 
# Approximate relative D-efficiency = 396.9804% 

</code></pre>

<hr>
<h2 id='assessobjects'>
Print and Summary of <code>assess</code> Objects
</h2><span id='topic+print.assess'></span><span id='topic+summary.assess'></span>

<h3>Description</h3>

<p>These functions print and summarise objects of class <code>"assess"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assess'
print(x, ...)
## S3 method for class 'assess'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assessobjects_+3A_x">x</code></td>
<td>

<p>An object of class <code>"assess"</code>.
</p>
</td></tr>
<tr><td><code id="assessobjects_+3A_object">object</code></td>
<td>

<p>An object of class <code>"assess"</code>.
</p>
</td></tr>
<tr><td><code id="assessobjects_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to and from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions both provide a print out with the following information.
</p>
<p>In the case of when <code>d1</code> was generated from a call to <code>(p)ace</code> with argument <code>deterministic = FALSE</code> or from a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>method</code> being <code>"MC"</code>, then the mean and standard deviation of the <code>n.assess</code> evaluations of the approximate expected utility for each of the designs <code>d1</code> and <code>d2</code> will be printed.
</p>
<p>Otherwise, one evaluation of the deterministic approximation to the expected utility will be printed for each of the designs from <code>d1</code> and <code>d2</code>. In the case when <code>d1</code> was generated as a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>criterion</code> being <code>"A"</code>, <code>"D"</code> or <code>"E"</code>, the relative D-, E-, or A-efficiency of the two designs will be also be printed.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess</a></code>
</p>

<hr>
<h2 id='overstallwoods'>
Functions implementing the examples of Overstall &amp; Woods (2017).
</h2><span id='topic+utilcomp18bad'></span><span id='topic+optdescomp18bad'></span><span id='topic+utilcomp15bad'></span><span id='topic+optdescomp15bad'></span><span id='topic+optdescomp15sig'></span><span id='topic+utilcomp15sig'></span><span id='topic+utilcomp15sigDRS'></span><span id='topic+optdescomp15sigDRS'></span><span id='topic+utillrbad'></span><span id='topic+optdeslrbad'></span><span id='topic+utillrsig'></span><span id='topic+inideslrsig'></span><span id='topic+optdeslrsig'></span><span id='topic+utillrbaa'></span><span id='topic+optdeslrbaa'></span><span id='topic+utillrnsel'></span><span id='topic+inideslrnsel'></span><span id='topic+optdeslrnsel'></span><span id='topic+utilhlrbad'></span><span id='topic+optdeshlrbad'></span><span id='topic+utilhlrsig'></span><span id='topic+inideshlrsig'></span><span id='topic+optdeshlrsig'></span><span id='topic+utilhlrbaa'></span><span id='topic+optdeshlrbaa'></span><span id='topic+utilhlrnsel'></span><span id='topic+inideshlrnsel'></span><span id='topic+optdeshlrnsel'></span><span id='topic+utilbeetle'></span><span id='topic+optdesbeetle'></span><span id='topic+utillinmod'></span><span id='topic+optdeslinmod'></span>

<h3>Description</h3>

<p>This suite of functions implement the examples in Overstall &amp; Woods (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
######## Compartmental model #################################

utilcomp18bad(d, B)
optdescomp18bad(type = "ACE")
utilcomp15bad(d, B)
optdescomp15bad()
utilcomp15sig(d, B)
optdescomp15sig()
utilcomp15sigDRS(d, B)
optdescomp15sigDRS()

######## Logistic regression model ###########################

utillrbad(d, B)
optdeslrbad(n, type = "ACE")
utillrsig(d, B)
inideslrsig(n, rep)
optdeslrsig(n)

utilhlrbad(d, B)
optdeshlrbad(n)
utilhlrsig(d, B)
inideshlrsig(n, rep)
optdeshlrsig(n)

utillrbaa(d, B)
optdeslrbaa(n)
utillrnsel(d, B)
inideslrnsel(n, rep)
optdeslrnsel(n)

optdeshlrbaa(n)
utilhlrbaa(d, B)
utilhlrnsel(d, B)
inideshlrnsel(n, rep)
optdeshlrnsel(n)

######## Beetle mortality experiment #########################

utilbeetle(d, B)
optdesbeetle(n)

######## Linear model ########################################

utillinmod(d, B)
optdeslinmod(n, type = "ACE")

##############################################################
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overstallwoods_+3A_d">d</code></td>
<td>

<p>An <code>n</code> by <code>k</code> matrix specifying the design matrix, where <code>n</code> and <code>k</code> denote the number of runs and factors, respectively. See <b>Details</b> and <b>Value</b> for the values that <code>n</code> and <code>k</code> can take for each of the examples. Each element of <code>d</code> is scaled to the interval [-1,1].
</p>
</td></tr>
<tr><td><code id="overstallwoods_+3A_n">n</code></td>
<td>

<p>The number of runs ins the experiment.
</p>
</td></tr>
<tr><td><code id="overstallwoods_+3A_rep">rep</code></td>
<td>

<p>A scalar integer in the set <code class="reqn">\left\{1,\dots,20\right\}</code> specifying the initial design.
</p>
</td></tr>
<tr><td><code id="overstallwoods_+3A_b">B</code></td>
<td>

<p>A scalar integer specifying the Monte Carlo sample size.
</p>
</td></tr>
<tr><td><code id="overstallwoods_+3A_type">type</code></td>
<td>

<p>An optional character argument specifying which design to return. 
</p>
<p>For <code>optdeslrbad</code>, possible values are <code>c("ACE","Gotwalt","Atkinson")</code>. If <code>"ACE"</code> (the default) then the design found by the ACE algorithm will be returned. If <code>"Gotwalt"</code> then the design published in Gotwalt et al (2009) is returned. If <code>"Atkinson"</code> then the design found by Atkinson et al (1993) is returned.
</p>
<p>For <code>optdeslinmod</code>, possible values are <code>c("ACE","BoxDraper")</code>. If <code>"ACE"</code> (the default) then the design found by the ACE algorithm will be returned. If <code>"BoxDraper"</code> then the true optimal design, as found by Box &amp; Draper (1971), will be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section provides details on the examples considered and the functions implemented in <code>acebayes</code>.
</p>
<p><b>Compartmental model</b>
</p>
<p>Compartmental models are used in Pharmokinetics to study how materials 
flow through an organism. A drug is administered to an individual or animal and then the 
amount present at a certain body location is measured at a set of <code>n</code> pre-determined sampling 
times (in hours). There is one design variable: sampling time. Therefore the design matrix <code>d</code> is 
an <code>n</code> by 1 matrix with elements controlling the <code>n</code> sampling times, i.e. the number of factors is
<code>k=1</code>.
</p>
<p>In Overstall &amp; Woods (2017), two different compartmental model examples are considered. The first (in the Supplementary Material) 
comes from Atkinson et al (1993) and Gotwalt et al (2009) where there are <code>n = 18</code> sampling times and interest 
lies in finding a Bayesian D-optimal design. The functions whose name includes <code>"comp18"</code> refer to this example.
</p>
<p>The second example (in Section 3.2) comes from Ryan et al (2014), where there are <code>n = 15</code> sampling times and 
the ultimate interest lies in finding an optimal design under the Shannon information gain utility. Also considered is the
Bayesian D-optimal design. The functions whose name includes <code>"comp15"</code> refer to this example. Note that Ryan et al (2014) used a dimension reduction scheme (DRS) to find optimal designs. The function whose name is suffixed by <code>"DRS"</code> refer to this situation.
</p>
<p><b>Logistic regression model</b>
</p>
<p>In Section 3.3 of Overstall &amp; Woods (2017), a first-order logistic regression model in <code>k = 4</code> factors and <code>n</code> runs is considered. Woods et al (2006) and Gotwalt et al (2009) considered generating Bayesian D-optimal designs for <code>n = 16</code> and <code>n = 48</code>. Overstall &amp; Woods (2017) extended this example by considering Bayesian A-optimal, Shannon information gain (SIG) and negative squared error loss (NSEL) utility functions, a range of number of runs from 6 to 48, and &quot;random effects&quot; to form a hierarchical logistic regression model.
</p>
<p><b>Beetle mortality experiment</b>
</p>
<p>Overstall &amp; Woods (2017, Section 3.4) considers generating an optimal design for a follow-up experiment. The original design and data (Bliss, 1935) involves administering different doses of poison to <code class="reqn">N = 8</code> groups of beetles. The number of beetles that die in each group are recorded. Six different models are considered formed from the combination of three link functions and two linear predictors (following the analysis of O'Hagan &amp; Forster, 2004). Interest lies in the quantity known as lethal dose 50 (LD50) which is the dose required to kill 50% of the beetles and is a function of the model parameters for a given model. Consider finding an optimal design for estimating LD50 under the negative squared error loss (NSEL) function for <code>n</code> new doses of poison (i.e. <code>k = 1</code> factor). The prior distribution is equivalent to the posterior distribution arising from the original data and includes model uncertainty.
</p>
<p><b>Linear model</b>
</p>
<p>In the supplementary material, Overstall &amp; Woods (2017) considers finding D-optimal designs for a second-order (i.e. <code>k = 2</code>) response surface in <code>n=6,7,8,9</code> runs. Note that the D-optimal design is equivalent to the optimal design under Shannon information gain and a non-informative prior distribution.
</p>
<p>The expected utility function in this case is available in closed form, i.e. it does not require approximation. Box &amp; Draper (1971) found optimal designs analytically for the number of runs considered here. Overstall &amp; Woods (2017) use this example to demonstrate the efficacy of the ACE algorithm.
</p>


<h3>Value</h3>

<p><b>Compartmental model</b>
</p>
<p>For the example in the Supplementary Material;
</p>

<ul>
<li>
<p>The function <code>utilcomp18bad</code> will return a vector of length <code>B</code> where each element is the value of the Bayesian D-optimal utility function (i.e. the log determinant of the Fisher information matrix) evaluated at a sample of size <code>B</code> generated from the prior distribution of the model parameters.
</p>
</li>
<li>
<p>The function <code>optdescomp18bad</code> will return an 18 by 1 matrix giving the optimal design (specified by the argument <code>type</code>). The elements will be scaled to be in the interval [-1, 1], i.e. a -1 corresponds to a sampling times of 0 hours, and 1 corresponds to a time of 24 hours.</p>
</li></ul>

<p>For the example in Section 3.2;
</p>

<ul>
<li>
<p>The function <code>utilcomp15bad</code> will return a vector of length <code>B</code> where each element is the value of the Bayesian D-optimal utility function (i.e. the log determinant of the Fisher information matrix) evaluated at a sample of size <code>B</code> generated from the prior distribution of the model parameters.
</p>
</li>
<li>
<p>The function <code>optdescomp15bad</code> will return an 15 by 1 matrix giving the optimal design (found using ACE) under Bayesian D-optimality. The elements will be scaled to be in the interval [-1, 1], i.e. a -1 corresponds to a sampling times of 0 hours, and 1 corresponds to a time of 24 hours.
</p>
</li>
<li>
<p>The function <code>utilcomp15sig</code> will return a vector of length <code>B</code> where each element is the value of the SIG utility function evaluated at a sample of size <code>B</code> generated from the joint distribution of model parameters and unobserved responses.
</p>
</li>
<li>
<p>The function <code>optdescomp15sig</code> will return an 18 by 1 matrix giving the optimal design (found using ACE) under the SIG utility. The elements will be scaled to be in the interval [-1, 1], i.e. a -1 corresponds to a sampling times of 0 hours, and 1 corresponds to a time of 24 hours.
</p>
</li>
<li>
<p>The function <code>utilcomp15sigDRS</code> will return a vector of length <code>B</code> where each element is the value of the SIG utility function (where a DRS has been used) evaluated at a sample of size <code>B</code> generated from the joint distribution of model parameters and unobserved responses. Here the Beta DRS (see Overstall &amp; Woods, 2017) has been used so <code>d</code> should be a 2 by 1 matrix containing the positive beta parameters.
</p>
</li>
<li>
<p>The function <code>optdescomp15sigDRS</code> will return a 2 by 1 matrix giving the optimal design (found using ACE) under the SIG utility, where a DRS has been used. The elements correspond to the parameters of a beta distribution.
</p>
</li></ul>

<p><b>Logistic regression model</b>
</p>
<p>A function whose name includes <code>"lr"</code> refers to standard logistic regression, whereas <code>"hlr"</code> refers to hierarchical logistic regression. Under standard logistic regression the possible values for the argument <code>n</code> can be any even integer between 6 and 48. For hierarchical logistic regression, <code>n</code> can be any integer divisible by 6 between 12 and 48. The function name also indicates the utility function:
</p>

<ul>
<li><p><code>"bad"</code>
Bayesian D-optimal
</p>
</li>
<li><p><code>"baa"</code>
Bayesian A-optimal
</p>
</li>
<li><p><code>"sig"</code>
Shannon information gain
</p>
</li>
<li><p><code>"nsel"</code>
Negative squared error loss</p>
</li></ul>

<p>The functions prefixed by <code>"util"</code> will return a vector of length <code>B</code> where each element is the utility function evaluated at a sample generated from the prior distribution of model parameters (for Bayesian D- and A-optimality) or the joint distribution of model parameters and unobserved responses (for SIG and NSEL).
</p>
<p>The functions prefixed by <code>"optdes"</code> will return an <code>n</code> by <code>k = 4</code> matrix giving the optimal design found by ACE. The designs given by this function are those reported on in Overstall &amp; Woods (2017). The function <code>optdeslrbad</code> will also return designs (for <code>n = 16, 48</code>) found by Woods et al (2006) and Gotwalt et al (2009) by specifying the <code>type</code> argument appropriately.
</p>
<p>The functions prefixed by <code>"inides"</code> will return an <code>n</code> by <code>k = 4</code> matrix giving an initial design for ACE to find the optimal designs under the SIG and NSEL utility functions. These are 20 designs found using ACE under approximations to the Bayesian A- and D-optimal utility functions, respectively. The argument <code>rep</code> specifies which of these 20 designs to use.
</p>
<p><b>Beetle mortality experiment</b>
</p>
<p>The function <code>utilbeetle</code> will return a vector of length <code>B</code> where each element is the value of the utility function for a sample generated from the joint distribution of the model parameters, model and unobserved responses.
</p>
<p>The function <code>optdesbeetle</code> will return an <code>n</code> by 1 matrix giving the optimal design under the NSEL utility function (found using ACE) for estimating the LD50. The elements will be scaled to be in the interval [-1, 1], where -1 corresponds to a dose of 1.6907, 0 to a dose of 1.7873 and 1 to a dose of 1.8839. The designs given by this function are those reported in Overstall &amp; Woods (2017) for <code>n</code> = 1, ..., 10.
</p>
<p><b>Linear model</b>
</p>
<p>The function <code>utillinmod</code> will return a vector of length <code>B</code> where each element is a realisation of a stochastic approximation to the expected utility.
</p>
<p>The function <code>optdeslinmod</code> will return an <code>n</code> by 2 matrix giving the D-optimal design (specified by the argument <code>type</code>). If <code>type = "ACE"</code>, the designs returned by this function are those found using the ACE algorithm and are reported in the Supplementary Material of Overstall &amp; Woods (2017), and if <code>type = "BoxDraper"</code>, the designs returned are the exact D-optimal designs.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Atkinson, A., Chaloner, K., Herzberg, A., &amp; Juritz, J. (1993). Experimental Designs for Properties
of a Compartmental Model. <em>Biometrics</em>, <b>49</b>, 325-337.
</p>
<p>Bliss, C. (1935). The calculation of the dosage-mortality curve. <em>Annals of Applied Biology</em>,
<b>22</b>, 134-167.
</p>
<p>Box, M. &amp; Draper, N. (1971). Factorial designs, the <code class="reqn">|F^T F|</code> criterion and some related matters. 
<em>Techometrics</em>, <b>13</b>, 731-742.
</p>
<p>Gotwalt, C., Jones, B. &amp; Steinberg, D. (2009). Fast Computation of Designs Robust to Parameter
Uncertainty for Nonlinear Settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>O'Hagan, A, &amp; Forster, J.J. (2004). <em>Kendall's Advanced Theory of Statistics, Volume 2B: Bayesian
Inference. 2nd edition</em>. John Wiley &amp; Sons.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>
<p>Ryan, E., Drovandi, C., Thompson, M., Pettitt, A. (2014). Towards Bayesian experimental design
for nonlinear models that require a large number of sampling times. <em>Computational
Statistics and Data Analysis</em>, <b>70</b>, 45-60.
</p>
<p>Woods, D.C., Lewis, S., Eccleston, J., Russell, K. (2006). Designs for Generalized Linear Models
With Several Variables and Model Uncertainty. <em>Technometrics</em>, <b>48</b>, 284-292.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+pace">pace</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######## Compartmental model #################################

set.seed(1)
## Set seed for reproducibility

d&lt;-optimumLHS(n = 18, k = 1) * 2 - 1
## Generate an 18-run design.

u&lt;-utilcomp18bad(d = d, B = 20000)
## Calculate the D-optimal utility function for a 
## sample of size 20000. 

u[1:5]
## Look at first 5 elements.
#[1] 14.283473 10.525390  4.126233  7.061498 12.793245

d0&lt;-optdescomp18bad( )
u0&lt;-utilcomp18bad(d = d0, B = 20000)
## Optimal design found by ACE and calculate the D-optimal 
## utility function for a sample of size 20000.

u0[1:5]
## Look at first 5 elements.
#[1] 15.04721 15.37141 16.84287 14.06750 14.01523

mean(u)
mean(u0)
## Calculate expected Bayesian D-optimal utility.

d&lt;-matrix(runif(2), ncol = 1)
## Generate two beta parameters.

u&lt;-utilcomp15sigDRS(d = d, B = 5)
u
## Calculate the SIG utility function for a 
## sample of size 5.
#[1] 17.652044  4.878998 19.919559 22.017760  5.600473

######## Logistic regression model ###########################

set.seed(1)
## Set seed for reproducibility

d&lt;-optimumLHS(n = 16,k = 4) * 2 - 1
## Generate an 16-run design.

u&lt;-utillrbad(d = d, B = 20000)
## Calculate the D-optimal utility function for a 
## sample of size 20000. 

u[1:5]
## Look at first 5 elements.
#[1] -11.630683  -5.748912  -9.554413 -10.150132  -7.940938

d0&lt;-optdeslrbad(16)
u0&lt;-utillrbad(d = d0, B = 20000)
## Optimal design found by ACE and calculate the D-optimal 
## utility function for a sample of size 20000.

u0[1:5]
## Look at first 5 elements.
#[1] -4.644116 -2.411431 -4.999891 -2.906558 -2.282687

mean(u)
mean(u0)
## Calculate expected Bayesian D-optimal utility.
#[1] -9.38253
#[1] -2.992012

######## Beetle mortality experiment #########################

set.seed(1)
## Set seed for reproducibility

d&lt;-optimumLHS(n = 10, k = 1)*2-1
## Generate a design of 10 doses with elements in [-1, 1]

utilbeetle(d = d, B = 5)
## Calculate the utility function for a sample of size 5.

#-4.720491e-06 -1.198955e-05 -1.681380e-05 -3.123498e-06 -1.412722e-05

d0&lt;-optdesbeetle(10)
d0
## Print out optimal design from Overstall &amp; Woods (2017) for 10 doses 

0.5*( d0 + 1)*( 1.8839 - 1.6907 ) + 1.6907
## On original scale.
#          [,1]
# [1,] 1.769957
# [2,] 1.769520
# [3,] 1.768641
# [4,] 1.777851
# [5,] 1.768641
# [6,] 1.769520
# [7,] 1.777851
# [8,] 1.765997
# [9,] 1.768641
#[10,] 1.768641

######## Linear model ########################################

set.seed(1)
## Set seed for reproducibility

d&lt;-cbind(rep(c( -1, 0, 1), each = 3), rep(c( -1, 0, 1), 3))
## Create a 9-run design which is the true D-optimal design

utillinmod(d = d, B = 5)
## Calculate the approximation to the true expected D-optimal utility 
## function for a sample of size 5. 

#[1]  7.926878  8.736976  7.717704 10.148613  8.882840

d0&lt;-optdeslinmod(9)
## Optimal D-optimal design found using ACE

X&lt;-cbind(1, d, d^2, d[,1] * d[,2])
X0&lt;-cbind(1, d0, d0^2, d0[,1] * d0[,2])
## Calculate model matrices under both designs

detX&lt;-determinant( t(X) %*% X)$modulus[1]
detX0&lt;-determinant( t(X0) %*% X0)$modulus[1]
## Calculate true expected D-optimal utility function for both designs

100 * exp( 0.2 * ( detX0 - detX ))
## Calculate D-efficiency of ACE design.

# 99.93107
</code></pre>

<hr>
<h2 id='plot.ace'>
Plot <code>ace</code> Objects
</h2><span id='topic+plot.ace'></span><span id='topic+plot.pace'></span>

<h3>Description</h3>

<p>This function plots objects of class <code>"ace"</code> or <code>"pace"</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ace'
plot(x, ...)

## S3 method for class 'pace'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ace_+3A_x">x</code></td>
<td>

<p>An object of class <code>"ace"</code> or <code>"pace"</code>.
</p>
</td></tr>
<tr><td><code id="plot.ace_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to and from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trace plot of the current evaluations of the approximate expected utility function. Separate lines are produced for the traces from Phases I and II of the ACE algorithm. 
</p>
<p>For objects of class <code>"pace"</code>, the evaluations of the approximate expected utility function are from the repetition which resulted in the terminal design (see <code><a href="#topic+pace">pace</a></code>, <code><a href="#topic+paceglm">paceglm</a></code>, and <code><a href="#topic+pacenlm">pacenlm</a></code> for more details).
</p>
<p>These trace plots can be used to assess convergence. See Overstall &amp; Woods (2017) for more details.
</p>


<h3>Note</h3>

<p>For an example see <code><a href="#topic+ace">ace</a></code>.</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ace">ace</a></code>, <code><a href="#topic+pace">pace</a></code>
</p>

<hr>
<h2 id='plot.assess'>
Plot <code>assess</code> Objects
</h2><span id='topic+plot.assess'></span>

<h3>Description</h3>

<p>This function plots objects of class <code>"assess"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'assess'
plot(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.assess_+3A_x">x</code></td>
<td>

<p>An object of class <code>"assess"</code>.
</p>
</td></tr>
<tr><td><code id="plot.assess_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to and from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the case of when <code>d1</code> was generated from a call to <code>(p)ace</code> with argument <code>deterministic = FALSE</code> or from a call to <code>(p)aceglm</code> or <code>(p)acenlm</code> with argument <code>method</code> being <code>"MC"</code>, then boxplots of the <code>n.assess</code> evaluations of the approximate expected utility for each of the designs <code>d1</code> and <code>d2</code> will be produced. Otherwise, a plot is not meaningful and a warning will be produced.
</p>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assess">assess</a></code>
</p>

<hr>
<h2 id='utilities'>
Approximate expected utility function for generalised linear models and non-linear regression models
</h2><span id='topic+utilitynlm'></span><span id='topic+utilityglm'></span>

<h3>Description</h3>

<p>Generates an approximate utility function for generalised linear models and non-linear regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilityglm(formula, family, prior, 
criterion = c("D", "A", "E", "SIG", "NSEL", "SIG-Norm", "NSEL-Norm"),
method = c("quadrature", "MC"), nrq)

utilitynlm(formula, prior, desvars, criterion =  c("D", "A", "E", "SIG", "NSEL"),
method = c("quadrature", "MC"), nrq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilities_+3A_formula">formula</code></td>
<td>

<p>An argument providing a symbolic description of the model.
</p>
<p>For <code>utilityglm</code>, an object of class <code>"formula"</code>: a symbolic description of the model. 
</p>
<p>For <code>utilitynlm</code>, an object of class <code>"formula"</code>: a symbolic description of the model. The terms should correspond to the argument <code>prior</code>
</p>
</td></tr>
<tr><td><code id="utilities_+3A_family">family</code></td>
<td>

<p>For <code>utilityglm</code>, a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)
</p>
</td></tr>
<tr><td><code id="utilities_+3A_prior">prior</code></td>
<td>

<p>An argument specifying the prior distribution.  	
</p>
<p>For <code>method = "MC"</code>, a function with one argument: <code>B</code>; a scalar integer. This function should return a <code>B</code> by <code>p</code> matrix (<code>p+1</code> for <code>criterion = "SIG"</code> or <code>criterion = "NSEL"</code>), with <code>p</code> the number of model parameters, containing a random sample from the prior distribution of the parameters. The value of <code>p</code> should correspond to the number of terms specified by the <code>formula</code> argument. For <code>utilitynlm</code>, the column names must match the names of parameters in the <code>formula</code> argument. For <code>utilitynlm</code>, if <code>criterion="SIG"</code>, <code>criterion="NSEL"</code>, <code>criterion="SIG-Norm"</code> or <code>criterion="NSEL-Norm"</code> then an extra column called <code>sig2</code> should be included with a sample from the error variance.
</p>
<p>For <code>method = "quadrature"</code>, a list specifying a normal or uniform prior for the model parameters. For a normal prior distribution, the list should have named entries <code>mu</code> and <code>sigma2</code> specifying the prior mean and variance-covariance matrix. The prior mean may be specified as a scalar, which will then be replicated to form an vector of common prior means, or a vector of length <code>p</code>. The prior variance-covariance matrix may be specified as either a scalar common variance or a vector of length <code>p</code> of variances (for independent prior distributions) or as a <code>p</code> by <code>p</code> matrix. For <code>utilitynlm</code>, the names attribute of <code>mu</code> must match the names of the parameters in the <code>formula</code> argument. For a uniform prior distribution, the list should have a named entry <code>support</code>, a <code>2</code> by <code>p</code> matrix with each column giving the lower and upper limits of the support of the independent continuous uniform distribution for the corresponding parameter. For <code>utilitynlm</code>, the column names of <code>support</code> must match the names of parameters in the <code>formula</code> argument.	
</p>
</td></tr>
<tr><td><code id="utilities_+3A_desvars">desvars</code></td>
<td>

<p>For <code>utilitynlm</code>, a character vector listing the design variables that appear in the argument <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="utilities_+3A_criterion">criterion</code></td>
<td>

<p>An optional character argument specifying the utility function. There are currently seven utility functions implemented as follows:
</p>

<ol>
<li>
<p><b>pseudo-Bayesian D-optimality</b> (<code>criterion = "D"</code>);
</p>
</li>
<li>
<p><b>pseudo-Bayesian A-optimality</b> (<code>criterion = "A"</code>);
</p>
</li>
<li>
<p><b>pseudo-Bayesian E-optimality</b> (<code>criterion = "E"</code>).
</p>
</li>
<li>
<p><b>Shannon information gain</b> with Monte Carlo (MC) approximation to marginal likelihood (<code>criterion = "SIG"</code>);
</p>
</li>
<li>
<p><b>Shannon information gain</b> with normal-based Laplace approximation to marginal likelihood (<code>criterion = "SIG-Norm"</code>, only for <code>utilityglm</code>));
</p>
</li>
<li>
<p><b>negative squared error loss</b> with importance sampling approximation to posterior mean (<code>criterion = "NSEL"</code>);
</p>
</li>
<li>
<p><b>negative squared error loss</b> with normal-based approximation to posterior mean (<code>criterion = "NSEL-Norm"</code>, only for <code>utilityglm</code>)) ;
</p>
</li></ol>

<p>The default value is <code>"D"</code> denoting pseudo-Bayesian D-optimality. See <b>Details</b> for more information. 
</p>
</td></tr>
<tr><td><code id="utilities_+3A_method">method</code></td>
<td>

<p>An optional character argument specifying the method of approximating the expected utility function. Current choices are <code>method = "quadrature"</code> for a deterministic quadrature approximation and <code>method = "MC"</code> for a stochastic Monte Carlo approximation. The first of these choices is <b>only</b> available when the argument <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code>. The second choice is available for all possible values of the argument <code>criterion</code>. If left unspecified, the argument defaults to <code>"quadrature"</code> for <code>criterion = "A"</code>, <code>"D"</code> or <code>"E"</code> and to <code>"MC"</code> otherwise. See <b>Details</b> for more information. 			
</p>
</td></tr>
<tr><td><code id="utilities_+3A_nrq">nrq</code></td>
<td>

<p>For <code>method = "quadrature"</code>, a vector of length two specifying the number of radial abscissas (<code>nrq[1]</code>) and quasi-random rotations (<code>nrq[2]</code>) required for the implemented quadrature scheme; see <b>Details</b> for more information. If left unspecified, the default value is <code>c(2, 8)</code>.	
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two utility functions are implemented.
</p>

<ol>
<li>
<p><b>Shannon information gain (SIG)</b> 
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{SIG}(d) = \pi(\theta|y,d) - \pi(\theta),</code>
</p>

<p>where <code class="reqn">\pi(\theta|y,d)</code> and <code class="reqn">\pi(\theta)</code> denote the posterior and prior densities of the parameters <code class="reqn">\theta</code>, respectively.
</p>
</li>
<li>
<p><b>Negative squared error loss (NSEL)</b>
</p>
<p>The utility function is
</p>
<p style="text-align: center;"><code class="reqn">u^{NSEL}(d) = - \left(\theta - E(\theta |y,d)\right)^T \left(\theta - E(\theta |y,d)\right),</code>
</p>

<p>where <code class="reqn">E(\theta | y,d)</code> denotes the posterior mean of <code class="reqn">\theta</code>.
</p>
</li></ol>

<p>In both cases the utility function is not available in closed form due to the analytical intractability of either the posterior distribution (for SIG) or the posterior mean (for NSEL). The <code>acebayes</code> package implements two approximations to both utility functions. If <code>criterion = "SIG"</code> or <code>criterion = "NSEL"</code> then sampling-based Monte Carlo or importance sampling approximations will be employed. This was the original approach used by Overstall &amp; Woods (2017). If <code>criterion = "SIG-Norm"</code> or <code>criterion = "NSEL-Norm"</code> then approximations based on approximate normality of the posterior (Overstall et al., 2017) will be used.
</p>
<p>The normal approximation to the posterior can be taken further leading to the approximation by some scalar function of the Fisher information matrix, <code class="reqn">\mathcal{I} (\theta;d)</code>, which only depends on <code class="reqn">\theta</code> (Chaloner &amp; Verdinelli, 1995). In the case of SIG, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^{D}(d) = \log \vert \mathcal{I} (\theta;d) \vert,</code>
</p>

<p>and the resulting design is typically called pseudo-Bayesian D-optimal. For NSEL, the approximate utility is given by
</p>
<p style="text-align: center;"><code class="reqn">u^A(d) = - \mathrm{tr} \left\{ \mathcal{I} (\theta;d)^{-1} \right\} </code>
</p>

<p>with the resulting design termed pseudo-Bayesian A-optimal. These designs are often used under the frequentist approach to optimal experimental design and so to complete the usual set, the following utility for finding a pseudo-Bayesian E-optimal design is also implemented:
</p>
<p style="text-align: center;"><code class="reqn">u^E(d) = \mathrm{min} \mbox{ } e\left(\mathcal{I} (\theta;d) \right),</code>
</p>

<p>where <code class="reqn">e()</code> denotes the function that calculates the eigenvalues of its argument.
</p>
<p>The expected utilities can be approximated using Monte Carlo methods (<code>method = "MC"</code> for all criteria) or using a deterministic quadrature method (<code>method = "quadrature"</code>, implemented for the D, A and E criteria). The former approach approximates the expected utility via sampling from the prior. The latter approach uses a radial-spherical integration rule (Monahan and Genz, 1997) and <code>B[1]</code> specifies the number, <code class="reqn">n_r</code>, of radial abscissas and <code>B[2]</code> specifies the number,  <code class="reqn">n_q</code>, of random rotations. Larger values of  <code class="reqn">n_r</code> will produce more accurate, but also more computationally expensive, approximations. See Gotwalt et al. (2009) for further details.   
</p>
<p>For <code>utilityglm</code>, note that the utility functions for SIG and NSEL are currently only implemented for logistic regression, i.e. <code>family = binomial</code>, or Poisson regression, i.e. <code>family = poisson(link = "log")</code>, whereas the utility functions for pseudo-Bayesian designs are implemented for generic GLM families.
</p>
<p>For more details on the ACE algorithm, see Overstall &amp; Woods (2017).
</p>


<h3>Value</h3>

<p>The function will return a list with the following components:
</p>
<table>
<tr><td><code>utility</code></td>
<td>

<p>The utility function resulting from the choice of arguments.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antony M. Overstall <a href="mailto:A.M.Overstall@soton.ac.uk">A.M.Overstall@soton.ac.uk</a>, David C. Woods, Maria Adamou &amp; Damianos Michaelides
</p>


<h3>References</h3>

<p>Chaloner, K. &amp; Verdinelli, I. (1995). Bayesian experimental design: a review. <em>Statistical
Science</em>, <b>10</b>, 273-304.
</p>
<p>Gotwalt, C. M., Jones, B. A.  &amp; Steinberg, D. M. (2009). Fast computation of designs robust to parameter uncertainty for nonlinear settings. <em>Technometrics</em>, <b>51</b>, 88-95.
</p>
<p>Monahan, J. and Genz, A. (1997). Spherical-radial integration rules for
Bayesian computation,” Journal of the American Statistical Association, 92, 664-674.
</p>
<p>Overstall, A.M. &amp; Woods, D.C. (2017). Bayesian design of experiments using
approximate coordinate exchange. <em>Technometrics</em>, <b>59</b>, 458-470.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aceglm">aceglm</a></code>, <code><a href="#topic+acenlm">acenlm</a></code>, <code><a href="#topic+paceglm">paceglm</a></code>, <code><a href="#topic+pacenlm">pacenlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1. This example uses utilityglm to generate the pseudo-Bayesian D-optimality
## approximate expected utility function using a Monte Carlo approximation.

low&lt;-c(-3, 4, 5, -6, -2.5)
upp&lt;-c(3, 10, 11, 0, 3.5)
## Lower and upper limits of the uniform prior distributions.

prior&lt;-function(B){
t(t(6*matrix(runif(n=5*B),ncol=5))+low)}
## Create a function which specifies the prior. This function will return a 
## B by 5 matrix where each row gives a value generated from the prior 
## distribution for the model parameters.

ex &lt;- utilityglm(formula = ~x1+x2+x3+x4, family = binomial, prior = prior, method = "MC")

set.seed(1)
## Set seed for reproducibility.

n&lt;-6
## Specify the sample size (number of runs).

start.d&lt;-matrix( 2 * randomLHS(n = n,k = 4) - 1,nrow = n,ncol = 4,
dimnames = list(as.character(1:n),c("x1", "x2", "x3", "x4")))
## Generate an initial design of appropriate dimension. The initial design is a 
## Latin hypercube sample.

ex$utility(d = start.d, B = 10)
## Evaluate resulting approximate utility. Should get:

#[1] -13.98143 -17.07772 -19.88988 -22.40720 -15.27411 -15.02717 -16.17253 -18.66600 -13.75118
#[10] -21.83820

## 2. This example uses utilitynlm to generate the psuedo-Bayesian A-optimality expected utility
## function using a quadrature approximation

low&lt;-c(0.01884, 0.298, 21.8)
upp&lt;-c(0.09884, 8.298, 21.8)
## Lower and upper limits of the uniform prior distributions. Note that the prior
## for the third element is a point mass.

prior2 &lt;- list(support = cbind(rbind(low, upp)))
colnames(prior2$support) &lt;- c("a", "b", "c")
## Specify a uniform prior with ranges given by low and upp

ex2 &lt;- utilitynlm(formula = ~ c * (exp( - a * t) - exp( - b *t)), prior = prior2, 
                            desvars = "t")
                            
n &lt;- 6
start.d &lt;- matrix(24 * randomLHS(n = n, k = 1), nrow = n)
colnames(start.d) &lt;- "t"
ex2$utility(d = start.d) 
## -13.17817    

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
