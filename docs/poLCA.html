<!DOCTYPE html><html><head><title>Help for package poLCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poLCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#carcinoma'><p>Diagnoses of carcinoma (sample data)</p></a></li>
<li><a href='#cheating'><p>GPA and chronic cheating (sample data)</p></a></li>
<li><a href='#election'><p>2000 National Election Studies survey (sample data)</p></a></li>
<li><a href='#gss82'><p>1982 General Social Survey (sample data)</p></a></li>
<li><a href='#poLCA'><p>Latent class analysis of polytomous outcome variables</p></a></li>
<li><a href='#poLCA.entropy'><p>Entropy of a fitted latent class model</p></a></li>
<li><a href='#poLCA.posterior'><p>Posterior probabilities from a latent class model</p></a></li>
<li><a href='#poLCA.predcell'><p>Predicted cell percentages in a latent class model</p></a></li>
<li><a href='#poLCA.reorder'><p>Reorder latent classes in poLCA</p></a></li>
<li><a href='#poLCA.simdata'><p>Create simulated cross-classification data</p></a></li>
<li><a href='#poLCA.table'><p>Frequency tables of predicted cell counts from latent class analysis</p></a></li>
<li><a href='#rmulti'><p>Random draws from a multinomial distribution</p></a></li>
<li><a href='#values'><p>Universalistic vs. particularistic values (sample data)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Polytomous Variable Latent Class Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Drew Linzer &lt;drew@votamatic.org&gt;, 
        Jeffrey Lewis &lt;jblewis@ucla.edu&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Drew Linzer &lt;drew@votamatic.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>scatterplot3d, MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Latent class analysis and latent class regression models 
    for polytomous outcome variables.  Also known as latent structure analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dlinzer/poLCA">https://github.com/dlinzer/poLCA</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-25 10:35:00 UTC; ripley</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-25 11:36:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='carcinoma'>Diagnoses of carcinoma (sample data)</h2><span id='topic+carcinoma'></span>

<h3>Description</h3>

<p>Dichotomous ratings by seven pathologists of 118 slides for the presence or absence of carcinoma in the uterine cervix. Pathologists are labeled <code>A</code> through <code>G</code>. There were 20 different observed response patterns. This data set appears in Agresti (2002, p. 542) as Table 13.1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carcinoma)</code></pre>


<h3>Format</h3>

<p>A data frame with 118 observations on 7 variables representing pathologist ratings with 1 denoting &quot;no&quot; and 2 denoting &quot;yes&quot;.</p>


<h3>Source</h3>

<p>Agresti, Alan. 2002. <em>Categorical Data Analysis, second edition</em>. Hoboken: John Wiley \&amp; Sons.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Replication of latent class models in Agresti (2002, p. 543), 
## Table 13.2 and Table 13.3.
##
data(carcinoma)
f &lt;- cbind(A,B,C,D,E,F,G)~1
lca2 &lt;- poLCA(f,carcinoma,nclass=2) # log-likelihood: -317.2568
lca3 &lt;- poLCA(f,carcinoma,nclass=3) # log-likelihood: -293.705
lca4 &lt;- poLCA(f,carcinoma,nclass=4,nrep=10,maxiter=5000) # log-likelihood: -289.2858 
</code></pre>

<hr>
<h2 id='cheating'>GPA and chronic cheating (sample data)</h2><span id='topic+cheating'></span>

<h3>Description</h3>

<p>Dichotomous responses by 319 undergraduates to four questions about cheating behavior, and each student's academic GPA.  
</p>
<p>Students responded either (1) no or (2) yes as to whether they had ever lied to avoid taking an exam (<code>LIEEXAM</code>), lied to avoid handing a term paper in on time (<code>LIEPAPER</code>), purchased a term paper to hand in as their own or had obtained a copy of an exam prior to taking the exam (<code>FRAUD</code>), or copied answers during an exam from someone sitting near to them (<code>COPYEXAM</code>).
</p>
<p>The <code>GPA</code> variable is partitioned into five groups: (1) 2.99 or less; (2) 3.00-3.25; (3) 3.26-3.50; (4) 3.51-3.75; (5) 3.76-4.00.
</p>
<p>This data set appears in Dayton (1998, pp. 33 and 85) as Tables 3.4 and 7.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cheating)</code></pre>


<h3>Format</h3>

<p>A data frame with 319 observations on 5 variables. Note: GPA data were not available for four students who reported never cheating.</p>


<h3>Source</h3>

<p>Dayton, C. Mitchell. 1998. <em>Latent Class Scaling Analysis</em>. Thousand Oaks, CA: SAGE Publications.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Replication of latent class models in Dayton (1998)
##
## Example 1. Two-class LCA. (Table 3.3, p. 32)
##
data(cheating)
f &lt;- cbind(LIEEXAM,LIEPAPER,FRAUD,COPYEXAM)~1
ch2 &lt;- poLCA(f,cheating,nclass=2)	# log-likelihood: -440.0271 

##
## Example 2. Two-class latent class regression using 
## GPA as a covariate to predict class membership as 
## "cheaters" vs. "non-cheaters".
## (Table 7.1, p. 85, and Figure 7.1, p. 86)
##
f2 &lt;- cbind(LIEEXAM,LIEPAPER,FRAUD,COPYEXAM)~GPA
ch2c &lt;- poLCA(f2,cheating,nclass=2)	# log-likelihood: -429.6384 
GPAmat &lt;- cbind(1,c(1:5))
exb &lt;- exp(GPAmat %*% ch2c$coeff)
matplot(c(1:5),cbind(1/(1+exb),exb/(1+exb)),type="l",lwd=2,
	main="GPA as a predictor of persistent cheating",
	xlab="GPA category, low to high",
	ylab="Probability of latent class membership")
text(1.7,0.3,"Cheaters")
text(1.7,0.7,"Non-cheaters")

##
## Compare results from Example 1 to Example 2.
## Non-simultaneous estimation of effect of GPA on latent class
## membership biases the estimated effect in Example 1. 
##
cheatcl &lt;- which.min(ch2$P)
predcc &lt;- sapply(c(1:5),function(v) mean(ch2$posterior[cheating$GPA==v,cheatcl],na.rm=TRUE))
## Having run Ex.2, add to plot:
matplot(c(1:5),cbind(1-predcc,predcc),type="l",lwd=2,add=TRUE)
text(4,0.14,"Cheaters\n (non-simul. estimate)")
text(4,0.87,"Non-cheaters\n (non-simul. estimate)")
</code></pre>

<hr>
<h2 id='election'>2000 National Election Studies survey (sample data)</h2><span id='topic+election'></span>

<h3>Description</h3>

<p>Survey data from the 2000 American National Election Study.  Two sets of six questions with four responses each, asking respondents' opinions of how well various traits (moral, caring, knowledgable, good leader, dishonest, intelligent) describe presidential candidates Al Gore and George W. Bush.  The responses are (1) Extremely well; (2) Quite well; (3) Not too well; (4) Not well at all.  Many respondents have varying numbers of missing values on these variables.
</p>
<p>The data set also includes potential covariates <code>VOTE3</code>, the respondent's 2000 vote choice (when asked); <code>AGE</code>, the respondent's age; <code>EDUC</code>, the respondent's level of education; <code>GENDER</code>, the respondent's gender; and <code>PARTY</code>, the respondent's Democratic-Republican partisan identification.
</p>
<p><code>VOTE3</code> is coded as (1) Gore; (2) Bush; (3) Other.
</p>
<p><code>EDUC</code> is coded as (1) 8 grades or less; (2) 9-11 grades, no further schooling; (3) High school diploma or equivalency; (4) More than 12 years of schooling, no higher degree; (5) Junior or community college level degree; (6) BA level degrees, no advanced degree; (7) Advanced degree.
</p>
<p><code>GENDER</code> is coded as (1) Male; (2) Female.
</p>
<p><code>PARTY</code> is coded as (1) Strong Democrat; (2) Weak Democrat; (3) Independent-Democrat; (4) Independent-Independent; (5) Independent-Republican; (6) Weak Republican; (7) Strong Republican.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(election)</code></pre>


<h3>Format</h3>

<p>A data frame with 1785 observations on 17 survey variables.  Of these, 1311 individuals provided responses on all twelve candidate evaluations.</p>


<h3>Source</h3>

<p>The National Election Studies (<a href="https://electionstudies.org/">https://electionstudies.org/</a>). THE 2000 NATIONAL ELECTION STUDY [dataset]. Ann Arbor, MI: University of Michigan, Center for Political Studies [producer and distributor].</p>


<h3>Examples</h3>

<pre><code class='language-R'># Latent class models with one (loglinear independence) to three classes
data(election)
f &lt;- cbind(MORALG,CARESG,KNOWG,LEADG,DISHONG,INTELG,
           MORALB,CARESB,KNOWB,LEADB,DISHONB,INTELB)~1
nes1 &lt;- poLCA(f,election,nclass=1)  # log-likelihood: -18647.31
nes2 &lt;- poLCA(f,election,nclass=2)  # log-likelihood: -17344.92
nes3 &lt;- poLCA(f,election,nclass=3)  # log-likelihood: -16714.66

# Three-class model with a single covariate (party)
f2a &lt;- cbind(MORALG,CARESG,KNOWG,LEADG,DISHONG,INTELG,
             MORALB,CARESB,KNOWB,LEADB,DISHONB,INTELB)~PARTY
nes2a &lt;- poLCA(f2a,election,nclass=3,nrep=5)    # log-likelihood: -16222.32 
pidmat &lt;- cbind(1,c(1:7))
exb &lt;- exp(pidmat %*% nes2a$coeff)
matplot(c(1:7),(cbind(1,exb)/(1+rowSums(exb))),ylim=c(0,1),type="l",
    main="Party ID as a predictor of candidate affinity class",
    xlab="Party ID: strong Democratic (1) to strong Republican (7)",
    ylab="Probability of latent class membership",lwd=2,col=1)
text(5.9,0.35,"Other")
text(5.4,0.7,"Bush affinity")
text(1.8,0.6,"Gore affinity")
</code></pre>

<hr>
<h2 id='gss82'>1982 General Social Survey (sample data)</h2><span id='topic+gss82'></span>

<h3>Description</h3>

<p>Attitudes towards survey taking across two dichotomous and two trichotomous items among 1202 white respondents to the 1982 General Social Survey. Respondents give their opinion of the purpose of surveys (<code>PURPOSE</code>; good/depends/waste of time and money), the accuracy of surveys (<code>ACCURACY</code>; mostly true/not true), their understanding of survey questions (<code>UNDERSTA</code>; good/fair, poor), and how well they cooperated with the interviewer (<code>COOPERAT</code>; interested/cooperative/impatient, hostile). This data set appears in McCutcheon (1987, p. 30) as Table 3.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gss82)</code></pre>


<h3>Format</h3>

<p>A data frame with 1202 observations on 4 survey variables.</p>


<h3>Source</h3>

<p>McCutcheon, A.L. 1987. <em>Latent class analysis</em>. Newbury Park: SAGE Publications.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gss82)
f &lt;- cbind(PURPOSE,ACCURACY,UNDERSTA,COOPERAT)~1
gss.lc2 &lt;- poLCA(f,gss82,nclass=2) # log-likelihood = -2783.268

# Could also try:
# gss.lc3 &lt;- poLCA(f,gss82,nclass=3,maxiter=3000,nrep=10) # log-likelihood = -2754.545
# gss.lc4 &lt;- poLCA(f,gss82,nclass=4,maxiter=15000,nrep=10,tol=1e-7) # log-likelihood = -2746.621
</code></pre>

<hr>
<h2 id='poLCA'>Latent class analysis of polytomous outcome variables</h2><span id='topic+poLCA'></span>

<h3>Description</h3>

<p>Estimates latent class and latent class regression models for polytomous outcome variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poLCA(formula, data, nclass = 2, maxiter = 1000, graphs = FALSE, 
      tol = 1e-10, na.rm = TRUE, probs.start = NULL, nrep = 1, 
      verbose = TRUE, calc.se = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA_+3A_formula">formula</code></td>
<td>
<p>A formula expression of the form <code>response ~ predictors</code>. The details of model specification are given below.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_data">data</code></td>
<td>
<p>A data frame containing variables in <code>formula</code>. Manifest variables must contain <em>only</em> integer values, and must be coded with consecutive values from 1 to the maximum number of outcomes for each variable. All missing values should be entered as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_nclass">nclass</code></td>
<td>
<p>The number of latent classes to assume in the model. Setting <code>nclass=1</code> results in <code>poLCA</code> estimating the loglinear independence model. The default is two.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations through which the estimation algorithm will cycle.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_graphs">graphs</code></td>
<td>
<p>Logical, for whether <code>poLCA</code> should graphically display the parameter estimates at the completion of the estimation algorithm. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_tol">tol</code></td>
<td>
<p>A tolerance value for judging when convergence has been reached.  When the one-iteration change in the estimated log-likelihood is less than <code>tol</code>, the estimation algorithm stops updating and considers the maximum log-likelihood to have been found.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, for how <code>poLCA</code> handles cases with missing values on the manifest variables.  If <code>TRUE</code>, those cases are removed (listwise deleted) before estimating the model. If <code>FALSE</code>, cases with missing values are retained. Cases with missing covariates are always removed. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_probs.start">probs.start</code></td>
<td>
<p>A list of matrices of class-conditional response probabilities to be used as the starting values for the estimation algorithm.  Each matrix in the list corresponds to one manifest variable, with one row for each latent class, and one column for each outcome.  The default is <code>NULL</code>, producing random starting values.  Note that if <code>nrep&gt;1</code>, then any user-specified <code>probs.start</code> values are only used in the first of the <code>nrep</code> attempts.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_nrep">nrep</code></td>
<td>
<p>Number of times to estimate the model, using different values of <code>probs.start</code>.  The default is one.  Setting <code>nrep</code>&gt;1 automates the search for the global&mdash;rather than just a local&mdash;maximum of the log-likelihood function. <code>poLCA</code> returns the parameter estimates corresponding to the model with the greatest log-likelihood.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating whether <code>poLCA</code> should output to the screen the results of the model.  If <code>FALSE</code>, no output is produced. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="poLCA_+3A_calc.se">calc.se</code></td>
<td>
<p>Logical, indicating whether <code>poLCA</code> should calculate the standard errors of the estimated class-conditional response probabilities and mixing proportions.  The default is <code>TRUE</code>; can only be set to <code>FALSE</code> if estimating a basic model with no concomitant variables specified in <code>formula</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Latent class analysis, also known as latent structure analysis, is a technique for the analysis of clustering among observations in multi-way tables of qualitative/categorical variables.  The central idea is to fit a model in which any confounding between the manifest variables can be explained by a single unobserved &quot;latent&quot; categorical variable.  <code>poLCA</code> uses the assumption of local independence to estimate a mixture model of latent multi-way tables, the number of which (<code>nclass</code>) is specified by the user.  Estimated parameters include the class-conditional response probabilities for each manifest variable, the &quot;mixing&quot; proportions denoting population share of observations corresponding to each latent multi-way table, and coefficients on any class-predictor covariates, if specified in the model.
</p>
<p>Model specification: Latent class models have more than one manifest variable, so the response variables are <code>cbind(dv1,dv2,dv3...)</code> where <code>dv#</code> refer to variable names in the data frame.  For models with no covariates, the formula is <code>cbind(dv1,dv2,dv3)~1</code>.  For models with covariates, replace the <code>~1</code> with the desired function of predictors <code>iv1,iv2,iv3...</code> as, for example, <code>cbind(dv1,dv2,dv3)~iv1+iv2*iv3</code>.
</p>
<p><code>poLCA</code> treats all manifest variables as qualitative/categorical/nominal &ndash; NOT as ordinal.
</p>


<h3>Value</h3>

<p><code>poLCA</code> returns an object of class poLCA; a list containing the following elements:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>data frame of manifest variables.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>data frame of covariates, if specified.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>number of cases used in model.</p>
</td></tr>
<tr><td><code>Nobs</code></td>
<td>
<p>number of fully observed cases (less than or equal to <code>N</code>).</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>estimated class-conditional response probabilities.</p>
</td></tr>
<tr><td><code>probs.se</code></td>
<td>
<p>standard errors of estimated class-conditional response probabilities, in the same format as <code>probs</code>.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>sizes of each latent class; equal to the mixing proportions in the basic latent class model, or the mean of the priors in the latent class regression model.</p>
</td></tr>
<tr><td><code>P.se</code></td>
<td>
<p>the standard errors of the estimated <code>P</code>.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>matrix of posterior class membership probabilities; also see function <code><a href="#topic+poLCA.posterior">poLCA.posterior</a></code>.</p>
</td></tr>
<tr><td><code>predclass</code></td>
<td>
<p>vector of predicted class memberships, by modal assignment.</p>
</td></tr>
<tr><td><code>predcell</code></td>
<td>
<p>table of observed versus predicted cell counts for cases with no missing values; also see functions <code><a href="#topic+poLCA.table">poLCA.table</a></code> and <code><a href="#topic+poLCA.predcell">poLCA.predcell</a></code>.</p>
</td></tr>
<tr><td><code>llik</code></td>
<td>
<p>maximum value of the log-likelihood.</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>number of iterations until reaching convergence.</p>
</td></tr>
<tr><td><code>maxiter</code></td>
<td>
<p>maximum number of iterations through which the estimation algorithm was set to run.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>multinomial logit coefficient estimates on covariates (when estimated). <code>coeff</code> is a matrix with <code>nclass-1</code> columns, and one row for each covariate.  All logit coefficients are calculated for classes with respect to class 1.</p>
</td></tr>
<tr><td><code>coeff.se</code></td>
<td>
<p>standard errors of coefficient estimates on covariates (when estimated), in the same format as <code>coeff</code>.</p>
</td></tr>
<tr><td><code>coeff.V</code></td>
<td>
<p>covariance matrix of coefficient estimates on covariates (when estimated).</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Akaike Information Criterion.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>Bayesian Information Criterion.</p>
</td></tr>
<tr><td><code>Gsq</code></td>
<td>
<p>Likelihood ratio/deviance statistic.</p>
</td></tr>
<tr><td><code>Chisq</code></td>
<td>
<p>Pearson Chi-square goodness of fit statistic for fitted vs. observed multiway tables.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>length of time it took to run the model.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>number of degrees of freedom used by the model (estimated parameters).</p>
</td></tr>
<tr><td><code>resid.df</code></td>
<td>
<p>number of residual degrees of freedom.</p>
</td></tr>
<tr><td><code>attempts</code></td>
<td>
<p>a vector containing the maximum log-likelihood values found in each of the <code>nrep</code> attempts to fit the model.</p>
</td></tr>
<tr><td><code>eflag</code></td>
<td>
<p>Logical, error flag. <code>TRUE</code> if estimation algorithm needed to automatically restart with new initial parameters. A restart is caused in the event of computational/rounding errors that result in nonsensical parameter estimates.</p>
</td></tr>
<tr><td><code>probs.start</code></td>
<td>
<p>A list of matrices containing the class-conditional response probabilities used as starting values in the estimation algorithm. If the algorithm needed to restart (see <code>eflag</code>), then this contains the starting values used for the final, successful, run.</p>
</td></tr>
<tr><td><code>probs.start.ok</code></td>
<td>
<p>Logical. <code>FALSE</code> if <code>probs.start</code> was incorrectly specified by the user, otherwise <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call to <code>poLCA</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>poLCA</code> uses EM and Newton-Raphson algorithms to maximize the latent class model log-likelihood function. Depending on the starting parameters, this algorithm may only locate a local, rather than global, maximum. This becomes more and more of a problem as <code>nclass</code> increases. It is therefore highly advisable to run <code>poLCA</code> multiple times until you are relatively certain that you have located the global maximum log-likelihood. As long as <code>probs.start=NULL</code>, each function call will use different (random) initial starting parameters.  Alternatively, setting <code>nrep</code> to a value greater than one enables the user to estimate the latent class model multiple times with a single call to <code>poLCA</code>, thus conducting the search for the global maximizer automatically.
</p>
<p>The term &quot;Latent class regression&quot; (LCR) can have two meanings.  In this package, LCR models refer to latent class models in which the probability of class membership is predicted by one or more covariates.  However, in other contexts, LCR is also used to refer to regression models in which the manifest variable is partitioned into some specified number of latent classes as part of estimating the regression model. It is a way to simultaneously fit more than one regression to the data when the latent data partition is unknown. The <code><a href="flexmix.html#topic+flexmix">flexmix</a></code> function in package <span class="pkg">flexmix</span> will estimate this other type of LCR model.  Because of these terminology issues, the LCR models this package estimates are sometimes termed &quot;latent class models with covariates&quot; or &quot;concomitant-variable latent class analysis,&quot; both of which are accurate descriptions of this model.
</p>
<p>A more detailed presentation is available online at <a href="https://www.jstatsoft.org/article/view/v042i10">https://www.jstatsoft.org/article/view/v042i10</a>.
</p>


<h3>References</h3>

<p>Agresti, Alan. 2002. <em>Categorical Data Analysis, second edition</em>. Hoboken: John Wiley \&amp; Sons.
</p>
<p>Bandeen-Roche, Karen, Diana L. Miglioretti, Scott L. Zeger, and Paul J. Rathouz. 1997. &quot;Latent Variable Regression for Multiple Discrete Outcomes.&quot; <em>Journal of the American Statistical Association</em>. 92(440): 1375-1386.
</p>
<p>Hagenaars, Jacques A. and Allan L. McCutcheon, eds. 2002. <em>Applied Latent Class Analysis</em>. Cambridge: Cambridge University Press.
</p>
<p>McLachlan, Geoffrey J. and Thriyambakam Krishnan. 1997. <em>The EM Algorithm and Extensions</em>. New York: John Wiley \&amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Three models without covariates:
## M0: Loglinear independence model.
## M1: Two-class latent class model.
## M2: Three-class latent class model.
##
data(values)
f &lt;- cbind(A,B,C,D)~1
M0 &lt;- poLCA(f,values,nclass=1) # log-likelihood: -543.6498
M1 &lt;- poLCA(f,values,nclass=2) # log-likelihood: -504.4677
M2 &lt;- poLCA(f,values,nclass=3,maxiter=8000) # log-likelihood: -503.3011

##
## Three-class model with a single covariate.
##
data(election)
f2a &lt;- cbind(MORALG,CARESG,KNOWG,LEADG,DISHONG,INTELG,
             MORALB,CARESB,KNOWB,LEADB,DISHONB,INTELB)~PARTY
nes2a &lt;- poLCA(f2a,election,nclass=3,nrep=5)    # log-likelihood: -16222.32 
pidmat &lt;- cbind(1,c(1:7))
exb &lt;- exp(pidmat %*% nes2a$coeff)
matplot(c(1:7),(cbind(1,exb)/(1+rowSums(exb))),ylim=c(0,1),type="l",
    main="Party ID as a predictor of candidate affinity class",
    xlab="Party ID: strong Democratic (1) to strong Republican (7)",
    ylab="Probability of latent class membership",lwd=2,col=1)
text(5.9,0.35,"Other")
text(5.4,0.7,"Bush affinity")
text(1.8,0.6,"Gore affinity")
</code></pre>

<hr>
<h2 id='poLCA.entropy'>Entropy of a fitted latent class model</h2><span id='topic+poLCA.entropy'></span>

<h3>Description</h3>

<p>Calculates the entropy of a cross-classification table produced as a density estimate using a latent class model.</p>


<h3>Usage</h3>

<pre><code class='language-R'> poLCA.entropy(lc) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA.entropy_+3A_lc">lc</code></td>
<td>
<p>A model object estimated using the <code>poLCA</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entropy is a measure of dispersion (or concentration) in a probability mass function. For multivariate categorical data it is calculated </p>
<p style="text-align: center;"><code class="reqn">H = -\sum_c p_c log(p_c)</code>
</p>
<p> where <code class="reqn">p_c</code> is the share of the probability in the <em>c</em>th cell of the cross-classification table.  A fitted latent class model produces a smoothed density estimate of the underlying distribution of cell percentages in the multi-way table of the manifest variables.  This function calculates the entropy of that estimated probability mass function.
</p>


<h3>Value</h3>

<p>A number taking a minumum value of 0 (representing complete concentration of probability on one cell) and a maximum value equal to the logarithm of the total number of cells in the fitted cross-classfication table (representing complete dispersion, or equal probability for outcomes across every cell).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+poLCA">poLCA</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carcinoma)
f &lt;- cbind(A,B,C,D,E,F,G)~1
lca2 &lt;- poLCA(f,carcinoma,nclass=2) # log-likelihood: -317.2568
lca3 &lt;- poLCA(f,carcinoma,nclass=3) # log-likelihood: -293.705
lca4 &lt;- poLCA(f,carcinoma,nclass=4,nrep=10,maxiter=5000) # log-likelihood: -289.2858 

# Maximum entropy (if all cases equally dispersed)
log(prod(sapply(lca2$probs,ncol)))

# Sample entropy ("plug-in" estimator, or MLE)
p.hat &lt;- lca2$predcell$observed/lca2$N
H.hat &lt;- -sum(p.hat * log(p.hat))
H.hat   # 2.42

# Entropy of fitted latent class models
poLCA.entropy(lca2)
poLCA.entropy(lca3)
poLCA.entropy(lca4)
</code></pre>

<hr>
<h2 id='poLCA.posterior'>Posterior probabilities from a latent class model</h2><span id='topic+poLCA.posterior'></span>

<h3>Description</h3>

<p>Calculates the posterior probability that cases belong to each latent class.</p>


<h3>Usage</h3>

<pre><code class='language-R'> poLCA.posterior(lc,y,x=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA.posterior_+3A_lc">lc</code></td>
<td>
<p>A model object estimated using the <code>poLCA</code> function.</p>
</td></tr>
<tr><td><code id="poLCA.posterior_+3A_y">y</code></td>
<td>
<p>A vector or matrix containing series of responses on the manifest variables in <code>lc</code>.</p>
</td></tr>
<tr><td><code id="poLCA.posterior_+3A_x">x</code></td>
<td>
<p>An optional vector or matrix of covariate values, if <code>lc</code> was specified as a latent class regression model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the parameters estimated by the latent class model, this function calculates the &quot;posterior&quot; probability that a specified case &ndash; characterized by values of the manifest variables <code>y</code>, and, if a latent class regression model, concomitant variables <code>x</code> &ndash; &quot;belongs to&quot; each latent class in <code>lc</code>.  For observed cases, this information is also contained in the <code>lc</code> model object as <code>lc$posterior</code>.  The added benefit of this function is that it can calculate posterior class membership probabilities for arbitrary values of <code>x</code> and <code>y</code>, whether or observed or not.
</p>


<h3>Value</h3>

<p>A matrix containing posterior probabilities corresponding to the specified sets of responses <code>y</code>, based on the estimated latent class model <code>lc</code>.  For each row (one case), the first column gives the posterior probability of being in class 1, the second column gives the posterior probability of being in class 2, and so forth.  Across rows, these probabilities sum to one.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+poLCA">poLCA</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(election)

## Basic latent class model with three classes
f1 &lt;- cbind(MORALG,CARESG,KNOWG,LEADG,DISHONG,INTELG,
            MORALB,CARESB,KNOWB,LEADB,DISHONB,INTELB)~1
lc1 &lt;- poLCA(f1,election,nclass=3)  # log-likelihood: -16714.66

# The first observed case
lc1$y[1,]
lc1$posterior[1,]
poLCA.posterior(lc=lc1,y=as.numeric(lc1$y[1,]))

# A hypothetical case
poLCA.posterior(lc=lc1,y=rep(2,12))

# Entering y as a matrix
lc1$posterior[1:10,]
poLCA.posterior(lc=lc1,y=mapply(as.numeric,lc1$y[1:10,]))


## Latent class regression model with three classes
f2 &lt;- cbind(MORALG,CARESG,KNOWG,LEADG,DISHONG,INTELG,
            MORALB,CARESB,KNOWB,LEADB,DISHONB,INTELB)~AGE+EDUC+GENDER
lc2 &lt;- poLCA(f2,election,nclass=3)  # log-likelihood: -16598.38

# Posteriors for case number 97 (poorly classified)
lc2$y[97,]
lc2$x[97,]
lc2$posterior[97,]
poLCA.posterior(lc=lc2,y=as.numeric(lc2$y[97,]),x=c(41,6,1))

# If x is not specified, the posterior is calculated using the population average
poLCA.posterior(lc=lc2,y=as.numeric(lc2$y[97,]))

# Entering y and x as matrices
round(lc2$posterior[95:100,],2)
round(poLCA.posterior(lc=lc2,y=mapply(as.numeric,lc2$y[95:100,]),
                             x=as.matrix(lc2$x[95:100,-1])),2)
</code></pre>

<hr>
<h2 id='poLCA.predcell'>Predicted cell percentages in a latent class model</h2><span id='topic+poLCA.predcell'></span>

<h3>Description</h3>

<p>Calculates the predicted cell percentages from a latent class model, for specified values of the manifest variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'> poLCA.predcell(lc,y) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA.predcell_+3A_lc">lc</code></td>
<td>
<p>A model object estimated using the <code>poLCA</code> function.</p>
</td></tr>
<tr><td><code id="poLCA.predcell_+3A_y">y</code></td>
<td>
<p>A vector or matrix containing series of responses on the manifest variables in <code>lc</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters estimated by a latent class model can be used to produce a density estimate of the underlying probability mass function across the cells in the multi-way table of manifest variables.  This function calculates cell percentages for that density estimate, corresponding to selected sets of responses on the manifest variables, <code>y</code>.
</p>


<h3>Value</h3>

<p>A vector containing cell percentages corresponding to the specified sets of responses <code>y</code>, based on the estimated latent class model <code>lc</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+poLCA">poLCA</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(carcinoma)
f &lt;- cbind(A,B,C,D,E,F,G)~1
lca3 &lt;- poLCA(f,carcinoma,nclass=3) # log-likelihood: -293.705

# Only 20 out of 32 possible response patterns are observed
lca3$predcell

# Produce cell probabilities for one sequence of responses
poLCA.predcell(lc=lca3,y=c(1,1,1,1,1,1,1))

# Estimated probabilities for a cell with zero observations
poLCA.predcell(lc=lca3,y=c(1,1,1,1,1,1,2))

# Cell probabilities for both cells at once; y entered as a matrix
poLCA.predcell(lc=lca3,y=rbind(c(1,1,1,1,1,1,1),c(1,1,1,1,1,1,2)))
</code></pre>

<hr>
<h2 id='poLCA.reorder'>Reorder latent classes in poLCA</h2><span id='topic+poLCA.reorder'></span>

<h3>Description</h3>

<p>A helper function to simplify the reordering of latent classes returned by <code>poLCA</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poLCA.reorder(probs, o.new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA.reorder_+3A_probs">probs</code></td>
<td>
<p>a list of class-conditional response probabilities previously used as start values to estimate a particular latent class model using <code>poLCA</code>.</p>
</td></tr>
<tr><td><code id="poLCA.reorder_+3A_o.new">o.new</code></td>
<td>
<p>a vector of length equal to the number of latent classes in <code>probs</code>, giving the desired reordering of the latent classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the latent classes outputted by <code>poLCA</code> are unordered categories, the numerical order of the classes is arbitrary, and is determined solely by the initial values of the EM algorithm. If <code>probs.start</code> is set to <code>NULL</code> (the default) when calling <code>poLCA</code>, then the function generates the starting values randomly in each run, typically rearranging the latent class labels.  The <code>poLCA.reorder</code> function is a convenient way to manually adjust the order of the latent classes, by changing the order of the <code>probs.start</code>.  Refitting the latent class model using these reordered start values will produce a model having the desired category labels.</p>


<h3>Value</h3>

<p>The function returns a list of matrices containing the rearranged (by row) class-conditional response probabilities.</p>


<h3>See Also</h3>

<p><code><a href="#topic+poLCA">poLCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Using the "cheating" sample data set, make the larger
## non-cheater class the first ("reference") class in a 
## latent class regression model.  The coefficient on GPA
## now maintains a consistent interpretation.
##
data(cheating)
f2 &lt;- cbind(LIEEXAM,LIEPAPER,FRAUD,COPYEXAM)~GPA
lc.ch &lt;- poLCA(f2,cheating,nclass=2,verbose=FALSE)
probs.start.new &lt;- poLCA.reorder(lc.ch$probs.start,order(lc.ch$P,decreasing=TRUE))
lc.ch &lt;- poLCA(f2,cheating,nclass=2,probs.start=probs.start.new)
</code></pre>

<hr>
<h2 id='poLCA.simdata'>Create simulated cross-classification data</h2><span id='topic+poLCA.simdata'></span>

<h3>Description</h3>

<p>Uses the latent class model's assumed data-generating process to create a simulated dataset that can be used to test the properties of the poLCA latent class and latent class regression estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poLCA.simdata(N = 5000, probs = NULL, nclass = 2, ndv = 4, 
              nresp = NULL, x = NULL, niv = 0, b = NULL, 
              P = NULL, missval = FALSE, pctmiss = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA.simdata_+3A_n">N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_probs">probs</code></td>
<td>
<p>a list of matrices of dimension <code>nclass</code> by <code>nresp</code> with each matrix corresponding to one manifest variable, and each row containing the class-conditional outcome probabilities (which must sum to 1)  If <code>probs</code> is <code>NULL</code> (default) then the outcome probabilities are generated randomly.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_nclass">nclass</code></td>
<td>
<p>number of latent classes. If<code>probs</code> is specified, then <code>nclass</code> is set equal to the number of rows in each matrix in that list. If <code>P</code> is specified, then <code>nclass</code> is set equal to the length of that vector. If <code>b</code> is specified, then <code>nclass</code> is set equal to one greater than the number of columns in <code>b</code>. Otherwise, the default is two.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_ndv">ndv</code></td>
<td>
<p>number of manifest variables.  If <code>probs</code> is specified, then <code>ndv</code> is set equal to the number of matrices in that list. If <code>nresp</code> is specified, then <code>ndv</code> is set equal to the length of that vector. Otherwise, the default is four.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_nresp">nresp</code></td>
<td>
<p>number of possible outcomes for each manifest variable. If <code>probs</code> is specified, then <code>ndv</code> is set equal to the number of columns in each matrix in that list. If both <code>probs</code> and <code>nresp</code> are <code>NULL</code> (default), then the manifest variables are assigned a random number of outcomes between two and five.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_x">x</code></td>
<td>
<p>a matrix of concomicant variables with <code>N</code> rows and <code>niv</code> columns. If <code>x=NULL</code> (default), but <code>niv&gt;0</code>, then <code>niv</code> concomitant variables will be  generated as mutually independent random draws from a standard normal distribution.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_niv">niv</code></td>
<td>
<p>number of concomitant variables (covariates).  Setting <code>niv=0</code> (default) creates a data set assuming no covariates.  If <code>nclass=1</code> then <code>niv</code> is automatically set equal to 0. If both <code>x</code> and <code>niv</code> are entered, then the number of columns in <code>x</code> overrides the value of <code>niv</code>.  The number of rows in <code>b</code>, less one, also overrides <code>niv</code>.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_b">b</code></td>
<td>
<p>when using covariates, an <code>niv+1</code> by <code>nclass-1</code> matrix of (multinomial) logit coefficients. If <code>b</code> is <code>NULL</code> (default), then coefficients are generated as random integers between -2 and 2.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_p">P</code></td>
<td>
<p>a vector of mixing proportions (class population shares) of length <code>nclass</code>. <code>P</code> must sum to 1.  Disregarded if <code>b</code> is specified or <code>niv&gt;1</code> because then <code>P</code> is, in part, a function of the concomitant variables.  If <code>P</code> is <code>NULL</code> (default), then the mixing proportions are generated randomly.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_missval">missval</code></td>
<td>
<p>logical. If <code>TRUE</code> then a fraction <code>pctmiss</code> of the manifest variables are randomly dropped as missing values.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="poLCA.simdata_+3A_pctmiss">pctmiss</code></td>
<td>
<p>percentage of values to be dropped as missing, if <code>missval=TRUE</code>.  If <code>pctmiss</code> is <code>NULL</code> (default), then a value between 5 and 40 percent is chosen randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that entering <code>probs</code> overrides <code>nclass</code>, <code>ndv</code>, and <code>nresp</code>.  It also overrides <code>P</code> if the length of the <code>P</code> vector is not equal to the length of the <code>probs</code> list.  Likewise, if <code>probs=NULL</code>, then <code>length(nresp)</code> overrides <code>ndv</code> and <code>length(P)</code> overrides <code>nclass</code>.  Setting <code>niv&gt;1</code> causes any user-entered value of <code>P</code> to be disregarded.</p>


<h3>Value</h3>

<table>
<tr><td><code>dat</code></td>
<td>
<p>a data frame containing the simulated variables.  Variable names for manifest variables are Y1, Y2, etc.  Variable names for concomitant variables are X1, X2, etc.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>a list of matrices of dimension <code>nclass</code> by <code>nresp</code> containing the class-conditional response probabilities.</p>
</td></tr>
<tr><td><code>nresp</code></td>
<td>
<p>a vector containing the number of possible outcomes for each manifest variable.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>coefficients on covariates, if used.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>mixing proportions corresponding to each latent class.</p>
</td></tr>
<tr><td><code>pctmiss</code></td>
<td>
<p>percent of observations missing.</p>
</td></tr>
<tr><td><code>trueclass</code></td>
<td>
<p><code>N</code> by 1 vector containing the &quot;true&quot; class membership for each individual.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poLCA">poLCA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample data set with 3 classes and no covariates 
# and run poLCA to recover the specified parameters.

probs &lt;- list(matrix(c(0.6, 0.1, 0.3,
                       0.6, 0.3, 0.1,
		       0.3, 0.1, 0.6),
		     ncol = 3,byrow = TRUE), # conditional resp prob to Y1
              matrix(c(0.2, 0.8,
	               0.7, 0.3,
		       0.3, 0.7),
		     ncol = 2, byrow = TRUE), # conditional resp prob to Y2
              matrix(c(0.3, 0.6, 0.1,
	               0.1, 0.3, 0.6,
		       0.3, 0.6, 0.1),
		     ncol = 3,byrow = TRUE), # conditional resp prob to Y3
              matrix(c(0.1, 0.1, 0.5, 0.3,
	               0.5, 0.3, 0.1, 0.1,
		       0.3, 0.1, 0.1, 0.5),
		     ncol = 4,byrow = TRUE), # conditional resp prob to Y4
              matrix(c(0.1, 0.1, 0.8,
	               0.1, 0.8, 0.1,
		       0.8, 0.1, 0.1),
		     ncol = 3,
		     byrow = TRUE)) # conditional resp prob to Y5
simdat &lt;- poLCA.simdata(N=1000,probs,P=c(0.2,0.3,0.5))
f1 &lt;- cbind(Y1,Y2,Y3,Y4,Y5)~1
lc1 &lt;- poLCA(f1,simdat$dat,nclass=3)
table(lc1$predclass,simdat$trueclass)

# Create a sample dataset with 2 classes and three covariates.
# Then compare predicted class memberships when the model is 
# estimated "correctly" with covariates to when it is estimated
# "incorrectly" without covariates.
simdat2 &lt;- poLCA.simdata(N=1000,ndv=7,niv=3,nclass=2,b=matrix(c(1,-2,1,-1)))
f2a &lt;- cbind(Y1,Y2,Y3,Y4,Y5,Y6,Y7)~X1+X2+X3
lc2a &lt;- poLCA(f2a,simdat2$dat,nclass=2)
f2b &lt;- cbind(Y1,Y2,Y3,Y4,Y5,Y6,Y7)~1
lc2b &lt;- poLCA(f2b,simdat2$dat,nclass=2)
table(lc2a$predclass,lc2b$predclass)
</code></pre>

<hr>
<h2 id='poLCA.table'>Frequency tables of predicted cell counts from latent class analysis</h2><span id='topic+poLCA.table'></span>

<h3>Description</h3>

<p>Calculates predicted cell frequencies based on an estimated latent class model.</p>


<h3>Usage</h3>

<pre><code class='language-R'> poLCA.table(formula, condition, lc) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poLCA.table_+3A_formula">formula</code></td>
<td>
<p>A formula expression of the form <code>variable ~ 1</code> for a one-way frequency distribution, or <code>row ~ column</code> for two way-tables.</p>
</td></tr>
<tr><td><code id="poLCA.table_+3A_condition">condition</code></td>
<td>
<p>A list containing the values of the manifest variables to hold fixed when creating the table specified by the <code>formula</code> argument. Setting this to an empty list, <code>condition=list()</code>, conditions on none of the other manifest variables, producing the marginal frequencies.</p>
</td></tr>
<tr><td><code id="poLCA.table_+3A_lc">lc</code></td>
<td>
<p>A model object previously estimated using the <code><a href="#topic+poLCA">poLCA</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function outputs predicted cell counts for user-specified combinations of the manifest variables, based on a latent class model estimated by the <code><a href="#topic+poLCA">poLCA</a></code> function.  The <code>predcell</code> table outputted automatically by <code>poLCA</code> also contains predicted cell frequencies, but only for cells containing at least one observation.  In contrast, <code>poLCA.table</code> will calculate predicted cell counts for all cells, including those with zero observations.
</p>


<h3>Value</h3>

<p>A vector or table containing the specified frequency distribution.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+poLCA">poLCA</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gss82)
f &lt;- cbind(PURPOSE,ACCURACY,UNDERSTA,COOPERAT)~1
gss.lc2 &lt;- poLCA(f,gss82,nclass=2)
gss.lc2$predcell

poLCA.table(formula=COOPERAT~1,condition=list(PURPOSE=3,ACCURACY=1,UNDERSTA=2),lc=gss.lc2)

poLCA.table(formula=COOPERAT~UNDERSTA,condition=list(PURPOSE=3,ACCURACY=1),lc=gss.lc2)

poLCA.table(formula=COOPERAT~UNDERSTA,condition=list(),lc=gss.lc2)
</code></pre>

<hr>
<h2 id='rmulti'>Random draws from a multinomial distribution</h2><span id='topic+rmulti'></span>

<h3>Description</h3>

<p>One random draw from a multinomial distribution or list of multinomial distributions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmulti(p)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmulti_+3A_p">p</code></td>
<td>
<p>matrix of dimension <code>n</code> by <code>r</code> containing probabilities, for each row, of drawing each of <code>r</code> outcomes.  <code>p</code> may also be entered as a vector, in which case <code>rmulti</code> treats it as a matrix of dimension <code>n=1</code> by <code>r</code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a vector of length <code>n</code>.  Each item represents one draw from the multinomial distribution parameterized by the outcome probabilities in each row of <code>p</code>.</p>


<h3>Note</h3>

<p>Each row of matrix <code>p</code> must sum to 1 or <code>rmulti</code> will not work properly.</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## One draw from a three-category multinomial distribution.
##
p1 &lt;- c(0.7,0.2,0.1)
rmulti(p1)

##
## 10,000 draws from a three-category multinomial distribution.
##
n &lt;- 10000
p2 &lt;- matrix(p1,nrow=n,ncol=length(p1),byrow=TRUE)
rmdraws &lt;- rmulti(p2)
table(rmdraws)/n    # should be approximately 0.7, 0.2, 0.1

##
## 10,000 draws from a mixture of three groups of a
## four-category multinomial distribution.
##
group.p &lt;- matrix(c(0.5,0.3,0.2),nrow=n,ncol=3,byrow=TRUE)
group &lt;- rmulti(group.p)
p3 &lt;- t(matrix(NA,nrow=n,ncol=4))
p3[,group==1] &lt;- c(0.7,0.1,0.1,0.1)
p3[,group==2] &lt;- c(0.1,0.7,0.1,0.1)
p3[,group==3] &lt;- c(0.1,0.1,0.1,0.7)
p3 &lt;- t(p3)
rmdraws3 &lt;- rmulti(p3)
table(group,rmdraws3)
table(group,rmdraws3)/rowSums(table(group,rmdraws3))
</code></pre>

<hr>
<h2 id='values'>Universalistic vs. particularistic values (sample data)</h2><span id='topic+values'></span>

<h3>Description</h3>

<p>Dichotomous survey responses from 216 respondents to four questions (<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>) measuring tendencies towards &quot;universalistic&quot; or &quot;particularistic&quot; values.  This data set appears in Goodman (2002, p. 14) as Table 4, and previously appeared in Goodman (1974) and Stouffer and Toby (1951).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(values)</code></pre>


<h3>Format</h3>

<p>A data frame with 216 observations on 4 variables representing survey responses to dichotomous questions, with 1 denoting the &quot;particularistic&quot; values response and 2 denoting the &quot;universalistic&quot; values response.</p>


<h3>Source</h3>

<p>Stouffer, S.A. and J. Toby. 1951. &quot;Role conflict and personality.&quot; <em>American Journal of Sociology</em>. 56: 395:406.
</p>
<p>Goodman, Leo A. 1974. &quot;Exploratory Latent-Structure Analysis Using Both Identifiable and Unidentifiable Models.&quot; <em>Biometrika</em>. 61(2): 215-231.
</p>
<p>Goodman, Leo A. 2002. &quot;Latent Class Analysis; The Empirical Study of Latent Types, Latent Variables, and Latent Structures.&quot; in Jacques A. Hagenaars and Allan L. McCutcheon, eds. <em>Applied Latent Class Analysis</em>. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Replication of latent class models in Goodman (2002), 
## Tables 5b, 5c, and 6.
##
data(values)
f &lt;- cbind(A,B,C,D)~1
M0 &lt;- poLCA(f,values,nclass=1) # log-likelihood: -543.6498
M1 &lt;- poLCA(f,values,nclass=2) # log-likelihood: -504.4677
M2 &lt;- poLCA(f,values,nclass=3,maxiter=8000) # log-likelihood: -503.3011
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
