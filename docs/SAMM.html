<!DOCTYPE html><html><head><title>Help for package SAMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SAMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#loglikfuncmmmkmv'><p>Calculate the loglikeligood for a general mixed model</p></a></li>
<li><a href='#SAMM'><p>Some Algoritms for Mixed Models</p></a></li>
<li><a href='#SAMM-package'>
<p>Some Algorithms for Mixed Models</p></a></li>
<li><a href='#sigcovfuncs_cppforR'><p>Covariance and Sigma Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Some Algorithms for Mixed Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Deniz Akdemir</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This program can be used to fit Gaussian linear mixed models (LMM). Univariate and multivariate response models, multiple variance components, as well as, certain correlation and covariance structures are supported. In many occasions, the user can pick one of the several mixed model fitting algorithms, which are explained further in the details section. Some algorithms are specific to certain types of models (univariate or multivariate, diagonal or non-diagonal residual, one or multiple variance components, etc,...).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-05 18:33:35 UTC; deniz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-06 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='loglikfuncmmmkmv'>Calculate the loglikeligood for a general mixed model</h2><span id='topic+loglikfuncmmmkmv'></span>

<h3>Description</h3>

<p>Calculate the loglikeligood for the LMM model expressed as </p>
<p style="text-align: center;"><code class="reqn">Y=XB+\sum_{j=1}^k Z_j G_j+WE,</code>
</p>
<p> where <code class="reqn">Y</code> is the <code class="reqn">n \times d</code> response variable, <code class="reqn">X</code> is the <code class="reqn">n \times q</code> design matrix of <code class="reqn">q \times d</code> the fixed effects <code class="reqn">B</code>, <code class="reqn">Z_j</code> for <code class="reqn">j=1,2,\ldots,k</code>  (<code class="reqn">k\geq 1</code>) are the <code class="reqn">n \times q_j</code> design matrices of the <code class="reqn">q_j \times d</code> random effects <code class="reqn">G_j,</code>  and <code class="reqn">W</code> is the <code class="reqn">n \times t</code> design matrix of <code class="reqn">t \times d</code> residual effecs <code class="reqn">E</code>. The random effects and the residual are independently distributed, and have matrix variate distributions (<code class="reqn">G_j\sim N_{q_j \times d}(0_{q_j \times d}, K_j,\Sigma_j)</code> for <code class="reqn">j=1,2,\ldots,k</code> and <code class="reqn">E\sim N_{t \times d}(0_{t \times d}, R,\Sigma_E)</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikfuncmmmkmv(Y,X,Zlist, Klist, sigmahatlist, B,W,R )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikfuncmmmkmv_+3A_y">Y</code></td>
<td>
<p>a numeric vector for the parameters (a mapping of the original parameters)</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_x">X</code></td>
<td>
<p>a numeric matrix (see examples and details)</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_zlist">Zlist</code></td>
<td>
<p>a numeric matrix (see examples and details)</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_klist">Klist</code></td>
<td>
<p>a numeric matrix (see examples and details)</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_sigmahatlist">sigmahatlist</code></td>
<td>
<p>a numeric matrix (see examples and details)</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_b">B</code></td>
<td>
<p>bla bla</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_w">W</code></td>
<td>
<p>bla bal</p>
</td></tr>
<tr><td><code id="loglikfuncmmmkmv_+3A_r">R</code></td>
<td>
<p>bla bla</p>
</td></tr>
</table>


<h3>Details</h3>

<p>bla bla
</p>


<h3>Value</h3>

<p>bla bla
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SAMM)
n=100
nsample=80
rhotrans=5
ar1cov_cppforR(c(rhotrans),matrix(5))
rho=(2/pi)*atan(rhotrans)
rho
tan((pi/2)*(rho))

M1&lt;-matrix(rbinom(n*300, 2, .2)-1, nrow=n)
K1&lt;-relmatcov_cppforR(c(.01), M1)

M2&lt;-matrix(rbinom(n*300, 2, .2)-1, nrow=n)
K2&lt;-relmatcov_cppforR(c(0.03), M2)
W=(diag(5)[sample(1:5,n, replace=TRUE),])
covY&lt;-3*K1+5*K2+10*(W%*%ar1cov_cppforR(c(rhotrans),matrix(5))%*%t(W))
K1[1:5,1:5]
dim(W)
dim(ar1cov_cppforR(c(6),matrix(5)))
Y&lt;-10+crossprod(chol(covY),rnorm(n))


#training set
Trainset&lt;-sample(1:n,nsample)
ytrain=Y[Trainset]
Xtrain=matrix(rep(1, n)[Trainset], ncol=1)
Ztrain=diag(n)[Trainset,]
Wtrain=W[Trainset,]

samout&lt;-SAMM(Y=matrix(ytrain,ncol=1),X=Xtrain,
Zlist=list(Ztrain, Ztrain), Klist=list(K1,K2),
lambda=0, W=Wtrain,R=list("ar1",c(0),matrix(5,1,1)),
Siglist=list("","",""), corfunc=c(F,F,T), corfuncfixed=c(F,F,F),
sigfunc=c(F,F,F),mmalg="dermm_reml2", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)
samout$corfuncparamslist[[3]]
rhohat=(2/pi)*atan(samout$corfuncparamslist[[3]])
rhohat
ar1cov_cppforR(c(samout$corfuncparamslist[[3]]),matrix(5,1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='SAMM'>Some Algoritms for Mixed Models</h2><span id='topic+SAMM'></span>

<h3>Description</h3>

<p>The LMM model of focus can be expressed as </p>
<p style="text-align: center;"><code class="reqn">Y=XB+\sum_{j=1}^k Z_j G_j+WE,</code>
</p>
<p> where <code class="reqn">Y</code> is the <code class="reqn">n \times d</code> response variable, <code class="reqn">X</code> is the <code class="reqn">n \times q</code> design matrix of <code class="reqn">q \times d</code> the fixed effects <code class="reqn">B</code>, <code class="reqn">Z_j</code> for <code class="reqn">j=1,2,\ldots,k</code>  (<code class="reqn">k\geq 1</code>) are the <code class="reqn">n \times q_j</code> design matrices of the <code class="reqn">q_j \times d</code> random effects <code class="reqn">G_j,</code>  and <code class="reqn">W</code> is the <code class="reqn">n \times t</code> design matrix of <code class="reqn">t \times d</code> residual effecs <code class="reqn">E</code>. The random effects and the residual are independently distributed, and have matrix variate distributions (<code class="reqn">G_j\sim N_{q_j \times d}(0_{q_j \times d}, K_j,\Sigma_j)</code> for <code class="reqn">j=1,2,\ldots,k</code> and <code class="reqn">E\sim N_{t \times d}(0_{t \times d}, R,\Sigma_E)</code>). The matrices  <code class="reqn">K_j, R, \Sigma_j, \Sigma_E</code> might be further parametrized.  When the response is univariate <code class="reqn">(d=1)</code> there is no need to specify a structure for <code class="reqn">\Sigma_j</code>'s and<code class="reqn">\Sigma_E.</code>  On the other hand, the <code class="reqn">K_j</code> and <code class="reqn">R</code> are kernel matrices (covariance matrices with some standardization over the diagonals) and they need to be provided by the user. 
</p>
<p>Please refer to the examples below and the other help files for more details about the kernel and covariance structures. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAMM(Y, X, Zlist, Klist, lambda, W, R, Siglist, corfunc,
                 corfuncfixed, sigfunc, mmalg, tolparconv = 1e-10,
                 tolparinv = 1e-10, maxiter = 1000L, geterrors = FALSE,
                 Hinv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SAMM_+3A_y">Y</code></td>
<td>
<p><code class="reqn">Y</code> is the <code class="reqn">n \times d</code> response variable</p>
</td></tr>
<tr><td><code id="SAMM_+3A_x">X</code></td>
<td>
<p><code class="reqn">n \times q</code> design matrix of <code class="reqn">q \times d</code> the fixed effects <code class="reqn">B</code></p>
</td></tr>
<tr><td><code id="SAMM_+3A_zlist">Zlist</code></td>
<td>
<p>a list object containing <code class="reqn">Z_j</code> for <code class="reqn">j=1,2,\ldots,k</code>  (<code class="reqn">k\geq 1</code>), the <code class="reqn">n \times q_j</code> design matrices of the <code class="reqn">q_j \times d</code> random effects <code class="reqn">G_j,</code></p>
</td></tr>
<tr><td><code id="SAMM_+3A_klist">Klist</code></td>
<td>
<p>a list to specify the kernel matrices <code class="reqn">K_j</code> for <code class="reqn">j=1,2,\ldots,k.</code> For each <code class="reqn">j</code>, the user needs to provide a constant matrix, or a list specifying the kernel structure</p>
</td></tr>
<tr><td><code id="SAMM_+3A_lambda">lambda</code></td>
<td>
<p>a scalar shrinkage parameter for shrinkage of variance components (only works with the choice mmalg=&rdquo;mmmk_ml&rdquo;).</p>
</td></tr>
<tr><td><code id="SAMM_+3A_w">W</code></td>
<td>
<p><code class="reqn">W</code> is the <code class="reqn">n \times t</code> design matrix of <code class="reqn">t \times d</code> residual effecs <code class="reqn">E</code></p>
</td></tr>
<tr><td><code id="SAMM_+3A_r">R</code></td>
<td>
<p>a list to specify the kernel matrix <code class="reqn">R</code>,the user needs to provide a constant matrix, or a list specifying the kernel structure</p>
</td></tr>
<tr><td><code id="SAMM_+3A_siglist">Siglist</code></td>
<td>
<p>a list to specify the covariance structures <code class="reqn">\Sigma_j</code>'s and<code class="reqn">\Sigma_E</code></p>
</td></tr>
<tr><td><code id="SAMM_+3A_corfunc">corfunc</code></td>
<td>
<p>a boolian vector specifying whether <code class="reqn">K_j</code> for <code class="reqn">j=1,2,\ldots,k</code>  and <code class="reqn">R</code> are functions or given matrices (TRUE for functions)</p>
</td></tr>
<tr><td><code id="SAMM_+3A_corfuncfixed">corfuncfixed</code></td>
<td>
<p>a boolian vector specifying whether <code class="reqn">K_j</code> for <code class="reqn">j=1,2,\ldots,k</code> and <code class="reqn">R</code> are fixed at the initial parameter values specified </p>
</td></tr>
<tr><td><code id="SAMM_+3A_sigfunc">sigfunc</code></td>
<td>
<p>a boolian vector specifying whether <code class="reqn">\Sigma_j</code> for <code class="reqn">j=1,2,\ldots,k, E</code> are functions or unstructured (TRUE for functions)</p>
</td></tr>
<tr><td><code id="SAMM_+3A_mmalg">mmalg</code></td>
<td>
<p>The mixed model solving algorithm</p>
</td></tr>
<tr><td><code id="SAMM_+3A_tolparconv">tolparconv</code></td>
<td>
<p>convergence criteria</p>
</td></tr>
<tr><td><code id="SAMM_+3A_tolparinv">tolparinv</code></td>
<td>
<p>a small scalar to add to the diagonals of positive semidefinite matrices for inversion or for calculating the Cholesky decompositions</p>
</td></tr>
<tr><td><code id="SAMM_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="SAMM_+3A_geterrors">geterrors</code></td>
<td>
<p>TRUE or FALSE, if true prediction error variances for the random effects are supplied in the output</p>
</td></tr>
<tr><td><code id="SAMM_+3A_hinv">Hinv</code></td>
<td>
<p>TRUE or FALSE, if TRUE the inverse of the</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This might change with respect to the algorithm or analysis.
</p>


<h3>Value</h3>

<p>This might change with respect to the algorithm or analysis.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SAMM)
#set.seed(12345)

n=120
ntrain=100
M1&lt;-matrix(rbinom(n*180,2,.3)-1, nrow=n)
K&lt;-relmatcov_cppforR(c(0), M1)
K[1:5,1:5]
det(K)
K=K+1e-3*diag(n)
mean(diag(K))

covY&lt;-2*K+1*diag(n)

Y&lt;-10+crossprod(chol(covY),rnorm(n))


#training set
Trainset&lt;-sample(1:n,ntrain,replace=(ntrain&gt;n))
y=Y[Trainset]
X=matrix(rep(1, n)[Trainset], ncol=1)
Z=diag(n)[Trainset,]

X=X
y=y



########1
samout1&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), Klist=list(K),
lambda=0, W=diag(ntrain),R=list(diag(ntrain)),Siglist=list(),
corfunc=c(F,F), corfuncfixed=c(F,F), sigfunc=c(F),mmalg="emm_ml",
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)

samout2&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), Klist=list(K),
lambda=0, W=diag(ntrain),R=list(diag(ntrain)),Siglist=list(),
corfunc=c(F,F), corfuncfixed=c(F,F), sigfunc=c(F),mmalg="emm_reml",
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)

samout3&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(list("Const",c(0),K)), lambda=0, 
W=diag(ntrain),R=list(diag(ntrain)),Siglist=list(),
corfunc=c(F,F), corfuncfixed=c(F,F), sigfunc=c(F),
mmalg="dmm_ml", tolparconv=1e-10, tolparinv=1e-10,
maxiter=1000,geterrors=F)

samout4&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(list("Const",c(0),K)), lambda=0, 
W=diag(ntrain),R=list(diag(ntrain)),Siglist=list(), 
corfunc=c(F,F), corfuncfixed=c(F,F), sigfunc=c(F),
mmalg="dmm_reml", tolparconv=1e-10, tolparinv=1e-10,
maxiter=1000,geterrors=F)

samout5&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(K), lambda=0, W=diag(ntrain),
R=list(diag(ntrain)),Siglist=list(), corfunc=c(F,F), 
corfuncfixed=c(F,F), sigfunc=c(F),mmalg="mm_ml", 
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)

samout6&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(diag(ntrain)),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="dermm_reml1", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout7&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(K), lambda=0, W=diag(ntrain),R=list(diag(ntrain)),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="dermm_reml2", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout8&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(K), lambda=0, W=diag(ntrain),R=list(diag(ntrain)),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="mmmk_ml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout9&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(diag(ntrain)),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="emmmk_reml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout10&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(diag(ntrain)),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="emmmk_ml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout11&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(K), lambda=0, W=diag(ntrain),R=list(diag(ntrain)),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), sigfunc=c(F),
mmalg="emmmv_ml", tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)

###########2
R&lt;-diag(ntrain)
diag(R)&lt;-diag(R)+.01*rnorm(nrow(R))

samout12&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(K), lambda=0, W=diag(ntrain),R=list(R),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F),
sigfunc=c(F),mmalg="mmmk_ml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout13&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(R),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="mm_ml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout14&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(K), lambda=0, W=diag(ntrain),R=list(R),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="mmmv_ml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout15&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(R),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="mmmkmv_ml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout16&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(R),Siglist=list(),
corfunc=c(F,F), corfuncfixed=c(F,F), sigfunc=c(F),
mmalg="dermm_reml1", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout17&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(K), lambda=0, W=diag(ntrain),R=list(R),
Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F),
sigfunc=c(F),mmalg="dermm_reml2", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout18&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(list("Const",c(0),K)), lambda=0, W=diag(ntrain),
R=list(R),Siglist=list(), corfunc=c(F,F), 
corfuncfixed=c(F,F), sigfunc=c(F),mmalg="dmm_ml",
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)

samout19&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(list("Const",c(0),K)), lambda=0, W=diag(ntrain),
R=list(R),Siglist=list(), corfunc=c(F,F), corfuncfixed=c(F,F), 
sigfunc=c(F),mmalg="dmm_reml", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)




##3
samout20&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z), 
Klist=list(list("Const",c(0),K)), lambda=0, W=diag(ntrain),
R=list(R),Siglist=list(), corfunc=c(T,F), corfuncfixed=c(F,F),
sigfunc=c(F),mmalg="dmm_reml", tolparconv=1e-10, 
tolparinv=1e-10,maxiter=1000,geterrors=F)

samout21&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(list("ar1",c(0),matrix(n,1,1))), lambda=0, 
W=diag(ntrain),R=list(R),Siglist=list(), corfunc=c(T,F),
corfuncfixed=c(F,F), sigfunc=c(F),mmalg="dmm_reml",
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)


samout22&lt;-SAMM(Y=matrix(y,ncol=1),X=X, Zlist=list(Z),
Klist=list(list("ar1het",rep(0,n),matrix(n,1,1))), lambda=0,
W=diag(ntrain),R=list(R),Siglist=list(), corfunc=c(T,F),
corfuncfixed=c(F,F), sigfunc=c(F),mmalg="dmm_reml",
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)

samout1$Vu
samout2$Vu
samout3$Vu
samout4$Vu
samout5$Vu
samout6$Vu
samout7$Vu
samout8$Vu
samout9$Vu
samout10$Vu
samout11$Vu

samout12$Vu
samout13$Vu
samout14$sigmahatlist[[1]]
samout15$sigmahatlist[[1]]
samout16$Vu
samout17$Vu
samout18$Vu
samout19$Vu

samout20$Ve
str(samout19)


str(samout20)
str(samout21)
str(samout22)




###

samout1$Vu
samout2$Vu
samout3$Vu
samout4$Vu
samout5$Vu
samout6$Vu
samout7$Vu
samout8$Vu
samout9$Vu
samout10$Vu
samout11$Vgt

samout12$Vu
samout13$Vu
samout14$sigmahatlist[[1]]
samout15$sigmahatlist[[1]]
samout16$Vu
samout17$Vu
samout18$Vu
samout19$Vu

samout20$Ve
str(samout19)


str(samout20)
str(samout21)
str(samout22)



###############################


n=100
nsample=80
rhotrans=5
rho=tan((pi/2)*print((2/pi)*atan(rhotrans)))
rho
M1&lt;-matrix(rbinom(n*300, 2, .2)-1, nrow=n)
K1&lt;-relmatcov_cppforR(c(.01), M1)

M2&lt;-matrix(rbinom(n*300, 2, .2)-1, nrow=n)
K2&lt;-relmatcov_cppforR(c(-0.3), M2)
##K2&lt;-ar1_cppforR(c(20), matrix(n))
W=(diag(5)[sample(1:5,n, replace=T),])
covY&lt;-3*K1+5*K2+10*(W%*%ar1cov_cppforR(c(rhotrans),matrix(5))%*%t(W))
K1[1:5,1:5]
dim(W)
dim(ar1cov_cppforR(c(6),matrix(5)))
Y&lt;-10+crossprod(chol(covY),rnorm(n))


#training set
Trainset&lt;-sample(1:n,nsample)
ytrain=Y[Trainset]
Xtrain=matrix(rep(1, n)[Trainset], ncol=1)
Ztrain=diag(n)[Trainset,]
Wtrain=W[Trainset,]



samout27&lt;-SAMM(Y=matrix(ytrain,ncol=1),X=Xtrain,
Zlist=list(Ztrain, Ztrain), Klist=list(K1,K2), 
lambda=0, W=Wtrain,R=list(list("ar1",c(0),matrix(5,1,1))),
Siglist=list("","",""), corfunc=c(F,F,T), 
corfuncfixed=c(F,F,F), sigfunc=c(F,F,F),mmalg="mmmk_ml",
tolparconv=1e-10, tolparinv=1e-10,maxiter=1000,geterrors=F)
str(samout27)


samout29&lt;-SAMM(Y=matrix(ytrain,ncol=1),X=Xtrain,
Zlist=list(Ztrain, Ztrain), Klist=list(K1,K2),
lambda=0, W=Wtrain,R=list("ar1",c(0),matrix(5,1,1)),
Siglist=list("","",""), corfunc=c(F,F,T),
corfuncfixed=c(F,F,F), sigfunc=c(F,F,F),
mmalg="dermm_reml1", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)

str(samout29)

samout30&lt;-SAMM(Y=matrix(ytrain,ncol=1),X=Xtrain,
Zlist=list(Ztrain, Ztrain), Klist=list(K1,K2),
lambda=0, W=Wtrain,R=list("ar1",c(0),matrix(5,1,1)),
Siglist=list("","",""), corfunc=c(F,F,T), corfuncfixed=c(F,F,F),
sigfunc=c(F,F,F),mmalg="dermm_reml2", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)
str(samout30)


###########################

n=100
M1&lt;-matrix(rbinom(n*150, 2, .2)-1, nrow=n)
K1&lt;-relmatcov_cppforR(c(0), M1)
M2&lt;-matrix(rbinom(n*150, 2, .2)-1, nrow=n)
K2&lt;-relmatcov_cppforR(c(0), M2)
M3&lt;-matrix(rbinom(n*100, 2, .2)-1, nrow=n)
K3&lt;-relmatcov_cppforR(c(0), M3)
M4&lt;-matrix(rbinom(n*100, 2, .2)-1, nrow=n)
K4&lt;-relmatcov_cppforR(c(0), M4)


covY&lt;-2*K1+3*K2+1*K3+2*K4+3*diag(n)

Y&lt;-10+crossprod(chol(covY),rnorm(n))


#training set
Trainset&lt;-sample(1:n,80)
y=Y[Trainset]
X=matrix(rep(1, n)[Trainset], ncol=1)
Z=diag(n)[Trainset,]

X=X
y=y

samout35&lt;-SAMM(Y=matrix(y,ncol=1),X=X,Zlist=list(Z,Z,Z,Z),
lambda=0,Klist=list(K1,K2,K3,K4), W=Z,R=list(diag(n)),
Siglist=list("","","","",""), corfunc=c(F,F,F,F,F), 
corfuncfixed=c(T,T,T,T,T),sigfunc=c(F,F,F,F,F),
mmalg="mmmk_ml", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)
str(samout35)

samout36&lt;-SAMM(Y=matrix(y,ncol=1),X=X,Zlist=list(Z,Z,Z,Z),
lambda=0.99999,Klist=list(K1,K2,K3,K4), W=Z,
R=list(diag(n)),Siglist=list("","","","",""),
corfunc=c(F,F,F,F,F), corfuncfixed=c(T,T,T,T,T),
sigfunc=c(F,F,F,F,F),mmalg="mmmk_ml", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)
str(samout36)


outmat&lt;-c()
for (lambda in seq(0,.999999, length=30)){
  
  
  samout37&lt;-SAMM(Y=matrix(y,ncol=1),X=X,
  Zlist=list(Z,Z,Z,Z),lambda=lambda,Klist=list(K1,K2,K3,K4),
  W=Z,R=list(diag(n)),Siglist=list("","","","",""),
  corfunc=c(F,F,F,F,F), corfuncfixed=c(T,T,T,T,T), 
  sigfunc=c(F,F,F,F,F),mmalg="mmmk_ml",
  tolparconv=1e-10, tolparinv=1e-10,
  maxiter=1000,geterrors=F)
  
  
  outmat&lt;-cbind(outmat,c(samout37$Vu*samout37$weights, samout37$Ve))
  
}
str(samout37)
colnames(outmat)&lt;-seq(0,.999999, length=30)

maxmat&lt;-max(c(outmat))
minmat&lt;-min(c(outmat))

plot(seq(0,.999999, length=30),outmat[1,],
ylim=c(minmat-1, maxmat+1), col=2, type="l")
for (i in 2:5){
  par(new=T)
  plot(seq(0,.999999, length=30), outmat[i,],
  axes=F, ylim=c(minmat-1, maxmat+1), col=i+1, type="l", xlab="", ylab="")
}


## End(Not run) 
</code></pre>

<hr>
<h2 id='SAMM-package'>
Some Algorithms for Mixed Models
</h2><span id='topic+SAMM-package'></span><span id='topic+SAMM-package'></span>

<h3>Description</h3>

<p>This program can be used to fit Gaussian linear mixed models (LMM). Univariate and multivariate response models, multiple variance components, as well as, certain correlation and covariance structures are supported. In many occasions, the user can pick one of the several mixed model fitting algorithms, which are explained further in the details section. Some algorithms are specific to certain types of models (univariate or multivariate, diagonal or non-diagonal residual, one or multiple variance components, etc,...).
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SAMM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Some Algorithms for Mixed Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-11-22</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Deniz Akdemir</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> This program can be used to fit Gaussian linear mixed models (LMM). Univariate and multivariate response models, multiple variance components, as well as, certain correlation and covariance structures are supported. In many occasions, the user can pick one of the several mixed model fitting algorithms, which are explained further in the details section. Some algorithms are specific to certain types of models (univariate or multivariate, diagonal or non-diagonal residual, one or multiple variance components, etc,...).</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 0.12.4)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
FA1hetSig_cppforR       Covariance and Sigma Functions
SAMM                    Some Algoritms for Mixed Models
SAMM-package            Some Algorithms for Mixed Models
loglikfuncmmmkmv        Calculate the loglikeligood for a general mixed
                        model
</pre>
<p>This program can be used to fit Gaussian linear mixed models (LMM). Univariate and multivariate response models, multiple variance components, as well as, certain correlation and covariance structures are supported. In many occations, the user can pick one of the several mixed model fitting algorithms, which are explained further in the details section. Some algorithms are specific to certain types of models (univariate or multivariate, diagonal or nondiagonal residual, one or multiple variance components, etc,...).
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>
<p>Maintainer: Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bates, Douglas M. &quot;lme4: Mixed-effects modeling with R.&quot; URL http://lme4. r-forge. r-project. org/book (2010).
</p>
<p>Zhou, Hua, et al. &quot;MM Algorithms for Variance Components Models.&quot; arXiv preprint arXiv:1509.07426 (2015).
</p>
<p>Zhou, Xiang, and Matthew Stephens. &quot;Efficient algorithms for multivariate linear mixed models in genome-wide association studies.&quot; Nature methods 11.4 (2014): 407.
</p>
<p>Kang, Hyun Min, et al. &quot;Efficient control of population structure in model organism association mapping.&quot; Genetics 178.3 (2008): 1709-1723.
</p>
<p>Gilmour, Arthur R., Robin Thompson, and Brian R. Cullis. &quot;Average information REML: an efficient algorithm for variance parameter estimation in linear mixed models.&quot; Biometrics (1995): 1440-1450.
</p>


<h3>See Also</h3>

<p>~~ Optional links to other man pages, e.g. ~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=2
</code></pre>

<hr>
<h2 id='sigcovfuncs_cppforR'>Covariance and Sigma Functions</h2><span id='topic+FA1hetSig_cppforR'></span><span id='topic+FA1homSig_cppforR'></span><span id='topic+FAhetSig_cppforR'></span><span id='topic+FAhomSig_cppforR'></span><span id='topic+UnstrKronIdentSig_cppforR'></span><span id='topic+IdentKronUnstrSig_cppforR'></span><span id='topic+IdentSig_cppforR'></span><span id='topic+ar1hetcov_cppforR'></span><span id='topic+arma11cov_cppforR'></span><span id='topic+compsymmcov_cppforR'></span><span id='topic+compsymmhetSig_cppforR'></span><span id='topic+compsymmhetcov_cppforR'></span><span id='topic+compsymmhomSig_cppforR'></span><span id='topic+diagSig_cppforR'></span><span id='topic+diagcov_cppforR'></span><span id='topic+expcov_cppforR'></span><span id='topic+lincombcov_cppforR'></span><span id='topic+rbfcov_cppforR'></span><span id='topic+ar1cov_cppforR'></span><span id='topic+unstrKronKcov_cppforR'></span><span id='topic+relmatcov_cppforR'></span><span id='topic+UnstrKronUnstrcov_cppforR'></span><span id='topic+unstrcov_cppforR'></span><span id='topic+ConstMatcov_cppforR'></span><span id='topic+KKronar1cov_cppforR'></span><span id='topic+KKronar1hetcov_cppforR'></span><span id='topic+KKronarma11cov_cppforR'></span><span id='topic+KKroncompsymmcov_cppforR'></span><span id='topic+KKroncompsymmhetcov_cppforR'></span><span id='topic+KKrondiagcov_cppforR'></span><span id='topic+KKronunstrcov_cppforR'></span><span id='topic+ar1KronKcov_cppforR'></span><span id='topic+ar1hetKronKcov_cppforR'></span><span id='topic+arma11KronKcov_cppforR'></span><span id='topic+compsymmKronKcov_cppforR'></span><span id='topic+compsymmhetKronKcov_cppforR'></span><span id='topic+diagKronKcov_cppforR'></span><span id='topic+expdistcov_cppforR'></span><span id='topic+rbfdistcov_cppforR'></span><span id='topic+splincov_cppforR'></span><span id='topic+splinlogcov_cppforR'></span><span id='topic+sppowcov_cppforR'></span>

<h3>Description</h3>

<p>The &quot;kernel&quot; functions end with &quot;cov_cppforR&quot; and sigma functions end with &quot;Sig_cppforR&quot;. Check table below and the examples for details and usage. Documentation for some of these functions is missing. Let <code class="reqn">K</code> be a given covariance matrix, <code class="reqn">D</code> be a given Euclidean distance matrix, let <code class="reqn">q</code> be the dimension of desired sigma or covariance matrices. 
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigcovfuncs_cppforR_+3A_params">params</code></td>
<td>
<p>a numeric vector for the parameters (a mapping of the original parameters)</p>
</td></tr>
<tr><td><code id="sigcovfuncs_cppforR_+3A_data">data</code></td>
<td>
<p>a numeric matrix (see examples and details)</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
  <strong>function name</strong></td><td style="text-align: right;"> <strong>function ref</strong> </td><td style="text-align: right;"> <strong>params</strong> </td><td style="text-align: right;"> <strong>data</strong> </td><td style="text-align: right;"> <strong>formula</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
 

   IdentSig_cppforR </td><td style="text-align: right;"> Ident </td><td style="text-align: right;"> 1 </td><td style="text-align: right;">  matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A=\sigma I_q</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">

  ar1hetcov_cppforR </td><td style="text-align: right;"> ar1het </td><td style="text-align: right;"> q </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma_i\sigma_j\rho^{|i-j|}</code>,</td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">\sigma_1=1</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

  arma11cov_cppforR</td><td style="text-align: right;"> arma11 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=(\lambda\rho^{|i-j|-1}*</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">1(i\neq j)+1(i=j))</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 FA1hetSig_cppforR </td><td style="text-align: right;"> FA1het </td><td style="text-align: right;"> 2q-2 </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">f_if_j+\sigma_{ii}1(i=j) </code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">f_1=1,</code> <code class="reqn">\sigma_1=1</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

  FA1homSig_cppforR </td><td style="text-align: right;"> FA1hom </td><td style="text-align: right;"> q </td><td style="text-align: right;">  matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">f_if_j+\sigma 1(i=j)</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">f_1=1</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    
  compsymmcov_cppforR </td><td style="text-align: right;"> compsymm </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;">  <code class="reqn">A_{ij}=\rho</code>, <code class="reqn">i\neq j;</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">A_{ij}=1</code>, <code class="reqn">i=j</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

   compsymmhetSig_cppforR </td><td style="text-align: right;"> compsymmhet </td><td style="text-align: right;"> q+1 </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma_i\sigma_j\rho,</code> <code class="reqn">i\neq j</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma_i\sigma_j,</code> <code class="reqn">i= j</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

  compsymmhetcov_cppforR </td><td style="text-align: right;"> compsymmhet </td><td style="text-align: right;"> q </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma_i\sigma_j\rho,</code> <code class="reqn">i\neq j</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma_i\sigma_j,</code> <code class="reqn">i= j</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">\sigma_1=1</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">

  compsymmhomSig_cppforR </td><td style="text-align: right;"> compsymmhom </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma\rho</code>, <code class="reqn">i\neq j;</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma</code>, <code class="reqn">i=j</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

  diagSig_cppforR </td><td style="text-align: right;"> diag </td><td style="text-align: right;"> q </td><td style="text-align: right;">  matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">diag(\sigma_1,..,\sigma_q)</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">

   diagcov_cppforR </td><td style="text-align: right;"> Diag </td><td style="text-align: right;"> q-1 </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">diag(1,\sigma_2,..,\sigma_q)</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

  expcov_cppforR </td><td style="text-align: right;"> exp </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> M </td><td style="text-align: right;"> <code class="reqn">exp(-\sigma*d_{ij})</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> M defines D </td>
</tr>
<tr>
 <td style="text-align: right;">

  lincombcov_cppforR </td><td style="text-align: right;"> lincomb </td><td style="text-align: right;"> k </td><td style="text-align: right;"> <code class="reqn">(K_1;\ldots; K_k)</code> </td><td style="text-align: right;"> <code class="reqn">\sum^k_{j=1}w_jK_j</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

   rbfcov_cppforR </td><td style="text-align: right;"> rbf </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> M </td><td style="text-align: right;"> <code class="reqn">exp(-\sigma*d^2_{ij})</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> M defines D </td>
</tr>
<tr>
 <td style="text-align: right;">

  ar1cov_cppforR </td><td style="text-align: right;"> ar1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> matrix(nrow, 1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\rho^{|i-j|}</code></td>
</tr>
<tr>
 <td style="text-align: right;">

  relmatcov_cppforR </td><td style="text-align: right;"> RelMat</td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> M </td><td style="text-align: right;"> Genetic Similarity+</td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> M is coded as -1, 0, 1  </td><td style="text-align: right;">  <code class="reqn">\sigma I</code></td>
</tr>
<tr>
 <td style="text-align: right;">

  unstrcov_cppforR </td><td style="text-align: right;"> unstr </td><td style="text-align: right;"> <code class="reqn">\frac{q(q+1)}{2}-1</code> </td><td style="text-align: right;"> matrix(q,1,1) </td><td style="text-align: right;"> <code class="reqn">A_{ij}=\sigma_i\sigma_j\rho_{ij}</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"><code class="reqn">\sigma_1=1,</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   <code class="reqn">\rho_{ii}=1</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

  ConstMatcov_cppforR </td><td style="text-align: right;"> Const </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> K </td><td style="text-align: right;"> <code class="reqn">A=K</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  
  expdistcov_cppforR </td><td style="text-align: right;"> expdist </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> D </td><td style="text-align: right;"> <code class="reqn">exp(-\sigma d_{ij})</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   
   rbfdistcov_cppforR </td><td style="text-align: right;"> rbfdist </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> D </td><td style="text-align: right;"> <code class="reqn">exp(-\sigma d^2_{ij})</code></td>
</tr>
<tr>
 <td style="text-align: right;">
   
   splincov_cppforR </td><td style="text-align: right;"> splin </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> D </td><td style="text-align: right;"> <code class="reqn">1-\rho d_{ij},</code> <code class="reqn">\rho d_{ij}\leq 1</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;">   </td><td style="text-align: right;"> <code class="reqn">0,</code> <code class="reqn">\rho d_{ij}&gt; 1</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   
   sppowcov_cppforR </td><td style="text-align: right;"> sppow </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> D </td><td style="text-align: right;"> <code class="reqn">\rho^{d_{ij}}</code>

 </td>
</tr>

</table>



<h3>Value</h3>

<p>A kernel or sigma matrix. 
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SAMM)
n=100
nsample=80
rhotrans=5
ar1cov_cppforR(c(rhotrans),matrix(5))
rho=(2/pi)*atan(rhotrans)
rho
tan((pi/2)*(rho))

M1&lt;-matrix(rbinom(n*300, 2, .2)-1, nrow=n)
K1&lt;-relmatcov_cppforR(c(.01), M1)

M2&lt;-matrix(rbinom(n*300, 2, .2)-1, nrow=n)
K2&lt;-relmatcov_cppforR(c(0.03), M2)
W=(diag(5)[sample(1:5,n, replace=TRUE),])
covY&lt;-3*K1+5*K2+10*(W%*%ar1cov_cppforR(c(rhotrans),matrix(5))%*%t(W))
K1[1:5,1:5]
dim(W)
dim(ar1cov_cppforR(c(6),matrix(5)))
Y&lt;-10+crossprod(chol(covY),rnorm(n))


#training set
Trainset&lt;-sample(1:n,nsample)
ytrain=Y[Trainset]
Xtrain=matrix(rep(1, n)[Trainset], ncol=1)
Ztrain=diag(n)[Trainset,]
Wtrain=W[Trainset,]

samout&lt;-SAMM(Y=matrix(ytrain,ncol=1),X=Xtrain,
Zlist=list(Ztrain, Ztrain), Klist=list(K1,K2),
lambda=0, W=Wtrain,R=list("ar1",c(0),matrix(5,1,1)),
Siglist=list("","",""), corfunc=c(F,F,T), corfuncfixed=c(F,F,F),
sigfunc=c(F,F,F),mmalg="dermm_reml2", tolparconv=1e-10,
tolparinv=1e-10,maxiter=1000,geterrors=F)
samout$corfuncparamslist[[3]]
rhohat=(2/pi)*atan(samout$corfuncparamslist[[3]])
rhohat
ar1cov_cppforR(c(samout$corfuncparamslist[[3]]),matrix(5,1,1))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
