<!DOCTYPE html><html lang="en"><head><title>Help for package BMS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BMS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BMS-package'><p>BMS: Bayesian Model Averaging Library</p></a></li>
<li><a href='#as.zlm'><p>Extract a Model from a bma Object</p></a></li>
<li><a href='#beta.draws.bma'><p>Coefficients of the Best Models</p></a></li>
<li><a href='#bma-class'><p>Class &quot;bma&quot;</p></a></li>
<li><a href='#bms'><p>Bayesian Model Sampling and Averaging</p></a></li>
<li><a href='#c.bma'><p>Concatenate bma objects</p></a></li>
<li><a href='#datafls'><p>FLS (2001) growth data</p></a></li>
<li><a href='#density.bma'><p>Coefficient Marginal Posterior Densities</p></a></li>
<li><a href='#estimates.bma'><p>Posterior Inclusion Probabilities and Coefficients from a 'bma' Object</p></a></li>
<li><a href='#f21hyper'><p>Gaussian Hypergeometric Function F(a,b,c,z)</p></a></li>
<li><a href='#fullmodel.ssq'><p>OLS Statistics for the Full Model Including All Potential Covariates</p></a></li>
<li><a href='#gdensity'><p>Posterior Density of the Shrinkage Factor</p></a></li>
<li><a href='#gprior-class'><p>Class &quot;gprior&quot;</p></a></li>
<li><a href='#hex2bin'><p>Converting Binary Code to and from Hexadecimal Code</p></a></li>
<li><a href='#image.bma'><p>Plot Signs of Best Models</p></a></li>
<li><a href='#info.bma'><p>Summary Statistics for a 'bma' Object</p></a></li>
<li><a href='#is.bma'><p>Tests for a 'bma' Object</p></a></li>
<li><a href='#lps.bma'><p>Log Predictive Score</p></a></li>
<li><a href='#mprior-class'><p>Class &quot;mprior&quot;</p></a></li>
<li><a href='#plot.bma'><p>Plot Posterior Model Size and Model Probabilities</p></a></li>
<li><a href='#plotComp'><p>Compare Two or More bma Objects</p></a></li>
<li><a href='#plotConv'><p>Plot Convergence of BMA Sampler</p></a></li>
<li><a href='#plotModelsize'><p>Plot Model Size Distribution</p></a></li>
<li><a href='#pmp.bma'><p>Posterior Model Probabilities</p></a></li>
<li><a href='#pmpmodel'><p>Posterior Model Probability for any Model</p></a></li>
<li><a href='#post.var'><p>Posterior Variance and Deviance</p></a></li>
<li><a href='#pred.density'><p>Predictive Densities for bma Objects</p></a></li>
<li><a href='#predict.bma'><p>Predict Method for bma Objects</p></a></li>
<li><a href='#predict.zlm'><p>Predict Method for zlm Linear Model</p></a></li>
<li><a href='#print.topmod'><p>Printing topmod Objects</p></a></li>
<li><a href='#quantile.density'><p>Extract Quantiles from 'density' Objects</p></a></li>
<li><a href='#summary.zlm'><p>Summarizing Linear Models under Zellner's g</p></a></li>
<li><a href='#topmod'><p>Topmodel Object</p></a></li>
<li><a href='#topmod-class'><p>Class &quot;topmod&quot;</p></a></li>
<li><a href='#topmodels.bma'><p>Model Binaries and their Posterior model Probabilities</p></a></li>
<li><a href='#variable.names.bma'><p>Variable names and design matrix</p></a></li>
<li><a href='#variable.names.zlm'><p>Variable names and design matrix</p></a></li>
<li><a href='#zlm'><p>Bayesian Linear Model with Zellner's g</p></a></li>
<li><a href='#zlm-class'><p>Class &quot;zlm&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Model Averaging Library</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Feldkircher and Stefan Zeugner and Paul Hofmarcher</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Zeugner &lt;stefan.zeugner@ec.europa.eu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, stats, graphics, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian Model Averaging for linear models with a wide choice of (customizable) priors. Built-in priors include coefficient priors (fixed, hyper-g and empirical priors), 5 kinds of model priors, moreover model sampling by enumeration or various MCMC approaches. Post-processing functions allow for inferring posterior inclusion and model probabilities, various moments, coefficient and predictive densities. Plotting functions available for posterior model size, MCMC convergence, predictive and coefficient densities, best models representation, BMA comparison. Also includes Bayesian normal-conjugate linear model with Zellner's g prior, and assorted methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-05 10:42:16 UTC; admin-b1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-09 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BMS-package'>BMS: Bayesian Model Averaging Library</h2><span id='topic+BMS'></span><span id='topic+BMS-package'></span>

<h3>Description</h3>

<p>Bayesian Model Averaging for linear models with a wide choice of (customizable) priors. Built-in priors include coefficient priors (fixed, hyper-g and empirical priors), 5 kinds of model priors, moreover model sampling by enumeration or various MCMC approaches. Post-processing functions allow for inferring posterior inclusion and model probabilities, various moments, coefficient and predictive densities. Plotting functions available for posterior model size, MCMC convergence, predictive and coefficient densities, best models representation, BMA comparison. Also includes Bayesian normal-conjugate linear model with Zellner's g prior, and assorted methods.
</p>


<h3>Details</h3>

<p>The key function you need is  <code><a href="#topic+bms">bms</a></code>.
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher, Paul Hofmarcher, and Stefan Zeugner
</p>


<h3>References</h3>

<p><a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a>: BMS package homepage with help and tutorials
</p>
<p>Feldkircher, M. and S. Zeugner (2015): Bayesian Model Averaging Employing 
Fixed and Flexible Priors: The BMS Package for R, Journal of Statistical Software 68(4).
</p>
<p>Feldkircher, M. and S. Zeugner (2009): Benchmark Priors
Revisited: On Adaptive Shrinkage and the Supermodel Effect in Bayesian Model
Averaging, IMF Working Paper 09/202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.bma">coef.bma</a></code>, <code><a href="#topic+plotModelsize">plotModelsize</a></code> and
<code><a href="#topic+density.bma">density.bma</a></code> for some operations on the resulting 'bma' object, 
as well as 
<code><a href="#topic+predict.bma">predict.bma</a></code> or <code><a href="#topic+gdensity">gdensity</a></code>, or
<code><a href="#topic+zlm">zlm</a></code> for individual Zellner regression models.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>

<hr>
<h2 id='as.zlm'>Extract a Model from a bma Object</h2><span id='topic+as.zlm'></span>

<h3>Description</h3>

<p>Extracts a model out of a <code>bma</code> object's saved models and converts it
to a <code><a href="#topic+zlm">zlm</a></code> linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.zlm(bmao, model = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.zlm_+3A_bmao">bmao</code></td>
<td>
<p>A <code>bma</code> object, e.g. resulting from a call to
<code><a href="#topic+bms">bms</a></code></p>
</td></tr>
<tr><td><code id="as.zlm_+3A_model">model</code></td>
<td>
<p>The model index, in one of the following forms:<br /> An integer,
denoting the rank of the model (1 for best, 2 for second-best, ...)<br /> A
numeric or logical vector of length K describing which covariates are
contained in the model<br /> A hexcode character describing which covariates
are contained in the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bma object stores several 'best' models it encounters (cf. argument
<code>nmodel</code> in <code><a href="#topic+bms">bms</a></code>). <code>as.zlm</code> extracts a single model
and converts it to an object of class <code><a href="#topic+zlm">zlm</a></code>, which represents a
linear model estimated under Zellner's g prior.<br /> The utility
<code><a href="stats.html#topic+model.frame">model.frame</a></code> allows to transfrom a <code>zlm</code> model into an OLS
model of class <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Value</h3>

<p>a list of class <code><a href="#topic+zlm">zlm</a></code>
</p>


<h3>Author(s)</h3>

<p>Stefan Zeugner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating <code>bma</code> objects,
<code><a href="#topic+zlm">zlm</a></code> for creating <code>zlm</code> objects,
<code><a href="#topic+pmp.bma">pmp.bma</a></code> for displaying the
topmodels in a <code>bma</code> object
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datafls)

mm=bms(datafls[,1:6],mcmc="enumeration") # do a small BMA chain
topmodels.bma(mm)[,1:5] #display the best 5 models

m2a=as.zlm(mm,4) #extract the fourth best model
summary(m2a)

# Bayesian Model Selection:
# transform the best model into an OLS model:
lm(model.frame(as.zlm(mm)))

# extract the model only containing the 5th regressor
m2b=as.zlm(mm,c(0,0,0,0,1)) 

# extract the model only containing the 5th regressor in hexcode
print(bin2hex(c(0,0,0,0,1)))
m2c=as.zlm(mm,"01")




</code></pre>

<hr>
<h2 id='beta.draws.bma'>Coefficients of the Best Models</h2><span id='topic+beta.draws.bma'></span>

<h3>Description</h3>

<p>Returns a matrix whose columns are the (expected value or standard
deviations of) coefficients for the best models in a bma object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.draws.bma(bmao, stdev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta.draws.bma_+3A_bmao">bmao</code></td>
<td>
<p>a 'bma' object (as e.g. resulting from <code><a href="#topic+bms">bms</a></code>)</p>
</td></tr>
<tr><td><code id="beta.draws.bma_+3A_stdev">stdev</code></td>
<td>
<p>if <code>stdev=FALSE</code> then <code>beta.draws.bma</code> returns the
(conditional) posterior expected values of the coefficients (i.e. 'Bayesian
coefficients'). If <code>stdev=TRUE</code> it returns their posterior standard
deviations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each column presents the coefficients for the model indicated by its
column name. The zero coefficients are the excluded covariates per model.
Note that the coefficients returned are only those of the best (100) models
encountered by the <code>bma</code> object (cf. argument <code>nmodels</code> of
<code><a href="#topic+bms">bms</a></code>).
</p>
<p>For aggregate coefficients please refer to <code><a href="#topic+coef.bma">coef.bma</a></code>.
</p>


<h3>Note</h3>

<p>Note that the elements of <code>beta.draws.bma(bmao)</code> correspond to
<code>bmao$topmod$betas()</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating bms objects, <code><a href="#topic+coef.bma">coef.bma</a></code>
for aggregate coefficients
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #sample a bma object:
  data(datafls)
  mm=bms(datafls,burn=500,iter=5000,nmodel=20)
  
  #coefficients for all
  beta.draws.bma(mm) 
  
  #standard deviations for the fourth- to eight best models
  beta.draws.bma(mm[4:8],TRUE); 

</code></pre>

<hr>
<h2 id='bma-class'>Class &quot;bma&quot;</h2><span id='topic+bma-class'></span>

<h3>Description</h3>

<p>A list holding results from a BMA iteration chain
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created via calls to
<code><a href="#topic+bms">bms</a></code>, but indirectly also via <code><a href="#topic+c.bma">c.bma</a></code><br /> A
<code>bma</code> object is a list whose elements hold information on input and
output for a Bayesian Model Averaging iteration chain, such as from a call
to <code><a href="#topic+bms">bms</a></code>:
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher and Stefan Zeugner
</p>


<h3>References</h3>

<p><a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating <code>bma</code> objects,<br /> or
<code><a href="#topic+topmod-class">topmod</a></code> for the topmod object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm=bms(datafls)
 #show posterior model size
 print(mm$info$msize/mm$info$cumsumweights)
 #is the same number as in
 summary(mm)
 

</code></pre>

<hr>
<h2 id='bms'>Bayesian Model Sampling and Averaging</h2><span id='topic+bms'></span>

<h3>Description</h3>

<p>Given data and prior information, this function samples all possible model
combinations via MC3 or enumeration and returns aggregate results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bms(
  X.data,
  burn = 1000,
  iter = NA,
  nmodel = 500,
  mcmc = "bd",
  g = "UIP",
  mprior = "random",
  mprior.size = NA,
  user.int = TRUE,
  start.value = NA,
  g.stats = TRUE,
  logfile = FALSE,
  logstep = 10000,
  force.full.ols = FALSE,
  fixed.reg = numeric(0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bms_+3A_x.data">X.data</code></td>
<td>
<p>a data frame or a matrix, with the dependent variable in the
first column, followed by the covariates (alternatively, <code>X.data</code> can
also be provided as a <code><a href="stats.html#topic+formula">formula</a></code>).  Note that <code>bms</code>
automatically estimates a constant, therefore including constant terms is
not necessary.</p>
</td></tr>
<tr><td><code id="bms_+3A_burn">burn</code></td>
<td>
<p>The (positive integer) number of burn-in draws for the MC3
sampler, defaults to 1000. (Not taken into account if mcmc=&quot;enumerate&quot;)</p>
</td></tr>
<tr><td><code id="bms_+3A_iter">iter</code></td>
<td>
<p>If mcmc is set to an MC3 sampler, then this is the number of
iteration draws to be sampled (ex burn-ins), default 3000 draws. <br /> If
<code>mcmc="enumerate"</code>, then iter is the number of models to be sampled,
starting from 0 (defaults to <code class="reqn">2^K-1</code>) - cf. <code>start.value</code>.</p>
</td></tr>
<tr><td><code id="bms_+3A_nmodel">nmodel</code></td>
<td>
<p>the number of best models for which information is stored
(default 500). Best models are used for convergence analysis between
likelihoods and MCMC frequencies, as well as likelihood-based inference.<br />
Note that a very high value for <code>nmodel</code> slows down the sampler
significantly. Set nmodel=0 to speed up sampling (if best model information
is not needed).</p>
</td></tr>
<tr><td><code id="bms_+3A_mcmc">mcmc</code></td>
<td>
<p>a character denoting the model sampler to be used.<br /> The MC3
sampler <code>mcmc="bd"</code> corresponds to a birth/death MCMC algogrithm.
<code>mcmc="rev.jump"</code> enacts a reversible jump algorithm adding a &quot;swap&quot;
step to the birth / death steps from &quot;bd&quot;.<br /> Alternatively, the entire
model space may be fully enumerated by setting <code>mcmc="enumerate"</code> which
will iterate all possible regressor combinations (Note: consider that this
means <code class="reqn">2^K</code> iterations, where K is the number of covariates.)<br /> Default
is full enumeration (<code>mcmc="enumerate"</code>) with less then 15 covariates,
and the birth-death MC3 sampler (<code>mcmc="bd"</code>) with 15 covariates or
more. Cf. section 'Details' for more options.</p>
</td></tr>
<tr><td><code id="bms_+3A_g">g</code></td>
<td>
<p>the hyperparameter on Zellner's g-prior for the regression
coefficients.<br /> <code>g="UIP"</code> corresponds to <code class="reqn">g=N</code>, the number of
observations (default);<br /> <code>g="BRIC"</code> corresponds to the benchmark
prior suggested by Fernandez, Ley and Steel (2001), i.e <code class="reqn">g=max(N, K^2)</code>,
where K is the total number of covariates;<br /> <code>g="RIC"</code> sets
<code class="reqn">g=K^2</code> and conforms to the risk inflation criterion by George and
Foster (1994)<br /> <code>g="HQ"</code> sets <code class="reqn">g=log(N)^3</code> and asymptotically
mimics the Hannan-Quinn criterion with <code class="reqn">C_{HQ}=3</code> (cf. Fernandez, Ley
and Steel, 2001, p.395)<br /> <code>g="EBL"</code> estimates a local empirical Bayes
g-parameter (as in Liang et al. (2008));<br /> <code>g="hyper"</code> takes the
'hyper-g' prior distribution (as in Liang et al., 2008) with the default
hyper-parameter <code class="reqn">a</code> set such that the prior expected shrinkage factor
conforms to 'UIP';<br /> This hyperparameter <code class="reqn">a</code> can be adjusted (between
<code class="reqn">2&lt;a&lt;=4</code>) by setting <code>g="hyper=2.9"</code>, for instance.<br />
Alternatively, <code>g="hyper=UIP"</code> sets the prior expected value of the
shrinkage factor equal to that of UIP (default), <code>g="hyper=BRIC"</code> sets
it according to BRIC <br /> cf section 'Details' fro more on the hyper-g prior</p>
</td></tr>
<tr><td><code id="bms_+3A_mprior">mprior</code></td>
<td>
<p>a character denoting the model prior choice, defaulting to
&quot;random&quot;:<br /> <code>mprior="fixed"</code> denotes fixed common prior inclusion
probabilities for each regressor as e.g. in Sala-i-Martin, Doppelhofer, and
Miller(2004) - for their fine-tuning, cf. <code>mprior.size</code>. Preferable to
<code>mcmc="random"</code> if strong prior information on model size exists;<br />
<code>mprior="random"</code> (default) triggers the 'random theta' prior by Ley
and Steel (2008), who suggest a binomial-beta hyperprior on the a priori
inclusion probability;<br /> <code>mprior="uniform"</code> employs the uniform model
prior;<br /> <code>mprior="customk"</code> allows for custom model size priors (cf.
<code>mprior.size</code>);<br /> <code>mprior="pip"</code> allows for custom prior
inclusion probabilities (cf. <code>mprior.size</code>);<br /> Note that the prior on
models with more than N-3 regressors is automatically zero: these models
will not be sampled.</p>
</td></tr>
<tr><td><code id="bms_+3A_mprior.size">mprior.size</code></td>
<td>
<p>if <code>mprior</code> is &quot;fixed&quot; or &quot;random&quot;,
<code>mprior.size</code> is a scalar that denotes the prior expected value of the
model size prior (default K/2).<br /> If <code>mprior="customk"</code> then a custom
model size prior can be provided as a K+1 vector detailing the priors from
model size 0 to K (e.g. rep(1,K+1) for the uniform model prior);<br /> if
<code>mprior="pip"</code>, then custom prior inclusion probabilities can be
provided as a vector of size K, with elements in the interval (0,1)</p>
</td></tr>
<tr><td><code id="bms_+3A_user.int">user.int</code></td>
<td>
<p>'interactive mode': print out results to console after
ending the routine and plots a chart (default TRUE).</p>
</td></tr>
<tr><td><code id="bms_+3A_start.value">start.value</code></td>
<td>
<p>specifies the starting model of the iteration chain. For
instance a specific model by the corresponding column indices (e.g.
starting.model=numeric(K) starts from the null model including solely a
constant term) or <code>start.value=c(3,6)</code> for a starting model only
including covariates 3 and 6.<br /> If <code>start.model</code> is set to an integer
(e.g. <code>start.model=15</code>) then that number of covariates (here: 15
covariates) is randomly chosen and the starting model is identified by those
regressors with an OLS t-statistic&gt;0.2.<br /> The default value
<code>start.value=NA</code> corresponds to
<code>start.value=min(ncol(X.data),nrow(X.data)-3)</code>. Note that
<code>start.value=0</code> or <code>start.value=NULL</code> starts from the null
model.<br /> If <code>mcmc="enumerate"</code> then <code>start.value</code> is the index to
start the iteration (default: 0, the null model) . Any number between 0 and
<code class="reqn">K^2-1</code> is admissible.</p>
</td></tr>
<tr><td><code id="bms_+3A_g.stats">g.stats</code></td>
<td>
<p><code>TRUE</code> if statistics on the shrinkage factor g/(1+g)
should be collected, defaulting to TRUE (Note: set <code>g.stats=FALSE</code> for
faster iteration.)</p>
</td></tr>
<tr><td><code id="bms_+3A_logfile">logfile</code></td>
<td>
<p>setting <code>logfile=TRUE</code> produces a logfile named
<code>"test.log"</code> in your current working directory, in order to keep track
of the sampling procedure. <code>logfile</code> equal to some filepath (like
<code>logfile="subfolder/log.txt"</code>) puts the logfile into that specified
position. (default: <code>logfile=FALSE</code>). Note that <code>logfile=""</code>
implies log printouts on the console.</p>
</td></tr>
<tr><td><code id="bms_+3A_logstep">logstep</code></td>
<td>
<p>specifies at which number of posterior draws information is
written to the log file; default: 10 000 iterations</p>
</td></tr>
<tr><td><code id="bms_+3A_force.full.ols">force.full.ols</code></td>
<td>
<p>default FALSE. If <code>force.full.ols=TRUE</code>, the OLS
estimation part of the sampling procedure relies on slower matrix inversion,
instead of streamlined routines. <code>force.full.ols=TRUE</code> can slow down
sampling but may deal better with highly collinear data</p>
</td></tr>
<tr><td><code id="bms_+3A_fixed.reg">fixed.reg</code></td>
<td>
<p>indices or variable names of <code>X.data</code> that are fixed
regressors to be always included in every sampled model. Note: the parameter
<code>mprior.size</code> refers to prior model size including these fixed
regressors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ad <code>mcmc</code>: <br /> Interaction sampler: adding an &quot;.int&quot; to an MC3 sampler
(e.g. &quot;mcmc=&quot;bd.int&quot;) provides for special treatment of interaction terms.
Interaction terms will only be sampled along with their component variables:
In the colnumn names of X.data, interaction terms need to be denominated by
names consisting of the base terms separated by <code>#</code> (e.g. an
interaction term of base variables <code>"A"</code>, <code>"B"</code> and <code>"C"</code>
needs column name <code>"A#B#C"</code>). Then variable <code>"A#B#C"</code> will only be
included in a model if all of the component variables (&quot;A&quot;, &quot;B&quot;, and &quot;C&quot;)
are included.
</p>
<p>The MC3 samplers &quot;<code>bd</code>&quot;, &quot;<code>rev.jump</code>&quot;, &quot;<code>bd.int</code>&quot; and
&quot;<code>rev.jump.int</code>&quot;, iterate away from a starting model by adding,
dropping or swapping (only in the case of rev.jump) covariates.
</p>
<p>In an MCMC fashion, they thus randomly draw a candidate model and then move
to it in case its marginal likelihood (marg.lik.) is superior to the
marg.lik. of the current model.
</p>
<p>In case the candidate's marg.lik is inferior, it is randomly accepted or
rejected according to a probability formed by the ratio of candidate
marg.lik over current marg.lik.  Over time, the sampler should thus converge
to a sensible distribution. For aggregate results based on these MC3
frequencies, the first few iterations are typically disregarded (the
'burn-ins').
</p>
<p>Ad <code>g</code> and the hyper-g prior: The hyper-g prior introduced by Liang et
al. (2008) puts a prior distribution on the shrinkage factor <code class="reqn">g/(1+g)</code>,
namely a Beta distribution <code class="reqn"> Beta(1, 1/2-1)</code> that is governed by the
parameter <code class="reqn">a</code>. <code class="reqn">a=4</code> means a uniform prior distribution of the
shrinkage factor, while <code class="reqn">a&gt;2</code> close to 2 concentrates the prior
shrinkage factor close to one. <br /> The prior expected value is
<code class="reqn">E(g/1+g)) = 2/a</code>. In this sense <code>g="hyper=UIP"</code> and
<code>g="hyper=BRIC"</code> set the prior expected shrinkage such that it conforms
to a fixed UIP-g (eqng=N) or BRIC-g (<code class="reqn">g=max(K^2,N)</code> ).
</p>


<h3>Value</h3>

<p>A list of class <code>bma</code>, that may be displayed using e.g.
<code><a href="#topic+summary.bma">summary.bma</a></code> or <code><a href="#topic+coef.bma">coef.bma</a></code>. The list contains the
following elements: </p>
<table role = "presentation">
<tr><td><code>info</code></td>
<td>
<p>a list of aggregate statistics: <code>iter</code>
is the number of iterations, <code>burn</code> the number of burn-ins.<br /> The
following have to be divided by <code>cumsumweights</code> to get posterior
expected values: <code>inccount</code> are the posterior inclusion probabilities,
<code>b1mo</code> and <code>b2mo</code> the first and second moment of coefficients,
<code>add.otherstats</code> other statistics of interest (typically the moments of
the shrinkage factor), <code>msize</code> is the post. expected model size,
<code>k.vec</code> the posterior model size distribution, <code>pos.sign</code> the
unconditional post. probability of positive coefficients, <code>corr.pmp</code> is
the correlation between the best models' MCMC frequencies and their marg.
likelihoods.<br /> <code>timed</code> is the time that was needed for MCMC sampling,
<code>cons</code> is the posterior expected value of the constant. <code>K</code> and
<code>N</code> are the maximum number of covariates and the sample size,
respectively.</p>
</td></tr> <tr><td><code>arguments</code></td>
<td>
<p>a list of the evaluated function arguments
provided to <code>bms</code> (see above)</p>
</td></tr> <tr><td><code>topmod</code></td>
<td>
<p>a 'topmod' object
containing the best drawn models. see <code><a href="#topic+topmod">topmod</a></code> for more details</p>
</td></tr>
<tr><td><code>start.pos</code></td>
<td>
<p>the positions of the starting model. If bmao is a'bma'
object this corresponds to covariates bmao$reg.names[bmao$start.pos]. If
bmao is a chain that resulted from several starting models (cf.
<code><a href="#topic+c.bma">c.bma</a></code>, then <code>start.pos</code> is a list detailing all of them.</p>
</td></tr>
<tr><td><code>gprior.info</code></td>
<td>
<p>a list of class <code><a href="#topic+gprior-class">gprior-class</a></code>, detailing
information on the g-prior: <code>gtype</code> corresponds to argument <code>g</code>
above, <code>is.constant</code> is FALSE if <code>gtype</code> is either &quot;hyper&quot; or
&quot;EBL&quot;, <code>return.g.stats</code> corresponds to argument <code>g.stats</code> above,
<code>shrinkage.moments</code> contains the first and second moments of the
shrinkage factor (only if <code>return.g.stats==TRUE</code>), <code>g</code> details the
fixed g (if <code>is.constant==TRUE</code>), <code>hyper.parameter</code> corresponds to
the hyper-g parameter <code class="reqn">a</code> as in Liang et al. (2008) </p>
</td></tr>
<tr><td><code>mprior.info</code></td>
<td>
<p>a list of class <code><a href="#topic+mprior-class">mprior-class</a></code>, detailing
information on the model prior: <code>origargs</code> lists the original arguments
to <code>mprior</code> and <code>mprior.size</code> above; <code>mp.msize</code> denotes the
prior mode size; <code>mp.Kdist</code> is a (K+1) vector with the prior model size
distribution from 0 to K</p>
</td></tr> <tr><td><code>X.data</code></td>
<td>
<p>data.frame or matrix: corresponds to
argument <code>X.data</code> above, possibly cleaned for NAs</p>
</td></tr>
<tr><td><code>reg.names</code></td>
<td>
<p>character vector: the covariate names to be used for X.data
(corresponds to <code><a href="#topic+variable.names.bma">variable.names.bma</a></code> </p>
</td></tr> <tr><td><code>bms.call</code></td>
<td>
<p>the
original call to the <code>bms</code> function</p>
</td></tr>
</table>


<h3>Theoretical background</h3>

<p>The models analyzed are Bayesian
normal-gamma conjugate models with improper constant and variance priors
akin to Fernandez, Ley and Steel (2001): A model <code class="reqn">M</code> can be described as
follows, with <code class="reqn">\epsilon</code> ~ <code class="reqn">N(0,\sigma^2 I)</code>: </p>
<p style="text-align: center;"><code class="reqn">latex</code>
</p>
 <p style="text-align: center;"><code class="reqn">f(\beta | \sigma, M, g) ~ N(0, g \sigma^2
(X'X)^-1) </code>
</p>

<p>Moreover, the (improper) prior on the constant <code class="reqn">f(\alpha)</code> is put
proportional to 1. Similarly, the variance prior <code class="reqn">f(\sigma)</code> is
proportional to <code class="reqn">1/\sigma</code>.
</p>


<h3>Note</h3>

<p>There are several ways to speed-up sampling: <code>nmodel=10</code> saves
only the ten best models, at most a marginal improvement. <code>nmodels=0</code>
does not save the best (500) models, however then posterior convergence and
likelihood-based inference are not possible.  
the best models, but not their coefficients, which renders the use of
<code>image.bma</code> and the paramer <code>exact=TRUE</code> in functions such as
<code>coef.bma</code> infeasible.  <code>g.stats=FALSE</code> saves some time by not
retaining the shrinkage factors for the MC3 chain (and the best models).
<code>force.fullobject=TRUE</code> in contrast, slows sampling down significantly
if <code>mcmc="enumerate"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher, Paul Hofmarcher, and Stefan Zeugner
</p>


<h3>References</h3>

<p><a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a>: BMS package homepage with help and tutorials
</p>
<p>Feldkircher, M. and S. Zeugner (2015): Bayesian Model Averaging Employing 
Fixed and Flexible Priors: The BMS Package for R, Journal of Statistical Software 68(4).
</p>
<p>Feldkircher, M. and S. Zeugner (2009): Benchmark Priors
Revisited: On Adaptive Shrinkage and the Supermodel Effect in Bayesian Model
Averaging, IMF Working Paper 09/202.
</p>
<p>Fernandez, C. E. Ley and M. Steel (2001): Benchmark priors for Bayesian
model averaging. Journal of Econometrics 100(2), 381&ndash;427
</p>
<p>Ley, E. and M. Steel (2008): On the Effect of Prior Assumptions in Bayesian
Model Averaging with Applications to Growth Regressions. working paper
</p>
<p>Liang, F., Paulo, R., Molina, G., Clyde, M. A., and Berger, J. O. (2008).
Mixtures of g Priors for Bayesian Variable Selection. Journal of the
American Statistical Association 103, 410-423.
</p>
<p>Sala-i-Martin, X. and G. Doppelhofer and R.I. Miller (2004): Determinants of
long-term growth: a Bayesian averaging of classical estimates (BACE)
approach. American Economic Review 94(4), 813&ndash;835
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.bma">coef.bma</a></code>, <code><a href="#topic+plotModelsize">plotModelsize</a></code> and
<code><a href="#topic+density.bma">density.bma</a></code> for some operations on the resulting 'bma' object,
<code><a href="#topic+c.bma">c.bma</a></code> for integrating separate MC3 chains and splitting of
sampling over several runs.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(datafls)
  #estimating a standard MC3 chain with 1000 burn-ins and 2000 iterations and uniform model priors
  bma1 = bms(datafls,burn=1000, iter=2000, mprior="uniform")

  ##standard coefficients based on exact likelihoods of the 100 best models:
  coef(bma1,exact=TRUE, std.coefs=TRUE) 
  
  #suppressing user-interactive output, using a customized starting value, and not saving the best 
  #  ...models for only 19 observations (but 41 covariates)
  bma2 = bms(datafls[20:39,],burn=1000, iter=2000, nmodel=0, start.value=c(1,4,7,30),
     user.int=FALSE)
  coef(bma2)
  
  #MC3 chain with a hyper-g prior (custom coefficient a=2.1), saving only the 20 best models, 
  # ...and an alternative sampling procedure; putting a log entry to console every 1000th step
  bma3 = bms(datafls,burn=1000, iter=5000, nmodel=20, g="hyper=2.1", mcmc="rev.jump",
      logfile="",logstep=1000)
  image(bma3) #showing the coefficient signs of the 20 best models
  
  #enumerating with 10 covariates (= 1024 models), keeping the shrinkage factors 
  #  ...of the best 200 models
  bma4 = bms(datafls[,1:11],mcmc="enumerate",nmodel=200,g.stats=TRUE)

  #using an interaction sampler for two interaction terms
  dataint=datafls
  dataint=cbind(datafls,datafls$LifeExp*datafls$Abslat/1000,
        datafls$Protestants*datafls$Brit-datafls$Muslim)
  names(dataint)[ncol(dataint)-1]="LifeExp#Abslat"
  names(dataint)[ncol(dataint)]="Protestants#Brit#Muslim"
  bma5 = bms(X.data=dataint,burn=1000,iter=9000,start.value=0,mcmc="bd.int") 
  
  density(bma5,reg="English") # plot posterior density for covariate "English"
  
  # a matrix as X.data argument
  bms(matrix(rnorm(1000),100,10))
  
  # keeping a set of fixed regressors:
  bms(datafls, mprior.size=7, fixed.reg = c("PrScEnroll", "LifeExp", "GDP60"))
  # Note that mprior.size=7 means prior model size of 3 fixed to 4 'uncertain' regressors
  
</code></pre>

<hr>
<h2 id='c.bma'>Concatenate bma objects</h2><span id='topic+c.bma'></span><span id='topic+combine_chains'></span>

<h3>Description</h3>

<p>Combines bma objects (resulting from <code><a href="#topic+bms">bms</a></code>). Can be used to
split estimation over several machines, or combine the MCMC results obtained
from different starting points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.bma_+3A_...">...</code></td>
<td>
<p>At least two 'bma' objects (cf. <code><a href="#topic+bms">bms</a></code>)</p>
</td></tr>
<tr><td><code id="c.bma_+3A_recursive">recursive</code></td>
<td>
<p>retained for compatibility with <code><a href="base.html#topic+c">c</a></code> method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aggregates the information obtained from several chains. The result is a
'bma' object (cf. 'Values' in <code><a href="#topic+bms">bms</a></code>) that can be used just as a
standard 'bma' object.<br /> Note that <code>combine_chains</code> helps in
particular to paralllelize the enumeration of the total model space: A model
with <code class="reqn">K</code> regressors has <code class="reqn">2^K</code> potential covariate combinations: With
<code class="reqn">K</code> large (more than 25), this can be pretty time intensive.  With the
<code><a href="#topic+bms">bms</a></code> arguments <code>start.value</code> and <code>iter</code>, sampling can
be done in steps: cf. example 'enumeration' below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
  
 #MCMC case ############################
 model1=bms(datafls,burn=1000,iter=4000,mcmc="bd",start.value=c(20,30,35))
 model2=bms(datafls,burn=1500,iter=7000,mcmc="bd",start.value=c(1,10,15))
 
 model_all=c(model1,model2)
 coef(model_all)
 plot(model_all)
 
 
 
 #splitting enumeration ########################
 
 #standard case with 12 covariates (4096 differnt combinations):
 enum0=bms(datafls[,1:13],mcmc="enumerate")
 
 # now split the task:
 # enum1 does everything from model zero (the first model) to model 1999
 enum1=bms(datafls[,1:13],mcmc="enumerate",start.value=0,iter=1999)
 
 # enum2 does models from index 2000 to the index 3000 (in total 1001 models)
 enum2=bms(datafls[,1:13],mcmc="enumerate",start.value=2000,iter=1000)
 
 # enum3 does models from index 3001 to the end
 enum3=bms(datafls[,1:13],mcmc="enumerate",start.value=3001)
 
 enum_combi=c(enum1,enum2,enum3)
 coef(enum_combi)
 coef(enum0)
 #both enum_combi and enum0 have exactly the same results 
 #(one difference: enum_combi has more 'top models' (1500 instead of 500))

</code></pre>

<hr>
<h2 id='datafls'>FLS (2001) growth data</h2><span id='topic+datafls'></span>

<h3>Description</h3>

<p>The economic growth data set from Fernandez, Ley and Steel, Journal of Applied Econometrics 2001
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datafls
</code></pre>


<h3>Format</h3>

<p>A data frame with 53940 rows and 10 variables:
A data frame with 72 observations on the following 42 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>numeric: Economic growth 1960-1992 as from the Penn World Tables Rev 6.0</p>
</dd>
<dt><code>Abslat</code></dt><dd><p>numeric: Absolute latitude</p>
</dd>
<dt><code>Spanish</code></dt><dd><p>numeric: Spanish colony dummy</p>
</dd>
<dt><code>French</code></dt><dd><p>numeric: French colony dummy</p>
</dd>
<dt><code>Brit</code></dt><dd><p>numeric: British colony dummy</p>
</dd>
<dt><code>WarDummy</code></dt><dd><p>numeric: War dummy</p>
</dd>
<dt><code>LatAmerica</code></dt><dd><p>numeric: Latin America dummy</p>
</dd>
<dt><code>SubSahara</code></dt><dd><p>numeric; Sub-Sahara dummy</p>
</dd>
<dt><code>OutwarOr</code></dt><dd><p>numeric: Outward Orientation</p>
</dd>
<dt><code>Area</code></dt><dd><p>numeric: Area surface</p>
</dd>
<dt><code>PrScEnroll</code></dt><dd><p>numeric: Primary school enrolment</p>
</dd>
<dt><code>LifeExp</code></dt><dd><p>numeric: Life expectancy</p>
</dd>
<dt><code>GDP60</code></dt><dd><p>numeric: Initial GDP in 1960</p>
</dd>
<dt><code>Mining</code></dt><dd><p>numeric: Fraction of GDP in mining</p>
</dd>
<dt><code>EcoOrg</code></dt><dd><p>numeric: Degree of capitalism</p>
</dd>
<dt><code>YrsOpen</code></dt><dd><p>numeric: Number of years having an open economy</p>
</dd>
<dt><code>Age</code></dt><dd><p>numeric: Age</p>
</dd>
<dt><code>Buddha</code></dt><dd><p>numeric: Fraction Buddhist</p>
</dd>
<dt><code>Catholic</code></dt><dd><p>numeric: Fraction Catholic</p>
</dd>
<dt><code>Confucian</code></dt><dd><p>numeric: Fraction Confucian</p>
</dd>
<dt><code>EthnoL</code></dt><dd><p>numeric: Ethnolinguistic fractionalization</p>
</dd>
<dt><code>Hindu</code></dt><dd><p>numeric: Fraction Hindu</p>
</dd>
<dt><code>Jewish</code></dt><dd><p>numeric: Fraction Jewish</p>
</dd>
<dt><code>Muslim</code></dt><dd><p>numeric: Fraction Muslim</p>
</dd>
<dt><code>PrExports</code></dt><dd><p>numeric: Primary exports 1970</p>
</dd>
<dt><code>Protestants</code></dt><dd><p>numeric: Fraction Protestants</p>
</dd>
<dt><code>RuleofLaw</code></dt><dd><p>numeric: Rule of law</p>
</dd>
<dt><code>Popg</code></dt><dd><p>numeric: Population growth</p>
</dd>
<dt><code>WorkPop</code></dt><dd><p>numeric: workers per inhabitant</p>
</dd>
<dt><code>LabForce</code></dt><dd><p>numeric: Size of labor force</p>
</dd>
<dt><code>HighEnroll</code></dt><dd><p>numeric: Higher education enrolment</p>
</dd>
<dt><code>PublEdupct</code></dt><dd><p>numeric: Public education share</p>
</dd>
<dt><code>RevnCoup</code></dt><dd><p>numeric: Revolutions and coups</p>
</dd>
<dt><code>PolRights</code></dt><dd><p>numeric: Political rights</p>
</dd>
<dt><code>CivlLib</code></dt><dd><p>numeric: Civil liberties</p>
</dd>
<dt><code>English</code></dt><dd><p>numeric: Fraction speaking English</p>
</dd>
<dt><code>Foreign</code></dt><dd><p>numeric: Fraction speaking foreign language</p>
</dd>
<dt><code>RFEXDist</code></dt><dd><p>numeric: Exchange rate distortions</p>
</dd>
<dt><code>EquipInv</code></dt><dd><p>numeric: Equipment investment</p>
</dd>
<dt><code>NequipInv</code></dt><dd><p>numeric: Non-equipment investment</p>
</dd>
<dt><code>stdBMP</code></dt><dd><p>numeric: stand. dev. of black market premium</p>
</dd>
<dt><code>BlMktPm</code></dt><dd><p>numeric: black market premium</p>
</dd>
</dl>



<h3>Source</h3>

<p>Fernandez, C., Ley, E., and Steel, M. F. (2001b). Model Uncertainty in Cross-Country Growth Regressions. Journal of Applied Econometrics, 16:563-576.
Data set from <a href="https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/steel/steel_homepage/software">https://warwick.ac.uk/fac/sci/statistics/staff/academic-research/steel/steel_homepage/software</a>.
</p>
<p>A working paper version of Fernandez, Ley and Steel (2001) is available via <a href="https://econpapers.repec.org/article/jaejapmet/v_3a16_3ay_3a2001_3ai_3a5_3ap_3a563-576.htm">https://econpapers.repec.org/article/jaejapmet/v_3a16_3ay_3a2001_3ai_3a5_3ap_3a563-576.htm</a>.
</p>

<hr>
<h2 id='density.bma'>Coefficient Marginal Posterior Densities</h2><span id='topic+density.bma'></span><span id='topic+density.zlm'></span>

<h3>Description</h3>

<p>Calculates the mixture marginal posterior densities for the coefficients
from a BMA object and plots them
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
density(
  x,
  reg = NULL,
  addons = "lemsz",
  std.coefs = FALSE,
  n = 300,
  plot = TRUE,
  hnbsteps = 30,
  addons.lwd = 1.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="density.bma_+3A_x">x</code></td>
<td>
<p>A bma object (see <code><a href="#topic+bms">bms</a></code>) or a <code><a href="#topic+zlm">zlm</a></code> object.</p>
</td></tr>
<tr><td><code id="density.bma_+3A_reg">reg</code></td>
<td>
<p>A scalar integer or character detailing which covariate's
coefficient should be plotted. If <code>reg=NULL</code> (default), then all
regressors are plotted one after the other, waiting for user interaction.</p>
</td></tr>
<tr><td><code id="density.bma_+3A_addons">addons</code></td>
<td>
<p>character. Specifies which additional information should be
added to the plot via low-level commands (see 'Details' below).</p>
</td></tr>
<tr><td><code id="density.bma_+3A_std.coefs">std.coefs</code></td>
<td>
<p>logical. If <code>TRUE</code> then the posterior density is
estimated for standardized coefficients (representing the case where all
variables have mean zero and standard deviation 1) - default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="density.bma_+3A_n">n</code></td>
<td>
<p>numeric. the number of equally spaced points at which the density
is to be estimated.</p>
</td></tr>
<tr><td><code id="density.bma_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>TRUE</code> (default), the density is plotted; if
<code>FALSE</code> then <code>density.bma</code> only returns the estimated posterior
densities without plotting.</p>
</td></tr>
<tr><td><code id="density.bma_+3A_hnbsteps">hnbsteps</code></td>
<td>
<p>even integer, default 30. The number of numerical
integration steps to be used in case of a hyper-g prior (cf. argument
<code>g</code> in <code><a href="#topic+bms">bms</a></code>). Increase this number to increase accuracy.</p>
</td></tr>
<tr><td><code id="density.bma_+3A_addons.lwd">addons.lwd</code></td>
<td>
<p>scalar, default 1.5. Line width to be used for the
low-level plotting commands specified by <code>addons</code>. Cf. argument
<code>lwd</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="density.bma_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="graphics.html#topic+plot.default">plot.default</a></code> with
sensible defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>addons</code> specifies what additional information should be
added to the plot(s) via the low-level commands <code><a href="graphics.html#topic+lines">lines</a></code> and
<code><a href="graphics.html#topic+legend">legend</a></code>:<br /> <code>"e"</code> for the posterior expected value (EV) of
coefficients conditional on inclusion (see argument <code>exact=TRUE</code> in
<code><a href="#topic+coef.bma">coef.bma</a></code>),<br /> <code>"s"</code> for 2 times posterior standard
deviation (SD) bounds,<br /> <code>"m"</code> for the posterior median,<br /> <code>"b"</code>
for posterior expected values of the individual models whom the density is
averaged over,<br /> <code>"E"</code> for posterior EV under MCMC frequencies (see
argument <code>exact=FALSE</code> in <code><a href="#topic+coef.bma">coef.bma</a></code>),<br /> <code>"S"</code> for
the corresponding SD bounds (MCMC),<br /> <code>"p"</code> for plotting the Posterior
Inclusion Probability above the density plot,<br /> <code>"l"</code> for including a
<code><a href="graphics.html#topic+legend">legend</a></code>, <code>"z"</code> for a zero line, <code>"g"</code> for adding a
<code><a href="graphics.html#topic+grid">grid</a></code>
</p>
<p>Any combination of these letters will give the desired result. Use
<code>addons=""</code> for not using any of these.<br /> In case of
<code>density.zlm</code>, only the letters <code>e</code>, <code>s</code>, <code>l</code>, <code>z</code>,
and <code>g</code> will have an effect.
</p>


<h3>Value</h3>

<p>The function returns a list containing objects of the class
<code><a href="stats.html#topic+density">density</a></code> detailing the marginal posterior densities for each
coefficient provided in <code>reg</code>.<br /> In case of <code>density.zlm</code>, simple
marginal posterior coefficient densities are computed, while
<code>density.bma</code> calculates there mixtures over models according to
posterior model probabilities.<br /> These densities contain only the density
points apart from the origin. (see 'Note' below)
</p>
<p>As long as <code>plot=TRUE</code>, the densities are plotted too.  Note that (for
<code>density.bma</code>) if the posterior inclusion probability of a covariate is
zero, then it will not be plotted, and the returned density will be
<code>list(x=numeric(n),y=numeric(n))</code>.
</p>


<h3>Note</h3>

<p>The computed marginal posterior densities from <code>density.bma</code> are
a Bayesian Model Averaging mixture of the marginal posterior densities of
the individual models.  The accuracy of the result therefore depends on the
number of 'best' models contained in <code>x</code> (cf. argument <code>nmodel</code> in
<code><a href="#topic+bms">bms</a></code>).
</p>
<p>The marginal posterior density can be interpreted as 'conditional on
inclusion': If the posterior inclusion probability of a variable is smaller
than one, then some of its posterior density is Dirac at zero.  Therefore
the integral of the returned density vector adds up to the posterior
inclusion probability, i.e. the probability that the coefficient is not
zero.
</p>
<p>Correspondingly, the posterior EV and SD specified by <code>addons="es"</code> are
based on 'best' model likelihoods ('exact') and are conditional on
inclusion.  They correspond to the results from command
<code>coef.bma(x,exact=TRUE,condi.coef=TRUE,order.by.pip=FALSE)</code> (cf. the
example below).
</p>
<p>The low-level commands enacted by the argument <code>addons</code> rely on colors
of the <code><a href="grDevices.html#topic+palette">palette</a></code>: color 2 for <code>"e"</code> and <code>"s"</code>, color 3
for <code>"m"</code>, color 8 for <code>"b"</code>, color 4 for <code>"E"</code> and
<code>"S"</code>. The default colors may be changed by a call to
<code><a href="grDevices.html#topic+palette">palette</a></code>.
</p>
<p>Up to BMS version 0.3.0, <code>density.bma</code> may only cope with built-in
<code>gprior</code>s, not with any user-defined priors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantile.coef.density">quantile.coef.density</a></code> for extracting quantiles,
<code><a href="#topic+coef.bma">coef.bma</a></code> for similar concepts, <code><a href="#topic+bms">bms</a></code> for creating
bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 data(datafls)
 mm=bms(datafls)

 density(mm,reg="SubSahara")
 density(mm,reg=7,addons="lbz") 
 density(mm,1:9)
 density(mm,reg=2,addons="zgSE",addons.lwd=2,std.coefs=TRUE)

# plot the posterior density only for the very best model
 density(mm[1],reg=1,addons="esz")


#using the calculated density for other purposes...
 dd=density(mm,reg="SubSahara")
 plot(dd) 

 dd_list=density(mm,reg=1:3,plot=FALSE,n=400)
 plot(dd_list[[1]])


#Note that the shown density is only the part that is not zero
 dd=density(mm,reg="Abslat",addons="esl")
 pip_Abslat=sum(dd$y)*diff(dd$x)[1]

 #this pip and the EV conform to what is done by the follwing command
 coef(mm,exact=TRUE,condi.coef=TRUE)["Abslat",]

</code></pre>

<hr>
<h2 id='estimates.bma'>Posterior Inclusion Probabilities and Coefficients from a 'bma' Object</h2><span id='topic+estimates.bma'></span><span id='topic+coef.bma'></span>

<h3>Description</h3>

<p>Returns a matrix with aggregate covariate-specific Bayesian model Averaging:
posterior inclusion probabilites (PIP), post. expected values and standard
deviations of coefficients, as well as sign probabilites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimates.bma(
  bmao,
  exact = FALSE,
  order.by.pip = TRUE,
  include.constant = FALSE,
  incl.possign = TRUE,
  std.coefs = FALSE,
  condi.coef = FALSE
)

## S3 method for class 'bma'
coef(
  object,
  exact = FALSE,
  order.by.pip = TRUE,
  include.constant = FALSE,
  incl.possign = TRUE,
  std.coefs = FALSE,
  condi.coef = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimates.bma_+3A_exact">exact</code></td>
<td>
<p>if <code>exact=FALSE</code>, then PIPs, coefficients, etc. will be
based on aggregate information from the sampling chain with posterior model
distributions based on MCMC frequencies (except in case of enumeration - cf.
'Details');<br /> if <code>exact=TRUE</code>, estimates will be based on the
<code><a href="#topic+bms">nmodel</a></code> best models encountered by the sampling chain,
with the posterior model distribution based on their <em>exact</em> marginal
likelihoods - cf. 'Details' below.</p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_order.by.pip">order.by.pip</code></td>
<td>
<p><code>order.by.pip=TRUE</code> orders the resulting matrix
according to posterior inclusion probabilites, <code>order.by.pip=FALSE</code>
ranks them according to the original data (order of the covariates as in
provided in <code>X.data</code> to <code><a href="#topic+bms">bms</a></code>), default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_include.constant">include.constant</code></td>
<td>
<p>If <code>include.constant=TRUE</code> then the resulting
matrix includes the expected value of the constant in its last row. Default
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_incl.possign">incl.possign</code></td>
<td>
<p>If <code>incl.possign=FALSE</code>, then the sign probabilites
column (cf. 'Values' below) is omitted from the result. Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_std.coefs">std.coefs</code></td>
<td>
<p>If <code>std.coefs=TRUE</code> then the expected values and
standard deviations are returned in standardized form, i.e. as if the
original data all had mean zero and variance 1. If <code>std.coefs=FALSE</code>
(default) then both expected values and standard deviations are returned 'as
is'.</p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_condi.coef">condi.coef</code></td>
<td>
<p>If <code>condi.coef=FALSE</code> (default) then coefficients
<code class="reqn">\beta_i</code> and standard deviations are unconditional posterior expected
values, as in standard model averaging; if <code>condi.coef=FALSE</code> then they
are given as conditional on inclusion (equivalent to <code class="reqn">\beta_i / PIP_i</code>).</p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_object">object</code>, <code id="estimates.bma_+3A_bmao">bmao</code></td>
<td>
<p>a 'bma' object (cf. <code><a href="#topic+bms">bms</a></code>)</p>
</td></tr>
<tr><td><code id="estimates.bma_+3A_...">...</code></td>
<td>
<p>further arguments for other <code><a href="stats.html#topic+coef">coef</a></code> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More on the argument <code>exact</code>: <br /> In case the argument
<code>exact=TRUE</code>, the PIPs, coefficient statistics and conditional sign
probabilities are computed on the basis of the (500) best models the
sampling chain encountered (cf. argument <code>nmodel</code> in
<code><a href="#topic+bms">bms</a></code>). Here, the weights for Bayesian model averaging (BMA) are
the posterior marginal likelihoods of these best models. <br /> In case
<code>exact=FALSE</code>, then these statistics are based on all accepted models
(except burn-ins): If <code>mcmc="enumerate"</code> then this are simply all
models of the traversed model space, with their marginal likelihoods
providing the weights for BMA.<br /> If, however, the bma object <code>bmao</code>
was based on an MCMC sampler (e.g. when <code><a href="#topic+bms">bms</a></code> argument
<code>mcmc="bd"</code>), then BMA statistics are computed differently: In contrast
to above, the weights for BMA are MCMC frequencies, i.e. how often the
respective models were encountered by the MCMC sampler. (cf. a comparison of
MCMC frequencies and marginal likelihoods for the best models via the
function <code><a href="#topic+pmp.bma">pmp.bma</a></code>).
</p>


<h3>Value</h3>

<p>A matrix with five columns (or four if <code>incl.possign=FALSE</code>)
</p>
<table role = "presentation">
<tr><td><code>Column 'PIP'</code></td>
<td>
<p>Posterior inclusion probabilities <code class="reqn">\sum p(\gamma|i
\in \gamma, Y) / sum p(\gamma|Y) </code></p>
</td></tr> <tr><td><code>Column 'Post Mean'</code></td>
<td>
<p>posterior
expected value of coefficients, unconditional <code class="reqn">E(\beta|Y)=\sum
p(\gamma|Y) E(\beta|\gamma,Y)</code>, where <code class="reqn">E(\beta_i|\gamma,i \notin \gamma,
Y)=0</code> if <code>condi.coef=FALSE</code>, or conditional on inclusion
(<code class="reqn">E(\beta|Y) / \sum p(\gamma|Y, i \in \gamma) </code> ) if
<code>condi.coef=TRUE</code></p>
</td></tr> <tr><td><code>Column 'Post SD'</code></td>
<td>
<p>posterior standard deviation
of coefficients, unconditional or conditional on inclusion, depending on
<code>condi.coef</code></p>
</td></tr> <tr><td><code>Column 'Cond.Pos.Sign'</code></td>
<td>
<p>The ratio of how often the
coefficients' expected values were positive conditional on inclusion. (over
all visited models in case <code>exact=FALSE</code>, over the best models in case
<code>exact=TRUE</code>)</p>
</td></tr> <tr><td><code>Column 'Idx'</code></td>
<td>
<p>the original order of covariates as
the were used for sampling. (if included, the constant has index 0)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating bma objects, <code><a href="#topic+pmp.bma">pmp.bma</a></code>
for comparing MCMC frequencies and marginal likelihoods.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#sample, with keeping the best 200 models:
data(datafls)
mm=bms(datafls,burn=1000,iter=5000,nmodel=200)

#standard BMA PIPs and coefficients from the MCMC sampling chain, based on 
#  ...how frequently the models were drawn
coef(mm)

#standardized coefficients, ordered by index
coef(mm,std.coefs=TRUE,order.by.pip=FALSE)

#coefficients conditional on inclusion:
coef(mm,condi.coef=TRUE)

#same as
ests=coef(mm,condi.coef=FALSE)
ests[,2]/ests[,1]

#PIPs, coefficients, and signs based on the best 200 models
estimates.bma(mm,exact=TRUE)

#... and based on the 50 best models
coef(mm[1:50],exact=TRUE)


</code></pre>

<hr>
<h2 id='f21hyper'>Gaussian Hypergeometric Function F(a,b,c,z)</h2><span id='topic+f21hyper'></span>

<h3>Description</h3>

<p>Computes the value of a Gaussian hypergeometric function <code class="reqn"> F(a,b,c,z) </code>
for <code class="reqn">-1 \leq z \leq 1</code> and <code class="reqn">a,b,c \geq 0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f21hyper(a, b, c, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f21hyper_+3A_a">a</code></td>
<td>
<p>The parameter <code>a</code> of the Gaussian hypergeometric function,
must be a positive scalar here</p>
</td></tr>
<tr><td><code id="f21hyper_+3A_b">b</code></td>
<td>
<p>The parameter <code>b</code> of the Gaussian hypergeometric function,
must be a positive scalar here</p>
</td></tr>
<tr><td><code id="f21hyper_+3A_c">c</code></td>
<td>
<p>The parameter <code>c</code> of the Gaussian hypergeometric function,
must be a positive scalar here</p>
</td></tr>
<tr><td><code id="f21hyper_+3A_z">z</code></td>
<td>
<p>The parameter <code>z</code> of the Gaussian hypergeometric function,
must be between -1 and 1 here</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>f21hyper</code> complements the analysis of the 'hyper-g prior'
introduced by Liang et al. (2008).<br /> For parameter values, compare cf.
<a href="https://en.wikipedia.org/wiki/Hypergeometric_function">https://en.wikipedia.org/wiki/Hypergeometric_function</a>.
</p>


<h3>Value</h3>

<p>The value of the Gaussian hypergeometric function <code class="reqn"> F(a,b,c,z) </code>
</p>


<h3>Note</h3>

<p>This function is a simple wrapper function of sped-up code that is
intended for sporadic application by the user; it is neither efficient nor
general; for a more general version cf. the package '<code>hypergeo</code>'
</p>


<h3>References</h3>

<p>Liang F., Paulo R., Molina G., Clyde M., Berger J.(2008):
Mixtures of g-priors for Bayesian variable selection. J. Am. Statist. Assoc.
103, p. 410-423
</p>
<p><a href="https://en.wikipedia.org/wiki/Hypergeometric_function">https://en.wikipedia.org/wiki/Hypergeometric_function</a>
</p>


<h3>See Also</h3>

<p>package <code>hypergeo</code> for a more proficient implementation.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
  f21hyper(30,1,20,.8) #returns about 165.8197
  
  f21hyper(30,10,20,0) #returns one
  
  f21hyper(10,15,20,-0.1) # returns about 0.4872972
</code></pre>

<hr>
<h2 id='fullmodel.ssq'>OLS Statistics for the Full Model Including All Potential Covariates</h2><span id='topic+fullmodel.ssq'></span>

<h3>Description</h3>

<p>A utility function for reference: Returns a list with R2 and sum of squares
for the OLS model encompassing all potential covariates that are included in
a bma object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullmodel.ssq(yX.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fullmodel.ssq_+3A_yx.data">yX.data</code></td>
<td>
<p>a bma object (cf. <code><a href="#topic+bms">bms</a></code>) - alternatively a
<a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+matrix">matrix</a> whose first column is the dependent
variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with some basic OLS statistics </p>
<table role = "presentation">
<tr><td><code>R2</code></td>
<td>
<p>The
R-squared of the full model</p>
</td></tr> <tr><td><code>ymy</code></td>
<td>
<p>The sum of squares of residuals of
the full model</p>
</td></tr> <tr><td><code>ypy</code></td>
<td>
<p>The explained sum of squares of the full model</p>
</td></tr>
<tr><td><code>yty</code></td>
<td>
<p>The sum of squares of the (demeaned) dependent variable</p>
</td></tr>
<tr><td><code>Fstat</code></td>
<td>
<p>The F-statistic of the full model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is just for quick comparison; for proper OLS estimation
consider <code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating bma objects, <code><a href="stats.html#topic+lm">lm</a></code> for
OLS estimation
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datafls)
mm=bms(datafls)

fullmodel.ssq(mm)

#equivalent:
fullmodel.ssq(datafls)


</code></pre>

<hr>
<h2 id='gdensity'>Posterior Density of the Shrinkage Factor</h2><span id='topic+gdensity'></span>

<h3>Description</h3>

<p>Calculates the mixture marginal posterior density for the shrinkage factor
(g/(1+g)) from a BMA object under the hyper-g prior and plots it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdensity(x, n = 512, plot = TRUE, addons = "zles", addons.lwd = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdensity_+3A_x">x</code></td>
<td>
<p>A bma object (see <code><a href="#topic+bms">bms</a></code>).</p>
</td></tr>
<tr><td><code id="gdensity_+3A_n">n</code></td>
<td>
<p>The integer number of equally spaced points at which the density is
to be estimated. see 'Details' below</p>
</td></tr>
<tr><td><code id="gdensity_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>TRUE</code> (default), the density is plotted; if
<code>FALSE</code> then <code>gdensity</code> only returns the estimated posterior
density without plotting.</p>
</td></tr>
<tr><td><code id="gdensity_+3A_addons">addons</code></td>
<td>
<p>character, defaulting to <code>"zles"</code>. Specifies which
additional information should be added to the plot via low-level commands
(see 'Details' below).</p>
</td></tr>
<tr><td><code id="gdensity_+3A_addons.lwd">addons.lwd</code></td>
<td>
<p>scalar, default 1.5. Line width to be used for the
low-level plotting commands specified by <code>addons</code>. Cf. argument
<code>lwd</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="gdensity_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="graphics.html#topic+plot.default">plot.default</a></code> with
sensible defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>gdensity</code> estimates and plots the posterior density for
the shrinkage factor <code class="reqn">g/(1+g)</code><br /> This is evidently only possible if the
shrinkage factor if not fixed, i.e. if the bma object <code>x</code> was estimated
with a hyper-g prior - cf. argument <code>g</code> in <code><a href="#topic+bms">bms</a></code><br /> The
density is based only on the best models retained in the bma object
<code>x</code>, cf. argument <code>nmodel</code> in <code><a href="#topic+bms">bms</a></code><br /> A note on
argument <code>n</code>: The points at which the density is estimated start at
<code class="reqn">max(0,E-5*SD)</code>, where <code class="reqn">E</code> and <code class="reqn">SD</code> are the expected value and
standard deviation of the shrinkage factor, respectively. For plotting the
entire domain <code class="reqn">(0,1)</code> use <code>xlim=c(0,1)</code> as an argument for
<code>gdensity</code>.
</p>
<p>The argument <code>addons</code> specifies what additional information should be
added to the plot(s) via the low-level commands <code><a href="graphics.html#topic+lines">lines</a></code> and
<code><a href="graphics.html#topic+legend">legend</a></code>:<br /> <code>"e"</code> for the posterior expected value (EV) of
the shrinkage factor,<br /> <code>"s"</code> for 2 times posterior standard deviation
(SD) bounds,<br /> <code>"m"</code> for the posterior median,<br /> <code>"f"</code> for
posterior expected values of the individual models whom the density is
averaged over,<br /> <code>"z"</code> for a zero line, <code>"l"</code> for including a
<code><a href="graphics.html#topic+legend">legend</a></code><br /> The following two are only possible if the bma
object collected statistics on shrinkage, cf. argument <code>g.stats</code> in
<code><a href="#topic+bms">bms</a></code> <code>"E"</code> for posterior expected value under MCMC
frequencies (see argument <code>exact</code> in <code><a href="#topic+coef.bma">coef.bma</a></code>),<br />
<code>"S"</code> for the corresponding 2 times standard deviation bounds
(MCMC),<br />
</p>
<p>Any combination of these letters will give the desired result. Use
<code>addons=""</code> for not using any of these.
</p>


<h3>Value</h3>

<p><code>gdensity</code> returns an object of the class <code><a href="stats.html#topic+density">density</a></code>
detailing the posterior mixture density of the shrinkage factor.
</p>


<h3>Note</h3>

<p>The computed marginal posterior density is a Bayesian Model Averaging
mixture of the marginal posterior densities of the shrinkage factor under
individual models.  The accuracy of the result therefore depends on the
number of 'best' models contained in <code>x</code> (cf. argument <code>nmodel</code> in
<code><a href="#topic+bms">bms</a></code>).
</p>
<p>Correspondingly, the posterior EV and SD specified by <code>addons="es"</code> are
based on 'best' model likelihoods ('exact') and are conditional on
inclusion.
</p>
<p>The low-level commands enacted by the argument <code>addons</code> rely on colors
of the <code><a href="grDevices.html#topic+palette">palette</a></code>: color 2 for <code>"e"</code> and <code>"s"</code>, color 3
for <code>"m"</code>, color 8 for <code>"f"</code>, color 4 for <code>"E"</code> and
<code>"S"</code>. The default colors may be changed by a call to
<code><a href="grDevices.html#topic+palette">palette</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.bma">density.bma</a></code> for computing coefficient densities,
<code><a href="#topic+bms">bms</a></code> for creating bma objects, <code><a href="stats.html#topic+density">density</a></code> for the
general method
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 data(datafls)
 mm=bms(datafls,g="hyper=UIP")

 gdensity(mm) # default plotting
 
 # the grey bars represent expected shrinkage factors of the individual models
 gdensity(mm,addons="lzfes") 
 
 # #plotting the median 'm' and the posterior mean and bounds based on MCMC results:
 gdensity(mm,addons="zSEm",addons.lwd=2)

# plot the posterior shrinkage density only for the very best model
 gdensity(mm[1],addons="esz")


#using the calculated density for other purposes...
 dd=gdensity(mm,plot=FALSE)
 plot(dd) 

</code></pre>

<hr>
<h2 id='gprior-class'>Class &quot;gprior&quot;</h2><span id='topic+gprior-class'></span>

<h3>Description</h3>

<p>An object pertaining to a coefficient prior
</p>


<h3>Objects from the Class</h3>

<p>A <code>gprior</code> object holds descriptions
and subfunctions pertaining to coefficient priors. Functions such as
<code><a href="#topic+bms">bms</a></code> or <code><a href="#topic+zlm">zlm</a></code> rely on this class to 'convert' the
output of OLS results into posterior expressions for a Bayesian Linear
Model. Post-processing functions such as <code><a href="#topic+density.bma">density.bma</a></code> also
resort to gprior objects.<br /> There are currently three coefficient prior
structures built into the BMS package, generated by the following functions
(cf. Feldkircher and Zeugner, 2009) : <br /> <code>gprior.constg.init</code>: creates
a Zellner's g-prior object with constant <code>g</code>.<br />
<code>gprior.eblocal.init</code>: creates an Empricial Bayes Zellner's g-prior.<br />
<code>gprior.hyperg.init</code>: creates a hyper g-prior with a Beta-prior on the
shrinkage parameter.<br /> The following describes the necessary slots
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher and Stefan Zeugner
</p>


<h3>References</h3>

<p>Feldkircher, M. and S. Zeugner (2009): Benchmark Priors
Revisited: On Adaptive Shrinkage and the Supermodel Effect in Bayesian Model
Averaging, IMF Working Paper 09/202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> and <code><a href="#topic+zlm">zlm</a></code> for creating <code>bma</code> or
<code>zlm</code> objects. <br /> Check the appendix of <code>vignette(BMS)</code> for a
more detailed description of built-in priors.<br /> Check
<a href="http://bms.zeugner.eu/custompriors.php">http://bms.zeugner.eu/custompriors.php</a> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(datafls)
mm1=bms(datafls[,1:10], g="EBL")
gg=mm1$gprior.info # is the g-prior object, augmented with some posterior statistics

mm2=bms(datafls[,1:10], g=gg) #produces the same result

mm3=bms(datafls[,1:10], g=BMS:::.gprior.eblocal.init) 
#this passes BMS's internal Empirical Bayes g-prior object as the coefficient prior 
# - any other obejct might be used as well



</code></pre>

<hr>
<h2 id='hex2bin'>Converting Binary Code to and from Hexadecimal Code</h2><span id='topic+hex2bin'></span><span id='topic+bin2hex'></span>

<h3>Description</h3>

<p>A simple-to-use function for converting a logical ('binary') vector into hex
code and reverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hex2bin(hexcode)

bin2hex(binvec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hex2bin_+3A_hexcode">hexcode</code></td>
<td>
<p>a single-element character denoting an integer in hexcode
(admissible character: 0 to 9, ato f)</p>
</td></tr>
<tr><td><code id="hex2bin_+3A_binvec">binvec</code></td>
<td>
<p>a logical vector (alternatively a vector coercible into
logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument is an integer in binary form (such as &quot;101&quot;), provided as a
logical (<code>c(T,F,T)</code>) or numeric vector (<code>c(1,0,1)</code>).<br />
<code>bin2hex</code> then returns a character denoting this number in hexcode (in
this case &quot;5&quot;).
</p>
<p>The function <code>hex2bin</code> does the reverse operation, e.g.
<code>hex2bin("5")</code> gives (<code>c(1,0,1)</code>).
</p>


<h3>Value</h3>

<p><code>bin2hex</code> returns a single element character; <code>hex2bin</code>
returns a numeric vector equivalent to a logical vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hex2bin">hex2bin</a></code> for converting hexcode into binary vectors,
<code><a href="base.html#topic+format.hexmode">format.hexmode</a></code> for a related R function.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  bin2hex(c(TRUE,FALSE,TRUE,FALSE,TRUE,TRUE))
  bin2hex(c(1,0,1,0,1,1))
  hex2bin("b8a")
  bin2hex(hex2bin("b8a"))

</code></pre>

<hr>
<h2 id='image.bma'>Plot Signs of Best Models</h2><span id='topic+image.bma'></span>

<h3>Description</h3>

<p>Plots a grid with signs and inclusion of coefficients vs. posterior model
probabilities for the best models in a 'bma' object:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
image(
  x,
  yprop2pip = FALSE,
  order.by.pip = TRUE,
  do.par = TRUE,
  do.grid = TRUE,
  do.axis = TRUE,
  cex.axis = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.bma_+3A_x">x</code></td>
<td>
<p>a list of class bma (cf. <code><a href="#topic+bms">bms</a></code> for further details)</p>
</td></tr>
<tr><td><code id="image.bma_+3A_yprop2pip">yprop2pip</code></td>
<td>
<p>if <code>yprop2pip=TRUE</code> then the grid lines on the
vertical axis are scaled according to the coefficients' inclusion
probabilites.<br /> If <code>yprop2pip=FALSE</code> (default) then the grid lines on
the vertical axis are equidistant.</p>
</td></tr>
<tr><td><code id="image.bma_+3A_order.by.pip">order.by.pip</code></td>
<td>
<p>with <code>order.by.pip=TRUE</code> (default), coefficients
are sorted according to their posterior inclusion probabilites along the
vertical axis. If <code>order.by.pip=FALSE</code> they are ordered as they were
provided to <code><a href="#topic+bms">bms</a></code>.</p>
</td></tr>
<tr><td><code id="image.bma_+3A_do.par">do.par</code></td>
<td>
<p>Defaults to <code>do.par=TRUE</code>, which adjusts
<code><a href="graphics.html#topic+par">par</a>()$mar</code> for optimal positioning. Set <code>do.par=FALSE</code> for
customizing <code>par</code> yourself.</p>
</td></tr>
<tr><td><code id="image.bma_+3A_do.grid">do.grid</code></td>
<td>
<p><code>do.grid=TRUE</code> (default) plots grid lines among the
chart's boxes, akin to the low level command <code><a href="graphics.html#topic+grid">grid</a></code>.
<code>do.grid=FALSE</code> omits the grid lines.</p>
</td></tr>
<tr><td><code id="image.bma_+3A_do.axis">do.axis</code></td>
<td>
<p><code>do.axis=TRUE</code> (default) plots axis tick marks and
labels (cf. <code><a href="graphics.html#topic+axis">axis</a></code>). <code>do.axis=FALSE</code> omits them.</p>
</td></tr>
<tr><td><code id="image.bma_+3A_cex.axis">cex.axis</code></td>
<td>
<p>font size for the axes (cf. <code><a href="graphics.html#topic+axis">axis</a></code>), defaults to
1</p>
</td></tr>
<tr><td><code id="image.bma_+3A_...">...</code></td>
<td>
<p>Parameters to be passed on to <code><a href="graphics.html#topic+image.default">image.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under default settings, blue corresponds to positive sign, red to a negative
sign, white to non-inclusion.
</p>


<h3>See Also</h3>

<p><a href="#topic+coef.bma">coef.bma</a> for the coefficients in matrix form, <a href="#topic+bms">bms</a> for
creating 'bma' objects.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 
 model=bms(datafls,nmodel=200)
 
 #plot all models
 image(model,order.by.pip=FALSE)
 image(model,order.by.pip=TRUE,cex.axis=.8)
 
 #plot best 7 models, with other colors
 image(model[1:7],yprop2pip=TRUE,col=c("black","lightgrey"))
 
</code></pre>

<hr>
<h2 id='info.bma'>Summary Statistics for a 'bma' Object</h2><span id='topic+info.bma'></span><span id='topic+summary.bma'></span>

<h3>Description</h3>

<p>Returns a vector with summary statistics for a 'bma' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.bma(bmao)

## S3 method for class 'bma'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info.bma_+3A_bmao">bmao</code></td>
<td>
<p>same as <code>object</code></p>
</td></tr>
<tr><td><code id="info.bma_+3A_object">object</code></td>
<td>
<p>a list/object of class 'bma' that typically results from the
function <code>bms</code> (see <code><a href="#topic+bms">bms</a></code> for details)</p>
</td></tr>
<tr><td><code id="info.bma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>info.bma</code> is equivalent to <code>summary.bma</code>, its argument
<code>bmao</code> conforms to the argument <code>object</code>
</p>


<h3>Value</h3>

<p>A character vector summarizing the results of a call to <code>bms</code>
</p>
<table role = "presentation">
<tr><td><code>Mean no. of Regressors</code></td>
<td>
<p> the posterior mean of model size</p>
</td></tr>
<tr><td><code>Draws</code></td>
<td>
<p>the number of iterations (ex burn-ins)</p>
</td></tr> <tr><td><code>Burnins</code></td>
<td>
<p>the
number of burn-in iterations</p>
</td></tr> <tr><td><code>Time</code></td>
<td>
<p>the time spent on iterating
through the model space</p>
</td></tr> <tr><td><code>No. of models visited</code></td>
<td>
<p>the number of times a
model was accepted (including burn-ins)</p>
</td></tr> <tr><td><code>Modelspace</code></td>
<td>
<p>the total model
space <code class="reqn">2^K</code></p>
</td></tr><tr><td><code>list(list("2^K"))</code></td>
<td>
<p>the total model space <code class="reqn">2^K</code></p>
</td></tr>
<tr><td><code>Percentage visited</code></td>
<td>
<p><code>No. of models visited/Modelspace*100</code></p>
</td></tr>
<tr><td><code>Percentage Topmodels</code></td>
<td>
<p>number of times the best models were drawn in
percent of <code>Draws</code></p>
</td></tr> <tr><td><code>Corr. PMP</code></td>
<td>
<p>the correlation between the MCMC
frequencies of the best models (the number of times they were drawn) and
their marginal likelihoods.</p>
</td></tr> <tr><td><code>No. Obs.</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>Model Prior</code></td>
<td>
<p>a character conforming to the argument <code>mprior</code> of
<code>bms</code>, and the expected prior model size</p>
</td></tr> <tr><td><code>g-prior</code></td>
<td>
<p>a character
corresponding to argument <code>g</code> of function <code>bms</code></p>
</td></tr>
<tr><td><code>Shrinkage-Stats</code></td>
<td>
<p>Posterior expected value und standard deviation (if
applicable) of the shrinkage factor. Only included if argument
<code>g.stats</code> of function <code>bms</code> was set to TRUE</p>
</td></tr>
</table>


<h3>Note</h3>

<p>All of the above statistics can also be directly extracted from the
bma object (<code>bmao</code>). Therefore <code>summary.bma</code> only returns a
character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> and <code><a href="#topic+c.bma">c.bma</a></code> for functions creating
bma objects, <code>print.bma</code> makes use of <code>summary.bma</code>.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(datafls)

  m_fixed=bms(datafls,burn=1000,iter=3000,user.int=FALSE, )
  summary(m_fixed)
   
  m_ebl=bms(datafls,burn=1000,iter=3000,user.int=FALSE, g="EBL",g.stats=TRUE)
  info.bma(m_ebl)

</code></pre>

<hr>
<h2 id='is.bma'>Tests for a 'bma' Object</h2><span id='topic+is.bma'></span>

<h3>Description</h3>

<p>tests for objects of class &quot;bma&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bma(bmao)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.bma_+3A_bmao">bmao</code></td>
<td>
<p>a 'bma' object: see 'value'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if bmao is of class 'bma', <code>FALSE</code>
otherwise.
</p>


<h3>See Also</h3>

<p>'Output' in <code><a href="#topic+bms">bms</a></code> for the structure of a 'bma' object
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm=bms(datafls,burn=1000, iter=4000)
 is.bma(mm)
</code></pre>

<hr>
<h2 id='lps.bma'>Log Predictive Score</h2><span id='topic+lps.bma'></span>

<h3>Description</h3>

<p>Computes the Log Predictive Score to evaluate a forecast based on a bma
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lps.bma(object, realized.y, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lps.bma_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+pred.density">pred.density</a></code>, or class
<code>bma</code> (cf. <code><a href="#topic+bms">bms</a></code>), or class <code><a href="#topic+zlm">zlm</a></code></p>
</td></tr>
<tr><td><code id="lps.bma_+3A_realized.y">realized.y</code></td>
<td>
<p>a vector with realized values of the dependent variables
to be plotted in addition to the predictive density, must have its length
conforming to <code>newdata</code></p>
</td></tr>
<tr><td><code id="lps.bma_+3A_newdata">newdata</code></td>
<td>
<p>Needs to be provided if <code>object</code> is not of class
<code><a href="#topic+pred.density">pred.density</a></code>: a data.frame, matrix or vector containing
variables with which to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log predictive score is an indicator for the likelihood of several
forecasts.<br /> It is defined as minus the arithmethic mean of the logarithms
of the point densities for <code>realized.y</code> given <code>newdata</code>.<br /> Note
that in most cases is more efficient to first compute the predictive density
object via a call to <code><a href="#topic+pred.density">pred.density</a></code> and only then pass the
result on to <code>lps.bma</code>.
</p>


<h3>Value</h3>

<p>A scalar denoting the log predictive score
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pred.density">pred.density</a></code> for constructing predictive densities,
<code><a href="#topic+bms">bms</a></code> for creating <code>bma</code> objects, <code><a href="#topic+density.bma">density.bma</a></code>
for plotting coefficient densities
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm=bms(datafls,user.int=FALSE,nmodel=100)
 
 #LPS for actual values under the used data (static forecast)
 lps.bma(mm, realized.y=datafls[,1] , newdata=datafls[,-1])
 
 #the same result via predicitve.density
 pd=pred.density(mm, newdata=datafls[,-1])
 lps.bma(pd,realized.y=datafls[,1])
 
 # similarly for a linear model (not BMA)
 zz = zlm(datafls)
 lps.bma(zz, realized.y=datafls[,1] , newdata=datafls[,-1])
 
</code></pre>

<hr>
<h2 id='mprior-class'>Class &quot;mprior&quot;</h2><span id='topic+mprior-class'></span>

<h3>Description</h3>

<p>An object pertaining to a BMA model prior
</p>


<h3>Objects from the Class</h3>

<p>An <code>mprior</code> object holds descriptions
and subfunctions pertaining to model priors. The BMA functions
<code><a href="#topic+bms">bms</a></code> and post-processing functions rely on this class. <br />
There are currently five model prior structures built into the BMS package,
generated by the following functions (cf. the appendix of
<code>vignette(BMS)</code>): <br /> <code>mprior.uniform.init</code>: creates a uniform
model prior object.<br /> <code>mprior.fixedt.init</code>: creates the popular
binomial model prior object with common inclusion probabilities.<br />
<code>mprior.randomt.init</code>: creates a beta-binomial model prior object.<br />
<code>mprior.pip.init</code>: creates a binomial model prior object that allows
for defining individual prior inclusion probabilities.<br />
<code>mprior.customk.init</code>: creates a model prior object that allows for
defining a custom prior for each model parameter size.<br /> The following
describes the necessary slots:
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher and Stefan Zeugner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating <code>bma</code> objects. <br /> Check the
appendix of <code>vignette(BMS)</code> for a more detailed description of built-in
priors.<br /> Check <a href="http://bms.zeugner.eu/custompriors.php">http://bms.zeugner.eu/custompriors.php</a> for examples.
</p>

<hr>
<h2 id='plot.bma'>Plot Posterior Model Size and Model Probabilities</h2><span id='topic+plot.bma'></span>

<h3>Description</h3>

<p>Produces a combined plot: upper row shows prior and posterior model size
distribution, lower row shows posterior model probabilities for the best
models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bma_+3A_x">x</code></td>
<td>
<p>an object of class 'bma'</p>
</td></tr>
<tr><td><code id="plot.bma_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>combines the plotting functions <code><a href="#topic+plotModelsize">plotModelsize</a></code> and
<code><a href="#topic+plotConv">plotConv</a></code>
</p>


<h3>Note</h3>

<p>The upper plot shows the prior and posterior distribution of model
sizes (<code><a href="#topic+plotModelsize">plotModelsize</a></code>).<br /> The lower plot is an indicator of
how well the bma object has converged (<code><a href="#topic+plotConv">plotConv</a></code>).
and Paul
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotModelsize">plotModelsize</a></code> and <code><a href="#topic+plotConv">plotConv</a></code>
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datafls)
mm=bms(datafls,user.int=FALSE)

plot(mm)
</code></pre>

<hr>
<h2 id='plotComp'>Compare Two or More bma Objects</h2><span id='topic+plotComp'></span>

<h3>Description</h3>

<p>Plots a comparison of posterior inclusion probabilites, coefficients or
their standard deviation between various bma objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotComp(
  ...,
  varNr = NULL,
  comp = "PIP",
  exact = FALSE,
  include.legend = TRUE,
  add.grid = TRUE,
  do.par = TRUE,
  cex.xaxis = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotComp_+3A_...">...</code></td>
<td>
<p>one or more objects of class 'bma' to be compared.
<code>plotComp</code> passes on any other parameters in <code>...{}</code> to
<code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plotComp_+3A_varnr">varNr</code></td>
<td>
<p>optionally, covariate indices to be included in the plot, can
be either integer vector or character vector - see examples</p>
</td></tr>
<tr><td><code id="plotComp_+3A_comp">comp</code></td>
<td>
<p>a character denoting what should be compared: <code>comp="PIP"</code>
(default) for posterior inclusion probabilities, <code>comp="Post Mean"</code> for
coefficients, <code>comp="Post SD"</code> for their standard deviations,
<code>comp="Std Mean"</code> or standardized coefficients, or <code>comp="Std SD"</code>
for standardized standard deviations</p>
</td></tr>
<tr><td><code id="plotComp_+3A_exact">exact</code></td>
<td>
<p>if <code>FALSE</code>, the statistics to be compared are based on
aggregate bma statistics, if <code>TRUE</code>, they are based solely on the best
models retained in the bma objects</p>
</td></tr>
<tr><td><code id="plotComp_+3A_include.legend">include.legend</code></td>
<td>
<p>whether to include a default legend in the plot
(custom legends can be added with the command <code><a href="graphics.html#topic+legend">legend</a></code>)</p>
</td></tr>
<tr><td><code id="plotComp_+3A_add.grid">add.grid</code></td>
<td>
<p>whether to add a <code><a href="graphics.html#topic+grid">grid</a></code> to the plot</p>
</td></tr>
<tr><td><code id="plotComp_+3A_do.par">do.par</code></td>
<td>
<p>whether to adjust <code>par("mar")</code> in order to fit in the
tick labels on the x-axis</p>
</td></tr>
<tr><td><code id="plotComp_+3A_cex.xaxis">cex.xaxis</code></td>
<td>
<p>font size scaling parameter for the x-axis - cf. argument
<code>cex.axis</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+coef.bma">coef.bma</a></code> for the underlying function
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## sample two simple bma objects
data(datafls)
mm1=bms(datafls[,1:15])
mm2=bms(datafls[,1:15])

#compare PIPs
plotComp(mm1,mm2)

#compare standardized coefficeitns
plotComp(mm1,mm2,comp="Std Mean")

#...based on the lieklihoods of best models 
plotComp(mm1,mm2,comp="Std Mean",exact=TRUE)

#plot only PIPs for first four covariates
plotComp(mm1,mm2,varNr=1:4, col=c("black","red"))

#plot only coefficients for covariates 'GDP60 ' and 'LifeExp'
plotComp(mm1,mm2,varNr=c("GDP60", "LifeExp"),comp="Post Mean")



</code></pre>

<hr>
<h2 id='plotConv'>Plot Convergence of BMA Sampler</h2><span id='topic+plotConv'></span>

<h3>Description</h3>

<p>Plots the posterior model probabilites based on 1) marginal likelihoods and
2) MCMC frequencies for the best models in a 'bma' object and details the
sampler's convergence by their correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConv(bmao, include.legend = TRUE, add.grid = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotConv_+3A_bmao">bmao</code></td>
<td>
<p>an object of class 'bma' - see <code><a href="#topic+bms">bms</a></code></p>
</td></tr>
<tr><td><code id="plotConv_+3A_include.legend">include.legend</code></td>
<td>
<p>whether to include a <code><a href="graphics.html#topic+legend">legend</a></code> in the plot</p>
</td></tr>
<tr><td><code id="plotConv_+3A_add.grid">add.grid</code></td>
<td>
<p>whether to include a <code><a href="graphics.html#topic+grid">grid</a></code> in the plot</p>
</td></tr>
<tr><td><code id="plotConv_+3A_...">...</code></td>
<td>
<p>other parameters for <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to bms with a MCMC sampler (e.g.
<code>bms(datafls,mcmc="bd",nmodel=100)</code> uses a Metropolis-Hastings
algorithm to sample through the model space: the frequency of how often
models are drawn converges to the distribution of their posterior marginal
likelihoods.<br /> While sampling, each 'bma' object stores the best models
encountered by its sampling chain with their marginal likelihood and their
MCMC frequencies.<br /> <code>plotConv</code> compares the MCMC frequencies to
marginal likelihoods, and thus visualizes how well the sampler has
converged.
</p>


<h3>Note</h3>

<p><code>plotConv</code> is also used by <code><a href="#topic+plot.bma">plot.bma</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmp.bma">pmp.bma</a></code> for posterior model probabilites based on the
two concepts, <code><a href="#topic+bms">bms</a></code> for creating objects of class 'bma'
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(datafls)
mm=bms(datafls[,1:12],user.int=FALSE)

plotConv(mm)

#is similar to
matplot(pmp.bma(mm),type="l")

</code></pre>

<hr>
<h2 id='plotModelsize'>Plot Model Size Distribution</h2><span id='topic+plotModelsize'></span>

<h3>Description</h3>

<p>Plots posterior and prior model size distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModelsize(
  bmao,
  exact = FALSE,
  ksubset = NULL,
  include.legend = TRUE,
  do.grid = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotModelsize_+3A_bmao">bmao</code></td>
<td>
<p>a 'bma' object (cf. <code><a href="#topic+bms">bms</a></code>)</p>
</td></tr>
<tr><td><code id="plotModelsize_+3A_exact">exact</code></td>
<td>
<p>if <code>TRUE</code>, then the posterior model distribution is based
on the best models of <code>bmao</code> and their marginal likelihoods;<br /> if
<code>FALSE</code> (default) then the distribution is based on all encountered
models and their MCMC frequencies (cf. 'Details' in <code><a href="#topic+coef.bma">coef.bma</a></code>)</p>
</td></tr>
<tr><td><code id="plotModelsize_+3A_ksubset">ksubset</code></td>
<td>
<p>integer vector detailing for which model sizes the plot
should be done</p>
</td></tr>
<tr><td><code id="plotModelsize_+3A_include.legend">include.legend</code></td>
<td>
<p>if <code>TRUE</code>, a small legend is included via the
low-level command <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plotModelsize_+3A_do.grid">do.grid</code></td>
<td>
<p>if <code>TRUE</code>, a <code><a href="graphics.html#topic+grid">grid</a></code> is added to the plot
(with a simple <code>grid()</code>).</p>
</td></tr>
<tr><td><code id="plotModelsize_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="graphics.html#topic+matplot">matplot</a></code> with sensible
defaults</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a default, <code>plotModelsize</code> plots the posterior model size
distribution as a blue line, and the prior model distribution as a dashed
red line.<br /> In addition, it returns a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>The posterior expected value of model size</p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>The
variance of the posterior model size distribution</p>
</td></tr> <tr><td><code>dens</code></td>
<td>
<p>A vector
detailing the posterior model size distribution from model size <code class="reqn">0</code> (the
first element) to <code class="reqn">K</code> (the last element)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <code><a href="#topic+bms">bms</a></code>, <code><a href="#topic+image.bma">image.bma</a></code>,
<code><a href="#topic+density.bma">density.bma</a></code>, <code><a href="#topic+plotConv">plotConv</a></code>
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datafls)
mm=bms(datafls,burn=1500, iter=5000, nmodel=200,mprior="fixed",mprior.size=6)

#plot Nb.1 based on aggregate results
postdist= plotModelsize(mm)

#plot based only on 30 best models
plotModelsize(mm[1:30],exact=TRUE,include.legend=FALSE)

#plot based on all best models, but showing distribution only for model sizes 1 to 20
plotModelsize(mm,exact=TRUE,ksubset=1:20)

# create a plot similar to plot Nb. 1
plot(postdist$dens,type="l") 
lines(mm$mprior.info$mp.Kdist)


</code></pre>

<hr>
<h2 id='pmp.bma'>Posterior Model Probabilities</h2><span id='topic+pmp.bma'></span>

<h3>Description</h3>

<p>Returns the posterior model probabilites for the best models encountered by
a 'bma' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmp.bma(bmao, oldstyle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmp.bma_+3A_bmao">bmao</code></td>
<td>
<p>A bma object (see argument <code>nmodel</code> in <code><a href="#topic+bms">bms</a></code>),
alternatively an object of class <code><a href="#topic+topmod">topmod</a></code></p>
</td></tr>
<tr><td><code id="pmp.bma_+3A_oldstyle">oldstyle</code></td>
<td>
<p>For normal use, leave this at <code>FALSE</code>. It is an
argument for compatibility with older BMS versions - see section 'Notes'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to bms with an MCMC sampler (e.g.
<code>bms(datafls,mcmc="bd",nmodel=100)</code> uses a Metropolis-Hastings
algorithm to sample through the model space - and the frequency of how often
models are drawn converges to the distribution of their posterior marginal
likelihoods.  While sampling, each 'bma' object stores the best models
encountered by its sampling chain with their marginal likelihood and their
MCMC frequencies.
</p>
<p><code>pmp.bma</code> then allows for comparing the posterior model probabilities
(PMPs) for the two different methods, similar to <code><a href="#topic+plotConv">plotConv</a></code>.  It
calculates the PMPs based on marginal likelihoods (first column) and the
PMPs based on MCMC frequencies (second column) for the best x models stored
in the bma object.
</p>
<p>The correlation of the two columns is an indicator of how well the MCMC
sampler has converged to the actual PMP distribution - it is therefore also
given in the output of <code><a href="#topic+summary.bma">summary.bma</a></code>.
</p>
<p>The second column is slightly different in case the <code><a href="#topic+bms">bms</a></code>
argument <code>mcmc</code> was set to <code>mcmc="enumeration"</code>: In this case, the
second column is also based on marginal likelihoods. The correlation between
the two columns is therefore one.
</p>


<h3>Value</h3>

<p>the result is a matrix, its row names describe the model binaries<br />
There are two columns in the matrix: </p>
<table role = "presentation">
<tr><td><code>PMP (Exact)</code></td>
<td>
<p>posterior model
probabilities based on the posterior likelihoods of the best models in
<code>bmao</code> </p>
</td></tr> <tr><td><code>PMP (MCMC)</code></td>
<td>
<p>posterior model probabilities of the best
models in <code>bmao</code> based on their MCMC frequencies, relative to all
models encountered by <code>bmao</code> - see 'Details' </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The second column thus shows the PMPs of the best models relative to
all models the call to <code><a href="#topic+bms">bms</a></code> has sampled through (therefore
typically the second column adds up to less than one).  The first column
relates to the likelihoods of the best models, therefore it would add up to
1.  In order estimate for their marginal likelihoods with respect to the
other models (the ones not retained in the best models), these PMP aadding
up to one are multiplied with the sum of PMP of the best models accroding to
MCMC frequencies.  Therefore, the two columns have the same column sum.
</p>
<p>CAUTION: In package versions up to <code>BMS 0.2.5</code>, the first column was
indeed set always equal to one. This behaviour can still be mimicked by
setting <code>oldstyle=TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotConv">plotConv</a></code> for plotting <code>pmp.bma</code>,
<code><a href="#topic+pmpmodel">pmpmodel</a></code> to obtain the PMP for any individual model,
<code><a href="#topic+bms">bms</a></code> for sampling bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## sample BMA for growth dataset, MCMC sampler
data(datafls)
mm=bms(datafls[,1:10],nmodel=20, mcmc="bd")

## mmodel likelihoods and MCMC frequencies of best 20 models
print(mm$topmod)

pmp.bma(mm)
#first column: posterior model prob based on model likelihoods,
#  relative to best models in 'mm'
#second column: posterior model prob based MCMC frequencies,
#  relative to all models encountered by 'mm'

#consequently, first column adds up to one
#second column shows how much of the sampled model space is
# contained in the best models
colSums(pmp.bma(mm))


#correlation betwwen the two shows how well the sampler converged
cor(pmp.bma(mm)[,1],pmp.bma(mm)[,2])

#is the same as given in summary.bma
summary(mm)["Corr PMP"]

#plot the two model probabilites
plotConv(mm)

#equivalent to the following chart
plot(pmp.bma(mm)[,2], type="s")
lines(pmp.bma(mm)[,1],col=2)


#moreover, note how the first column is constructed
liks=exp(mm$top$lik())
liks/sum(liks)
pmp.bma(mm)[,1] #these two are equivalent



#the example above does not converge well,
#too few iterations and best models
# this is already better, but also not good
mm=bms(datafls[,1:10],burn=2000,iter=5000,nmodel=200)


# in case the sampler has been 'enumeration' instead of MCMC,
# then both matrix columns are of course equivalent
mm=bms(datafls[,1:10],nmodel=512,mcmc="enumeration")
cor(pmp.bma(mm)[,1],pmp.bma(mm)[,2])
colSums(pmp.bma(mm))


</code></pre>

<hr>
<h2 id='pmpmodel'>Posterior Model Probability for any Model</h2><span id='topic+pmpmodel'></span>

<h3>Description</h3>

<p>Returns the posterior model probability for any model based on bma results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmpmodel(bmao, model = numeric(0), exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmpmodel_+3A_bmao">bmao</code></td>
<td>
<p>A bma object as created by <code><a href="#topic+bms">bms</a></code>.</p>
</td></tr>
<tr><td><code id="pmpmodel_+3A_model">model</code></td>
<td>
<p>A model index - either variable names, or a logical with model
binaries, or the model hexcode (cf. <code><a href="#topic+hex2bin">hex2bin</a></code>, or a numeric with
positions of the variables to be included.</p>
</td></tr>
<tr><td><code id="pmpmodel_+3A_exact">exact</code></td>
<td>
<p>If <code>TRUE</code>, then the resulting PMP is based on analytical
model likelihoods (works for any model). <br /> If <code>FALSE</code>, the the
resulting PMP is derived from MCMC frequencies (works only for the null and
fullmodel, as well as for models contained in <code>bmao</code>'s topmod
object.<br /> If <code>bmao</code> is based on enumeration (cf. argument <code>mcmc</code>
in <code><a href="#topic+bms">bms</a></code>, then <code>exact</code> does not matter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model as provided in <code>model</code> is the null or the full model, or
is contained in <code>bmao</code>'s topmod object (cf. argument <code>nmodel</code> in
<code><a href="#topic+bms">bms</a></code>), <br /> then the result is the same as in
<code><a href="#topic+pmp.bma">pmp.bma</a></code>.<br /> If not and <code>exact=TRUE</code>, then <code>pmpmodel</code>
estimates the model based on comparing its marginal likelihood (times model
prior) to the likelihoods in the <code>topmod</code> object and multiplying by
their sum of PMP according to MCMC frequencies,
</p>


<h3>Value</h3>

<p>A scalar with (an estimate of) the posterior model probability for
<code>model</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmp.bma">pmp.bma</a></code> for similar
functions
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## sample BMA for growth dataset, enumeration sampler
data(datafls)
mm=bms(datafls[,1:10],nmodel=5)

#show the best 5 models:
pmp.bma(mm)
#first column: posterior model prob based on model likelihoods,
#second column: posterior model prob based MCMC frequencies,

### Different ways to get the same result: #########

#PMP of 2nd-best model (hex-code representation)
pmpmodel(mm,"00c")

#PMP of 2nd-best model (binary representation)
incls=as.logical(beta.draws.bma(mm)[,2])
pmpmodel(mm,incls)

#PMP of 2nd-best model (via variable names)
#names of regressors in model "00c": 
names(datafls[,2:10])[incls]
pmpmodel(mm,c("SubSahara", "LatAmerica"))

#PMP of 2nd-best model (via positions)
pmpmodel(mm,c(6,7))

####PMP of another model #########
pmpmodel(mm,1:5)


</code></pre>

<hr>
<h2 id='post.var'>Posterior Variance and Deviance</h2><span id='topic+post.var'></span><span id='topic+post.pr2'></span><span id='topic+deviance.bma'></span><span id='topic+deviance.zlm'></span>

<h3>Description</h3>

<p>Returns posterior residual variance, deviance, or pseudo R-squared,
according to the chosen prior structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.var(object, exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post.var_+3A_object">object</code></td>
<td>
<p>A <code>bma</code> object (as produced by <code><a href="#topic+bms">bms</a></code>) or a
<code><a href="#topic+zlm">zlm</a></code> object.</p>
</td></tr>
<tr><td><code id="post.var_+3A_exact">exact</code></td>
<td>
<p>When <code>exact=FALSE</code>, then <code>deviance</code> will be based on
MCMC frequencies, if <code>exact=TRUE</code> then it will be based on<br />
analytical posterior model probabilities - cf. argument <code>exact</code> in
<code><a href="#topic+coef.bma">coef.bma</a></code>.</p>
</td></tr>
<tr><td><code id="post.var_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>post.var</code>: Posterior residual variance as according to the prior
definitions contained in <code>object</code> <br /> <code>post.pr2</code>: A
pseudo-R-squared corresponding to unity minus posterior variance over
dependent variance. <br /> <code>deviance.bma</code>: returns the
<code><a href="stats.html#topic+deviance">deviance</a></code> of a <code>bma</code> model as returned from
<code><a href="#topic+bms">bms</a></code>. <br /> <code>deviance.zlm</code>: returns the
<code><a href="stats.html#topic+deviance">deviance</a></code> of a <code><a href="#topic+zlm">zlm</a></code> model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating <code>bma</code> objects and priors,
<code><a href="#topic+zlm">zlm</a></code> object.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
  
 mm=bms(datafls[,1:10])
 deviance(mm)/nrow(datafls) # is equivalent to
 post.var(mm)
 
 post.pr2(mm) # is equivalent to
 1 - post.var(mm) / ( var(datafls[,1])*(1-1/nrow(datafls)) )
 
</code></pre>

<hr>
<h2 id='pred.density'>Predictive Densities for bma Objects</h2><span id='topic+pred.density'></span><span id='topic+pred.density-class'></span><span id='topic+print.pred.density'></span>

<h3>Description</h3>

<p>Predictive densities for conditional forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.density(object, newdata = NULL, n = 300, hnbsteps = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred.density_+3A_object">object</code></td>
<td>
<p>a bma object - see <code><a href="#topic+bms">bms</a></code>, alternativel a
<code><a href="#topic+zlm">zlm</a></code> object</p>
</td></tr>
<tr><td><code id="pred.density_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame, matrix or vector containing variables with
which to predict.</p>
</td></tr>
<tr><td><code id="pred.density_+3A_n">n</code></td>
<td>
<p>The integer number of equally spaced points at which the density is
to be estimated.</p>
</td></tr>
<tr><td><code id="pred.density_+3A_hnbsteps">hnbsteps</code></td>
<td>
<p>The number of numerical integration steps to be used in case
of a hyper-g prior (cf. argument <code>g</code> in <code><a href="#topic+bms">bms</a></code>). Increase
this number to increase accuracy. Must be an even integer.</p>
</td></tr>
<tr><td><code id="pred.density_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to <code><a href="stats.html#topic+plot.density">plot.density</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictive density is a mixture density based on the <code>nmodels</code> best
models in a <code>bma</code> object (cf. <code>nmodel</code> in <code><a href="#topic+bms">bms</a></code>).<br />
The number of 'best models' to retain is therefore vital and should be set
quite high for accuracy.
</p>


<h3>Value</h3>

<p><code>pred.density</code> returns a list of class <code>pred.density</code> with
the following elements </p>
<table role = "presentation">
<tr><td><code>densities()</code></td>
<td>
<p>a list whose elements each contain
the estimated density for each forecasted observation</p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p>a vector
with the expected values of the predictions (the 'point forecasts')</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>a vector with the standard deviations of the predictions (the
'standard errors')</p>
</td></tr> <tr><td><code>dyf(realized.y</code>, <code>predict_index=NULL)</code></td>
<td>
<p>Returns the
densities of realized response variables provided in <code>realized.y</code>. <br />
If <code>realized.y</code> is a matrix, then each row corresponds to a forecast
observation in <code>newdata</code><br /> if not left empty, <code>predict.index</code>
specifies to which observations in newdata the realized.y should apply</p>
</td></tr>
<tr><td><code>lps(realized.y</code>, <code>predict_index=NULL)</code></td>
<td>
<p>Computes the log predictive score
for the response varaible provided in <code>realized.y</code> (cf.
<code><a href="#topic+lps.bma">lps.bma</a></code>) -<br /> Note that the LPS equals minus the mean of the
logarithmized results from <code>dyf</code>) </p>
</td></tr> <tr><td><code>plot((x</code>, <code>predict_index =
NULL</code>, <code>addons = "eslz"</code>, <code>realized.y = NULL</code>, <code>addons.lwd = 1.5</code>, <code>...)</code></td>
<td>
<p>the same
as <code>plot.pred.density</code></p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>The number of equally spaced
points for which the density (under <code>densities()</code> was computed.</p>
</td></tr>
<tr><td><code>nmodel</code></td>
<td>
<p>The number of best models predictive densities are based
upon.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the call that created this <code>pred.density</code> object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In BMS version 0.3.0, <code>pred.density</code> may only cope with built-in
<code>gprior</code>s, not with any user-defined priors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bma">predict.bma</a></code> for simple point forecasts,
<code>plot.pred.density</code> for plotting predictive densities,
<code><a href="#topic+lps.bma">lps.bma</a></code> for calculating the log predictive score
independently, <code><a href="#topic+quantile.pred.density">quantile.pred.density</a></code> for extracting quantiles
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm=bms(datafls,user.int=FALSE)
 
 #predictive densityfor two 'new' data points
 pd=pred.density(mm,newdata=datafls[1:2,]) 
 
 
 #fitted values based on best models, same as predict(mm, exact=TRUE)
 pd$fit
 
 #plot the density for the first forecast observation
 plot(pd,1)  
 
 # the same plot ' naked'
 plot(pd$densities()[[1]])
 
 
 #predict density for the first forecast observation if the dep. variable is 0
 pd$dyf(0,1) 
 
 #predict densities for both forecasts for the realizations 0 and 0.5
 pd$dyf(rbind(c(0,.5),c(0,.5)))
 
 # calc. Log Predictive Score if both forecasts are realized at 0:
 lps.bma(pd,c(0,0))
 
 
</code></pre>

<hr>
<h2 id='predict.bma'>Predict Method for bma Objects</h2><span id='topic+predict.bma'></span>

<h3>Description</h3>

<p>Expected value of prediction based on 'bma' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
predict(object, newdata = NULL, exact = FALSE, topmodels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bma_+3A_object">object</code></td>
<td>
<p>a bma object - see <code><a href="#topic+bms">bms</a></code></p>
</td></tr>
<tr><td><code id="predict.bma_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame, matrix or vector containing variables
with which to predict. If omitted, then (the expected values of) the fitted
values are returned.</p>
</td></tr>
<tr><td><code id="predict.bma_+3A_exact">exact</code></td>
<td>
<p>If <code>FALSE</code> (default), then prediction is based on all
models (i.e. on their MCMC frequencies in case the <code><a href="#topic+bms">bms</a></code>
parameter <code>mcmc</code> was set to an mcmc sampler.<br /> If <code>TRUE</code>, then
prediction is based on analytical likelihoods of the best models retained in
<code>object</code> - cf. <code><a href="#topic+bms">bms</a></code> parameter <code>nmodel</code>.</p>
</td></tr>
<tr><td><code id="predict.bma_+3A_topmodels">topmodels</code></td>
<td>
<p>index of the models with whom to predict: for instance,
<code>topmodels=1</code> predicts based solely on the best model, whereas
<code>topmodels=1:5</code> predicts based on a combination of the five best
models.<br /> Note that setting <code>topmodels</code> triggers <code>exact=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.bma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with (expected values of) fitted values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.bma">coef.bma</a></code> for obtaining coefficients,
<code><a href="#topic+bms">bms</a></code> for creating bma objects, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code> for a
comparable function
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm=bms(datafls,user.int=FALSE)
 
 predict(mm) #fitted values based on MCM frequencies
 predict(mm, exact=TRUE) #fitted values based on best models
 
 predict(mm, newdata=1:41) #prediction based on MCMC frequencies 
 
 predict(mm, newdata=datafls[1,], exact=TRUE) #prediction based on a data.frame
 
 # the following two are equivalent:
 predict(mm, topmodels=1:10)
 predict(mm[1:10], exact=TRUE)
 
 
</code></pre>

<hr>
<h2 id='predict.zlm'>Predict Method for zlm Linear Model</h2><span id='topic+predict.zlm'></span>

<h3>Description</h3>

<p>Expected value (And standard errors) of predictions based on 'zlm' linear
Bayesian model under Zellner's g prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
predict(object, newdata = NULL, se.fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.zlm_+3A_object">object</code></td>
<td>
<p>a zlm linear model object - see <code><a href="#topic+zlm">zlm</a></code></p>
</td></tr>
<tr><td><code id="predict.zlm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame, matrix or vector containing variables
with which to predict. If omitted, then (the expected values of) the fitted
values are returned.</p>
</td></tr>
<tr><td><code id="predict.zlm_+3A_se.fit">se.fit</code></td>
<td>
<p>A switch indicating if the standard deviations for the
predicted varaibles are required.</p>
</td></tr>
<tr><td><code id="predict.zlm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with (expected values of) fitted values.<br /> If
<code>se.fit</code> is <code>TRUE</code>, then the output is a list with the following
elements: </p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> a vector with the expected values of fitted values</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p> a vector with the standard deviations of fitted values</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p> a vector with the standard errors without the residual scale
akin to <code>se.fit</code> in <code><a href="stats.html#topic+predict.lm">predict.lm</a></code> </p>
</td></tr> <tr><td><code>residual.scale</code></td>
<td>

<p>The part from the standard deviations that involves the identity matrix.
Note that <code>sqrt(se.fit^2+residual.scale^2)</code> yields <code>std.err</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating zlm objects,
<code><a href="stats.html#topic+predict.lm">predict.lm</a></code> for a comparable function,
<code><a href="#topic+predict.bma">predict.bma</a></code> for predicting with bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm=zlm(datafls,g="EBL")
 
 predict(mm) #fitted values 
 predict(mm, newdata=1:41) #prediction based on a 'new data point' 
 
 #prediction based on a 'new data point', with 'standard errors'
 predict(mm, newdata=datafls[1,], se.fit=TRUE) 
 
</code></pre>

<hr>
<h2 id='print.topmod'>Printing topmod Objects</h2><span id='topic+print.topmod'></span>

<h3>Description</h3>

<p>Print method for objects of class 'topmod', typically the best models stored
in a 'bma' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'topmod'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.topmod_+3A_x">x</code></td>
<td>
<p>an object of class 'topmod' - see <code><a href="#topic+topmod">topmod</a></code></p>
</td></tr>
<tr><td><code id="print.topmod_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>link{print}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+pmp.bma">pmp.bma</a></code> for an explanation of likelihood vs. MCMC
frequency concepts
</p>


<h3>Value</h3>

<p>if <code>x</code> contains more than one model, then the function returns
a 2-column matrix: </p>
<table role = "presentation">
<tr><td><code>Row Names</code></td>
<td>
<p>show the model binaries in hexcode 
</p>
</td></tr> <tr><td><code>Column 'Marg.Log.Lik'</code></td>
<td>
<p>shows the
marginal log-likelihoods of the models in <code>x</code></p>
</td></tr> <tr><td><code>Column 'MCMC
Freq'</code></td>
<td>
<p>shows the MCMC frequencies of the models in <code>x</code></p>
</td></tr>
</table>
<p>if <code>x</code> contains only one model, then more detailed information is shown
for this model: </p>
<table role = "presentation">
<tr><td><code>first line</code></td>
<td>
<p>'Model Index' provides the model binary in
hexcode, 'Marg.Log.Lik' its marginal log likelhood, 'Sampled Freq.' how
often it was accepted (function <code>ncount()</code> in <code><a href="#topic+topmod">topmod</a></code>)</p>
</td></tr>
<tr><td><code>Estimates</code></td>
<td>
<p>first column: covariate indices included in the model,
second column: posterior expected value of the coefficients, third column:
their posterior standard deviations (excluded if no coefficients were stored
in the topmod object - cf. argument <code>bbeta</code> in <code><a href="#topic+topmod">topmod</a></code>) </p>
</td></tr>
<tr><td><code>Included Covariates</code></td>
<td>
<p>the model binary</p>
</td></tr> <tr><td><code>Additional
Statistics</code></td>
<td>
<p>any custom additional statistics saved with the model</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+topmod">topmod</a></code> for creating topmod objects, <code><a href="#topic+bms">bms</a></code>
for their typical use, <code><a href="#topic+pmp.bma">pmp.bma</a></code> for comparing posterior model
probabilities
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# do some small-scale BMA for demonstration
data(datafls)
mm=bms(datafls[,1:10],nmodel=20)

#print info on the best 20 models
print(mm$topmod)
print(mm$topmod,digits=10)

#equivalent:
cbind(mm$topmod$lik(),mm$topmod$ncount())



#now print info only for the second-best model:
print(mm$topmod[2])

#compare 'Included Covariates' to:
topmodels.bma(mm[2])

#and to
as.vector(mm$topmod[2]$bool_binary())


</code></pre>

<hr>
<h2 id='quantile.density'>Extract Quantiles from 'density' Objects</h2><span id='topic+quantile.density'></span><span id='topic+quantile.coef.density'></span><span id='topic+quantile.pred.density'></span>

<h3>Description</h3>

<p>Quantiles for objects of class &quot;density&quot;, &quot;pred.density&quot; or &quot;coef.density&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, normalize = TRUE, ...)

## S3 method for class 'coef.density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, ...)

## S3 method for class 'pred.density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile.density_+3A_x">x</code></td>
<td>
<p>a object of class <code><a href="#topic+pred.density">pred.density</a></code>, <code>coef.density</code>,
<code><a href="stats.html#topic+density">density</a></code>, or a list of densities.</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1] - elements
very close to the boundaries return <code>Inf</code> or <code>-Inf</code></p>
</td></tr>
<tr><td><code id="quantile.density_+3A_names">names</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result has a <code>names</code>
attribute, resp. a <code>rownames</code> and <code>colnames</code> attributes. Set to
<code>FALSE</code> for speedup with many probs.</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_normalize">normalize</code></td>
<td>
<p>logical; if <code>TRUE</code> then the values in <code>x$y</code> are
multiplied with a factor such that their integral is equal to one.</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>quantile.coef.density</code> and <code>quantile.pred.density</code>
both apply <code>quantile.density</code> to densities nested with object of class
<code>coef.density</code> or <code>pred.density</code>.<br /> The function
<code>quantile.density</code> applies generically to the built-in class
<code><a href="stats.html#topic+density">density</a></code> (as least for versions where there is no such method
in the pre-configured packages).<br /> Note that <code>quantile.density</code> relies
on trapezoidal integration in order to compute the cumulative densities
necessary for the calculation of quantiles.
</p>


<h3>Value</h3>

<p>If <code>x</code> is of class <code>density</code> (or a list with exactly one
element), a vector with quantiles.<br /> If <code>x</code> is a <code><a href="base.html#topic+list">list</a></code> of
densities with more than one element (e.g. as resulting from
<code>pred.density</code> or <code>coef.density</code>), then the output is a matrix of
quantiles, with each matrix row corresponding to the respective density.
</p>


<h3>Author(s)</h3>

<p>Stefan Zeugner
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile.default">quantile.default</a></code> for a comparable function,
<code><a href="#topic+pred.density">pred.density</a></code> and <code><a href="#topic+density.bma">density.bma</a></code> for the
BMA-specific objects.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 mm = bms(datafls[1:70,], user.int=FALSE)
 
 #predict last two observations with preceding 70 obs:
 pmm = pred.density(mm, newdata=datafls[71:72,], plot=FALSE) 
 #'standard error' quantiles
 quantile(pmm, c(.05, .95))
 
 #Posterior density for Coefficient of "GDP60"
 cmm = density(mm, reg="GDP60", plot=FALSE) 
 quantile(cmm, probs=c(.05, .95))
 
 
 #application to generic density:
 dd1 = density(rnorm(1000))
 quantile(dd1)
 
## Not run: 
 #application to list of densities:
 quantile.density( list(density(rnorm(1000)), density(rnorm(1000))) )

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.zlm'>Summarizing Linear Models under Zellner's g</h2><span id='topic+summary.zlm'></span>

<h3>Description</h3>

<p>summary method for class &quot;<code>zlm</code>&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
summary(object, printout = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.zlm_+3A_object">object</code></td>
<td>
<p>an object of class <code>zlm</code>: see &quot;Examples&quot; below</p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_printout">printout</code></td>
<td>
<p>If <code>TRUE</code> (default, then information is printed to
console in a neat form</p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.zlm</code> prints out coefficients expected values and their
standard deviations, as well as information on the gprior and the log
marginal likelihood. However, it invisibly returns a list with elements as
described below:
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with the following elements </p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>

<p>The expected value of residuals from the model</p>
</td></tr> <tr><td><code>coefficients</code></td>
<td>
<p>The
posterior expected values of coefficients (including the intercept) </p>
</td></tr>
<tr><td><code>coef.sd</code></td>
<td>
<p>Posterior standard deviations of the coefficients (the
intercept SD is <code>NA</code>, since an improper prior was used)</p>
</td></tr>
<tr><td><code>gprior</code></td>
<td>
<p>The g prior as it has been submitted to <code>object</code></p>
</td></tr>
<tr><td><code>E.shrinkage</code></td>
<td>
<p>the shrinkage factor <code class="reqn">g/(1+g)</code>, respectively its
posterior expected value in case of a hyper-g prior</p>
</td></tr>
<tr><td><code>SD.shrinkage</code></td>
<td>
<p>(Optionally) the shrinkage factor's posterior standard
deviation (in case of a hyper-g prior)</p>
</td></tr> <tr><td><code>log.lik</code></td>
<td>
<p>The log marginal
likelihood of the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Zeugner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zlm">zlm</a></code> for creating <code>zlm</code> objects,
<code>link{summary.lm}</code> for a similar function on OLS models
</p>
<p>See also <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datafls)

#simple example
foo = zlm(datafls)
summary(foo)

sfoo = summary(foo,printout=FALSE)
print(sfoo$E.shrinkage)

</code></pre>

<hr>
<h2 id='topmod'>Topmodel Object</h2><span id='topic+topmod'></span><span id='topic+is.topmod'></span>

<h3>Description</h3>

<p>Create or use an updateable list keeping the best x models it encounters
(for advanced users)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topmod(
  nbmodels,
  nmaxregressors = NA,
  bbeta = FALSE,
  lengthfixedvec = 0,
  liks = numeric(0),
  ncounts = numeric(0),
  modelbinaries = matrix(0, 0, 0),
  betas = matrix(0, 0, 0),
  betas2 = matrix(0, 0, 0),
  fixed_vector = matrix(0, 0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topmod_+3A_nbmodels">nbmodels</code></td>
<td>
<p>The maximum number of models to be retained by the topmod
object</p>
</td></tr>
<tr><td><code id="topmod_+3A_nmaxregressors">nmaxregressors</code></td>
<td>
<p>The maximum number of covariates the models in the
topmod object are allowed to have</p>
</td></tr>
<tr><td><code id="topmod_+3A_bbeta">bbeta</code></td>
<td>
<p>if <code>bbeta=TRUE</code>, then first and second moments of model
coefficients are stored in addition to basic model statistics (Note: if
<code>bbeta&lt;0</code> then only the first moments are saved)</p>
</td></tr>
<tr><td><code id="topmod_+3A_lengthfixedvec">lengthfixedvec</code></td>
<td>
<p>The length of an optional fixed vector adhering to
each model (for instance R-squared, etc). If <code>lengthfixedvec=0</code> then no
additonal fixed vector will be stored.</p>
</td></tr>
<tr><td><code id="topmod_+3A_liks">liks</code></td>
<td>
<p>optional vector of log-likelihoods to initialize topmod object
with (length must be <code>&lt;=nbmodels</code>) - see example below</p>
</td></tr>
<tr><td><code id="topmod_+3A_ncounts">ncounts</code></td>
<td>
<p>optional vector of MCMC frequencies to initialize topmod
object with (same length as <code>liks</code>) - see example below</p>
</td></tr>
<tr><td><code id="topmod_+3A_modelbinaries">modelbinaries</code></td>
<td>
<p>optional matrix whose columns detail model binaries to
initialize topmod object with (same nb columns as <code>liks</code>, nb rows as
<code>nmaxregressors</code>) - see example below</p>
</td></tr>
<tr><td><code id="topmod_+3A_betas">betas</code></td>
<td>
<p>optional matrix whose columns are coefficients to initialize
topmod object with (same dimensions as <code>modelbinaries</code>) - see example
below</p>
</td></tr>
<tr><td><code id="topmod_+3A_betas2">betas2</code></td>
<td>
<p>optional matrix whose columns are coefficients' second moments
to initialize topmod object with (same dimensions as <code>modelbinaries</code>) -
see example below</p>
</td></tr>
<tr><td><code id="topmod_+3A_fixed_vector">fixed_vector</code></td>
<td>
<p>optional matrix whose columns are a fixed vector
initialize topmod object with (same <code>ncol</code> as <code>modelbinaries</code>) -
see example below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 'topmod' object (as created by <code>topmod</code>) holds three basic vectors:
<code>lik</code> (for the (log) likelihood of models or similar), <code>bool()</code>
for a hexcode presentation of the model binaries (cf. <code><a href="#topic+bin2hex">bin2hex</a></code>)
and ncount() for the times the models have been drawn.<br /> All these vectors
are sorted descendantly by <code>lik</code>, and are of the same length. The
maximum length is limited by the argument <code>nbmodels</code>.
</p>
<p>If <code>tmo</code> is a topmod object, then a call to <code>tmo$addmodel</code> (e.g.
<code>tmo$addmodel(mylik=4,vec01=c(T,F,F,T))</code> updates the object <code>tmo</code>
by a model represented by <code>vec01</code> (here the one including the first and
fourth regressor) and the marginal (log) likelihood <code>lik</code> (here: 4).
</p>
<p>If this model is already part of <code>tmo</code>, then its respective
<code>ncount</code> entry is incremented by one; else it is inserted into a
position according to the ranking of <code>lik</code>.
</p>
<p>In addition, there is the possibility to save (the first moments of)
coefficients of a model (<code>betas</code>) and their second moments
(<code>betas2</code>), as well as an arbitrary vector of statistics per model
(<code>fixed_vector</code>).
</p>
<p><code>is.topmod</code> returns <code>TRUE</code> if the argument is of class 'topmod'
</p>


<h3>Value</h3>

<p>a call to <code>topmod</code> returns a list of class &quot;topmod&quot; with the
following elements:
</p>
<table role = "presentation">
<tr><td><code>addmodel(mylik</code>, <code>vec01</code>, <code>vbeta=numeric(0)</code>, <code>vbeta2=numeric(0)</code>, <code>fixedvec=numeric(0))</code></td>
<td>
<p>function
that adjusts the list of models in the 'topmod' object (see Details).
<code>mylik</code> is the basic selection criterion (usually log likelihood),
<code>vec01</code> is the model binary (logical or numeric) indicating which
regressors are included.<br /> <code>vbeta</code> is a vector of length equal to
<code>sum(vec01)</code>, contianing only the non-zero coefficients (only accounted
for if <code>bbeta!=FALSE</code>). <code>vbeta2</code> is a similar vector of second
moments etc. (only accounted for if <code>bbeta=TRUE</code>); <code>fixedvec</code> is
an arbitrary vector of length <code>lengthfixedvec</code> (see above)</p>
</td></tr>
<tr><td><code>lik()</code></td>
<td>
<p>A numeric vector of the best models (log) likelihoods, in
decreasing order</p>
</td></tr> <tr><td><code>bool()</code></td>
<td>
<p>A character vector of hexmode expressions
for the model binaries (cf. <code><a href="#topic+bin2hex">bin2hex</a></code>), sorted by <code>lik()</code> </p>
</td></tr>
<tr><td><code>ncount()</code></td>
<td>
<p>A numeric vector of MCMC frequencies for the best models
(i.e. how often the respective model was introduced by <code>addmodel</code>)</p>
</td></tr>
<tr><td><code>nbmodels</code></td>
<td>
<p>Returns the argument <code>nbmodel</code></p>
</td></tr> <tr><td><code>nregs</code></td>
<td>
<p>Returns
the argument <code>nmaxregressors</code></p>
</td></tr> <tr><td><code>bool_binary()</code></td>
<td>
<p>Returns a matrix
whose columns present the models conforming to <code>lik()</code> in binary form</p>
</td></tr>
<tr><td><code>betas()</code></td>
<td>
<p>a matrix whose columns are the coefficients conforming to
<code>bool_binary()</code> (Note that these include zero coefficients due to
non-inclusion of covariates); Note: if <code>bbeta=FALSE</code> this returns an
empty matrix</p>
</td></tr> <tr><td><code>betas2()</code></td>
<td>
<p>similar to <code>betas</code> , for the second
moments of coefficients Note: if <code>bbeta&lt;=0</code>, this returns an empty
matrix</p>
</td></tr> <tr><td><code>fixed_vector()</code></td>
<td>
<p>The columns of this matrix return the
<code>fixed_vector</code> statistics conforming to <code>lik()</code> (see Details);
Note: if <code>lengthfixedvec=0</code> this returns an empty matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>topmod</code> is rather intended as a building block for programming;
it has no direct application for a user of the BMS package.
</p>


<h3>See Also</h3>

<p>the object resulting from <code><a href="#topic+bms">bms</a></code> includes an element of
class 'topmod'
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#standard use
  tm= topmod(2,4,TRUE,0) #should keep a  maximum two models
  tm$addmodel(-2.3,c(1,1,1,1),1:4,5:8) #update with some model
  tm$addmodel(-2.2,c(0,1,1,1),1:3,5:7) #add another model
  tm$addmodel(-2.2,c(0,1,1,1),1:3,5:7) #add it again -&gt; adjust ncount
  tm$addmodel(-2.5,c(1,0,0,1),1:2,5:6) #add another model
  
  #read out
  tm$lik()
  tm$ncount()
  tm$bool_binary()
  tm$betas()
  
  is.topmod(tm)
  
  #extract a topmod oobject only containing the second best model
  tm2=tm[2]
  
  
  
  #advanced: should return the same result as
  #initialize
  tm2= topmod(2,4,TRUE,0, liks = c(-2.2,-2.3), ncounts = c(2,1), 
          modelbinaries = cbind(c(0,1,1,1),c(1,1,1,1)), betas = cbind(0:3,1:4), 
          betas2 = cbind(c(0,5:7),5:8)) 

  #update 
  tm$addmodel(-2.5,c(1,0,0,1),1:2,5:6) #add another model
  
  #read out
  tm$lik()
  tm$ncount()
  tm$bool_binary()
  tm$betas()

</code></pre>

<hr>
<h2 id='topmod-class'>Class &quot;topmod&quot;</h2><span id='topic+topmod-class'></span>

<h3>Description</h3>

<p>An updateable list keeping the best x models it encounters in any kind of
model iteration
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to
<code><a href="#topic+topmod">topmod</a></code>, or indirectly by calls to <code><a href="#topic+bms">bms</a></code>.<br />
</p>
<p>A 'topmod' object (as created by <code>topmod</code>) holds three basic vectors:
<code>lik</code> (for the (log) likelihood of models or similar), <code>bool()</code>
for a hexcode presentation of the model binaries (cf. <code><a href="#topic+bin2hex">bin2hex</a></code>)
and ncount() for the times the models have been drawn.<br /> All these vectors
are sorted descendantly by <code>lik</code>, and are of the same length. The
maximum length is limited by the argument <code>nbmodels</code>.
</p>
<p>If <code>tmo</code> is a topmod object, then a call to <code>tmo$addmodel</code> (e.g.
<code>tmo$addmodel(mylik=4,vec01=c(T,F,F,T))</code> updates the object <code>tmo</code>
by a model represented by <code>vec01</code> (here the one including the first and
fourth regressor) and the marginal (log) likelihood <code>lik</code> (here: 4).<br />
If this model is already part of <code>tmo</code>, then its respective
<code>ncount</code> entry is incremented by one; else it is inserted into a
position according to the ranking of <code>lik</code>.<br /> In addition, there is
the possibility to save (the first moments of) coefficients of a model
(<code>betas</code>) and their second moments (<code>betas2</code>), as well as an
arbitrary vector of statistics per model (<code>fixed_vector</code>).<br />
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher and Stefan Zeugner
</p>


<h3>References</h3>

<p><a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topmod">topmod</a></code> to create <code>topmod</code> objects and a more
detailed description,
<code><a href="#topic+is.topmod">is.topmod</a></code> to test for this class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  tm= topmod(2,4,TRUE,0) #should keep a  maximum two models
  tm$addmodel(-2.3,c(1,1,1,1),1:4,5:8) #update with some model
  tm$addmodel(-2.2,c(0,1,1,1),1:3,5:7) #add another model
  tm$addmodel(-2.2,c(0,1,1,1),1:3,5:7) #add it again -&gt; adjust ncount
  tm$addmodel(-2.5,c(1,0,0,1),1:2,5:6) #add another model
  
  #read out
  tm$lik()
  tm$ncount()
  tm$bool_binary()
  tm$betas()

</code></pre>

<hr>
<h2 id='topmodels.bma'>Model Binaries and their Posterior model Probabilities</h2><span id='topic+topmodels.bma'></span>

<h3>Description</h3>

<p>Returns a matrix whose columns show which covariates were included in the best models in a 'bma' object. The last two columns detail posterior model probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topmodels.bma(bmao)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topmodels.bma_+3A_bmao">bmao</code></td>
<td>
<p>an object of class 'bma' - see <code><a href="#topic+bma-class">bma-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each bma class (the result of bms) contains 'top models', the x models with tthe best 
analytical likelihood  that bms had encountered while sampling
</p>
<p>See <code><a href="#topic+pmp.bma">pmp.bma</a></code> for an explanation of likelihood vs. MCMC
frequency concepts
</p>


<h3>Value</h3>

<p>Each column in the resulting matrix corresponds to one of the 'best' models in bmao: the first column for the best model, the second for the second-best model, etc.
The model binaries have elements 1 if the regressor given by the row name was included in the respective models, and 0 otherwise.
The second-last row shows the model's posterior model probability based on marginal likelihoods (i.e. its marginal likelihood over the sum of likelihoods of all best models)
The last row shows the model's posterior model probability based on MCMC frequencies (i.e. how often the model was accepted vs sum of acceptance of all models) 
Note that the column names are hexcode representations of the model binaries (e.g. &quot;03&quot; for c(0,0,0,1,0,0))
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topmod">topmod</a></code> for creating topmod objects, <code><a href="#topic+bms">bms</a></code>
for their typical use, <code><a href="#topic+pmp.bma">pmp.bma</a></code> for comparing posterior model
probabilities
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datafls)
#sample with a limited data set for demonstration
mm=bms(datafls[,1:12],nmodel=20)

#show binaries for all
topmodels.bma(mm)

#show binaries for 2nd and 3rd best model, without the model probs
topmodels.bma(mm[2:3])[1:11,]

#access model binaries directly
mm$topmod$bool_binary()
 
</code></pre>

<hr>
<h2 id='variable.names.bma'>Variable names and design matrix</h2><span id='topic+variable.names.bma'></span><span id='topic+model.frame.bma'></span>

<h3>Description</h3>

<p>Simple utilities retrieving variable names and design matrix from a bma
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bma'
variable.names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variable.names.bma_+3A_object">object</code></td>
<td>
<p>A <code>bma</code> object (as produced by <code><a href="#topic+bms">bms</a></code>)</p>
</td></tr>
<tr><td><code id="variable.names.bma_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions are <code>bma</code>-functions for the generic methods
<code><a href="stats.html#topic+variable.names">variable.names</a></code>, <code><a href="stats.html#topic+deviance">deviance</a></code>, and
<code><a href="stats.html#topic+model.frame">model.frame</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bms">bms</a></code> for creating bma objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
 bma_enum=bms(datafls[1:20,1:10])
 
 model.frame(bma_enum) # similar to 
 bma_enum$arguments$X.data
 
 variable.names(bma_enum)[-1] # is equivalent to
 bma_enum$reg.names
 
</code></pre>

<hr>
<h2 id='variable.names.zlm'>Variable names and design matrix</h2><span id='topic+variable.names.zlm'></span><span id='topic+vcov.zlm'></span><span id='topic+logLik.zlm'></span>

<h3>Description</h3>

<p>Simple utilities retrieving variable names and design matrix from a bma
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
variable.names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variable.names.zlm_+3A_object">object</code></td>
<td>
<p>A <code>bma</code> object (as produced by <code><a href="#topic+bms">bms</a></code>)</p>
</td></tr>
<tr><td><code id="variable.names.zlm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>variable.names.zlm</code>: method <code><a href="stats.html#topic+variable.names">variable.names</a></code> for a
<code><a href="#topic+zlm">zlm</a></code> model. <br /> <code>vcov.zlm</code>: the posterior
variance-covariance matrix of the coefficients of a <code><a href="#topic+zlm">zlm</a></code> model
- cf. <code><a href="stats.html#topic+vcov">vcov</a></code> <br /> <code>logLik.zlm</code>: a <code><a href="#topic+zlm">zlm</a></code> model's
log-likelihood <code>p(y|M)</code> according to the implementation of the
respective coefficent prior <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zlm">zlm</a></code> for creating <code>zlm</code> objects
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(datafls)
  
 zz=zlm(datafls)
 variable.names(zz)
 vcov(zz)
 logLik(zz)
 
</code></pre>

<hr>
<h2 id='zlm'>Bayesian Linear Model with Zellner's g</h2><span id='topic+zlm'></span>

<h3>Description</h3>

<p>Used to fit the Bayesian normal-conjugate linear model with Zellner's g
prior and mean zero coefficient priors. Provides an object similar to the
<code><a href="stats.html#topic+lm">lm</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zlm(formula, data = NULL, subset = NULL, g = "UIP")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zlm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to
that class), such as a data.frame - cf. <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="zlm_+3A_data">data</code></td>
<td>
<p>an optional <code><a href="base.html#topic+data.frame">data.frame</a></code> (or one that can be coerced
to that class): cf. <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="zlm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="zlm_+3A_g">g</code></td>
<td>
<p>specifies the hyperparameter on Zellner's g-prior for the
regression coefficients.<br /> <code>g="UIP"</code> corresponds to <code class="reqn">g=N</code>, the
number of observations (default); <code>g="BRIC"</code> corresponds to the
benchmark prior suggested by Fernandez, Ley and Steel (2001), i.e
<code class="reqn">g=max(N, K^2)</code>, where K is the total number of covariates;<br />
<code>g="EBL"</code> estimates a local empirical Bayes g-parameter (as in Liang et
al. (2008));<br /> <code>g="hyper"</code> takes the 'hyper-g' prior distribution (as
in Liang et al., 2008) with the default hyper-parameter <code class="reqn">a=3</code>; This
hyperparameter can be adjusted (between <code class="reqn">2&lt;a&lt;=4</code>) by setting
<code>g="hyper=2.9"</code>, for instance.<br /> Alternatively, <code>g="hyper=UIP"</code>
sets the prior expected value of the shrinkage factor equal to that of UIP
(above), <code>g="hyper=BRIC"</code> sets it according to BRIC</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zlm</code> estimates the coefficients of the following model <code class="reqn">y = \alpha
+ X \beta + \epsilon</code> where <code class="reqn">\epsilon</code> ~ <code class="reqn">N(0,\sigma^2)</code> and <code class="reqn">X</code>
is the design matrix<br /> The priors on the intercept <code class="reqn">\alpha</code> and the
variance <code class="reqn">\sigma</code> are improper: <code class="reqn">alpha \propto 1</code>, <code class="reqn">sigma
\propto \sigma^{-1}</code> <br /> Zellner's g affects the prior on coefficients:
<code class="reqn">beta</code> ~ <code class="reqn">N(0, \sigma^2 g (X'X)^{-1})</code>. <br /> Note that the prior mean
of coefficients is set to zero by default and cannot be adjusted. Note
moreover that <code>zlm</code> always includes an intercept.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>zlm</code> that contains at least the
following elements (cf. <code><a href="stats.html#topic+lm">lm</a></code>):
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of posterior coefficient expected values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values</p>
</td></tr> <tr><td><code>rank</code></td>
<td>
<p>the numeric rank of
the fitted linear model</p>
</td></tr> <tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr> <tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object
used</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>the model frame used</p>
</td></tr> <tr><td><code>coef2moments</code></td>
<td>
<p>a named vector
of coefficient posterior second moments</p>
</td></tr> <tr><td><code>marg.lik</code></td>
<td>
<p>the log marginal
likelihood of the model</p>
</td></tr> <tr><td><code>gprior.info</code></td>
<td>
<p>a list detailing information on
the g-prior, cf. output value <code>gprior.info</code> in <code><a href="#topic+bms">bms</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Zeugner
</p>


<h3>References</h3>

<p>The representation follows Fernandez, C. E. Ley and M. Steel
(2001): Benchmark priors for Bayesian model averaging. Journal of
Econometrics 100(2), 381&ndash;427
</p>
<p>See also <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>See Also</h3>

<p>The methods <code><a href="#topic+summary.zlm">summary.zlm</a></code> and <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>
provide additional insights into <code>zlm</code> output.<br /> The function
<code><a href="#topic+as.zlm">as.zlm</a></code> extracts a single out model of a <code>bma</code> object (as
e.g. created through<code><a href="#topic+bms">bms</a></code>).<br /> Moreover, <code><a href="stats.html#topic+lm">lm</a></code> for
the standard OLS object, <code><a href="#topic+bms">bms</a></code> for the application of <code>zlm</code>
in Bayesian model averaging.
</p>
<p>Check <a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a> for additional help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(datafls)

#simple example
foo = zlm(datafls)
summary(foo)

#example with formula and subset
foo2 = zlm(y~GDP60+LifeExp, data=datafls, subset=2:70) #basic model, omitting three countries
summary(foo2)


</code></pre>

<hr>
<h2 id='zlm-class'>Class &quot;zlm&quot;</h2><span id='topic+zlm-class'></span>

<h3>Description</h3>

<p>A list holding output from the Bayesian Linar Model under Zellner's g prior
akin to class 'lm'
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created via calls to
<code><a href="#topic+zlm">zlm</a></code>, but indirectly also via <code><a href="#topic+as.zlm">as.zlm</a></code>.<br />
<code><a href="#topic+zlm">zlm</a></code> estimates a Bayesian Linear Model under Zellner's g prior
- its output is very similar to objects of class <code><a href="stats.html#topic+lm">lm</a></code> (cf.
section 'Value')
</p>


<h3>Author(s)</h3>

<p>Martin Feldkircher and Stefan Zeugner
</p>


<h3>References</h3>

<p><a href="http://bms.zeugner.eu">http://bms.zeugner.eu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zlm">zlm</a></code> and <code><a href="#topic+as.zlm">as.zlm</a></code> for creating <code>zlm</code>
objects,<br /> <code><a href="#topic+density.zlm">density.zlm</a></code>, <code><a href="#topic+predict.zlm">predict.zlm</a></code> and
<code><a href="#topic+summary.zlm">summary.zlm</a></code> for other posterior results
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
