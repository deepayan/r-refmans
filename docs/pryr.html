<!DOCTYPE html><html lang="en"><head><title>Help for package pryr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pryr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26lt+3Ba-+25'><p>Create an active binding.</p></a></li>
<li><a href='#+25+26lt+3Bc-+25'><p>Create a constant (locked) binding.</p></a></li>
<li><a href='#+25+26lt+3Bd-+25'><p>Create an delayed binding.</p></a></li>
<li><a href='#as.envlist'><p>Convert a list of environments to an <code>envlist</code> object.</p></a></li>
<li><a href='#bytes'><p>Print the byte-wise representation of a value</p></a></li>
<li><a href='#call_tree'><p>Display a call (or expression) as a tree.</p></a></li>
<li><a href='#compose'><p>Compose multiple functions</p></a></li>
<li><a href='#dots'><p>Capture unevaluated dots.</p></a></li>
<li><a href='#enclosing_env'><p>Find the environment that encloses of a function.</p></a></li>
<li><a href='#explicit'><p>Tools for making promises explicit</p></a></li>
<li><a href='#f'><p>A compact syntax for anonymous functions.</p></a></li>
<li><a href='#fget'><p>Find a function with specified name.</p></a></li>
<li><a href='#find_funs'><p>Find functions matching criteria.</p></a></li>
<li><a href='#find_uses'><p>Find all functions in that call supplied functions.</p></a></li>
<li><a href='#ftype'><p>Determine function type.</p></a></li>
<li><a href='#is_active_binding'><p>Active binding info</p></a></li>
<li><a href='#is_promise'><p>Promise info</p></a></li>
<li><a href='#is_s3_generic'><p>Determine if a function is an S3 generic or S3 method.</p></a></li>
<li><a href='#make_call'><p>Make and evaluate calls.</p></a></li>
<li><a href='#make_function'><p>Make a function from its components.</p></a></li>
<li><a href='#mem_change'><p>Determine change in memory from running code</p></a></li>
<li><a href='#mem_used'><p>How much memory is currently used by R?</p></a></li>
<li><a href='#method_from_call'><p>Given a function class, find correspoding S4 method</p></a></li>
<li><a href='#modify_call'><p>Modify the arguments of a call.</p></a></li>
<li><a href='#modify_lang'><p>Recursively modify a language object</p></a></li>
<li><a href='#names_c'><p>Extract function table from names.c from R subversion repository.</p></a></li>
<li><a href='#object_size'><p>Compute the size of an object.</p></a></li>
<li><a href='#otype'><p>Determine object type.</p></a></li>
<li><a href='#parent_promise'><p>Find the parent (first) promise.</p></a></li>
<li><a href='#parenv'><p>Get parent/ancestor environment</p></a></li>
<li><a href='#parenvs'><p>Given an environment or object, return an <code>envlist</code> of its</p>
parent environments.</a></li>
<li><a href='#partial'><p>Partial apply a function, filling in some arguments.</p></a></li>
<li><a href='#print.envlist'><p>Print an <code>envlist</code></p></a></li>
<li><a href='#rebind'><p>Rebind an existing name.</p></a></li>
<li><a href='#rls'><p>Recursive ls.</p></a></li>
<li><a href='#sexp_type'><p>Inspect internal attributes of R objects.</p></a></li>
<li><a href='#show_c_source'><p>Find C source code for internal R functions</p></a></li>
<li><a href='#standardise_call'><p>Standardise a function call</p></a></li>
<li><a href='#subs'><p>A version of substitute that works in the global environment.</p></a></li>
<li><a href='#substitute_q'><p>A version of substitute that evaluates its first argument.</p></a></li>
<li><a href='#track_copy'><p>Track if an object is copied</p></a></li>
<li><a href='#unenclose'><p>Unenclose a closure.</p></a></li>
<li><a href='#uneval'><p>Capture the call associated with a promise.</p></a></li>
<li><a href='#where'><p>Find where a name is defined.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Computing on the Language</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful tools to pry back the covers of R and understand the
    language at a deeper level.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hadley/pryr">https://github.com/hadley/pryr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hadley/pryr/issues">https://github.com/hadley/pryr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>codetools, lobstr, methods, Rcpp (&ge; 0.11.0), stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.8.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-17 15:08:08 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  R Core team [ctb] (Some code extracted from base R)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-17 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26lt+3Ba-+25'>Create an active binding.</h2><span id='topic++25+3Ca-+25'></span>

<h3>Description</h3>

<p>Infix form of <code><a href="base.html#topic+makeActiveBinding">makeActiveBinding</a></code> which creates an <em>active</em>
binding between a name and an expression: every time the name is accessed
the expression is recomputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;a-% value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3Ba-+2B25_+3A_x">x</code></td>
<td>
<p>unquoted expression naming variable to create</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3Ba-+2B25_+3A_value">value</code></td>
<td>
<p>unquoted expression to evaluate every time <code>name</code> is
accessed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x %&lt;a-% runif(1)
x
x
x %&lt;a-% runif(10)
x
x
rm(x)
</code></pre>

<hr>
<h2 id='+25+26lt+3Bc-+25'>Create a constant (locked) binding.</h2><span id='topic++25+3Cc-+25'></span>

<h3>Description</h3>

<p>Infix wrapper for <code><a href="base.html#topic+assign">assign</a></code> + <code><a href="base.html#topic+lockBinding">lockBinding</a></code> that
creates a constant: a binding whose value can not be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;c-% value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3Bc-+2B25_+3A_x">x</code></td>
<td>
<p>unquoted expression naming variable to create</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3Bc-+2B25_+3A_value">value</code></td>
<td>
<p>constant value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x %&lt;c-% 10
#' Generates an error:
## Not run: x &lt;- 20

# Note that because of R's operator precedence rules, you
# need to wrap compound RHS expressions in ()
y %&lt;c-% 1 + 2
y
z %&lt;c-% (1 + 2)
z
</code></pre>

<hr>
<h2 id='+25+26lt+3Bd-+25'>Create an delayed binding.</h2><span id='topic++25+3Cd-+25'></span>

<h3>Description</h3>

<p>Infix form of <code><a href="base.html#topic+delayedAssign">delayedAssign</a></code> which creates an <em>delayed</em>
or lazy binding, which only evaluates the expression the first time it is
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;d-% value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26lt+2B3Bd-+2B25_+3A_x">x</code></td>
<td>
<p>unquoted expression naming variable to create</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3Bd-+2B25_+3A_value">value</code></td>
<td>
<p>unquoted expression to evaluate the first time <code>name</code> is
accessed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x %&lt;d-% (a + b)
a &lt;- 10
b &lt;- 100
x
</code></pre>

<hr>
<h2 id='as.envlist'>Convert a list of environments to an <code>envlist</code> object.</h2><span id='topic+as.envlist'></span>

<h3>Description</h3>

<p>Convert a list of environments to an <code>envlist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.envlist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.envlist_+3A_x">x</code></td>
<td>
<p>A list of environments.</p>
</td></tr>
</table>

<hr>
<h2 id='bytes'>Print the byte-wise representation of a value</h2><span id='topic+bytes'></span><span id='topic+bits'></span>

<h3>Description</h3>

<p>Print the byte-wise representation of a value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bytes(x, split = TRUE)

bits(x, split = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bytes_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> vector of type <code>integer</code>, <code>numeric</code>, <code>logical</code>
or <code>character</code>.</p>
</td></tr>
<tr><td><code id="bytes_+3A_split">split</code></td>
<td>
<p>Whether we should split the output string at each byte.</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two's_complement</a> for more
information on the representation used for <code>int</code>s.
</p>
<p><a href="https://en.wikipedia.org/wiki/IEEE_floating_point">https://en.wikipedia.org/wiki/IEEE_floating_point</a> for more
information the floating-point representation used for <code>double</code>s.
</p>
<p><a href="https://en.wikipedia.org/wiki/Character_encoding">https://en.wikipedia.org/wiki/Character_encoding</a> for an introduction
to character encoding, and <code>?<a href="base.html#topic+Encoding">Encoding</a></code> for more information on
how <span class="rlang"><b>R</b></span> handles character encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Encoding doesn't change the internal bytes used to represent characters;
## it just changes how they are interpretted!

x &lt;- y &lt;- z &lt;- "\u9b3c"
Encoding(y) &lt;- "bytes"
Encoding(z) &lt;- "latin1"
print(x); print(y); print(z)
bytes(x); bytes(y); bytes(z)
bits(x); bits(y); bits(z)

## In R, integers are signed ints. The first bit indicates the sign, but
## values are stored in a two's complement representation. We see that
## NA_integer_ is really just the smallest negative integer that can be
## stored in 4 bytes
bits(NA_integer_)

## There are multiple kinds of NAs, NaNs for real numbers
## (at least, on 64bit architectures)
print( c(NA_real_, NA_real_ + 1) )
rbind( bytes(NA_real_), bytes(NA_real_ + 1) )
rbind( bytes(NaN), bytes(0/0) )
</code></pre>

<hr>
<h2 id='call_tree'>Display a call (or expression) as a tree.</h2><span id='topic+call_tree'></span><span id='topic+ast'></span>

<h3>Description</h3>

<p><code>call_tree</code> takes a quoted expression. <code>ast</code> does the quoting
for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_tree(x, width = getOption("width"))

ast(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call_tree_+3A_x">x</code></td>
<td>
<p>quoted call, list of calls, or expression to display</p>
</td></tr>
<tr><td><code id="call_tree_+3A_width">width</code></td>
<td>
<p>displays width, defaults to current width as reported by
<code>getOption("width")</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>call_tree(quote(f(x, 1, g(), h(i()))))
call_tree(quote(if (TRUE) 3 else 4))
call_tree(expression(1, 2, 3))

ast(f(x, 1, g(), h(i())))
ast(if (TRUE) 3 else 4)
ast(function(a = 1, b = 2) {a + b})
ast(f()()())
</code></pre>

<hr>
<h2 id='compose'>Compose multiple functions</h2><span id='topic+compose'></span><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>In infix and prefix forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose(...)

f %.% g
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compose_+3A_...">...</code></td>
<td>
<p>n functions to apply in order from right to left</p>
</td></tr>
<tr><td><code id="compose_+3A_f">f</code>, <code id="compose_+3A_g">g</code></td>
<td>
<p>two functions to compose for the infix form</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>not_null &lt;- `!` %.% is.null
not_null(4)
not_null(NULL)

add1 &lt;- function(x) x + 1
compose(add1,add1)(8)
</code></pre>

<hr>
<h2 id='dots'>Capture unevaluated dots.</h2><span id='topic+dots'></span><span id='topic+named_dots'></span>

<h3>Description</h3>

<p>Capture unevaluated dots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots(...)

named_dots(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dots_+3A_...">...</code></td>
<td>
<p><code>...</code> passed in to the parent function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of expressions (not expression objects). <code>named_dots</code>
will use the deparsed expressions as default names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- 2
str(dots(x = 1, y, z = ))
str(named_dots(x = 1, y, z =))
</code></pre>

<hr>
<h2 id='enclosing_env'>Find the environment that encloses of a function.</h2><span id='topic+enclosing_env'></span>

<h3>Description</h3>

<p>This is a wrapper around <code><a href="base.html#topic+environment">environment</a></code> with a
consistent syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enclosing_env(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enclosing_env_+3A_f">f</code></td>
<td>
<p>The name of a function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>enclosing_env("plot")
enclosing_env("t.test")
</code></pre>

<hr>
<h2 id='explicit'>Tools for making promises explicit</h2><span id='topic+explicit'></span><span id='topic+eval2'></span>

<h3>Description</h3>

<p>Deprecated: please use the lazyeval package instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explicit(x)

eval2(x, data = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explicit_+3A_x">x</code></td>
<td>
<p>expression to make explicit, or to evaluate.</p>
</td></tr>
<tr><td><code id="explicit_+3A_data">data</code></td>
<td>
<p>Data in which to evaluate code</p>
</td></tr>
<tr><td><code id="explicit_+3A_env">env</code></td>
<td>
<p>Enclosing environment to use if data is a list or data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='f'>A compact syntax for anonymous functions.</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>A compact syntax for anonymous functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(..., .env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_+3A_...">...</code></td>
<td>
<p>The last argument is the body of the function, all others are
arguments to the function.  If there is only one argument, the formals
are guessed from the code.</p>
</td></tr>
<tr><td><code id="f_+3A_.env">.env</code></td>
<td>
<p>parent environment of the created function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f(x + y)
f(x + y)(1, 10)
f(x, y = 2, x + y)

f({y &lt;- runif(1); x + y})
</code></pre>

<hr>
<h2 id='fget'>Find a function with specified name.</h2><span id='topic+fget'></span>

<h3>Description</h3>

<p>Find a function with specified name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fget(name, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fget_+3A_name">name</code></td>
<td>
<p>length one character vector giving name</p>
</td></tr>
<tr><td><code id="fget_+3A_env">env</code></td>
<td>
<p>environment to start search in.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>c &lt;- 10
fget("c")
</code></pre>

<hr>
<h2 id='find_funs'>Find functions matching criteria.</h2><span id='topic+find_funs'></span><span id='topic+fun_calls'></span><span id='topic+fun_args'></span><span id='topic+fun_body'></span>

<h3>Description</h3>

<p>This is a flexible function that matches function component against
a regular expression, returning the name of the function if there are any
matches. <code>fun_args</code> and <code>fun_calls</code> are helper functions that
make it possible to search for functions with specified argument names, or
which call certain functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_funs(env = parent.frame(), extract, pattern, ...)

fun_calls(f)

fun_args(f)

fun_body(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_funs_+3A_env">env</code></td>
<td>
<p>environment in which to search for functions</p>
</td></tr>
<tr><td><code id="find_funs_+3A_extract">extract</code></td>
<td>
<p>component of function to extract. Should be a function that
takes a function as input as returns a character vector as output,
like <code>fun_calls</code> or <code>fun_args</code>.</p>
</td></tr>
<tr><td><code id="find_funs_+3A_pattern">pattern</code></td>
<td>
<p><span class="pkg">stringr</span> regular expression to results of <code>extract</code>
function.</p>
</td></tr>
<tr><td><code id="find_funs_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="base.html#topic+grepl">grepl</a></code></p>
</td></tr>
<tr><td><code id="find_funs_+3A_f">f</code></td>
<td>
<p>function to extract information from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>find_funs("package:base", fun_calls, "match.fun", fixed = TRUE)
find_funs("package:stats", fun_args, "^[A-Z]+$")

fun_calls(match.call)
fun_calls(write.csv)

fun_body(write.csv)
find_funs("package:utils", fun_body, "write", fixed = TRUE)
</code></pre>

<hr>
<h2 id='find_uses'>Find all functions in that call supplied functions.</h2><span id='topic+find_uses'></span>

<h3>Description</h3>

<p>Find all functions in that call supplied functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_uses(envs, funs, match_any = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_uses_+3A_envs">envs</code></td>
<td>
<p>Vector of environments to look in. Can be specified by
name, position or as environment</p>
</td></tr>
<tr><td><code id="find_uses_+3A_funs">funs</code></td>
<td>
<p>Functions to look for</p>
</td></tr>
<tr><td><code id="find_uses_+3A_match_any">match_any</code></td>
<td>
<p>If <code>TRUE</code> return functions that use any of <code>funs</code>.
If <code>FALSE</code>, return functions that use all of <code>funs</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>names(find_uses("package:base", "sum"))

envs &lt;- c("package:base", "package:utils", "package:stats")
funs &lt;- c("match.call", "sys.call")
find_uses(envs, funs)
</code></pre>

<hr>
<h2 id='ftype'>Determine function type.</h2><span id='topic+ftype'></span>

<h3>Description</h3>

<p>This function figures out whether the input function is a 
regular/primitive/internal function, a internal/S3/S4 generic, or a 
S3/S4/RC method. This is function is slightly simplified as it's possible
for a method from one class to be a generic for another class, but that
seems like such a bad idea that hopefully no one has done it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftype(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ftype_+3A_f">f</code></td>
<td>
<p>unquoted function name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character of vector of length 1 or 2.
</p>


<h3>See Also</h3>

<p>Other object inspection: 
<code><a href="#topic+otype">otype</a>()</code>,
<code><a href="#topic+sexp_type">sexp_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ftype(`%in%`)
ftype(sum)
ftype(t.data.frame)
ftype(t.test) # Tricky!
ftype(writeLines)
ftype(unlist)
</code></pre>

<hr>
<h2 id='is_active_binding'>Active binding info</h2><span id='topic+is_active_binding'></span>

<h3>Description</h3>

<p>Active binding info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_active_binding(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_active_binding_+3A_x">x</code></td>
<td>
<p>unquoted object name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 10
is_active_binding(x)
x %&lt;a-% runif(1)
is_active_binding(x)
y &lt;- x
is_active_binding(y)
</code></pre>

<hr>
<h2 id='is_promise'>Promise info</h2><span id='topic+is_promise'></span><span id='topic+promise_info'></span>

<h3>Description</h3>

<p>Promise info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_promise(x)

promise_info(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_promise_+3A_x">x</code></td>
<td>
<p>unquoted object name</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other promise tools: 
<code><a href="#topic+uneval">uneval</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 10
is_promise(x)
(function(x) is_promise(x))(x = 10)
</code></pre>

<hr>
<h2 id='is_s3_generic'>Determine if a function is an S3 generic or S3 method.</h2><span id='topic+is_s3_generic'></span><span id='topic+is_s3_method'></span>

<h3>Description</h3>

<p><code>is_s3_generic</code> compares name checks for both internal and regular
generics.
</p>
<p><code>is_s3_method</code> builds names of all possible generics for that function
and then checks if any of them actually is a generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_s3_generic(fname, env = parent.frame())

is_s3_method(name, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_s3_generic_+3A_env">env</code></td>
<td>
<p>environment to search in.</p>
</td></tr>
<tr><td><code id="is_s3_generic_+3A_name">name</code></td>
<td>
<p>name of function as a string. Need name of function because
it's impossible to determine whether or not a function is a S3 method
based only on its contents.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_s3_generic("mean")
is_s3_generic("sum")
is_s3_generic("[[")
is_s3_generic("unlist")
is_s3_generic("runif")

is_s3_method("t.data.frame")
is_s3_method("t.test") # Just tricking!
is_s3_method("as.data.frame")
is_s3_method("mean.Date")
</code></pre>

<hr>
<h2 id='make_call'>Make and evaluate calls.</h2><span id='topic+make_call'></span><span id='topic+do_call'></span>

<h3>Description</h3>

<p>Make and evaluate calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_call(f, ..., .args = list())

do_call(f, ..., .args = list(), .env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_call_+3A_f">f</code></td>
<td>
<p>Function to call. For <code>make_call</code>, either a string, a symbol
or a quoted call. For <code>do_call</code>, a bare function name or call.</p>
</td></tr>
<tr><td><code id="make_call_+3A_...">...</code>, <code id="make_call_+3A_.args">.args</code></td>
<td>
<p>Arguments to the call either in or out of a list</p>
</td></tr>
<tr><td><code id="make_call_+3A_.env">.env</code></td>
<td>
<p>Environment in which to evaluate call. Defaults to parent frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># f can either be a string, a symbol or a call
make_call("f", a = 1)
make_call(quote(f), a = 1)
make_call(quote(f()), a = 1)

#' Can supply arguments individual or in a list
make_call(quote(f), a = 1, b = 2)
make_call(quote(f), list(a = 1, b = 2))
</code></pre>

<hr>
<h2 id='make_function'>Make a function from its components.</h2><span id='topic+make_function'></span>

<h3>Description</h3>

<p>This constructs a new function given it's three components:
list of arguments, body code and parent environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_function(args, body, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_function_+3A_args">args</code></td>
<td>
<p>A named list of default arguments.  Note that if you want
arguments that don't have defaults, you'll need to use the special function
<code><a href="base.html#topic+alist">alist</a></code>, e.g. <code>alist(a = , b = 1)</code></p>
</td></tr>
<tr><td><code id="make_function_+3A_body">body</code></td>
<td>
<p>A language object representing the code inside the function.
Usually this will be most easily generated with <code><a href="base.html#topic+quote">quote</a></code></p>
</td></tr>
<tr><td><code id="make_function_+3A_env">env</code></td>
<td>
<p>The parent environment of the function, defaults to the calling
environment of <code>make_function</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x + 3
g &lt;- make_function(alist(x = ), quote(x + 3))

# The components of the functions are identical
identical(formals(f), formals(g))
identical(body(f), body(g))
identical(environment(f), environment(g))

# But the functions are not identical because f has src code reference
identical(f, g)

attr(f, "srcref") &lt;- NULL
# Now they are:
stopifnot(identical(f, g))
</code></pre>

<hr>
<h2 id='mem_change'>Determine change in memory from running code</h2><span id='topic+mem_change'></span>

<h3>Description</h3>

<p>Determine change in memory from running code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem_change(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mem_change_+3A_code">code</code></td>
<td>
<p>Code to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Change in memory (in megabytes) before and after running code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Need about 4 mb to store 1 million integers
mem_change(x &lt;- 1:1e6)
# We get that memory back when we delete it
mem_change(rm(x))
</code></pre>

<hr>
<h2 id='mem_used'>How much memory is currently used by R?</h2><span id='topic+mem_used'></span>

<h3>Description</h3>

<p>R breaks down memory usage into Vcells (memory used by vectors) and
Ncells (memory used by everything else). However, neither this distinction
nor the &quot;gc trigger&quot; and &quot;max used&quot; columns are typically important. What
we're usually most interested in is the the first column: the total memory
used. This function wraps around <code>gc()</code> to return the total amount of
memory (in megabytes) currently used by R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem_used()
</code></pre>


<h3>Value</h3>

<p>Megabytes of ram used by R objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mem_used()
</code></pre>

<hr>
<h2 id='method_from_call'>Given a function class, find correspoding S4 method</h2><span id='topic+method_from_call'></span>

<h3>Description</h3>

<p>Given a function class, find correspoding S4 method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_from_call(call, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_from_call_+3A_call">call</code></td>
<td>
<p>unquoted function call</p>
</td></tr>
<tr><td><code id="method_from_call_+3A_env">env</code></td>
<td>
<p>environment in which to look for function definition</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(stats4)

# From example(mle)
y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
nLL &lt;- function(lambda) -sum(dpois(y, lambda, log = TRUE))
fit &lt;- mle(nLL, start = list(lambda = 5), nobs = length(y))

method_from_call(summary(fit))
method_from_call(coef(fit))
method_from_call(length(fit))
</code></pre>

<hr>
<h2 id='modify_call'>Modify the arguments of a call.</h2><span id='topic+modify_call'></span>

<h3>Description</h3>

<p>Modify the arguments of a call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_call(call, new_args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_call_+3A_call">call</code></td>
<td>
<p>A call to modify. It is first standardised with
<code><a href="#topic+standardise_call">standardise_call</a></code>.</p>
</td></tr>
<tr><td><code id="modify_call_+3A_new_args">new_args</code></td>
<td>
<p>A named list of expressions (constants, names or calls)
used to modify the call. Use <code>NULL</code> to remove arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>call &lt;- quote(mean(x, na.rm = TRUE))

# Modify an existing argument
modify_call(call, list(na.rm = FALSE))
modify_call(call, list(x = quote(y)))

# Remove an argument
modify_call(call, list(na.rm = NULL))

# Add a new argument
modify_call(call, list(trim = 0.1))

# Add an explicit missing argument
modify_call(call, list(na.rm = quote(expr = )))
</code></pre>

<hr>
<h2 id='modify_lang'>Recursively modify a language object</h2><span id='topic+modify_lang'></span>

<h3>Description</h3>

<p>Recursively modify a language object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_lang(x, f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_lang_+3A_x">x</code></td>
<td>
<p>object to modify: should be a call, expression, function or
list of the above.</p>
</td></tr>
<tr><td><code id="modify_lang_+3A_f">f</code></td>
<td>
<p>function to apply to leaves</p>
</td></tr>
<tr><td><code id="modify_lang_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>f</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a_to_b &lt;- function(x) {
  if (is.name(x) &amp;&amp; identical(x, quote(a))) return(quote(b))
  x
}
examples &lt;- list(
  quote(a &lt;- 5),
  alist(a = 1, c = a),
  function(a = 1) a * 10,
  expression(a &lt;- 1, a, f(a), f(a = a))
)
modify_lang(examples, a_to_b)
# Modifies all objects called a, but doesn't modify arguments named a
</code></pre>

<hr>
<h2 id='names_c'>Extract function table from names.c from R subversion repository.</h2><span id='topic+names_c'></span>

<h3>Description</h3>

<p>Since this is an expensive operation, it is done once and cached within
a session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names_c()
</code></pre>


<h3>Value</h3>

<p>A data frame with columns
</p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p>the function name in R</p>
</td></tr>
<tr><td><code>c-entry</code></td>
<td>
<p>The name of the corresponding C function, actually declared
in ../include/Internal.h. All start with &quot;do_&quot;, return SEXP, and
have argument list (SEXP call, SEXP op, SEXP args, SEXP env)</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the 'op' (offset pointer) above; used for C functions
which deal with more than one R function</p>
</td></tr>
<tr><td><code>eval</code></td>
<td>
<p>XYZ (three digits) <br />
<br />
X=0 says that we should force R_Visible on <br />
X=1 says that we should force R_Visible off <br />
X=2 says that we should switch R_Visible on but let the C code update it. <br />
<br />
Y=1 says that this is an internal function which must
be accessed with a	.Internal(.) call, any other value is
accessible directly and printed in R as &quot;.Primitive(..)&quot;.<br />
<br />
Z=0 says don't evaluate (SPECIALSXP).<br />
Z=1 says evaluate arguments before calling (BUILTINSXP)</p>
</td></tr>
<tr><td><code>arity</code></td>
<td>
<p>How many arguments are required/allowed;  &quot;-1&quot;	meaning &ldquo;any&rdquo;</p>
</td></tr>
<tr><td><code>pp-kind</code></td>
<td>
<p>Deparsing Info (-&gt; PPkind in ../include/Defn.h )</p>
</td></tr>
<tr><td><code>precedence</code></td>
<td>
<p>Operator precedence (-&gt; PPprec in ../include/Defn.h )</p>
</td></tr>
<tr><td><code>rightassoc</code></td>
<td>
<p>Right or left associative operator</p>
</td></tr>
</table>

<hr>
<h2 id='object_size'>Compute the size of an object.</h2><span id='topic+object_size'></span><span id='topic+compare_size'></span>

<h3>Description</h3>

<p><code>object_size</code> works similarly to <code><a href="utils.html#topic+object.size">object.size</a></code>, but counts
more accurately and includes the size of environments. <code>compare_size</code>
makes it easy to compare the output of <code>object_size</code> and
<code>object.size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_size(..., env = parent.frame())

compare_size(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="object_size_+3A_env">env</code></td>
<td>
<p>Environment in which to terminate search. This defaults to the
current environment so that you don't include the size of objects that
are already stored elsewhere.</p>
</td></tr>
<tr><td><code id="object_size_+3A_x">x</code>, <code id="object_size_+3A_...">...</code></td>
<td>
<p>Set of objects to compute total size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the size of the object, in bytes.
</p>


<h3>Environments</h3>

<p><code>object_size</code> attempts to take into account the size of the
environments associated with an object. This is particularly important
for closures and formulas, since otherwise you may not realise that you've
accidentally captured a large object. However, it's easy to over count:
you don't want to include the size of every object in every environment
leading back to the <code><a href="base.html#topic+emptyenv">emptyenv</a>()</code>. <code>object_size</code> takes
a heuristic approach: it never counts the size of the global env,
the base env, the empty env or any namespace.
</p>
<p>Additionally, the <code>env</code> argument allows you to specify another
environment at which to stop. This defaults to the environment from which
<code>object_size</code> is called to prevent double-counting of objects created
elsewhere.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># object.size doesn't keep track of shared elements in an object
# object_size does
x &lt;- 1:1e4
z &lt;- list(x, x, x)
compare_size(z)

# this means that object_size is not transitive
object_size(x)
object_size(z)
object_size(x, z)

# object.size doesn't include the size of environments, which makes
# it easy to miss objects that are carrying around large environments
f &lt;- function() {
  x &lt;- 1:1e4
  a ~ b
}
compare_size(f())
</code></pre>

<hr>
<h2 id='otype'>Determine object type.</h2><span id='topic+otype'></span>

<h3>Description</h3>

<p>Determine object type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otype(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="otype_+3A_x">x</code></td>
<td>
<p>object to determine type of</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Figure out which object system an object belongs to:
</p>

<ul>
<li><p> base: no class attribute
</p>
</li>
<li><p> S3: class attribute, but not S4
</p>
</li>
<li><p> S4: <code><a href="base.html#topic+isS4">isS4</a></code>, but not RC
</p>
</li>
<li><p> RC: inherits from &quot;refClass&quot;
</p>
</li></ul>



<h3>See Also</h3>

<p>Other object inspection: 
<code><a href="#topic+ftype">ftype</a>()</code>,
<code><a href="#topic+sexp_type">sexp_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>otype(data.frame())
otype(1:10)
</code></pre>

<hr>
<h2 id='parent_promise'>Find the parent (first) promise.</h2><span id='topic+parent_promise'></span>

<h3>Description</h3>

<p>Find the parent (first) promise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parent_promise(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parent_promise_+3A_x">x</code></td>
<td>
<p>unquoted name of promise to find initial value for for.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) g(x)
g &lt;- function(y) h(y)
h &lt;- function(z) parent_promise(z)

h(x + 1)
g(x + 1)
f(x + 1)
</code></pre>

<hr>
<h2 id='parenv'>Get parent/ancestor environment</h2><span id='topic+parenv'></span>

<h3>Description</h3>

<p>Get parent/ancestor environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parenv(env = parent.frame(), n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parenv_+3A_env">env</code></td>
<td>
<p>an environment</p>
</td></tr>
<tr><td><code id="parenv_+3A_n">n</code></td>
<td>
<p>number of parents to go up</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>adder &lt;- function(x) function(y) x + y
add2 &lt;- adder(2)
parenv(add2)
</code></pre>

<hr>
<h2 id='parenvs'>Given an environment or object, return an <code>envlist</code> of its
parent environments.</h2><span id='topic+parenvs'></span>

<h3>Description</h3>

<p>If <code>e</code> is not specified, it will start with environment from which
the function was called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parenvs(e = parent.frame(), all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parenvs_+3A_e">e</code></td>
<td>
<p>An environment or other object.</p>
</td></tr>
<tr><td><code id="parenvs_+3A_all">all</code></td>
<td>
<p>If <code>FALSE</code> (the default), stop at the global
environment or the empty environment. If <code>TRUE</code>, print all
parents, stopping only at the empty environment (which is the
top-level environment).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Print the current environment and its parents
parenvs()

# Print the parent environments of the load_all function
e &lt;- parenvs(parenvs)
e

# Get all parent environments, going all the way to empty env
e &lt;- parenvs(parenvs, TRUE)
e

# Print e with paths
print(e, path = TRUE)

# Print the first 6 environments in the envlist
e[1:6]

# Print just the parent environment of load_all.
# This is an envlist with one element.
e[1]

# Pull that environment out of the envlist and see what's in it.
e[[1]]
ls(e[[1]], all.names = TRUE)
</code></pre>

<hr>
<h2 id='partial'>Partial apply a function, filling in some arguments.</h2><span id='topic+partial'></span>

<h3>Description</h3>

<p>Partial function application allows you to modify a function by pre-filling
some of the arguments.  It is particularly useful in conjunction with
functionals and other function operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial(`_f`, ..., .env = parent.frame(), .lazy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_+3A__f">_f</code></td>
<td>
<p>a function. For the output source to read well, this should be an
be a named function.  This argument has the weird (non-syntactic) name
<code>_f</code> so it doesn't accidentally capture any argument names begining
with f.</p>
</td></tr>
<tr><td><code id="partial_+3A_...">...</code></td>
<td>
<p>named arguments to <code>f</code> that should be partially applied.</p>
</td></tr>
<tr><td><code id="partial_+3A_.env">.env</code></td>
<td>
<p>the environment of the created function. Defaults to
<code><a href="base.html#topic+parent.frame">parent.frame</a></code> and you should rarely need to modify this.</p>
</td></tr>
<tr><td><code id="partial_+3A_.lazy">.lazy</code></td>
<td>
<p>If <code>TRUE</code> arguments evaluated lazily, if <code>FALSE</code>,
evaluated when <code>partial</code> is called.</p>
</td></tr>
</table>


<h3>Design choices</h3>

<p>There are many ways to implement partial function application in R.
(see e.g. <code>dots</code> in <a href="https://github.com/crowding/vadr">https://github.com/crowding/vadr</a> for another
approach.)  This implementation is based on creating functions that are as
similar as possible to the anonymous function that'd you'd create by hand,
if you weren't using <code>partial</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Partial is designed to replace the use of anonymous functions for
# filling in function arguments. Instead of:
compact1 &lt;- function(x) Filter(Negate(is.null), x)

# we can write:
compact2 &lt;- partial(Filter, Negate(is.null))

# and the generated source code is very similar to what we made by hand
compact1
compact2

# Note that the evaluation occurs "lazily" so that arguments will be
# repeatedly evaluated
f &lt;- partial(runif, n = rpois(1, 5))
f
f()
f()

# You can override this by saying .lazy = FALSE
f &lt;- partial(runif, n = rpois(1, 5), .lazy = FALSE)
f
f()
f()

# This also means that partial works fine with functions that do
# non-standard evaluation
my_long_variable &lt;- 1:10
plot2 &lt;- partial(plot, my_long_variable)
plot2()
plot2(runif(10), type = "l")
</code></pre>

<hr>
<h2 id='print.envlist'>Print an <code>envlist</code></h2><span id='topic+print.envlist'></span>

<h3>Description</h3>

<p>Print an <code>envlist</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'envlist'
print(x, name = TRUE, path = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.envlist_+3A_x">x</code></td>
<td>
<p>An <code>envlist</code> object to print.</p>
</td></tr>
<tr><td><code id="print.envlist_+3A_name">name</code></td>
<td>
<p>If <code>TRUE</code> (the default), print the <code>name</code>
attribute of each environment.</p>
</td></tr>
<tr><td><code id="print.envlist_+3A_path">path</code></td>
<td>
<p>If <code>TRUE</code>, print the <code>path</code> attribute of
each environment.</p>
</td></tr>
<tr><td><code id="print.envlist_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>print</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rebind'>Rebind an existing name.</h2><span id='topic+rebind'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="base.html#topic++3C+3C-">&lt;&lt;-</a></code> with two exceptions:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebind(name, value, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rebind_+3A_name">name</code></td>
<td>
<p>name of existing binding to re-assign</p>
</td></tr>
<tr><td><code id="rebind_+3A_value">value</code></td>
<td>
<p>new value</p>
</td></tr>
<tr><td><code id="rebind_+3A_env">env</code></td>
<td>
<p>environment to start search in.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> if no existing binding is found, it throws an error
</p>
</li>
<li><p> it does not recurse past the global environment into the attached
packages
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
rebind("a", 2)
a
# Throws error if no existing binding
## Not run: rebind("b", 2)

local({
  rebind("a", 3)
})
a

# Can't find get because doesn't look past globalenv
## Not run: rebind("get", 1)
</code></pre>

<hr>
<h2 id='rls'>Recursive ls.</h2><span id='topic+rls'></span>

<h3>Description</h3>

<p>Performs <code><a href="base.html#topic+ls">ls</a></code> all the way up to a top-level environment (either
the parent of the global environment, the empty environment or a namespace
environment).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rls(env = parent.frame(), all.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rls_+3A_env">env</code></td>
<td>
<p>environment to start the search at. Defaults to the
<code><a href="base.html#topic+parent.frame">parent.frame</a></code>. If a function is supplied, uses the environment
associated with the function.</p>
</td></tr>
<tr><td><code id="rls_+3A_all.names">all.names</code></td>
<td>
<p>Show all names, even those starting with <code>.</code>?
Defaults to <code>TRUE</code>, the opposite of <code><a href="base.html#topic+ls">ls</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Winston Chang
</p>

<hr>
<h2 id='sexp_type'>Inspect internal attributes of R objects.</h2><span id='topic+sexp_type'></span><span id='topic+inspect'></span><span id='topic+refs'></span><span id='topic+address'></span><span id='topic+typename'></span>

<h3>Description</h3>

<p><code>typename</code> determines the internal C typename, <code>address</code>
returns the memory location of the object, and <code>refs</code> returns the
number of references pointing to the underlying object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sexp_type(x)

inspect(x, env = parent.frame())

refs(x)

address(x)

typename(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sexp_type_+3A_x">x</code></td>
<td>
<p>name of object to inspect. This can not be a value.</p>
</td></tr>
<tr><td><code id="sexp_type_+3A_env">env</code></td>
<td>
<p>When inspecting environments, don't go past this one.</p>
</td></tr>
</table>


<h3>Non-standard evaluation</h3>

<p>All functions uses non-standard evaluation to capture the symbol you are
referring to and the environment in which it lives. This means that you can
not call any of these functions on objects created in the function call.
All the underlying C level functions use <code>Rf_findVar</code> to get to the
underlying SEXP.
</p>


<h3>See Also</h3>

<p>Other object inspection: 
<code><a href="#topic+ftype">ftype</a>()</code>,
<code><a href="#topic+otype">otype</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
## Not run: .Internal(inspect(x))

typename(x)
refs(x)
address(x)

y &lt;- 1L
typename(y)
z &lt;- list(1:10)
typename(z)
delayedAssign("a", 1 + 2)
typename(a)
a
typename(a)

x &lt;- 1:5
address(x)
x[1] &lt;- 3L
address(x)
</code></pre>

<hr>
<h2 id='show_c_source'>Find C source code for internal R functions</h2><span id='topic+show_c_source'></span>

<h3>Description</h3>

<p>Opens a link to code search on github.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_c_source(fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_c_source_+3A_fun">fun</code></td>
<td>
<p>.Internal or .Primitive function call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
show_c_source(.Internal(mean(x)))
show_c_source(.Primitive(sum(x)))

</code></pre>

<hr>
<h2 id='standardise_call'>Standardise a function call</h2><span id='topic+standardise_call'></span>

<h3>Description</h3>

<p>Standardise a function call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardise_call(call, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardise_call_+3A_call">call</code></td>
<td>
<p>A call</p>
</td></tr>
<tr><td><code id="standardise_call_+3A_env">env</code></td>
<td>
<p>Environment in which to look up call value.</p>
</td></tr>
</table>

<hr>
<h2 id='subs'>A version of substitute that works in the global environment.</h2><span id='topic+subs'></span>

<h3>Description</h3>

<p>This version of <code><a href="base.html#topic+substitute">substitute</a></code> is more suited for interactive
exploration because it will perform substitution in the global environment:
the regular version has a special case for the global environment where it
effectively works like <code><a href="base.html#topic+quote">quote</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(x, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subs_+3A_x">x</code></td>
<td>
<p>a quoted call</p>
</td></tr>
<tr><td><code id="subs_+3A_env">env</code></td>
<td>
<p>an environment, or something that behaves like an environment
(like a list or data frame), or a reference to an environment (like a
positive integer or name, see <code><a href="base.html#topic+as.environment">as.environment</a></code> for more
details)</p>
</td></tr>
</table>


<h3>Substitution rules</h3>

<p>Formally, substitution takes place by examining each name in the expression.
If the name refers to:
</p>

<ul>
<li><p> an ordinary variable, it's replaced by the value of the variable.
</p>
</li>
<li><p> a promise, it's replaced by the expression associated with the
promise.
</p>
</li>
<li> <p><code>...</code>, it's replaced by the contents of <code>...</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
b &lt;- 2

substitute(a + b)
subs(a + b)
</code></pre>

<hr>
<h2 id='substitute_q'>A version of substitute that evaluates its first argument.</h2><span id='topic+substitute_q'></span>

<h3>Description</h3>

<p>This version of substitute is needed because <code>substitute</code> does not
evaluate it's first argument, and it's often useful to be able to modify
a quoted call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitute_q(x, env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="substitute_q_+3A_x">x</code></td>
<td>
<p>a quoted call</p>
</td></tr>
<tr><td><code id="substitute_q_+3A_env">env</code></td>
<td>
<p>an environment, or something that behaves like an environment
(like a list or data frame), or a reference to an environment (like a
positive integer or name, see <code><a href="base.html#topic+as.environment">as.environment</a></code> for more
details)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- quote(a + b)
substitute(x, list(a = 1, b = 2))
substitute_q(x, list(a = 1, b = 2))
</code></pre>

<hr>
<h2 id='track_copy'>Track if an object is copied</h2><span id='topic+track_copy'></span>

<h3>Description</h3>

<p>The title is somewhat misleading: rather than checking if an object is
modified, this really checks to see if a name points to the same object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_copy(var, env = parent.frame(), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track_copy_+3A_var">var</code></td>
<td>
<p>variable name (unquoted)</p>
</td></tr>
<tr><td><code id="track_copy_+3A_env">env</code></td>
<td>
<p>environment name in which to track changes</p>
</td></tr>
<tr><td><code id="track_copy_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code>, prints a message on change; if <code>FALSE</code>
only the return value of the function is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a zero-arg function, that when called returns a boolean indicating
if the object has changed since the last time this function was called
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1:5
track_a &lt;- track_copy(a)
track_a()
a[3] &lt;- 3L
track_a()
a[3] &lt;- 3
track_a()
rm(a)
track_a()
</code></pre>

<hr>
<h2 id='unenclose'>Unenclose a closure.</h2><span id='topic+unenclose'></span>

<h3>Description</h3>

<p>Unenclose a closure by substituting names for values found in the enclosing
environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unenclose(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unenclose_+3A_f">f</code></td>
<td>
<p>a closure</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>power &lt;- function(exp) {
  function(x) x ^ exp
}
square &lt;- power(2)
cube &lt;- power(3)

square
cube
unenclose(square)
unenclose(cube)
</code></pre>

<hr>
<h2 id='uneval'>Capture the call associated with a promise.</h2><span id='topic+uneval'></span>

<h3>Description</h3>

<p>This is an alternative to subsitute that performs one job, and so gives
a stronger signal regarding the intention of your code.  It returns an error
if the name is not associated with a promise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uneval(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uneval_+3A_x">x</code></td>
<td>
<p>unquoted variable name that refers to a promise. An error will be
thrown if it's not a promise.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other promise tools: 
<code><a href="#topic+is_promise">is_promise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) {
   uneval(x)
}
f(a + b)
f(1 + 4)

delayedAssign("x", 1 + 4)
uneval(x)
x
uneval(x)
</code></pre>

<hr>
<h2 id='where'>Find where a name is defined.</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>Implements the regular scoping rules, but instead of returning the value
associated with a name, it returns the environment in which it is located.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(name, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="where_+3A_name">name</code></td>
<td>
<p>name, as string, to look for</p>
</td></tr>
<tr><td><code id="where_+3A_env">env</code></td>
<td>
<p>environment to start at. Defaults to the calling environment
of this function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1
where("x")
where("t.test")
where("mean")
where("where")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
