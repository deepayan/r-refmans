<!DOCTYPE html><html><head><title>Help for package fddm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fddm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dfddm'><p>Density of Ratcliff Diffusion Decision Model</p></a></li>
<li><a href='#med_dec'><p>Medicial decision data</p></a></li>
<li><a href='#pfddm'><p>Distribution of Ratcliff Diffusion Decision Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Implementation of the Diffusion Decision Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the probability density function (PDF), cumulative
  distribution function (CDF), and the partial derivatives of the PDF of the
  diffusion decision model (DDM; e.g.,
  Ratcliff &amp; McKoon, 2008, &lt;<a href="https://doi.org/10.1162%2Fneco.2008.12-06-420">doi:10.1162/neco.2008.12-06-420</a>&gt;) with across-trial
  variability in the drift rate. Because the PDF, its partial derivatives, and
  the CDF of the DDM both contain an infinite sum, they need to be approximated.
  'fddm' implements all published approximations
  (Navarro &amp; Fuss, 2009, &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2009.02.003">doi:10.1016/j.jmp.2009.02.003</a>&gt;;
  Gondan, Blurton, &amp; Kesselmeier, 2014, &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2014.05.002">doi:10.1016/j.jmp.2014.05.002</a>&gt;;
  Blurton, Kesselmeier, &amp; Gondan, 2017, &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2016.11.003">doi:10.1016/j.jmp.2016.11.003</a>&gt;;
  Hartmann &amp; Klauer, 2021, &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2021.102550">doi:10.1016/j.jmp.2021.102550</a>&gt;) plus
  new approximations. All approximations are implemented purely in 'C++'
  providing faster speed than existing packages.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rtdists, RWiener, ggplot2, reshape2, testthat, knitr,
rmarkdown, microbenchmark, ggnewscale, ggforce, WienR</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rtdists/fddm">https://github.com/rtdists/fddm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rtdists/fddm/issues">https://github.com/rtdists/fddm/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-09 14:01:09 UTC; kendal</td>
</tr>
<tr>
<td>Author:</td>
<td>Kendal B. Foster [aut],
  Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Singmann &lt;singmann@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-09 19:02:54 UTC</td>
</tr>
</table>
<hr>
<h2 id='dfddm'>Density of Ratcliff Diffusion Decision Model</h2><span id='topic+dfddm'></span>

<h3>Description</h3>

<p>Density function for the Ratcliff diffusion decision model (DDM) with
following parameters: <code>a</code> (threshold separation), <code>v</code> (drift
rate), <code>t0</code> (non-decision time/response time constant), <code>w</code>
(relative starting point), <code>sv</code> (inter-trial variability of drift), and
<code>sigma</code> (diffusion coefficient of underlying Wiener process).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfddm(
  rt,
  response,
  a,
  v,
  t0,
  w = 0.5,
  sv = 0,
  sigma = 1,
  err_tol = 1e-06,
  log = FALSE,
  switch_mech = "eff_rt",
  switch_thresh = 0.8,
  n_terms_small = "SWSE",
  summation_small = "2017"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfddm_+3A_rt">rt</code></td>
<td>
<p>A vector of response times (in seconds). If a response time is
non-positve, then its density will evaluate to <code class="reqn">0</code> if log = FALSE and
-&#8734; if log = TRUE.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_response">response</code></td>
<td>
<p>Binary response(s) that correspond(s) to either the &quot;lower&quot;
or &quot;upper&quot; threshold. This model parameter can either be a singular value
or a vector. The value(s) in 'response' can be of the following data
types:
</p>

<ul>
<li><p> integers or doubles (<code class="reqn">1</code>
&#8594; &quot;lower&quot;, <code class="reqn">2</code>
&#8594; &quot;upper&quot;);
</p>
</li>
<li><p> factors (the first level gets mapped to &quot;lower&quot;, and the second
level gets mapped to &quot;upper&quot;; any additional levels are ignored).
</p>
</li>
<li><p> strings (only the first character is checked, &quot;L&quot;
&#8594; &quot;lower&quot; or &quot;U&quot;
&#8594; &quot;upper&quot;, case insensitive);
</p>
</li>
<li><p> logicals (FALSE &#8594; &quot;lower&quot;,
TRUE &#8594; &quot;upper&quot;);
</p>
</li></ul>
</td></tr>
<tr><td><code id="dfddm_+3A_a">a</code></td>
<td>
<p>Threshold separation. Amount of information that is considered for
a decision. Large values indicate a conservative decisional style. Allowed
range: <code class="reqn">0 &lt;</code> <code>a</code>. Typical range: <code class="reqn">0.5 &lt;</code> <code>a</code> <code class="reqn">&lt; 2</code>.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_v">v</code></td>
<td>
<p>Drift rate. Average slope of the information accumulation process.
The drift gives information about the speed and direction of the
accumulation of information. Large (absolute) values of drift indicate a
good performance. If received information supports the response linked to
the upper threshold, then the sign will be positive; similarly a negative
value indicates that the received information supports the response linked
to the lower threshold. Allowed range: <code>v</code> is a real number. Typical
range: <code class="reqn">-5 &lt;</code> <code>v</code> <code class="reqn">&lt; 5</code>.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_t0">t0</code></td>
<td>
<p>Non-decision time or response time constant (in seconds). Lower
bound for the duration of all non-decisional processes (encoding and
response execution). If this value is greater than <code>rt</code>, then the
resulting density is returned as if <code>rt</code> <code class="reqn"> \le 0</code>. Allowed range:
<code class="reqn">0 \le</code> <code>t0</code>. Typical range: <code class="reqn">0.1 &lt;</code> <code>t0</code> <code class="reqn">&lt; 0.5</code>.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_w">w</code></td>
<td>
<p>Relative starting point. Indicator of an a priori bias in decision
making. When the relative starting point <code>w</code> deviates from <code class="reqn">0.5</code>,
the amount of information necessary for a decision differs between
response alternatives. Allowed range: <code class="reqn">0 &lt;</code> <code>w</code> <code class="reqn">&lt; 1</code>.
Default value is <code class="reqn">0.5</code> (i.e., no bias).</p>
</td></tr>
<tr><td><code id="dfddm_+3A_sv">sv</code></td>
<td>
<p>Inter-trial-variability of drift rate. Standard deviation of a
normal distribution with mean <code>v</code> describing the distribution of
actual drift rates from specific trials. Values different from <code class="reqn">0</code> can
predict slow errors. Allowed range: <code class="reqn">0 \le</code> <code>sv</code>. Typical range:
<code class="reqn">0 &lt;</code> <code>sv</code> <code class="reqn">&lt; 2</code>. Default value is <code class="reqn">0</code>, which indicates
no drift in the function call. See Details for more information.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_sigma">sigma</code></td>
<td>
<p>Diffusion coefficient of the underlying Wiener process. Allowed
range: <code class="reqn">0 &lt;</code> <code>sigma</code>. Default value is <code class="reqn">1</code>. This parameter
simply scales the parameters <code>a</code>, <code>v</code>, and <code>sv</code> as follows.
See Details for more information. </p>
 <ul>
<li> <p><code>a</code>
&#8594; <code>a</code> <code class="reqn">/</code> <code>sigma</code>
</p>
</li>
<li> <p><code>v</code> &#8594; <code>v</code> <code class="reqn">/</code>
<code>sigma</code> </p>
</li>
<li> <p><code>sv</code> &#8594;
<code>sv</code> <code class="reqn">/</code> <code>sigma</code> </p>
</li></ul>
<p>.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_err_tol">err_tol</code></td>
<td>
<p>Allowed error tolerance of the density function. The density
function contains an infinite sum that must be approximated; this
parameter is the upper bound of the total error incurred from this
approximation (in absolute value). See Details for more information.
Default is <code class="reqn">1e-6</code>.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, probabilities <code class="reqn">p</code> are given as
<code class="reqn">log(p)</code>. Default is <code>FALSE</code>, which gives the density on the
probability scale.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_switch_mech">switch_mech</code></td>
<td>
<p>Which switching mechanism to use in the choice of the
&quot;large-time&quot; or &quot;small-time&quot; density function. Can be one of
{<code>"eff_rt"</code>, <code>"terms_large"</code>, <code>"terms"</code>, <code>"small"</code>,
<code>"large"</code>}. Note that the large-time approximation is unstable for
small effective response times (<code class="reqn">(</code><code>rt</code><code class="reqn">-</code><code>t0</code><code class="reqn">)</code>
<code class="reqn">/(</code><code>a</code><code class="reqn">*</code><code>a</code><code class="reqn">) &lt; 0.009</code>). See Details for more
information. Default is <code>"eff_rt"</code>.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_switch_thresh">switch_thresh</code></td>
<td>
<p>Threshold for determining whether the effective
response time (<code class="reqn">(</code><code>rt</code><code class="reqn">-</code><code>t0</code><code class="reqn">)</code>
<code class="reqn">/(</code><code>a</code><code class="reqn">*</code><code>a</code><code class="reqn">)</code>) is &quot;large&quot; or &quot;small&quot;. This
parameter is only considered if <code>switch_mech = "eff_rt"</code> or
<code>switch_mech = "terms_large"</code>.
If <code>switch_mech = "eff_rt"</code>, an effective response time greater than
<code>switch_thresh</code> is considered &quot;large&quot;, and the &quot;large-time&quot; variant
of the density function is used; otherwise, the &quot;small-time&quot; variant of
the density function is used. The default is <code class="reqn">0.8</code>.
If <code>switch_mech = "terms_large"</code>, this parameter is treated as
<code class="reqn">ceiling(</code><code>switch_thresh</code><code class="reqn">)</code>; the smallest integer that is
not less than <code>switch_thresh</code>. In this case, the default is
<code class="reqn">ceiling(0.8) = 1</code>. See the <code>switch_mech</code> section of Details for
more information.
Note that if <code>switch_thresh</code><code class="reqn"> \le 0</code>, then the effective response
time is always treated as &quot;large&quot;; contrarily, if <code>switch_thresh</code> =
&#8734; then the effective response
time is always treated as &quot;small&quot;. However, it is better to simply set
<code>switch_mech = "large"</code> or <code>switch_mech = "small"</code> to always use
the &quot;large-time&quot; or &quot;small-time&quot; variant, respectively.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_n_terms_small">n_terms_small</code></td>
<td>
<p>Which method to use for calculating the &quot;small-time&quot;
approximation to the density function. Only applicable if
<code>switch_mech = "terms"</code> or <code>switch_mech = "small"</code>; all other
values of <code>switch_mech</code> cause this parameter to be ignored. If
<code>switch_mech = "small"</code>, the allowed values are <code>"SWSE"</code>,
<code>"Gondan"</code>, and <code>"Navarro"</code>. The default value is <code>"SWSE"</code>.
If <code>switch_mech = "terms"</code>, the allowed values are <code>"Gondan"</code>
and <code>"Navarro"</code>. Note that if the user inputs
<code>switch_mech = "terms"</code>, then the user must also explicitly input
either <code>n_terms_small = "Gondan"</code> or
<code>n_terms_small = "Navarro"</code>. See Details for more information.</p>
</td></tr>
<tr><td><code id="dfddm_+3A_summation_small">summation_small</code></td>
<td>
<p>Which style of summation to use for the small-time
approximation to the infinite sum. Can be one of {<code>"2017"</code>,
<code>"2014"</code>}. Only applicable if <code>switch_mech</code> is one of
{<code>"eff_rt"</code>, <code>"terms_large"</code>, <code>"terms"</code>, <code>"small"</code>}.
See Details for more information. Default is <code>"2017"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of the model inputs and parameters (<code>rt</code>, <code>response</code>,
<code>a</code>, <code>v</code>, <code>t0</code>, <code>w</code>, <code>sv</code>, <code>sigma</code>) can be
input as a single value or as a vector of values. If input as a vector of
values, then the standard <code>R</code> recycling rules apply to ensure all 
inputs are of the same length.
</p>
<p>The default settings of <code>switch_mech = "eff_rt"</code>,
<code>switch_thresh = "0.8"</code>, <code>n_terms_small = "SWSE"</code>,
<code>summation_small = "2017"</code> produce the fastest and most accurate
results, as shown in our associated paper.
</p>
<p><code>sv</code> - Both the &quot;small-time&quot; and &quot;large-time&quot; variants of the density
function have two further variants: one with a constant drift rate <code>v</code>
(i.e., <code>sv</code> <code class="reqn">= 0</code>), and one with a variable drift rate <code>v</code>
(i.e., <code>sv</code> <code class="reqn">&gt; 0</code>). The details of the differences between these
two density functions can be found in our associated paper. To use the
density function with a constant drift rate, leave the parameter <code>sv</code>
to its default value of <code>sv = 0</code>, as this will indicate no drift to the
function. To use the density function with a variable drift rate, set the
parameter <code>sv</code> to some non-negative value, i.e., <code>sv</code> <code class="reqn">&gt; 0</code>.
</p>
<p><code>sigma</code> - The default value of this parameter is <code>1</code> because it
only scales the parameters <code>a</code>, <code>v</code>, and <code>sv</code>, as shown
above. However, other formulations of the DDM may set <code>sigma = 0.1</code>
(see Ratcliff (1978), the fourth reference), so care must be taken when
comparing the results of different formulations.
</p>
<p><code>err_tol</code> - The density function is composed of an infinite sum (that
must be approximated) and a multiplicative term outside the infinite sum,
<code class="reqn">m</code>. The total error of the approximation is the error incurred from
truncating the infinite sum multiplied by <code class="reqn">m</code>. Thus, to ensure that the
total error is bounded by the user-provided error tolerance, <code>err_tol</code>,
the approximation to the infinite sum uses a modified error tolerance
(<code>err_tol</code><code class="reqn"> / m</code>). If the error tolerance is small and <code class="reqn">m</code> is
large, the modified error tolerance can underflow to <code class="reqn">0</code>. To protect
against this, we check that the modified error tolerance is at least
<code class="reqn">1e-300</code> (near the smallest value that is representable by a floating
point number with double precision). If the modified error tolerance is
smaller than this threshold, then we silently change it to <code class="reqn">1e-300</code>.
This case should only be encountered if extreme values of error tolerance
are used (i.e., on the scale of <code class="reqn">1e-300</code>).
</p>
<p><code>switch_mech</code> - The density function for the DDM has traditionally been
written in two forms: a &quot;large-time&quot; variant, and a &quot;small-time&quot; variant
(Navarro and Fuss, 2009). These two forms are more
efficient at calculating the density for large and small response times,
respectively. The parameter <code>switch_mech</code> determines how <code>dfddm</code>  
decides which of these two variants is used. 
<code>switch_mech = "small"</code> uses
only the &quot;small-time&quot; variant, and <code>switch_mech = "large"</code> uses only
the &quot;large-time&quot; variant. The &quot;large-time&quot; variant is unstable for small
effective response times (<code class="reqn">(</code><code>rt</code><code class="reqn">-</code><code>t0</code><code class="reqn">)</code> <code class="reqn">/
(</code><code>a</code><code class="reqn">*</code><code>a</code><code class="reqn">) &lt; 0.009</code>) and may produce inaccurate
densities; thus, we do not recommend using the <code>switch_mech = "large"</code>
option if the inputs may contain such small effective response times. To
circumvent this accuracy issue and resolve the differing efficiencies of the
&quot;large-time&quot; and &quot;small-time&quot; variants, there are three switching mechanisms
that can be used to determine which of the two variants is more efficient.
First, <code>switch_mech = "terms"</code> is the traditional approach and
pre-calculates the number of terms required for the &quot;large-time&quot; and
&quot;small-time&quot; sums, and then uses whichever variant requires fewer terms.
This is the mechanism used in the Navarro and Fuss (2009) and Gondan,
Blurton, and Kesselmeier (2014) papers.
Second, <code>switch_mech = "terms_large"</code> pre-calculates the number of
terms only for the &quot;large-time&quot; variant, and compares that to the constant
value of <code class="reqn">ceil(</code><code>switch_thresh</code><code class="reqn">)</code> (default value of
<code class="reqn">ceil(0.8) = 1</code>) to determine if the &quot;large-time&quot; variant is
sufficiently efficient.
Third, <code>switch_mech = "eff_rt"</code> determines whether a given effective
response time (<code class="reqn">(</code><code>rt</code><code class="reqn">-</code><code>t0</code><code class="reqn">)</code>
<code class="reqn">/(</code><code>a</code><code class="reqn">*</code><code>a</code><code class="reqn">)</code>) is considered &quot;large&quot; or &quot;small&quot; by
comparing it to the value of the parameter <code>switch_thresh</code> (default
value of <code class="reqn">0.8</code>); it then uses the corresponding variant.
Both <code>switch_mech = "terms_large"</code> and <code>switch_mech = "eff_rt"</code>
only use the SWSE &quot;small-time&quot; approximation in the case that the
&quot;small-time&quot; variant is more efficient. <code>switch_mech = "eff_rt"</code> is the
most efficient method to determine which variant of the density function
should be used.
</p>
<p><code>switch_thresh</code> - This parameter determines what effective response
times (<code>rt</code><code class="reqn">/(</code><code>a</code> <code class="reqn">*</code><code>a</code><code class="reqn">)</code>) are &quot;large&quot; and
&quot;small&quot;. The <code>paper_analysis</code> folder in the <code>fddm</code> GitHub
repository contains plots showing the relative efficiencies of a range of
values for the <code>switch_thresh</code> parameter when used with
<code>switch_mech = "eff_rt"</code> and also <code>switch_mech = "terms_large"</code>.
Note that this parameter changed name and purpose with the release of
<code>fddm</code> version 0.5-0.
</p>
<p><code>n_terms_small</code> - The &quot;small-time&quot; variant has three different methods
for how to truncate the infinite sum in the density function. These
different methods are discussed extensively in our associated paper, but the
key distinction is that <code>n_terms_small = "SWSE"</code> uses a new method of
truncating the infinite sum. The <code>n_terms_small = "SWSE"</code> method is
currently recommended (when possible) because it is the fastest and most
stable algorithm when used with <code>switch_mech = "eff_rt"</code>.
</p>
<p><code>summation_small</code> - The &quot;large-time&quot; variant of the density function
does not have any further variants, but the &quot;small-time&quot; variant has more
options with respect to evaluating the infinite sum. There are two
equivalent styles of summation, <code>summation_small = "2017"</code> and
<code>summation_small = "2014"</code>, of which the <code>"2017"</code> version
evaluates slightly faster and thus earns our recommendation. These different
styles of summation are discussed in our associated paper.
</p>


<h3>Value</h3>

<p>A vector containing the densities of the DDM with precision
<code>err_tol</code> whose length matches that of the longest input parameter
(usually <code>rt</code>).
</p>


<h3>References</h3>

<p>Navarro, D. J., &amp; Fuss, I. G. (2009). Fast and accurate
calculations for first-passage times in Wiener diffusion models. Journal
of Mathematical Psychology, 53(4), 222-230.
</p>
<p>Gondan, M., Blurton, S. P., &amp; Kesselmeier, M. (2014). Even faster and even
more accurate first-passage time densities and distributions for the
Wiener diffusion model. Journal of Mathematical Psychology, 60, 20-22.
</p>
<p>Blurton, S. P., Kesselmeier, M., &amp; Gondan, M. (2017). The first-passage
time distribution for the diffusion model with variable drift. Journal of
Mathematical Psychology, 76, 7-12.
</p>
<p>Ratcliff, R. (1978). A theory of memory retrieval. Psychological review,
85(2), 59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># minimal example
dfddm(rt = 1.2, response = "lower", a = 1, v = -1, t0 = 0.3)

# example with all function parameters set to default or a practical value
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3),
      response = c("lower", "upper", "upper", "lower", "upper", "lower"),
      a = 1, v = -1, t0 = 0.2, w = 0.5, sv = 0, sigma = 1,
      err_tol = 1e-6, log = FALSE, switch_mech = "eff_rt", switch_thresh = 0.8,
      n_terms_small = "SWSE", summation_small = "2017")

# example of mismatched input lengths
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3),
      response = c("lower", "upper", "upper", "lower", "upper", "lower"),
      a = c(1, 3), v = c(-2, 2, 2, -2, 2, -2),
      t0 = 0.3, w = c(0.4, 0.5, 0.6), sv = 0.9,
      err_tol = 1e-10, log = FALSE, switch_mech = "large",
      summation_small = "2017")

# example with Wiener diffusion coefficient (sigma) not equal to 1
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3),
      response = c("lower", "upper", "upper", "lower", "upper", "lower"),
      a = 1, v = -1, t0 = 0.3, w = 0.5, sv = 0, sigma = 0.1,
      err_tol = 1e-10, log = TRUE, switch_mech = "terms_large",
      switch_thresh = 1, summation_small = "2017")


### examples of different response inputs

# integer
resp_int &lt;- as.integer(c(1, 2, 2, 1, 2, 1))
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_int,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, switch_mech = "eff_rt",
      summation_small = "2017")

# double
resp_dbl &lt;- as.double(c(1, 2, 2, 1, 2, 1))
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_dbl,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, switch_mech = "eff_rt",
      summation_small = "2017")

# factor (first level is mapped to "lower")
days &lt;- c("Monday", "Friday", "Friday", "Monday", "Friday", "Monday")
resp_fac &lt;- factor(days, levels = c("Monday", "Friday"))
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_fac,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, switch_mech = "eff_rt",
      summation_small = "2017")

# string
resp_str &lt;- c("lower", "upper", "upper", "lower", "upper", "lower")
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_str,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, switch_mech = "eff_rt",
      summation_small = "2017")

# logical
resp_log &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE, FALSE)
dfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_log,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, switch_mech = "eff_rt",
      summation_small = "2017")
</code></pre>

<hr>
<h2 id='med_dec'>Medicial decision data</h2><span id='topic+med_dec'></span>

<h3>Description</h3>

<p>Part of the accuracy and response time data presented in Trueblood et al.
(2017) investigating medical decision making among medical professionals
(pathologists) and novices (i.e., undergraduate students). The task of
participants was to judge whether pictures of blood cells show cancerous
cells (i.e., blast cells) or non-cancerous cells (i.e., non-blast cells). The
current data set contains 200 decisions per participant (the &quot;accuracy&quot;
condition from Trueblood et al.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(med_dec)
</code></pre>


<h3>Format</h3>

<p>A data frame with 11000 rows and 9 variables:
</p>

<dl>
<dt>id</dt><dd><p>identification number of the participant</p>
</dd>
<dt>group</dt><dd><p>expertise of participant; &quot;experienced&quot;, &quot;inexperienced&quot;, or &quot;novice&quot;. The first two levels refer to different type of medical professional (i.e., experts).</p>
</dd>
<dt>block</dt><dd><p>block number</p>
</dd>
<dt>trial</dt><dd><p>index of trial for each participant</p>
</dd>
<dt>classification</dt><dd><p>true classification of the pictured cell; i.e. the correct response</p>
</dd>
<dt>difficulty</dt><dd><p>adjudged difficulty of the task for the particular image</p>
</dd>
<dt>response</dt><dd><p>response given by the participant; either &quot;blast&quot; or &quot;non-blast&quot;</p>
</dd>
<dt>rt</dt><dd><p>the response time associated with the response, in seconds</p>
</dd>
<dt>stimulus</dt><dd><p>the image file used for the specific trial</p>
</dd>
</dl>



<h3>Details</h3>

<p>At the beginning of the experiment, both novices and medical experts
completed a training to familiarize themselves with blast cells. After that,
each participant performed the main task in which they judged whether or not
presented images were blast cells or non-blast cells. Among them, some of the
cells were judged as easy and some as difficult trials by an additional group
of experts. The current data set only contains the data from the &quot;accuracy&quot;
condition (i.e., Trueblood et al. considered additional conditions that are
not part of the current data set).
</p>
<p>The relevant part of the method section for the accuracy condition from the
original paper is as follows:
</p>
<p>&quot;The main task consisted of six blocks with 100 trials in each block. The
main task was the same as the practice block, where participants were asked
to identify single images. However, participants did not receive
trial-by-trial feedback about their choices. They received feedback about
their performance at the end of each block. The 100 trials in each block were
composed of equal numbers of easy blast images, hard blast images, easy
non-blast images, and hard non-blast images, fully randomized.
</p>
<p>There were three manipulations across blocks: accuracy, speed, and bias. In
the accuracy blocks, participants were instructed to respond as accurately as
possible and were given 5 s to respond. [...] If they responded after the
deadline, they received the message &quot;Too Slow!&quot; The 5-s [...] response
windows for the accuracy [...] [condition was] based on the response time
data from the three expert raters. The 0.975 quantile of the expert raters'
response times was 4.96 s; thus, we set the accuracy response window to 5 s.
</p>
<p>The order of the first three blocks was randomized but with the constraint
that there was one block for each type of manipulation (i.e., accuracy,
speed, and bias). The order of the last three blocks was identical to the
order of the first three blocks.&quot;
</p>
<p>Note that this dataset contains some negative response times that indicate a
missing response (i.e., the response value for that trial is 'NA'). Take care
in removing these values before using this dataset. See our Validity vignette
for an example of use in an optimization setting.
</p>


<h3>Source</h3>

<p>Trueblood, J.S., Holmes, W.R., Seegmiller, A.C. et al. The impact of
speed and bias on the cognitive processes of experts and novices in medical
image decision-making. Cogn. Research 3, 28 (2018).
https://doi.org/10.1186/s41235-018-0119-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("med_dec", package = "fddm")
str(med_dec)

## number of participants per expertise condition:
aggregate(id ~ group, med_dec, function(x) length(unique(x)))

## number of trials per participant
aggregate(rt ~ group + id, med_dec, length)
</code></pre>

<hr>
<h2 id='pfddm'>Distribution of Ratcliff Diffusion Decision Model</h2><span id='topic+pfddm'></span>

<h3>Description</h3>

<p>Distribution function for the Ratcliff diffusion decision model (DDM) with
following parameters: <code>a</code> (threshold separation), <code>v</code> (drift
rate), <code>t0</code> (non-decision time/response time constant), <code>w</code>
(relative starting point), <code>sv</code> (inter-trial variability of drift), and
<code>sigma</code> (diffusion coefficient of underlying Wiener process).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfddm(
  rt,
  response,
  a,
  v,
  t0,
  w = 0.5,
  sv = 0,
  sigma = 1,
  err_tol = 1e-06,
  log = FALSE,
  method = "Mills"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfddm_+3A_rt">rt</code></td>
<td>
<p>A vector of response times (in seconds). If a response time is
non-positve, then its density will evaluate to <code class="reqn">0</code> if log = FALSE and
-&#8734; if log = TRUE.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_response">response</code></td>
<td>
<p>Binary response(s) that correspond(s) to either the &quot;lower&quot;
or &quot;upper&quot; threshold. This model parameter can either be a singular value
or a vector. The value(s) in 'response' can be of the following data
types:
</p>

<ul>
<li><p> integers or doubles (<code class="reqn">1</code>
&#8594; &quot;lower&quot;, <code class="reqn">2</code>
&#8594; &quot;upper&quot;);
</p>
</li>
<li><p> factors (the first level gets mapped to &quot;lower&quot;, and the second
level gets mapped to &quot;upper&quot;; any additional levels are ignored).
</p>
</li>
<li><p> strings (only the first character is checked, &quot;L&quot;
&#8594; &quot;lower&quot; or &quot;U&quot;
&#8594; &quot;upper&quot;, case insensitive);
</p>
</li>
<li><p> logicals (FALSE &#8594; &quot;lower&quot;,
TRUE &#8594; &quot;upper&quot;);
</p>
</li></ul>
</td></tr>
<tr><td><code id="pfddm_+3A_a">a</code></td>
<td>
<p>Threshold separation. Amount of information that is considered for
a decision. Large values indicate a conservative decisional style. Allowed
range: <code class="reqn">0 &lt;</code> <code>a</code>. Typical range: <code class="reqn">0.5 &lt;</code> <code>a</code> <code class="reqn">&lt; 2</code>.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_v">v</code></td>
<td>
<p>Drift rate. Average slope of the information accumulation process.
The drift gives information about the speed and direction of the
accumulation of information. Large (absolute) values of drift indicate a
good performance. If received information supports the response linked to
the upper threshold, then the sign will be positive; similarly a negative
value indicates that the received information supports the response linked
to the lower threshold. Allowed range: <code>v</code> is a real number. Typical
range: <code class="reqn">-5 &lt;</code> <code>v</code> <code class="reqn">&lt; 5</code>.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_t0">t0</code></td>
<td>
<p>Non-decision time or response time constant (in seconds). Lower
bound for the duration of all non-decisional processes (encoding and
response execution). If this value is greater than <code>rt</code>, then the
resulting density is returned as if <code>rt</code> <code class="reqn"> \le 0</code>. Allowed range:
<code class="reqn">0 \le</code> <code>t0</code>. Typical range: <code class="reqn">0.1 &lt;</code> <code>t0</code> <code class="reqn">&lt; 0.5</code>.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_w">w</code></td>
<td>
<p>Relative starting point. Indicator of an a priori bias in decision
making. When the relative starting point <code>w</code> deviates from <code class="reqn">0.5</code>,
the amount of information necessary for a decision differs between
response alternatives. Allowed range: <code class="reqn">0 &lt;</code> <code>w</code> <code class="reqn">&lt; 1</code>.
Default value is <code class="reqn">0.5</code> (i.e., no bias).</p>
</td></tr>
<tr><td><code id="pfddm_+3A_sv">sv</code></td>
<td>
<p>Inter-trial-variability of drift rate. Standard deviation of a
normal distribution with mean <code>v</code> describing the distribution of
actual drift rates from specific trials. Values different from <code class="reqn">0</code> can
predict slow errors. Allowed range: <code class="reqn">0 \le</code> <code>sv</code>. Typical range:
<code class="reqn">0 &lt;</code> <code>sv</code> <code class="reqn">&lt; 2</code>. Default value is <code class="reqn">0</code>, which indicates
no drift in the function call. See Details for more information.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_sigma">sigma</code></td>
<td>
<p>Diffusion coefficient of the underlying Wiener process. Allowed
range: <code class="reqn">0 &lt;</code> <code>sigma</code>. Default value is <code class="reqn">1</code>. This parameter
simply scales the parameters <code>a</code>, <code>v</code>, and <code>sv</code> as follows.
See Details for more information. </p>
 <ul>
<li> <p><code>a</code>
&#8594; <code>a</code> <code class="reqn">/</code> <code>sigma</code>
</p>
</li>
<li> <p><code>v</code> &#8594; <code>v</code> <code class="reqn">/</code>
<code>sigma</code> </p>
</li>
<li> <p><code>sv</code> &#8594;
<code>sv</code> <code class="reqn">/</code> <code>sigma</code> </p>
</li></ul>
<p>.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_err_tol">err_tol</code></td>
<td>
<p>Allowed error tolerance of the density function. Since the
density function contains an infinite sum, this parameter defines the
precision of the approximation to that infinite sum. If the provided
error tolerance is less than <code class="reqn">1e-300</code>, it is set to <code class="reqn">1e-300</code>.
Default is <code class="reqn">1e-6</code>.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, probabilities <code class="reqn">p</code> are given as
<code class="reqn">log(p)</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pfddm_+3A_method">method</code></td>
<td>
<p>Which method of calculating the CDF to use. Can be one of
{<code>"Mills"</code>, <code>"NCDF"</code>}, case-insensitive. Default is
<code>"Mills"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of the model inputs and parameters (<code>rt</code>, <code>response</code>,
<code>a</code>, <code>v</code>, <code>t0</code>, <code>w</code>, <code>sv</code>, <code>sigma</code>) can be
input as a single value or as a vector of values. If input as a vector of
values, then the standard <code>R</code> input wrapping will occur.
</p>
<p><code>sigma</code> - The default value of this parameter is <code>1</code> because it
only scales the parameters <code>a</code>, <code>v</code>, and <code>sv</code>, as shown
above. However, other formulations of the DDM may set <code>sigma = 0.1</code>
(see Ratcliff (1978), the fourth reference), so care must be taken when
comparing the results of different formulations.
</p>


<h3>Value</h3>

<p>A vector containing the distribution of the DDM with precision
<code>err_tol</code> whose length matches that of the longest input parameter
(usually <code>rt</code>).
</p>


<h3>References</h3>

<p>Navarro, D. J., &amp; Fuss, I. G. (2009). Fast and accurate
calculations for first-passage times in Wiener diffusion models. Journal
of Mathematical Psychology, 53(4), 222-230.
</p>
<p>Gondan, M., Blurton, S. P., &amp; Kesselmeier, M. (2014). Even faster and even
more accurate first-passage time densities and distributions for the
Wiener diffusion model. Journal of Mathematical Psychology, 60, 20-22.
</p>
<p>Blurton, S. P., Kesselmeier, M., &amp; Gondan, M. (2017). The first-passage
time distribution for the diffusion model with variable drift. Journal of
Mathematical Psychology, 76, 7-12.
</p>
<p>Ratcliff, R. (1978). A theory of memory retrieval. Psychological review,
85(2), 59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># minimal example
pfddm(rt = 1.2, response = "lower", a = 1, v = -1, t0 = 0.3)

# example with all function parameters set to default or a practical value
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3),
      response = c("lower", "upper", "upper", "lower", "upper", "lower"),
      a = 1, v = -1, t0 = 0.2, w = 0.5, sv = 0, sigma = 1,
      err_tol = 1e-6, log = FALSE, method = "Mills")

# example of mismatched input lengths
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3),
      response = c("lower", "upper", "upper", "lower", "upper", "lower"),
      a = c(1, 3), v = c(-2, 2, 2, -2, 2, -2),
      t0 = 0.3, w = c(0.4, 0.5, 0.6), sv = 0.9,
      err_tol = 1e-10, log = FALSE, method = "NCDF")

# example with Wiener diffusion coefficient (sigma) not equal to 1
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3),
      response = c("lower", "upper", "upper", "lower", "upper", "lower"),
      a = 1, v = -1, t0 = 0.3, w = 0.5, sv = 0, sigma = 0.1,
      err_tol = 1e-10, log = TRUE, method = "Mills")


### examples of different response inputs

# integer
resp_int &lt;- as.integer(c(1, 2, 2, 1, 2, 1))
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_int,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, method = "Mills")

# double
resp_dbl &lt;- as.double(c(1, 2, 2, 1, 2, 1))
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_dbl,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, method = "Mills")

# factor (first level is mapped to "lower")
days &lt;- c("Monday", "Friday", "Friday", "Monday", "Friday", "Monday")
resp_fac &lt;- factor(days, levels = c("Monday", "Friday"))
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_fac,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, method = "Mills")

# string
resp_str &lt;- c("lower", "upper", "upper", "lower", "upper", "lower")
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_str,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, method = "Mills")

# logical
resp_log &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE, FALSE)
pfddm(rt = c(1.2, 0.9, 1.1, 1.4, 0.8, 1.3), response = resp_log,
      a = 1, v = -2, t0 = 0.3, w = 0.5, sv = 0.1,
      err_tol = 1e-10, log = FALSE, method = "Mills")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
