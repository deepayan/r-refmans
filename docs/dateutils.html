<!DOCTYPE html><html><head><title>Help for package dateutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dateutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_forecast_dates'><p>Add NA values to the tail of a wide data.table</p></a></li>
<li><a href='#agg_to_freq'><p>Aggregate long format data.table</p></a></li>
<li><a href='#agg_to_freq_wide'><p>Aggregate data.table and return wide format</p></a></li>
<li><a href='#all_finite'><p>Rows with only finite values</p></a></li>
<li><a href='#allNA'><p>Are all elements 'NA'?</p></a></li>
<li><a href='#any_finite'><p>Rows with finite values</p></a></li>
<li><a href='#can_seasonal'><p>Can data be seasonally adjusted?</p></a></li>
<li><a href='#col_to_list'><p>Convert columns to list</p></a></li>
<li><a href='#comp_form'><p>Companion Form</p></a></li>
<li><a href='#count_obs'><p>Count observations</p></a></li>
<li><a href='#day'><p>Return the day of a Date value</p></a></li>
<li><a href='#Diff'><p>Difference data</p></a></li>
<li><a href='#end_of_period'><p>End of period date</p></a></li>
<li><a href='#end_of_year'><p>End of Year</p></a></li>
<li><a href='#extract_basic_character'><p>Extract characters</p></a></li>
<li><a href='#extract_character'><p>Extract character values</p></a></li>
<li><a href='#extract_numeric'><p>Extract numeric values</p></a></li>
<li><a href='#fill_forward'><p>Fill Forward</p></a></li>
<li><a href='#first_of_month'><p>First of month</p></a></li>
<li><a href='#first_of_quarter'><p>First of Quarter</p></a></li>
<li><a href='#first_previous_quarter'><p>First of previous quarter date</p></a></li>
<li><a href='#fred'><p>Sample mixed frequency data from FRED</p></a></li>
<li><a href='#fredlib'><p>Library of metadata for mixed frequency dataset 'fred'</p></a></li>
<li><a href='#get_data_frq'><p>Get frequency of data based on missing observations</p></a></li>
<li><a href='#get_from_list'><p>Get from list</p></a></li>
<li><a href='#index_by_friday'><p>Find the Friday in a given week</p></a></li>
<li><a href='#is_in'><p>Find element of this_in that</p></a></li>
<li><a href='#last_in_month'><p>Last date in the month</p></a></li>
<li><a href='#last_in_quarter'><p>Last date in the week</p></a></li>
<li><a href='#last_in_week'><p>Last date in the week</p></a></li>
<li><a href='#last_in_year'><p>Last date in the year</p></a></li>
<li><a href='#last_obs'><p>Last observation</p></a></li>
<li><a href='#limit_character'><p>Limit Characters</p></a></li>
<li><a href='#long_run_var'><p>Long Run Variance of a VAR</p></a></li>
<li><a href='#match_index'><p>Match index values</p></a></li>
<li><a href='#match_ts_dates'><p>Match dates between two timeseries</p></a></li>
<li><a href='#mean_na'><p>Return the mean</p></a></li>
<li><a href='#month_days'><p>Number of days in a given month</p></a></li>
<li><a href='#number_finite'><p>Number of finite values in a column</p></a></li>
<li><a href='#numdum'><p>Dummies for Numeric Data</p></a></li>
<li><a href='#pct_chng'><p>Percent change</p></a></li>
<li><a href='#pct_response'><p>Percent of responses at a given frequency</p></a></li>
<li><a href='#process'><p>Process Data</p></a></li>
<li><a href='#process_MF'><p>Process mixed frequency</p></a></li>
<li><a href='#process_wide'><p>Process Wide Format Data</p></a></li>
<li><a href='#rollmax'><p>Rolling Max</p></a></li>
<li><a href='#rollmean'><p>Rolling mean</p></a></li>
<li><a href='#rollmin'><p>Rolling Min</p></a></li>
<li><a href='#row_to_list'><p>Convert rows to list</p></a></li>
<li><a href='#run_sa'><p>Seasonally adjust data using seas()</p></a></li>
<li><a href='#sd_na'><p>Return the standard deviation</p></a></li>
<li><a href='#seas_df_long'><p>Seasonally adjust long format data using seas()</p></a></li>
<li><a href='#seas_df_wide'><p>Seasonally adjust wide format data using seas()</p></a></li>
<li><a href='#spline_fill'><p>Spline fill missing observations</p></a></li>
<li><a href='#spline_fill_trend'><p>Spline fill missing observations</p></a></li>
<li><a href='#stack_obs'><p>Stack time series observations in VAR format</p></a></li>
<li><a href='#sum_na'><p>Return the sum</p></a></li>
<li><a href='#to_ts'><p>Tabular data to ts() format</p></a></li>
<li><a href='#total_response'><p>Number of of responses at a given frequency</p></a></li>
<li><a href='#try_detrend'><p>Remove low frequency trends from data</p></a></li>
<li><a href='#try_sa'><p>Seasonally adjust data using seas()</p></a></li>
<li><a href='#try_trend'><p>Estimate low frequnecy trends</p></a></li>
<li><a href='#ts_to_df'><p>ts() data to a dataframe</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Date Utils</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Seth Leonard [aut, cre],
  Jiancong Liu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Seth Leonard &lt;seth@ottoquant.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities for mixed frequency data. In particular, use to aggregate and normalize tabular mixed frequency data, index dates to end of period, and seasonally adjust tabular data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), data.table (&ge; 1.9.8), seasonal</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/macroeconomicdata/dateutils">https://github.com/macroeconomicdata/dateutils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/macroeconomicdata/dateutils/issues">https://github.com/macroeconomicdata/dateutils/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-10 01:18:06 UTC; seton</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-10 15:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_forecast_dates'>Add NA values to the tail of a wide data.table</h2><span id='topic+add_forecast_dates'></span>

<h3>Description</h3>

<p>Add NA values to the tail of a wide data.table to be filled by forecasting routines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_forecast_dates(
  dt,
  horizon = 1,
  frq = c("month", "week", "quarter", "year"),
  date_name = "ref_date"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_forecast_dates_+3A_dt">dt</code></td>
<td>
<p>data.table in wide format</p>
</td></tr>
<tr><td><code id="add_forecast_dates_+3A_horizon">horizon</code></td>
<td>
<p>number of periods to add at specified 'frq'</p>
</td></tr>
<tr><td><code id="add_forecast_dates_+3A_frq">frq</code></td>
<td>
<p>frequency for aggregation, one of '&quot;month&quot;', '&quot;week&quot;', '&quot;quarter&quot;', or '&quot;year&quot;'</p>
</td></tr>
<tr><td><code id="add_forecast_dates_+3A_date_name">date_name</code></td>
<td>
<p>name of date column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA-filled data.table in wide format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_forecast_dates(fred[series_name == "gdp constant prices"],frq="quarter")
</code></pre>

<hr>
<h2 id='agg_to_freq'>Aggregate long format data.table</h2><span id='topic+agg_to_freq'></span>

<h3>Description</h3>

<p>Aggregate a data.table in long format to a specified frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_to_freq(
  dt_long,
  frq = c("month", "week", "quarter", "year"),
  date_name = "ref_date",
  id_name = "series_name",
  value_name = "value"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_to_freq_+3A_dt_long">dt_long</code></td>
<td>
<p>data.table in long format</p>
</td></tr>
<tr><td><code id="agg_to_freq_+3A_frq">frq</code></td>
<td>
<p>frequency for aggregation, one of '&quot;month&quot;', '&quot;week&quot;', '&quot;quarter&quot;', or '&quot;year&quot;'</p>
</td></tr>
<tr><td><code id="agg_to_freq_+3A_date_name">date_name</code></td>
<td>
<p>name of date column</p>
</td></tr>
<tr><td><code id="agg_to_freq_+3A_id_name">id_name</code></td>
<td>
<p>name of id column</p>
</td></tr>
<tr><td><code id="agg_to_freq_+3A_value_name">value_name</code></td>
<td>
<p>name of value column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated data at specified frequency in long format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- agg_to_freq(fred[series_name == "gdp constant prices"], frq = "year")
</code></pre>

<hr>
<h2 id='agg_to_freq_wide'>Aggregate data.table and return wide format</h2><span id='topic+agg_to_freq_wide'></span>

<h3>Description</h3>

<p>Aggregate a data.table to a specified frequency and return wide format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_to_freq_wide(
  dt,
  date_name = "ref_date",
  frq = c("month", "week", "quarter", "year"),
  id_name = "series_name",
  value_name = "value",
  dt_is_wide = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_to_freq_wide_+3A_dt">dt</code></td>
<td>
<p>data.table in long format</p>
</td></tr>
<tr><td><code id="agg_to_freq_wide_+3A_date_name">date_name</code></td>
<td>
<p>name of date column</p>
</td></tr>
<tr><td><code id="agg_to_freq_wide_+3A_frq">frq</code></td>
<td>
<p>frequency for aggregation, one of '&quot;month&quot;', '&quot;week&quot;', '&quot;quarter&quot;', or '&quot;year&quot;'</p>
</td></tr>
<tr><td><code id="agg_to_freq_wide_+3A_id_name">id_name</code></td>
<td>
<p>name of id column</p>
</td></tr>
<tr><td><code id="agg_to_freq_wide_+3A_value_name">value_name</code></td>
<td>
<p>name of value column</p>
</td></tr>
<tr><td><code id="agg_to_freq_wide_+3A_dt_is_wide">dt_is_wide</code></td>
<td>
<p>T/F, is input data 'dt' in wide format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated data at specificed frequency in wide format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- agg_to_freq_wide(fred,frq="quarter")
</code></pre>

<hr>
<h2 id='all_finite'>Rows with only finite values</h2><span id='topic+all_finite'></span>

<h3>Description</h3>

<p>Return indexes of rows with only finite values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_finite(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_finite_+3A_y">Y</code></td>
<td>
<p>matrix like data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Indexes of rows with with only finite values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1,10,2)
X[3,1] &lt;- NA
all_finite(X)
</code></pre>

<hr>
<h2 id='allNA'>Are all elements 'NA'?</h2><span id='topic+allNA'></span>

<h3>Description</h3>

<p>Return a logical indicating if all elements are 'NA'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allNA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allNA_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical variable indicating all elements are 'NA'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>allNA(c(NA, NA, 1, NA)) ## FALSE
</code></pre>

<hr>
<h2 id='any_finite'>Rows with finite values</h2><span id='topic+any_finite'></span>

<h3>Description</h3>

<p>Return indexes of rows with at least one finite value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_finite(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any_finite_+3A_y">Y</code></td>
<td>
<p>matrix like data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Indexes of rows with at least one finite value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1,10,2)
X[3,] &lt;- NA
any_finite(X)
</code></pre>

<hr>
<h2 id='can_seasonal'>Can data be seasonally adjusted?</h2><span id='topic+can_seasonal'></span>

<h3>Description</h3>

<p>Return a logical indicating whether data at given dates can be seasonally adjusted using seas()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>can_seasonal(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="can_seasonal_+3A_dates">dates</code></td>
<td>
<p>dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical variable indicating whether data can be seasonally adjusted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>can_seasonal(fred$ref_date[1:20]) ## TRUE
</code></pre>

<hr>
<h2 id='col_to_list'>Convert columns to list</h2><span id='topic+col_to_list'></span>

<h3>Description</h3>

<p>Return 'Y' with each column as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_to_list(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_to_list_+3A_y">Y</code></td>
<td>
<p>matrix like data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each column as a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>row_to_list(matrix(rnorm(20),10,2))
</code></pre>

<hr>
<h2 id='comp_form'>Companion Form</h2><span id='topic+comp_form'></span>

<h3>Description</h3>

<p>Put the transition matrix 'B' into companion form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_form(B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_form_+3A_b">B</code></td>
<td>
<p>Transition matrix from a VAR model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Companion matrix of the input matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_form(matrix(c(1:4), nrow = 2, byrow = TRUE)) ## matrix(c(4,-2,-3,1), nrow = 2, byrow = TRUE)
</code></pre>

<hr>
<h2 id='count_obs'>Count observations</h2><span id='topic+count_obs'></span>

<h3>Description</h3>

<p>Return the number of finite observations in 'x'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_obs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_obs_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Number of observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_obs(c(1,3,5,7,9,NA)) # 5
</code></pre>

<hr>
<h2 id='day'>Return the day of a Date value</h2><span id='topic+day'></span>

<h3>Description</h3>

<p>Return the day of a Date value as an integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>day(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="day_+3A_date">date</code></td>
<td>
<p>date value formated as.Date()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the day of the date (integer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>day(as.Date("2019-09-15")) ## 15
</code></pre>

<hr>
<h2 id='Diff'>Difference data</h2><span id='topic+Diff'></span>

<h3>Description</h3>

<p>Wrapper for 'diff()' maintaining the same number of observations in 'x'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diff(x, lag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diff_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="Diff_+3A_lag">lag</code></td>
<td>
<p>number of lags to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Differenced data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Diff(c(100,50,100,20,100,110))
</code></pre>

<hr>
<h2 id='end_of_period'>End of period date</h2><span id='topic+end_of_period'></span>

<h3>Description</h3>

<p>Return the date of the last day of the period (week, month, quarter, year). Weekly dates are indexed to Friday.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>end_of_period(dates, period = c("month", "week", "quarter", "year"), shift = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="end_of_period_+3A_dates">dates</code></td>
<td>
<p>Date values formatted as.Date()</p>
</td></tr>
<tr><td><code id="end_of_period_+3A_period">period</code></td>
<td>
<p>One of ''month'&lsquo;, '&rsquo;week'&lsquo;, '&rsquo;quarter'&lsquo;, '&rsquo;year''.</p>
</td></tr>
<tr><td><code id="end_of_period_+3A_shift">shift</code></td>
<td>
<p>Integer, shift date forward (positive values) or backwards (negative values) by the number of periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last day of period in as.Date() format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>end_of_period(as.Date("2019-09-15")) ## 2019-09-30
</code></pre>

<hr>
<h2 id='end_of_year'>End of Year</h2><span id='topic+end_of_year'></span>

<h3>Description</h3>

<p>Find the end of year for a vector of dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>end_of_year(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="end_of_year_+3A_dates">dates</code></td>
<td>
<p>Transition matrix from a VAR model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The last day of the year for the dates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>end_of_year(as.Date("2019-09-15")) ## 2019-12-31
</code></pre>

<hr>
<h2 id='extract_basic_character'>Extract characters</h2><span id='topic+extract_basic_character'></span>

<h3>Description</h3>

<p>Extract character values from x excluding space and underscore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_basic_character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_basic_character_+3A_x">x</code></td>
<td>
<p>object containing character (and other) values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character values without space and underscore
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_basic_character(c("this_1one", "abc123"))  ## c("thisone", "abc123)
</code></pre>

<hr>
<h2 id='extract_character'>Extract character values</h2><span id='topic+extract_character'></span>

<h3>Description</h3>

<p>Extract character values from x including space and underscore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_character_+3A_x">x</code></td>
<td>
<p>object containing character values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character valus from the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_character(c("this_1one", "abc123")) ## c("this_one", "abc")
</code></pre>

<hr>
<h2 id='extract_numeric'>Extract numeric values</h2><span id='topic+extract_numeric'></span>

<h3>Description</h3>

<p>Extract numeric values from x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_numeric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_numeric_+3A_x">x</code></td>
<td>
<p>object containing numeric (and other) values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric values from the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_numeric(c("7+5", "abc123")) ## c(75, 123)
</code></pre>

<hr>
<h2 id='fill_forward'>Fill Forward</h2><span id='topic+fill_forward'></span>

<h3>Description</h3>

<p>Fill missing observations forward using the last finite observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_forward(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_forward_+3A_x">x</code></td>
<td>
<p>Transition matrix from a VAR model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with missing obs filled by forward value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fill_forward(c(1,2,NA,NA,3,NA,5)) ## 1 2 2 2 3 3 5   
</code></pre>

<hr>
<h2 id='first_of_month'>First of month</h2><span id='topic+first_of_month'></span>

<h3>Description</h3>

<p>Return the first day of the month for each date in 'dates'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_of_month(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_of_month_+3A_dates">dates</code></td>
<td>
<p>A sequence of dates in 'as.Date()' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>First day of the month
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- seq.Date(from = as.Date("2020-09-11"),
                  by = "day", length.out = 10)
first_of_month(dates)
</code></pre>

<hr>
<h2 id='first_of_quarter'>First of Quarter</h2><span id='topic+first_of_quarter'></span>

<h3>Description</h3>

<p>Find the first date in the quarter for a vector of dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_of_quarter(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_of_quarter_+3A_dates">dates</code></td>
<td>
<p>Transition matrix from a VAR model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first day of the quarter for the dates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>first_of_quarter(as.Date("2019-9-15")) ## 2019-07-01
</code></pre>

<hr>
<h2 id='first_previous_quarter'>First of previous quarter date</h2><span id='topic+first_previous_quarter'></span>

<h3>Description</h3>

<p>Return the date of the first day of the previous quarter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_previous_quarter(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_previous_quarter_+3A_date">date</code></td>
<td>
<p>date value formated as.Date()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first day of the previous quarter of the date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>first_previous_quarter(as.Date("2019-09-15")) ## 2019-04-01
</code></pre>

<hr>
<h2 id='fred'>Sample mixed frequency data from FRED</h2><span id='topic+fred'></span>

<h3>Description</h3>

<p>Sample mixed frequency data from FRED
</p>


<h3>Author(s)</h3>

<p>Seth Leonard <a href="mailto:seth@macroeconomicdata.com">seth@macroeconomicdata.com</a>
</p>


<h3>References</h3>

<p><a href="https://fred.stlouisfed.org/">https://fred.stlouisfed.org/</a>
</p>

<hr>
<h2 id='fredlib'>Library of metadata for mixed frequency dataset 'fred'</h2><span id='topic+fredlib'></span>

<h3>Description</h3>

<p>Library of metadata for mixed frequency dataset 'fred'
</p>


<h3>Author(s)</h3>

<p>Seth Leonard <a href="mailto:seth@macroeconomicdata.com">seth@macroeconomicdata.com</a>
</p>


<h3>References</h3>

<p><a href="https://fred.stlouisfed.org/">https://fred.stlouisfed.org/</a>
</p>

<hr>
<h2 id='get_data_frq'>Get frequency of data based on missing observations</h2><span id='topic+get_data_frq'></span>

<h3>Description</h3>

<p>Guess the frequency of a data series based on the pattern of missing observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_frq(x = NULL, dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_frq_+3A_x">x</code></td>
<td>
<p>data, potentially with missing observations</p>
</td></tr>
<tr><td><code id="get_data_frq_+3A_dates">dates</code></td>
<td>
<p>corresponding dates in 'as.Date()' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The frequency of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- as.Date(c("2020-1-1", "2020-1-15", "2020-2-1", 
                   "2020-2-15", "2020-3-1", "2020-3-15", "2020-4-1"))
get_data_frq(c(1,NA,2,NA,3,NA,4), dates) ## "month"
</code></pre>

<hr>
<h2 id='get_from_list'>Get from list</h2><span id='topic+get_from_list'></span>

<h3>Description</h3>

<p>Retrieve object 'what' from 'lst'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_from_list(lst, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_from_list_+3A_lst">lst</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="get_from_list_+3A_what">what</code></td>
<td>
<p>object to retrieve (by name or index)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Element of the list indicated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_from_list(list("a" = "alpha", "b" = c(1,2,3)), "a") # "alpha"
</code></pre>

<hr>
<h2 id='index_by_friday'>Find the Friday in a given week</h2><span id='topic+index_by_friday'></span>

<h3>Description</h3>

<p>Find the Friday in a given week from a sequence of Dates
Vectors should be in as.Date() format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_by_friday(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_by_friday_+3A_dates">dates</code></td>
<td>
<p>vector of dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The date of the Friday in the week of the given date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- seq.Date(from = as.Date("2020-09-21"),
                  by = "week", length.out = 10)
fridays &lt;- index_by_friday(dates)
weekdays(fridays)
</code></pre>

<hr>
<h2 id='is_in'>Find element of this_in that</h2><span id='topic+is_in'></span>

<h3>Description</h3>

<p>Find element of this_in that, ie 'this_in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_in(that, this_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_in_+3A_that">that</code></td>
<td>
<p>first object</p>
</td></tr>
<tr><td><code id="is_in_+3A_this_in">this_in</code></td>
<td>
<p>second object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical variables indicating whether the element exists in both objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>that &lt;- seq.Date(from = as.Date("2020-09-15"), by = "day", length.out = 10)
this_in &lt;- seq.Date(from = as.Date("2020-09-11"), by = "day", length.out = 10)
is_in(that, this_in)
</code></pre>

<hr>
<h2 id='last_in_month'>Last date in the month</h2><span id='topic+last_in_month'></span>

<h3>Description</h3>

<p>Return the latest date in each month for the values in 'dates'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_in_month(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_in_month_+3A_dates">dates</code></td>
<td>
<p>A sequence of dates in 'as.Date()' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last day of each month
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- seq.Date(from = as.Date("2020-09-11"),
                  by = "day", length.out = 10)
last_in_month(dates)
</code></pre>

<hr>
<h2 id='last_in_quarter'>Last date in the week</h2><span id='topic+last_in_quarter'></span>

<h3>Description</h3>

<p>Return the latest date in the quarter fop the values in 'dates'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_in_quarter(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_in_quarter_+3A_dates">dates</code></td>
<td>
<p>A sequence of dates in 'as.Date()' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last day of the quarter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- seq.Date(from = as.Date("2020-09-11"),
                  by = "day", length.out = 10)
last_in_quarter(dates)
</code></pre>

<hr>
<h2 id='last_in_week'>Last date in the week</h2><span id='topic+last_in_week'></span>

<h3>Description</h3>

<p>Return the latest date in each week for the values in 'dates'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_in_week(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_in_week_+3A_dates">dates</code></td>
<td>
<p>A sequence of dates in 'as.Date()' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last day of each week
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- seq.Date(from = as.Date("2020-09-21"),
                  by = "day", length.out = 10)
last_in_week(dates)
</code></pre>

<hr>
<h2 id='last_in_year'>Last date in the year</h2><span id='topic+last_in_year'></span>

<h3>Description</h3>

<p>Return the latest date in each year for the values in 'dates'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_in_year(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_in_year_+3A_dates">dates</code></td>
<td>
<p>A sequence of dates in 'as.Date()' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last day of the year
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- seq.Date(from = as.Date("2020-09-11"),
                  by = "day", length.out = 10)
last_in_year(dates)
</code></pre>

<hr>
<h2 id='last_obs'>Last observation</h2><span id='topic+last_obs'></span>

<h3>Description</h3>

<p>Return the last finite observation of 'x'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_obs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last_obs_+3A_x">x</code></td>
<td>
<p>data potentially with non-finite values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The last finite observation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>last_obs(c(NA,1,2,3,NA,5,NA,7,NA,NA)) ## 7
</code></pre>

<hr>
<h2 id='limit_character'>Limit Characters</h2><span id='topic+limit_character'></span>

<h3>Description</h3>

<p>limit the number of characters in a string and remove spacial characters (will not drop numbers)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit_character(x, limit = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limit_character_+3A_x">x</code></td>
<td>
<p>object containing character values</p>
</td></tr>
<tr><td><code id="limit_character_+3A_limit">limit</code></td>
<td>
<p>maximum number of characters to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character values within the limit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>limit_character("a%b+&amp;cd!efghij",limit = 3)  ## "abc"
</code></pre>

<hr>
<h2 id='long_run_var'>Long Run Variance of a VAR</h2><span id='topic+long_run_var'></span>

<h3>Description</h3>

<p>Find the long run variance of a VAR using the transition equation 'A' and shocks to observations 'Q'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_run_var(A, Q, m, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long_run_var_+3A_a">A</code></td>
<td>
<p>Transition matrix from a VAR model in companion form</p>
</td></tr>
<tr><td><code id="long_run_var_+3A_q">Q</code></td>
<td>
<p>Covariance of shocks</p>
</td></tr>
<tr><td><code id="long_run_var_+3A_m">m</code></td>
<td>
<p>Number of series in the VAR</p>
</td></tr>
<tr><td><code id="long_run_var_+3A_p">p</code></td>
<td>
<p>Number of lags in the VAR</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long_run_var(comp_form(matrix(c(.2,.1,.1,.2,0,0,0,0), 2, 4)),
             matrix(c(1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0),4,4),2, 2)
</code></pre>

<hr>
<h2 id='match_index'>Match index values</h2><span id='topic+match_index'></span>

<h3>Description</h3>

<p>Match index values of this to that
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_index(this, that)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_index_+3A_this">this</code></td>
<td>
<p>first object</p>
</td></tr>
<tr><td><code id="match_index_+3A_that">that</code></td>
<td>
<p>second object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of indexes indicating the elements that are matched to each other
</p>


<h3>Examples</h3>

<pre><code class='language-R'>match_index(c(1,2,3),c(2,3,4)) ## $that_idx: 1 2; $this_idx: 2 3
</code></pre>

<hr>
<h2 id='match_ts_dates'>Match dates between two timeseries</h2><span id='topic+match_ts_dates'></span>

<h3>Description</h3>

<p>Find values in 'new_ts' that correspond to dates in 'old_ts'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_ts_dates(old_ts, new_ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_ts_dates_+3A_old_ts">old_ts</code></td>
<td>
<p>timeseries data</p>
</td></tr>
<tr><td><code id="match_ts_dates_+3A_new_ts">new_ts</code></td>
<td>
<p>timeseries data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Timeseries data in which 'new_ts' corresponds to 'old_ts'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old_ts &lt;- ts(c(1,2,3,4), start=c(2020,1), end=c(2020,4), frequency=4) 
new_ts &lt;- ts(c(5,6,3,4), start=c(2019,4), end=c(2020,3), frequency=4) 
match_ts_dates(old_ts, new_ts) 
</code></pre>

<hr>
<h2 id='mean_na'>Return the mean</h2><span id='topic+mean_na'></span>

<h3>Description</h3>

<p>Return the mean of 'x'. If no observations, return 'NA'. This is a workaround for the fact that in data.table, ':= mean(x, na.rm = TRUE)' will return 'NaN' where there are no observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_na_+3A_x">x</code></td>
<td>
<p>data potentially with non-finite values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_na(c(1,2,3,7,9,NA)) ## 4.4
</code></pre>

<hr>
<h2 id='month_days'>Number of days in a given month</h2><span id='topic+month_days'></span>

<h3>Description</h3>

<p>Get the number of days in a month given the year and month
</p>


<h3>Usage</h3>

<pre><code class='language-R'>month_days(year, month)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="month_days_+3A_year">year</code></td>
<td>
<p>integer year value</p>
</td></tr>
<tr><td><code id="month_days_+3A_month">month</code></td>
<td>
<p>integer month value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of days in the month (integer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>month_days(2021,9) ## 30

month_days(2020,2) ## 29
</code></pre>

<hr>
<h2 id='number_finite'>Number of finite values in a column</h2><span id='topic+number_finite'></span>

<h3>Description</h3>

<p>Return the number of finite values in a column of Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_finite(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_finite_+3A_y">Y</code></td>
<td>
<p>matrix like data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of finite values per column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1,10,2)
X[3,1] &lt;- NA
number_finite(X)
</code></pre>

<hr>
<h2 id='numdum'>Dummies for Numeric Data</h2><span id='topic+numdum'></span>

<h3>Description</h3>

<p>Create dummy variables for unique numeric values in 'x'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numdum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numdum_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dummy variables for each unique value in the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numdum(c(3,3,5,3,4,3,5,4,4,5)) ## dummies for each of 3, 4, and 5
</code></pre>

<hr>
<h2 id='pct_chng'>Percent change</h2><span id='topic+pct_chng'></span>

<h3>Description</h3>

<p>Calculate the percent change in 'y' from one period to the next
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pct_chng(y, lag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pct_chng_+3A_y">y</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="pct_chng_+3A_lag">lag</code></td>
<td>
<p>number of periods for percent change</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The percentage change among the lag period
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
pct_chng(c(100,50,100,20,100,110))
</code></pre>

<hr>
<h2 id='pct_response'>Percent of responses at a given frequency</h2><span id='topic+pct_response'></span>

<h3>Description</h3>

<p>Return the percent of responses to categorical answers at a specified frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pct_response(
  dt,
  col_name = NULL,
  by = c("month", "quarter", "week"),
  date_name = "ref_date"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pct_response_+3A_dt">dt</code></td>
<td>
<p>data table of responses</p>
</td></tr>
<tr><td><code id="pct_response_+3A_col_name">col_name</code></td>
<td>
<p>name of column containing responses</p>
</td></tr>
<tr><td><code id="pct_response_+3A_by">by</code></td>
<td>
<p>frequency of response aggregation, one of '&quot;month&quot;', '&quot;quarter&quot;', '&quot;week&quot;'</p>
</td></tr>
<tr><td><code id="pct_response_+3A_date_name">date_name</code></td>
<td>
<p>name of column containing dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The percent of responses at the frequency
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- data.frame("ref_date" = seq.Date(as.Date("2000-01-01"), length.out = 100, by = "week"),
                 "response" = c(rep("yes", 20), rep("no",50),rep("yes",30)))
out &lt;- pct_response(dt, col_name = "response")
</code></pre>

<hr>
<h2 id='process'>Process Data</h2><span id='topic+process'></span>

<h3>Description</h3>

<p>Process data to ensure stationarity in long format for time series modeling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process(
  dt,
  lib,
  detrend = TRUE,
  center = TRUE,
  scale = TRUE,
  as_of = NULL,
  date_name = "ref_date",
  id_name = "series_name",
  value_name = "value",
  pub_date_name = NULL,
  ignore_numeric_names = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_+3A_dt">dt</code></td>
<td>
<p>Data in long format.</p>
</td></tr>
<tr><td><code id="process_+3A_lib">lib</code></td>
<td>
<p>Library with instructions regarding how to process data; see details.</p>
</td></tr>
<tr><td><code id="process_+3A_detrend">detrend</code></td>
<td>
<p>T/F should data be detrended (see details)?</p>
</td></tr>
<tr><td><code id="process_+3A_center">center</code></td>
<td>
<p>T/F should data be centered (i.e. de-meaned)?</p>
</td></tr>
<tr><td><code id="process_+3A_scale">scale</code></td>
<td>
<p>T/F should data be scaled (i.e. variance 1)?</p>
</td></tr>
<tr><td><code id="process_+3A_as_of">as_of</code></td>
<td>
<p>&quot;As of&quot; date at which to censor observations for backesting. This requires 'pub_date_name' is specified.</p>
</td></tr>
<tr><td><code id="process_+3A_date_name">date_name</code></td>
<td>
<p>Name of data column in the data.</p>
</td></tr>
<tr><td><code id="process_+3A_id_name">id_name</code></td>
<td>
<p>Name of ID column in the data.</p>
</td></tr>
<tr><td><code id="process_+3A_value_name">value_name</code></td>
<td>
<p>Name of value column in the data</p>
</td></tr>
<tr><td><code id="process_+3A_pub_date_name">pub_date_name</code></td>
<td>
<p>Name of publication date column in the data; required if 'as_of' specified.</p>
</td></tr>
<tr><td><code id="process_+3A_ignore_numeric_names">ignore_numeric_names</code></td>
<td>
<p>T/F ignore numeric values in matching series names in 'dt' to series names in 'lib'. This
is required for data aggregated using 'process_MF()', as lags of LHS and RHS data are tagged 0 for contemporaneous data, 
1 for one lag, 2 for 2 lags, etc. Ignoring these tags insures processing from 'lib' is correctly identified.</p>
</td></tr>
<tr><td><code id="process_+3A_silent">silent</code></td>
<td>
<p>T/F, supress warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Process data can be used to transform data to insure stationarity and to censor data for backtesting. Directions
for processing each file come from the data.table 'lib'. This table must include the columns 'series_name', 'take_logs',
and 'take_diffs'. Unique series may also be identified by a combination of 'country' and 'series_name'. Optional columns
include 'needs_SA' for series that need seasonal adjustment, 'detrend' for removing low frequency trends (nowcasting only;
detrend should not be used for long horizon forecasts), 'center' to de-mean the data, and 'scale' to scale the data. If the 
argument to 'process_wide()' of 'detrend', 'center', or 'scale' is 'FALSE', the operation will not be performed. If 'TRUE',
the function will check for the column of the same name in 'lib'. If the column exists, T/F entries from this column are used
to determine which series to transform. If the column does not exist, all series will be transformed.
</p>


<h3>Value</h3>

<p>data.table of processed values in long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- process(fred, fredlib)

LHS &lt;- fred[series_name == "gdp constant prices"]
RHS &lt;- fred[series_name != "gdp constant prices"]
dtQ &lt;- process_MF(LHS, RHS)
dt_processed &lt;- process(dtQ, fredlib)
</code></pre>

<hr>
<h2 id='process_MF'>Process mixed frequency</h2><span id='topic+process_MF'></span>

<h3>Description</h3>

<p>Process mixed frequency data for nowcasting applications by identifying the
missing observations in the contemporaneous data and replicating this pattern
of missing observations in the historical data prior to aggregation. This allows
the incorporation of all available information into the model while still using 
uniform frequency models to actually generate predictions, and can thus be applied
to a wide array of econometrics and machine learning applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_MF(
  LHS,
  RHS,
  LHS_lags = 1,
  RHS_lags = 1,
  as_of = NULL,
  frq = c("auto", "week", "month", "quarter", "year"),
  date_name = "ref_date",
  id_name = "series_name",
  value_name = "value",
  pub_date_name = "pub_date",
  return_dt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_MF_+3A_lhs">LHS</code></td>
<td>
<p>Left hand side data in long format. May include multiple LHS variables, but LHS variance MUST have the same frequency.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_rhs">RHS</code></td>
<td>
<p>Right hand side data in long format at any frequency.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_lhs_lags">LHS_lags</code></td>
<td>
<p>Number of lags of LHS variables to include in output.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_rhs_lags">RHS_lags</code></td>
<td>
<p>Number of lags of RHS variables to include in output (may be 0, indicating contemporaneous values only).</p>
</td></tr>
<tr><td><code id="process_MF_+3A_as_of">as_of</code></td>
<td>
<p>Backtesting the model &quot;as of&quot; this date; requires that 'pub_date' is specified in the data</p>
</td></tr>
<tr><td><code id="process_MF_+3A_frq">frq</code></td>
<td>
<p>Frequency of LHS data, one of 'week', 'month', 'quarter', 'year'. If not specified, the function will attempt to automatically identify the frequency.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_date_name">date_name</code></td>
<td>
<p>Name of date column in data.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_id_name">id_name</code></td>
<td>
<p>Name of ID column in the data.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_value_name">value_name</code></td>
<td>
<p>Name of value column in the data.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_pub_date_name">pub_date_name</code></td>
<td>
<p>Name of publication date in the data.</p>
</td></tr>
<tr><td><code id="process_MF_+3A_return_dt">return_dt</code></td>
<td>
<p>T/F, should the function return a 'data.table'? IF FALSE the function will return matrix data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Right hand side data will always include observations contemporaneous with LHS data. Use 'RHS_lags' to add lags
of RHS data to the output, and 'LHS_lags' to add lags of LHS data to the output. By default the function will return
data in long format designed to be used with the 'dateutils' function 'process()'. Specifying 'return_dt = FALSE' will 
return LHS variables in the matrix 'Y', RHS variables in the matrix 'X', and corresponding dates (by index) in the
date vector 'dates'.
</p>


<h3>Value</h3>

<p>data.table in long format (unless &lsquo;return_dt = FALSE'). Variables ending in &rsquo;0' are contemporaneous, ending in '1' are at one lag, '2' at two lags, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
LHS &lt;- fred[series_name == "gdp constant prices"]
RHS &lt;- fred[series_name != "gdp constant prices"]
dt &lt;- process_MF(LHS, RHS)
</code></pre>

<hr>
<h2 id='process_wide'>Process Wide Format Data</h2><span id='topic+process_wide'></span>

<h3>Description</h3>

<p>Process data in wide format for time series modeling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_wide(
  dt_wide,
  lib,
  detrend = TRUE,
  center = TRUE,
  scale = TRUE,
  date_name = "ref_date",
  ignore_numeric_names = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_wide_+3A_dt_wide">dt_wide</code></td>
<td>
<p>Data in wide format.</p>
</td></tr>
<tr><td><code id="process_wide_+3A_lib">lib</code></td>
<td>
<p>Library with instructions regarding how to process data; see details.</p>
</td></tr>
<tr><td><code id="process_wide_+3A_detrend">detrend</code></td>
<td>
<p>T/F should data be detrended (see details)?</p>
</td></tr>
<tr><td><code id="process_wide_+3A_center">center</code></td>
<td>
<p>T/F should data be centered (i.e. de-meaned)?</p>
</td></tr>
<tr><td><code id="process_wide_+3A_scale">scale</code></td>
<td>
<p>T/F should data be scaled (i.e. variance 1)?</p>
</td></tr>
<tr><td><code id="process_wide_+3A_date_name">date_name</code></td>
<td>
<p>Name of data column in the data.</p>
</td></tr>
<tr><td><code id="process_wide_+3A_ignore_numeric_names">ignore_numeric_names</code></td>
<td>
<p>T/F ignore numeric values in matching series names in 'dt' to series names in 'lib'. This
is required for data aggregated using 'process_MF()', as lags of LHS and RHS data are tagged 0 for contemporaneous data, 
1 for one lag, 2 for 2 lags, etc. Ignoring these tags insures processing from 'lib' is correctly identified.</p>
</td></tr>
<tr><td><code id="process_wide_+3A_silent">silent</code></td>
<td>
<p>T/F, supress warnings?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'process_wide()' can be used to transform wide data to insure stationarity. Censoring by pub_date requires long format. Directions
for processing each file come from the data.table 'lib'. This table must include the columns 'series_name', 'take_logs',
and 'take_diffs'. Unique series may also be identified by a combination of 'country' and 'series_name'. Optional columns
include 'needs_SA' for series that need seasonal adjustment, 'detrend' for removing low frequency trends (nowcasting only;
'detrend' should not be used for long horizon forecasts), 'center' to de-mean the data, and 'scale' to scale the data. If the 
argument to 'process_wide()' of 'detrend', 'center', or 'scale' is 'FALSE', the operation will not be performed. If 'TRUE',
the function will check for the column of the same name in 'lib'. If the column exists, T/F entries from this column are used
to determine which series to transform. If the column does not exist, all series will be transformed.
</p>


<h3>Value</h3>

<p>data.table of processed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LHS &lt;- fred[series_name == "gdp constant prices"]
RHS &lt;- fred[series_name != "gdp constant prices"]
dtQ &lt;- process_MF(LHS, RHS)
dt_wide &lt;- data.table::dcast(dtQ, ref_date ~ series_name, value.var = "value")
dt_processed &lt;- process_wide(dt_wide, fredlib)
</code></pre>

<hr>
<h2 id='rollmax'>Rolling Max</h2><span id='topic+rollmax'></span>

<h3>Description</h3>

<p>Find the rolling maximum in 'x' with span 'n'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmax(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmax_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="rollmax_+3A_n">n</code></td>
<td>
<p>Integer span</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum value of 'x' with span 'n'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rollmax(c(1,2,3), 2) ## c(2,3,3)
</code></pre>

<hr>
<h2 id='rollmean'>Rolling mean</h2><span id='topic+rollmean'></span>

<h3>Description</h3>

<p>Take the rolling mean of 'x' over 'n' elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmean(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmean_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="rollmean_+3A_n">n</code></td>
<td>
<p>span of rolling mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rolling mean of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rollmean(c(1,2,3),2) ## NA, 1.5, 2.5 
</code></pre>

<hr>
<h2 id='rollmin'>Rolling Min</h2><span id='topic+rollmin'></span>

<h3>Description</h3>

<p>Find the rolling minimum in 'x' with span 'n'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollmin(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollmin_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="rollmin_+3A_n">n</code></td>
<td>
<p>Integer span</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The minimum value of 'x' with span 'n'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rollmin(c(1,2,3),2) ## c(1,1,2)
</code></pre>

<hr>
<h2 id='row_to_list'>Convert rows to list</h2><span id='topic+row_to_list'></span>

<h3>Description</h3>

<p>Return 'Y' with each row as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_to_list(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_to_list_+3A_y">Y</code></td>
<td>
<p>matrix like data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each row as a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>row_to_list(matrix(rnorm(20),10,2))
</code></pre>

<hr>
<h2 id='run_sa'>Seasonally adjust data using seas()</h2><span id='topic+run_sa'></span>

<h3>Description</h3>

<p>Seasonaly adjust monthly or quarterly data using X-13 SEATS via seas()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_sa(x, dates, x11 = FALSE, transfunc = c("none", "auto", "log"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_sa_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="run_sa_+3A_dates">dates</code></td>
<td>
<p>dates corresponding to data 'x'</p>
</td></tr>
<tr><td><code id="run_sa_+3A_x11">x11</code></td>
<td>
<p>T/F, use x11 as opposed to X-13 SEATS</p>
</td></tr>
<tr><td><code id="run_sa_+3A_transfunc">transfunc</code></td>
<td>
<p>Data transformation, one of 'none' for no transformation, 'auto' for automatic detection, or 'log' for log transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 'adj_fact' containing seasonal factors and 'sa_final' containing seasonally adjusted data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- fred[series_name == "gdp constant prices", value]
dates &lt;- fred[series_name == "gdp constant prices", ref_date ]
run_sa(x, dates, transfunc = "log")
</code></pre>

<hr>
<h2 id='sd_na'>Return the standard deviation</h2><span id='topic+sd_na'></span>

<h3>Description</h3>

<p>Return the standard deviation of 'x'. If no observations, return 'NA'. This is a workaround for the fact that in data.table, ':= sd(x, na.rm = TRUE)' will return 'NaN' where there are no observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_na_+3A_x">x</code></td>
<td>
<p>data potentially with non-finite values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard deviation of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sd_na(c(1,2,3,NA)) ## 1
</code></pre>

<hr>
<h2 id='seas_df_long'>Seasonally adjust long format data using seas()</h2><span id='topic+seas_df_long'></span>

<h3>Description</h3>

<p>Seasonaly adjust multiple monthly or quarterly series in long format using X-13 SEATS via seas()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seas_df_long(
  df,
  sa_names,
  x11 = FALSE,
  transfunc = "none",
  series_names = "series_name",
  value_var = "value",
  date_var = "ref_date"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seas_df_long_+3A_df">df</code></td>
<td>
<p>long format dataframe</p>
</td></tr>
<tr><td><code id="seas_df_long_+3A_sa_names">sa_names</code></td>
<td>
<p>names of series to seasonally adjust</p>
</td></tr>
<tr><td><code id="seas_df_long_+3A_x11">x11</code></td>
<td>
<p>T/F, use x11 as opposed to X-13 SEATS</p>
</td></tr>
<tr><td><code id="seas_df_long_+3A_transfunc">transfunc</code></td>
<td>
<p>Data transformation, one of 'none' for no transformation, 'auto' for automatic detection, or 'log' for log transformation</p>
</td></tr>
<tr><td><code id="seas_df_long_+3A_series_names">series_names</code></td>
<td>
<p>name of column containing series names</p>
</td></tr>
<tr><td><code id="seas_df_long_+3A_value_var">value_var</code></td>
<td>
<p>name of column containing values</p>
</td></tr>
<tr><td><code id="seas_df_long_+3A_date_var">date_var</code></td>
<td>
<p>name of column containing dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with data.frames 'sa_factors' containing seasonal factors and 'values_sa' containing seasonally adjusted data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seas_df_long(fred[series_name == "gdp constant prices"], sa_names="value")
</code></pre>

<hr>
<h2 id='seas_df_wide'>Seasonally adjust wide format data using seas()</h2><span id='topic+seas_df_wide'></span>

<h3>Description</h3>

<p>Seasonaly adjust multiple monthly or quarterly series in wide format using X-13 SEATS via seas()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seas_df_wide(df, sa_cols, x11 = FALSE, transfunc = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seas_df_wide_+3A_df">df</code></td>
<td>
<p>wide format dataframe</p>
</td></tr>
<tr><td><code id="seas_df_wide_+3A_sa_cols">sa_cols</code></td>
<td>
<p>names or column indexes of series to seasonally adjust</p>
</td></tr>
<tr><td><code id="seas_df_wide_+3A_x11">x11</code></td>
<td>
<p>T/F, use x11 as opposed to X-13 SEATS</p>
</td></tr>
<tr><td><code id="seas_df_wide_+3A_transfunc">transfunc</code></td>
<td>
<p>Data transformation, one of 'none' for no transformation, 'auto' for automatic detection, or 'log' for log transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with data.frames 'sa_factors' containing seasonal factors and 'values_sa' containing seasonally adjusted data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
seas_df_wide(fred[series_name == "gdp constant prices"], sa_cols="value")
</code></pre>

<hr>
<h2 id='spline_fill'>Spline fill missing observations</h2><span id='topic+spline_fill'></span>

<h3>Description</h3>

<p>Spline fill missing observations from the first observation to the last, leaving NA observations in the head and tail
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_fill(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_fill_+3A_x">x</code></td>
<td>
<p>data with missing observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with interpolated missing observations, except at head and tail, which remain NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spline_fill_trend(c(NA,1,2,3,NA,5)) ## NA 1 2 3 4 5
</code></pre>

<hr>
<h2 id='spline_fill_trend'>Spline fill missing observations</h2><span id='topic+spline_fill_trend'></span>

<h3>Description</h3>

<p>Spline fill missing observations, designed for filling low frequency trend estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_fill_trend(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_fill_trend_+3A_x">x</code></td>
<td>
<p>data with missing observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with interpolated missing observations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spline_fill_trend(c(1,2,3,NA,5)) ## 1 2 3 4 5
</code></pre>

<hr>
<h2 id='stack_obs'>Stack time series observations in VAR format</h2><span id='topic+stack_obs'></span>

<h3>Description</h3>

<p>Stack time series observations in VAR format over
series for p lags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_obs(Dat, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_obs_+3A_dat">Dat</code></td>
<td>
<p>Data in a format convertable to a matrix</p>
</td></tr>
<tr><td><code id="stack_obs_+3A_p">p</code></td>
<td>
<p>number of lags, integer value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stacked time series obs with p lags
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rnorm(100),50,2)
Z &lt;- stack_obs(mat, 2) ## stack the dataset `mat` with two lags 
## Note: one "lag" will just return the original dataset.
</code></pre>

<hr>
<h2 id='sum_na'>Return the sum</h2><span id='topic+sum_na'></span>

<h3>Description</h3>

<p>Return the sum of 'x'. If no observations, return 'NA'. This is a workaround for the fact that in data.table, ':= sum()' will return 'NaN' where there are no observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_na_+3A_x">x</code></td>
<td>
<p>data potentially with non-finite values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum_na(c(1,2,3,NA)) # 6
</code></pre>

<hr>
<h2 id='to_ts'>Tabular data to ts() format</h2><span id='topic+to_ts'></span>

<h3>Description</h3>

<p>transform data in 'x' corresponding to dates in 'dates' to ts() format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_ts(x, dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_ts_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="to_ts_+3A_dates">dates</code></td>
<td>
<p>dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data in ts() format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,2,3,4)
dates &lt;- as.Date(c("2020-1-1","2020-2-1","2020-3-1","2020-4-1"))
to_ts(x, dates) 
</code></pre>

<hr>
<h2 id='total_response'>Number of of responses at a given frequency</h2><span id='topic+total_response'></span>

<h3>Description</h3>

<p>Return the total number of responses to categorical answers at a specified frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_response(
  dt,
  col_name = NULL,
  by = c("month", "quarter", "week"),
  date_name = "ref_date"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="total_response_+3A_dt">dt</code></td>
<td>
<p>data table of responses</p>
</td></tr>
<tr><td><code id="total_response_+3A_col_name">col_name</code></td>
<td>
<p>name of column containing responses</p>
</td></tr>
<tr><td><code id="total_response_+3A_by">by</code></td>
<td>
<p>frequency of response aggregation, one of '&quot;month&quot;', '&quot;quarter&quot;', '&quot;week&quot;'</p>
</td></tr>
<tr><td><code id="total_response_+3A_date_name">date_name</code></td>
<td>
<p>name of column containing dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of responses at the frequency
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- data.frame("ref_date" = seq.Date(as.Date("2000-01-01"), length.out = 100, by = "week"),
                 "response" = c(rep("yes", 20), rep("no",50),rep("yes",30)))
out &lt;- total_response(dt, col_name = "response")
</code></pre>

<hr>
<h2 id='try_detrend'>Remove low frequency trends from data</h2><span id='topic+try_detrend'></span>

<h3>Description</h3>

<p>Estimate low frequency trends via loess regression and remove them. If the function errors, return x (i.e. no trend)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_detrend(x, outlier_rm = TRUE, span = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_detrend_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="try_detrend_+3A_outlier_rm">outlier_rm</code></td>
<td>
<p>T/F, remove outliers to estimate trends?</p>
</td></tr>
<tr><td><code id="try_detrend_+3A_span">span</code></td>
<td>
<p>span for the loess regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data with trends removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try_detrend(c(1,3,6,7,9,11,14,15,17,18))
</code></pre>

<hr>
<h2 id='try_sa'>Seasonally adjust data using seas()</h2><span id='topic+try_sa'></span>

<h3>Description</h3>

<p>Seasonaly adjust monthly or quarterly data using X-13 SEATS via seas()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_sa(x, dates, x11 = FALSE, transfunc = "none", series_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_sa_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="try_sa_+3A_dates">dates</code></td>
<td>
<p>dates corresponding to data 'x'</p>
</td></tr>
<tr><td><code id="try_sa_+3A_x11">x11</code></td>
<td>
<p>T/F, use x11 as opposed to X-13 SEATS</p>
</td></tr>
<tr><td><code id="try_sa_+3A_transfunc">transfunc</code></td>
<td>
<p>Data transformation, one of 'none' for no transformation, 'auto' for automatic detection, or 'log' for log transformation</p>
</td></tr>
<tr><td><code id="try_sa_+3A_series_name">series_name</code></td>
<td>
<p>Include series name to print out if failure (for lapply() applications)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 'adj_fact' containing seasonal factors and 'sa_final' containing seasonally adjusted data. 
If seasonal adjsutment failed 'adj_fact' will contain zeros and 'sa_final' will contain the original data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- fred[series_name == "gdp constant prices", value]
dates &lt;- fred[series_name == "gdp constant prices", ref_date ]
try_sa(x, dates, transfunc = "log")
</code></pre>

<hr>
<h2 id='try_trend'>Estimate low frequnecy trends</h2><span id='topic+try_trend'></span>

<h3>Description</h3>

<p>Estimate low frequency trends via loess regression. If the function errors, return zeros (i.e. no trend)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_trend(x, outlier_rm = TRUE, span = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_trend_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="try_trend_+3A_outlier_rm">outlier_rm</code></td>
<td>
<p>T/F, remove outliers to estimate trends?</p>
</td></tr>
<tr><td><code id="try_trend_+3A_span">span</code></td>
<td>
<p>span for the loess regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated trend in the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try_trend(c(1,3,6,7,9,11,14,15,17,18))
</code></pre>

<hr>
<h2 id='ts_to_df'>ts() data to a dataframe</h2><span id='topic+ts_to_df'></span>

<h3>Description</h3>

<p>Transform monthly or quarterly ts() data to a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_to_df(x, end_period = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_to_df_+3A_x">x</code></td>
<td>
<p>ts() format data which is either monthly or quarterly</p>
</td></tr>
<tr><td><code id="ts_to_df_+3A_end_period">end_period</code></td>
<td>
<p>T/F, for monthly or quarterly data, should dates be indexed to the end of the period?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data in dataframe format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ts(c(1,2,3,4), start=c(2020,1), end=c(2020,4), frequency=4) 
ts_to_df(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
