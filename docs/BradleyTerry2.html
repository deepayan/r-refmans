<!DOCTYPE html><html lang="en-GB"><head><title>Help for package BradleyTerry2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BradleyTerry2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add1.BTm'><p>Add or Drop Single Terms to/from a Bradley Terry Model</p></a></li>
<li><a href='#anova.BTm'><p>Compare Nested Bradley Terry Models</p></a></li>
<li><a href='#baseball'><p>Baseball Data from Agresti (2002)</p></a></li>
<li><a href='#BTabilities'><p>Estimated Abilities from a Bradley-Terry Model</p></a></li>
<li><a href='#BTm'><p>Bradley-Terry Model and Extensions</p></a></li>
<li><a href='#CEMS'><p>Dittrich, Hatzinger and Katzenbeisser (1998, 2001) Data on Management School</p>
Preference in Europe</a></li>
<li><a href='#chameleons'><p>Male Cape Dwarf Chameleons: Measured Traits and Contest Outcomes</p></a></li>
<li><a href='#citations'><p>Statistics Journal Citation Data from Stigler (1994)</p></a></li>
<li><a href='#countsToBinomial'><p>Convert Contingency Table of Wins to Binomial Counts</p></a></li>
<li><a href='#flatlizards'><p>Augrabies Male Flat Lizards: Contest Results and Predictor Variables</p></a></li>
<li><a href='#football'><p>English Premier League Football Results 2008/9 to 2012/13</p></a></li>
<li><a href='#GenDavidson'><p>Specify a Generalised Davidson Term in a gnm Model Formula</p></a></li>
<li><a href='#glmmPQL'><p>PQL Estimation of Generalized Linear Mixed Models</p></a></li>
<li><a href='#glmmPQL.control'><p>Control Aspects of the glmmPQL Algorithm</p></a></li>
<li><a href='#icehockey'><p>College Hockey Men's Division I 2009-10 results</p></a></li>
<li><a href='#plotProportions'><p>Plot Proportions of Tied Matches and Non-tied Matches Won</p></a></li>
<li><a href='#predict.BTglmmPQL'><p>Predict Method for BTglmmPQL Objects</p></a></li>
<li><a href='#predict.BTm'><p>Predict Method for Bradley-Terry Models</p></a></li>
<li><a href='#qvcalc.BTabilities'><p>Quasi Variances for Estimated Abilities</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.BTm'><p>Residuals from a Bradley-Terry Model</p></a></li>
<li><a href='#seeds'><p>Seed Germination Data from Crowder (1978)</p></a></li>
<li><a href='#sound.fields'><p>Kousgaard (1984) Data on Pair Comparisons of Sound Fields</p></a></li>
<li><a href='#springall'><p>Springall (1973) Data on Subjective Evaluation of Flavour Strength</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Title:</td>
<td>Bradley-Terry Models</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hturner/BradleyTerry2">https://github.com/hturner/BradleyTerry2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hturner/BradleyTerry2/issues">https://github.com/hturner/BradleyTerry2/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Specify and fit the Bradley-Terry model, including structured versions in which the parameters are related to explanatory variables through a linear predictor and versions with contest-specific effects, such as a home advantage.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brglm, gtools, lme4 (&ge; 1.0), qvcalc, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>prefmod, testthat</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gnm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-02 14:39:13 UTC; hturner</td>
</tr>
<tr>
<td>Author:</td>
<td>Heather Turner [aut, cre],
  David Firth [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Heather Turner &lt;ht@heatherturner.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-03 13:50:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='add1.BTm'>Add or Drop Single Terms to/from a Bradley Terry Model</h2><span id='topic+add1.BTm'></span><span id='topic+drop1.BTm'></span>

<h3>Description</h3>

<p>Add or drop single terms within the limit specified by the <code>scope</code>
argument. For models with no random effects, compute an analysis of deviance
table, otherwise compute the Wald statistic of the parameters that have been
added to or dropped from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BTm'
add1(object, scope, scale = 0, test = c("none", "Chisq", "F"), x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add1.BTm_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from <code>"BTm"</code>.</p>
</td></tr>
<tr><td><code id="add1.BTm_+3A_scope">scope</code></td>
<td>
<p>a formula specifying the model including all terms to be
considered for adding or dropping.</p>
</td></tr>
<tr><td><code id="add1.BTm_+3A_scale">scale</code></td>
<td>
<p>an estimate of the dispersion. Not implemented for models with
random effects.</p>
</td></tr>
<tr><td><code id="add1.BTm_+3A_test">test</code></td>
<td>
<p>should a p-value be returned? The F test is only appropriate for
models with no random effects for which the dispersion has been estimated.
The Chisq test is a likelihood ratio test for models with no random effects,
otherwise a Wald test.</p>
</td></tr>
<tr><td><code id="add1.BTm_+3A_x">x</code></td>
<td>
<p>a model matrix containing columns for all terms in the scope.
Useful if <code>add1</code> is to be called repeatedly.  <strong>Warning:</strong> no checks
are done on its validity.</p>
</td></tr>
<tr><td><code id="add1.BTm_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+add1.glm">add1.glm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hierarchy is respected when considering terms to be added or dropped:
all main effects contained in a second-order interaction must remain, and so
on.
</p>
<p>In a scope formula &lsquo;<span class="samp">&#8288;.&#8288;</span>&rsquo; means &lsquo;what is already there&rsquo;.
</p>
<p>For <code>drop1</code>, a missing <code>scope</code> is taken to mean that all terms in
the model may be considered for dropping.
</p>
<p>If <code>scope</code> includes player covariates and there are players with
missing values over these covariates, then a separate ability will be
estimated for these players in <em>all</em> fitted models. Similarly if there
are missing values in any contest-level variables in <code>scope</code>, the
corresponding contests will be omitted from all models.
</p>
<p>If <code>formula</code> includes random effects, the same random effects structure
will apply to all models.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> summarizing the differences in fit
between the models.
</p>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>, <code><a href="#topic+anova.BTm">anova.BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
result &lt;- rep(1, nrow(flatlizards$contests))
BTmodel1 &lt;- BTm(result, winner, loser,
                ~ throat.PC1[..] + throat.PC3[..] + (1|..),
                data = flatlizards,
                tol = 1e-4, sigma = 2, trace = TRUE)

drop1(BTmodel1)

add1(BTmodel1, ~ . + head.length[..] + SVL[..], test = "Chisq")

BTmodel2 &lt;- update(BTmodel1, formula = ~ . + head.length[..])

drop1(BTmodel2, test = "Chisq")

</code></pre>

<hr>
<h2 id='anova.BTm'>Compare Nested Bradley Terry Models</h2><span id='topic+anova.BTm'></span>

<h3>Description</h3>

<p>Compare nested models inheriting from class <code>"BTm"</code>. For models with no
random effects, compute analysis of deviance table, otherwise compute Wald
tests of additional terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BTm'
anova(object, ..., dispersion = NULL, test = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.BTm_+3A_object">object</code></td>
<td>
<p>a fitted object of class inheriting from <code>"BTm"</code>.</p>
</td></tr>
<tr><td><code id="anova.BTm_+3A_...">...</code></td>
<td>
<p>additional <code>"BTm"</code> objects.</p>
</td></tr>
<tr><td><code id="anova.BTm_+3A_dispersion">dispersion</code></td>
<td>
<p>a value for the dispersion. Not implemented for models
with random effects.</p>
</td></tr>
<tr><td><code id="anova.BTm_+3A_test">test</code></td>
<td>
<p>optional character string (partially) matching one of
<code>"Chisq"</code>, <code>"F"</code> or <code>"Cp"</code> to specify that p-values should be
returned.  The Chisq test is a likelihood ratio test for models with no
random effects, otherwise a Wald test. Options <code>"F"</code> and <code>"Cp"</code>
are only applicable to models with no random effects, see
<code><a href="stats.html#topic+stat.anova">stat.anova()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For models with no random effects, an analysis of deviance table is computed
using <code><a href="stats.html#topic+anova.glm">anova.glm()</a></code>. Otherwise, Wald tests are computed as
detailed here.
</p>
<p>If a single object is specified, terms are added sequentially and a Wald
statistic is computed for the extra parameters. If the full model includes
player covariates and there are players with missing values over these
covariates, then the <code>NULL</code> model will include a separate ability for
these players. If there are missing values in any contest-level variables in
the full model, the corresponding contests will be omitted throughout. The
random effects structure of the full model is assumed for all sub-models.
</p>
<p>For a list of objects, consecutive pairs of models are compared by computing
a Wald statistic for the extra parameters in the larger of the two models.
</p>
<p>The Wald statistic is always based on the variance-covariance matrix of the
larger of the two models being compared.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class
<code>"data.frame"</code>.
</p>


<h3>Warning</h3>

<p>The comparison between two or more models will only be
valid if they are fitted to the same dataset. This may be a problem if there
are missing values and 's default of <code>na.action = na.omit</code> is used. An
error will be returned in this case.
</p>
<p>The same problem will occur when separate abilities have been estimated for
different subsets of players in the models being compared. However no
warning is given in this case.
</p>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>, <code><a href="#topic+add1.BTm">add1.BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
result &lt;- rep(1, nrow(flatlizards$contests))
BTmodel &lt;- BTm(result, winner, loser, ~ throat.PC1[..] + throat.PC3[..] +
               head.length[..] + (1|..), data = flatlizards,
               trace = TRUE)
anova(BTmodel)

</code></pre>

<hr>
<h2 id='baseball'>Baseball Data from Agresti (2002)</h2><span id='topic+baseball'></span>

<h3>Description</h3>

<p>Baseball results for games in the 1987 season between 7 teams in the Eastern
Division of the American League.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseball
</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations on the following 4 variables.
</p>

<dl>
<dt>home.team</dt><dd><p>a factor with levels <code>Baltimore</code>,
<code>Boston</code>, <code>Cleveland</code>, <code>Detroit</code>, <code>Milwaukee</code>, <code style="white-space: pre;">&#8288;New York&#8288;</code>, <code>Toronto</code>.</p>
</dd>
<dt>away.team</dt><dd><p>a factor with levels
<code>Baltimore</code>, <code>Boston</code>, <code>Cleveland</code>, <code>Detroit</code>,
<code>Milwaukee</code>, <code style="white-space: pre;">&#8288;New York&#8288;</code>, <code>Toronto</code>.</p>
</dd>
<dt>home.wins</dt><dd><p>a numeric vector.</p>
</dd>
<dt>away.wins</dt><dd><p>a numeric vector.</p>
</dd> </dl>


<h3>Note</h3>

<p>This dataset is in a simpler format than the one described in Firth
(2005).
</p>


<h3>Source</h3>

<p>Page 438 of Agresti, A. (2002) <em>Categorical Data Analysis</em> (2nd
Edn.). New York: Wiley.
</p>


<h3>References</h3>

<p>Firth, D. (2005) Bradley-Terry models in R.  <em>Journal of
Statistical Software</em>, <strong>12</strong>(1), 1&ndash;12.
</p>
<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The BradleyTerry2
package.  <em>Journal of Statistical Software</em>, <strong>48</strong>(9), 1&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  This reproduces the analysis in Sec 10.6 of Agresti (2002).
data(baseball) # start with baseball data as provided by package

##  Simple Bradley-Terry model, ignoring home advantage:
baseballModel1 &lt;- BTm(cbind(home.wins, away.wins), home.team, away.team,
                      data = baseball, id = "team")

##  Now incorporate the "home advantage" effect
baseball$home.team &lt;- data.frame(team = baseball$home.team, at.home = 1)
baseball$away.team &lt;- data.frame(team = baseball$away.team, at.home = 0)
baseballModel2 &lt;- update(baseballModel1, formula = ~ team + at.home)

##  Compare the fit of these two models:
anova(baseballModel1, baseballModel2)


</code></pre>

<hr>
<h2 id='BTabilities'>Estimated Abilities from a Bradley-Terry Model</h2><span id='topic+BTabilities'></span><span id='topic+print.BTabilities'></span><span id='topic+coef.BTabilities'></span><span id='topic+vcov.BTabilities'></span>

<h3>Description</h3>

<p>Computes the (baseline) ability of each player from a model object of class
<code>"BTm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BTabilities(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BTabilities_+3A_model">model</code></td>
<td>
<p>a model object for which <code>inherits(model, "BTm")</code> is
<code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The player abilities are either directly estimated by the model, in which
case the appropriate parameter estimates are returned, otherwise the
abilities are computed from the terms of the fitted model that involve
player covariates only (those indexed by <code>model$id</code> in the model
formula). Thus parameters in any other terms are assumed to be zero. If one
player has been set as the reference, then <code>predict.BTm()</code> can be used to
obtain ability estimates with non-player covariates set to other values,
see examples for <code><a href="#topic+predict.BTm">predict.BTm()</a></code>.
</p>
<p>If the abilities are structured according to a linear predictor, and if
there are player covariates with missing values, the abilities for the
corresponding players are estimated as separate parameters.  In this event
the resultant matrix has an attribute, named <code>"separate"</code>, which
identifies those players whose ability was estimated separately.  For an
example, see <code><a href="#topic+flatlizards">flatlizards()</a></code>.
</p>


<h3>Value</h3>

<p>A two-column numeric matrix of class <code>c("BTabilities", "matrix")</code>, with columns named <code>"ability"</code> and <code>"se"</code>; has one row
for each player; has attributes named <code>"vcov"</code>, <code>"modelcall"</code>,
<code>"factorname"</code> and (sometimes &mdash; see below) <code>"separate"</code>.  The
first three attributes are not printed by the method
<code>print.BTabilities</code>.
</p>


<h3>Author(s)</h3>

<p>David Firth and Heather Turner
</p>


<h3>References</h3>

<p>Firth, D. (2005) Bradley-Terry models in R.  <em>Journal of
Statistical Software</em>, <strong>12</strong>(1), 1&ndash;12.
</p>
<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The BradleyTerry2
package.  <em>Journal of Statistical Software</em>, <strong>48</strong>(9), 1&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>, <code><a href="#topic+residuals.BTm">residuals.BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### citations example

##  Convert frequencies to success/failure data
citations.sf &lt;- countsToBinomial(citations)
names(citations.sf)[1:2] &lt;- c("journal1", "journal2")

##  Fit the "standard" Bradley-Terry model
citeModel &lt;- BTm(cbind(win1, win2), journal1, journal2, data = citations.sf)
BTabilities(citeModel)

### baseball example

data(baseball) # start with baseball data as provided by package

##  Fit mode with home advantage
baseball$home.team &lt;- data.frame(team = baseball$home.team, at.home = 1)
baseball$away.team &lt;- data.frame(team = baseball$away.team, at.home = 0)
baseballModel2 &lt;- BTm(cbind(home.wins, away.wins), home.team, away.team,
                      formula = ~ team + at.home, id = "team",
                      data = baseball)
##  Estimate abilities for each team, relative to Baltimore, when
##  playing away from home:  
BTabilities(baseballModel2)

</code></pre>

<hr>
<h2 id='BTm'>Bradley-Terry Model and Extensions</h2><span id='topic+BTm'></span>

<h3>Description</h3>

<p>Fits Bradley-Terry models for pair comparison data, including models with
structured scores, order effect and missing covariate data.  Fits by either
maximum likelihood or maximum penalized likelihood (with Jeffreys-prior
penalty) when abilities are modelled exactly, or by penalized
quasi-likelihood when abilities are modelled by covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BTm(
  outcome = 1,
  player1,
  player2,
  formula = NULL,
  id = "..",
  separate.ability = NULL,
  refcat = NULL,
  family = "binomial",
  data = NULL,
  weights = NULL,
  subset = NULL,
  na.action = NULL,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  offset = NULL,
  br = FALSE,
  model = TRUE,
  x = FALSE,
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BTm_+3A_outcome">outcome</code></td>
<td>
<p>the binomial response: either a numeric vector, a factor in
which the first level denotes failure and all others success, or a
two-column matrix with the columns giving the numbers of successes and
failures.</p>
</td></tr>
<tr><td><code id="BTm_+3A_player1">player1</code></td>
<td>
<p>either an ID factor specifying the first player in each
contest, or a data.frame containing such a factor and possibly other
contest-level variables that are specific to the first player. If given in a
data.frame, the ID factor must have the name given in the <code>id</code>
argument. If a factor is specified it will be used to create such a
data.frame.</p>
</td></tr>
<tr><td><code id="BTm_+3A_player2">player2</code></td>
<td>
<p>an object corresponding to that given in <code>player1</code> for
the second player in each contest, with identical structure &ndash; in particular
factors must have identical levels.</p>
</td></tr>
<tr><td><code id="BTm_+3A_formula">formula</code></td>
<td>
<p>a formula with no left-hand-side, specifying the model for
player ability. See details for more information.</p>
</td></tr>
<tr><td><code id="BTm_+3A_id">id</code></td>
<td>
<p>the name of the ID factor.</p>
</td></tr>
<tr><td><code id="BTm_+3A_separate.ability">separate.ability</code></td>
<td>
<p>(if <code>formula</code> does not include the ID factor as
a separate term) a character vector giving the names of players whose
abilities are to be modelled individually rather than using the
specification given by <code>formula</code>.</p>
</td></tr>
<tr><td><code id="BTm_+3A_refcat">refcat</code></td>
<td>
<p>(if <code>formula</code> includes the ID factor as a separate term)
a character specifying which player to use as a reference, with the first
level of the ID factor as the default. Overrides any other contrast
specification for the ID factor.</p>
</td></tr>
<tr><td><code id="BTm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. Only the binomial family is implemented, with
either<code>"logit"</code>, <code>"probit"</code> , or <code>"cauchit"</code> link. (See
<code><a href="stats.html#topic+family">stats::family()</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="BTm_+3A_data">data</code></td>
<td>
<p>an optional object providing data required by the model. This
may be a single data frame of contest-level data or a list of data frames.
Names of data frames are ignored unless they refer to data frames specified
by <code>player1</code> and <code>player2</code>. The rows of data frames that do not
contain contest-level data must correspond to the levels of a factor used
for indexing, i.e. row 1 corresponds to level 1, etc. Note any rownames are
ignored. Objects are searched for first in the <code>data</code> object if
provided, then in the environment of <code>formula</code>. If <code>data</code> is a
list, the data frames are searched in the order given.</p>
</td></tr>
<tr><td><code id="BTm_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector of &lsquo;prior weights&rsquo;.</p>
</td></tr>
<tr><td><code id="BTm_+3A_subset">subset</code></td>
<td>
<p>an optional logical or numeric vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="BTm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when any
contest-level variables contain <code>NA</code>s. The default is the
<code>na.action</code> setting of <code>options</code>. See details for the handling of
missing values in other variables.</p>
</td></tr>
<tr><td><code id="BTm_+3A_start">start</code></td>
<td>
<p>a vector of starting values for the fixed effects.</p>
</td></tr>
<tr><td><code id="BTm_+3A_etastart">etastart</code></td>
<td>
<p>a vector of starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="BTm_+3A_mustart">mustart</code></td>
<td>
<p>a vector of starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="BTm_+3A_offset">offset</code></td>
<td>
<p>an optional offset term in the model. A vector of length equal
to the number of contests.</p>
</td></tr>
<tr><td><code id="BTm_+3A_br">br</code></td>
<td>
<p>logical.  If <code>TRUE</code> fitting will be by penalized maximum
likelihood as in Firth (1992, 1993), using <code><a href="brglm.html#topic+brglm">brglm::brglm()</a></code>,
rather than maximum likelihood using <code><a href="stats.html#topic+glm">glm()</a></code>, when abilities are
modelled exactly or when the abilities are modelled by covariates and the
variance of the random effects is estimated as zero.</p>
</td></tr>
<tr><td><code id="BTm_+3A_model">model</code></td>
<td>
<p>logical: whether or not to return the model frame.</p>
</td></tr>
<tr><td><code id="BTm_+3A_x">x</code></td>
<td>
<p>logical: whether or not to return the design matrix for the fixed
effects.</p>
</td></tr>
<tr><td><code id="BTm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list specifying contrasts for the factors in
<code>formula</code>. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="BTm_+3A_...">...</code></td>
<td>
<p>other arguments for fitting function (currently either
<code><a href="stats.html#topic+glm">glm()</a></code>, <code><a href="brglm.html#topic+brglm">brglm::brglm()</a></code>, or <code><a href="#topic+glmmPQL">glmmPQL()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each comparison to be modelled there is a 'first player' and a 'second
player' and it is assumed that one player wins while the other loses (no
allowance is made for tied comparisons).
</p>
<p>The <code><a href="#topic+countsToBinomial">countsToBinomial()</a></code> function is provided to convert a
contingency table of wins into a data frame of wins and losses for each pair
of players.
</p>
<p>The <code>formula</code> argument specifies the model for player ability and
applies to both the first player and the second player in each contest. If
<code>NULL</code> a separate ability is estimated for each player, equivalent to
setting <code>formula = reformulate(id)</code>.
</p>
<p>Contest-level variables can be specified in the formula in the usual manner,
see <code><a href="stats.html#topic+formula">formula()</a></code>. Player covariates should be included as variables
indexed by <code>id</code>, see examples. Thus player covariates must be ordered
according to the levels of the ID factor.
</p>
<p>If <code>formula</code> includes player covariates and there are players with
missing values over these covariates, then a separate ability will be
estimated for those players.
</p>
<p>When player abilities are modelled by covariates, then random player effects
should be added to the model. These should be specified in the formula using
the vertical bar notation of <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code>, see examples.
</p>
<p>When specified, it is assumed that random player effects arise from a
<code class="reqn">N(0, </code><code class="reqn"> \sigma^2)</code> distribution and
model parameters, including <code class="reqn">\sigma</code>, are estimated using PQL
(Breslow and Clayton, 1993) as implemented in the <code><a href="#topic+glmmPQL">glmmPQL()</a></code>
function.
</p>


<h3>Value</h3>

<p>An object of class <code>c("BTm", "x")</code>, where <code>"x"</code> is the
class of object returned by the model fitting function (e.g. <code>glm</code>).
Components are as for objects of class <code>"x"</code>, with additionally
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>the <code>id</code> argument.</p>
</td></tr> <tr><td><code>separate.ability</code></td>
<td>
<p>the
<code>separate.ability</code> argument.</p>
</td></tr> <tr><td><code>refcat</code></td>
<td>
<p>the <code>refcat</code>
argument.</p>
</td></tr> <tr><td><code>player1</code></td>
<td>
<p>a data frame for the first player containing the
ID factor and any player-specific contest-level variables.</p>
</td></tr> <tr><td><code>player2</code></td>
<td>
<p>a
data frame corresponding to that for <code>player1</code>.</p>
</td></tr> <tr><td><code>assign</code></td>
<td>
<p>a
numeric vector indicating which coefficients correspond to which terms in
the model.</p>
</td></tr> <tr><td><code>term.labels</code></td>
<td>
<p>labels for the model terms.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>for models with random effects, the design matrix for the
random effects. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner, David Firth
</p>


<h3>References</h3>

<p>Agresti, A. (2002) <em>Categorical Data Analysis</em> (2nd ed).  New York:
Wiley.
</p>
<p>Firth, D. (1992) Bias reduction, the Jeffreys prior and GLIM. In
<em>Advances in GLIM and Statistical Modelling</em>, Eds. Fahrmeir, L.,
Francis, B. J., Gilchrist, R. and Tutz, G., pp91&ndash;100. New York: Springer.
</p>
<p>Firth, D. (1993) Bias reduction of maximum likelihood estimates.
<em>Biometrika</em> <strong>80</strong>, 27&ndash;38.
</p>
<p>Firth, D. (2005) Bradley-Terry models in R.  <em>Journal of Statistical
Software</em>, <strong>12</strong>(1), 1&ndash;12.
</p>
<p>Stigler, S. (1994) Citation patterns in the journals of statistics and
probability.  <em>Statistical Science</em> <strong>9</strong>, 94&ndash;108.
</p>
<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The BradleyTerry2
package.  <em>Journal of Statistical Software</em>, <strong>48</strong>(9), 1&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+countsToBinomial">countsToBinomial()</a></code>, <code><a href="#topic+glmmPQL">glmmPQL()</a></code>,
<code><a href="#topic+BTabilities">BTabilities()</a></code>, <code><a href="#topic+residuals.BTm">residuals.BTm()</a></code>,
<code><a href="#topic+add1.BTm">add1.BTm()</a></code>, <code><a href="#topic+anova.BTm">anova.BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
########################################################
##  Statistics journal citation data from Stigler (1994)
##  -- see also Agresti (2002, p448)
########################################################

##  Convert frequencies to success/failure data
citations.sf &lt;- countsToBinomial(citations)
names(citations.sf)[1:2] &lt;- c("journal1", "journal2")

##  First fit the "standard" Bradley-Terry model
citeModel &lt;- BTm(cbind(win1, win2), journal1, journal2, data = citations.sf)

##  Now the same thing with a different "reference" journal
citeModel2 &lt;- update(citeModel, refcat = "JASA")
BTabilities(citeModel2)

##################################################################
##  Now an example with an order effect -- see Agresti (2002) p438
##################################################################
data(baseball) # start with baseball data as provided by package

##  Simple Bradley-Terry model, ignoring home advantage:
baseballModel1 &lt;- BTm(cbind(home.wins, away.wins), home.team, away.team,
                      data = baseball, id = "team")

##  Now incorporate the "home advantage" effect
baseball$home.team &lt;- data.frame(team = baseball$home.team, at.home = 1)
baseball$away.team &lt;- data.frame(team = baseball$away.team, at.home = 0)
baseballModel2 &lt;- update(baseballModel1, formula = ~ team + at.home)

##  Compare the fit of these two models:
anova(baseballModel1, baseballModel2)

##
## For a more elaborate example with both player-level and contest-level
## predictor variables, see help(chameleons).
##

</code></pre>

<hr>
<h2 id='CEMS'>Dittrich, Hatzinger and Katzenbeisser (1998, 2001) Data on Management School
Preference in Europe</h2><span id='topic+CEMS'></span>

<h3>Description</h3>

<p><em>Community of European management schools</em> (CEMS) data as used in the
paper by Dittrich et al. (1998, 2001), re-formatted for use with
<code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEMS
</code></pre>


<h3>Format</h3>

<p>A list containing three data frames, <code>CEMS$preferences</code>,
<code>CEMS$students</code> and <code>CEMS$schools</code>.
</p>
<p>The <code>CEMS$preferences</code> data frame has <code>303 * 15 = 4505</code>
observations (15 possible comparisons, for each of 303 students) on the
following 8 variables: </p>

<dl>
<dt>student</dt><dd><p>a factor with
levels <code>1:303</code></p>
</dd>
<dt>school1</dt><dd><p>a factor with levels
<code>c("Barcelona", "London", "Milano", "Paris", "St.Gallen", "Stockholm")</code>; the first management school in a comparison</p>
</dd>
<dt>school2</dt><dd><p>a factor with the same levels as <code>school1</code>; the
second management school in a comparison</p>
</dd>
<dt>win1</dt><dd><p>integer (value
0 or 1) indicating whether <code>school1</code> was preferred to <code>school2</code></p>
</dd>
<dt>win2</dt><dd><p>integer (value 0 or 1) indicating whether <code>school2</code>
was preferred to <code>school1</code></p>
</dd>
<dt>tied</dt><dd><p>integer (value 0 or 1)
indicating whether no preference was expressed</p>
</dd>
<dt>win1.adj</dt><dd><p>numeric, equal to <code>win1 + tied/2</code></p>
</dd>
<dt>win2.adj</dt><dd><p>numeric, equal to <code>win2 + tied/2</code></p>
</dd> </dl>

<p>The <code>CEMS$students</code> data frame has 303 observations (one for each
student) on the following 8 variables: </p>

<dl>
<dt>STUD</dt><dd><p>a
factor with levels <code>c("other", "commerce")</code>, the student's main
discipline of study</p>
</dd>
<dt>ENG</dt><dd><p>a factor with levels <code>c("good, poor")</code>, indicating the student's knowledge of English</p>
</dd>
<dt>FRA</dt><dd><p>a
factor with levels <code>c("good, poor")</code>, indicating the student's
knowledge of French</p>
</dd>
<dt>SPA</dt><dd><p>a factor with levels <code>c("good, poor")</code>, indicating the student's knowledge of Spanish</p>
</dd>
<dt>ITA</dt><dd><p>a
factor with levels <code>c("good, poor")</code>, indicating the student's
knowledge of Italian</p>
</dd>
<dt>WOR</dt><dd><p>a factor with levels <code>c("no", "yes")</code>, whether the student was in full-time employment while studying</p>
</dd>
<dt>DEG</dt><dd><p>a factor with levels <code>c("no", "yes")</code>, whether the
student intended to take an international degree</p>
</dd>
<dt>SEX</dt><dd><p>a
factor with levels <code>c("female", "male")</code> </p>
</dd> </dl>

<p>The <code>CEMS$schools</code> data frame has 6 observations (one for each
management school) on the following 7 variables: </p>

<dl>
<dt>Barcelona</dt><dd><p>numeric (value 0 or 1)</p>
</dd>
<dt>London</dt><dd><p>numeric (value 0 or 1)</p>
</dd>
<dt>Milano</dt><dd><p>numeric
(value 0 or 1)</p>
</dd> <dt>Paris</dt><dd><p>numeric (value 0 or 1)</p>
</dd>
<dt>St.Gallen</dt><dd><p>numeric (value 0 or 1)</p>
</dd>
<dt>Stockholm</dt><dd><p>numeric (value 0 or 1)</p>
</dd>
<dt>LAT</dt><dd><p>numeric
(value 0 or 1) indicating a 'Latin' city</p>
</dd> </dl>


<h3>Details</h3>

<p>The variables <code>win1.adj</code> and <code>win2.adj</code> are provided in order to
allow a simple way of handling ties (in which a tie counts as half a win and
half a loss), which is slightly different numerically from the Davidson
(1970) method that is used by Dittrich et al. (1998): see the examples.
</p>


<h3>Author(s)</h3>

<p>David Firth
</p>


<h3>Source</h3>

<p>Royal Statistical Society datasets website, at
<a href="https://rss.onlinelibrary.wiley.com/hub/journal/14679876/series-c-datasets/pre_2016">https://rss.onlinelibrary.wiley.com/hub/journal/14679876/series-c-datasets/pre_2016</a>.
</p>


<h3>References</h3>

<p>Davidson, R. R. (1970) Extending the Bradley-Terry model to
accommodate ties in paired comparison experiments.  <em>Journal of the
American Statistical Association</em> <strong>65</strong>, 317&ndash;328.
</p>
<p>Dittrich, R., Hatzinger, R. and Katzenbeisser, W. (1998) Modelling the
effect of subject-specific covariates in paired comparison studies with an
application to university rankings.  <em>Applied Statistics</em> <strong>47</strong>,
511&ndash;525.
</p>
<p>Dittrich, R., Hatzinger, R. and Katzenbeisser, W. (2001) Corrigendum:
Modelling the effect of subject-specific covariates in paired comparison
studies with an application to university rankings. <em>Applied
Statistics</em> <strong>50</strong>, 247&ndash;249.
</p>
<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The BradleyTerry2
package.  <em>Journal of Statistical Software</em>, <strong>48</strong>(9), 1&ndash;21.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
##  Fit the standard Bradley-Terry model, using the simple 'add 0.5'
##  method to handle ties:
##
table3.model &lt;-  BTm(outcome = cbind(win1.adj, win2.adj),
                     player1 = school1, player2 = school2,
                     formula = ~.. , refcat = "Stockholm",
                     data = CEMS)
##  The results in Table 3 of Dittrich et al (2001) are reproduced
##  approximately by a simple re-scaling of the estimates:
table3 &lt;- summary(table3.model)$coef[, 1:2]/1.75
print(table3)
##
##  Now fit the 'final model' from Table 6 of Dittrich et al.:
##
table6.model &lt;-  BTm(outcome = cbind(win1.adj, win2.adj),
                     player1 = school1, player2 = school2,
                     formula = ~ .. +
                         WOR[student] * Paris[..] +
                         WOR[student] * Milano[..] +
                         WOR[student] * Barcelona[..] +
                         DEG[student] * St.Gallen[..] +
                         STUD[student] * Paris[..] +
                         STUD[student] * St.Gallen[..] +
                         ENG[student] * St.Gallen[..] +
                         FRA[student] * London[..] +
                         FRA[student] * Paris[..] +
                         SPA[student] * Barcelona[..] +
                         ITA[student] * London[..] +
                         ITA[student] * Milano[..] +
                         SEX[student] * Milano[..],
                     refcat = "Stockholm",
                     data = CEMS)
##
##  Again re-scale to reproduce approximately Table 6 of Dittrich et
##  al. (2001):
##
table6 &lt;- summary(table6.model)$coef[, 1:2]/1.75
print(table6)
##
## Not run: 
##  Now the slightly simplified model of Table 8 of Dittrich et al. (2001):
##
table8.model &lt;-  BTm(outcome = cbind(win1.adj, win2.adj),
                     player1 = school1, player2 = school2,
                     formula = ~ .. +
                         WOR[student] * LAT[..] +
                         DEG[student] * St.Gallen[..] +
                         STUD[student] * Paris[..] +
                         STUD[student] * St.Gallen[..] +
                         ENG[student] * St.Gallen[..] +
                         FRA[student] * London[..] +
                         FRA[student] * Paris[..] +
                         SPA[student] * Barcelona[..] +
                         ITA[student] * London[..] +
                         ITA[student] * Milano[..] +
                         SEX[student] * Milano[..],
                     refcat = "Stockholm",
                     data = CEMS)
table8 &lt;- summary(table8.model)$coef[, 1:2]/1.75
##
##  Notice some larger than expected discrepancies here (the coefficients
##  named "..Barcelona", "..Milano" and "..Paris") from the results in
##  Dittrich et al. (2001).  Apparently a mistake was made in Table 8 of
##  the published Corrigendum note (R. Dittrich personal communication,
##  February 2010).
##
print(table8)

## End(Not run)

</code></pre>

<hr>
<h2 id='chameleons'>Male Cape Dwarf Chameleons: Measured Traits and Contest Outcomes</h2><span id='topic+chameleons'></span>

<h3>Description</h3>

<p>Data as used in the study by Stuart-Fox et al. (2006).  Physical
measurements made on 35 male Cape dwarf chameleons, and the results of 106
inter-male contests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chameleons
</code></pre>


<h3>Format</h3>

<p>A list containing three data frames: <code>chameleons$winner</code>,
<code>chameleons$loser</code> and <code>chameleons$predictors</code>.
</p>
<p>The <code>chameleons$winner</code> and <code>chameleons$loser</code> data frames each
have 106 observations (one per contest) on the following 4 variables:
</p>

<dl>
<dt>ID</dt><dd><p>a factor with 35 levels <code>C01</code>, <code>C02</code>,
... , <code>C43</code>, the identity of the winning (or losing) male in each
contest</p>
</dd>
<dt>prev.wins.1</dt><dd><p>integer (values 0 or 1), did the
winner/loser of this contest win in an immediately previous contest?</p>
</dd>
<dt>prev.wins.2</dt><dd><p>integer (values 0, 1 or 2), how many of his
(maximum) previous 2 contests did each male win?</p>
</dd>
<dt>prev.wins.all</dt><dd><p>integer, how many previous contests has each
male won?</p>
</dd> </dl>

<p>The <code>chameleons$predictors</code> data frame has 35 observations, one for
each male involved in the contests, on the following 7 variables:
</p>

<dl>
<dt>ch.res</dt><dd><p>numeric, residuals of casque height regression on
<code>SVL</code>, i.e. relative height of the bony part on the top of the
chameleons' heads</p>
</dd>
<dt>jl.res</dt><dd><p>numeric, residuals of jaw length
regression on <code>SVL</code></p>
</dd>
<dt>tl.res</dt><dd><p>numeric, residuals of tail
length regression on <code>SVL</code></p>
</dd>
<dt>mass.res</dt><dd><p>numeric, residuals
of body mass regression on <code>SVL</code> (body condition)</p>
</dd>
<dt>SVL</dt><dd><p>numeric, snout-vent length (body size)</p>
</dd>
<dt>prop.main</dt><dd><p>numeric, proportion (arcsin transformed) of area of
the flank occupied by the main pink patch on the flank</p>
</dd>
<dt>prop.patch</dt><dd><p>numeric, proportion (arcsin transformed) of area
of the flank occupied by the entire flank patch</p>
</dd> </dl>


<h3>Details</h3>

<p>The published paper mentions 107 contests, but only 106 contests are
included here.  Contest number 16 was deleted from the data used to fit the
models, because it involved a male whose predictor-variables were incomplete
(and it was the only contest involving that lizard, so it is uninformative).
</p>


<h3>Author(s)</h3>

<p>David Firth
</p>


<h3>Source</h3>

<p>The data were obtained by Dr Devi Stuart-Fox,
<a href="https://devistuartfox.com/">https://devistuartfox.com/</a>,
and they are reproduced here with her kind permission.
</p>
<p>These are the same data that were used in
</p>
<p>Stuart-Fox, D. M., Firth, D., Moussalli, A. and Whiting, M. J. (2006)
Multiple signals in chameleon contests: designing and analysing animal
contests as a tournament. <em>Animal Behaviour</em> <strong>71</strong>, 1263&ndash;1271.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## Reproduce Table 3 from page 1268 of the above paper:
##
summary(chameleon.model &lt;- BTm(player1 = winner, player2 = loser,
  formula = ~ prev.wins.2 + ch.res[ID] + prop.main[ID] + (1|ID), id = "ID",
  data = chameleons))
head(BTabilities(chameleon.model))
##
## Note that, although a per-chameleon random effect is specified as in the
## above [the term "+ (1|ID)"], the estimated variance for that random
## effect turns out to be zero in this case.  The "prior experience"
## effect ["+ prev.wins.2"] in this analysis has explained most of the
## variation, leaving little for the ID-specific predictors to do.
## Despite that, two of the ID-specific predictors do emerge as
## significant.
##
## Test whether any of the other ID-specific predictors has an effect:
##
add1(chameleon.model, ~ . + jl.res[ID] + tl.res[ID] + mass.res[ID] +
  SVL[ID] + prop.patch[ID]) 

</code></pre>

<hr>
<h2 id='citations'>Statistics Journal Citation Data from Stigler (1994)</h2><span id='topic+citations'></span>

<h3>Description</h3>

<p>Extracted from a larger table in Stigler (1994).  Inter-journal citation
counts for four journals, &ldquo;Biometrika&rdquo;, &ldquo;Comm Statist.&rdquo;,
&ldquo;JASA&rdquo; and &ldquo;JRSS-B&rdquo;, as used on p448 of Agresti (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>citations
</code></pre>


<h3>Format</h3>

<p>A 4 by 4 contingency table of citations, cross-classified by the
factors <code>cited</code> and <code>citing</code> each with levels <code>Biometrika</code>,
<code style="white-space: pre;">&#8288;Comm Statist&#8288;</code>, <code>JASA</code>, and <code>JRSS-B</code>.</p>


<h3>Details</h3>

<p>In the context of paired comparisons, the &lsquo;winner&rsquo; is the cited
journal and the &lsquo;loser&rsquo; is the one doing the citing.
</p>


<h3>Source</h3>

<p>Agresti, A. (2002) <em>Categorical Data Analysis</em> (2nd ed).  New
York: Wiley.
</p>


<h3>References</h3>

<p>Firth, D. (2005) Bradley-Terry models in R.  <em>Journal of
Statistical Software</em> <strong>12</strong>(1), 1&ndash;12.
</p>
<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The BradleyTerry2
package.  <em>Journal of Statistical Software</em>, <strong>48</strong>(9), 1&ndash;21.
</p>
<p>Stigler, S. (1994) Citation patterns in the journals of statistics and
probability.  <em>Statistical Science</em> <strong>9</strong>, 94&ndash;108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  Data as a square table, as in Agresti p448
citations

##
## Convert frequencies to success/failure data:
##
citations.sf &lt;- countsToBinomial(citations)
names(citations.sf)[1:2] &lt;- c("journal1", "journal2")

## Standard Bradley-Terry model fitted to these data
citeModel &lt;-  BTm(cbind(win1, win2), journal1, journal2,
                  data = citations.sf)

</code></pre>

<hr>
<h2 id='countsToBinomial'>Convert Contingency Table of Wins to Binomial Counts</h2><span id='topic+countsToBinomial'></span>

<h3>Description</h3>

<p>Convert a contingency table of wins to a four-column data frame containing
the number of wins and losses for each pair of players.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countsToBinomial(xtab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countsToBinomial_+3A_xtab">xtab</code></td>
<td>
<p>a contingency table of wins cross-classified by &ldquo;winner&rdquo;
and &ldquo;loser&rdquo;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with four columns </p>
<table role = "presentation">
<tr><td><code>player1</code></td>
<td>
<p> the first player in
the contest. </p>
</td></tr> <tr><td><code>player2</code></td>
<td>
<p> the second player in the contest. </p>
</td></tr>
<tr><td><code>win1</code></td>
<td>
<p> the number of times <code>player1</code> won. </p>
</td></tr> <tr><td><code>win2</code></td>
<td>
<p> the
number of times <code>player2</code> won. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
########################################################
##  Statistics journal citation data from Stigler (1994)
##  -- see also Agresti (2002, p448)
########################################################
citations

## Convert frequencies to success/failure data
citations.sf &lt;- countsToBinomial(citations)
names(citations.sf)[1:2] &lt;- c("journal1", "journal2")
citations.sf

</code></pre>

<hr>
<h2 id='flatlizards'>Augrabies Male Flat Lizards: Contest Results and Predictor Variables</h2><span id='topic+flatlizards'></span>

<h3>Description</h3>

<p>Data collected at Augrabies Falls National Park (South Africa) in
September-October 2002, on the contest performance and background attributes
of 77 male flat lizards (<em>Platysaurus broadleyi</em>).  The results of
exactly 100 contests were recorded, along with various measurements made on
each lizard.  Full details of the study are in Whiting et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatlizards
</code></pre>


<h3>Format</h3>

<p>This dataset is a list containing two data frames:
<code>flatlizards$contests</code> and <code>flatlizards$predictors</code>.
</p>
<p>The <code>flatlizards$contests</code> data frame has 100 observations on the
following 2 variables: </p>

<dl>
<dt>winner</dt><dd><p>a factor with 77
levels <code>lizard003</code> ... <code>lizard189</code>.</p>
</dd>
<dt>loser</dt><dd><p>a factor
with the same 77 levels <code>lizard003</code> ... <code>lizard189</code>.</p>
</dd> </dl>

<p>The <code>flatlizards$predictors</code> data frame has 77 observations (one for
each of the 77 lizards) on the following 18 variables: </p>

<dl>
<dt>id</dt><dd><p>factor with 77 levels (3 5 6 ... 189), the lizard
identifiers.</p>
</dd>
<dt>throat.PC1</dt><dd><p>numeric, the first principal
component of the throat spectrum.</p>
</dd>
<dt>throat.PC2</dt><dd><p>numeric, the
second principal component of the throat spectrum.</p>
</dd>
<dt>throat.PC3</dt><dd><p>numeric, the third principal component of the
throat spectrum.</p>
</dd>
<dt>frontleg.PC1</dt><dd><p>numeric, the first principal
component of the front-leg spectrum.</p>
</dd>
<dt>frontleg.PC2</dt><dd><p>numeric,
the second principal component of the front-leg spectrum.</p>
</dd>
<dt>frontleg.PC3</dt><dd><p>numeric, the third principal component of the
front-leg spectrum.</p>
</dd>
<dt>badge.PC1</dt><dd><p>numeric, the first principal
component of the ventral colour patch spectrum.</p>
</dd>
<dt>badge.PC2</dt><dd><p>numeric, the second principal component of the
ventral colour patch spectrum.</p>
</dd>
<dt>badge.PC3</dt><dd><p>numeric, the third
principal component of the ventral colour patch spectrum.</p>
</dd>
<dt>badge.size</dt><dd><p>numeric, a measure of the area of the ventral
colour patch.</p>
</dd>
<dt>testosterone</dt><dd><p>numeric, a measure of blood
testosterone concentration.</p>
</dd>
<dt>SVL</dt><dd><p>numeric, the snout-vent
length of the lizard.</p>
</dd>
<dt>head.length</dt><dd><p>numeric, head length.</p>
</dd>
<dt>head.width</dt><dd><p>numeric, head width.</p>
</dd>
<dt>head.height</dt><dd><p>numeric, head height.</p>
</dd>
<dt>condition</dt><dd><p>numeric, a measure of body condition.</p>
</dd>
<dt>repro.tactic</dt><dd><p>a factor indicating reproductive tactic; levels
are <code>resident</code> and <code>floater</code>.</p>
</dd> </dl>


<h3>Details</h3>

<p>There were no duplicate contests (no pair of lizards was seen fighting more
than once), and there were no tied contests (the result of each contest was
clear).
</p>
<p>The variables <code>head.length</code>, <code>head.width</code>, <code>head.height</code> and
<code>condition</code> were all computed as residuals (of directly measured head
length, head width, head height and body mass index, respectively) from
simple least-squares regressions on <code>SVL</code>.
</p>
<p>Values of some predictors are missing (<code>NA</code>) for some lizards,
&lsquo;at random&rsquo;, because of instrument problems unconnected with the
value of the measurement being made.
</p>


<h3>Source</h3>

<p>The data were collected by Dr Martin Whiting,
<a href="http://whitinglab.com/people/martin-whiting/">http://whitinglab.com/people/martin-whiting/</a>, and they appear here
with his kind permission.
</p>


<h3>References</h3>

<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The
BradleyTerry2 package.  <em>Journal of Statistical Software</em>,
<strong>48</strong>(9), 1&ndash;21.
</p>
<p>Whiting, M. J., Stuart-Fox, D. M., O'Connor, D., Firth, D., Bennett, N. C.
and Blomberg, S. P. (2006). Ultraviolet signals ultra-aggression in a
lizard. <em>Animal Behaviour</em> <strong>72</strong>, 353&ndash;363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
##  Fit the standard Bradley-Terry model, using the bias-reduced
##  maximum likelihood method:
##
result &lt;- rep(1, nrow(flatlizards$contests))
BTmodel &lt;- BTm(result, winner, loser, br = TRUE, data = flatlizards$contests)
summary(BTmodel)
##
##  That's fairly useless, though, because of the rather small
##  amount of data on each lizard.  And really the scientific
##  interest is not in the abilities of these particular 77
##  lizards, but in the relationship between ability and the
##  measured predictor variables.
##
##  So next fit (by maximum likelihood) a "structured" B-T model in
##  which abilities are determined by a linear predictor.
##
##  This reproduces results reported in Table 1 of Whiting et al. (2006):
##
Whiting.model &lt;- BTm(result, winner, loser, 
                     ~ throat.PC1[..] + throat.PC3[..] +
                         head.length[..] + SVL[..],
                     data = flatlizards)
summary(Whiting.model)
##
##  Equivalently, fit the same model using glmmPQL:
##
Whiting.model &lt;- BTm(result, winner, loser,
                     ~ throat.PC1[..] + throat.PC3[..] +
                         head.length[..] + SVL[..] + (1|..), 
                     sigma = 0, sigma.fixed = TRUE, data = flatlizards)
summary(Whiting.model)
##
##  But that analysis assumes that the linear predictor formula for
##  abilities is _perfect_, i.e., that there is no error in the linear
##  predictor.  This will always be unrealistic.
##
##  So now fit the same predictor but with a normally distributed error
##  term --- a generalized linear mixed model --- by using the BTm
##  function instead of glm.
##
Whiting.model2 &lt;- BTm(result, winner, loser,
                      ~ throat.PC1[..] + throat.PC3[..] +
                          head.length[..] + SVL[..] + (1|..), 
                      data = flatlizards, trace = TRUE)
summary(Whiting.model2)
##
##  The estimated coefficients (of throat.PC1, throat.PC3,
##  head.length and SVL are not changed substantially by
##  the recognition of an error term in the model; but the estimated
##  standard errors are larger, as expected.  The main conclusions from
##  Whiting et al. (2006) are unaffected.
##
##  With the normally distributed random error included, it is perhaps
##  at least as natural to use probit rather than logit as the link
##  function:
##
require(stats)
Whiting.model3 &lt;- BTm(result, winner, loser, 
                      ~ throat.PC1[..] + throat.PC3[..] +
                          head.length[..] + SVL[..] + (1|..),
                      family = binomial(link = "probit"),
                      data = flatlizards, trace = TRUE)
summary(Whiting.model3)
BTabilities(Whiting.model3)
##  Note the "separate" attribute here, identifying two lizards with
##  missing values of at least one predictor variable 
##
##  Modulo the usual scale change between logit and probit, the results
##  are (as expected) very similar to Whiting.model2.

</code></pre>

<hr>
<h2 id='football'>English Premier League Football Results 2008/9 to 2012/13</h2><span id='topic+football'></span>

<h3>Description</h3>

<p>The win/lose/draw results for five seasons of the English Premier League
football results, from 2008/9 to 2012/13
</p>


<h3>Usage</h3>

<pre><code class='language-R'>football
</code></pre>


<h3>Format</h3>

<p>A data frame with 1881 observations on the following 4 variables.
</p>

<dl>
<dt>season</dt><dd><p>a factor with levels <code>2008-9</code>,
<code>2009-10</code>, <code>2010-11</code>, <code>2011-12</code>, <code>2012-13</code></p>
</dd>
<dt>home</dt><dd><p>a factor specifying the home team, with 29 levels
<code>Ars</code> (Arsenal), ... , <code>Wol</code> (Wolverhampton)</p>
</dd>
<dt>away</dt><dd><p>a factor specifying the away team, with the same levels
as <code>home</code>.</p>
</dd>
<dt>result</dt><dd><p>a numeric vector giving the result
for the home team: 1 for a win, 0 for a draw, -1 for a loss.</p>
</dd> </dl>


<h3>Details</h3>

<p>In each season, there are 20 teams, each of which plays one home game and
one away game against all the other teams in the league. The results in 380
games per season.
</p>


<h3>Source</h3>

<p>These data were downloaded from http://soccernet.espn.go.com in
2013. The site has since moved and the new site does not appear to have an
equivalent source.
</p>


<h3>References</h3>

<p>Davidson, R. R. (1970). On extending the Bradley-Terry model to
accommodate ties in paired comparison experiments. <em>Journal of the
American Statistical Association</em>, <strong>65</strong>, 317&ndash;328.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenDavidson">GenDavidson()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### example requires gnm
if (require(gnm)) {
    ### convert to trinomial counts
    football.tri &lt;- expandCategorical(football, "result", idvar = "match")
    head(football.tri)

    ### add variable to indicate whether team playing at home
    football.tri$at.home &lt;- !logical(nrow(football.tri))

    ### fit Davidson model for ties
    ###  - subset to first and last season for illustration
    Davidson &lt;- gnm(count ~
        GenDavidson(result == 1, result == 0, result == -1,
                    home:season, away:season,
                    home.adv = ~1, tie.max = ~1,
                    at.home1 = at.home, at.home2 = !at.home) - 1,
        eliminate = match, family = poisson, data = football.tri,
        subset = season %in% c("2008-9", "2012-13"))

    ### see ?GenDavidson for further analysis
}

</code></pre>

<hr>
<h2 id='GenDavidson'>Specify a Generalised Davidson Term in a gnm Model Formula</h2><span id='topic+GenDavidson'></span>

<h3>Description</h3>

<p>GenDavidson is a function of class <code>"nonlin"</code> to specify a generalised
Davidson term in the formula argument to <code><a href="gnm.html#topic+gnm">gnm::gnm()</a></code>, providing a
model for paired comparison data where ties are a possible outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenDavidson(
  win,
  tie,
  loss,
  player1,
  player2,
  home.adv = NULL,
  tie.max = ~1,
  tie.mode = NULL,
  tie.scale = NULL,
  at.home1 = NULL,
  at.home2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenDavidson_+3A_win">win</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if player1 wins, <code>FALSE</code>
otherwise.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_tie">tie</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if the outcome is a tie,
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_loss">loss</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if player1 loses, <code>FALSE</code>
otherwise.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_player1">player1</code></td>
<td>
<p>an ID factor specifying the first player in each contest,
with the same set of levels as <code>player2</code>.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_player2">player2</code></td>
<td>
<p>an ID factor specifying the second player in each contest,
with the same set of levels as <code>player2</code>.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_home.adv">home.adv</code></td>
<td>
<p>a formula for the parameter corresponding to the home
advantage effect. If <code>NULL</code>, no home advantage effect is estimated.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_tie.max">tie.max</code></td>
<td>
<p>a formula for the parameter corresponding to the maximum tie
probability.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_tie.mode">tie.mode</code></td>
<td>
<p>a formula for the parameter corresponding to the location of
maximum tie probability, in terms of the probability that <code>player1</code>
wins, given the outcome is not a draw.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_tie.scale">tie.scale</code></td>
<td>
<p>a formula for the parameter corresponding to the scale of
dependence of the tie probability on the probability that <code>player1</code>
wins, given the outcome is not a draw.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_at.home1">at.home1</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if <code>player1</code> is at home,
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="GenDavidson_+3A_at.home2">at.home2</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if <code>player2</code> is at home,
<code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GenDavidson</code> specifies a generalisation of the Davidson model (1970)
for paired comparisons where a tie is a possible outcome. It is designed for
modelling trinomial counts corresponding to the win/draw/loss outcome for
each contest, which are assumed Poisson conditional on the total count for
each match. Since this total must be one, the expected counts are
equivalently the probabilities for each possible outcome, which are modelled
on the log scale: </p>
<p style="text-align: center;"><code class="reqn">\log(p(i \textrm{beats} j)_k) = \theta_{ijk} +
\log(\mu\alpha_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(p(draw)_k) = \theta_{ijk} + \delta + c + </code>
</p>
<p style="text-align: center;"><code class="reqn">
\sigma(\pi\log(\mu\alpha_i) - (1 - \pi)log(\alpha_j)) + </code>
</p>
<p style="text-align: center;"><code class="reqn"> (1 -
\sigma)(\log(\mu\alpha_i + \alpha_j))</code>
</p>
 <p style="text-align: center;"><code class="reqn">\log(p(j \textrm{beats}
i)_k) = \theta_{ijk} + </code>
</p>
<p style="text-align: center;"><code class="reqn"> log(\alpha_j)</code>
</p>
<p> Here <code class="reqn">\theta_{ijk}</code> is a structural parameter
to fix the trinomial totals; <code class="reqn">\mu</code> is the home advantage parameter;
<code class="reqn">\alpha_i</code> and <code class="reqn">\alpha_j</code> are the abilities of
players <code class="reqn">i</code> and <code class="reqn">j</code> respectively; <code class="reqn">c</code> is a function of the
parameters such that <code class="reqn">\textrm{expit}(\delta)</code> is the
maximum probability of a tie, <code class="reqn">\sigma</code> scales the dependence of
the probability of a tie on the relative abilities and <code class="reqn">\pi</code> allows
for asymmetry in this dependence.
</p>
<p>For parameters that must be positive (<code class="reqn">\alpha_i, \sigma, \mu</code>), the log is estimated, while for parameters that must be between
zero and one (<code class="reqn">\delta, \pi</code>), the logit is estimated, as illustrated in
the example.
</p>


<h3>Value</h3>

<p>A list with the anticipated components of a &quot;nonlin&quot; function:
</p>
<table role = "presentation">
<tr><td><code>predictors</code></td>
<td>
<p> the formulae for the different parameters and the ID
factors for player 1 and player 2. </p>
</td></tr> <tr><td><code>variables</code></td>
<td>
<p> the outcome
variables and the &ldquo;at home&rdquo; variables, if specified.  </p>
</td></tr> <tr><td><code>common</code></td>
<td>
<p> an index to specify that common effects are to be estimated for the
players. </p>
</td></tr> <tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical
expression of the term, given labels for the predictors.</p>
</td></tr> <tr><td><code>start</code></td>
<td>
<p> a
function to generate starting values for the parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>References</h3>

<p>Davidson, R. R. (1970). On extending the Bradley-Terry model to
accommodate ties in paired comparison experiments. <em>Journal of the
American Statistical Association</em>, <strong>65</strong>, 317&ndash;328.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+football">football()</a></code>, <code><a href="#topic+plotProportions">plotProportions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### example requires gnm
if (require(gnm)) {
    ### convert to trinomial counts
    football.tri &lt;- expandCategorical(football, "result", idvar = "match")
    head(football.tri)

    ### add variable to indicate whether team playing at home
    football.tri$at.home &lt;- !logical(nrow(football.tri))

    ### fit shifted &amp; scaled Davidson model
    ###  - subset to first and last season for illustration
    shifScalDav &lt;- gnm(count ~
        GenDavidson(result == 1, result == 0, result == -1,
                    home:season, away:season, home.adv = ~1,
                    tie.max = ~1, tie.scale = ~1, tie.mode = ~1,
                    at.home1 = at.home,
                    at.home2 = !at.home) - 1,
        eliminate = match, family = poisson, data = football.tri,
        subset = season %in% c("2008-9", "2012-13"))

    ### look at coefs
    coef &lt;- coef(shifScalDav)
    ## home advantage
    exp(coef["home.adv"])
    ## max p(tie)
    plogis(coef["tie.max"])
    ## mode p(tie)
    plogis(coef["tie.mode"])
    ## scale relative to Davidson of dependence of p(tie) on p(win|not a draw)
    exp(coef["tie.scale"])

    ### check model fit
    alpha &lt;- names(coef[-(1:4)])
    plotProportions(result == 1, result == 0, result == -1,
                    home:season, away:season,
                    abilities = coef[alpha], home.adv = coef["home.adv"],
                    tie.max = coef["tie.max"], tie.scale = coef["tie.scale"],
                    tie.mode = coef["tie.mode"],
                    at.home1 = at.home, at.home2 = !at.home,
                    data = football.tri, subset = count == 1)
}

### analyse all five seasons
### - takes a little while to run, particularly likelihood ratio tests
## Not run: 
### fit Davidson model
Dav &lt;- gnm(count ~ GenDavidson(result == 1, result == 0, result == -1,
                               home:season, away:season, home.adv = ~1,
                               tie.max = ~1,
                               at.home1 = at.home,
                               at.home2 = !at.home) - 1,
           eliminate = match, family = poisson, data = football.tri)

### fit scaled Davidson model
scalDav &lt;- gnm(count ~ GenDavidson(result == 1, result == 0, result == -1,
                                  home:season, away:season, home.adv = ~1,
                                  tie.max = ~1, tie.scale = ~1,
                                  at.home1 = at.home,
                                  at.home2 = !at.home) - 1,
               eliminate = match, family = poisson, data = football.tri)

### fit shifted &amp; scaled Davidson model
shifScalDav &lt;- gnm(count ~
    GenDavidson(result == 1, result == 0, result == -1,
                home:season, away:season, home.adv = ~1,
                tie.max = ~1, tie.scale = ~1, tie.mode = ~1,
                at.home1 = at.home,
                at.home2 = !at.home) - 1,
    eliminate = match, family = poisson, data = football.tri)

### compare models
anova(Dav, scalDav, shifScalDav, test = "Chisq")

### diagnostic plots
main &lt;- c("Davidson", "Scaled Davidson", "Shifted &amp; Scaled Davidson")
mod &lt;- list(Dav, scalDav, shifScalDav)
names(mod) &lt;- main

## use football.tri data so that at.home can be found,
## but restrict to actual match results
par(mfrow = c(2,2))
for (i in 1:3) {
    coef &lt;- parameters(mod[[i]])
    plotProportions(result == 1, result == 0, result == -1,
                    home:season, away:season,
                    abilities = coef[alpha],
                    home.adv = coef["home.adv"],
                    tie.max = coef["tie.max"],
                    tie.scale = coef["tie.scale"],
                    tie.mode = coef["tie.mode"],
                    at.home1 = at.home,
                    at.home2 = !at.home,
                    main = main[i],
                    data = football.tri, subset = count == 1)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='glmmPQL'>PQL Estimation of Generalized Linear Mixed Models</h2><span id='topic+glmmPQL'></span>

<h3>Description</h3>

<p>Fits GLMMs with simple random effects structure via Breslow and Clayton's
PQL algorithm.
The GLMM is assumed to be of the form g(<b>&mu;</b>) =
<b>X&beta;</b> + <b>Ze</b> where <code class="reqn">g</code> is the link
function, <b>&mu;</b> is the
vector of means and <b>X</b>, <b>Z</b> are design matrices for the fixed effects
<b>&beta;</b> and random
effects <b>e</b> respectively.
Furthermore the random effects are assumed to be i.i.d.
N(0, &sigma;<sup>2</sup>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmPQL(
  fixed,
  random = NULL,
  family = "binomial",
  data = NULL,
  subset = NULL,
  weights = NULL,
  offset = NULL,
  na.action = NULL,
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  control = glmmPQL.control(...),
  sigma = 0.1,
  sigma.fixed = FALSE,
  model = TRUE,
  x = FALSE,
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmmPQL_+3A_fixed">fixed</code></td>
<td>
<p>a formula for the fixed effects.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_random">random</code></td>
<td>
<p>a design matrix for the random effects, with number of rows
equal to the length of variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family()</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> to a data frame) containing the variables in
the model.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>glmmPQL</code> called.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_subset">subset</code></td>
<td>
<p>an optional logical or numeric vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used in
the fitting process.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_offset">offset</code></td>
<td>
<p>an optional numeric vector to be added to the linear predictor
during fitting. One or more <code>offset</code> terms can be included in the
formula instead or as well, and if more than one is specified their sum is
used.  See <code><a href="stats.html#topic+model.offset">model.offset()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set by the <code>na.action</code> setting of
<code><a href="base.html#topic+options">options()</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail()</a></code> if that is unset.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process.
See the <code><a href="#topic+glmmPQL.control">glmmPQL.control()</a></code> for details.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_sigma">sigma</code></td>
<td>
<p>a starting value for the standard deviation of the random
effects.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_sigma.fixed">sigma.fixed</code></td>
<td>
<p>logical: whether or not the standard deviation of the
random effects should be fixed at its starting value.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_model">model</code></td>
<td>
<p>logical: whether or not the model frame should be returned.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_x">x</code></td>
<td>
<p>logical: whether or not the design matrix for the fixed effects
should be returned.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> argument of
<code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="glmmPQL_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+glmmPQL.control">glmmPQL.control()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"BTglmmPQL"</code> which inherits from
<code>"glm"</code> and <code>"lm"</code>: </p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of
coefficients, with a <code>"random"</code> attribute giving the estimated random
effects.</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>
<p> the working residuals from the final iteration
of the IWLS loop.</p>
</td></tr> <tr><td><code>random</code></td>
<td>
<p>the design matrix for the random effects.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted mean values, obtained by transforming the
linear predictors by the inverse of the link function.</p>
</td></tr> <tr><td><code>rank</code></td>
<td>
<p>the
numeric rank of the fitted linear model.</p>
</td></tr> <tr><td><code>family</code></td>
<td>
<p>the <code>family</code>
object used.</p>
</td></tr> <tr><td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>up to a constant, minus twice the maximized log-likelihood.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>a version of Akaike's <em>An Information Criterion</em>, minus
twice the maximized log-likelihood plus twice the number of parameters,
computed by the <code>aic</code> component of the family.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the deviance for the null model, comparable with
<code>deviance</code>.</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p>the numer of iterations of the PQL algorithm.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the working weights, that is the weights in the final
iteration of the IWLS loop.</p>
</td></tr> <tr><td><code>prior.weights</code></td>
<td>
<p>the weights initially
supplied, a vector of <code>1</code>'s if none were.</p>
</td></tr> <tr><td><code>df.residual</code></td>
<td>
<p>the
residual degrees of freedom.</p>
</td></tr> <tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom
for the null model.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>if requested (the default) the <code>y</code> vector
used. (It is a vector even for a binomial model.)</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>if requested,
the model matrix.</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model
frame.</p>
</td></tr> <tr><td><code>converged</code></td>
<td>
<p>logical. Was the PQL algorithm judged to have
converged?</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr> <tr><td><code>formula</code></td>
<td>
<p>the formula
supplied.</p>
</td></tr> <tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used.</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>the
<code>data</code> argument used.</p>
</td></tr> <tr><td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the <code>control</code> argument used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(where relevant) the contrasts used.</p>
</td></tr> <tr><td><code>xlevels</code></td>
<td>
<p>(where
relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by <code>model.frame</code>
on the special handling of <code>NA</code>s.</p>
</td></tr> <tr><td><code>sigma</code></td>
<td>
<p>the estimated standard
deviation of the random effects</p>
</td></tr> <tr><td><code>sigma.fixed</code></td>
<td>
<p>logical: whether or not
<code>sigma</code> was fixed</p>
</td></tr> <tr><td><code>varFix</code></td>
<td>
<p>the variance-covariance matrix of the
fixed effects</p>
</td></tr> <tr><td><code>varSigma</code></td>
<td>
<p>the variance of <code>sigma</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>References</h3>

<p>Breslow, N. E. and Clayton, D. G. (1993) Approximate inference
in Generalized Linear Mixed Models. <em>Journal of the American
Statistical Association</em> <strong>88</strong>(421), 9&ndash;25.
</p>
<p>Harville, D. A. (1977) Maximum likelihood approaches to variance component
estimation and to related problems. <em>Journal of the American
Statistical Association</em> <strong>72</strong>(358), 320&ndash;338.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.BTglmmPQL">predict.BTglmmPQL()</a></code>,<code><a href="#topic+glmmPQL.control">glmmPQL.control()</a></code>,<code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################################
## Crowder seeds example from Breslow &amp; Clayton
###############################################

summary(glmmPQL(cbind(r, n - r) ~ seed + extract,
        random = diag(nrow(seeds)),
        family = "binomial", data = seeds))

summary(glmmPQL(cbind(r, n - r) ~ seed*extract,
                random = diag(nrow(seeds)),
                family = "binomial", data = seeds))

</code></pre>

<hr>
<h2 id='glmmPQL.control'>Control Aspects of the glmmPQL Algorithm</h2><span id='topic+glmmPQL.control'></span>

<h3>Description</h3>

<p>Set control variables for the glmmPQL algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmPQL.control(maxiter = 50, IWLSiter = 10, tol = 1e-06, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmmPQL.control_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of outer iterations.</p>
</td></tr>
<tr><td><code id="glmmPQL.control_+3A_iwlsiter">IWLSiter</code></td>
<td>
<p>the maximum number of iterated weighted least squares
iterations used to estimate the fixed effects, given the standard deviation
of the random effects.</p>
</td></tr>
<tr><td><code id="glmmPQL.control_+3A_tol">tol</code></td>
<td>
<p>the tolerance used to determine convergence in the IWLS
iterations and over all (see details).</p>
</td></tr>
<tr><td><code id="glmmPQL.control_+3A_trace">trace</code></td>
<td>
<p>logical: whether or not to print the score for the random
effects variance at the end of each iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an interface to control the PQL algorithm used by
<code><a href="#topic+BTm">BTm()</a></code> for fitting Bradley Terry models with random effects.
</p>
<p>The algorithm iterates between a series of iterated weighted least squares
iterations to update the fixed effects and a single Fisher scoring iteration
to update the standard deviation of the random effects.
</p>
<p>Convergence of both the inner and outer iterations are judged by comparing
the squared components of the relevant score vector with corresponding
elements of the diagonal of the Fisher information matrix. If, for all
components of the relevant score vector, the ratio is less than
<code>tolerance^2</code>, or the corresponding diagonal element of the Fisher
information matrix is less than 1e-20, iterations cease.
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>References</h3>

<p>Breslow, N. E. and Clayton, D. G. (1993), Approximate inference
in Generalized Linear Mixed Models. <em>Journal of the American
Statistical Association</em> <strong>88</strong>(421), 9&ndash;25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmmPQL">glmmPQL()</a></code>, <code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Variation on example(flatlizards)
result &lt;- rep(1, nrow(flatlizards$contests))

## BTm passes arguments on to glmmPQL.control()
args(BTm)
BTmodel &lt;- BTm(result, winner, loser, ~ throat.PC1[..] + throat.PC3[..] +
               head.length[..] + SVL[..] + (1|..),
               data = flatlizards, tol = 1e-3, trace = TRUE)
summary(BTmodel)

</code></pre>

<hr>
<h2 id='icehockey'>College Hockey Men's Division I 2009-10 results</h2><span id='topic+icehockey'></span>

<h3>Description</h3>

<p>Game results from American College Hockey Men's Division I composite
schedule 2009-2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icehockey
</code></pre>


<h3>Format</h3>

<p>A data frame with 1083 observations on the following 6 variables.
</p>

<dl>
<dt>date</dt><dd><p>a numeric vector</p>
</dd>
<dt>visitor</dt><dd><p>a
factor with 58 levels <code style="white-space: pre;">&#8288;Alaska Anchorage&#8288;</code> ... <code>Yale</code></p>
</dd>
<dt>v_goals</dt><dd><p>a numeric vector</p>
</dd>
<dt>opponent</dt><dd><p>a factor
with 58 levels <code style="white-space: pre;">&#8288;Alaska Anchorage&#8288;</code> ... <code>Yale</code></p>
</dd>
<dt>o_goals</dt><dd><p>a numeric vector</p>
</dd>
<dt>conference</dt><dd><p>a factor
with levels <code>AH</code>, <code>CC</code>, <code>CH</code>, <code>EC</code>, <code>HE</code>,
<code>NC</code>, <code>WC</code></p>
</dd>
<dt>result</dt><dd><p>a numeric vector: 1 if visitor
won, 0.5 for a draw and 0 if visitor lost</p>
</dd>
<dt>home.ice</dt><dd><p>a logical
vector: 1 if opponent on home ice, 0 if game on neutral ground</p>
</dd> </dl>


<h3>Details</h3>

<p>The Division I ice hockey teams are arranged in six conferences: Atlantic
Hockey, Central Collegiate Hockey Association, College Hockey America, ECAC
Hockey, Hockey East and the Western Collegiate Hockey Association, all part
of the National Collegiate Athletic Association. The composite schedule
includes within conference games and between conference games.
</p>
<p>The data set here contains only games from the regular season, the results
of which determine the teams that play in the NCAA national tournament.
There are six automatic bids that go to the conference tournament champions,
the remaining 10 teams are selected based upon ranking under the NCAA's
system of pairwise comparisons
(<a href="https://www.collegehockeynews.com/info/?d=pwcrpi">https://www.collegehockeynews.com/info/?d=pwcrpi</a>). Some have argued
that Bradley-Terry rankings would be fairer
(<a href="https://www.collegehockeynews.com/info/?d=krach">https://www.collegehockeynews.com/info/?d=krach</a>).
</p>


<h3>Source</h3>

<p><a href="http://www.collegehockeystats.net/0910/schedules/men">http://www.collegehockeystats.net/0910/schedules/men</a>.
</p>


<h3>References</h3>

<p>Schlobotnik, J. Build your own rankings:
<a href="http://www.elynah.com/tbrw/2010/rankings.diy.shtml">http://www.elynah.com/tbrw/2010/rankings.diy.shtml</a>.
</p>
<p>College Hockey News <a href="https://www.collegehockeynews.com/">https://www.collegehockeynews.com/</a>.
</p>
<p>Selections for 2010 NCAA tournament:
<a href="https://www.espn.com/college-sports/news/story?id=5012918">https://www.espn.com/college-sports/news/story?id=5012918</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Fit the standard Bradley-Terry model
standardBT &lt;- BTm(outcome = result,
    player1 = visitor, player2 = opponent,
    id = "team", data = icehockey)

## Bradley-Terry abilities
abilities &lt;- exp(BTabilities(standardBT)[,1])

## Compute round-robin winning probability and KRACH ratings
## (scaled abilities such that KRACH = 100 for a team with
## round-robin winning probability of 0.5)
rankings &lt;- function(abilities){
    probwin &lt;- abilities/outer(abilities, abilities, "+")
    diag(probwin) &lt;- 0
    nteams &lt;- ncol(probwin)
    RRWP &lt;- rowSums(probwin)/(nteams - 1)
    low &lt;- quantile(abilities, 0.45)
    high &lt;- quantile(abilities, 0.55)
    middling &lt;- uniroot(function(x) {sum(x/(x+abilities)) - 0.5*nteams},
                        lower = low, upper = high)$root
    KRACH &lt;- abilities/middling*100
    cbind(KRACH, RRWP) 
}

ranks &lt;- rankings(abilities)
## matches those produced by Joe Schlobotnik's Build Your Own Rankings 
head(signif(ranks, 4)[order(ranks[,1], decreasing = TRUE),])

## At one point the NCAA rankings gave more credit for wins on
## neutral/opponent's ground. Home ice effects are easily
## incorporated into the Bradley-Terry model, comparing teams
## on a "level playing field"
levelBT &lt;- BTm(result,
               data.frame(team = visitor, home.ice = 0),
               data.frame(team = opponent, home.ice = home.ice),
               ~ team + home.ice,
               id = "team", data = icehockey)

abilities &lt;- exp(BTabilities(levelBT)[,1])
ranks2 &lt;- rankings(abilities)

## Look at movement between the two rankings
change &lt;- factor(rank(ranks2[,1]) - rank(ranks[,1]))
barplot(xtabs(~change), xlab = "Change in Rank", ylab = "No. Teams")

## Take out regional winners and look at top 10
regional &lt;- c("RIT", "Alabama-Huntsville", "Michigan", "Cornell", "Boston College",
              "North Dakota")

ranks &lt;- ranks[!rownames(ranks) %in% regional]
ranks2 &lt;- ranks2[!rownames(ranks2) %in% regional]

## compare the 10 at-large selections under both rankings
## with those selected under NCAA rankings
cbind(names(sort(ranks, decr = TRUE)[1:10]),
      names(sort(ranks2, decr = TRUE)[1:10]),
      c("Miami", "Denver", "Wisconsin", "St. Cloud State",
        "Bemidji State", "Yale", "Northern Michigan", "New Hampshire",
        "Alsaka", "Vermont"))


</code></pre>

<hr>
<h2 id='plotProportions'>Plot Proportions of Tied Matches and Non-tied Matches Won</h2><span id='topic+plotProportions'></span>

<h3>Description</h3>

<p>Plot proportions of tied matches and non-tied matches won by the first
player, within matches binned by the relative player ability, as expressed
by the probability that the first player wins, given the match is not a tie.
Add fitted lines for each set of matches, as given by the generalized
Davidson model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProportions(
  win,
  tie = NULL,
  loss,
  player1,
  player2,
  abilities = NULL,
  home.adv = NULL,
  tie.max = NULL,
  tie.scale = NULL,
  tie.mode = NULL,
  at.home1 = NULL,
  at.home2 = NULL,
  data = NULL,
  subset = NULL,
  bin.size = 20,
  xlab = "P(player1 wins | not a tie)",
  ylab = "Proportion",
  legend = NULL,
  col = 1:2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotProportions_+3A_win">win</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if player1 wins, <code>FALSE</code>
otherwise.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_tie">tie</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if the outcome is a tie,
<code>FALSE</code> otherwise (<code>NULL</code> if there are no ties).</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_loss">loss</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if player1 loses, <code>FALSE</code>
otherwise.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_player1">player1</code></td>
<td>
<p>an ID factor specifying the first player in each contest,
with the same set of levels as <code>player2</code>.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_player2">player2</code></td>
<td>
<p>an ID factor specifying the second player in each contest,
with the same set of levels as <code>player2</code>.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_abilities">abilities</code></td>
<td>
<p>the fitted abilities from a generalized Davidson model (or
a Bradley-Terry model).</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_home.adv">home.adv</code></td>
<td>
<p>if applicable, the fitted home advantage parameter from a
generalized Davidson model (or a Bradley-Terry model).</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_tie.max">tie.max</code></td>
<td>
<p>the fitted parameter from a generalized Davidson model
corresponding to the maximum tie probability.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_tie.scale">tie.scale</code></td>
<td>
<p>if applicable, the fitted parameter from a generalized
Davidson model corresponding to the scale of dependence of the tie
probability on the probability that <code>player1</code> wins, given the outcome
is not a draw.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_tie.mode">tie.mode</code></td>
<td>
<p>if applicable, the fitted parameter from a generalized
Davidson model corresponding to the location of maximum tie probability, in
terms of the probability that <code>player1</code> wins, given the outcome is not
a draw.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_at.home1">at.home1</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if <code>player1</code> is at home,
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_at.home2">at.home2</code></td>
<td>
<p>a logical vector: <code>TRUE</code> if <code>player2</code> is at home,
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_data">data</code></td>
<td>
<p>an optional data frame providing variables required by the
model, with one observation per match.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_subset">subset</code></td>
<td>
<p>an optional logical or numeric vector specifying a subset of
observations to include in the plot.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_bin.size">bin.size</code></td>
<td>
<p>the approximate number of matches in each bin.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_xlab">xlab</code></td>
<td>
<p>the label to use for the x-axis.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_ylab">ylab</code></td>
<td>
<p>the label to use for the y-axis.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_legend">legend</code></td>
<td>
<p>text to use for the legend.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_col">col</code></td>
<td>
<p>a vector specifying colours to use for the proportion of non-tied
matches won and the proportion of tied matches.</p>
</td></tr>
<tr><td><code id="plotProportions_+3A_...">...</code></td>
<td>
<p>further arguments passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>home.adv</code> is specified, the results are re-ordered if necessary so
that the home player comes first; any matches played on neutral ground are
omitted.
</p>
<p>First the probability that the first player wins given that the match is not
a tie is computed: </p>
<p style="text-align: center;"><code class="reqn">expit(home.adv + abilities[player1] -
abilities[player2])</code>
</p>
<p> where <code>home.adv</code> and <code>abilities</code> are
parameters from a generalized Davidson model that have been estimated on the
log scale.
</p>
<p>The matches are then binned according to this probability, grouping together
matches with similar relative ability between the first player and the
second player. Within each bin, the proportion of tied matches is computed
and these proportions are plotted against the mid-point of the bin. Then the
bins are re-computed omitting the tied games and the proportion of non-tied
matches won by the first player is found and plotted against the new
mid-point.
</p>
<p>Finally curves are added for the probability of a tie and the conditional
probability of win given the match is not a tie, under a generalized
Davidson model with parameters as specified by <code>tie.max</code>,
<code>tie.scale</code> and <code>tie.mode</code>.
</p>
<p>The function can also be used to plot the proportions of wins along with the
fitted probability of a win under the Bradley-Terry model.
</p>


<h3>Value</h3>

<p>A list of data frames: </p>
<table role = "presentation">
<tr><td><code>win</code></td>
<td>
<p> a data frame comprising
<code>prop.win</code>, the proportion of non-tied matches won by the first player
in each bin and <code>bin.win</code>, the mid-point of each bin. </p>
</td></tr> <tr><td><code>tie</code></td>
<td>

<p>(when ties are present) a data frame comprising <code>prop.tie</code>, the
proportion of tied matches in each bin and <code>bin.tie</code>, the mid-point of
each bin. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is designed for single match outcomes, therefore data
aggregated over player pairs will need to be expanded.
</p>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenDavidson">GenDavidson()</a></code>, <code><a href="#topic+BTm">BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### A Bradley-Terry example using icehockey data

## Fit the standard Bradley-Terry model, ignoring home advantage
standardBT &lt;- BTm(outcome = result,
                  player1 = visitor, player2 = opponent,
                  id = "team", data = icehockey)

## comparing teams on a "level playing field"
levelBT &lt;- BTm(result,
               data.frame(team = visitor, home.ice = 0),
               data.frame(team = opponent, home.ice = home.ice),
               ~ team + home.ice,
               id = "team", data = icehockey)

## compare fit to observed proportion won
## exclude tied matches as not explicitly modelled here
par(mfrow = c(1, 2))
plotProportions(win = result == 1, loss = result == 0,
                player1 = visitor, player2 = opponent,
                abilities = BTabilities(standardBT)[,1],
                data = icehockey, subset = result != 0.5,
                main = "Without home advantage")

plotProportions(win = result == 1, loss = result == 0,
                player1 = visitor, player2 = opponent,
                home.adv = coef(levelBT)["home.ice"],
                at.home1 = 0, at.home2 = home.ice,
                abilities = BTabilities(levelBT)[,1],
                data = icehockey, subset = result != 0.5,
                main = "With home advantage")

#### A generalized Davidson example using football data
if (require(gnm)) {

    ## subset to first and last season for illustration
    football &lt;- subset(football, season %in% c("2008-9", "2012-13"))

    ## convert to trinomial counts
    football.tri &lt;- expandCategorical(football, "result", idvar = "match")

    ## add variable to indicate whether team playing at home
    football.tri$at.home &lt;- !logical(nrow(football.tri))

    ## fit Davidson model
    Dav &lt;- gnm(count ~ GenDavidson(result == 1, result == 0, result == -1,
                                   home:season, away:season, home.adv = ~1,
                                   tie.max = ~1,
                                   at.home1 = at.home,
                                   at.home2 = !at.home) - 1,
               eliminate = match, family = poisson, data = football.tri)

    ## fit shifted &amp; scaled Davidson model
    shifScalDav &lt;- gnm(count ~
        GenDavidson(result == 1, result == 0, result == -1,
                    home:season, away:season, home.adv = ~1,
                    tie.max = ~1, tie.scale = ~1, tie.mode = ~1,
                    at.home1 = at.home,
                    at.home2 = !at.home) - 1,
        eliminate = match, family = poisson, data = football.tri)

    ## diagnostic plots
    main &lt;- c("Davidson", "Shifted &amp; Scaled Davidson")
    mod &lt;- list(Dav, shifScalDav)
    names(mod) &lt;- main
    alpha &lt;- names(coef(Dav)[-(1:2)])

    ## use football.tri data so that at.home can be found,
    ## but restrict to actual match results
    par(mfrow = c(1,2))
    for (i in 1:2) {
        coef &lt;- parameters(mod[[i]])
        plotProportions(result == 1, result == 0, result == -1,
                        home:season, away:season,
                        abilities = coef[alpha],
                        home.adv = coef["home.adv"],
                        tie.max = coef["tie.max"],
                        tie.scale = coef["tie.scale"],
                        tie.mode = coef["tie.mode"],
                        at.home1 = at.home,
                        at.home2 = !at.home,
                        main = main[i],
                        data = football.tri, subset = count == 1)
    }
}

</code></pre>

<hr>
<h2 id='predict.BTglmmPQL'>Predict Method for BTglmmPQL Objects</h2><span id='topic+predict.BTglmmPQL'></span>

<h3>Description</h3>

<p>Obtain predictions and optionally standard errors of those predictions from
a <code>"BTglmmPQL"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BTglmmPQL'
predict(
  object,
  newdata = NULL,
  newrandom = NULL,
  level = ifelse(object$sigma == 0, 0, 1),
  type = c("link", "response", "terms"),
  se.fit = FALSE,
  terms = NULL,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.BTglmmPQL_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>"BTglmmPQL"</code></p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_newdata">newdata</code></td>
<td>
<p>(optional) a data frame in which to look for variables with
which to predict.  If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_newrandom">newrandom</code></td>
<td>
<p>if <code>newdata</code> is provided, a corresponding design
matrix for the random effects, will columns corresponding to the random
effects estimated in the original model.</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_level">level</code></td>
<td>
<p>an integer vector giving the level(s) at which predictions are
required. Level zero corresponds to population-level predictions (fixed
effects only), whilst level one corresponds to the individual-level
predictions (full model) which are NA for contests involving individuals not
in the original data. By default <code>level = 0</code> if the model converged to a
fixed effects model, <code>1</code> otherwise.</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_type">type</code></td>
<td>
<p>the type of prediction required.  The default is on the scale of
the linear predictors; the alternative <code>"response"</code> is on the scale of
the response variable. Thus for a default binomial model the default
predictions are of log-odds (probabilities on logit scale) and <code>type = "response"</code> gives the predicted probabilities. The <code>"terms"</code> option
returns a matrix giving the fitted values of each term in the model formula
on the linear predictor scale (fixed effects only).</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_se.fit">se.fit</code></td>
<td>
<p>logical switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_terms">terms</code></td>
<td>
<p>with <code>type ="terms"</code> by default all terms are returned.  A
character vector specifies which terms are to be returned.</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing
values in <code>newdata</code>.  The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.BTglmmPQL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for
the fit.  In that case how cases with missing values in the original fit are
treated is determined by the <code>na.action</code> argument of that fit.  If
<code>na.action = na.omit</code> omitted cases will not appear in the residuals,
whereas if <code>na.action = na.exclude</code> they will appear (in predictions
and standard errors), with residual value <code>NA</code>.  See also
<code>napredict</code>.
</p>
<p>Standard errors for the predictions are approximated assuming the variance
of the random effects is known, see Booth and Hobert (1998).
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code>, a vector or matrix of predictions.  If
<code>se = TRUE</code>, a list with components </p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>Predictions</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Estimated standard errors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>References</h3>

<p>Booth, J. G. and Hobert, J. P. (1998). Standard errors of
prediction in Generalized Linear Mixed Models. <em>Journal of the American
Statistical Association</em> <strong>93</strong>(441), 262 &ndash; 272.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>, <code><a href="#topic+predict.BTm">predict.BTm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seedsModel &lt;- glmmPQL(cbind(r, n - r) ~ seed + extract,
                      random = diag(nrow(seeds)),
                      family = binomial,
                      data = seeds)

pred &lt;- predict(seedsModel, level = 0)
predTerms &lt;- predict(seedsModel, type = "terms")

all.equal(pred, rowSums(predTerms) + attr(predTerms, "constant"))

</code></pre>

<hr>
<h2 id='predict.BTm'>Predict Method for Bradley-Terry Models</h2><span id='topic+predict.BTm'></span>

<h3>Description</h3>

<p>Obtain predictions and optionally standard errors of those predictions from
a fitted Bradley-Terry model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BTm'
predict(
  object,
  newdata = NULL,
  level = ifelse(is.null(object$random), 0, 1),
  type = c("link", "response", "terms"),
  se.fit = FALSE,
  dispersion = NULL,
  terms = NULL,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.BTm_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>"BTm"</code></p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_newdata">newdata</code></td>
<td>
<p>(optional) a data frame in which to look for variables with
which to predict.  If omitted, the fitted linear predictors are used.</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_level">level</code></td>
<td>
<p>for models with random effects: an integer vector giving the
level(s) at which predictions are required. Level zero corresponds to
population-level predictions (fixed effects only), whilst level one
corresponds to the player-level predictions (full model) which are NA for
contests involving players not in the original data. By default, <code>level = 0</code>
for a fixed effects model, <code>1</code> otherwise.</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_type">type</code></td>
<td>
<p>the type of prediction required.  The default is on the scale of
the linear predictors; the alternative <code>"response"</code> is on the scale of
the response variable. Thus for a default Bradley-Terry model the default
predictions are of log-odds (probabilities on logit scale) and
<code>type = "response"</code> gives the predicted probabilities. The <code>"terms"</code> option
returns a matrix giving the fitted values of each term in the model formula
on the linear predictor scale (fixed effects only).</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_se.fit">se.fit</code></td>
<td>
<p>logical switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_dispersion">dispersion</code></td>
<td>
<p>a value for the dispersion, not used for models with
random effects. If omitted, that returned by <code>summary</code> applied to the
object is used, where applicable.</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_terms">terms</code></td>
<td>
<p>with <code>type ="terms"</code> by default all terms are returned.  A
character vector specifies which terms are to be returned.</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing
values in <code>newdata</code>.  The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.BTm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used for
the fit.  In that case how cases with missing values in the original fit are
treated is determined by the <code>na.action</code> argument of that fit.  If
<code>na.action = na.omit</code> omitted cases will not appear in the residuals,
whereas if <code>na.action = na.exclude</code> they will appear (in predictions
and standard errors), with residual value <code>NA</code>.  See also
<code>napredict</code>.
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code>, a vector or matrix of predictions.  If
<code>se = TRUE</code>, a list with components </p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>Predictions</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Estimated standard errors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.glm">predict.glm()</a></code>, <code><a href="MASS.html#topic+predict.glmmPQL">predict.glmmPQL()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The final model in example(flatlizards)
result &lt;- rep(1, nrow(flatlizards$contests))
Whiting.model3 &lt;- BTm(1, winner, loser, ~ throat.PC1[..] + throat.PC3[..] +
                      head.length[..] + SVL[..] + (1|..),
                      family = binomial(link = "probit"),
                      data = flatlizards, trace = TRUE)

## `new' data for contests between four of the original lizards
## factor levels must correspond to original levels, but unused levels
## can be dropped - levels must match rows of predictors
newdata  &lt;- list(contests = data.frame(
                 winner = factor(c("lizard048", "lizard060"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard060")),
                 loser = factor(c("lizard006", "lizard011"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard060"))
                 ),
                 predictors = flatlizards$predictors[c(3, 6, 27, 33), ])

predict(Whiting.model3, level = 1, newdata = newdata)

## same as
predict(Whiting.model3, level = 1)[1:2]

## introducing a new lizard
newpred &lt;- rbind(flatlizards$predictors[c(3, 6, 27),
                     c("throat.PC1","throat.PC3", "SVL", "head.length")],
                 c(-5, 1.5, 1, 0.1))
rownames(newpred)[4] &lt;- "lizard059"

newdata  &lt;- list(contests = data.frame(
                 winner = factor(c("lizard048", "lizard059"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard059")),
                 loser = factor(c("lizard006", "lizard011"),
                 levels = c("lizard006", "lizard011", 
                            "lizard048", "lizard059"))
                 ),
                 predictors = newpred)

## can only predict at population level for contest with new lizard
predict(Whiting.model3, level = 0:1, se.fit = TRUE, newdata = newdata)

## predicting at specific levels of covariates

## consider a model from example(CEMS)
table6.model &lt;-  BTm(outcome = cbind(win1.adj, win2.adj),
                     player1 = school1, player2 = school2,
                     formula = ~ .. +
                         WOR[student] * Paris[..] +
                         WOR[student] * Milano[..] +
                         WOR[student] * Barcelona[..] +
                         DEG[student] * St.Gallen[..] +
                         STUD[student] * Paris[..] +
                         STUD[student] * St.Gallen[..] +
                         ENG[student] * St.Gallen[..] +
                         FRA[student] * London[..] +
                         FRA[student] * Paris[..] +
                         SPA[student] * Barcelona[..] +
                         ITA[student] * London[..] +
                         ITA[student] * Milano[..] +
                         SEX[student] * Milano[..],
                     refcat = "Stockholm",
                     data = CEMS)
                     
## estimate abilities for a combination not seen in the original data

## same schools
schools &lt;- levels(CEMS$preferences$school1)
## new student data
students &lt;- data.frame(STUD = "other", ENG = "good", FRA = "good", 
                       SPA = "good", ITA = "good", WOR = "yes", DEG = "no",
                       SEX = "female", stringsAsFactors = FALSE)
## set levels to be the same as original data    
for (i in seq_len(ncol(students))){
    students[,i] &lt;- factor(students[,i], levels(CEMS$students[,i]))
}
newdata &lt;- list(preferences = 
    data.frame(student = factor(500), # new id matching with `students[1,]`
               school1 = factor("London", levels = schools),
               school2 = factor("Paris", levels = schools)),
    students = students,
    schools = CEMS$schools)

## warning can be ignored as model specification was over-parameterized
predict(table6.model, newdata = newdata)

## if treatment contrasts are use (i.e. one player is set as the reference
## category), then predicting the outcome of contests against the reference
## is equivalent to estimating abilities with specific covariate values

## add student with all values at reference levels 
students &lt;- rbind(students,
    data.frame(STUD = "other", ENG = "good", FRA = "good", 
               SPA = "good", ITA = "good", WOR = "no", DEG = "no",
               SEX = "female", stringsAsFactors = FALSE))
## set levels to be the same as original data    
for (i in seq_len(ncol(students))){
    students[,i] &lt;- factor(students[,i], levels(CEMS$students[,i]))
}
newdata &lt;- list(preferences = 
    data.frame(student = factor(rep(c(500, 502), each = 6)), 
               school1 = factor(schools, levels = schools),
               school2 = factor("Stockholm", levels = schools)),
    students = students,
    schools = CEMS$schools)
    
predict(table6.model, newdata = newdata, se.fit = TRUE)

## the second set of predictions (elements 7-12) are equivalent to the output 
## of BTabilities; the first set are adjust for `WOR` being equal to "yes"
BTabilities(table6.model)

</code></pre>

<hr>
<h2 id='qvcalc.BTabilities'>Quasi Variances for Estimated Abilities</h2><span id='topic+qvcalc.BTabilities'></span>

<h3>Description</h3>

<p>A method for <code><a href="qvcalc.html#topic+qvcalc">qvcalc::qvcalc()</a></code> to compute a set of quasi variances (and
corresponding quasi standard errors) for estimated abilities from a
Bradley-Terry model as returned by <code><a href="#topic+BTabilities">BTabilities()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BTabilities'
qvcalc(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qvcalc.BTabilities_+3A_object">object</code></td>
<td>
<p>a <code>"BTabilities"</code> object as returned by <code><a href="#topic+BTabilities">BTabilities()</a></code>.</p>
</td></tr>
<tr><td><code id="qvcalc.BTabilities_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the method see Firth (2000), Firth (2003) or Firth and de
Menezes (2004). Quasi variances generalize and improve the accuracy of
&ldquo;floating absolute risk&rdquo; (Easton et al., 1991). This device for
economical model summary was first suggested by Ridout (1989).
</p>
<p>Ordinarily the quasi variances are positive and so their square roots
(the quasi standard errors) exist and can be used in plots, etc.
</p>


<h3>Value</h3>

<p>A list of class <code>"qv"</code>, with components
</p>
<table role = "presentation">
<tr><td><code>covmat</code></td>
<td>
<p>The full variance-covariance matrix for the estimated
abilities.</p>
</td></tr>
<tr><td><code>qvframe</code></td>
<td>
<p>A data frame with variables <code>estimate</code>, <code>SE</code>, <code>quasiSE</code> and
<code>quasiVar</code>, the last two being a quasi standard error and quasi-variance
for each ability.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p><code>NULL</code> (dispersion is fixed to 1).</p>
</td></tr>
<tr><td><code>relerrs</code></td>
<td>
<p>Relative errors for approximating the standard errors of all
simple contrasts.</p>
</td></tr>
<tr><td><code>factorname</code></td>
<td>
<p>The name of the ID factor identifying players in the <code>BTm</code>
formula.</p>
</td></tr>
<tr><td><code>coef.indices</code></td>
<td>
<p><code>NULL</code> (no required for this method).</p>
</td></tr>
<tr><td><code>modelcall</code></td>
<td>
<p>The call to <code>BTm</code> to fit the Bradley-Terry model from which
the abilities were estimated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Firth
</p>


<h3>References</h3>

<p>Easton, D. F, Peto, J. and Babiker, A. G. A. G. (1991) Floating absolute
risk: an alternative to relative risk in survival and case-control analysis
avoiding an arbitrary reference group. <em>Statistics in Medicine</em> <strong>10</strong>,
1025&ndash;1035.
</p>
<p>Firth, D. (2000)  Quasi-variances in Xlisp-Stat and on the web.
<em>Journal of Statistical Software</em> <strong>5.4</strong>, 1&ndash;13.
<a href="https://www.jstatsoft.org/article/view/v005i04">https://www.jstatsoft.org/article/view/v005i04</a>.
</p>
<p>Firth, D. (2003) Overcoming the reference category problem in the
presentation of statistical models. <em>Sociological Methodology</em>
<strong>33</strong>, 1&ndash;18.
</p>
<p>Firth, D. and de Menezes, R. X. (2004)  Quasi-variances.
<em>Biometrika</em> <strong>91</strong>, 65&ndash;80.
</p>
<p>Menezes, R. X. de (1999)  More useful standard errors for group and factor
effects in generalized linear models.  <em>D.Phil. Thesis</em>,
Department of Statistics, University of Oxford.
</p>
<p>Ridout, M.S. (1989). Summarizing the results of fitting generalized
linear models to data from designed experiments. In: <em>Statistical
Modelling: Proceedings of GLIM89 and the 4th International
Workshop on Statistical Modelling held in Trento, Italy, July 17&ndash;21,
1989</em> (A. Decarli et al., eds.), pp 262&ndash;269. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="qvcalc.html#topic+worstErrors">qvcalc::worstErrors()</a></code>, <code><a href="qvcalc.html#topic+plot.qv">qvcalc::plot.qv()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
example(baseball)
baseball.qv &lt;- qvcalc(BTabilities(baseballModel2))
print(baseball.qv)
plot(baseball.qv, xlab = "team",
     levelNames = c("Bal", "Bos", "Cle", "Det", "Mil", "NY", "Tor"))
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+qvcalc'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>qvcalc</dt><dd><p><code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.BTm'>Residuals from a Bradley-Terry Model</h2><span id='topic+residuals.BTm'></span>

<h3>Description</h3>

<p>Computes residuals from a model object of class <code>"BTm"</code>. In additional
to the usual options for objects inheriting from class <code>"glm"</code>, a
<code>"grouped"</code> option is implemented to compute player-specific residuals
suitable for diagnostic checking of a predictor involving player-level
covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BTm'
residuals(
  object,
  type = c("deviance", "pearson", "working", "response", "partial", "grouped"),
  by = object$id,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.BTm_+3A_object">object</code></td>
<td>
<p>a model object for which <code>inherits(model, "BTm")</code> is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.BTm_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be returned.  The
alternatives are: <code>"deviance"</code> (default), <code>"pearson"</code>,
<code>"working"</code>, <code>"response"</code>, and <code>"partial"</code>.</p>
</td></tr>
<tr><td><code id="residuals.BTm_+3A_by">by</code></td>
<td>
<p>the grouping factor to use when <code>type = "grouped"</code>.</p>
</td></tr>
<tr><td><code id="residuals.BTm_+3A_...">...</code></td>
<td>
<p>arguments to pass on other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type</code> other than <code>"grouped"</code> see <code><a href="stats.html#topic+residuals.glm">residuals.glm()</a></code>.
</p>
<p>For <code>type = "grouped"</code> the residuals returned are weighted means of
working residuals, with weights equal to the binomial denominators in the
fitted model.  These are suitable for diagnostic model checking, for example
plotting against candidate predictors.
</p>


<h3>Value</h3>

<p>A numeric vector of length equal to the number of players, with a
<code>"weights"</code> attribute.
</p>


<h3>Author(s)</h3>

<p>David Firth and Heather Turner
</p>


<h3>References</h3>

<p>Firth, D. (2005) Bradley-Terry models in R.  <em>Journal of
Statistical Software</em> <strong>12</strong>(1), 1&ndash;12.
</p>
<p>Turner, H. and Firth, D. (2012) Bradley-Terry models in R: The BradleyTerry2
package.  <em>Journal of Statistical Software</em>, <strong>48</strong>(9), 1&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BTm">BTm()</a></code>, <code><a href="#topic+BTabilities">BTabilities()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
##  See ?springall
##
springall.model &lt;- BTm(cbind(win.adj, loss.adj),
                       col, row, 
                       ~ flav[..] + gel[..] + 
                       flav.2[..] + gel.2[..] + flav.gel[..] + (1 | ..),
                       data = springall)
res &lt;- residuals(springall.model, type = "grouped")
with(springall$predictors, plot(flav, res))
with(springall$predictors, plot(gel, res))
##  Weighted least-squares regression of these residuals on any variable
##  already included in the model yields slope coefficient zero:
lm(res ~ flav, weights = attr(res, "weights"),
   data = springall$predictors)
lm(res ~ gel, weights = attr(res, "weights"),
   data = springall$predictors)

</code></pre>

<hr>
<h2 id='seeds'>Seed Germination Data from Crowder (1978)</h2><span id='topic+seeds'></span>

<h3>Description</h3>

<p>Data from Crowder(1978) giving the proportion of seeds germinated for 21
plates that were arranged according to a 2x2 factorial layout by seed
variety and type of root extract.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seeds
</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 4 variables.
</p>

<dl>
<dt>r</dt><dd><p>the number of germinated seeds.</p>
</dd>
<dt>n</dt><dd><p>the total number of seeds.</p>
</dd>
<dt>seed</dt><dd><p>the seed
variety.</p>
</dd>
<dt>extract</dt><dd><p>the type of root extract.</p>
</dd> </dl>


<h3>Source</h3>

<p>Crowder, M. (1978) Beta-Binomial ANOVA for proportions.
<em>Applied Statistics</em>, <strong>27</strong>, 34&ndash;37.
</p>


<h3>References</h3>

<p>Breslow, N. E. and Clayton, D. G. (1993) Approximate inference
in Generalized Linear Mixed Models. <em>Journal of the American
Statistical Association</em>, <strong>88</strong>(421), 9&ndash;25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmmPQL">glmmPQL()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(glmmPQL(cbind(r, n - r) ~ seed + extract,
                random = diag(nrow(seeds)),
                family = binomial, 
                data = seeds))

</code></pre>

<hr>
<h2 id='sound.fields'>Kousgaard (1984) Data on Pair Comparisons of Sound Fields</h2><span id='topic+sound.fields'></span>

<h3>Description</h3>

<p>The results of a series of factorial subjective room acoustic experiments
carried out at the Technical University of Denmark by A C Gade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sound.fields
</code></pre>


<h3>Format</h3>

<p>A list containing two data frames, <code>sound.fields$comparisons</code>,
and <code>sound.fields$design</code>.
</p>
<p>The <code>sound.fields$comparisons</code> data frame has 84 observations on the
following 8 variables: </p>

<dl>
<dt>field1</dt><dd><p>a factor with levels
<code>c("000", "001", "010", "011", "100", "101", "110", "111")</code>, the first
sound field in a comparison</p>
</dd>
<dt>field2</dt><dd><p>a factor with the same
levels as <code>field1</code>; the second sound field in a comparison</p>
</dd>
<dt>win1</dt><dd><p>integer, the number of times that <code>field1</code> was
preferred to <code>field2</code></p>
</dd>
<dt>tie</dt><dd><p>integer, the number of times
that no preference was expressed when comparing <code>field1</code> and
<code>field2</code></p>
</dd>
<dt>win2</dt><dd><p>integer, the number of times that
<code>field2</code> was preferred to <code>field1</code></p>
</dd>
<dt>win1.adj</dt><dd><p>numeric, equal to <code>win1 + tie/2</code></p>
</dd>
<dt>win2.adj</dt><dd><p>numeric, equal to <code>win2 + tie/2</code></p>
</dd>
<dt>instrument</dt><dd><p>a factor with 3 levels, <code>c("cello", "flute", "violin")</code></p>
</dd> </dl>

<p>The <code>sound.fields$design</code> data frame has 8 observations (one for each
of the sound fields compared in the experiment) on the following 3
variables: </p>

<dl>
<dt>a&quot;)</dt><dd><p>a factor with levels <code>c("0", "1")</code>, the <em>direct sound</em> factor (0 for <em>obstructed sight line</em>, 1
for <em>free sight line</em>); contrasts are sum contrasts</p>
</dd>
<dt>b</dt><dd><p>a
factor with levels <code>c("0", "1")</code>, the <em>reflection</em> factor (0 for
<em>-26dB</em>, 1 for <em>-20dB</em>); contrasts are sum contrasts</p>
</dd>
<dt>c</dt><dd><p>a factor with levels <code>c("0", "1")</code>, the
<em>reverberation</em> factor (0 for <em>-24dB</em>, 1 for <em>-20dB</em>);
contrasts are sum contrasts</p>
</dd> </dl>


<h3>Details</h3>

<p>The variables <code>win1.adj</code> and <code>win2.adj</code> are provided in order to
allow a simple way of handling ties (in which a tie counts as half a win and
half a loss), which is slightly different numerically from the Davidson
(1970) method that is used by Kousgaard (1984): see the examples.
</p>


<h3>Author(s)</h3>

<p>David Firth
</p>


<h3>Source</h3>

<p>Kousgaard, N. (1984) Analysis of a Sound Field Experiment by a Model
for Paired Comparisons with Explanatory Variables.  <em>Scandinavian
Journal of Statistics</em> <strong>11</strong>, 51&ndash;57.
</p>


<h3>References</h3>

<p>Davidson, R. R. (1970) Extending the Bradley-Terry model to
accommodate ties in paired comparison experiments.  <em>Journal of the
American Statistical Association</em> <strong>65</strong>, 317&ndash;328.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
##  Fit the Bradley-Terry model to data for flutes, using the simple 
##  'add 0.5' method to handle ties:
##
flutes.model &lt;- BTm(cbind(win1.adj, win2.adj), field1, field2, ~ field,
                    id = "field",
                    subset = (instrument == "flute"),
                    data = sound.fields)
##
##  This agrees (after re-scaling) quite closely with the estimates given
##  in Table 3 of Kousgaard (1984):
##
table3.flutes &lt;- c(-0.581, -1.039, 0.347, 0.205, 0.276, 0.347, 0.311, 0.135)
plot(c(0, coef(flutes.model)), table3.flutes)
abline(lm(table3.flutes ~ c(0, coef(flutes.model))))
##
##  Now re-parameterise that model in terms of the factorial effects, as
##  in Table 5 of Kousgaard (1984):
##
flutes.model.reparam &lt;- update(flutes.model,
                               formula = ~ a[field] * b[field] * c[field]
			       )
table5.flutes &lt;- c(.267, .250, -.088, -.294, .062, .009, -0.070)
plot(coef(flutes.model.reparam), table5.flutes)
abline(lm(table5.flutes ~ coef(flutes.model.reparam)))

</code></pre>

<hr>
<h2 id='springall'>Springall (1973) Data on Subjective Evaluation of Flavour Strength</h2><span id='topic+springall'></span>

<h3>Description</h3>

<p>Data from Section 7 of the paper by Springall (1973) on Bradley-Terry
response surface modelling.  An experiment to assess the effects of gel and
flavour concentrations on the subjective assessment of flavour strength by
pair comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>springall
</code></pre>


<h3>Format</h3>

<p>A list containing two data frames, <code>springall$contests</code> and
<code>springall$predictors</code>.
</p>
<p>The <code>springall$contests</code> data frame has 36 observations (one for each
possible pairwise comparison of the 9 treatments) on the following 7
variables: </p>

<dl>
<dt>row</dt><dd><p>a factor with levels <code>1:9</code>,
the row number in Springall's dataset</p>
</dd></dl>
<p> #
</p>
<dl>
<dt>col</dt><dd><p>a factor with
levels <code>1:9</code>, the column number in Springall's dataset</p>
</dd>
<dt>win</dt><dd><p>integer, the number of wins for column treatment over row
treatment</p>
</dd>
<dt>loss</dt><dd><p>integer, the number of wins for row treatment
over column treatment</p>
</dd>
<dt>tie</dt><dd><p>integer, the number of ties
between row and column treatments</p>
</dd>
<dt>win.adj</dt><dd><p>numeric, equal to
<code>win + tie/2</code></p>
</dd>
<dt>loss.adj</dt><dd><p>numeric, equal to <code>loss + tie/2</code></p>
</dd> </dl>

<p>The <code>predictors</code> data frame has 9 observations (one for each treatment)
on the following 5 variables: </p>

<dl>
<dt>flav</dt><dd><p>numeric, the
flavour concentration</p>
</dd>
<dt>gel</dt><dd><p>numeric, the gel concentration</p>
</dd>
<dt>flav.2</dt><dd><p>numeric, equal to <code>flav^2</code></p>
</dd>
<dt>gel.2</dt><dd><p>numeric, equal to <code>gel^2</code></p>
</dd>
<dt>flav.gel</dt><dd><p>numeric, equal to <code>flav * gel</code></p>
</dd> </dl>


<h3>Details</h3>

<p>The variables <code>win.adj</code> and <code>loss.adj</code> are provided in order to
allow a simple way of handling ties (in which a tie counts as half a win and
half a loss), which is slightly different numerically from the Rao and
Kupper (1967) model that Springall (1973) uses.
</p>


<h3>Author(s)</h3>

<p>David Firth
</p>


<h3>Source</h3>

<p>Springall, A (1973) Response surface fitting using a generalization
of the Bradley-Terry paired comparison method.  <em>Applied Statistics</em>
<strong>22</strong>, 59&ndash;68.
</p>


<h3>References</h3>

<p>Rao, P. V. and Kupper, L. L. (1967) Ties in paired-comparison
experiments: a generalization of the Bradley-Terry model.  <em>Journal of
the American Statistical Association</em>, <strong>63</strong>, 194&ndash;204.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## Fit the same response-surface model as in section 7 of 
## Springall (1973).
##
## Differences from Springall's fit are minor, arising from the 
## different treatment of ties.
##
## Springall's model in the paper does not include the random effect.  
## In this instance, however, that makes no difference: the random-effect 
## variance is estimated as zero.
##
summary(springall.model &lt;- BTm(cbind(win.adj, loss.adj), col, row, 
                               ~ flav[..] + gel[..] + 
                                 flav.2[..] + gel.2[..] + flav.gel[..] +
                                 (1 | ..),
                               data = springall))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
