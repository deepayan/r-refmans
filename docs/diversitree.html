<!DOCTYPE html><html><head><title>Help for package diversitree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diversitree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#argnames'><p>Argument Names for Vector-Argument Functions</p></a></li>
<li><a href='#asr'><p>Ancestral State Reconstruction</p></a></li>
<li><a href='#asr-bisse'><p>Ancestral State Reconstruction Under BiSSE</p></a></li>
<li><a href='#asr-mkn'><p>Ancestral State Reconstruction Under Mk2/Mkn</p></a></li>
<li><a href='#big.brother'><p>Verbosely Track Function Evaluations</p></a></li>
<li><a href='#check'><p>Check Capabilities of the Diversitree Install</p></a></li>
<li><a href='#combine'><p>Combine Several Likelihood Functions Multiplicatively</p></a></li>
<li><a href='#Constants'><p>Constants Used by Diversitree</p></a></li>
<li><a href='#constrain'><p>Constrain Parameters of a Model</p></a></li>
<li><a href='#diversitree-deprecated'><p>Deprecated and Defunct Functions in Diversitree</p></a></li>
<li><a href='#diversitree-package'>
<p>Comparative 'Phylogenetic' Analyses of Diversification</p></a></li>
<li><a href='#find.mle'><p>Maximimum Likelihood Inference</p></a></li>
<li><a href='#history.from.sim'><p>Extract Character Histories From Simulations</p></a></li>
<li><a href='#make.bd'><p>Constant Rate Birth-Death Models</p></a></li>
<li><a href='#make.bd.split'><p>Constant Rate Birth-Death Models: Split Models</p></a></li>
<li><a href='#make.bd.t'><p>Time-varing Birth-Death Models</p></a></li>
<li><a href='#make.bisse'><p>Binary State Speciation and Extinction Model</p></a></li>
<li><a href='#make.bisse.split'><p>Binary State Speciation and Extinction Model: Split Models</p></a></li>
<li><a href='#make.bisse.td'><p>Binary State Speciation and Extinction Model: Time Dependant</p>
Models</a></li>
<li><a href='#make.bisseness'><p>Binary State Speciation and Extinction (Node Enhanced State Shift) Model</p></a></li>
<li><a href='#make.bm'><p>Brownian Motion and Related Models of Character Evolution</p></a></li>
<li><a href='#make.clade.tree'><p>Make a &quot;Clade Tree&quot;</p></a></li>
<li><a href='#make.classe'><p>Cladogenetic State change Speciation and Extinction Model</p></a></li>
<li><a href='#make.geosse'><p>Geographic State Speciation and Extinction Model</p></a></li>
<li><a href='#make.geosse.split'><p>Geographic State Speciation and Extinction Model: Split Models</p></a></li>
<li><a href='#make.geosse.t'><p>Geographic State Speciation and Extinction Model: Time Dependent</p>
Models</a></li>
<li><a href='#make.mkn'><p>Mk2 and Mk-n Models of character evolution</p></a></li>
<li><a href='#make.musse'><p>MuSSE: Multi-State Speciation and Extinction</p></a></li>
<li><a href='#make.musse.multitrait'><p>MuSSE: Multi-State Speciation and Extinction (Multiple Binary Traits</p>
Version)</a></li>
<li><a href='#make.musse.split'><p>Multiple State Speciation and Extinction Model: Split Models</p></a></li>
<li><a href='#make.musse.td'><p>Multiple State Speciation and Extinction Model: Time Dependent</p>
Models</a></li>
<li><a href='#make.pgls'><p>Phylogenetic Generalised Least Squares</p></a></li>
<li><a href='#make.prior'><p>Simple Prior Functions</p></a></li>
<li><a href='#make.quasse'><p>Quantitative State Speciation and Extinction Model</p></a></li>
<li><a href='#make.quasse.split'><p>Quantitative State Speciation and Extinction Model: Split Models</p></a></li>
<li><a href='#mcmc'><p>Simple Markov Chain Monte Carlo with Slice Sampling</p></a></li>
<li><a href='#plot.history'><p>Plot Character History</p></a></li>
<li><a href='#profiles.plot'><p>Plot Marginal Distributions from MCMC</p></a></li>
<li><a href='#protect'><p>Protect Function Evaluations</p></a></li>
<li><a href='#quasse-common'><p>Support Functions for QuaSSE Models</p></a></li>
<li><a href='#set.defaults'><p>Set Default Arguments of a Function</p></a></li>
<li><a href='#sim.character'><p>Simulate a Character Distribution on a Tree</p></a></li>
<li><a href='#simulate'><p>Evolve Birth-Death Trees</p></a></li>
<li><a href='#trait.plot'><p>Plot a Phylogeny and Traits</p></a></li>
<li><a href='#utilities'><p>Utility Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.10-0</td>
</tr>
<tr>
<td>Title:</td>
<td>Comparative 'Phylogenetic' Analyses of Diversification</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods, ape</td>
</tr>
<tr>
<td>Imports:</td>
<td>deSolve (&ge; 1.7), graphics, grDevices, stats, subplex, Rcpp
(&ge; 0.10.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>numDeriv, minqa, lubridate, expm, caper, geiger</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>diversitree</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fftw3 (&gt;= 3.1.2), gsl (&gt;= 1.15)</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains a number of comparative 'phylogenetic' methods,
  mostly focusing on analysing diversification and character
  evolution.  Contains implementations of 'BiSSE' (Binary State
  'Speciation' and Extinction) and its unresolved tree extensions,
  'MuSSE' (Multiple State 'Speciation' and Extinction), 'QuaSSE',
  'GeoSSE', and 'BiSSE-ness' Other included methods include Markov
  models of discrete and continuous trait evolution and constant rate
  'speciation' and extinction.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.zoology.ubc.ca/prog/diversitree/">https://www.zoology.ubc.ca/prog/diversitree/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 09:45:11 UTC; rich</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard G. FitzJohn [aut, cre],
  Emma Goldberg [aut],
  Karen Magnuson-Ford [aut],
  Roger Sidje [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard G. FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-20 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='argnames'>Argument Names for Vector-Argument Functions</h2><span id='topic+argnames'></span><span id='topic+argnames+3C-'></span><span id='topic+argnames.constrained'></span><span id='topic+argnames+3C-.constrained'></span>

<h3>Description</h3>

<p>Functions to get and set &ldquo;argument names&rdquo; for
functions that take vectorised arguments.  For example, the likelihood
function returned by <code>make.bisse</code> takes a vector of six these
functions can be used to get the canonical names for these six
parameters, and also to set them to something more memorable.  These
names are used by the <code><a href="#topic+constrain">constrain</a></code> function to specify
submodels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argnames(x, ...)
argnames(x) &lt;- value
## S3 method for class 'constrained'
argnames(x, ...)
## S3 replacement method for class 'constrained'
argnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argnames_+3A_x">x</code></td>
<td>
<p>A function taking a vector of parameters as its first
argument.</p>
</td></tr>
<tr><td><code id="argnames_+3A_value">value</code></td>
<td>
<p>Vector of names to set the argument names to.</p>
</td></tr>
<tr><td><code id="argnames_+3A_...">...</code></td>
<td>
<p>Ignored arguments to future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods exist for all models: <code>bisse</code>, <code>geosse</code>, <code>bd</code>,
<code>yule</code>, <code>mk2</code>, and <code>mkn</code>.  These are particulary useful
for <code>mkn</code> as the number of parameters for the Q matrix can be
very large.</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Same example likelihood function as for \link{make.bisse}:
pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(4)
phy &lt;- tree.bisse(pars, max.t=30, x0=0)
f &lt;- make.bisse(phy, phy$tip.state)

argnames(f) # Canonical argument names (set by default)
## Names that might be more informative for a tall/short state
argnames(f) &lt;- c("l.tall", "l.short", "m.tall", "m.short",
                 "q.tall.short", "q.short.tall")
argnames(f)

</code></pre>

<hr>
<h2 id='asr'>Ancestral State Reconstruction</h2><span id='topic+asr'></span><span id='topic+asr.marginal'></span><span id='topic+asr.joint'></span><span id='topic+asr.stoch'></span><span id='topic+make.asr.marginal'></span><span id='topic+make.asr.joint'></span><span id='topic+make.asr.stoch'></span>

<h3>Description</h3>

<p>Perform ancestral state reconstruction.  These functions
are all generic and will dispatch on the class of the given likelihood
functions.  Currently methods exist for all generics for Mk2, and
marginal ancestral state reconstructions are supported for BiSSE.</p>


<h3>Usage</h3>

<pre><code class='language-R'>asr.marginal(lik, pars, nodes=NULL, ...)
asr.joint(lik, pars, n=1, ...)
asr.stoch(lik, pars, n=1, ...) 

make.asr.marginal(lik, ...)
make.asr.joint(lik, ...)
make.asr.stoch(lik, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr_+3A_lik">lik</code></td>
<td>
<p>A likelihood function.</p>
</td></tr>
<tr><td><code id="asr_+3A_pars">pars</code></td>
<td>
<p>A vector of parameters, suitable for <code>lik</code>.</p>
</td></tr>
<tr><td><code id="asr_+3A_nodes">nodes</code></td>
<td>
<p>For <code>asr.marginal</code> only; an optional vector of
nodes to return ancestral states for (using ape's index).  By
default, all nodes are returned.</p>
</td></tr>
<tr><td><code id="asr_+3A_n">n</code></td>
<td>
<p>The number of samples to draw from the joint distribution, or
number of stochastic reconstructions to make.</p>
</td></tr>
<tr><td><code id="asr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed through to future methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These three functions compute marginal, joint, and stochastic
ancestral reconstructions.  The <code>make</code> versions return functions
that can efficiently be used many times over.
</p>


<h3>Value</h3>

<p>The return values of the functions are likely to change in the near
future.  Watch out!
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>See Also</h3>

<p><a href="#topic+asr.mkn">asr.mkn</a> and <a href="#topic+asr.bisse">asr.bisse</a> for methods specific to particular
classes, with examples of use.
</p>

<hr>
<h2 id='asr-bisse'>Ancestral State Reconstruction Under BiSSE</h2><span id='topic+asr.bisse'></span><span id='topic+asr.musse'></span><span id='topic+asr.marginal.bisse'></span><span id='topic+asr.marginal.musse'></span><span id='topic+make.asr.marginal.bisse'></span><span id='topic+make.asr.marginal.musse'></span>

<h3>Description</h3>

<p>Perform ancestral state reconstruction under BiSSE and
other constant rate Markov models.  Marginal reconstructions are
supported (c.f. <code><a href="#topic+asr">asr</a></code>).  Documentation is still in an
early stage, and mostly in terms of examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bisse'
make.asr.marginal(lik, ...)
## S3 method for class 'musse'
make.asr.marginal(lik, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr-bisse_+3A_lik">lik</code></td>
<td>
<p>A likelihood function, returned by <code>make.mk2</code> or
<code>make.mkn</code>.</p>
</td></tr>












<tr><td><code id="asr-bisse_+3A_...">...</code></td>
<td>
<p>Additional arguments passed through to future methods.
Currently unused.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Start with a simple tree evolved under a BiSSE with all rates
## asymmetric:
pars &lt;- c(.1, .2, .03, .06, .01, .02)
set.seed(3)
phy &lt;- trees(pars, "bisse", max.taxa=50, max.t=Inf, x0=0)[[1]]

## Here is the true history
h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy, main="True history")

## Not run: 
## BiSSE ancestral state reconstructions under the ML model
lik &lt;- make.bisse(phy, phy$tip.state)
fit &lt;- find.mle(lik, pars, method="subplex")
st &lt;- asr.marginal(lik, coef(fit))
nodelabels(thermo=t(st), piecol=1:2, cex=.5)

## Mk2 ancestral state reconstructions, ignoring the shifts in
## diversification rates:
lik.m &lt;- make.mk2(phy, phy$tip.state)
fit.m &lt;- find.mle(lik.m, pars[5:6], method="subplex")
st.m &lt;- asr.marginal(lik.m, coef(fit.m))
## The Mk2 results have more uncertainty at the root, but both are
## similar.
nodelabels(thermo=t(st.m), piecol=1:2, cex=.5, adj=-.5)

## (This section will take 10 or so minutes to run.)
## Try integrating over parameter uncertainty and comparing the BiSSE
## with Mk2 output:
prior &lt;- make.prior.exponential(2)
samples &lt;- mcmc(lik, coef(fit), 1000, w=1, prior=prior,
                print.every=100)
st.b &lt;- apply(samples[2:7], 1, function(x) asr.marginal(lik, x)[2,])
st.b.avg &lt;- rowMeans(st.b)

samples.m &lt;- mcmc(lik.m, coef(fit.m), 1000, w=1, prior=prior,
                  print.every=100)
st.m &lt;- apply(samples.m[2:3], 1, function(x) asr.marginal(lik.m, x)[2,])
st.m.avg &lt;- rowMeans(st.m)

## These end up being more striking in their similarity than their
## differences, except for the root node, where BiSSE remains more sure
## that is in state 0 (there is about 0.05 red there).
plot(h, phy, main="Marginal ASR, BiSSE (left), Mk2 (right)",
     show.node.state=FALSE)
nodelabels(thermo=1-st.b.avg, piecol=1:2, cex=.5)
nodelabels(thermo=1-st.m.avg, piecol=1:2, cex=.5, adj=-.5)

## Equivalency of Mk2 and BiSSE where diversification is state
## independent.  For any values of lambda/mu (here .1 and .03) where
## these do not vary across character states, these two methods will
## give essentially identical marginal ancestral state reconstructions.
st.id &lt;- asr.marginal(lik, c(.1, .1, .03, .03, coef(fit.m)))
st.id.m &lt;- asr.marginal(lik.m, coef(fit.m))

## Reconstructions are identical to a relative tolerance of 1e-7
## (0.0000001), which is similar to the expected tolerance of the BiSSE
## calculations.
all.equal(st.id, st.id.m, tolerance=1e-7)

## Equivalency of BiSSE and MuSSE reconstructions for two states:
lik.b &lt;- make.bisse(phy, phy$tip.state)
lik.m &lt;- make.musse(phy, phy$tip.state + 1, 2)

st.b &lt;- asr.marginal(lik.b, coef(fit))
st.m &lt;- asr.marginal(lik.m, coef(fit))

all.equal(st.b, st.m)

## End(Not run)
</code></pre>

<hr>
<h2 id='asr-mkn'>Ancestral State Reconstruction Under Mk2/Mkn</h2><span id='topic+asr.mkn'></span><span id='topic+make.asr.marginal.mk2'></span><span id='topic+make.asr.joint.mk2'></span><span id='topic+make.asr.stoch.mk2'></span><span id='topic+make.asr.marginal.mkn'></span><span id='topic+make.asr.joint.mkn'></span><span id='topic+make.asr.stoch.mkn'></span>

<h3>Description</h3>

<p>Perform ancestral state reconstruction under Mk2 and other
constant rate Markov models.  Marginal, joint, and stochastic
reconstructions are supported.  Documentation is still in an early
stage, and mostly in terms of examples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mkn'
make.asr.marginal(lik, ...)
## S3 method for class 'mkn'
make.asr.joint(lik, ...)
## S3 method for class 'mkn'
make.asr.stoch(lik, slim=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asr-mkn_+3A_lik">lik</code></td>
<td>
<p>A likelihood function, returned by <code>make.mk2</code> or
<code>make.mkn</code>.</p>
</td></tr>
<tr><td><code id="asr-mkn_+3A_slim">slim</code></td>
<td>
<p>Should the history object be slimmed down?</p>
</td></tr>
<tr><td><code id="asr-mkn_+3A_...">...</code></td>
<td>
<p>Additional arguments; currently ignored.</p>
</td></tr>

















</table>


<h3>Details</h3>

<p>Output will differ slightly when <code>mk2</code> and <code>mkn</code> models are
used as <code>lik</code>, as <code>mk2</code> uses states 0/1, while 2-state
<code>mkn</code> uses 1/2.
</p>
<p>This is all quite slow.  Faster versions are coming eventually.
</p>
<p>These functions all return functions that generate different types of
ancestral reconstruction.


</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Start with a simple tree evolved under a constant rates birth-death
## model with asymetric character evolution
pars &lt;- c(.1, .1, .03, .03, .03, .06)
set.seed(1)
phy &lt;- trees(pars, "bisse", max.taxa=50, max.t=Inf, x0=0)[[1]]

## Here is the true history.  The root node appears to be state 1 (red)
## at the root, despite specifying a root of state 0 (x0=0, in statement
## above).  This is because the tree started with a single lineage, but
## had changed state by the time the first speciation event happened.
h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy, main="True history")

## All of the methods need a likelihood function; build a mk2 function:
lik &lt;- make.mk2(phy, phy$tip.state)

## Using the true parameters, compute the marginal ancestral state
## reconstructions:
st.m &lt;- asr.marginal(lik, pars[5:6])

## There is still not a good stand-alone plotting command for nodes.
## For now, use ape's nodelabels().
plot(h, phy, main="Marginal ASR", show.node.state=FALSE)
nodelabels(thermo=t(st.m), piecol=1:2, cex=.5)

## Again, with the true parameters, a sample from the joint
## distribution:
st.j &lt;- asr.joint(lik, pars[5:6])

## Plotting this sample against the true values.
plot(h, phy, main="Joint ASR", show.node.state=FALSE)
nodelabels(pch=19, col=st.j + 1)

## This is just one sample, and is not very accurate in this case!  Make
## 1,000 such samples and average them:
st.j2 &lt;- asr.joint(lik, pars[5:6], 1000)
st.j2.mean &lt;- colMeans(st.j2)

plot(h, phy, main="Joint ASR (averaged)", show.node.state=FALSE)
nodelabels(thermo=1-st.j2.mean, piecol=1:2, cex=.5)

## Check the estimates against one another:
plot(st.m[2,], st.j2.mean, xlab="Marginal", ylab="Joint", las=1)
abline(0, 1)

## Finally, the stochastic character mapping.  This uses samples from
## the joint distribution at its core.
st.s &lt;- asr.stoch(lik, pars[5:6])
plot(st.s, phy)

## Again, multiple samples can be done at once.  There is a function for
## summarising histories, but it is still in the works.

## Repeating the above with a two-state mkn model:
lik2 &lt;- make.mkn(phy, phy$tip.state + 1, 2, FALSE)

## Everything works:
st2.m &lt;- asr.marginal(lik2, pars[5:6])
st2.j &lt;- asr.joint(lik2, pars[5:6], 100)
st2.s &lt;- asr.stoch(lik2, pars[5:6])

## Marginal likelihoods agree:
all.equal(st.m, st2.m)
## Joint reconstructions are stochastic, so just check with a
## regression:
summary(lm(colMeans(st2.j) - 1 ~ colMeans(st.j2) - 1))

## Integrate parameter uncertainty, and see how far down the tree there
## is any real information on parameter states for this tree (this takes
## about 6s)
## Not run: 
set.seed(1)
prior &lt;- make.prior.exponential(.5)
samples &lt;- mcmc(lik, pars[5:6], 1000, w=1, prior=prior, print.every=100)
st.m.avg &lt;- rowMeans(apply(samples[2:3], 1, asr.joint, lik=lik))

plot(h, phy, main="MCMC Averaged ASR", show.node.state=FALSE)
nodelabels(thermo=1 - st.m.avg, piecol=1:2, cex=.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='big.brother'>Verbosely Track Function Evaluations</h2><span id='topic+big.brother'></span>

<h3>Description</h3>

<p>This is for making function evaluations more verbose;
<code>big.brother</code> returns a function that prints its arguments and
return value every iteration (or every several iterations if
<code>interval</code> is specified)</p>


<h3>Usage</h3>

<pre><code class='language-R'>  big.brother(f, interval=1, file="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="big.brother_+3A_f">f</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="big.brother_+3A_interval">interval</code></td>
<td>
<p>Interval between printed evaluations</p>
</td></tr>
<tr><td><code id="big.brother_+3A_file">file</code></td>
<td>
<p>(Optional) file to log to.  By default, logs to the console.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Using this directly on the likelihood functions may lead to unintended
consequences as it affects the class attribute of the likelihood
function and stop it causing the correct MLE function being
dispatched.  Probably best to leave this alone.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='check'>Check Capabilities of the Diversitree Install</h2><span id='topic+check.fftC'></span>

<h3>Description</h3>

<p>These check to see if FFTW support was included in
diversitree.  They rarely need to be called directly.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.fftC(error=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_error">error</code></td>
<td>
<p>Logical: causes an error if FFTW is not
available if <code>TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='combine'>Combine Several Likelihood Functions Multiplicatively</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>Combine several likelihood functions, so that the new functions gives
the product of all likelihoods (the sum of the log likelihoods).  This
assumes that all likelihoods are independent from one another!
</p>
<p>This function is little tested.  Use at your own risk!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(liks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_liks">liks</code></td>
<td>
<p>A list of likelihood functions.  All must be of  the same
type, with the same argnames, and not constrained.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='Constants'>Constants Used by Diversitree</h2><span id='topic+ROOT.FLAT'></span><span id='topic+ROOT.EQUI'></span><span id='topic+ROOT.OBS'></span><span id='topic+ROOT.GIVEN'></span><span id='topic+ROOT.BOTH'></span><span id='topic+ROOT.ALL'></span><span id='topic+ROOT.MAX'></span>

<h3>Description</h3>

<p>These constants are used by <code><a href="#topic+make.bisse">make.bisse</a></code>, 
<code><a href="#topic+make.geosse">make.geosse</a></code> and <code><a href="#topic+make.mkn">make.mkn</a></code>
for specifying root behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROOT.FLAT
ROOT.EQUI
ROOT.OBS
ROOT.GIVEN
ROOT.BOTH
ROOT.ALL
ROOT.MAX
</code></pre>

<hr>
<h2 id='constrain'>Constrain Parameters of a Model</h2><span id='topic+constrain'></span><span id='topic+constrain.i'></span>

<h3>Description</h3>

<p>Constrain a model to make submodels with fewer parameters.
If <code>f</code> is a function that takes a vector <code>x</code> as its first
argument, this function returns a new function that takes a
shorter vector <code>x</code> with some elements constrained in some way;
parameters can be fixed to particular values, constrained to be the
same as other parameters, or arbitrary expressions of free
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain(f, ..., formulae=NULL, names=argnames(f), extra=NULL)
constrain.i(f, p, i.free)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constrain_+3A_f">f</code></td>
<td>
<p>A function to constrain.</p>
</td></tr>
<tr><td><code id="constrain_+3A_...">...</code></td>
<td>
<p>Formulae indicating how the function should be constrained
(see Details and Examples).</p>
</td></tr>
<tr><td><code id="constrain_+3A_formulae">formulae</code></td>
<td>
<p>Optional list of constraints, possibly in addition to
those in <code>...</code></p>
</td></tr>
<tr><td><code id="constrain_+3A_names">names</code></td>
<td>
<p>Optional Character vector of names, the same length as
the number of parameters in <code>x</code>.  Use this only if
<code><a href="#topic+argnames">argnames</a></code> does not return a vector for your function.
Generally this should not be used.</p>
</td></tr>
<tr><td><code id="constrain_+3A_extra">extra</code></td>
<td>
<p>Optional vector of additional names that might appear on
the RHS of constraints but do not represent names in the function's
<code>argnames</code>.  This can be used to set up dummy variables
(example coming later).</p>
</td></tr>
<tr><td><code id="constrain_+3A_p">p</code></td>
<td>
<p>A parameter vector (for <code>constrain.i</code>) indicating values
for all parameters.</p>
</td></tr>
<tr><td><code id="constrain_+3A_i.free">i.free</code></td>
<td>
<p>Indices of the parameters that are <strong>not</strong>
constrained.  Other indices will get the value in <code>p</code>.  The
element of <code>p[i.free]</code> will never be used and can be zero,
<code>NA</code>, or any other value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relationships are specified in the form <code>target ~ rel</code>, where
<code>target</code> is the name of a vector to be constrained, and
<code>rel</code> is some relationship.  For example <code>lambda0 ~ lambda1</code>
would have the effect of making the parameters <code>lambda0</code> and
<code>lambda1</code> take the same value.
</p>
<p>The <code>rel</code> term can be a constant (e.g., <code>target ~ 0</code>),
another parameter (as above) or some expression of the parameters
(e.g., <code>lambda0 ~ 2 * lambda1</code> or
<code>lambda0 ~ lambda1 - mu1</code>).
</p>
<p>Terms that appear on the right hand side of an expression may not be
constrained in another expression, and no term may be constrained
twice.
</p>


<h3>Value</h3>

<p>This function returns a constrained function that can be passed
through to <code><a href="#topic+find.mle">find.mle</a></code> and <code>mcmc</code>.  It will behave
like any other function.  However, it has a modified <code>class</code>
attribute so that some methods will dispatch differently
(<code>argnames</code>, for example).  All arguments in addition to <code>x</code>
will be passed through to the original function <code>f</code>.
</p>
<p>For help in designing constrained models, the returned function has
an additional argument <code>pars.only</code>, when this is <code>TRUE</code> the
function will return a named vector of arguments rather than evaluate
the function (see Examples).
</p>


<h3>Warning</h3>

<p>Only a few checks are done to ensure that the resulting function makes
any sense; it is possible that I have missed some cases.  There is
currently no way of modifying constrained functions to remove the
constraints.  These weaknesses will be addressed in a future version.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## Same example likelihood function as for \link{find.mle} - BiSSE on a
## tree with 203 species, generated with an asymmetry in the speciation
## rates.
pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(2)
phy &lt;- tree.bisse(pars, max.t=60, x0=0)
lik &lt;- make.bisse(phy, phy$tip.state)

argnames(lik) # Canonical argument names

## Specify equal speciation rates
lik.2 &lt;- constrain(lik, lambda0 ~ lambda1)
argnames(lik.2) # Note lambda0 now missing

## On constrained functions, use the "pars.only" argument to see what
## the full argument list would be:
lik.2(c(.1, pars[3:6]), pars.only=TRUE)

## Check this works:
lik(c(.1, .1, pars[3:6])) == lik.2(c(.1, pars[3:6]))

## For optimisation of these functions, see \link{find.mle}, which
## includes an example.

## More complicated; constrain lambda0 to half of lambda1, constrain mu0
## to be the same mu1, and set q01 equal to zero.
lik.3 &lt;- constrain(lik, lambda0 ~ lambda1 / 2, mu0 ~ mu1, q01 ~ 0)
argnames(lik.3) # lambda1, mu1, q10
lik(c(.1, .2, .03, .03, 0, .01)) == lik.3(c(.2, .03, .01))

## Alternatively, coefficients can be specified using a list of
## constraints:
cons &lt;- list(lambda1 ~ lambda0, mu1 ~ mu0, q10 ~ q01)
constrain(lik, formulae=cons)

## Using the "extra" argument allows recasting things to dummy
## parameters.  Here both lambda0 and lambda1 are mapped to the
## parameter "lambda":
lik.4 &lt;- constrain(lik, lambda0 ~ lambda, lambda1 ~ lambda, extra="lambda")
argnames(lik.4)

## constrain.i can be useful for setting a number of values at once.
## Suppose we wanted to look at the shape of the likelihood surface with
## respect to one parameter around the ML point.  For this tree, the ML
## point is approximately:
p.ml &lt;- c(0.09934, 0.19606, 0.02382, 0.03208, 0.01005, 0.00982)

## Leaving just lambda1 (which is parameter number 2) free:
lik.l1 &lt;- constrain.i(lik, p.ml, 2)

## The function now reports that five of the parameters are constrained,
## with one free (lambda1)
lik.l1

## Likewise:
argnames(lik.l1)

## Looking in the neighbourhood of the ML point, the likelihood surface
## is approximately quadratic:
pp &lt;- seq(p.ml[2] - .02, p.ml[2] + .02, length.out=15)
yy &lt;- sapply(pp, lik.l1)
plot(yy ~ pp, type="b", xlab="lambda 1", ylab="Log likelihood")
abline(v=p.ml[2], col="red", lty=2)

## pars.only works as above, returning the full parameter vector
lik.l1(p.ml[2], pars.only=TRUE)
identical(p.ml, lik.l1(p.ml[2], pars.only=TRUE))
</code></pre>

<hr>
<h2 id='diversitree-deprecated'>Deprecated and Defunct Functions in Diversitree</h2><span id='topic+diversitree-deprecated'></span><span id='topic+polytomies.to.clades'></span>

<h3>Description</h3>

<p>These functions have all been replaced by other functions.
A warning is given when a deprecated function is used, and an error is
given when a defunct function is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
polytomies.to.clades(tree)
</code></pre>


<h3>Details</h3>

<p><code>polytomies.to.clades</code> has been renamed to
<code><a href="#topic+clades.from.polytomies">clades.from.polytomies</a></code>, for consistency with other
functions.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>, <code><a href="base.html#topic+Deprecated">Deprecated</a></code>
</p>

<hr>
<h2 id='diversitree-package'>
Comparative 'Phylogenetic' Analyses of Diversification
</h2><span id='topic+diversitree-package'></span><span id='topic+diversitree'></span>

<h3>Description</h3>

<p>Contains a number of comparative 'phylogenetic' methods,
  mostly focusing on analysing diversification and character
  evolution.  Contains implementations of 'BiSSE' (Binary State
  'Speciation' and Extinction) and its unresolved tree extensions,
  'MuSSE' (Multiple State 'Speciation' and Extinction), 'QuaSSE',
  'GeoSSE', and 'BiSSE-ness' Other included methods include Markov
  models of discrete and continuous trait evolution and constant rate
  'speciation' and extinction.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn [aut, cre],
  Emma Goldberg [aut],
  Karen Magnuson-Ford [aut],
  Roger Sidje [aut]
</p>
<p>Maintainer: Richard G. FitzJohn &lt;rich.fitzjohn@gmail.com&gt;
</p>


<h3>References</h3>

<p>Diversitree contains methods described in the following papers (all of
which aside from Maddison et al. 2007 were originally published as a
diversitree implementation).
</p>

<ul>
<li><p>FitzJohn R.G., Maddison W.P., and Otto S.P. 2009. Estimating
trait-dependent speciation and extinction rates from incompletely
resolved phylogenies. systematic biology 58:595-611. Systematic
Biology 58:595-611.
</p>
</li>
<li><p>FitzJohn R.G. 2010. Quantitative traits and
diversification. Systematic Biology 59:619-633.
</p>
</li>
<li><p>Goldberg E.E., Lancaster L.T., Ree R.H. 2011. Phylogenetic
inference of reciprocal effects between geographic range evolution
and diversification.  Systematic Biology 60: 451-465.
</p>
</li>
<li><p>Maddison W.P., Midford P.E., and Otto S.P. 2007.  Estimating a
binary character's effect on speciation and extinction.
Systematic Biology 56: 701-710.
</p>
</li>
<li><p>Magnuson-Ford K. and Otto S.P. 2012. Linking the
investigations of character evolution and species
diversification. The American Naturalist 180: 225-245.
</p>
</li></ul>


<hr>
<h2 id='find.mle'>Maximimum Likelihood Inference</h2><span id='topic+find.mle'></span><span id='topic+coef.fit.mle'></span><span id='topic+logLik.fit.mle'></span><span id='topic+anova.fit.mle'></span>

<h3>Description</h3>

<p>Find the maximum likelihood point of a model by nonlinear
optimisation.  <code>find.mle</code> is generic, and allows different
default behaviour for different likelihood functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.mle(func, x.init, method, ...)
## S3 method for class 'fit.mle'
coef(object, full=FALSE, extra=FALSE, ...)
## S3 method for class 'fit.mle'
logLik(object, ...)
## S3 method for class 'fit.mle'
anova(object, ..., sequential=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.mle_+3A_func">func</code></td>
<td>
<p>A likelihood function.  This is assumed to return the log
likelihood (see Details).  The function must take a vector of
parameters as the first argument.</p>
</td></tr>
<tr><td><code id="find.mle_+3A_x.init">x.init</code></td>
<td>
<p>Initial starting point for the optimisation.</p>
</td></tr>
<tr><td><code id="find.mle_+3A_method">method</code></td>
<td>
<p>Method to use for optimisation.  May be one of &quot;optim&quot;,
&quot;subplex&quot;, &quot;nlminb&quot;, &quot;nlm&quot; (partial unambigious string is allowed).</p>
</td></tr>
<tr><td><code id="find.mle_+3A_...">...</code></td>
<td>
<p>For <code>find.mle</code>, additional arguments passed through to
the methods, optimisation routines, or to the likelihood function
<code>func</code> - see Details.  For <code>anova</code>, this is one or more
models to compare against the model <code>object</code> (either submodels
or supermodels or the test is meaningless).</p>
</td></tr>
<tr><td><code id="find.mle_+3A_object">object</code></td>
<td>
<p>A fitted model, returned by <code>find.mle</code>.</p>
</td></tr>
<tr><td><code id="find.mle_+3A_full">full</code></td>
<td>
<p>When returning the coefficients for a constrained model,
should be coefficients for the underlying constrained model be
returned?</p>
</td></tr>
<tr><td><code id="find.mle_+3A_extra">extra</code></td>
<td>
<p>When returning the coefficients for a constrained model,
should dummy &ldquo;extra&rdquo; parameters be returned as well?</p>
</td></tr>
<tr><td><code id="find.mle_+3A_sequential">sequential</code></td>
<td>
<p>Should <code>anova</code> treat the models as a series of
increasing complexity?  Currently this is a little overzealous in
checking and will refuse to work if the likelihood values are not
strictly increasing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>find.mle</code> starts a search for the maximum likelihood (ML)
parameters from a starting point <code>x.init</code>.  <code>x.init</code> should
be the correct length for <code>func</code>, so that <code>func(x.init)</code>
returns a valid likelihood.  However, if <code>func</code> is a constrained
function (via <code><a href="#topic+constrain">constrain</a></code>) and <code>x.init</code> is the
correct length for the unconstrained function then an attempt will be
made to guess a valid starting point.  This will often do poorly and a
warning will be given.
</p>
<p>Different methods will be dispatched for different types of likelihood
functions.  Currently all models in <code>diversitree</code> are supported
(<code>bisse</code>, <code>geosse</code>, <code>mk2</code>, <code>mkn</code>, <code>bd</code>, and 
<code>yule</code>).  With the exception of the Yule pure-birth process, these
methods just specify different default arguments for the underlying
optimisation routines (the Yule model has an analytical solution, and no
optimisation step is required).  Generally, it will not be necessary
to specify the <code>method</code> argument to <code>find.mle</code> as a sensible
method is chosen during dispatch.
</p>
<p>The <code>...</code> argument may contain additional arguments for the
function <code>func</code>.  This includes things like <code>condition.surv</code>
for conditioning on survival in BiSSE, birth-death, and Yule models.
Specify this as
</p>
<pre>
    find.mle(lik, x.init, condition.surv=TRUE)
  </pre>
<p>(see the Examples).
</p>
<p>Different <code>method</code> arguments take different arguments passed
through <code>...</code> to control their behaviour:
</p>
<p><code>method="optim"</code>: Uses <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+optim">optim</a></code> function for the
optimisation.  This allows access to a variety of general purpose
optimisation algorithms.  The method <em>within</em> <code>optim</code> can be
chosen via the argument <code>optim.method</code>, which is set to
&quot;L-BFGS-B&quot; by default (box constrained quasi-Newton optimisation).
This should be suitable for most uses.  See the <code>method</code> argument
of <code><a href="stats.html#topic+optim">optim</a></code> for other possibilities.  If <code>"L-BFGS-B"</code>
is used, then upper and lower bounds may be specified by the arguments
<code>lower</code> and <code>upper</code>.  The argument <code>control</code> can be
used to specify other control parameters for the algorithms - see
<code><a href="stats.html#topic+optim">optim</a></code> for details.  Most of the <code>optim</code> algorithms
require finite values be returned at every evaluated point.  This is
often not possible (extreme values of parameters or particular
combinations may have zero likelihood and therefore -Inf
log-likelihood).  To get around this, the argument <code>fail.value</code>
can be used to specify a fallback value.  By default this is set to
<code>func(x.init) - 1000</code>, which should work reasonably well for most
cases.
</p>
<p><code>method="subplex"</code>: Uses the &quot;subplex&quot; algorithm (a variant of
the downhill simplex/Nelder-Mead algorithm that uses Nelder-Mead on a
sequence of subspaces).  This algorithm generally requires more
evaluations than <code>optim</code>-based optimisation, but does not require
approximation of derivatives and seems to find the global optimum more
reliably (though often less precisely).  Additional arguments are
<code>control</code> to control aspects of the search (see
<code><a href="subplex.html#topic+subplex">subplex</a></code> for details).  The argument <code>fail.value</code>
can be used as in <code>method="optim"</code>, but by default <code>-Inf</code>
will be used on failure to evaluate, which is generally appropriate.
</p>
<p><code>method="nlminb"</code>: Uses the function <code><a href="stats.html#topic+nlminb">nlminb</a></code> for
optimisation, so that optimising a Mk2/Mkn likelihood function behaves
as similarly as possible to <code>ape</code>'s <code><a href="ape.html#topic+ace">ace</a></code> function.
As for <code>method="optim"</code>, lower and upper bounds on parameters may
be specified via <code>lower</code> and <code>upper</code>.  <code>fail.value</code> can
be used to control behaviour on evaluation failure, but like
<code>method="subplex"</code>, <code>-Inf</code> is used which should work in most
cases.  Additional control parameters may be passed via <code>control</code>
- see <code>link{nlminb} for details</code>.  This function is not generally
recommended for use.
</p>
<p><code>method="nlm"</code>: Uses the function <code><a href="stats.html#topic+nlm">nlm</a></code> for
optimisation, so that optimising a birth-death likelihood function
behaves as similarly as possible to <code>ape</code>'s
<code><a href="ape.html#topic+birthdeath">birthdeath</a></code> function.  Takes the same additional
arguments as <code>method="nlminb"</code> (except that <code>fail.value</code>
behaves as for <code>method="optim"</code>).  Like <code>method="nlminb"</code>,
this is not recommended for general use.
</p>
<p><code>code</code> and <code>logLik</code> methods exist for <code>fit.mle</code> objects
so that parameters and log-likelihoods may be extracted.  This also
allows use with <code><a href="stats.html#topic+AIC">AIC</a></code>.
</p>
<p>Simple model comparison by way of likelihood ratio tests can be
performed with <code><a href="stats.html#topic+anova">anova</a></code>.  See Examples for usage.
</p>


<h3>Value</h3>

<p>A list of class <code>fit.mle</code>, with at least the components
</p>

<ul>
<li> <p><code>par</code> The estimated parameters.
</p>
</li>
<li> <p><code>lnLik</code> The log likelihood at the ML point.
</p>
</li>
<li> <p><code>counts</code> The number of function evaluations performed
during the search.
</p>
</li>
<li> <p><code>code</code> Convergence code.  See the documentation for the
underlying optimisation method for meaning, but &quot;0&quot; is usually good.
</p>
</li>
<li> <p><code>func</code> The likelihood function used in the fit.
</p>
</li>
<li> <p><code>method</code> The optimisation method used.
</p>
</li></ul>



<h3>Model comparison</h3>

<p>The <code><a href="stats.html#topic+anova">anova</a></code> function carries out likelihood ratio tests.
There are a few possible configurations.
</p>
<p>First, the first fit provided could be the focal fit, and all other
fits are either special cases of it (every additional model is nested
within the focal model) or generalisations of it (the focal model is
nested within every additional model).
</p>
<p>Second, the models could be sequential series of fits (if
<code>sequential=TRUE</code>), such that models (A, B, C, D) are to be
compared A vs. B, B vs. C, C vs. D.  The models can either be strictly
increasing in parameters (A nested in B, B nested in C, ...) or
strictly decreasing in parameters (D nested in C, C nested in B, ...).
</p>
<p>In both cases, nestedness is checked.  First, the &quot;class&quot; of the
fitted object must match.  Second, the <code><a href="#topic+argnames">argnames</a></code> of the
likelihood function of a sub model must all appear in the
<code>argnames</code> of the parent model.  There are some cases where this
second condition may not be satisfied and yet the comparison is valid
(e.g., comparing a time-varying model against a non time varying
model, and some <code>make.quasse</code> fits).  We attempt to detect this
but it may fail on some valid comparisons and silently allow some
invalid comparisons.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(2)
phy &lt;- tree.bisse(pars, max.t=60, x0=0)

## Here is the 203 species tree with the true character history coded.
## Red is state '1', which has twice the speciation rate of black (state
## '0').
h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy, cex=.5, show.node.state=FALSE)

## Make a BiSSE likelihood function
lik &lt;- make.bisse(phy, phy$tip.state)
lik(pars)

## This takes ~30s to run, so is not enabled by default
## Not run: 
## Fit the full six-parameter model
fit &lt;- find.mle(lik, pars)
fit[1:2]

coef(fit)   # Named vector of six parameters
logLik(fit) # -659.93
AIC(fit)    # 1331.86

## find.mle works with constrained models (see \link{constrain}).  Here
## the two speciation rates are constrained to be the same as each
## other.
lik.l &lt;- constrain(lik, lambda0 ~ lambda1)
fit.l &lt;- find.mle(lik.l, pars[-2])
logLik(fit.l) # 663.41

## Compare the models with \link{anova} - this shows that the more
## complicated model with two separate speciation rates fits
## significantly better than the simpler model with equal rates
## (p=0.008).
anova(fit, equal.lambda=fit.l)

## You can return the parameters for the full six parameter model from
## the fitted five parameter model - this makes a good starting point
## for a ML search.
coef(fit.l, full=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='history.from.sim'>Extract Character Histories From Simulations</h2><span id='topic+history.from.sim.discrete'></span>

<h3>Description</h3>

<p>This function extracts a history object from a simulated
phylogeny produced by <code><a href="#topic+tree.bisse">tree.bisse</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>history.from.sim.discrete(phy, states)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="history.from.sim_+3A_phy">phy</code></td>
<td>
<p>A phylogeny produced by <code><a href="#topic+tree.bisse">tree.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="history.from.sim_+3A_states">states</code></td>
<td>
<p>Possible states.  For <code><a href="#topic+tree.bisse">tree.bisse</a></code> this
should be <code>0:1</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='make.bd'>Constant Rate Birth-Death Models</h2><span id='topic+make.bd'></span><span id='topic+make.yule'></span><span id='topic+starting.point.bd'></span>

<h3>Description</h3>

<p>Prepare to run a constant rate birth-death model on a
phylogenetic tree.  This fits the Nee et al. 1994 equation,
duplicating the <code>birthdeath</code> function in ape.  Differences with
that function include (1) the function is not constrained to positive
diversification rates (mu can exceed lambda), (2) [eventual] support
for both random taxon sampling and unresolved terminal clades (but see
<code>bd.ext</code>), and (3) run both MCMC and MLE fits to birth death
trees.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bd(tree, sampling.f=NULL, unresolved=NULL, times=NULL, control=list())
make.yule(tree, sampling.f=NULL, unresolved=NULL, times=NULL, control=list())
starting.point.bd(tree, yule=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bd_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bd_+3A_times">times</code></td>
<td>
<p>Vector of branching times, as returned by
<code>branching.times</code>.  You don't need to use this unless you know
that you need to use this.  Don't use it at the same time as
<code>tree</code>.</p>
</td></tr>
<tr><td><code id="make.bd_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Probability of an extant species being included in
the phylogeny (sampling fraction).  By default, all extant species are
assumed to be included.</p>
</td></tr>
<tr><td><code id="make.bd_+3A_unresolved">unresolved</code></td>
<td>
<p>Unresolved clade information.  This is a named
vector, with the number of species as the value and names
corresponding to tip labels.  Tips that represent a single species
should not be included in this vector.  For example
<code>sp1=10, sp2=2</code>, would mean that <code>sp1</code> represents 10
species, while <code>sp2</code> represents two.  These labels must exist
in <code>tree$tip.label</code> and all other tips are assumed to
represent one species.</p>
</td></tr>
<tr><td><code id="make.bd_+3A_yule">yule</code></td>
<td>
<p>Should the starting point function return a Yule model
(zero extinction rate)?</p>
</td></tr>
<tr><td><code id="make.bd_+3A_control">control</code></td>
<td>
<p>List of control parameters.  The element <code>method</code>
can be either <code>nee</code> or <code>ode</code> to compute the likelihood
using the equation from Nee et al. (1994) or in a BiSSE-style ODE
approach respectively.  <code>nee</code> should be faster, and <code>ode</code>
is provided for completeness (and forms the basis of other methods).
When <code>ode</code> is selected, other elements of <code>control</code> affect
the behaviour of the ODE solver: see details in
<code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.bd</code> returns a function of class <code>bd</code>.
This function has argument list (and default values)
</p>
<pre>
    f(pars, prior=NULL, condition.surv=TRUE)
  </pre>
<p>The arguments are interpreted as
</p>

<ul>
<li> <p><code>pars</code> A vector of two parameters, in the order
<code>lambda</code>, <code>mu</code>.
</p>
</li>
<li> <p><code>prior</code>: a valid prior.  See <code><a href="#topic+make.prior">make.prior</a></code> for
more information.
</p>
</li>
<li> <p><code>condition.surv</code> (logical): should the likelihood
calculation condition on survival of two lineages and the speciation
event subtending them?  This is done by default, following Nee et
al. 1994.
</p>
</li></ul>

<p>The function &quot;ode&quot; method is included for completeness, but should not
be taken too seriously.  It uses an alternative ODE-based approach,
more similar to most diversitree models, to compute the likelihood.
It exists so that other models that extend the birth-death models may
be tested.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>References</h3>

<p>Nee S., May R.M., and Harvey P.H. 1994. The reconstructed
evolutionary process. Philos.  Trans. R. Soc. Lond. B
Biol. Sci. 344:305-311.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain">constrain</a></code> for making submodels, <code><a href="#topic+find.mle">find.mle</a></code>
for ML parameter estimation, <code><a href="#topic+mcmc">mcmc</a></code> for MCMC integration,
and <code><a href="#topic+make.bisse">make.bisse</a></code> for state-dependent birth-death models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a tree under a constant rates birth-death model and look at
## the maximum likelihood speciation/extinction parameters:
set.seed(1)
phy &lt;- trees(c(.1, .03), "bd", max.taxa=25)[[1]]
lik &lt;- make.bd(phy)

## By default, optimisation gives a lambda close to 0.1 and extremely
## small mu:
fit &lt;- find.mle(lik, c(.1, .03))
coef(fit)

## The above optimisation uses the algorithm \link{nlm} for
## compatibility with ape's \link{birthdeath}.  This can be slightly
## improved by using \link{optim} for the optimisation, which allows
## bounds to be specified:
fit.o &lt;- find.mle(lik, c(.1, .03), method="optim", lower=0)
coef(fit.o)

logLik(fit.o) - logLik(fit) # slight improvement

## Special case methods are worked out for the Yule model, for which
## analytic solutions are available.  Compare a direct fit of the Yule
## model with one where mu is constrained to be zero:
lik.yule &lt;- make.yule(phy)
lik.mu0 &lt;- constrain(lik, mu ~ 0)

## The same to a reasonable tolerance:
fit.yule &lt;- find.mle(lik.yule, .1)
fit.mu0 &lt;- find.mle(lik.mu0, .1)
all.equal(fit.yule[1:2], fit.mu0[1:2], tolerance=1e-6)

## There is no significant improvement in the fit by including the mu
## parameter (unsurprising as the ML value was zero)
anova(fit.o, yule=fit.yule)

## Optimisation can be done without conditioning on survival:
fit.nosurv &lt;- find.mle(lik, c(.1, .03), method="optim", lower=0,
                       condition.surv=FALSE)
coef(fit.nosurv) # higher lambda than before

## Look at the marginal likelihoods, computed through MCMC (see
## \link{mcmc} for details, and increase nsteps for smoother
## plots [takes longer]).
samples &lt;- mcmc(lik, fit$par, nsteps=500,
                lower=c(-Inf, -Inf), upper=c(Inf, Inf), w=c(.1, .1),
                fail.value=-Inf, print.every=100)
samples$r &lt;- with(samples, lambda - mu)

## Plot the profiles (see \link{profiles.plot}).
## The vertical lines are the simulated parameters, which match fairly
## well with the estimated ones.
col &lt;- c("red", "blue", "green3")
profiles.plot(samples[c("lambda", "mu", "r")], col.line=col, las=1,
              legend="topright")
abline(v=0, lty=2)
abline(v=c(.1, .03, .07), col=col)

## Sample the phylogeny to include 20 of the species, and run the
## likelihood search assuming random sampling:
set.seed(1)
phy2 &lt;- drop.tip(phy, sample(25, 5))
lik2 &lt;- make.bd(phy2, sampling.f=20/25)
fit2 &lt;- find.mle(lik2, c(.1, .03))

## The ODE based version gives comparable results.  However, it is
## about 55x slower.
lik.ode &lt;- make.bd(phy, control=list(method="ode"))
all.equal(lik.ode(coef(fit)), lik(coef(fit)), tolerance=2e-7)
</code></pre>

<hr>
<h2 id='make.bd.split'>Constant Rate Birth-Death Models: Split Models</h2><span id='topic+make.bd.split'></span>

<h3>Description</h3>

<p>Create a likelihood function for a birth-death model where
the tree is partitioned into regions with different parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bd.split(tree, nodes, split.t, sampling.f=NULL, unresolved=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bd.split_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bd.split_+3A_nodes">nodes</code></td>
<td>
<p>Vector of nodes that will be split (see Details).</p>
</td></tr>
<tr><td><code id="make.bd.split_+3A_split.t">split.t</code></td>
<td>
<p>Vector of split times, same length as <code>nodes</code> (see
Details).</p>
</td></tr>
<tr><td><code id="make.bd.split_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Probability of an extant species being included in
the phylogeny (sampling fraction).  By default, all extant species are
assumed to be included.</p>
</td></tr>
<tr><td><code id="make.bd.split_+3A_unresolved">unresolved</code></td>
<td>
<p>Unresolved clade information.  This is a named
vector, with the number of species as the value and names
corresponding to tip labels.  Tips that represent a single species
should not be included in this vector.  For example
<code>sp1=10, sp2=2</code>, would mean that <code>sp1</code> represents 10
species, while <code>sp2</code> represents two.  These labels must exist
in <code>tree$tip.label</code> and all other tips are assumed to
represent one species.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branching times can be controlled with the <code>split.t</code>
argument.  If this is <code>Inf</code>, split at the base of the branch (as in
MEDUSA).  If <code>0</code>, split at the top (closest to the present, as in
the new option for MEDUSA).  If <code>0 &lt; split.t &lt; Inf</code> then we split
at that time on the tree (zero is the present, with time growing
backwards).
</p>

<p>This function is related to MEDUSA (Alfaro et al. 2009), but does not
include any of the code for efficiently moving between different splits
(split creation here is fairly slow).  The primary use for this model is
for generating starting points for state dependent split models (e.g.,
<code><a href="#topic+make.bisse.split">make.bisse.split</a></code>) and testing <em>a priori</em> splits.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
pars &lt;- c(.1, .03)
phy &lt;- trees(pars, "bd", max.taxa=30)[[1]]

## Here is the phylogeny:
plot(phy, show.node.label=TRUE, label.offset=.1, font=1, cex=.75,
     no.margin=TRUE)

## Construct the plain likelihood function as a benchmark:
lik &lt;- make.bd(phy)
lik(pars) # -21.74554

## Split this phylogeny at three points: nd11, nd13 and nd26
nodes &lt;- c("nd11", "nd13", "nd26")

## This is the index in ape's node indexing:
nodes.i &lt;- match(nodes, phy$node.label) + length(phy$tip.label)

nodelabels(node=nodes.i, pch=19, cex=2, col="#FF000099")

## To make a split likelihood function, pass the node locations and times in:
lik.s &lt;- make.bd.split(phy, nodes)

## The parameters must be a list of the same length as the number of
## partitions.  Partition '1' is the root partition, and partition i is
## the partition rooted at the node[i-1]
pars4 &lt;- rep(pars, 4)
names(pars4) &lt;- argnames(lik.s)

## Run the likelihod calculation:
lik.s(pars4) # -21.74554

## These are basically identical (to acceptable tolerance)
lik.s(pars4) - lik(pars)

## You can use the labelled nodes rather than indices:
lik.s2 &lt;- make.bd.split(phy, nodes)
identical(lik.s(pars4), lik.s2(pars4))

## All the usual ML/MCMC functions work as before:
fit &lt;- find.mle(lik.s, pars4)
</code></pre>

<hr>
<h2 id='make.bd.t'>Time-varing Birth-Death Models</h2><span id='topic+make.bd.t'></span>

<h3>Description</h3>

<p>Create a likelihood function for the birth-death model,
where birth and/or death rates are arbitrary functions of time.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bd.t(tree, functions, sampling.f=NULL, unresolved=NULL,
          control=list(), truncate=FALSE, spline.data=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bd.t_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bd.t_+3A_functions">functions</code></td>
<td>
<p>A named list of functions of time.  See details.</p>
</td></tr>
<tr><td><code id="make.bd.t_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Probability of an extant species being included in
the phylogeny (sampling fraction).  By default, all extant species are
assumed to be included.</p>
</td></tr>
<tr><td><code id="make.bd.t_+3A_unresolved">unresolved</code></td>
<td>
<p>Not yet included: present in the argument list for
future compatibility with <code><a href="#topic+make.bd">make.bd</a></code>.</p>
</td></tr>
<tr><td><code id="make.bd.t_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.bd.t_+3A_truncate">truncate</code></td>
<td>
<p>Logical, indicating if functions should be truncated
to zero when negative (rather than causing an error).  May be
scalar (applying to all functions) or a vector (of length 2).</p>
</td></tr>
<tr><td><code id="make.bd.t_+3A_spline.data">spline.data</code></td>
<td>
<p>List of data for spline-based time functions.  See
details</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First, show equivalence to the plain Birth-death model.  This is not
## a very interesting use of the functions, but it serves as a useful
## check.

## Here is a simulated 25 species tree for testing.
set.seed(1)
pars &lt;- c(.1, .03)
phy &lt;- trees(pars, "bd", max.taxa=25)[[1]]

## Next, make three different likelihood functions: a "normal" one that
## uses the direct birth-death calculation, an "ode" based one (that
## uses numerical integration to compute the likelihood, and is
## therefore not exact), and one that is time-varying, but that the
## time-dependent functions are constant.t().
lik.direct &lt;- make.bd(phy)
lik.ode &lt;- make.bd(phy, control=list(method="ode"))
lik.t &lt;- make.bd.t(phy, c("constant.t", "constant.t"))

lik.direct(pars) # -22.50267

## ODE-based likelihood calculations are correct to about 1e-6.
lik.direct(pars) - lik.ode(pars)

## The ODE calculation agrees exactly with the time-varying (but
## constant) calculation.
lik.ode(pars) - lik.t(pars)

## Next, make a real case, where speciation is a linear function of
## time.
lik.t2 &lt;- make.bd.t(phy, c("linear.t", "constant.t"))

## Confirm that this agrees with the previous calculations when the
## slope is zero
pars2 &lt;- c(pars[1], 0, pars[2])
lik.t2(pars2) - lik.t(pars)

## The time penalty comes from moving to the ODE-based solution, not
## from the time dependence.
system.time(lik.direct(pars)) # ~ 0.000
system.time(lik.ode(pars))    # ~ 0.003
system.time(lik.t(pars))      # ~ 0.003
system.time(lik.t2(pars2))    # ~ 0.003

## Not run: 
fit &lt;- find.mle(lik.direct, pars)
fit.t2 &lt;- find.mle(lik.t2, pars2)

## No significant improvement in model fit:
anova(fit, time.varying=fit.t2)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.bisse'>Binary State Speciation and Extinction Model</h2><span id='topic+make.bisse'></span><span id='topic+starting.point.bisse'></span>

<h3>Description</h3>

<p>Prepare to run BiSSE (Binary State Speciation and
Extinction) on a phylogenetic tree and character distribution.  This
function creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bisse(tree, states, unresolved=NULL, sampling.f=NULL, nt.extra=10,
           strict=TRUE, control=list())
starting.point.bisse(tree, q.div=5, yule=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bisse_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0 or
1, or <code>NA</code> if the state is unknown.  This vector must have
names that correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips
corresponding to unresolved clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_unresolved">unresolved</code></td>
<td>
<p>Unresolved clade information: see section below for
structure.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 2 with the estimated proportion of
extant species in state 0 and 1 that are included in the phylogeny.
A value of <code>c(0.5, 0.75)</code> means that half of species in state 0
and three quarters of species in state 1 are included in the
phylogeny.  By default all species are assumed to be known.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_nt.extra">nt.extra</code></td>
<td>
<p>The number of species modelled in unresolved clades
(this is in addition to the largest observed clade).</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details below.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are 0 and 1 only.  If <code>strict</code> is <code>TRUE</code>
(the default), then the additional check is made that <em>every</em>
state is present.  The likelihood models tend to be poorly behaved
where states are missing.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_q.div">q.div</code></td>
<td>
<p>Ratio of diversification rate to character change rate.
Eventually this will be changed to allow for Mk2 to be used for
estimating q parameters.</p>
</td></tr>
<tr><td><code id="make.bisse_+3A_yule">yule</code></td>
<td>
<p>Logical: should starting parameters be Yule estimates
rather than birth-death estimates?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.bisse</code> returns a function of class <code>bisse</code>.  This
function has argument list (and default values)
</p>
<pre>
    f(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL,
      intermediates=FALSE)
  </pre>
<p>The arguments are interpreted as
</p>

<ul>
<li> <p><code>pars</code> A vector of six parameters, in the order
<code>lambda0</code>, <code>lambda1</code>, <code>mu0</code>, <code>mu1</code>,
<code>q01</code>, <code>q10</code>.
</p>
</li>
<li> <p><code>condition.surv</code> (logical): should the likelihood
calculation condition on survival of two lineages and the speciation
event subtending them?  This is done by default, following Nee et
al. 1994.
</p>
</li>
<li> <p><code>root</code>: Behaviour at the root (see Maddison et al. 2007,
FitzJohn et al. 2009).  The possible options are
</p>

<ul>
<li> <p><code>ROOT.FLAT</code>: A flat prior, weighting
<code class="reqn">D_0</code> and <code class="reqn">D_1</code> equally.
</p>
</li>
<li> <p><code>ROOT.EQUI</code>: Use the equilibrium distribution
of the model, as described in Maddison et al. (2007).
</p>
</li>
<li> <p><code>ROOT.OBS</code>: Weight <code class="reqn">D_0</code> and
<code class="reqn">D_1</code> by their relative probability of observing the
data, following FitzJohn et al. 2009:
</p>
<p style="text-align: center;"><code class="reqn">D = D_0\frac{D_0}{D_0 + D_1} + D_1\frac{D_1}{D_0 + D_1}</code>
</p>

</li>
<li> <p><code>ROOT.GIVEN</code>: Root will be in state 0
with probability <code>root.p[1]</code>, and in state 1 with
probability <code>root.p[2]</code>.
</p>
</li>
<li> <p><code>ROOT.BOTH</code>: Don't do anything at the root,
and return both values.  (Note that this will not give you a
likelihood!).
</p>
</li></ul>

</li>
<li> <p><code>root.p</code>: Root weightings for use when
<code>root=ROOT.GIVEN</code>.  <code>sum(root.p)</code> should equal 1.
</p>
</li>
<li> <p><code>intermediates</code>: Add intermediates to the returned value as
attributes:
</p>

<ul>
<li> <p><code>cache</code>: Cached tree traversal information.
</p>
</li>
<li> <p><code>intermediates</code>: Mostly branch end information.
</p>
</li>
<li> <p><code>vals</code>: Root <code class="reqn">D</code> values.
</p>
</li></ul>

<p>At this point, you will have to poke about in the source for more
information on these.
</p>
</li></ul>

<p><code>starting.point.bisse</code> produces a heuristic starting point to
start from, based on the character-independent birth-death model.  You
can probably do better than this; see the vignette, for example.
<code>bisse.starting.point</code> is the same code, but deprecated in favour
of <code>starting.point.bisse</code> - it will be removed in a future
version.
</p>


<h3>Unresolved clade information</h3>

<p>Since 0.10.10 this is no longer supported. See the package README for
more information.
</p>
<p>This must be a <code><a href="base.html#topic+data.frame">data.frame</a></code> with at least the four columns
</p>

<ul>
<li> <p><code>tip.label</code>, giving the name of the tip to which the data
applies
</p>
</li>
<li> <p><code>Nc</code>, giving the number of species in the clade
</p>
</li>
<li> <p><code>n0</code>, <code>n1</code>, giving the number of species known to be
in state 0 and 1, respectively.
</p>
</li></ul>

<p>These columns may be in any order, and additional columns will be
ignored.  (Note that column names are case sensitive).
</p>
<p>An alternative way of specifying unresolved clade information is to
use the function <code><a href="#topic+make.clade.tree">make.clade.tree</a></code> to construct a tree
where tips that represent clades contain information about which
species are contained within the clades.  With a <code>clade.tree</code>,
the <code>unresolved</code> object will be automatically constructed from
the state information in <code>states</code>.  (In this case, <code>states</code>
must contain state information for the species contained within the
unresolved clades.)
</p>


<h3>ODE solver control</h3>

<p>The differential equations that define the
BiSSE model are solved numerically using ODE solvers from the GSL
library or deSolve's LSODA.  The <code>control</code> argument to
<code>make.bisse</code> controls the behaviour of the integrator.  This is a
list that may contain elements:
</p>

<ul>
<li><p><code>tol</code>: Numerical tolerance used for the calculations.
The default value of <code>1e-8</code> should be a reasonable trade-off
between speed and accuracy.  Do not expect too much more than this
from the abilities of most machines!
</p>
</li>
<li><p><code>eps</code>: A value that when the sum of the D values drops
below, the integration results will be discarded and the
integration will be attempted again (the second-chance integration
will divide a branch in two and try again, recursively until the
desired accuracy is reached).  The default value of <code>0</code> will
only discard integration results when the parameters go negative.
However, for some problems more restrictive values (on the order
of <code>control$tol</code>) will give better stability.
</p>
</li>
<li><p><code>backend</code>: Select the solver.  The three options here are
</p>

<ul>
<li><p><code>gslode</code>: (the default).  Use the GSL solvers, by
default a Runge Kutta Kash Carp stepper.
</p>
</li>
<li><p><code>deSolve</code>: Use the LSODA solver from the
<code>deSolve</code> package.  This is quite a bit slower at the
moment.
</p>
</li></ul>

</li></ul>

<p><code>deSolve</code> is the only supported backend on Windows.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>References</h3>

<p>FitzJohn R.G., Maddison W.P., and Otto S.P. 2009. Estimating
trait-dependent speciation and extinction rates from incompletely
resolved phylogenies. Syst. Biol. 58:595-611.
</p>
<p>Maddison W.P., Midford P.E., and Otto S.P. 2007. Estimating
a binary character's effect on speciation and
extinction. Syst. Biol. 56:701-710.
</p>
<p>Nee S., May R.M., and Harvey P.H. 1994. The reconstructed
evolutionary process. Philos.  Trans. R. Soc. Lond. B
Biol. Sci. 344:305-311.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain">constrain</a></code> for making submodels, <code><a href="#topic+find.mle">find.mle</a></code>
for ML parameter estimation, <code><a href="#topic+mcmc">mcmc</a></code> for MCMC integration,
and <code><a href="#topic+make.bd">make.bd</a></code> for state-independent birth-death models.
</p>
<p>The help pages for <code><a href="#topic+find.mle">find.mle</a></code> has further examples of ML
searches on full and constrained BiSSE models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}
pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(4)
phy &lt;- tree.bisse(pars, max.t=30, x0=0)

## Here is the 52 species tree with the true character history coded.
## Red is state '1', which has twice the speciation rate of black (state
## '0').
h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy)

lik &lt;- make.bisse(phy, phy$tip.state)
lik(pars) # -159.71
</code></pre>

<hr>
<h2 id='make.bisse.split'>Binary State Speciation and Extinction Model: Split Models</h2><span id='topic+make.bisse.split'></span><span id='topic+make.bisse.uneven'></span>

<h3>Description</h3>

<p>Create a likelihood function for a BiSSE model where the
tree is partitioned into regions with different parameters.
Alternatively, <code>make.bisse.uneven</code> can be used where different
regions of the tree have different fractions of species known.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bisse.split(tree, states, nodes, split.t, unresolved=NULL,
                 sampling.f=NULL, nt.extra=10, strict=TRUE, control=list())
make.bisse.uneven(tree, states, nodes, split.t, unresolved=NULL,
                  sampling.f=NULL, nt.extra=10, strict=TRUE, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bisse.split_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0 or
1, or <code>NA</code> if the state is unknown.  This vector must have
names that correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips
corresponding to unresolved clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_nodes">nodes</code></td>
<td>
<p>Vector of nodes that will be split (see Details).</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_split.t">split.t</code></td>
<td>
<p>Vector of split times, same length as <code>nodes</code> (see
Details).</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_unresolved">unresolved</code></td>
<td>
<p>Unresolved clade information: see section below for
structure.</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 2 with the estimated proportion of
extant species in state 0 and 1 that are included in the phylogeny.
A value of <code>c(0.5, 0.75)</code> means that half of species in state 0
and three quarters of species in state 1 are included in the
phylogeny.  By default all species are assumed to be known.
Alternatively, with split models this can be a list of length
<code>(length(nodes) + 1)</code>, each element of which is a vector of
length 2.  The first element is the sampling fraction for the
&ldquo;background&rdquo; group, the second element corresponds to the
clade subtended by <code>nodes[1]</code>, and the <code>i</code>th element
corresponding to the clade subtended by <code>nodes[i+1]</code>.</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_nt.extra">nt.extra</code></td>
<td>
<p>The number of species modelled in unresolved clades
(this is in addition to the largest observed clade).</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are 0 and 1 only.  If <code>strict</code> is <code>TRUE</code>
(the default), then the additional check is made that <em>every</em>
state is present.  The likelihood models tend to be poorly behaved
where states are missing.</p>
</td></tr>
<tr><td><code id="make.bisse.split_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branching times can be controlled with the <code>split.t</code>
argument.  If this is <code>Inf</code>, split at the base of the branch (as in
MEDUSA).  If <code>0</code>, split at the top (closest to the present, as in
the new option for MEDUSA).  If <code>0 &lt; split.t &lt; Inf</code> then we split
at that time on the tree (zero is the present, with time growing
backwards).
</p>
<p>TODO: Describe <code>nodes</code> and <code>split.t</code> here.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(546)
phy &lt;- tree.bisse(pars, max.taxa=30, x0=0)

## Here is the phylogeny:
plot(phy, show.node.label=TRUE, label.offset=.1, font=1, cex=.75,
     no.margin=TRUE)

## Here is a plain BiSSE function for comparison:
lik.b &lt;- make.bisse(phy, phy$tip.state)
lik.b(pars) # -93.62479

## Split this phylogeny at three points: nd15, nd18 and nd26
nodes &lt;- c("nd15", "nd18", "nd26")

## This is the index in ape's node indexing:
nodes.i &lt;- match(nodes, phy$node.label) + length(phy$tip.label)

nodelabels(node=nodes.i, pch=19, cex=2, col="#FF000099")

## To make a split BiSSE function, pass the node locations and times in:
lik.s &lt;- make.bisse.split(phy, phy$tip.state, nodes.i)

## The parameters must be a list of the same length as the number of
## partitions.  Partition '1' is the root partition, and partition i is
## the partition rooted at the node[i-1]
pars4 &lt;- rep(pars, 4)
pars4

## Run the likelihod calculation:
lik.s(pars4) # -93.62479

## These are basically identical (to acceptable tolerance)
lik.s(pars4) - lik.b(pars)

## You can use the labelled nodes rather than indices:
lik.s2 &lt;- make.bisse.split(phy, phy$tip.state, nodes)
identical(lik.s(pars4), lik.s2(pars4))
</code></pre>

<hr>
<h2 id='make.bisse.td'>Binary State Speciation and Extinction Model: Time Dependant
Models</h2><span id='topic+make.bisse.t'></span><span id='topic+make.bisse.td'></span>

<h3>Description</h3>

<p>Create a likelihood function for a BiSSE model where
different chunks of time have different parameters.  This code is
experimental!</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bisse.td(tree, states, n.epoch, unresolved=NULL, sampling.f=NULL,
              nt.extra=10, strict=TRUE, control=list())

make.bisse.t(tree, states, functions, unresolved=NULL, sampling.f=NULL,
             strict=TRUE, control=list(), truncate=FALSE, spline.data=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bisse.td_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0 or
1, or <code>NA</code> if the state is unknown.  This vector must have
names that correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips
corresponding to unresolved clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_n.epoch">n.epoch</code></td>
<td>
<p>Number of epochs.  1 corresponds to plain BiSSE, so
this will generally be an integer at least 2.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_functions">functions</code></td>
<td>
<p>A named character vector of functions of time.  See
details.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_unresolved">unresolved</code></td>
<td>
<p>Unresolved clade information: see
<code><a href="#topic+make.bisse">make.bisse</a></code>. (Currently this is not supported.)</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 2 with the estimated proportion of
extant species in state 0 and 1 that are included in the phylogeny.
See <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_nt.extra">nt.extra</code></td>
<td>
<p>The number of species modelled in unresolved clades
(this is in addition to the largest observed clade).</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are 0 and 1 only.  If <code>strict</code> is <code>TRUE</code>
(the default), then the additional check is made that <em>every</em>
state is present.  The likelihood models tend to be poorly behaved
where states are missing.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_truncate">truncate</code></td>
<td>
<p>Logical, indicating if functions should be truncated
to zero when negative (rather than causing an error).  May be
scalar (applying to all functions) or a vector (of length 6).</p>
</td></tr>
<tr><td><code id="make.bisse.td_+3A_spline.data">spline.data</code></td>
<td>
<p>List of data for spline-based time functions.  See
details</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>This builds a BiSSE likelihood function where different regions of
time (epochs) have different parameter sets.  By default, all
parameters are free to vary between epochs, so some constraining will
probably be required to get reasonable answers.
</p>
<p>For <code>n</code> epochs, there are <code>n-1</code> time points; the first
<code>n-1</code> elements of the likelihood's parameter vector are these
points.  These are measured from the present at time zero, with time
increasing towards the base of the tree.  The rest of the parameter
vector are BiSSE parameters; the elements <code>n:(n+6)</code> are for the
first epoch (closest to the present), elements <code>(n+7):(n+13)</code> are
for the second epoch, and so on.
</p>
<p>For <code>make.bisse.t</code>, the <code>funtions</code> is a vector of names of
functions of time.
For example, to have speciation rates be linear functions of
time, while the extinction and character change rates be constant with
respect to time, one can do
</p>
<pre>functions=rep(c("linear.t", "constant.t"), c(2, 4))</pre>
<p>The functions here must have <code>t</code> as their first argument,
interpreted as time back from the present.  Other possible functions
are &quot;sigmoid.t&quot;, &quot;stepf.t&quot;, &quot;spline.t&quot;, &quot;exp.t&quot;, and &quot;spline.linear.t&quot;.
Unfortunately, documentation is still pending.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

set.seed(4)
pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
phy &lt;- tree.bisse(pars, max.t=30, x0=0)

## Suppose we want to see if diversification is different in the most
## recent 3 time units, compared with the rest of the tree (yes, this is
## a totally contrived example!):
plot(phy)
axisPhylo()
abline(v=max(branching.times(phy)) - 3, col="red", lty=3)

## For comparison, make a plain BiSSE likelihood function
lik.b &lt;- make.bisse(phy, phy$tip.state)

## Create the time-dependent likelihood function.  The final argument
## here is the number of 'epochs' that are allowed.  Two epochs is one
## switch point.
lik.t &lt;- make.bisse.td(phy, phy$tip.state, 2)

## The switch point is the first argument.  The remaining 12 parameters
## are the BiSSE parameters, with the first 6 being the most recent
## epoch.
argnames(lik.t)

pars.t &lt;- c(3, pars, pars)
names(pars.t) &lt;- argnames(lik.t)

## Calculations are identical to a reasonable tolerance:
lik.b(pars) - lik.t(pars.t)

## It will often be useful to constrain the time as a fixed quantity.
lik.t2 &lt;- constrain(lik.t, t.1 ~ 3)

## Parameter estimation under maximum likelihood.  This is marked "don't
## run" because the time-dependent fit takes a few minutes.
## Not run: 
## Fit the BiSSE ML model
fit.b &lt;- find.mle(lik.b, pars)

## And fit the BiSSE/td model
fit.t &lt;- find.mle(lik.t2, pars.t[argnames(lik.t2)],
                  control=list(maxit=20000))

## Compare these two fits with a likelihood ratio test (lik.t2 is nested
## within lik.b)
anova(fit.b, td=fit.t)

## End(Not run)

## The time varying model (bisse.t)  is more general, but substantially
## slower.  Here, I will show that the two functions are equivalent for
## step function models.  We'll constrain all the non-lambda parameters
## to be the same over a time-switch at t=5.  This leaves 8 parameters.
lik.td &lt;- make.bisse.td(phy, phy$tip.state, 2)
lik.td2 &lt;- constrain(lik.td, t.1 ~ 5,          
                     mu0.2 ~ mu0.1, mu1.2 ~ mu1.1,
                     q01.2 ~ q01.1, q10.2 ~ q10.1)

lik.t &lt;- make.bisse.t(phy, phy$tip.state,
                      rep(c("stepf.t", "constant.t"), c(2, 4)))
lik.t2 &lt;- constrain(lik.t, lambda0.tc ~ 5, lambda1.tc ~ 5)

## Note that the argument names for these functions are different from
## one another.  This reflects different ways that the functions will
## tend to be used, but is potentially confusing here.
argnames(lik.td2)
argnames(lik.t2)

## First, evaluate the functions with no time effect and check that they
## are the same as the base BiSSE model
p.td &lt;- c(pars, pars[1:2])
p.t &lt;- pars[c(1, 1, 2, 2, 3:6)]

## All agree:
lik.b(pars)   # -159.7128
lik.td2(p.td) # -159.7128
lik.t2(p.t)   # -159.7128

## In fact, the time-varying BiSSE will tend to be identical to plain
## BiSSE where the functions to not change:
lik.b(pars) - lik.t2(p.t)

## Slight numerical differences are typical for the time-chunk BiSSE,
## because it forces the integration to be carried out more carefully
## around the switch point.
lik.b(pars) - lik.td2(p.td)

## Next, evaluate the functions with a time effect (5 time units ago,
## speciation rates were twice the contemporary rate)
p.td2 &lt;- c(pars, pars[1:2]*2)
p.t2 &lt;- c(pars[1], pars[1]*2, pars[2], pars[2]*2, pars[3:6])

## Huge drop in the likelihood (from -159.7128 to -172.7874)
lik.b(pars)
lik.td2(p.td2)
lik.t2(p.t2)

## The small difference remains between the two approaches, but they are
## basically the same.
lik.td2(p.td2) - lik.t2(p.t2)

## There is a small time cost to both time-dependent methods, 
## heavily paid for the time-chunk case:
system.time(lik.b(pars))
system.time(lik.td2(p.td))  # 1.9x slower than plain BiSSE
system.time(lik.td2(p.td2)) # 1.9x slower than plain BiSSE
system.time(lik.t2(p.t))    # about the same speed
system.time(lik.t2(p.t2))   # about the same speed
</code></pre>

<hr>
<h2 id='make.bisseness'>Binary State Speciation and Extinction (Node Enhanced State Shift) Model</h2><span id='topic+make.bisseness'></span>

<h3>Description</h3>

<p>Prepare to run BiSSE-ness (Binary State Speciation and
Extinction (Node Enhanced State Shift)) on a phylogenetic tree and character distribution.  This
function creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bisseness(tree, states, unresolved=NULL, sampling.f=NULL,
               nt.extra=10, strict=TRUE, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bisseness_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bisseness_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0 or
1, or <code>NA</code> if the state is unknown.  This vector must have
names that correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips
corresponding to unresolved clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.bisseness_+3A_unresolved">unresolved</code></td>
<td>
<p>Unresolved clade information: see section below for
structure.</p>
</td></tr>
<tr><td><code id="make.bisseness_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 2 with the estimated proportion of
extant species in state 0 and 1 that are included in the phylogeny.
A value of <code>c(0.5, 0.75)</code> means that half of species in state 0
and three quarters of species in state 1 are included in the
phylogeny.  By default all species are assumed to be known.</p>
</td></tr>
<tr><td><code id="make.bisseness_+3A_nt.extra">nt.extra</code></td>
<td>
<p>The number of &quot;extra&quot; species to include in the
unresolved clade calculations.  This is in addition to the largest
included unresolved clade.</p>
</td></tr>
<tr><td><code id="make.bisseness_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.bisseness_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are 0 and 1 only.  If <code>strict</code> is <code>TRUE</code>
(the default), then the additional check is made that <em>every</em>
state is present at least once in the tree.  The likelihood models
tend to be poorly behaved where a state is not represented on the
tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.bisse</code> returns a function of class <code>bisse</code>.  This
function has argument list (and default values) [RICH:  Update to BiSSEness?]
</p>
<pre>
    f(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL,
      intermediates=FALSE)
  </pre>
<p>The arguments are interpreted as
</p>

<ul>
<li> <p><code>pars</code> A vector of 10 parameters, in the order
<code>lambda0</code>, <code>lambda1</code>, <code>mu0</code>, <code>mu1</code>,
<code>q01</code>, <code>q10</code>, <code>p0c</code>, <code>p0a</code>, <code>p1c</code>, <code>p1a</code>.
</p>
</li>
<li> <p><code>condition.surv</code> (logical): should the likelihood
calculation condition on survival of two lineages and the speciation
event subtending them?  This is done by default, following Nee et
al. 1994.  For BiSSE-ness, equation (A5) in Magnuson-Ford and Otto
describes how conditioning on survival alters the likelihood of
observing the data.

</p>
</li>
<li> <p><code>root</code>: Behaviour at the root (see Maddison et al. 2007,
FitzJohn et al. 2009).  The possible options are
</p>

<ul>
<li> <p><code>ROOT.FLAT</code>: A flat prior, weighting
<code class="reqn">D_0</code> and <code class="reqn">D_1</code> equally.
</p>
</li>
<li> <p><code>ROOT.EQUI</code>: Use the equilibrium distribution
of the model, as described in Maddison et al. (2007) using
equation (A6) in Magnuson-Ford and Otto.
</p>
</li>
<li> <p><code>ROOT.OBS</code>: Weight <code class="reqn">D_0</code> and
<code class="reqn">D_1</code> by their relative probability of observing the
data, following FitzJohn et al. 2009:
</p>
<p style="text-align: center;"><code class="reqn">D = D_0\frac{D_0}{D_0 + D_1} + D_1\frac{D_1}{D_0 + D_1}</code>
</p>

</li>
<li> <p><code>ROOT.GIVEN</code>: Root will be in state 0
with probability <code>root.p[1]</code>, and in state 1 with
probability <code>root.p[2]</code>.
</p>
</li>
<li> <p><code>ROOT.BOTH</code>: Don't do anything at the root,
and return both values.  (Note that this will not give you a
likelihood!).
</p>
</li></ul>

</li>
<li> <p><code>root.p</code>: Root weightings for use when
<code>root=ROOT.GIVEN</code>.  <code>sum(root.p)</code> should equal 1.
</p>
</li>
<li> <p><code>intermediates</code>: Add intermediates to the returned value as
attributes:
</p>

<ul>
<li> <p><code>cache</code>: Cached tree traversal information.
</p>
</li>
<li> <p><code>intermediates</code>: Mostly branch end information.
</p>
</li>
<li> <p><code>vals</code>: Root <code class="reqn">D</code> values.
</p>
</li></ul>

<p>At this point, you will have to poke about in the source for more
information on these.
</p>
</li></ul>



<h3>Unresolved clade information</h3>

<p>Since 0.10.10 this is no longer supported. See the package README for
more information.
</p>

<p>This must be a <code><a href="base.html#topic+data.frame">data.frame</a></code> with at least the four columns
</p>

<ul>
<li> <p><code>tip.label</code>, giving the name of the tip to which the data
applies
</p>
</li>
<li> <p><code>Nc</code>, giving the number of species in the clade
</p>
</li>
<li> <p><code>n0</code>, <code>n1</code>, giving the number of species known to be
in state 0 and 1, respectively.
</p>
</li></ul>

<p>These columns may be in any order, and additional columns will be
ignored.  (Note that column names are case sensitive).
</p>
<p>An alternative way of specifying unresolved clade information is to
use the function <code><a href="#topic+make.clade.tree">make.clade.tree</a></code> to construct a tree
where tips that represent clades contain information about which
species are contained within the clades.  With a <code>clade.tree</code>,
the <code>unresolved</code> object will be automatically constructed from
the state information in <code>states</code>.  (In this case, <code>states</code>
must contain state information for the species contained within the
unresolved clades.)
</p>


<h3>Author(s)</h3>

<p>Karen Magnuson-Ford</p>


<h3>References</h3>

<p>FitzJohn R.G., Maddison W.P., and Otto S.P. 2009. Estimating
trait-dependent speciation and extinction rates from incompletely
resolved phylogenies. Syst. Biol. 58:595-611.
</p>
<p>Maddison W.P., Midford P.E., and Otto S.P. 2007. Estimating
a binary character's effect on speciation and
extinction. Syst. Biol. 56:701-710.
</p>
<p>Magnuson-Ford, K., and Otto, S.P. 2012. Linking the investigations of
character evolution and species diversification.  American Naturalist,
in press.
</p>
<p>Nee S., May R.M., and Harvey P.H. 1994. The reconstructed
evolutionary process. Philos.  Trans. R. Soc. Lond. B
Biol. Sci. 344:305-311.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.bisse">make.bisse</a></code> for the model with no state change at nodes.
</p>
<p><code><a href="#topic+tree.bisseness">tree.bisseness</a></code> for simulating trees under the BiSSE-ness
model.
</p>
<p><code><a href="#topic+constrain">constrain</a></code> for making submodels, <code><a href="#topic+find.mle">find.mle</a></code>
for ML parameter estimation, <code><a href="#topic+mcmc">mcmc</a></code> for MCMC integration,
and <code><a href="#topic+make.bd">make.bd</a></code> for state-independent birth-death models.
</p>
<p>The help pages for <code><a href="#topic+find.mle">find.mle</a></code> has further examples of ML
searches on full and constrained BiSSE models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## First we simulate a 50 species tree, assuming cladogenetic shifts in
## the trait (i.e., the trait only changes at speciation).
## Red is state '1', black is state '0', and we let red lineages
## speciate at twice the rate of black lineages.
## The simulation starts in state 0.
set.seed(3)
pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0, 0, 0.1, 0, 0.1, 0)
phy &lt;- tree.bisseness(pars, max.taxa=50, x0=0)
phy$tip.state

h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy)

## This builds the likelihood of the data according to BiSSEness:
lik &lt;- make.bisseness(phy, phy$tip.state)
## e.g., the likelihood of the true parameters is:
lik(pars) # -174.7954

## ML search:  First we make hueristic guess at a starting point, based
## on the constant-rate birth-death model assuming anagenesis (uses
## \link{make.bd}).
startp &lt;- starting.point.bisse(phy)

## We then take the total amount of anagenetic change expected across
## the tree and assign half of this change to anagenesis and half to
## cladogenetic change at the nodes as a heuristic starting point:
t &lt;- branching.times(phy)
tryq &lt;- 1/2 * startp[["q01"]] * sum(t)/length(t)
p &lt;- c(startp[1:4], startp[5:6]/2, p0c=tryq, p0a=0.5, p1c=tryq, p1a=0.5)
</code></pre>

<hr>
<h2 id='make.bm'>Brownian Motion and Related Models of Character Evolution</h2><span id='topic+make.bm'></span><span id='topic+make.ou'></span><span id='topic+make.eb'></span><span id='topic+make.lambda'></span>

<h3>Description</h3>

<p>Create a likelihood function for models of simple Brownian
Motion (BM), Ornstein-Uhlenbeck (OU), or Early Burst (EB) character
evolution, or BM on a &ldquo;lambda&rdquo; rescaled tree.  This function
creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.bm(tree, states, states.sd=0, control=list())
make.ou(tree, states, states.sd=0, with.optimum=FALSE, control=list())
make.eb(tree, states, states.sd=0, control=list())
make.lambda(tree, states, states.sd=0, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.bm_+3A_tree">tree</code></td>
<td>
<p>A bifurcating phylogenetic tree, in <code>ape</code>
&ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.bm_+3A_states">states</code></td>
<td>
<p>A vector of continuous valued character states.  This
vector must be named with the tip labels of <code>tree</code>.</p>
</td></tr>
<tr><td><code id="make.bm_+3A_states.sd">states.sd</code></td>
<td>
<p>An optional vector of measurement errors, as standard
deviation around the mean.  If a single value is given it is used
for all tips, otherwise the vector must be named as for
<code>states</code>.</p>
</td></tr>
<tr><td><code id="make.bm_+3A_with.optimum">with.optimum</code></td>
<td>
<p>Should the optimum (often &quot;theta&quot;) be considered
a free parameter?  The default, <code>FALSE</code>, makes this behave like
geiger's <code>fitContinuous</code>.  Setting <code>TRUE</code> leaves the
optimim to be a free parameter to be estimated.  This setting can
(currently) only be set to <code>TRUE</code> with
<code>method="pruning"</code>.</p>
</td></tr>
<tr><td><code id="make.bm_+3A_control">control</code></td>
<td>
<p>A list of control parameters.  See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control</code> argument is a named list of options.
</p>
<p>The main option is <code>method</code>.  Specifying
<code>control=list(method="vcv")</code> uses a variance-covariance matrix
based approach to compute the likelihood.  This is similar to the
approach used by geiger, and is the default.
</p>
<p>Two alternative approaches are available.
<code>control=list(method="pruning")</code> uses the transition density
function for brownian motion along each branch, similar to how most
methods in diversitree are computed.  This second approach is much
faster for very large trees.  <code>control=list(method="contrasts")</code>
uses Freckleton (2012)'s contrasts based approach, which is also much
faster on large trees.
</p>
<p>When <code>method="pruning"</code> is specified, <code>backend="R"</code> or
<code>backend="C"</code> may also be provided, which switch between a slow
(and stable) R calculator and a fast (but less extensively tested) C
calculator.  <code>backend="R"</code> is currently the default.
</p>
<p>The VCV-based functions are heavily based on <code>fitContinuous</code> in
the <code>geiger</code> package.
</p>
<p>For non-ultrametric trees with OU models, computed likelihoods may
differ because of the different root treatments.  This is particularly
the case for models where the optimum is estimated.
</p>
<p>For the EB model, the parameter intepretation follows geiger; the 'a'
parameter is equivalent to -log(g) in Bloomberg et al. 2003; when
negative it indicates a decelerating rate of trait evolution over
time.  When zero, it reduces to Brownian motion.
</p>



<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>See Also</h3>

<p>See
<a href="https://www.zoology.ubc.ca/prog/diversitree/examples/ou-nonultrametric/">https://www.zoology.ubc.ca/prog/diversitree/examples/ou-nonultrametric/</a>
for a discussion about calculations on non-ultrametric trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Random data (following APE)
data(bird.orders)
set.seed(1)
x &lt;- structure(rnorm(length(bird.orders$tip.label)),
               names=bird.orders$tip.label)

## Not run: 
## With the VCV approach
fit1 &lt;- find.mle(make.bm(bird.orders, x), .1)

## With the pruning calculations
lik.pruning &lt;- make.bm(bird.orders, x, control=list(method="pruning"))
fit2 &lt;- find.mle(lik.pruning, .1)

## All the same (need to drop the function from this though)
all.equal(fit1[-7], fit2[-7])

## If this is the same as the estimates from Geiger, to within the
## tolerances expected for the calculation and optimisation:
fit3 &lt;- fitContinuous(bird.orders, x)
all.equal(fit3$Trait1$lnl, fit1$lnLik)
all.equal(fit3$Trait1$beta, fit1$par, check.attributes=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='make.clade.tree'>Make a &quot;Clade Tree&quot;</h2><span id='topic+make.clade.tree'></span><span id='topic+clades.from.polytomies'></span><span id='topic+clades.from.classification'></span>

<h3>Description</h3>

<p>This function makes a &ldquo;clade tree&rdquo;, where tips
represent clades.  It is designed to make working with unresolved
clade information in <code><a href="#topic+make.bisse">make.bisse</a></code> more straightforward.
<code>clade.tree</code> objects have their own plotting methods.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.clade.tree(tree, clades)
clades.from.polytomies(tree)
clades.from.classification(tree, class, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.clade.tree_+3A_tree">tree</code></td>
<td>
<p>An ultrametric phylogenetic tree, in <code>ape</code>
&ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.clade.tree_+3A_clades">clades</code></td>
<td>
<p>A list, where the name of each element represents a tip
in <code>tree</code> and each element is a character vector containing the
names of species contained within that clade.</p>
</td></tr>
<tr><td><code id="make.clade.tree_+3A_class">class</code></td>
<td>
<p>A vector along <code>tree$tip.label</code>, indicating the
class to which each tip belongs.</p>
</td></tr>
<tr><td><code id="make.clade.tree_+3A_check">check</code></td>
<td>
<p>Logical, indicating whether a (potentially slow) check
will be done to ensure that all resulting clades are reciprocally
monophyletic within the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea here is that <code>make.bisse</code> takes a tree and a named
character state vector.  If the phylogenetic tree contains information
about the membership of clades, then the unresolved clade information
can be constructed automatically.  The names chosen should therefore
reflect the names used in the state information.
</p>


<h3>Note</h3>

<p>Currently, <code>clade.tree</code> objects work poorly with some <code>ape</code>
functions.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='make.classe'>Cladogenetic State change Speciation and Extinction Model</h2><span id='topic+make.classe'></span><span id='topic+starting.point.classe'></span>

<h3>Description</h3>

<p>Prepare to run ClaSSE (Cladogenetic State change
Speciation and Extinction) on a phylogenetic tree and character
distribution.  This function creates a likelihood function that can be
used in <a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  make.classe(tree, states, k, sampling.f=NULL, strict=TRUE,
              control=list())
  starting.point.classe(tree, k, eps=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.classe_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.classe_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be an
integer between 1 and <code>k</code>.  This vector must have names that
correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).</p>
</td></tr>
<tr><td><code id="make.classe_+3A_k">k</code></td>
<td>
<p>The number of states.  (The maximum now is 31, but that can
easily be increased if necessary.)</p>
</td></tr>
<tr><td><code id="make.classe_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length <code>k</code> where <code>sampling.f[i]</code>
is the proportion of species in state <code>i</code> that are present in
the phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 1, three quarters of species in state 2, and all
species in state 3 are included in the phylogeny.  By default all
species are assumed to be known</p>
</td></tr>
<tr><td><code id="make.classe_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are integers on <code>1:k</code>.  If <code>strict</code> is
<code>TRUE</code> (the default), then the additional check is made that
<em>every</em> state is present.  The likelihood models tend to be
poorly behaved where states are missing, but there are cases
(missing intermediate states for meristic characters) where allowing
such models may be useful.</p>
</td></tr>
<tr><td><code id="make.classe_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.classe_+3A_eps">eps</code></td>
<td>
<p>Ratio of extinction to speciation rates to be used when
choosing a starting set of parameters.  The procedure used is based
on Magallon &amp; Sanderson (2001).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ClaSSE model with <code>k = 2</code> is equivalent to but a different
parameterization than the <a href="#topic+make.bisseness">BiSSE-ness</a> model.
The <a href="#topic+make.geosse">GeoSSE</a> model can be constructed from ClaSSE
with <code>k = 3</code>; see the example below.
</p>
<p><code>make.classe</code> returns a function of class <code>classe</code>.  The
arguments and default values for this function are:
</p>
<pre>
    f(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL,
      intermediates=FALSE)
  </pre>
<p>The arguments of this function are explained in <a href="#topic+make.bisse">make.bisse</a>.
The speciation rate parameters are lambda_ijk, ordered with k changing
fastest and insisting on j &lt; k.
</p>
<p>With more than 9 states, lambda_ijk and q_ij can be ambiguous (e.g. is
q113 1-&gt;13 or 11-&gt;3?).  To avoid this, the numbers are zero padded (so
that the above would be q0113 or q1103 for 1-&gt;13 and 11-&gt;3
respectively).  It might be easier to rename the arguments in practice
though.  More human-friendly handling of large speciation rate arrays
is in the works.
</p>
<p><code>starting.point.classe</code> produces a first-guess set of parameters,
ignoring character states.
</p>
<p>Unresolved clade methods are not available for ClaSSE.
</p>
<p>Tree simulation methods are not yet available for ClaSSE.
</p>


<h3>Author(s)</h3>

<p>Emma E. Goldberg</p>


<h3>References</h3>

<p>FitzJohn R.G., Maddison W.P., and Otto S.P. 2009. Estimating
trait-dependent speciation and extinction rates from incompletely
resolved phylogenies. Syst. Biol. 58:595-611.
</p>
<p>Goldberg E.E. and Igic B. Tempo and mode in plant breeding system
evolution. In review.
</p>
<p>Maddison W.P., Midford P.E., and Otto S.P. 2007. Estimating a binary
character's effect on speciation and extinction. Syst. Biol.
56:701-710.
</p>
<p>Magallon S. and Sanderson M.J. 2001. Absolute diversification rates in
angiospem clades. Evol. 55:1762-1780.
</p>
<p>Magnuson-Ford, K., and Otto, S.P. 2012. Linking the investigations of
character evolution and species diversification.  American Naturalist,
in press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain">constrain</a></code> for making submodels, <code><a href="#topic+find.mle">find.mle</a></code>
for ML parameter estimation, and <code><a href="#topic+mcmc">mcmc</a></code> for MCMC
integration.  The help page for <code><a href="#topic+find.mle">find.mle</a></code> has further
examples of ML searches on full and constrained BiSSE models.  Things
work similarly for ClaSSE, just with different speciation parameters.
</p>
<p><code><a href="#topic+make.bisse">make.bisse</a></code>, <code><a href="#topic+make.bisseness">make.bisseness</a></code>,
<code><a href="#topic+make.geosse">make.geosse</a></code>, <code><a href="#topic+make.musse">make.musse</a></code> for similar models
and further relevant examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## GeoSSE equivalence
## Same tree simulated in ?make.geosse
pars &lt;- c(1.5, 0.5, 1.0, 0.7, 0.7, 2.5, 0.5)
names(pars) &lt;- diversitree:::default.argnames.geosse()
set.seed(5)
phy &lt;- tree.geosse(pars, max.t=4, x0=0)

lik.g &lt;- make.geosse(phy, phy$tip.state)
pars.g &lt;- c(1.5, 0.5, 1.0, 0.7, 0.7, 1.4, 1.3)
names(pars.g) &lt;- argnames(lik.g)

lik.c &lt;- make.classe(phy, phy$tip.state+1, 3)
pars.c &lt;- 0 * starting.point.classe(phy, 3)
pars.c['lambda222'] &lt;- pars.c['lambda112'] &lt;- pars.g['sA']
pars.c['lambda333'] &lt;- pars.c['lambda113'] &lt;- pars.g['sB']
pars.c['lambda123'] &lt;-  pars.g['sAB']
pars.c['mu2'] &lt;- pars.c['q13'] &lt;- pars.g['xA']
pars.c['mu3'] &lt;- pars.c['q12'] &lt;- pars.g['xB']
pars.c['q21'] &lt;- pars.g['dA']
pars.c['q31'] &lt;- pars.g['dB']

lik.g(pars.g)   # -175.7685
lik.c(pars.c)   # -175.7685
</code></pre>

<hr>
<h2 id='make.geosse'>Geographic State Speciation and Extinction Model</h2><span id='topic+make.geosse'></span><span id='topic+starting.point.geosse'></span>

<h3>Description</h3>

<p>Prepare to run GeoSSE (Geographic State Speciation and
Extinction) on a phylogenetic tree and character distribution.  This
function creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  make.geosse(tree, states, sampling.f=NULL, strict=TRUE,
    control=list())
  starting.point.geosse(tree, eps=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.geosse_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.geosse_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0
(in both regions/widespread; AB), 1 or 2 (endemic to one region; A
or B), or <code>NA</code> if the state is unknown.  This vector must have
names that correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).</p>
</td></tr>
<tr><td><code id="make.geosse_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 3 with the estimated proportion of
extant species in states 0, 1 and 2 that are included in the
phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 0, three quarters of species in state 1, and all
the species in state 2 are included in the phylogeny.  By default
all species are assumed to be known.</p>
</td></tr>
<tr><td><code id="make.geosse_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are 0, 1 and 2 only.  If <code>strict</code> is
<code>TRUE</code> (the default), then the additional check is made that
<em>every</em> state is present.  The likelihood models tend to be
poorly behaved where states are missing.</p>
</td></tr>
<tr><td><code id="make.geosse_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.geosse_+3A_eps">eps</code></td>
<td>
<p>Ratio of extinction to speciation rates to be used when
choosing a starting set of parameters.  The procedure used is based
on Magallon &amp; Sanderson (2001).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.geosse</code> returns a function of class <code>geosse</code>.  The
arguments and default values for this function are:
</p>
<pre>
    f(pars, condition.surv=TRUE, root=ROOT.OBS, root.p=NULL,
      intermediates=FALSE)
  </pre>
<p>The arguments of this function are explained in <a href="#topic+make.bisse">make.bisse</a>.
The parameter vector <code>pars</code> is ordered <code>sA</code>, <code>sB</code>,
<code>sAB</code>, <code>xA</code>, <code>xB</code>, <code>dA</code>, <code>dB</code>.
</p>
<p>Unresolved clade methods are not available for GeoSSE.  With three
states, it would rapidly become computationally infeasible.
</p>


<h3>Author(s)</h3>

<p>Emma E. Goldberg</p>


<h3>References</h3>

<p>FitzJohn R.G., Maddison W.P., and Otto S.P. 2009. Estimating
trait-dependent speciation and extinction rates from incompletely
resolved phylogenies. Syst. Biol. 58:595-611.
</p>
<p>Goldberg E.E., Lancaster L.T., and Ree R.H. 2011. Phylogenetic
inference of reciprocal effects between geographic range evolution and
diversification. Syst. Biol. 60:451-465.
</p>
<p>Maddison W.P., Midford P.E., and Otto S.P. 2007. Estimating a binary
character's effect on speciation and extinction. Syst. Biol.
56:701-710.
</p>
<p>Magallon S. and Sanderson M.J. 2001. Absolute diversification rates
in angiospem clades. Evol. 55:1762-1780.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain">constrain</a></code> for making submodels, <code><a href="#topic+find.mle">find.mle</a></code>
for ML parameter estimation, <code><a href="#topic+mcmc">mcmc</a></code> for MCMC integration,
<code><a href="#topic+make.bisse">make.bisse</a></code> for further relevant examples.
</p>
<p>The help page for <code><a href="#topic+find.mle">find.mle</a></code> has further examples of ML
searches on full and constrained BiSSE models.  Things work similarly
for GeoSSE, just with different parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## Parameter values
pars &lt;- c(1.5, 0.5, 1.0, 0.7, 0.7, 2.5, 0.5)
names(pars) &lt;- diversitree:::default.argnames.geosse()

## Simulate a tree
set.seed(5)
phy &lt;- tree.geosse(pars, max.t=4, x0=0)

## See the data
statecols &lt;- c("AB"="purple", "A"="blue", "B"="red")
plot(phy, tip.color=statecols[phy$tip.state+1], cex=0.5)

## The likelihood function
lik &lt;- make.geosse(phy, phy$tip.state)

## With "true" parameter values
lik(pars) # -168.4791

## A guess at a starting point.
p &lt;- starting.point.geosse(phy)

## Start an ML search from this point (takes a couple minutes to run).
## Not run: 
fit &lt;- find.mle(lik, p, method="subplex")
logLik(fit) # -165.9965

## Compare with sim values.
rbind(real=pars, estimated=round(coef(fit), 2))

## A model with constraints on the dispersal rates.
lik.d &lt;- constrain(lik, dA ~ dB)
fit.d &lt;- find.mle(lik.d, p[-7])
logLik(fit.d) # -166.7076

## A model with constraints on the speciation rates.
lik.s &lt;- constrain(lik, sA ~ sB, sAB ~ 0)
fit.s &lt;- find.mle(lik.s, p[-c(2,3)])
logLik(fit.s) # -169.0123

## End(Not run)

## "Skeletal tree" sampling is supported.  For example, if your tree
## includes all AB species, half of A species, and a third of B species,
## create the likelihood function like this:
lik.f &lt;- make.geosse(phy, phy$tip.state, sampling.f=c(1, 0.5, 1/3))

## If you have external evidence that the base of your tree must have
## been in state 1, say (endemic to region A), you can fix the root 
## when computing the likelihood, like this:
lik(pars, root=ROOT.GIVEN, root.p=c(0,1,0))
</code></pre>

<hr>
<h2 id='make.geosse.split'>Geographic State Speciation and Extinction Model: Split Models</h2><span id='topic+make.geosse.split'></span><span id='topic+make.geosse.uneven'></span>

<h3>Description</h3>

<p>Create a likelihood function for a GeoSSE model where the
tree is partitioned into regions with different parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.geosse.split(tree, states, nodes, split.t,
                  sampling.f=NULL, strict=TRUE, control=list())
make.geosse.uneven(tree, states, nodes, split.t,
                   sampling.f=NULL, strict=TRUE, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.geosse.split_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.geosse.split_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be an
integer between 0 and 2: see <code><a href="#topic+make.geosse">make.geosse</a></code>.  This vector
must have names that correspond to the tip labels in the
phylogenetic tree (<code>tree$tip.label</code>).  Unresolved clades are
not supported.</p>
</td></tr>
<tr><td><code id="make.geosse.split_+3A_nodes">nodes</code></td>
<td>
<p>Vector of nodes that will be split (see Details).</p>
</td></tr>
<tr><td><code id="make.geosse.split_+3A_split.t">split.t</code></td>
<td>
<p>Vector of split times, same length as <code>nodes</code> (see
Details).</p>
</td></tr>
<tr><td><code id="make.geosse.split_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 3 where <code>sampling.f[i]</code>
is the proportion of species in state <code>i</code> that are present in
the phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 0, three quarters of species in state 1, and all
species in state 2 are included in the phylogeny.  By default all
species are assumed to be known.</p>
</td></tr>
<tr><td><code id="make.geosse.split_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are integers on <code>0:2</code>.  If <code>strict</code> is
<code>TRUE</code> (the default), then the additional check is made that
<em>every</em> state is present.  The likelihood models tend to be
poorly behaved where states are missing, but there are cases
(missing intermediate states for meristic characters) where allowing
such models may be useful.</p>
</td></tr>
<tr><td><code id="make.geosse.split_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branching times can be controlled with the <code>split.t</code>
argument.  If this is <code>Inf</code>, split at the base of the branch (as in
MEDUSA).  If <code>0</code>, split at the top (closest to the present, as in
the new option for MEDUSA).  If <code>0 &lt; split.t &lt; Inf</code> then we split
at that time on the tree (zero is the present, with time growing
backwards).
</p>
<p>The <code>nodes</code> at the top of the split location are specified as a
vector of node names.  For example, a value of <code>c("nd10",
"nd12")</code> means that the splits are along the branches leading from each
of these nodes towards the root.
</p>


<h3>Author(s)</h3>

<p>Emma E. Goldberg</p>

<hr>
<h2 id='make.geosse.t'>Geographic State Speciation and Extinction Model: Time Dependent
Models</h2><span id='topic+make.geosse.t'></span>

<h3>Description</h3>

<p>Prepare to run time dependent GeoSSE (Geographic State
Speciation and Extinction) on a phylogenetic tree and character
distribution. This function creates a likelihood function that can be
used in <a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.geosse.t(tree, states, functions, sampling.f=NULL, strict=TRUE,
              control=list(), truncate=FALSE, spline.data=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.geosse.t_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0
(in both regions/widespread; AB), 1 or 2 (endemic to one region; A or
B), or <code>NA</code> if the state is unknown.  This vector must have names
that correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_functions">functions</code></td>
<td>
<p>A named character vector of functions of time.  See
details.</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length 3 with the estimated proportion of
extant species in states 0, 1 and 2 that are included in the
phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 0, three quarters of species in state 1, and all the
species in state 2 are included in the phylogeny.  By default all
species are assumed to be known.</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are 0, 1 and 2 only. If <code>strict</code> is <code>TRUE</code>
(the default), then the additional check is made that <em>every</em>
state is present.  The likelihood models tend to be poorly behaved
where states are missing.</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_truncate">truncate</code></td>
<td>
<p>Logical, indicating if functions should be truncated
to zero when negative (rather than causing an error).  May be
scalar (applying to all functions) or a vector (of length 7).</p>
</td></tr>
<tr><td><code id="make.geosse.t_+3A_spline.data">spline.data</code></td>
<td>
<p>List of data for spline-based time functions.  See
details in <code><a href="#topic+make.bisse.t">make.bisse.t</a></code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Please see <code><a href="#topic+make.bisse.t">make.bisse.t</a></code> for further details.
</p>
<p><code>make.geosse.t</code> returns a function of class <code>geosse.t</code>. 
</p>
<p>The <code>funtions</code> is a vector of named functions of time.  For
example, to have speciation rates be linear functions of time, while
the extinction and dispersal rates be constant with respect to time,
one can do </p>
<pre>functions=rep(c("linear.t", "constant.t"),
  c(3, 4))</pre><p>.  The functions here must have <code>t</code> as their first
argument, interpreted as time back from the present.  See
<code><a href="#topic+make.bisse.t">make.bisse.t</a></code> for more information, and for some
potentially useful time functions.
</p>
<p>The function has argument list (and default values):
</p>
<pre>
    f(pars, condition.surv=FALSE, root=ROOT.OBS, root.p=NULL,
      intermediates=FALSE)
  </pre>
<p>The parameter vector pars is ordered <code>sA</code>, <code>sB</code>, <code>sAB</code>,
<code>xA</code>, <code>xB</code>, <code>dA</code>, <code>dB</code>. Unresolved clade methods
are not available for GeoSSE. With three states, it would rapidly
become computationally infeasible.  The arguments of this function are
also explained in <code><a href="#topic+make.bisse">make.bisse</a></code>.
</p>
<p><code>starting.point.geosse</code> produces a first-guess set of parameters,
ignoring character states.
</p>


<h3>Warning</h3>

<p>This computer intensive code is experimental!</p>


<h3>Author(s)</h3>

<p>Jonathan Rolland</p>


<h3>References</h3>

<p>FitzJohn R.G. 2012. Diversitree: comparative phylogenetic analyses of 
diversification in R. Methods in Ecology and Evolution. 3, 1084-1092.
</p>
<p>FitzJohn R.G., Maddison W.P., and Otto S.P. 2009. Estimating
trait-dependent speciation and extinction rates from incompletely
resolved phylogenies. Syst. Biol. 58:595-611.
</p>
<p>Goldberg E.E., Lancaster L.T., and Ree R.H. 2011. Phylogenetic
inference of reciprocal effects between geographic range evolution and
diversification. Syst. Biol. 60:451-465.
</p>
<p>Maddison W.P., Midford P.E., and Otto S.P. 2007. Estimating
a binary character's effect on speciation and
extinction. Syst. Biol. 56:701-710.
</p>
<p>Nee S., May R.M., and Harvey P.H. 1994. The reconstructed
evolutionary process. Philos.  Trans. R. Soc. Lond. B
Biol. Sci. 344:305-311.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain">constrain</a></code> for making submodels and reduce number
of parameters, <code><a href="#topic+find.mle">find.mle</a></code> for ML parameter estimation,
<code><a href="#topic+mcmc">mcmc</a></code> for MCMC integration, <code><a href="#topic+make.bisse">make.bisse</a></code> and
<code><a href="#topic+make.bisse.t">make.bisse.t</a></code> for further relevant examples.
</p>
<p>The help page for <code><a href="#topic+find.mle">find.mle</a></code> has further examples of ML
searches on full and constrained BiSSE models.  Things work similarly
for GeoSSE and GeoSSE.t, just with different parameters.
</p>
<p>See <code><a href="#topic+make.geosse">make.geosse</a></code> for explanation of the base model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## Parameter values
pars &lt;- c(1.5, 0.5, 1.0, 0.7, 0.7, 2.5, 0.5)
names(pars) &lt;- diversitree:::default.argnames.geosse()

## Simulate a tree
set.seed(5)
phy &lt;- tree.geosse(pars, max.t=4, x0=0)

## See the data
statecols &lt;- c("AB"="purple", "A"="blue", "B"="red")
plot(phy, tip.color=statecols[phy$tip.state+1], cex=0.5)

## Create your list of functions. Its length corresponds to the number
## of parameters (speciation, extinction and dispersal) you want to
## estimate.
## For an unconstrained model, at least 7 parameters are estimated for
## sA, sB, sAB, xA, xB, dA, dB.
## In the case you want to define a model with linear functions of
## speciation and extinction, and constant dispersal:
functions &lt;- rep(c("linear.t", "constant.t"), c(5, 2))

## Create the likelihood function
lik &lt;- make.geosse.t(phy, phy$tip.state, functions)

## This function will estimate a likelihood from 12 parameters.
argnames(lik)

## Imagine that you want to get an estimate of the likelihood from a
## known set of parameters.
pars &lt;- c(0.01,0.001,0.01,0.001,0.01,0.001,0.02,0.002,0.02,0.002,0.1,0.1)
names(pars)&lt;-argnames(lik)
lik(pars) # -640.1644

## A guess at a starting point from character independent birth-death
## model (constant across time) .
p &lt;- starting.point.geosse(phy)

#it only gives 7 parameters for time-constant model.
names(p)

## it can be modified for time-dependent with a guess on the slopes of
## speciation and extinction rates.
p.t&lt;-c(p[1],0.001,p[2],0.001,p[3],0.001,p[4],0.001,p[5],0.001,p[6],p[7])
names(p.t)&lt;-argnames(lik)

## Start an ML search from this point (takes from one minute to a very
## long time depending on your computer).
## Not run: 
fit &lt;- find.mle(lik, p.t, method="subplex")
fit$logLik
coef(fit)

## End(Not run)

## A model with constraints on the dispersal rates.
lik.d &lt;- constrain(lik, dA ~ dB)

##Now dA and dB are the same parameter dB.
argnames(lik.d)

##The parameter dA must be removed from maximum likelihood initial parameters
## Not run: 
fit.d &lt;- find.mle(lik.d, p.t[-which(names(p.t)=="dA")])
fit$logLik
coef(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.mkn'>Mk2 and Mk-n Models of character evolution</h2><span id='topic+make.mkn'></span><span id='topic+make.mk2'></span><span id='topic+make.mkn.meristic'></span>

<h3>Description</h3>

<p>Prepare to run a Mk2/Mk-n model on a phylogenetic tree and
binary/discrete trait data.  This fits the Pagel 1994 model,
duplicating the <code>ace</code> function in ape.  Differences with that
function include (1) alternative root treatments are possible, (2)
easier to tweak parameter combinations through
<code><a href="#topic+constrain">constrain</a></code>, and (3) run both MCMC and MLE fits to
parameters.  Rather than exponentiate the Q matrix, this
implementation solves the ODEs that this matrix defines.  This may or
may not be robust on trees leading to low probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.mk2(tree, states, strict=TRUE, control=list())
make.mkn(tree, states, k, strict=TRUE, control=list())
make.mkn.meristic(tree, states, k, control=list())
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="make.mkn_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.mkn_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be 0 or
1 for <code>make.mk2</code> or 1 to <code>k</code> for <code>make.mkn</code>.</p>
</td></tr>
<tr><td><code id="make.mkn_+3A_k">k</code></td>
<td>
<p>Number of states to model.</p>
</td></tr>
<tr><td><code id="make.mkn_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are integers on <code>0:1</code> (<code>mk2</code>) or
<code>1:k</code> (<code>mkn</code>).  If <code>strict</code> is <code>TRUE</code> (the
default), then the additional check is made that <em>every</em> state
is present.  The likelihood models tend to be poorly behaved where
states are missing, but there are cases (missing intermediate states
for meristic characters) where allowing such models may be useful.</p>
</td></tr>
<tr><td><code id="make.mkn_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make.mk2</code> and <code>make.mkn</code> return functions of class <code>mkn</code>.
These functions have argument list (and default values)
</p>
<pre>
    f(pars, pars, prior=NULL, root=ROOT.OBS, root.p=NULL, fail.value=NULL)
  </pre>
<p>The arguments are interpreted as
</p>

<ul>
<li> <p><code>pars</code> For <code>make.mk2</code>, a vector of two parameters,
in the order <code>q01</code>, <code>q10</code>.  For <code>make.mkn</code>, a
vector of <code>k(k-1)</code> parameters, in the order
<code>q12,q13,...q1k, q21,q23,...,q2k,...qk(k-1)</code>, corresponding
to the off-diagonal elements of the <code>Q</code> matrix in row order.
The order of parameters can be seen by running
<code><a href="#topic+argnames">argnames</a>(f)</code>.
</p>
</li>
<li> <p><code>prior</code>: a valid prior.  See <code><a href="#topic+make.prior">make.prior</a></code> for
more information.
</p>
</li>
<li> <p><code>root</code>: Behaviour at the root (see Maddison et al. 2007,
FitzJohn et al. 2009).  The possible options are
</p>

<ul>
<li> <p><code>ROOT.FLAT</code>: A flat prior, weighting all variables
equally.
</p>
</li>
<li> <p><code>ROOT.EQUI</code>: Use the equilibrium distribution
of the model (not yet implemented).
</p>
</li>
<li> <p><code>ROOT.OBS</code>: Weight <code class="reqn">D_0</code> and
<code class="reqn">D_1</code> by their relative probability of observing the
data, following FitzJohn et al. 2009:
</p>
<p style="text-align: center;"><code class="reqn">D = \sum_i D_i \frac{D_i}{\sum_j D_j}</code>
</p>

</li>
<li> <p><code>ROOT.GIVEN</code>: Root will be in state i
with probability <code>root.p[i]</code>.
</p>
</li>
<li> <p><code>ROOT.BOTH</code>: Don't do anything at the root,
and return both values.  (Note that this will not give you a
likelihood for use with ML or MCMC functions!).
</p>
</li></ul>

</li>
<li> <p><code>root.p</code>: Vector of probabilities/weights to use when
<code>ROOT.GIVEN</code> is specified.  Must be of length <code>k</code> (2 for
<code>make.mk2</code>).
</p>

</li>
<li> <p><code>intermediates</code>: Add intermediates to the returned value as
attributes.  Currently undocumented.
</p>
</li></ul>

<p>With more than 9 states, qij can be ambiguous (e.g. is q113 1-&gt;13 or
11-&gt;3?).  To avoid this, the numbers are zero padded (so that the
above would be q0113 or q1103 for 1-&gt;13 and 11-&gt;3 respectively).  It
might be easier to rename the arguments in practice though.
</p>
<p>The <code>control</code> argument controls how the calculations will be
carried out.  It is a list, which may contain elements in
<code><a href="#topic+make.bisse">make.bisse</a></code>.  In addition, the list element <code>method</code>
may be present, which selects between three different ways of
computing the likelihood:
</p>

<ul>
<li> <p><code>method="exp"</code>: Uses a matrix exponentiation approach,
where all transition probabilities are computed (i.e., for a rate
matrix <code class="reqn">Q</code> and time interval <code class="reqn">t</code>, it computes <code class="reqn">P =
      exp(Qt)</code>).
</p>
</li>
<li> <p><code>method="mk2"</code>: As for <code>exp</code>, but for 2 states only.
Faster, direct, calculations are available here, rather than
numerically computing the exponentiation.
</p>
</li>
<li> <p><code>method="ode"</code>: Uses an ODE-based approach to compute
only the <code class="reqn">k</code> variables over time, rather than the <code class="reqn">k^2</code>
transition probabilities in the <code>exp</code> approach.  This will be
much more efficient when <code>k</code> is large.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain">constrain</a></code> for making submodels, <code><a href="#topic+find.mle">find.mle</a></code>
for ML parameter estimation, <code><a href="#topic+mcmc">mcmc</a></code> for MCMC integration,
and <code><a href="#topic+make.bisse">make.bisse</a></code> for state-dependent birth-death models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a tree and character distribution.  This is on a birth-death
## tree, with high rates of character evolution and an asymmetry in the
## character transition rates.
pars &lt;- c(.1, .1, .03, .03, .1, .2)
set.seed(3)
phy &lt;- trees(pars, "bisse", max.taxa=25, max.t=Inf, x0=0)[[1]]

## Here is the 25 species tree with the true character history coded.
## Red is state '1', which has twice the character transition rate of
## black (state '0').
h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy)

## Maximum likelihood parameter estimation:
p &lt;- c(.1, .1) # initial parameter guess

## Not run: 
lik &lt;- make.mk2(phy, phy$tip.state)
fit.mk2 &lt;- find.mle(lik, p)
coef(fit.mk2)   # q10 &gt;&gt; q01
logLik(fit.mk2) # -10.9057

## This can also be done using the more general Mk-n.
## This uses an approximation for the likelihood calculations.  make.mkn
## assumes that states are numbered 1, 2, ..., k, so 1 needs to be added
## to the states returned by trees.
lik.mkn &lt;- make.mkn(phy, phy$tip.state + 1, 2)
fit.mkn &lt;- find.mle(lik.mkn, p)
fit.mkn[1:2]

## These are the same (except for the naming of arguments)
all.equal(fit.mkn[-7], fit.mk2[-7], check.attr=FALSE, tolerance=1e-7)

## Equivalence to ape's \link{ace} function:
model &lt;- matrix(c(0, 2, 1, 0), 2)
fit.ape &lt;- ace(phy$tip.state, phy, "discrete", model=model, ip=p)

## To do the comparison, we need to rerun the diversitree version with
## the same root conditions as ape.
fit.mk2 &lt;- find.mle(lik, p, root=ROOT.GIVEN, root.p=c(1,1))

## These are the same to a reasonable degree of accuracy, too (the
## matrix exponentiation is slightly less accurate than the ODE
## solving approach.  The make.mk2 version is exact)
all.equal(fit.ape[c("rates", "loglik")], fit.mk2[1:2],
          check.attributes=FALSE, tolerance=1e-4)

## The ODE calculation method may be useful when there are a large
## number of possible states (say, over 20).
lik.ode &lt;- make.mkn(phy, phy$tip.state + 1, 2,
                    control=list(method="ode"))
fit.ode &lt;- find.mle(lik.ode, p)
fit.ode[1:2]

all.equal(fit.ode[-7], fit.mkn[-7], tolerance=1e-7)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.musse'>MuSSE: Multi-State Speciation and Extinction</h2><span id='topic+make.musse'></span><span id='topic+starting.point.musse'></span>

<h3>Description</h3>

<p>Prepare to run MuSSE (Multi-State Speciation and
Extinction) on a phylogenetic tree and character distribution.  This
function creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.
</p>
<p>MuSSE is agnostic as to whether multiple states or multiple traits are
modelled (following Pagel 1994).  Instead, a transition rate matrix
amongst possible trait/state combinations is constructed and the
analysis is conducted on this.
</p>
<p>The helper function <code><a href="#topic+make.musse.multitrait">make.musse.multitrait</a></code> wraps the
basic MuSSE model for the case of a combination of several binary
traits; its argument handling are a little different; please see the
help page for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.musse(tree, states, k, sampling.f=NULL, strict=TRUE,
           control=list())
starting.point.musse(tree, k, q.div=5, yule=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.musse_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.musse_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be an
integer between 1 and <code>k</code>.  This vector must have names that
correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips corresponding to unresolved
clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.musse_+3A_k">k</code></td>
<td>
<p>The number of states.</p>
</td></tr>
<tr><td><code id="make.musse_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length <code>k</code> where <code>sampling.f[i]</code>
is the proportion of species in state <code>i</code> that are present in
the phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 1, three quarters of species in state 2, and all
species in state 3 are included in the phylogeny.  By default all
species are assumed to be known</p>
</td></tr>
<tr><td><code id="make.musse_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are integers on <code>1:k</code>.  If <code>strict</code> is
<code>TRUE</code> (the default), then the additional check is made that
<em>every</em> state is present.  The likelihood models tend to be
poorly behaved where states are missing, but there are cases
(missing intermediate states for meristic characters) where allowing
such models may be useful.</p>
</td></tr>
<tr><td><code id="make.musse_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.musse_+3A_q.div">q.div</code></td>
<td>
<p>Ratio of diversification rate to character change rate.
Eventually this will be changed to allow for Mk2 to be used for
estimating q parameters.</p>
</td></tr>
<tr><td><code id="make.musse_+3A_yule">yule</code></td>
<td>
<p>Logical: should starting parameters be Yule estimates
rather than birth-death estimates?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With more than 9 states, qij can be ambiguous (e.g. is q113 1-&gt;13 or
11-&gt;3?).  To avoid this, the numbers are zero padded (so that the
above would be q0113 or q1103 for 1-&gt;13 and 11-&gt;3 respectively).  It
might be easier to rename the arguments in practice though.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.bisse">make.bisse</a></code> for the basic binary model, and
<code><a href="#topic+make.musse.multitrait">make.musse.multitrait</a></code> for the case where the data are
really combinations of binary traits.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## 1: BiSSE equivalence
pars &lt;- c(.1, .2, .03, .04, 0.05, 0.1)
set.seed(2)
phy &lt;- tree.musse(pars, 20, x0=1)

## Show that the likelihood functions give the same answers.  Ignore the
## warning when creating the MuSSE function.
lik.b &lt;- make.bisse(phy, phy$tip.state-1)
lik.m &lt;- make.musse(phy, phy$tip.state, 2)
all.equal(lik.b(pars), lik.m(pars), tolerance=1e-7)

## Notice that default argument names are different between BiSSE and
## MuSSE, but that the order is the same.
argnames(lik.b) # BiSSE: 0/1
argnames(lik.m) # MuSSE: 1/2

## 2: A 3-state example where movement is only allowed between
## neighbouring states (1 &lt;-&gt; 2 &lt;-&gt; 3), and where speciation and
## extinction rates increase moving from 1 -&gt; 2 -&gt; 3:

## You can get the expected argument order for any number of states
## this way (sorry - clunky).  The help file also lists the order.
diversitree:::default.argnames.musse(3)

## Here are the parameters:
pars &lt;- c(.1,  .15,  .2,  # lambda 1, 2, 3
          .03, .045, .06, # mu 1, 2, 3
          .05, 0,         # q12, q13
          .05, .05,       # q21, q23
          0,   .05)       # q31, q32

set.seed(2)
phy &lt;- tree.musse(pars, 30, x0=1)

## Extract history from simulated tree and plot
## (colours are 1: black, 2: red, 3: blue)
col &lt;- c("blue", "orange", "red")
h &lt;- history.from.sim.discrete(phy, 1:3)
plot(h, phy, cex=.7, col=col)

## The states are numbered 1:3, rather than 0:1 in bisse.
states &lt;- phy$tip.state
table(states)

## 2: Likelihood
## Making a likelihood function is basically identical to bisse.  The
## third argument needs to be the number of states.  In a future
## version this will probably be max(states), but there are some
## pitfalls about this that I am still worried about.
lik &lt;- make.musse(phy, states, 3)

## Here are the arguments.  Even with three states, this is getting
## ridiculous.
argnames(lik)

## Start with a fully constrained model, but still enforcing stepwise
## changes (disallowing 1 &lt;-&gt; 3 shifts)
lik.base &lt;- constrain(lik, lambda2 ~ lambda1, lambda3 ~ lambda1,
                      mu2 ~ mu1, mu3 ~ mu1,
                      q13 ~ 0, q21 ~ q12, q23 ~ q12, q31 ~ 0, q32 ~ q12)

## Not run: 
p &lt;- starting.point.musse(phy, 3)
fit.base &lt;- find.mle(lik.base, p[argnames(lik.base)])

## Now, allow the speciation rates to vary:
lik.lambda &lt;- constrain(lik, mu2 ~ mu1, mu3 ~ mu1,
                        q13 ~ 0, q21 ~ q12, q23 ~ q12, q31 ~ 0, q32 ~ q12)
fit.lambda &lt;- find.mle(lik.lambda, p[argnames(lik.lambda)])

## Very little improvement in fit (this *is* a small tree)
anova(fit.base, lambda=fit.lambda)

## Run an MCMC with this set.  Priors will be necessary (using the
## usual exponential with mean of 2r)
prior &lt;- make.prior.exponential(1 / (2 * (p[1] - p[4])))
samples &lt;- mcmc(lik.lambda, coef(fit.lambda), nstep=1000, w=1,
                prior=prior, print.every=50)

## Posterior probability profile plots for the three speciation rates.
profiles.plot(samples[2:4], col)
abline(v=c(.1, .15, .2), col=col)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.musse.multitrait'>MuSSE: Multi-State Speciation and Extinction (Multiple Binary Traits
Version)</h2><span id='topic+make.musse.multitrait'></span><span id='topic+make.mkn.multitrait'></span><span id='topic+musse.multitrait.translate'></span><span id='topic+mkn.multitrait.translate'></span><span id='topic+starting.point.musse.multitrait'></span>

<h3>Description</h3>

<p>Prepare to run MuSSE or Mkn (Multi-State Speciation and
Extinction) on a phylogenetic tree and character distribution.  This
function creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.
</p>
<p>This is a helper function that wraps the basic MuSSE/Mkn models for
the case of a combination of several binary traits; its
parametrisation and argument handling are a little different to the
other models in diversitree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.musse.multitrait(tree, states, sampling.f=NULL,
                      depth=NULL, allow.multistep=FALSE,
                      strict=TRUE, control=list())
make.mkn.multitrait(tree, states,
                    depth=NULL, allow.multistep=FALSE,
                    strict=TRUE, control=list())

musse.multitrait.translate(n.trait, depth=NULL, names=NULL,
                           allow.multistep=FALSE)
mkn.multitrait.translate(n.trait, depth=NULL, names=NULL,
                         allow.multistep=FALSE)

starting.point.musse.multitrait(tree, lik, q.div=5, yule=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.musse.multitrait_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_states">states</code></td>
<td>
<p>A <code>data.frame</code> of character states, each column of
which represents a different binary state (with values 0 or 1), and
each row of which represents a taxon.  The row names of
<code>states</code> must be the names that correspond to the tip labels in
the phylogenetic tree (<code>tree$tip.label</code>).  The column names
must be unique and a single character long.  The character &quot;0&quot;
(zero) is reserved and may not be used. <code>NA</code> values are allowed
in one or more columns when one or more traits is unknown for a
taxon.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_depth">depth</code></td>
<td>
<p>A scalar or vector of length 3 indicating the depth of
interactions to include in the model.  See Details.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_allow.multistep">allow.multistep</code></td>
<td>
<p>Should transition rates be included that imply
simultaneous changes in more than one trait?  By default this is not
allowed, but if set to <code>TRUE</code> these rates are included at the
end of the parameter vector.  Warning: treatment of these will
change in future versions!</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Scalar with the estimated proportion of extant
species that are included in the phylogeny.  A value of <code>0.75</code>
means that three quarters of extant species are included in the
phylogeny.  By default all species are assumed to be known.  In the
future, this will expand to allow state-specific sampling rates.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_strict">strict</code></td>
<td>
<p>Each column in <code>states</code> is always checked to make
sure that the values are 0 or 1.  If <code>strict</code> is <code>TRUE</code>
(the default), then the additional check is made that <em>every</em>
state is present.  The likelihood models tend to be poorly behaved
where states are missing, but there are cases (missing intermediate
states for meristic characters) where allowing such models may be
useful.  Note that this model may misbehave even if this check is
met, due to combinations of traits being absent.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_lik">lik</code></td>
<td>
<p>A likelihood function created by
<code>make.musse.multitrait</code>.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_q.div">q.div</code></td>
<td>
<p>Ratio of diversification rate to character change rate.
Eventually this will be changed to allow for Mk2 to be used for
estimating q parameters.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_yule">yule</code></td>
<td>
<p>Logical: should starting parameters be Yule estimates
rather than birth-death estimates?</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_n.trait">n.trait</code></td>
<td>
<p>Number of binary traits.</p>
</td></tr>
<tr><td><code id="make.musse.multitrait_+3A_names">names</code></td>
<td>
<p>Vector of names for the traits when using
musse.multitrait.translate (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that you have two binary traits that may affect speciation and
extinction.  In previous versions of diversitree, you had to code the
possible combinations as states 1, 2, 3, 4, which makes the
interpretation of the speciation rates (<code>lambda1</code>,
<code>lambda2</code>, etc) unintuitive.
</p>
<p>Let <code>states</code> is a data.frame with columns &quot;A&quot; and &quot;B&quot;,
representing the two binary traits.  We can write the speciation rate
as

</p>
<p style="text-align: center;"><code class="reqn">\lambda_0 + \lambda_A X_A + \lambda_B X_B + \lambda_{AB}X_AX_B</code>
</p>


<p>where <code class="reqn">X_A</code> and <code class="reqn">X_B</code> are indicator variables that take the
value of trait A and B respectively (with values 0 or 1).  In this
form, <code class="reqn">\lambda_0</code> is the intercept,
<code class="reqn">\lambda_A</code> and <code class="reqn">\lambda_B</code> are &quot;main
effects&quot; of traits A and B, and <code class="reqn">\lambda_{AB}</code> is the
&quot;interaction&quot; between these.  We can do a similar trick for the
extinction rates.
</p>
<p>For character transition rates, we first consider changes only in a
single trait.  For our two trait case we have four &quot;types&quot; of
character change allowed (A 0-&gt;1, A 1-&gt;0, B 0-&gt;1, and B 1-&gt;0), but the
rates of change for trait A might depend on the current state of trait
B (and vice versa).  So we have, for the A0-&gt;1 trait change
<code class="reqn">q_{A01,0} + q_{A01,B} \times X_B</code>.  Note that one fewer levels of
interaction are possible for these character changes than for the
speciation/extinction parameters.
</p>
<p>It may sometimes be desirable to have the multi-trait changes in the
model.  At present, if <code>allow.multistep</code> is <code>TRUE</code>, all the
multiple change transitions are included at the end of the parameter
vector.  For the two trait case these are labelled <code>q00.11</code>,
<code>q10.01</code>, <code>q01.10</code>, and <code>q11.00</code>, where <code>qij.kl</code>
represents a change from (A=i, B=j) to (C=k, D=l).  The argument name,
and treatment, of these may change in future.
</p>
<p>This approach generalises out to more than two traits.  For <code>N</code>
traits, interactions are possible up to the <code>N</code>th order for
lambda and mu, and up to the <code>N-1</code>th order for q.  The
<code>depth</code> argument controls how many of these are returned.  If
this is a scalar, then the same level is used for <code>lambda</code>,
<code>mu</code> and <code>q</code>.  If it is a vector of length 3, then different
depths are used for these three types of parameters.  By default, all
possible interactions are returned and the model has the same number
of degrees of freedom as the models returned by <code>make.musse</code>
(except for a reduction in the possible q parameters when
<code>allow.multistep</code> is <code>FALSE</code>).  Parameters can then be
further refined with <code>constrain</code>.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.bisse">make.bisse</a></code> for the basic binary model, and
<code><a href="#topic+make.musse">make.musse</a></code> for the basic multistate model.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The translation between these two bases is fairly straightforward; if
## we have a vector of parameters in our new basis 'p' we can convert it
## into the original MuSSE basis ('q') through this matrix:
tr &lt;- musse.multitrait.translate(2)
tr

## Notice that the rows that correspond to transitions in multiple
## traits are all zero by default; this means that these q values will
## be zero regardless of the parameter vector used.
tr["q00.11",]

## And here is the section of the transition matrix corresponding to the
## lambda values; every rate gets a contribution from the intercept term
## (lambda0), lambda10 and lambda11 get a contribution from lambdaA, etc.
tr[1:4,1:4]

## There is currently no nice simulation support for this, so bear with
## an ugly script to generate the tree and traits.
pars &lt;- c(.10, .15, .20, .25, # lambda 00, 10, 01, 11
          .03, .03, .03, .03, # mu 00, 10, 01, 11
          .05, .05, .0,       # q00.10, q00.01, q00.11
          .05, .0,  .05,      # q10.00, q10.01, q10.11
          .05, .0,  .05,      # q01.00, q01.10, q01.11
          .0,  .05, .05)      # q11.00, q11.10, q11.01
set.seed(2)
phy &lt;- tree.musse(pars, 60, x0=1)

states &lt;- expand.grid(A=0:1, B=0:1)[phy$tip.state,]
rownames(states) &lt;- phy$tip.label

## Here, states has row names corresponding to the different taxa, and
## the states of two traits "A" and "B" are recorded in the columns.
head(states)

## Note that transition from the original MuSSE basis to this basis is
## only possible in general when depth=n.trait and allow.multistep=TRUE
## (as only this generates a square matrix that is invertible).
## However, when it is possible to express the set of parameters in the
## new basis (as it is above), this can be done through a pseudoinverse
## (here, a left inverse).
pars2 &lt;- drop(solve(t(tr) %*% tr) %*% t(tr) %*% pars)

## Going from our new basis to the original MuSSE parameters is always
## straightforward.  This is done automatically in the likelihood
## function.
all.equal(drop(tr %*% pars2), pars, check.attributes=FALSE)

## This shows that the two traits act additively on speciation rate
## (lambdaAB is zero), that there is no effect of any trait on
## extinction (the only nonzero mu parameter is mu0) and transition
## rates for one trait are unaffected by other traits (the only nonzero
## q parameters are the qXij.0 parameters; qXij.Y parameters are all
## zero).

## Here is our new MuSSE function parametrised as a multi-trait
## function:
lik &lt;- make.musse.multitrait(phy, states)

## Here are the argument names for the likelihood function.
argnames(lik)

## Basic MuSSE function for comparison
lik.m &lt;- make.musse(phy, phy$tip.state, 4)
argnames(lik.m)

## Rather than fit this complicated model first, let's start with a
## simple model with no state dependent diversification.  This model
## allows the forwards and backwards transition rates to vary, but the
## speciation and extinction rates do not depend on the character
## state:
lik0 &lt;- make.musse.multitrait(phy, states, depth=0)
argnames(lik0)

## This can be used in analyses as usual.  However, this can take a
## while to run, so is not run by default.
## Not run: 
p &lt;- starting.point.musse.multitrait(phy, lik0)
fit0 &lt;- find.mle(lik0, p)

## Now, allow the speciation rates to vary additively with both
## character states (extinction and character changes are left as in the
## previous model)
lik1 &lt;- make.musse.multitrait(phy, states, depth=c(1, 0, 0))

## Start from the previous ML point:
p &lt;- starting.point.musse.multitrait(phy, lik1)
p[names(coef(fit0))] &lt;- coef(fit0)

fit1 &lt;- find.mle(lik1, p)

## The likelihood improves, but the difference is not statistically
## significant (p = 0.35).
anova(fit1, fit0)

## We can fit an interaction for the speciation rates, too:
lik2 &lt;- make.musse.multitrait(phy, states, depth=c(2, 0, 0))
p &lt;- starting.point.musse.multitrait(phy, lik2)
p[names(coef(fit1))] &lt;- coef(fit1)
fit2 &lt;- find.mle(lik2, p)

## There is next to no support for the interaction term (which is good,
## as the original model did not have any interaction!)
anova(fit2, fit1)

## Constraining also works with these models.  For example, constraining
## the lambdaA parameter to zero:
lik1b &lt;- constrain(lik1, lambdaA ~ 0)
argnames(lik1b)
p &lt;- starting.point.musse.multitrait(phy, lik1b)
p[names(coef(fit0))] &lt;- coef(fit0)
fit1b &lt;- find.mle(lik1b, p)
anova(fit1b, fit0)

## Or constraining both main effects to take the same value:
lik1c &lt;- constrain(lik1, lambdaB ~ lambdaA)
argnames(lik1c)
p &lt;- starting.point.musse.multitrait(phy, lik1c)
p[names(coef(fit0))] &lt;- coef(fit0)
fit1c &lt;- find.mle(lik1c, p)
anova(fit1c, fit0)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.musse.split'>Multiple State Speciation and Extinction Model: Split Models</h2><span id='topic+make.musse.split'></span>

<h3>Description</h3>

<p>Create a likelihood function for a MuSSE model where the
tree is partitioned into regions with different parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.musse.split(tree, states, k, nodes, split.t,
                 sampling.f=NULL, strict=TRUE, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.musse.split_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.musse.split_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be an
integer between 1 and <code>k</code>.  This vector must have names that
correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips corresponding to unresolved
clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.musse.split_+3A_k">k</code></td>
<td>
<p>The number of states.</p>
</td></tr>  
<tr><td><code id="make.musse.split_+3A_nodes">nodes</code></td>
<td>
<p>Vector of nodes that will be split (see Details).</p>
</td></tr>
<tr><td><code id="make.musse.split_+3A_split.t">split.t</code></td>
<td>
<p>Vector of split times, same length as <code>nodes</code> (see
Details).</p>
</td></tr>
<tr><td><code id="make.musse.split_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length <code>k</code> where <code>sampling.f[i]</code>
is the proportion of species in state <code>i</code> that are present in
the phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 1, three quarters of species in state 2, and all
species in state 3 are included in the phylogeny.  By default all
species are assumed to be known</p>
</td></tr>
<tr><td><code id="make.musse.split_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are integers on <code>1:k</code>.  If <code>strict</code> is
<code>TRUE</code> (the default), then the additional check is made that
<em>every</em> state is present.  The likelihood models tend to be
poorly behaved where states are missing, but there are cases
(missing intermediate states for meristic characters) where allowing
such models may be useful.</p>
</td></tr>
<tr><td><code id="make.musse.split_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branching times can be controlled with the <code>split.t</code>
argument.  If this is <code>Inf</code>, split at the base of the branch (as in
MEDUSA).  If <code>0</code>, split at the top (closest to the present, as in
the new option for MEDUSA).  If <code>0 &lt; split.t &lt; Inf</code> then we split
at that time on the tree (zero is the present, with time growing
backwards).
</p>



<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example picks up from the tree used in the ?make.musse example.

## First, simulate the tree:
set.seed(2)
pars &lt;- c(.1,  .15,  .2,  # lambda 1, 2, 3
          .03, .045, .06, # mu 1, 2, 3
          .05, 0,         # q12, q13
          .05, .05,       # q21, q23
          0,   .05)       # q31, q32
phy &lt;- tree.musse(pars, 30, x0=1)

## Here is the phylogeny, with true character history superposed:
h &lt;- history.from.sim.discrete(phy, 1:3)
plot(h, phy, show.node.label=TRUE, font=1, cex=.75, no.margin=TRUE)

## Here is a plain MuSSE function for later comparison:
lik.m &lt;- make.musse(phy, phy$tip.state, 3)
lik.m(pars) # -110.8364

## Split this phylogeny at three points: nd16 and nd25, splitting it
## into three chunks
nodes &lt;- c("nd16", "nd25")
nodelabels(node=match(nodes, phy$node.label) + length(phy$tip.label),
           pch=19, cex=2, col="#FF000099")

## To make a split BiSSE function, pass the node locations and times
## in.  Here, we'll use 'Inf' as the split time to mimick MEDUSA's
## behaviour of placing the split at the base of the branch subtended by
## a node.
lik.s &lt;- make.musse.split(phy, phy$tip.state, 3, nodes, split.t=Inf)

## The parameters must be a list of the same length as the number of
## partitions.  Partition '1' is the root partition, and partition i is
## the partition rooted at the node[i-1]:
argnames(lik.s)

## Because we have two nodes, there are three sets of parameters.
## Replicate the original list to get a starting point for the analysis:
pars.s &lt;- rep(pars, 3)
names(pars.s) &lt;- argnames(lik.s)

lik.s(pars.s) # -110.8364

## This is basically identical (to acceptable tolerance) to the plain
## MuSSE version:
lik.s(pars.s) - lik.m(pars)

## The resulting likelihood function can be used in ML analyses with
## find.mle.  However, because of the large number of parameters, this
## may take some time (especially with as few species as there are in
## this tree - getting convergence in a reasonable number of iterations
## is difficult).
## Not run: 
fit.s &lt;- find.mle(lik.s, pars.s, control=list(maxit=20000))

## End(Not run)

## Bayesian analysis also works, using the mcmc function.  Given the
## large number of parameters, priors will be essential, as there will
## be no signal for several parameters.  Here, I am using an exponential
## distribution with a mean of twice the state-independent
## diversification rate.
## Not run: 
prior &lt;- make.prior.exponential(1/(-2*diff(starting.point.bd(phy))))
samples &lt;- mcmc(lik.s, pars.s, 100, prior=prior, w=1, print.every=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.musse.td'>Multiple State Speciation and Extinction Model: Time Dependent
Models</h2><span id='topic+make.musse.t'></span><span id='topic+make.musse.td'></span>

<h3>Description</h3>

<p>Create a likelihood function for a MuSSE model where
different chunks of time have different parameters.  This code is
experimental!</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.musse.td(tree, states, k, n.epoch, sampling.f=NULL,
              strict=TRUE, control=list())

make.musse.t(tree, states, k, functions, sampling.f=NULL,
             strict=TRUE, control=list(), truncate=FALSE, spline.data=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.musse.td_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be an
integer between 1 and <code>k</code>.  This vector must have names that
correspond to the tip labels in the phylogenetic tree
(<code>tree$tip.label</code>).  For tips corresponding to unresolved
clades, the state should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_k">k</code></td>
<td>
<p>The number of states.</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_n.epoch">n.epoch</code></td>
<td>
<p>Number of epochs.  1 corresponds to plain MuSSE, so
this will generally be an integer at least 2.</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_functions">functions</code></td>
<td>
<p>A named list of functions of time.  See details.</p>
</td></tr>  
<tr><td><code id="make.musse.td_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Vector of length <code>k</code> where <code>sampling.f[i]</code>
is the proportion of species in state <code>i</code> that are present in
the phylogeny.  A value of <code>c(0.5, 0.75, 1)</code> means that half of
species in state 1, three quarters of species in state 2, and all
species in state 3 are included in the phylogeny.  By default all
species are assumed to be known</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_strict">strict</code></td>
<td>
<p>The <code>states</code> vector is always checked to make sure
that the values are integers on <code>1:k</code>.  If <code>strict</code> is
<code>TRUE</code> (the default), then the additional check is made that
<em>every</em> state is present.  The likelihood models tend to be
poorly behaved where states are missing, but there are cases
(missing intermediate states for meristic characters) where allowing
such models may be useful.</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_control">control</code></td>
<td>
<p>List of control parameters for the ODE solver.  See
details in <code><a href="#topic+make.bisse">make.bisse</a></code>.</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_truncate">truncate</code></td>
<td>
<p>Logical, indicating if functions should be truncated
to zero when negative (rather than causing an error).  May be
scalar (applying to all functions) or a vector (of same length as
the functions vector).</p>
</td></tr>
<tr><td><code id="make.musse.td_+3A_spline.data">spline.data</code></td>
<td>
<p>List of data for spline-based time functions.  See
details</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Please see <code><a href="#topic+make.bisse.t">make.bisse.t</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Here we will start with the tree and three-state character set from
## the make.musse example.  This is a poorly contrived example.
pars &lt;- c(.1,  .15,  .2,  # lambda 1, 2, 3
          .03, .045, .06, # mu 1, 2, 3
          .05, 0,         # q12, q13
          .05, .05,       # q21, q23
          0,   .05)       # q31, q32
set.seed(2)
phy &lt;- tree.musse(pars, 30, x0=1)

## Suppose we want to see if diversification is different in the most
## recent 3 time units, compared with the rest of the tree (yes, this is
## a totally contrived example!):
plot(phy)
axisPhylo()
abline(v=max(branching.times(phy)) - 3, col="red", lty=3)

## For comparison, make a plain MuSSE likelihood function
lik.m &lt;- make.musse(phy, phy$tip.state, 3)

## Create the time-dependent likelihood function.  The final argument
## here is the number of 'epochs' that are allowed.  Two epochs is one
## switch point.
lik.t &lt;- make.musse.td(phy, phy$tip.state, 3, 2)

## The switch point is the first argument.  The remaining 12 parameters
## are the MuSSE parameters, with the first 6 being the most recent
## epoch.
argnames(lik.t)

pars.t &lt;- c(3, pars, pars)
names(pars.t) &lt;- argnames(lik.t)

## Calculations are identical to a reasonable tolerance:
lik.m(pars) - lik.t(pars.t)

## It will often be useful to constrain the time as a fixed quantity.
lik.t2 &lt;- constrain(lik.t, t.1 ~ 3)

## Parameter estimation under maximum likelihood.  This is marked "don't
## run" because the time-dependent fit takes a few minutes.
## Not run: 
## Fit the MuSSE ML model
fit.m &lt;- find.mle(lik.m, pars)

## And fit the MuSSE/td model
fit.t &lt;- find.mle(lik.t2, pars.t[argnames(lik.t2)],
                  control=list(maxit=20000))

## Compare these two fits with a likelihood ratio test (lik.t2 is nested
## within lik.m)
anova(fit.m, td=fit.t)

## End(Not run)
</code></pre>

<hr>
<h2 id='make.pgls'>Phylogenetic Generalised Least Squares</h2><span id='topic+make.pgls'></span>

<h3>Description</h3>

<p>Generate the likelihood function that underlies PGLS
(Phylogenetic Generalised Least Squares).  This is a bit of a misnomer
here, as you may not be interested in least squares (e.g., if using
this with <code><a href="#topic+mcmc">mcmc</a></code> for Bayesian inference).</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.pgls(tree, formula, data, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.pgls_+3A_tree">tree</code></td>
<td>
<p>A bifurcating phylogenetic tree, in <code>ape</code>
&ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.pgls_+3A_formula">formula</code></td>
<td>
<p>A model formula; see <code><a href="stats.html#topic+lm">lm</a></code> for details on
formulae; the interface is the same here.</p>
</td></tr>
<tr><td><code id="make.pgls_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model.  If
not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from
which this function is called.  That may perform badly with
reconciling with species names, however.</p>
</td></tr>
<tr><td><code id="make.pgls_+3A_control">control</code></td>
<td>
<p>A list of control parameters.  Currently the only
option is the key &ldquo;method&rdquo; which can be <code>"vcv"</code> for the
traditional variance-covariance approach (slow for large trees) or
<code>"contrasts"</code> for the contrasts-based approach outlined in
Freckleton (2012).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>References</h3>

<p>Freckleton R.P. 2012. Fast likelihood calculations for comparative
analyses. Methods in Ecology and Evolution 3: 940-947.
</p>

<hr>
<h2 id='make.prior'>Simple Prior Functions</h2><span id='topic+make.prior'></span><span id='topic+make.prior.exponential'></span><span id='topic+make.prior.uniform'></span>

<h3>Description</h3>

<p>Functions for generating prior functions for use with
<code><a href="#topic+mcmc">mcmc</a></code>, etc.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.prior.exponential(r)
make.prior.uniform(lower, upper, log=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.prior_+3A_r">r</code></td>
<td>
<p>Scalar or vector of rate parameters</p>
</td></tr>
<tr><td><code id="make.prior_+3A_lower">lower</code></td>
<td>
<p>Lower bound of the parameter</p>
</td></tr>
<tr><td><code id="make.prior_+3A_upper">upper</code></td>
<td>
<p>Upper bound of the parameter</p>
</td></tr>
<tr><td><code id="make.prior_+3A_log">log</code></td>
<td>
<p>Logical: should the prior be on a log basis?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential prior probability distribution has probability
density </p>
<p style="text-align: center;"><code class="reqn">\sum_i r_i e^{-r_i x_i}</code>
</p>

<p>where the <code class="reqn">i</code> denotes the <code class="reqn">i</code>th parameter.  If <code>r</code> is a
scalar, then the same rate is used for all parameters.
</p>
<p>These functions each return a function that may be used as the
<code>prior</code> argument to <code>mcmc()</code>.  </p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='make.quasse'>Quantitative State Speciation and Extinction Model</h2><span id='topic+make.quasse'></span><span id='topic+starting.point.quasse'></span>

<h3>Description</h3>

<p>Prepare to run QuaSSE (Quantitative State Speciation and
Extinction) on a phylogenetic tree and character distribution.  This
function creates a likelihood function that can be used in
<a href="#topic+find.mle">maximum likelihood</a> or <a href="#topic+mcmc">Bayesian</a>
inference.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.quasse(tree, states, states.sd, lambda, mu, control,
            sampling.f=NULL)
starting.point.quasse(tree, states, states.sd=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.quasse_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.quasse_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be a
numeric real values.  Missing values (<code>NA</code>) are not yet handled.
This vector must have names that correspond to the tip labels in the
phylogenetic tree  (<code>tree$tip.label</code>).</p>
</td></tr>
<tr><td><code id="make.quasse_+3A_states.sd">states.sd</code></td>
<td>
<p>A scalar or vector corresponding to the standard
error around the mean in states (the initial probability
distribution is assumed to be normal).</p>
</td></tr>
<tr><td><code id="make.quasse_+3A_lambda">lambda</code></td>
<td>
<p>A function to use as the speciation function.  The first
argument of this must be <code>x</code> (see Details).</p>
</td></tr>
<tr><td><code id="make.quasse_+3A_mu">mu</code></td>
<td>
<p>A function to use as the extinction function.  The first
argument of this must be <code>x</code> (see Details.)</p>
</td></tr>
<tr><td><code id="make.quasse_+3A_control">control</code></td>
<td>
<p>A list of parameters for tuning the performance of the
integrator.  A guess at reasonble values will be made here.  See
Details for possible entries.</p>
</td></tr>
<tr><td><code id="make.quasse_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Scalar with the estimated proportion of extant
species that are included in the phylogeny.  A value of <code>0.75</code>
means that three quarters of extant species are included in the
phylogeny.  By default all species are assumed to be known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control</code> list may contain the following elements:
</p>

<ul>
<li> <p><code>method</code>: one of <code>fftC</code> or <code>fftR</code> to switch
between <code>C</code> (fast) and <span class="rlang"><b>R</b></span> (slow) backends for the integration.
Both use non-adaptive fft-based convolutions.  Eventually, an
adaptive methods-of-lines approach will be available.
</p>
</li>
<li> <p><code>dt.max</code>: Maximum time step to use for the integration.
By default, this will be set to 1/1000 of the tree depth.  Smaller
values will slow down calculations, but improve accuracy.
</p>
</li>
<li> <p><code>nx</code>: The number of bins into which the character space
is divided (default=1024).  Larger values will be slower and more
accurate.  For the <code>fftC</code> integration method, this should be an
integer power of 2 (512, 2048, etc).
</p>
</li>
<li> <p><code>r</code>: Scaling factor that multiplies <code>nx</code> for a &quot;high
resolution&quot; section at the tips of the tree (default=4, giving a
high resolution character space divided into 4096 bins).  This helps
improve accuracy while possibly tight initial probability
distributions flatten out as time progresses towards the root.
Larger values will be slower and more accurate.  For the <code>fftC</code>
integration method, this should be a power of 2 (2, 4, 8, so that
<code>nx*r</code> is a power of 2).
</p>
</li>
<li> <p><code>tc</code>: where in the tree to switch to the low-resolution
integration (zero corresponds to the present, larger numbers moving
towards the root).  By default, this happens at 10% of the tree
depth.  Smaller values will be faster, but less accurate.
</p>
</li>
<li> <p><code>xmid</code>: Mid point to center the character space.  By
default this is at the mid point of the extremes of the character
states.
</p>
</li>
<li> <p><code>tips.combined</code>: Get a modest speed-up by simultaneously
integrating all tips?  By default, this is <code>FALSE</code>, but
speedups of up to 25% are possible with this set to <code>TRUE</code>.
</p>
</li>
<li> <p><code>w</code>: Number of standard deviations of the normal
distribution induced by Brownian motion to use when doing the
convolutions (default=5).  Probably best to leave this one alone.
</p>
</li></ul>



<h3>Warning</h3>

<p>In an attempt at being computationally efficient, a substantial amount
of information is cached in memory so that it does not have to be
created each time.  However, this can interact poorly with the
<code>multicore</code> package.  In particular, likelihood functions should
not be made within a call to <code>mclapply</code>, or they will not share
memory with the main <span class="rlang"><b>R</b></span> thread, and will not work (this will cause an
error, but should no longer crash <span class="rlang"><b>R</b></span>).
</p>
<p>The method has less general testing than BiSSE, and is a little more
fragile.  In particular, because of the way that I chose to implement
the integrator, there is a very real chance of likelihood calculation
failure when your data are a poor fit to the model; this can be
annoyingly difficult to diagnose (you will just get a <code>-Inf</code> log
likelihood, but the problem is often just caused by two sister species
on short branches with quite different states).  There are also a
large number of options for fine tuning the integration, but these
aren't really discussed in any great detail anywhere.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## Example showing simple integration with two different backends,
## plus the splits.
lambda &lt;- function(x) sigmoid.x(x, 0.1, 0.2,  0, 2.5)
mu &lt;- function(x) constant.x(x, 0.03)
char &lt;- make.brownian.with.drift(0, 0.025)

set.seed(1)
phy &lt;- tree.quasse(c(lambda, mu, char), max.taxa=15, x0=0,
                   single.lineage=FALSE, verbose=TRUE)

nodes &lt;- c("nd13", "nd9", "nd5")
split.t &lt;- Inf

pars &lt;- c(.1, .2, 0, 2.5, .03, 0, .01)
pars4 &lt;- unlist(rep(list(pars), 4))

sd &lt;- 1/200
control.C.1 &lt;- list(dt.max=1/200)


## Not run: 
control.R.1 &lt;- list(dt.max=1/200, method="fftR")
lik.C.1 &lt;- make.quasse(phy, phy$tip.state, sd, sigmoid.x, constant.x, control.C.1)
(ll.C.1 &lt;- lik.C.1(pars)) # -62.06409




## slow...
lik.R.1 &lt;- make.quasse(phy, phy$tip.state, sd, sigmoid.x, constant.x, control.R.1)
(ll.R.1 &lt;- lik.R.1(pars)) # -62.06409

lik.s.C.1 &lt;- make.quasse.split(phy, phy$tip.state, sd, sigmoid.x, constant.x,
                               nodes, split.t, control.C.1)
(ll.s.C.1 &lt;- lik.s.C.1(pars4)) # -62.06409

## End(Not run)
</code></pre>

<hr>
<h2 id='make.quasse.split'>Quantitative State Speciation and Extinction Model: Split Models</h2><span id='topic+make.quasse.split'></span>

<h3>Description</h3>

<p>Create a likelihood function for a QuaSSE model where the
tree is partitioned into regions with different parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.quasse.split(tree, states, states.sd, lambda, mu, nodes, split.t,
                  control=NULL, sampling.f=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.quasse.split_+3A_tree">tree</code></td>
<td>
<p>An ultrametric bifurcating phylogenetic tree, in
<code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_states">states</code></td>
<td>
<p>A vector of character states, each of which must be a
numeric real values.  Missing values (<code>NA</code>) are not yet handled.
This vector must have names that correspond to the tip labels in the
phylogenetic tree  (<code>tree$tip.label</code>).</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_states.sd">states.sd</code></td>
<td>
<p>A scalar or vector corresponding to the standard
error around the mean in states (the initial probability
distribution is assumed to be normal).</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_lambda">lambda</code></td>
<td>
<p>A function to use as the speciation function.  The first
argument of this must be <code>x</code> (see Details).</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_mu">mu</code></td>
<td>
<p>A function to use as the extinction function.  The first
argument of this must be <code>x</code> (see Details.)</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_nodes">nodes</code></td>
<td>
<p>Vector of nodes that will be split (see Details).</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_split.t">split.t</code></td>
<td>
<p>Vector of split times, same length as <code>nodes</code> (see
Details).</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_control">control</code></td>
<td>
<p>A list of parameters for tuning the performance of the
integrator.  A guess at reasonble values will be made here.  See
Details in <code><a href="#topic+make.quasse">make.quasse</a></code> for possible entries.</p>
</td></tr>
<tr><td><code id="make.quasse.split_+3A_sampling.f">sampling.f</code></td>
<td>
<p>Scalar with the estimated proportion of extant
species that are included in the phylogeny.  A value of <code>0.75</code>
means that three quarters of extant species are included in the
phylogeny.  By default all species are assumed to be known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Branching times can be controlled with the <code>split.t</code>
argument.  If this is <code>Inf</code>, split at the base of the branch (as in
MEDUSA).  If <code>0</code>, split at the top (closest to the present, as in
the new option for MEDUSA).  If <code>0 &lt; split.t &lt; Inf</code> then we split
at that time on the tree (zero is the present, with time growing
backwards).
</p>
<p>TODO: Describe <code>nodes</code> and <code>split.t</code> here.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='mcmc'>Simple Markov Chain Monte Carlo with Slice Sampling</h2><span id='topic+mcmc'></span><span id='topic+mcmc.default'></span><span id='topic+sampler.slice'></span><span id='topic+sampler.norm'></span>

<h3>Description</h3>

<p>Run a simple-minded MCMC using slice samples (Neal 2003)
for independent updating of each variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(lik, x.init, nsteps, ...)
## Default S3 method:
mcmc(lik, x.init, nsteps, w, prior=NULL,
             sampler=sampler.slice, fail.value=-Inf, lower=-Inf,
             upper=Inf, print.every=1, control=list(),
             save.file, save.every=0, save.every.dt=NULL,
             previous=NULL, previous.tol=1e-4, keep.func=TRUE, ...)

sampler.slice(lik, x.init, y.init, w, lower, upper, control)
sampler.norm(lik, x.init, y.init, w, lower, upper, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_+3A_lik">lik</code></td>
<td>
<p>Likelihood function to run MCMC on.  This must return the
log likelihood (or the log of a value proportional to the
likelihood).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_x.init">x.init</code></td>
<td>
<p>Initial parameter location (vector).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of MCMC steps to take.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_w">w</code></td>
<td>
<p>Tuning parameter for the sampler.  See Details below for
more information.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_prior">prior</code></td>
<td>
<p>An optional prior probability distribution function.
This must be a function that returns the log prior probability,
given a parameter vector. See <code><a href="#topic+make.prior">make.prior</a></code> for more
information.  If no prior is given, unbounded (and therefore
&ldquo;improper&rdquo;) priors are used for all parameters, which can
cause the MCMC to fail in some situations.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_sampler">sampler</code></td>
<td>
<p>Sampler to use for the MCMC.  There are currently only
two implemented; <code>sampler.slice</code> (the default, and generally
recommended), and <code>sampler.norm</code> (Gaussian updates, and for
illustrative purposes mostly).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_lower">lower</code></td>
<td>
<p>Lower bounds on parameter space (scalar or vector of same
length as <code>x.init</code>).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_upper">upper</code></td>
<td>
<p>Upper bounds on parameter space (scalar or vector of same
length as <code>x.init</code>).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_fail.value">fail.value</code></td>
<td>
<p>Value to use where function evaluation fails.  The
default (negative infinity) corresponds to zero probability.  Most
values that fail are invalid for a given model (negative rates, etc)
or have negligble probability, so this is reasonable.  Set to
<code>NULL</code> to turn off checking.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_print.every">print.every</code></td>
<td>
<p>The position and its probability will be printed
every <code>print.every</code> generations.  Set this to 0 to disable
printing.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_control">control</code></td>
<td>
<p>List with additional control parameters for the
sampler.  Not currently used.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_save.file">save.file</code></td>
<td>
<p>Name of csv or rds file to save temporary output in.
Contents will be rewritten at each save (rds is faster than csv, but
is R-specific).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_save.every">save.every</code></td>
<td>
<p>Number of steps to save progress into
<code>save.file</code>.  By default this is 0, which prevents saving
occuring.  Low nonzero values of this will slow things down, but
may be useful during long runs.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_save.every.dt">save.every.dt</code></td>
<td>
<p>Period of time to save after, as a
<code>lubridate</code> <code>Period</code> object (e.g., <code>minutes(10)</code>).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_previous">previous</code></td>
<td>
<p>Output from a previous <code>mcmc</code> run, perhaps only
partly completed.  The sampler will continue from the end of this
chain until the total chain has <code>nsteps</code> points.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_previous.tol">previous.tol</code></td>
<td>
<p>Before continuing, the sampler re-evaluates the
last point and compares the posterior probability against the
posterior probability in the <code>previous</code> samples.  If the
difference is greater than <code>previous.tol</code> then <code>mcmc</code> will
not continue.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_keep.func">keep.func</code></td>
<td>
<p>Indicates if the returned samples should include the
likelihood function, which can be accessed with
<code><a href="#topic+get.likelihood">get.likelihood</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_...">...</code></td>
<td>
<p>Arguments passed to the function <code>lik</code></p>
</td></tr>
<tr><td><code id="mcmc_+3A_y.init">y.init</code></td>
<td>
<p>Likelihood evaluated at <code>x.init</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two samplers implemented: a slice sampler (Neal 2003) and a
basic Gaussian sampler.  In general, only the slice sampler should be
used; the Gaussian sampler is provided for illustration and as a
starting point for future samplers.
</p>
<p>For slice sampling (<code>sampler.slice</code>), the tuning parameter <code>w</code>
affects how many function evaluations are required between sample
updates, but in almost all cases <strong>it does not affect how fast the
MCMC &ldquo;mixes&rdquo;</strong> (Neal 2003).  In particular, <code>w</code> is not analagous
to the step sizes used in conventional Metropolis-Hastings updaters that
use some fixed kernel for updates (see below).  Ideally, <code>w</code> would
be set to approximately the width of the high probability region.  I
find that chosing the distance between the 5% and 95% quantiles of the
marginal distributions of each parameter works well, computed from this
preliminary set of samples (see Examples).  If a single value is given,
this is shared across all parameters.
</p>
<p>For the Gaussian updates (<code>sampler.norm</code>), the tuning parameter
<code>w</code> is the standard deviation of the normal distribution centred on
each parameter as it is updated.
</p>
<p>For both samplers, if a single value is given, this is shared across all
parameters.  If a vector is given, then it must be the same length as
<code>w</code>, and parameter <code>i</code> will use <code>w[i]</code>.
</p>
<p>If the MCMC is stopped by an interrupt (Escape on GUI versions of R,
Control-C on command-line version), it will return a truncated chain
with as many points as completed so far.
</p>
<p>This is far from the most efficient MCMC function possible, as it was
designed to work with likelihood functions that are relatively expensive
to compute.  The overhead for 10,000 slice samples is on the order of 5s
on a 2008 Mac Pro (0.0005 s / sample).
</p>
<p>The sampler function <code>sampler.norm</code> and <code>sampler.slice</code> should
not generally be called directly (though this is possible), but exist
only to be passed in to <code>mcmc</code>.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>References</h3>

<p>Neal R.M. 2003. Slice sampling. Annals of Statistics 31:705-767.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.bd">make.bd</a></code>, <code><a href="#topic+make.bisse">make.bisse</a></code>,
<code><a href="#topic+make.geosse">make.geosse</a></code>, and <code><a href="#topic+make.mkn">make.mkn</a></code>, all of which
provide likelihood functions that are suitable for use with this
function.  The help page for <code><a href="#topic+make.bd">make.bd</a></code> has further
examples of using MCMC, and <code><a href="#topic+make.bisse">make.bisse</a></code> has examples of
using priors with MCMC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## To demonstrate, start with a simple bivariate normal.  The function
## 'make.mvn' creates likelihood function for the multivariate normal
## distribution given 'mean' (a vector) and 'vcv' (the variance
## covariance matrix).  This is based on mvnorm in the package
## mvtnorm, but will be faster where the vcv does not change between
## calls.
make.mvn &lt;- function(mean, vcv) {
  logdet &lt;- as.numeric(determinant(vcv, TRUE)$modulus)
  tmp &lt;- length(mean) * log(2 * pi) + logdet
  vcv.i &lt;- solve(vcv)

  function(x) {
    dx &lt;- x - mean
    -(tmp + rowSums((dx %*% vcv.i) * dx))/2
  }
}

## Our target distribution has mean 0, and a VCV with positive
## covariance between the two parameters.
vcv &lt;- matrix(c(1, .25, .25, .75), 2, 2)
lik &lt;- make.mvn(c(0, 0), vcv)

## Sample 500 points from the distribution, starting at c(0, 0).
set.seed(1)
samples &lt;- mcmc(lik, c(0, 0), 500, 1, print.every=100)

## The marginal distribution of V1 (the first axis of the
## distribution) should be a normal distribution with mean 0 and
## variance 1:
curve(dnorm, xlim=range(samples$X1), ylim=c(0, .5), col="red")
hist(samples$X1, 30, add=TRUE, freq=FALSE)

plot(X2 ~ X1, samples, pch=19, cex=.2, col="#00000055", asp=1)

## The estimated variance here matches nicely with the true VCV: (These
## all look much better if you increase the number of sampled points,
## say to 10,000)
var(samples[2:3])

## The above uses slice sampling.  We can use simple Gaussian updates
## instead.  This performs updates with standard deviation '1' in each
## direction.  Unlike slice sampling, the 'w' parameter here will
## matter a great deal in determining how fast the chain will mix.
samples.norm &lt;- mcmc(lik, c(0, 0), 500, 1, print.every=100,
                     sampler=sampler.norm)

## This *appears* to run much faster than the slice sampling based
## approach above, but the effective sample size of the second
## approach is much lower.  The 'effectiveSize' function in coda says
## that for 10,000 samples using slice sampling, the effective sample
## size (equivalent number of independent samples) is about 8,500, but
## for the Gaussian updates is only 1,200.  This can be seen by
## comparing the autocorrelation between samples from the two
## different runs.  
op &lt;- par(oma=c(0, 0, 2, 0))
acf(samples[2:3])
title(main="Slice sampling", outer=TRUE)

acf(samples.norm[2:3])
title(main="Gaussian updates", outer=TRUE)

## The autocorrelation is negligable after just 2 samples under slice
## sampling, but remains significant for about 15 with Gaussian
## updates.

## Not run: 
## Next, a diversitree likelihood example.  This example uses a 203
## species phylogeny evolved under the BiSSE model.  This takes a
## more substantial amount of time, so is not evaluated by default.
pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(2)
phy &lt;- tree.bisse(pars, max.t=60, x0=0)

## First, create a likelihood function:
lik &lt;- make.bisse(phy, phy$tip.state)
lik(pars)

## This produces about a sample a second, so takes a while.  The "upper"
## limit is a hard upper limit, above which the sampler will never let
## the parameter go (in effect, putting a uniform prior on the range
## lower..upper, and returning the joint distribution conditional on the
## parameters being in this range).
tmp &lt;- mcmc(lik, pars, nsteps=100, w=.1)

## The argument 'w' works best when it is about the width of the "high
## probability" region for that parameter.  This takes the with of the
## 90% quantile range.  The resulting widths are only slightly faster
## than the first guess.  Samples are generated about 1/s; allow 15
## minutes to generate 1000 samples.
w &lt;- diff(sapply(tmp[2:7], quantile, c(.05, .95)))
out &lt;- mcmc(lik, pars, nsteps=1000, w=w)

## You can do several things with this.  Look for candidate ML points:
out[which.max(out$p),]

## Or look at the marginal distribution of parameters
profiles.plot(out["lambda0"], col.line="red")

## Or look at the joint marginal distribution of pairs of parameters
plot(lambda0 ~ mu0, out)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.history'>Plot Character History</h2><span id='topic+plot.history'></span>

<h3>Description</h3>

<p>Both stochastic character mapping and simulation may create
character histories.  This function plots these histories</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'history'
plot(x, phy, cols=seq_along(states),
             states=x$states,
             xlim=NULL, ylim=NULL, show.tip.label=TRUE,
             show.node.label=FALSE, show.tip.state=TRUE,
             show.node.state=TRUE, no.margin=FALSE, cex=1, font=3,
             srt=0, adj=0, label.offset=NA, lwd=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.history_+3A_x">x</code></td>
<td>
<p>An object of class <code>history.discrete</code> containing a
discrete character history.  This could be made by
<code><a href="#topic+history.from.sim.discrete">history.from.sim.discrete</a></code>.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_phy">phy</code></td>
<td>
<p>The phylogeny used to generate the history.  Few checks are
made to make sure that this is really correct, and all manner of
terrible things might happen if these are not compatible.  This may
change in future.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_cols">cols</code></td>
<td>
<p>A vector of colours.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_states">states</code></td>
<td>
<p>The different state types.  Probably best to leave
alone.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_xlim">xlim</code></td>
<td>
<p>Plot x-limits (optional).</p>
</td></tr>
<tr><td><code id="plot.history_+3A_ylim">ylim</code></td>
<td>
<p>Plot y-limits (optional).</p>
</td></tr>
<tr><td><code id="plot.history_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>Logical: show the species tip labels?</p>
</td></tr>
<tr><td><code id="plot.history_+3A_show.node.label">show.node.label</code></td>
<td>
<p>Logical: show the species node labels?</p>
</td></tr>
<tr><td><code id="plot.history_+3A_show.tip.state">show.tip.state</code></td>
<td>
<p>Logical: draw a symbol at the tips to indicate
tip state?</p>
</td></tr>
<tr><td><code id="plot.history_+3A_show.node.state">show.node.state</code></td>
<td>
<p>Logical: draw a symbol at the nodes to indicate
node state?</p>
</td></tr>
<tr><td><code id="plot.history_+3A_no.margin">no.margin</code></td>
<td>
<p>Supress drawing of margins around the plot</p>
</td></tr>
<tr><td><code id="plot.history_+3A_cex">cex</code></td>
<td>
<p>Font and symbol scaling factor.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_font">font</code></td>
<td>
<p>Font used for tip and node labels (see
<code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.history_+3A_srt">srt</code></td>
<td>
<p>String rotation for tip and node labels.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_adj">adj</code></td>
<td>
<p>Label <code>adj</code>ustment (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="plot.history_+3A_label.offset">label.offset</code></td>
<td>
<p>Horizontal offset of tip and node labels, in
branch length units.</p>
</td></tr>
<tr><td><code id="plot.history_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="plot.history_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This attempts to be as compatible with <code>ape</code>'s plotting functions
as possible, but currently implements only right-facing cladegrams.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## Simulate a tree, but retain extinct species.
pars &lt;- c(.1, .2, .03, .04, 0.05, 0.1) # BiSSE pars
set.seed(2)
phy &lt;- tree.bisse(pars, 20, x0=0, include.extinct=TRUE)

## Create a 'history' from the information produced by the simulation
## and plot this
h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy, cex=.7)

## Prune the extinct taxa.
phy2 &lt;- prune(phy)

## The history must be recreated for this pruned tree:
h2 &lt;- history.from.sim.discrete(phy2, 0:1)
plot(h2, phy2, cex=.7)
</code></pre>

<hr>
<h2 id='profiles.plot'>Plot Marginal Distributions from MCMC</h2><span id='topic+profiles.plot'></span>

<h3>Description</h3>

<p>Simple plotting assistance for plotting output from MCMC
runs</p>


<h3>Usage</h3>

<pre><code class='language-R'>profiles.plot(y, col.line, col.fill, xlim=NULL, ymax=NULL, n.br=50,
              opacity=.5, xlab="Parameter estimate",
              ylab="Probability density", legend.pos=NULL,
              with.bar=TRUE, col.bg=NA, lwd=1, lines.on.top=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profiles.plot_+3A_y">y</code></td>
<td>
<p>Data frame, columns of which will be plotted as separate
profiles.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_col.line">col.line</code></td>
<td>
<p>Vector of colours for the lines.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_col.fill">col.fill</code></td>
<td>
<p>Vector of colours for the fill of the 95% most
probable region of the distribution.  If ommited, this will be a
semi-transparent version of <code>col.line</code>.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_xlim">xlim</code></td>
<td>
<p>X-axis limits - calculated automatically if omitted.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_ymax">ymax</code></td>
<td>
<p>Y-axis upper limit - calculated automatically if omitted.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_n.br">n.br</code></td>
<td>
<p>Number of breaks along the range of the data.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_opacity">opacity</code></td>
<td>
<p>Opacity of the filled region (0 is transparent, 1 is
fully opaque).</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_xlab">xlab</code>, <code id="profiles.plot_+3A_ylab">ylab</code></td>
<td>
<p>Axis labels for the plot.</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>String to pass to <code><a href="graphics.html#topic+legend">legend</a></code> to position
the legend (for automatic legend building based on the names of
<code>y</code>).</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_with.bar">with.bar</code></td>
<td>
<p>Should a bar be included that shows the CI ranges
below the plot (in addition to the shading)?</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_col.bg">col.bg</code></td>
<td>
<p>Colour to draw behind the profiles (set to &quot;white&quot; for
nicer transparency on non-white backgrounds)</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_lwd">lwd</code></td>
<td>
<p>Width of lines around the profiles</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_lines.on.top">lines.on.top</code></td>
<td>
<p>Draw lines around profiles on top of all profiles?</p>
</td></tr>
<tr><td><code id="profiles.plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed through to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For usage, see the example in ?make.bd
</code></pre>

<hr>
<h2 id='protect'>Protect Function Evaluations</h2><span id='topic+protect'></span><span id='topic+invert'></span>

<h3>Description</h3>

<p>Ensures non-failure and possibly finite-ness of a function
evaluation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>protect(f, fail.value.default=NULL)
invert(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protect_+3A_f">f</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="protect_+3A_fail.value.default">fail.value.default</code></td>
<td>
<p>Value that will be used as on failure of
<code>f</code>, if not overridden.  The default here (<code>NULL</code>) will
allow failure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>protect</code> returns a function with arguments
</p>
<pre>
    g(..., fail.value=fail.value.default, finite=NULL)
  </pre>
<p>The <code>...</code> arguments are all passed through to the underlying
function <code>f</code>, <code>fail.value</code> contains the value to return in
the event of a failure (e.g., an error occuring).  If <code>finite</code> is
<code>TRUE</code>, then <code>fail.value</code> is also returned where the value
is <code>NA</code>, <code>NaN</code> or infinite.
</p>
<p>Some functions, such as <code><a href="stats.html#topic+optim">optim</a></code> with method
<code>L-BFGS-B</code> (and therefore <code><a href="#topic+find.mle">find.mle</a></code>), require that
every value is finite.  Optimisation with these functions also
requires that the target functions to not generate errors.
<code>protect</code> catches these issues, returning the value of
<code>fail.value</code> instead.
</p>
<p>No check is made that <code>f</code> returns a single value, but it should.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) log(x)
g &lt;- protect(f)
f(0) # -Inf
g(0, fail.value=-999) # -999

f &lt;- function(x) {
  if ( x &lt; 1 )
    stop("dummmy error")
  x
}
g &lt;- protect(f)
## Not run: 
f(0) # error

## End(Not run)
g(0, fail.value=-999) # -999
</code></pre>

<hr>
<h2 id='quasse-common'>Support Functions for QuaSSE Models</h2><span id='topic+constant.x'></span><span id='topic+make.linear.x'></span><span id='topic+sigmoid.x'></span><span id='topic+sigmoid2.x'></span><span id='topic+stepf.x'></span><span id='topic+noroptimal.x'></span><span id='topic+make.brownian.with.drift'></span>

<h3>Description</h3>

<p>Utility functions for working with QuaSSE models.  These
provide a minimal set of state-varying functions, suitable for use
with <code><a href="#topic+make.quasse">make.quasse</a></code>, and simulation assistance functions
for use with <code><a href="#topic+tree.quasse">tree.quasse</a></code>.
</p>
<p>This is currently poorly explained!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant.x(x, c)
sigmoid.x(x, y0, y1, xmid, r)
stepf.x(x, y0, y1, xmid)
noroptimal.x(x, y0, y1, xmid, s2)

make.linear.x(x0, x1)

make.brownian.with.drift(drift, diffusion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quasse-common_+3A_x">x</code></td>
<td>
<p>Character state</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_c">c</code></td>
<td>
<p>Constant.</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_y0">y0</code></td>
<td>
<p>y value at very small <code>x</code> (limit as <code>x</code> tends to
negative infinity)</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_y1">y1</code></td>
<td>
<p>y value at very large <code>x</code> (limit as <code>x</code> tends to
infinity).  For <code>noroptimal.x</code>, this is the y value at
<code>xmid</code>.</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_xmid">xmid</code></td>
<td>
<p>Midpoint (inflection point) of sigmoid or step function</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_r">r</code></td>
<td>
<p>Rate at which exponential decay occurs or sigmoid changes -
higher values are steeper</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_s2">s2</code></td>
<td>
<p>Variance of the normal distribution specified by
<code>noroptimal.x</code>.</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_x0">x0</code></td>
<td>
<p>Lower x limit for the linear function: y will take value at
x0 for all x smaller than this</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_x1">x1</code></td>
<td>
<p>Upper x limit for the linear function: y will take value at
x1 for all x greater than this</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_drift">drift</code></td>
<td>
<p>Rate of drift</p>
</td></tr>
<tr><td><code id="quasse-common_+3A_diffusion">diffusion</code></td>
<td>
<p>Rate of diffusion (positive)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear function returned by  (<code>make.linear.x</code>) will go to
zero wherever negative.  This may not always be desired, but is
required for valid likelihood calculations under QuaSSE.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='set.defaults'>Set Default Arguments of a Function</h2><span id='topic+set.defaults'></span>

<h3>Description</h3>

<p>Set the default values of formal arguments of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.defaults(f, ..., defaults)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.defaults_+3A_f">f</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="set.defaults_+3A_...">...</code></td>
<td>
<p>Named arguments to be set</p>
</td></tr>
<tr><td><code id="set.defaults_+3A_defaults">defaults</code></td>
<td>
<p>A named list of arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The repetitive argument lists of many of diversitree's
likelihood functions are the motivation for this function.
</p>
<p>For example, the likelihood function that <code>make.bisse</code> produces
takes arguments <code>condition.surv</code>, <code>root</code>, and <code>root.p</code>,
each with default values.  If you dislike the defaults, you can change
them by passing in alternative values when computing likelihoods, or
when doing an ML search.  However, this can get tedious if you are
using a function a lot, and your code will get cluttered with lots of
statements like <code>condition.surv=FALSE</code>, some of which you may
forget.  See the example below for how to avoid this.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(4)
phy &lt;- tree.bisse(pars, max.t=30, x0=0)
lik &lt;- make.bisse(phy, phy$tip.state)

## default arguments:
args(lik)

lik.no.cond &lt;- set.defaults(lik, condition.surv=FALSE)
args(lik.no.cond)

## Multiple arguments at once:
lik2 &lt;- set.defaults(lik, root=ROOT.GIVEN, root.p=c(0, 1))
args(lik2)

## Equivalently (using alist, not list -- see ?alist)
defaults &lt;- alist(root=ROOT.GIVEN, root.p=c(0, 1))
lik3 &lt;- set.defaults(lik, defaults=defaults)
identical(lik2, lik3)
</code></pre>

<hr>
<h2 id='sim.character'>Simulate a Character Distribution on a Tree</h2><span id='topic+sim.character'></span><span id='topic+make.sim.character'></span>

<h3>Description</h3>

<p>Simulate a character distribution (state of each species)
under some simple models of trait evolution.  Currently this does not
return the full history (node states, and state changes) but this may
be added in a future version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.character(tree, pars, x0=0, model="bm", br=NULL)
make.sim.character(tree, pars, model="bm", br=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.character_+3A_tree">tree</code></td>
<td>
<p>A bifurcating phylogenetic tree, in <code>ape</code>
&ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="sim.character_+3A_pars">pars</code></td>
<td>
<p>A set of model parameters (see Details below), as the
order and interpretation depends on the model.</p>
</td></tr>
<tr><td><code id="sim.character_+3A_x0">x0</code></td>
<td>
<p>Root state.  The default is zero, which may not make sense
in all models.</p>
</td></tr>
<tr><td><code id="sim.character_+3A_model">model</code></td>
<td>
<p>Character string specifying which model to evolve the
character under.  Possible values are <code>"bm"</code>, <code>"ou"</code>,
<code>"bbm"</code>, <code>"mk"</code> and <code>"meristic"</code>; see Details.</p>
</td></tr>
<tr><td><code id="sim.character_+3A_br">br</code></td>
<td>
<p>For cases where none of the models specifiable through the
<code>model</code> argument are sufficient, you can provide your own
function.  The function must have arguments <code>x0</code>, <code>t</code>,
which are the state at the base of a branch and the length of time
to simulate over.  It must return a scalar state at the tip of the
branch.  Future versions may change requirements of this function,
especially to allow retention of character histories along
branches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function duplicates functionality in other packages; see
<code>sim.char</code> in <code>geiger</code> in particular.  The main difference
here is that for continuous characters, this does not use the
variance-covariance matrix, which can make it much faster for very
large trees.  I believe that this approach is similar to <code>fastBM</code>
in <code>phytools</code>.
</p>

<ul>
<li> <p><code>model="bm"</code>: Brownian Motion.  Takes a single
parameter, representing the rate of diffusion (must be positive)
</p>
</li>
<li> <p><code>model="ou"</code>: Ornstein-Uhlenbeck process.  Takes a vector
of three parameters, representing the rate of diffusion, strength of
restoring force, and the &quot;optimum&quot; value.  The first two parameters
must be non-negative, and the rate of diffusion must be positive.
</p>
</li>
<li> <p><code>model="bbm"</code>: Bounded Brownian Motion.  Takes a vector
of three parameters (<code>s2</code>, <code>c</code>, <code>d</code>), representing
the rate of diffusion, lower and upper bound, respectively.  The
rate of diffusion must be positive.
</p>

<p><code>model="mk"</code>: Mk model (see <code><a href="#topic+make.mkn">make.mkn</a></code>).  Takes a Q
matrix as its argument.  The element <code>Q[i,j]</code> represents the
rate of transition from state <code>i</code> to state <code>j</code>, and the
diagonal elements must be such that <code>rowSums(Q)</code> is zero.
</p>
<p><code>model="meristic"</code>: A special case of the Mk model, where the
trait is meristic and character transitions are only possible
between adjacent states.  There are three parameters (<code>k</code>,
<code>up</code>, <code>down</code>), representing the number of states, and rate
of character change up (from state <code>i</code> to <code>i+1</code>) and down.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

<hr>
<h2 id='simulate'>Evolve Birth-Death Trees</h2><span id='topic+trees'></span><span id='topic+tree.bd'></span><span id='topic+tree.bisse'></span><span id='topic+tree.bisseness'></span><span id='topic+tree.classe'></span><span id='topic+tree.geosse'></span><span id='topic+tree.musse'></span><span id='topic+tree.musse.multitrait'></span><span id='topic+tree.quasse'></span><span id='topic+tree.yule'></span><span id='topic+prune'></span>

<h3>Description</h3>

<p>Evolves one or more trees under the BiSSE (Binary State
Speciation and Extinction), MuSSE (Multi-State Speciation and
Extinction), BiSSE-ness (BiSSE-node enhanced state shift), ClaSSE
(Cladogenetic State change Speciation and Extinction), or GeoSSE
(Geographic State Speciation and Extinction) model, or a simple
character independent birth-death model.  For the SSE models, it
simultaneously evolves a character that affects speciation and/or
extinction, and the tree itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trees(pars, type=c("bisse", "bisseness", "bd", "classe", "geosse",
      "musse", "quasse", "yule"), n=1, max.taxa=Inf, max.t=Inf,
      include.extinct=FALSE, ...)

tree.bisse(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE,
           x0=NA)
tree.musse(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE,
           x0=NA)
tree.musse.multitrait(pars, n.trait, depth, max.taxa=Inf, max.t=Inf,
                      include.extinct=FALSE, x0=NA)

tree.quasse(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE, x0=NA,
            single.lineage=TRUE, verbose=FALSE)

tree.bisseness(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE,
               x0=NA)

tree.classe(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE,
           x0=NA)

tree.geosse(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE,
           x0=NA)

tree.bd(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE)
tree.yule(pars, max.taxa=Inf, max.t=Inf, include.extinct=FALSE)

prune(phy, to.drop=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_pars">pars</code></td>
<td>
<p>Vector of parameters.  The parameters must be in the same
order as an unconstrained likelihood function returned by
<code>make.x</code>, for tree type <code>x</code>.  The MuSSE simulator automatically
detects the appropriate number of states, given a parameter vector.</p>
</td></tr>
<tr><td><code id="simulate_+3A_type">type</code></td>
<td>
<p>Type of tree to generate: May be &quot;bisse&quot; or &quot;bd&quot;.</p>
</td></tr>
<tr><td><code id="simulate_+3A_n">n</code></td>
<td>
<p>How many trees to generate?</p>
</td></tr>
<tr><td><code id="simulate_+3A_max.taxa">max.taxa</code></td>
<td>
<p>Maximum number of taxa to include in the tree.  If
<code>Inf</code>, then the tree will be evolved until <code>max.t</code> time
has passed.</p>
</td></tr>
<tr><td><code id="simulate_+3A_max.t">max.t</code></td>
<td>
<p>Maximum length to evolve the phylogeny over.  If
<code>Inf</code> (the default), then the tree will evolve until
<code>max.taxa</code> extant taxa are present.</p>
</td></tr>
<tr><td><code id="simulate_+3A_include.extinct">include.extinct</code></td>
<td>
<p>Logical: should extinct taxa be included in
the final phylogeny?  And should extinct trees be returned by
<code>trees</code>?</p>
</td></tr>
<tr><td><code id="simulate_+3A_x0">x0</code></td>
<td>
<p>Initial character state at the root (state 0 or 1).  A value
of <code>NA</code> will randomly choose a state from the model's
equilibrium distribution for a BiSSE, ClaSSE, or GeoSSE model, but a
non-NA value must be specified for MuSSE and QuaSSE.</p>
</td></tr>
<tr><td><code id="simulate_+3A_n.trait">n.trait</code>, <code id="simulate_+3A_depth">depth</code></td>
<td>
<p>For <code>tree.musse.multitrait</code> only, these
specify the number of binary traits and the style of parameters
(with the same meaning as in <code><a href="#topic+make.musse.multitrait">make.musse.multitrait</a></code>).
The <code>pars</code> argument then needs to be in the same order as a
likelihood function created by <code>make.musse.multitrait</code> with
these arguments (this interface may be improved in future &ndash; email
me if you find this annoying).</p>
</td></tr>
<tr><td><code id="simulate_+3A_single.lineage">single.lineage</code></td>
<td>
<p>(<code>tree.quasse</code> only): Start simulation with
a single lineage?  If <code>FALSE</code>, then the simulation starts with
two lineages in state <code>x0</code> (i.e., immediately following a
speciation event).</p>
</td></tr>
<tr><td><code id="simulate_+3A_verbose">verbose</code></td>
<td>
<p>(<code>tree.quasse</code> only): print verbose details about
tree simuations.  This can be reassuring for really large trees.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="simulate_+3A_phy">phy</code></td>
<td>
<p>A phylogeny, possibly with extinct species, produced by one
of the tree evolving functions.</p>
</td></tr>
<tr><td><code id="simulate_+3A_to.drop">to.drop</code></td>
<td>
<p>Optional vector with the species names to drop.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The phylogeny will begin from a single lineage in state <code>x0</code>, but
the final phylogeny will include only branches above the first split.
</p>
<p><code>tree.bisse</code> may return an extinct phylogeny, and <code>trees</code>
might return extinct phylogenies if <code>include.extinct</code> is
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>phylo</code> phylogenetic tree (ape format), or for
<code>bisse.trees</code>, a <code>list</code> of <code>phylo</code> trees.
</p>
<p>The trees will have an element <code>tip.state</code> that contains the
binary state information.
</p>


<h3>Note</h3>

<p>There are some logic problems around the creation of zero and one
species trees; this will cause occasional errors when running the
above functions.  Things will change to fix this soon.  All these
functions may change in the near future.
</p>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

pars &lt;- c(0.1, 0.2, 0.03, 0.03, 0.01, 0.01)
set.seed(3)
phy &lt;- tree.bisse(pars, max.taxa=30, x0=0)
phy$tip.state

h &lt;- history.from.sim.discrete(phy, 0:1)
plot(h, phy)

## Retain extinct species:
set.seed(3)
phy2 &lt;- tree.bisse(pars, max.taxa=30, x0=0, include.extinct=TRUE)
h2 &lt;- history.from.sim.discrete(phy2, 0:1)
plot(h2, phy2)

#### MuSSE:
## Two states
pars &lt;- c(.1, .2, .03, .04, 0.05, 0.1)
set.seed(2)
phy &lt;- tree.musse(pars, 20, x0=1)

h &lt;- history.from.sim.discrete(phy, 1:2)
plot(h, phy)

## A 3-state example where movement is only allowed between neighbouring
## states (1 &lt;-&gt; 2 &lt;-&gt; 3), and where speciation and extinction rates
## increase moving from 1 -&gt; 2 -&gt; 3:
pars &lt;- c(.1,  .15,  .2,  # lambda 1, 2, 3
          .03, .045, .06, # mu 1, 2, 3
          .05, 0,         # q12, q13
          .05, .05,       # q21, q23
          0,   .05)       # q31, q32

set.seed(2)
phy &lt;- tree.musse(pars, 30, x0=1, include.extinct=TRUE)

h &lt;- history.from.sim.discrete(phy, 1:3)
plot(h, phy, cex=.7)

## And with extinct taxa pruned:
phy2 &lt;- prune(phy)
h2 &lt;- history.from.sim.discrete(phy2, 1:3)
plot(h2, phy2, cex=.7)

## This can all be done in one step (and is by default):
set.seed(2)
phy &lt;- tree.musse(pars, 30, x0=1)
h &lt;- history.from.sim.discrete(phy, 1:3)
plot(h, phy, cex=.7)
</code></pre>

<hr>
<h2 id='trait.plot'>Plot a Phylogeny and Traits</h2><span id='topic+trait.plot'></span>

<h3>Description</h3>

<p>Plot a phylogeny and label the tips with traits.
This function is experimental, and may change soon.  Currently it can
handle discrete-valued traits and two basic tree shapes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>trait.plot(tree, dat, cols, lab=names(cols), str=NULL, 
           class=NULL, type="f", w=1/50, 
           legend=length(cols) &gt; 1, cex.lab=.5, 
           font.lab=3, cex.legend=.75, margin=1/4, 
           check=TRUE, quiet=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trait.plot_+3A_tree">tree</code></td>
<td>
<p>Phylogenetic tree, in ape format.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_dat">dat</code></td>
<td>
<p>A <code>data.frame</code> of trait values.  The row names must be
the same names as the tree (<code>tree$tip.label</code>), and each column
contains the states (0, 1, etc., or <code>NA</code>).  The column names
must give the trait names.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_cols">cols</code></td>
<td>
<p>A list with colors.  Each element corresponds to a trait
and must be named so that all names appear in <code>names(dat)</code>.
Each of these elements is a vector of colors, with length matching
the number of states for that trait.  Traits will be plotted in the
order given by <code>cols</code>.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_lab">lab</code></td>
<td>
<p>Alternative names for the legend (perhaps longer or more
informative).  Must be in the same order as <code>cols</code>.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_str">str</code></td>
<td>
<p>Strings used for the states in the legend.  If <code>NULL</code>
(the default), the values in <code>dat</code> are used.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_class">class</code></td>
<td>
<p>A vector along <code>phy$tip.label</code> giving a higher level
classification (e.g., genus or family).  No checking is done to
ensure that such classifications are not polyphyletic.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_type">type</code></td>
<td>
<p>Plot type (same as <code>type</code> in <code>?plot.phylo</code>).
Currently only <code>f</code> (fan) and <code>p</code> (rightwards phylogram)
are implemented.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_w">w</code></td>
<td>
<p>Width of the trait plot, as a fraction of the tree depth.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_legend">legend</code></td>
<td>
<p>Logical: should a legend be plotted?</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_cex.lab">cex.lab</code>, <code id="trait.plot_+3A_font.lab">font.lab</code></td>
<td>
<p>Font size and type for the tip labels.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Font size for the legend.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_margin">margin</code></td>
<td>
<p>How much space, relative to the total tree depth, should
be reserved when plotting a higher level classification.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_check">check</code></td>
<td>
<p>When TRUE (by default), this will check that the classes
specified by <code>class</code> are monophyletic.  If not, classes will be 
concatenated and a warning raised.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_quiet">quiet</code></td>
<td>
<p>When TRUE (FALSE by default), this suppresses the warning
caused by <code>check=TRUE</code>.</p>
</td></tr>
<tr><td><code id="trait.plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed through to phylogeny plotting
code (similar to <code>ape</code>'s <code>plot.phylo</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Due to a change in sample() behaviour in newer R it is necessary to
## use an older algorithm to replicate the previous examples
if (getRversion() &gt;= "3.6.0") {
  RNGkind(sample.kind = "Rounding")
}

## These are the parameters: they are a single speciation and extinction
## rate, then 0-&gt;1 (trait A), 1-&gt;0 (A), 0-&gt;1 (B) and 1-&gt;0 (B).
colnames(musse.multitrait.translate(2, depth=0))

## Simulate a tree where trait A changes slowly and B changes rapidly.
set.seed(1)
phy &lt;- tree.musse.multitrait(c(.1, 0, .01, .01, .05, .05),
                             n.trait=2, depth=0, max.taxa=100,
                             x0=c(0,0))
## Here is the matrix of tip states (each row is a species, each column
## is a trait).
head(phy$tip.state)

trait.plot(phy, phy$tip.state,
           cols=list(A=c("pink", "red"), B=c("lightblue", "blue")))

nodes &lt;- c("nd5", "nd4", "nd7", "nd11", "nd10", "nd8")
grp &lt;- lapply(nodes, get.descendants, phy, tips.only=TRUE)
class &lt;- rep(NA, 100)
for ( i in seq_along(grp) )
  class[grp[[i]]] &lt;- paste("group", LETTERS[i])

## Now, 'class' is a vector along phy$tip.label indicating which of six
## groups each species belongs.

## Plotting the phylogeny with these groups:
trait.plot(phy, phy$tip.state,
           cols=list(A=c("pink", "red"), B=c("lightblue", "blue")),
           class=class, font=1, cex.lab=1, cex.legend=1)

## Add another state, showing values 1:3, names, and trait ordering.
tmp &lt;- sim.character(phy, c(-.1, .05, .05, .05, -.1, .05, .05, 0.05, -.1), 
                     model="mkn", x0=1)
phy$tip.state &lt;- data.frame(phy$tip.state, C=tmp)
trait.plot(phy, phy$tip.state,
           cols=list(C=c("palegreen", "green3", "darkgreen"),
                     A=c("pink", "red"), B=c("lightblue", "blue")),
           lab=c("Animal", "Vegetable", "Mineral"),
           str=list(c("crane", "toad", "snail"), c("kale", "carrot"), 
                    c("calcite", "beryl")))

## Rectangular/phylogram plot with groups.
trait.plot(ladderize(phy, right=FALSE), phy$tip.state, type="p",
           cols=list(A=c("pink", "red"), B=c("lightblue", "blue"),
                     C=c("palegreen", "green3", "darkgreen")),
           class=class, font=1, cex.lab=1)
</code></pre>

<hr>
<h2 id='utilities'>Utility Functions</h2><span id='topic+get.descendants'></span><span id='topic+run.cached'></span><span id='topic+expand.parameters'></span><span id='topic+drop.likelihood'></span><span id='topic+get.likelihood'></span>

<h3>Description</h3>

<p>These are utility functions that are used internally by diversitree,
but which might be more generally useful.
</p>
<p>Currently only <code>get.descendants</code> docuemnted here, which
determines which species or nodes are descended from a particular
node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.descendants(node, tree, tips.only=FALSE, edge.index=FALSE)
run.cached(filename, expr, regenerate=FALSE)
expand.parameters(p, lik.new, repl=0, target=argnames(lik.new))
get.likelihood(object)
drop.likelihood(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilities_+3A_node">node</code></td>
<td>
<p>A node, either a name in <code>tree$node.label</code>, an
integer in <code>1..tree$Nnode</code>, or in
<code>length(tree$tip.label)..(length(tree$tip.label)+tree$Nnode)</code>.</p>
</td></tr>
<tr><td><code id="utilities_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree, in ape's <code>phylo</code> format.</p>
</td></tr>
<tr><td><code id="utilities_+3A_tips.only">tips.only</code></td>
<td>
<p>Logical: return only descendant indices of tip
species?</p>
</td></tr>
<tr><td><code id="utilities_+3A_edge.index">edge.index</code></td>
<td>
<p>Logical: return the row indices in the edge matrix?</p>
</td></tr>
<tr><td><code id="utilities_+3A_filename">filename</code></td>
<td>
<p>Name of the file to store cached results</p>
</td></tr>
<tr><td><code id="utilities_+3A_expr">expr</code></td>
<td>
<p>Expression to evaluate</p>
</td></tr>
<tr><td><code id="utilities_+3A_regenerate">regenerate</code></td>
<td>
<p>Logical: force re-evaluation of expr and
regeneration of filename?</p>
</td></tr>
<tr><td><code id="utilities_+3A_object">object</code></td>
<td>
<p>For <code>drop.likelihood</code>, an object that has a
<code>likelihood</code> attribute to be removed (saves space on object
save); for <code>get.likelihood</code>, retrieves the function.</p>
</td></tr>
<tr><td><code id="utilities_+3A_p">p</code>, <code id="utilities_+3A_lik.new">lik.new</code>, <code id="utilities_+3A_repl">repl</code>, <code id="utilities_+3A_target">target</code></td>
<td>
<p>Undocumented currently</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard G. FitzJohn</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
