<!DOCTYPE html><html><head><title>Help for package RcppSimdJson</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcppSimdJson}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RcppSimdJson-package'><p>'Rcpp' Bindings for the 'simdjson' Header-Only Library for 'JSON' Parsing</p></a></li>
<li><a href='#fparse'><p>Fast, Friendly, and Flexible JSON Parsing</p></a></li>
<li><a href='#is_valid_json'><p>simdjson Utilities</p></a></li>
<li><a href='#parseExample'><p>Simple JSON Parsing Example</p></a></li>
<li><a href='#validateJSON'><p>Validate a JSON file, fast</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Rcpp' Bindings for the 'simdjson' Header-Only Library for
'JSON' Parsing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Eddelbuettel, Brendan Knapp, Daniel Lemire</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'JSON' format is ubiquitous for data interchange, and the
 'simdjson' library written by Daniel Lemire (and many contributors) provides a
 high-performance parser for these files which by relying on parallel 'SIMD'
 instruction manages to parse these files as faster than disk speed. See the
 &lt;<a href="https://doi.org/10.48550%2FarXiv.1902.08318">doi:10.48550/arXiv.1902.08318</a>&gt; paper for more details about 'simdjson'.  This
 package parses 'JSON' from string, file, or remote URLs under a variety of
 settings.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, tinytest</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>A C++17 compiler is required</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eddelbuettel/rcppsimdjson/">https://github.com/eddelbuettel/rcppsimdjson/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eddelbuettel/rcppsimdjson/issues">https://github.com/eddelbuettel/rcppsimdjson/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-07 15:31:55 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-07 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RcppSimdJson-package'>'Rcpp' Bindings for the 'simdjson' Header-Only Library for 'JSON' Parsing</h2><span id='topic+RcppSimdJson-package'></span><span id='topic+RcppSimdJson'></span>

<h3>Description</h3>

<p>The 'JSON' format is ubiquitous for data interchange, and the
 'simdjson' library written by Daniel Lemire (and many contributors) provides a
 high-performance parser for these files which by relying on parallel 'SIMD'
 instruction manages to parse these files as faster than disk speed. See the
 &lt;doi:10.48550/arXiv.1902.08318&gt; paper for more details about 'simdjson'.  This
 package parses 'JSON' from string, file, or remote URLs under a variety of
 settings.</p>


<h3>Package Content</h3>


<p>Index of help topics:
</p>
<pre>
RcppSimdJson-package    'Rcpp' Bindings for the 'simdjson' Header-Only
                        Library for 'JSON' Parsing
fparse                  Fast, Friendly, and Flexible JSON Parsing
is_valid_json           simdjson Utilities
parseExample            Simple JSON Parsing Example
validateJSON            Validate a JSON file, fast
</pre>

<h3>Maintainer</h3>

<p>Dirk Eddelbuettel &lt;edd@debian.org&gt;</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel, Brendan Knapp, Daniel Lemire</p>

<hr>
<h2 id='fparse'>Fast, Friendly, and Flexible JSON Parsing</h2><span id='topic+fparse'></span><span id='topic+fload'></span>

<h3>Description</h3>

<p>Parse JSON strings and files to R objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fparse(
  json,
  query = NULL,
  empty_array = NULL,
  empty_object = NULL,
  single_null = NULL,
  parse_error_ok = FALSE,
  on_parse_error = NULL,
  query_error_ok = FALSE,
  on_query_error = NULL,
  max_simplify_lvl = c("data_frame", "matrix", "vector", "list"),
  type_policy = c("anything_goes", "numbers", "strict"),
  int64_policy = c("double", "string", "integer64", "always"),
  always_list = FALSE
)

fload(
  json,
  query = NULL,
  empty_array = NULL,
  empty_object = NULL,
  single_null = NULL,
  parse_error_ok = FALSE,
  on_parse_error = NULL,
  query_error_ok = FALSE,
  on_query_error = NULL,
  max_simplify_lvl = c("data_frame", "matrix", "vector", "list"),
  type_policy = c("anything_goes", "numbers", "strict"),
  int64_policy = c("double", "string", "integer64", "always"),
  always_list = FALSE,
  verbose = FALSE,
  temp_dir = tempdir(),
  keep_temp_files = FALSE,
  compressed_download = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fparse_+3A_json">json</code></td>
<td>
<p>JSON strings, file paths, or raw vectors.
</p>

<ul>
<li> <p><code>fparse()</code>
</p>

<ul>
<li> <p><code>character</code>: One or more JSON strings.
</p>
</li>
<li> <p><code>raw</code>: <code>json</code> is interpreted as the bytes of a single
JSON string.
</p>
</li>
<li> <p><code>list</code> Every element must be of type <code>"raw"</code> and each
is individually interpreted as the bytes of a single JSON string.
</p>
</li></ul>

</li>
<li> <p><code>fload()</code>
</p>

<ul>
<li> <p><code>character</code>: One or more paths to files (local or remote)
containing JSON.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="fparse_+3A_query">query</code></td>
<td>
<p>If not <code>NULL</code>, JSON Pointer(s) used to identify and extract
specific elements within <code>json</code>. See Details and Examples.
<code>NULL</code>, <code>character()</code>, or <code>list()</code> of <code>character()</code>. default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="fparse_+3A_empty_array">empty_array</code></td>
<td>
<p>Any R object to return for empty JSON arrays.
default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="fparse_+3A_empty_object">empty_object</code></td>
<td>
<p>Any R object to return for empty JSON objects.
default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_single_null">single_null</code></td>
<td>
<p>Any R object to return for single JSON nulls.
default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_parse_error_ok">parse_error_ok</code></td>
<td>
<p>Whether to allow parsing errors.
default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_on_parse_error">on_parse_error</code></td>
<td>
<p>If <code>parse_error_ok</code> is <code>TRUE</code>, <code>on_parse_error</code> is any
R object to return when query errors occur.
default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_query_error_ok">query_error_ok</code></td>
<td>
<p>Whether to allow parsing errors.
default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_on_query_error">on_query_error</code></td>
<td>
<p>If <code>query_error_ok</code> is <code>TRUE</code>, <code>on_query_error</code> is any
R object to return when query errors occur.
default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_max_simplify_lvl">max_simplify_lvl</code></td>
<td>
<p>Maximum simplification level.
<code>character(1L)</code> or <code>integer(1L)</code>, default: <code>"data_frame"</code>
</p>

<ul>
<li> <p><code>"data_frame"</code> or <code>0L</code>
</p>
</li>
<li> <p><code>"matrix"</code> or <code>1L</code>
</p>
</li>
<li> <p><code>"vector"</code> or <code>2L</code>
</p>
</li>
<li> <p><code>"list"</code> or <code>3L</code> (no simplification)
</p>
</li></ul>
</td></tr>
<tr><td><code id="fparse_+3A_type_policy">type_policy</code></td>
<td>
<p>Level of type strictness.
<code>character(1L)</code> or <code>integer(1L)</code>, default: <code>"anything_goes"</code>.
</p>

<ul>
<li> <p><code>"anything_goes"</code> or <code>0L</code>: non-recursive arrays always become atomic vectors
</p>
</li>
<li> <p><code>"numbers"</code> or <code>1L</code>: non-recursive arrays containing only numbers always become atomic vectors
</p>
</li>
<li> <p><code>"strict"</code> or <code>2L</code>: non-recursive arrays containing mixed types never become atomic vectors
</p>
</li></ul>
</td></tr>
<tr><td><code id="fparse_+3A_int64_policy">int64_policy</code></td>
<td>
<p>How to return big integers to R.
<code>character(1L)</code> or <code>integer(1L)</code>, default: <code>"double"</code>.
</p>

<ul>
<li> <p><code>"double"</code> or <code>0L</code>: big integers become <code>double</code>s
</p>
</li>
<li> <p><code>"string"</code> or <code>1L</code>: big integers become <code>character</code>s
</p>
</li>
<li> <p><code>"integer64"</code> or <code>2L</code>: big integers become <code>bit64::integer64</code>s
</p>
</li>
<li> <p><code>"always"</code> or <code>3L</code>: all integers become <code>bit64::integer64</code>s
</p>
</li></ul>
</td></tr>
<tr><td><code id="fparse_+3A_always_list">always_list</code></td>
<td>
<p>Whether a <code>list</code> should always be returned, even when <code>length(json) == 1L</code>.
default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fparse_+3A_verbose">verbose</code></td>
<td>
<p>Whether to display status messages.
<code>TRUE</code> or <code>FALSE</code>, default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fparse_+3A_temp_dir">temp_dir</code></td>
<td>
<p>Directory path to use for any temporary files.
<code>character(1L)</code>, default: <code>tempdir()</code></p>
</td></tr>
<tr><td><code id="fparse_+3A_keep_temp_files">keep_temp_files</code></td>
<td>
<p>Whether to remove any temporary files created by
<code>fload()</code> from <code>temp_dir</code>.
<code>TRUE</code> or <code>FALSE</code>, default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fparse_+3A_compressed_download">compressed_download</code></td>
<td>
<p>Whether to request server-side compression on
the downloaded document, default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fparse_+3A_...">...</code></td>
<td>
<p>Optional arguments which can be use <em>e.g.</em> to pass additional
header settings</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Instead of using <code>lapply()</code> to parse multiple values, just use
<code>fparse()</code> and <code>fload()</code> directly.
</p>

<ul>
<li><p> They are vectorized in order to leverage the underlying
<code>simdjson::dom::parser</code>'s ability to reuse its internal buffers
between parses.
</p>
</li>
<li><p> Since the overwhelming majority of JSON parsed will not result in
scalars, a <code>list()</code> is always returned if <code>json</code> contains
more than one value.
</p>
</li>
<li><p> If <code>json</code> contains multiple values and has <code>names()</code>, the
returned object will have the same names.
</p>
</li>
<li><p> If <code>json</code> contains multiple values and is unnamed, <code>fload()</code>
names each returned element using the file's <code>basename()</code>.
</p>
</li></ul>

</li>
<li> <p><code>query</code>'s goal is to minimize te amount of data that must be
materialized as R objects (the main performance bottleneck) as well as
facilitate any post-parse processing.
</p>

<ul>
<li><p> To maximize flexibility, there are two approaches to consider when designing <code>query</code> arguments.
</p>

<ul>
<li> <p><code>character</code> vectors are interpreted as containing queries that
meant to be applied to all elements of <code>json=</code>.
</p>

<ul>
<li><p> If <code>json=</code> contains 3 strings and <code>query=</code> contains
3 strings, the returned object will be a list of 3 elements (1 for each element
of <code>json=</code>), which themselves each contain 3 lists (1 for each element
of <code>query=</code>).
</p>
</li></ul>

</li>
<li> <p><code>list</code>s of <code>character</code> vectors are interpreted as containing
queries meant to be applied  to <code>json</code> in a zip-like fashion.
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Brendan Knapp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple parsing ============================================================
json_string &lt;- '{"a":[[1,null,3.0],["a","b",true],[10000000000,2,3]]}'
fparse(json_string)

raw_json &lt;- as.raw(
    c(0x22, 0x72, 0x61, 0x77, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x63,
      0x61, 0x6e, 0x20, 0x62, 0x65, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x4a, 0x53,
      0x4f, 0x4e, 0x20, 0x74, 0x6f, 0x6f, 0x21, 0x22)
)
fparse(raw_json)

# ensuring a list is always returned ========================================
fparse(json_string, always_list = TRUE)
fparse(c(named_single_element_character = json_string), always_list = TRUE)

# controlling type-strictness ===============================================
fparse(json_string, type_policy = "numbers")
fparse(json_string, type_policy = "strict")
fparse(json_string, type_policy = "numbers", int64_policy = "string")

if (requireNamespace("bit64", quietly = TRUE)) {
    fparse(json_string, type_policy = "numbers", int64_policy = "integer64")
}

# vectorized parsing ========================================================
json_strings &lt;- c(
    json1 = '[{"b":true,
               "c":null},
              {"b":[[1,2,3],
                    [4,5,6]],
               "c":"Q"}]',
    json2 = '[{"b":[[7, 8, 9],
                   [10,11,12]],
              "c":"Q"},
              {"b":[[13,14,15],
                   [16,17,18]],
              "c":null}]'
)
fparse(json_strings)

fparse(
    list(
        raw_json1 = as.raw(c(0x74, 0x72, 0x75, 0x65)),
        raw_json2 = as.raw(c(0x66, 0x61, 0x6c, 0x73, 0x65))
    )
)

# controlling simplification ================================================
fparse(json_strings, max_simplify_lvl = "matrix")
fparse(json_strings, max_simplify_lvl = "vector")
fparse(json_strings, max_simplify_lvl = "list")

# customizing what `[]`, `{}`, and single `null`s return ====================
empties &lt;- "[[],{},null]"
fparse(empties)
fparse(empties,
       empty_array = logical(),
       empty_object = `names&lt;-`(list(), character()),
       single_null = NA_real_)

# handling invalid JSON and parsing errors ==================================
fparse("junk JSON", parse_error_ok = TRUE)
fparse("junk JSON", parse_error_ok = TRUE,
       on_parse_error = "can't parse invalid JSON")
fparse(
    c(junk_JSON_1 = "junk JSON 1",
      valid_JSON_1 = '"this is valid JSON"',
      junk_JSON_2 = "junk JSON 2",
      valid_JSON_2 = '"this is also valid JSON"'),
    parse_error_ok = TRUE,
    on_parse_error = NA
)

# querying JSON w/ a JSON Pointer ===========================================
json_to_query &lt;- c(
    json1 = '[
    "a",
    {
        "b": {
            "c": [[1,2,3],
                  [4,5,6]]
        }
    }
]',
    json2 = '[
    "a",
    {
        "b": {
            "c": [[7,8,9],
                  [10,11,12]],
           "d": [1,2,3,4]
        }
    }
]')
fparse(json_to_query, query = "/1")
fparse(json_to_query, query = "/1/b")
fparse(json_to_query, query = "/1/b/c")
fparse(json_to_query, query = "/1/b/c/1")
fparse(json_to_query, query = "/1/b/c/1/0")

# handling invalid queries ==================================================
fparse(json_to_query, query = "/1/b/d",
       query_error_ok = TRUE,
       on_query_error = "d isn't a key here!")

# multiple queries applied to EVERY element =================================
fparse(json_to_query, query = c(query1 = "/1/b/c/1/0",
                                query2 = "/1/b/c/1/1",
                                query3 = "/1/b/c/1/2"))

# multiple queries applied to EACH element ==================================
fparse(json_to_query,
       query = list(queries_for_json1 = c(c1 = "/1/b/c/1/0",
                                          c2 = "/1/b/c/1/1"),
                    queries_for_json2 = c(d1 = "/1/b/d/1",
                                          d2 = "/1/b/d/2")))

# load JSON files ===========================================================
single_file &lt;- system.file("jsonexamples/small/demo.json", package = "RcppSimdJson")
fload(single_file)

multiple_files &lt;- c(
  single_file,
  system.file("jsonexamples/small/smalldemo.json", package = "RcppSimdJson")
)
fload(multiple_files)


## Not run: 

# load remote JSON ==========================================================
a_url &lt;- "https://api.github.com/users/lemire"
fload(a_url)

multiple_urls &lt;- c(
  a_url,
  "https://api.github.com/users/eddelbuettel",
  "https://api.github.com/users/knapply",
  "https://api.github.com/users/dcooley"
)
fload(multiple_urls, query = "name", verbose = TRUE)

# download compressed (faster) JSON =========================================
fload(multiple_urls, query = "name", verbose = TRUE,
      compressed_download = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='is_valid_json'>simdjson Utilities</h2><span id='topic+is_valid_json'></span><span id='topic+is_valid_utf8'></span><span id='topic+fminify'></span><span id='topic+simdjson-utilities'></span>

<h3>Description</h3>

<p>simdjson Utilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_json(json)

is_valid_utf8(x)

fminify(json)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_valid_json_+3A_json">json</code></td>
<td>
<p>JSON string(s), or raw vectors representing JSON string(s)</p>
</td></tr>
<tr><td><code id="is_valid_json_+3A_x">x</code></td>
<td>
<p>String(s), or raw vectors representing string(s).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prettified_json &lt;-
    '[
    {
        "b": true,
        "c": null
    },
    {
        "b": [
            [
                1,
                2,
                3
            ],
            [
                4,
                5,
                6
            ]
        ],
        "c": "Q"
    }
]'

example_text &lt;- list(
    valid_json = c(json1 = prettified_json,
                   json2 = '{\n\t"good_json":true\n}'),
    invalid_json = c(bad_json1 = "BAD JSON",
                     bad_json2 = `Encoding&lt;-`('"fa\xE7ile"', "latin1")),
    mixed_json = c(na = NA_character_, good_json = '{"good_json":true}',
                   bad_json =  `Encoding&lt;-`('"fa\xE7ile"', "latin1")),
    good_raw_json = charToRaw('{\n\t"good_json":true\n}'),
    bad_raw_json = charToRaw("JUNK"),
    list_of_raw_json = lapply(
        c(na = NA_character_, good_json = '{"good_json":true}',
          bad_json =  `Encoding&lt;-`('"fa\xE7ile"', "latin1")),
        charToRaw
    ),
    not_utf8 = `Encoding&lt;-`('"fa\xE7ile"', "latin1")
)

# UTF-8 validation ==========================================================
example_text$valid_json
is_valid_utf8(example_text$valid_json)

example_text$invalid_json
is_valid_utf8(example_text$invalid_json)

example_text$mixed_json
is_valid_utf8(example_text$mixed_json)

example_text$good_raw_json
is_valid_utf8(example_text$good_raw_json)

example_text$bad_raw_json
is_valid_utf8(example_text$bad_raw_json)

example_text$list_of_raw_json
is_valid_utf8(example_text$list_of_raw_json)

example_text$not_utf8
is_valid_utf8(example_text$not_utf8)
is_valid_utf8(iconv(example_text$not_utf8, from = "latin1", to = "UTF-8"))

# JSON validation ===========================================================
cat(example_text$valid_json[[1L]])
cat(example_text$valid_json[[2L]])
is_valid_json(example_text$valid_json)

example_text$invalid_json
is_valid_json(example_text$invalid_json)

example_text$mixed_json
is_valid_json(example_text$mixed_json)

example_text$good_raw_json
cat(rawToChar(example_text$good_raw_json))
is_valid_json(example_text$good_raw_json)

example_text$bad_raw_json
rawToChar(example_text$bad_raw_json)
is_valid_json(example_text$bad_raw_json)

example_text$list_of_raw_json
lapply(example_text$list_of_raw_json, rawToChar)
is_valid_json(example_text$list_of_raw_json)

example_text$not_utf8
Encoding(example_text$not_utf8)
is_valid_json(example_text$not_utf8)
is_valid_json(iconv(example_text$not_utf8, from = "latin1", to = "UTF-8"))

# JSON minification =========================================================
cat(example_text$valid_json[[1L]])
cat(example_text$valid_json[[2L]])
fminify(example_text$valid_json)

example_text$invalid_json
fminify(example_text$invalid_json)

example_text$mixed_json
fminify(example_text$mixed_json)

example_text$good_raw_json
cat(rawToChar(example_text$good_raw_json))
fminify(example_text$good_raw_json)

example_text$bad_raw_json
rawToChar(example_text$bad_raw_json)
fminify(example_text$bad_raw_json)

example_text$list_of_raw_json
lapply(example_text$list_of_raw_json, rawToChar)
fminify(example_text$list_of_raw_json)

example_text$not_utf8
Encoding(example_text$not_utf8)
fminify(example_text$not_utf8)
fminify(iconv(example_text$not_utf8, from = "latin1", to = "UTF-8"))
</code></pre>

<hr>
<h2 id='parseExample'>Simple JSON Parsing Example</h2><span id='topic+parseExample'></span>

<h3>Description</h3>

<p>This example is adapted from a blogpost announcing an earlier &lsquo;simdjson&rsquo;
release. It is of interest mostly for the elegance and conciseness of its C++
code rather than for any functionality exported to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseExample()
</code></pre>


<h3>Details</h3>

<p>The function takes no argument and returns nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parseExample()
</code></pre>

<hr>
<h2 id='validateJSON'>Validate a JSON file, fast</h2><span id='topic+validateJSON'></span>

<h3>Description</h3>

<p>By relying on simd-parallel 'simdjson' header-only library JSON
files can be parsed very quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateJSON(jsonfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateJSON_+3A_jsonfile">jsonfile</code></td>
<td>
<p>A character variable with a path and filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value indicating whether the JSON content was
parsed successfully
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!RcppSimdJson:::.unsupportedArchitecture()) {
    jsonfile &lt;- system.file("jsonexamples", "twitter.json", package="RcppSimdJson")
    validateJSON(jsonfile)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
