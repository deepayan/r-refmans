<!DOCTYPE html><html lang="en"><head><title>Help for package mldr.resampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mldr.resampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustedHammingDist'><p>Auxiliary function used by MLeNN. Computes the Hamming Distance between two instances</p></a></li>
<li><a href='#calculateDistances'><p>Auxiliary function used to calculate the distances between an instance and the ones with a specific active label. Euclidean distance is calculated for numeric attributes, and VDM for non numeric ones.</p></a></li>
<li><a href='#calculateTableVDM'><p>Auxiliary function used to calculate an auxiliary table to make VDM calculation faster</p></a></li>
<li><a href='#executeAlgorithm'><p>Auxiliary function used by resample. It executes an algorithm, given as a string, and stores the resulting MLD in a arff file</p></a></li>
<li><a href='#generateInstanceMLSOL'><p>Auxiliary function used by MLSOL. Creates a synthetic sample based on two other samples, taking into account their types</p></a></li>
<li><a href='#getAllNeighbors'><p>Auxiliary function used by MLSOL and MLUL. Computes the kNN of every instance in a dataset</p></a></li>
<li><a href='#getAllNeighbors2'><p>Auxiliary function used by MLeNN and MLTL. Gets the kNN of every instance in a dataset, when compared to some of the rest</p></a></li>
<li><a href='#getAllReverseNeighbors'><p>Auxiliary function used by MLUL. For each instance in the dataset, given the neighbors structure, we compute its reverse nearest neighbors</p></a></li>
<li><a href='#getC'><p>Auxiliary function used by MLSOL and MLUL. For each instance in the dataset, we compute, for each label, the proportion of neighbors having an opposite class with respect to the proper instance</p></a></li>
<li><a href='#getNN'><p>Auxiliary function used to compute the neighbors of an instance</p></a></li>
<li><a href='#getNumCores'><p>Get the number of cores available for parallel computing</p></a></li>
<li><a href='#getS'><p>Auxiliary function used by MLSOL and MLUL. For non outlier instances, it aggregates the values of C, taking into account the global class imbalance</p></a></li>
<li><a href='#getU'><p>Auxiliary function used by MLUL. It computes the influence of each instance with respect to its reverse neighbors</p></a></li>
<li><a href='#getV'><p>Auxiliary function used by MLUL. It calculates, for each instance, how important it is in the dataset</p></a></li>
<li><a href='#getW'><p>Auxiliary function used by MLSOL and MLUL. For non outlier instances, it aggregates the values of S for each label</p></a></li>
<li><a href='#initTypes'><p>Auxiliary function used by MLSOL. Categorizes each pair instance-label of the dataset with a type</p></a></li>
<li><a href='#LPROS'><p>Randomly clones instances with minoritary labelsets</p></a></li>
<li><a href='#LPRUS'><p>Randomly deletes instances with majoritary labelsets</p></a></li>
<li><a href='#MLeNN'><p>Multilabel edited Nearest Neighbor (MLeNN)</p></a></li>
<li><a href='#MLRkNNOS'><p>Reverse-nearest neighborhood based oversampling for imbalanced, multi-label datasets</p></a></li>
<li><a href='#MLROS'><p>Randomly clones instances with minoritary labels</p></a></li>
<li><a href='#MLRUS'><p>Randomly deletes instances with majoritary labels</p></a></li>
<li><a href='#MLSMOTE'><p>Synthetic oversampling of multilabel instances (MLSMOTE)</p></a></li>
<li><a href='#MLSOL'><p>Multi-label oversampling based on local label imbalance (MLSOL)</p></a></li>
<li><a href='#MLTL'><p>Multilabel approach for the Tomek Link undersampling algorithm (MLTL)</p></a></li>
<li><a href='#MLUL'><p>Multi-label undersampling based on local label imbalance (MLUL)</p></a></li>
<li><a href='#newSample'><p>Auxiliary function used by MLSMOTE. Creates a synthetic sample based on values of attributes and labels of its neighbors</p></a></li>
<li><a href='#REMEDIAL'><p>Decouples highly imbalanced labels</p></a></li>
<li><a href='#resample'><p>Interface function of the package. It executes one or several algorithms, given as strings, and stores the resulting MLDs in arff files</p></a></li>
<li><a href='#setNumCores'><p>Set the number of cores available for parallel computing</p></a></li>
<li><a href='#setParallel'><p>Enable/Disable parallel computing</p></a></li>
<li><a href='#vdm'><p>Auxiliary function used to calculate the Value Difference Metric (VDM) between two instances considering their non numeric attributes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Resampling Algorithms for Multi-Label Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of the state of the art multi-label resampling algorithms. The objective of these algorithms is to achieve balance in multi-label datasets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, e1071, mldr, pbapply, vecsets</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 09:28:44 UTC; mdavila</td>
</tr>
<tr>
<td>Author:</td>
<td>Miguel Ángel Dávila [cre],
  Francisco Charte <a href="https://orcid.org/0000-0002-3083-8942"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  María José Del Jesus
    <a href="https://orcid.org/0000-0002-7891-3059"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Antonio Rivera <a href="https://orcid.org/0000-0002-1062-3127"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miguel Ángel Dávila &lt;madr0008@red.ujaen.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustedHammingDist'>Auxiliary function used by MLeNN. Computes the Hamming Distance between two instances</h2><span id='topic+adjustedHammingDist'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLeNN. Computes the Hamming Distance between two instances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustedHammingDist(x, y, D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustedHammingDist_+3A_x">x</code></td>
<td>
<p>Index of sample 1</p>
</td></tr>
<tr><td><code id="adjustedHammingDist_+3A_y">y</code></td>
<td>
<p>Index of sample 2</p>
</td></tr>
<tr><td><code id="adjustedHammingDist_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object in which the instances are located</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hamming Distance between the instances
</p>

<hr>
<h2 id='calculateDistances'>Auxiliary function used to calculate the distances between an instance and the ones with a specific active label. Euclidean distance is calculated for numeric attributes, and VDM for non numeric ones.</h2><span id='topic+calculateDistances'></span>

<h3>Description</h3>

<p>Auxiliary function used to calculate the distances between an instance and the ones with a specific active label. Euclidean distance is calculated for numeric attributes, and VDM for non numeric ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateDistances(sample, rest, label, D, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateDistances_+3A_sample">sample</code></td>
<td>
<p>Index of the sample whose distances to other samples we want to know</p>
</td></tr>
<tr><td><code id="calculateDistances_+3A_rest">rest</code></td>
<td>
<p>Indexes of the samples to which we will calculate the distance</p>
</td></tr>
<tr><td><code id="calculateDistances_+3A_label">label</code></td>
<td>
<p>Label that must be active</p>
</td></tr>
<tr><td><code id="calculateDistances_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="calculateDistances_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the distance to the rest of samples
</p>

<hr>
<h2 id='calculateTableVDM'>Auxiliary function used to calculate an auxiliary table to make VDM calculation faster</h2><span id='topic+calculateTableVDM'></span>

<h3>Description</h3>

<p>Auxiliary function used to calculate an auxiliary table to make VDM calculation faster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateTableVDM(D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateTableVDM_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with tables, useful for VDM calculation
</p>

<hr>
<h2 id='executeAlgorithm'>Auxiliary function used by resample. It executes an algorithm, given as a string, and stores the resulting MLD in a arff file</h2><span id='topic+executeAlgorithm'></span>

<h3>Description</h3>

<p>Auxiliary function used by resample. It executes an algorithm, given as a string, and stores the resulting MLD in a arff file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>executeAlgorithm(
  D,
  a,
  P,
  k,
  TH,
  strategy,
  outputDirectory,
  neighbors,
  neighbors2,
  tableVDM
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="executeAlgorithm_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_a">a</code></td>
<td>
<p>String with the name of the algorithm to be applied.</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased/decreased (if required by the algorithm)</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_k">k</code></td>
<td>
<p>Number of neighbors taken into account for each instance (if required by the algorithm)</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_th">TH</code></td>
<td>
<p>Threshold for the Hamming Distance in order to consider an instance different to another one (if required by the algorithm)</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_strategy">strategy</code></td>
<td>
<p>Strategy for choosing the synthetic labels (if required by the algorithm). Possible values: &quot;union&quot;, &quot;intersection&quot; and &quot;ranking&quot; (default)</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_outputdirectory">outputDirectory</code></td>
<td>
<p>Route with the directory where the generated ARFF file will be stored</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with all instances and neighbors in the dataset, useful in MLSOL and MLUL</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_neighbors2">neighbors2</code></td>
<td>
<p>Structure with some instances and neighbors in the dataset, useful in MLeNN and MLTL</p>
</td></tr>
<tr><td><code id="executeAlgorithm_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time (in seconds) taken to execute the algorithm (NULL if no algorithm was executed)
</p>

<hr>
<h2 id='generateInstanceMLSOL'>Auxiliary function used by MLSOL. Creates a synthetic sample based on two other samples, taking into account their types</h2><span id='topic+generateInstanceMLSOL'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSOL. Creates a synthetic sample based on two other samples, taking into account their types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateInstanceMLSOL(seedInstance, refNeigh, t, D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateInstanceMLSOL_+3A_seedinstance">seedInstance</code></td>
<td>
<p>Index of the sample we are using as &quot;template&quot;</p>
</td></tr>
<tr><td><code id="generateInstanceMLSOL_+3A_refneigh">refNeigh</code></td>
<td>
<p>Index of the reference neighbor</p>
</td></tr>
<tr><td><code id="generateInstanceMLSOL_+3A_t">t</code></td>
<td>
<p>types of the instances</p>
</td></tr>
<tr><td><code id="generateInstanceMLSOL_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A synthetic sample derived from the one passed as a parameter and its neighbors
</p>

<hr>
<h2 id='getAllNeighbors'>Auxiliary function used by MLSOL and MLUL. Computes the kNN of every instance in a dataset</h2><span id='topic+getAllNeighbors'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSOL and MLUL. Computes the kNN of every instance in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllNeighbors(D, d, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAllNeighbors_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="getAllNeighbors_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which have one or more label active (ideally, all of them)</p>
</td></tr>
<tr><td><code id="getAllNeighbors_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors with the indexes of the neighbors for each instance
</p>

<hr>
<h2 id='getAllNeighbors2'>Auxiliary function used by MLeNN and MLTL. Gets the kNN of every instance in a dataset, when compared to some of the rest</h2><span id='topic+getAllNeighbors2'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLeNN and MLTL. Gets the kNN of every instance in a dataset, when compared to some of the rest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllNeighbors2(neighbors, d, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAllNeighbors2_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with all the neighbors in the dataset, regardless of which ones to be compared</p>
</td></tr>
<tr><td><code id="getAllNeighbors2_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which are going to be compared</p>
</td></tr>
<tr><td><code id="getAllNeighbors2_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be retrieved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors with the indexes of the neighbors for each instance
</p>

<hr>
<h2 id='getAllReverseNeighbors'>Auxiliary function used by MLUL. For each instance in the dataset, given the neighbors structure, we compute its reverse nearest neighbors</h2><span id='topic+getAllReverseNeighbors'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLUL. For each instance in the dataset, given the neighbors structure, we compute its reverse nearest neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllReverseNeighbors(d, neighbors, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAllReverseNeighbors_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which have one or more label active (ideally, all of them)</p>
</td></tr>
<tr><td><code id="getAllReverseNeighbors_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with the neighbors of every instance in the dataset</p>
</td></tr>
<tr><td><code id="getAllReverseNeighbors_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors with the indexes of the reverse nearest neighbors of every instance in the dataset
</p>

<hr>
<h2 id='getC'>Auxiliary function used by MLSOL and MLUL. For each instance in the dataset, we compute, for each label, the proportion of neighbors having an opposite class with respect to the proper instance</h2><span id='topic+getC'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSOL and MLUL. For each instance in the dataset, we compute, for each label, the proportion of neighbors having an opposite class with respect to the proper instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getC(D, d, neighbors, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getC_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="getC_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which have one or more label active (ideally, all of them)</p>
</td></tr>
<tr><td><code id="getC_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with the neighbors of every instance in the dataset</p>
</td></tr>
<tr><td><code id="getC_+3A_k">k</code></td>
<td>
<p>Number of neighbors taken into account for each instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure with the proportion of neighbors having an opposite class with respect to an instance and label
</p>

<hr>
<h2 id='getNN'>Auxiliary function used to compute the neighbors of an instance</h2><span id='topic+getNN'></span>

<h3>Description</h3>

<p>Auxiliary function used to compute the neighbors of an instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNN(sample, rest, label, D, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNN_+3A_sample">sample</code></td>
<td>
<p>Index of the sample whose neighbors we want to know</p>
</td></tr>
<tr><td><code id="getNN_+3A_rest">rest</code></td>
<td>
<p>Indexes of the samples among which we will search</p>
</td></tr>
<tr><td><code id="getNN_+3A_label">label</code></td>
<td>
<p>Label that must be active, in order to calculate the distances</p>
</td></tr>
<tr><td><code id="getNN_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="getNN_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the indexes inside rest of the neighbors
</p>

<hr>
<h2 id='getNumCores'>Get the number of cores available for parallel computing</h2><span id='topic+getNumCores'></span>

<h3>Description</h3>

<p>Get the number of cores available for parallel computing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumCores()
</code></pre>


<h3>Value</h3>

<p>The number of cores available for parallel computing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getNumCores()

</code></pre>

<hr>
<h2 id='getS'>Auxiliary function used by MLSOL and MLUL. For non outlier instances, it aggregates the values of C, taking into account the global class imbalance</h2><span id='topic+getS'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSOL and MLUL. For non outlier instances, it aggregates the values of C, taking into account the global class imbalance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getS(D, d, C, minoritary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getS_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="getS_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which have one or more label active (ideally, all of them)</p>
</td></tr>
<tr><td><code id="getS_+3A_c">C</code></td>
<td>
<p>Structure with the proportion of neighbors having an opposite class with respect to an instance and label</p>
</td></tr>
<tr><td><code id="getS_+3A_minoritary">minoritary</code></td>
<td>
<p>Vector with the minoritary class of each label (normally, 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure with the proportion of neighbors having an opposite class with respect to an instance and label, normalized by the global class imbalance
</p>

<hr>
<h2 id='getU'>Auxiliary function used by MLUL. It computes the influence of each instance with respect to its reverse neighbors</h2><span id='topic+getU'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLUL. It computes the influence of each instance with respect to its reverse neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getU(D, d, rNeighbors, S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getU_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="getU_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which have one or more label active (ideally, all of them)</p>
</td></tr>
<tr><td><code id="getU_+3A_rneighbors">rNeighbors</code></td>
<td>
<p>Structure with the reverse nearest neighbors of each instance of the dataset</p>
</td></tr>
<tr><td><code id="getU_+3A_s">S</code></td>
<td>
<p>Structure with the proportion of neighbors having an opposite class with respect to an instance and label, normalized by the global class imbalance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values of influence for each instance with respect to its reverse neighbors
</p>

<hr>
<h2 id='getV'>Auxiliary function used by MLUL. It calculates, for each instance, how important it is in the dataset</h2><span id='topic+getV'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLUL. It calculates, for each instance, how important it is in the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getV(w, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getV_+3A_w">w</code></td>
<td>
<p>List of weights for each instance</p>
</td></tr>
<tr><td><code id="getV_+3A_u">u</code></td>
<td>
<p>List of influences in reverse neighbors for each instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values of importance of each instance in the dataset
</p>

<hr>
<h2 id='getW'>Auxiliary function used by MLSOL and MLUL. For non outlier instances, it aggregates the values of S for each label</h2><span id='topic+getW'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSOL and MLUL. For non outlier instances, it aggregates the values of S for each label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getW(S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getW_+3A_s">S</code></td>
<td>
<p>Structure with the proportion of neighbors having an opposite class with respect to an instance and label, normalized by the global class imbalance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of weights to be considered when oversampling for each instance
</p>

<hr>
<h2 id='initTypes'>Auxiliary function used by MLSOL. Categorizes each pair instance-label of the dataset with a type</h2><span id='topic+initTypes'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSOL. Categorizes each pair instance-label of the dataset with a type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initTypes(C, neighbors, k, minoritary, D, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initTypes_+3A_c">C</code></td>
<td>
<p>List of vectors with one value for each pair instance-label</p>
</td></tr>
<tr><td><code id="initTypes_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with the k nearest neighbors of each instance of the dataset</p>
</td></tr>
<tr><td><code id="initTypes_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be considered for each instance</p>
</td></tr>
<tr><td><code id="initTypes_+3A_minoritary">minoritary</code></td>
<td>
<p>Vector with the minoritary value of each label (normally, 1)</p>
</td></tr>
<tr><td><code id="initTypes_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="initTypes_+3A_d">d</code></td>
<td>
<p>Vector with the instances of the dataset which have one or more label active (ideally, all of them)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A synthetic sample derived from the one passed as a parameter and its neighbors
</p>

<hr>
<h2 id='LPROS'>Randomly clones instances with minoritary labelsets</h2><span id='topic+LPROS'></span>

<h3>Description</h3>

<p>This function implements the LP-ROS algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to identify instances with minoritary labels, and randomly clone them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPROS(D, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LPROS_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="LPROS_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Charte, F., Rivera, A. J., del Jesus, M. J., &amp; Herrera, F. (2015). Addressing imbalance in multilabel classification: Measures and random resampling algorithms. Neurocomputing, 163, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mldr)
LPROS(birds, 25)

</code></pre>

<hr>
<h2 id='LPRUS'>Randomly deletes instances with majoritary labelsets</h2><span id='topic+LPRUS'></span>

<h3>Description</h3>

<p>This function implements the LP-RUS algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to identify instances with majoritary labelsets, and randomly delete them from the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPRUS(D, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LPRUS_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="LPRUS_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Charte, F., Rivera, A. J., del Jesus, M. J., &amp; Herrera, F. (2015). Addressing imbalance in multilabel classification: Measures and random resampling algorithms. Neurocomputing, 163, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mldr)
LPRUS(birds, 25)

</code></pre>

<hr>
<h2 id='MLeNN'>Multilabel edited Nearest Neighbor (MLeNN)</h2><span id='topic+MLeNN'></span>

<h3>Description</h3>

<p>This function implements the MLeNN algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to identify instances with majoritary labels, and remove its neihgbors which are too different to them, in terms of active labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLeNN(D, TH = 0.5, k = 3, neighbors = NULL, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLeNN_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLeNN_+3A_th">TH</code></td>
<td>
<p>threshold for the Hamming Distance in order to consider an instance different to another one. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="MLeNN_+3A_k">k</code></td>
<td>
<p>number of nearest neighbours to check for each instance. Defaults to 3.</p>
</td></tr>
<tr><td><code id="MLeNN_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with instances and neighbors. If it is empty, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="MLeNN_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mldr object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Francisco Charte, Antonio J. Rivera, María J. del Jesus, and Francisco Herrera. MLeNN: A First Approach to Heuristic Multilabel Undersampling. Intelligent Data Engineering and Automated Learning &ndash; IDEAL 2014. ISBN 978-3-319-10840-7.
</p>

<hr>
<h2 id='MLRkNNOS'>Reverse-nearest neighborhood based oversampling for imbalanced, multi-label datasets</h2><span id='topic+MLRkNNOS'></span>

<h3>Description</h3>

<p>This function implements an algorithm that uses the concept of reverse nearest neighbors, in order to create new instances for each label. Then, several radial SVMs, one for each label, are trained in order to predict each label of the synthetic instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLRkNNOS(D, k, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLRkNNOS_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLRkNNOS_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be considered when creating a synthetic instance</p>
</td></tr>
<tr><td><code id="MLRkNNOS_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Sadhukhan, P., &amp; Palit, S. (2019). Reverse-nearest neighborhood based oversampling for imbalanced, multi-label datasets. Pattern Recognition Letters, 125, 813-820
</p>

<hr>
<h2 id='MLROS'>Randomly clones instances with minoritary labels</h2><span id='topic+MLROS'></span>

<h3>Description</h3>

<p>This function implements the ML-ROS algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to identify instances with minoritary labels, and randomly clone them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLROS(D, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLROS_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLROS_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Charte, F., Rivera, A. J., del Jesus, M. J., &amp; Herrera, F. (2015). Addressing imbalance in multilabel classification: Measures and random resampling algorithms. Neurocomputing, 163, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mldr)
library(mldr.resampling)
MLROS(birds, 25)

</code></pre>

<hr>
<h2 id='MLRUS'>Randomly deletes instances with majoritary labels</h2><span id='topic+MLRUS'></span>

<h3>Description</h3>

<p>This function implements the ML-RUS algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to identify instances with majoritary labels, and randomly delete them from the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLRUS(D, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLRUS_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLRUS_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Charte, F., Rivera, A. J., del Jesus, M. J., &amp; Herrera, F. (2015). Addressing imbalance in multilabel classification: Measures and random resampling algorithms. Neurocomputing, 163, 3-16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mldr)
MLRUS(birds, 25)

</code></pre>

<hr>
<h2 id='MLSMOTE'>Synthetic oversampling of multilabel instances (MLSMOTE)</h2><span id='topic+MLSMOTE'></span>

<h3>Description</h3>

<p>This function implements the MLSMOTE algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to identify instances with minoritary labels, and generate synthetic instances based on their neighbor instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLSMOTE(D, k, strategy = "ranking", tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLSMOTE_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLSMOTE_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be considered when creating a synthetic instance</p>
</td></tr>
<tr><td><code id="MLSMOTE_+3A_strategy">strategy</code></td>
<td>
<p>Strategy for choosing the synthetic labels. Possible values: &quot;union&quot;, &quot;intersection&quot; and &quot;ranking&quot; (default)</p>
</td></tr>
<tr><td><code id="MLSMOTE_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Charte, F., Rivera, A. J., del Jesus, M. J., &amp; Herrera, F. (2015). MLSMOTE: Approaching imbalanced multilabel learning through synthetic instance generation. Knowledge-Based Systems, 89, 385-397.
</p>

<hr>
<h2 id='MLSOL'>Multi-label oversampling based on local label imbalance (MLSOL)</h2><span id='topic+MLSOL'></span>

<h3>Description</h3>

<p>This function implements the MLSOL algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets, which applies oversampling on difficult regions of the instance space, in order to help classifiers distinguish labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLSOL(D, P, k, neighbors = NULL, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLSOL_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLSOL_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased</p>
</td></tr>
<tr><td><code id="MLSOL_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be considered when computing the neighbors of an instance</p>
</td></tr>
<tr><td><code id="MLSOL_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with all instances and neighbors in the dataset. If it is empty, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="MLSOL_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Liu, B., Blekas, K., &amp; Tsoumakas, G. (2022). Multi-label sampling based on local label imbalance. Pattern Recognition, 122, 108294.
</p>

<hr>
<h2 id='MLTL'>Multilabel approach for the Tomek Link undersampling algorithm (MLTL)</h2><span id='topic+MLTL'></span>

<h3>Description</h3>

<p>This function implements the MLTL algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets, whose aim is to identify
tomek links (majoritary instances with a very different neighbor), and remove them. It's like MLeNN, with the number of neighbors being 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLTL(D, TH, neighbors = NULL, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLTL_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLTL_+3A_th">TH</code></td>
<td>
<p>threshold for the Hamming Distance in order to consider an instance different to another one.</p>
</td></tr>
<tr><td><code id="MLTL_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with instances and neighbors. If it is empty, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="MLTL_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mldr object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Pereira, R. M., Costa, Y. M., &amp; Silla Jr, C. N. (2020). MLTL: A multi-label approach for the Tomek Link undersampling algorithm. Neurocomputing, 383, 95-105.
</p>

<hr>
<h2 id='MLUL'>Multi-label undersampling based on local label imbalance (MLUL)</h2><span id='topic+MLUL'></span>

<h3>Description</h3>

<p>This function implements the MLUL algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets, which applies undersampling, removing difficult instances according to their neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLUL(D, P, k, neighbors = NULL, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLUL_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="MLUL_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is decreased</p>
</td></tr>
<tr><td><code id="MLUL_+3A_k">k</code></td>
<td>
<p>Number of neighbors to be considered when computing the neighbors of an instance</p>
</td></tr>
<tr><td><code id="MLUL_+3A_neighbors">neighbors</code></td>
<td>
<p>Structure with all instances and neighbors in the dataset. If it is empty, it will be calculated by the function</p>
</td></tr>
<tr><td><code id="MLUL_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mld object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>Liu, B., Blekas, K., &amp; Tsoumakas, G. (2022). Multi-label sampling based on local label imbalance. Pattern Recognition, 122, 108294.
</p>

<hr>
<h2 id='newSample'>Auxiliary function used by MLSMOTE. Creates a synthetic sample based on values of attributes and labels of its neighbors</h2><span id='topic+newSample'></span>

<h3>Description</h3>

<p>Auxiliary function used by MLSMOTE. Creates a synthetic sample based on values of attributes and labels of its neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newSample(seedInstance, refNeigh, neighbors, strategy, D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newSample_+3A_seedinstance">seedInstance</code></td>
<td>
<p>Sample we are using as &quot;template&quot;</p>
</td></tr>
<tr><td><code id="newSample_+3A_refneigh">refNeigh</code></td>
<td>
<p>Reference neighbor</p>
</td></tr>
<tr><td><code id="newSample_+3A_neighbors">neighbors</code></td>
<td>
<p>Neighbors to take into account</p>
</td></tr>
<tr><td><code id="newSample_+3A_strategy">strategy</code></td>
<td>
<p>Strategy for choosing the synthetic labels: union, intersection or ranking</p>
</td></tr>
<tr><td><code id="newSample_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A synthetic sample derived from the one passed as a parameter and its neighbors
</p>

<hr>
<h2 id='REMEDIAL'>Decouples highly imbalanced labels</h2><span id='topic+REMEDIAL'></span>

<h3>Description</h3>

<p>This function implements the REMEDIAL algorithm. It is a preprocessing algorithm for imbalanced multilabel datasets,
whose aim is to decouple frequent and rare classes appearing in the same instance. For doing so, it aggregates new instances to the dataset
and edit the labels present in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REMEDIAL(mld)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REMEDIAL_+3A_mld">mld</code></td>
<td>
<p><code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mldr object containing the preprocessed multilabel dataset
</p>


<h3>Source</h3>

<p>F. Charte, A. J. Rivera, M. J. del Jesus, F. Herrera. &quot;Resampling Multilabel Datasets by Decoupling Highly Imbalanced Labels&quot;. Proc. 2015 International Conference on Hybrid Artificial Intelligent Systems (HAIS 2015), pp. 489-501, Bilbao, Spain, 2015. Implementation from the original <code>mldr</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mldr)
REMEDIAL(birds)
</code></pre>

<hr>
<h2 id='resample'>Interface function of the package. It executes one or several algorithms, given as strings, and stores the resulting MLDs in arff files</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Interface function of the package. It executes one or several algorithms, given as strings, and stores the resulting MLDs in arff files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(
  D,
  algorithms,
  P = 25,
  k = 3,
  TH = 0.5,
  strategy = "ranking",
  params,
  outputDirectory = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="resample_+3A_algorithms">algorithms</code></td>
<td>
<p>String, or string vector, with the name(s) of the algorithm(s) to be applied.</p>
</td></tr>
<tr><td><code id="resample_+3A_p">P</code></td>
<td>
<p>Percentage in which the original dataset is increased/decreased, if required by the algorithm(s). Defaults to 25</p>
</td></tr>
<tr><td><code id="resample_+3A_k">k</code></td>
<td>
<p>Number of neighbors taken into account for each instance, if required by the algorithm(s). Defaults to 3</p>
</td></tr>
<tr><td><code id="resample_+3A_th">TH</code></td>
<td>
<p>Threshold for the Hamming Distance in order to consider an instance different to another one, if required by the algorithm(s). Defaults to 0.5</p>
</td></tr>
<tr><td><code id="resample_+3A_strategy">strategy</code></td>
<td>
<p>Strategy for choosing the synthetic labels, if required by the algorithm. Defaults to ranking</p>
</td></tr>
<tr><td><code id="resample_+3A_params">params</code></td>
<td>
<p>Dataframe with 4 columns: name of the algorithm, P, k and TH, in that order, to execute several algorithms with different values for their parameters</p>
</td></tr>
<tr><td><code id="resample_+3A_outputdirectory">outputDirectory</code></td>
<td>
<p>Route with the directory where generated ARFF files will be stored. Defaults to a temporary directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with times (in seconds) taken in to execute each algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mldr)
library(mldr.resampling)
resample(birds, "LPROS", P=25)
resample(birds, c("LPROS", "LPRUS"), P=30)
</code></pre>

<hr>
<h2 id='setNumCores'>Set the number of cores available for parallel computing</h2><span id='topic+setNumCores'></span>

<h3>Description</h3>

<p>Set the number of cores available for parallel computing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setNumCores(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setNumCores_+3A_n">n</code></td>
<td>
<p>The new value for the number of cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called in order to change the number of cores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
setNumCores(8)

</code></pre>

<hr>
<h2 id='setParallel'>Enable/Disable parallel computing</h2><span id='topic+setParallel'></span>

<h3>Description</h3>

<p>Enable/Disable parallel computing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setParallel(beParallel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setParallel_+3A_beparallel">beParallel</code></td>
<td>
<p>A boolean indicating if parallel computing is to be enabled (TRUE) or disabled (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called in order to enable parallel computing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setParallel(TRUE)

</code></pre>

<hr>
<h2 id='vdm'>Auxiliary function used to calculate the Value Difference Metric (VDM) between two instances considering their non numeric attributes</h2><span id='topic+vdm'></span>

<h3>Description</h3>

<p>Auxiliary function used to calculate the Value Difference Metric (VDM) between two instances considering their non numeric attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdm(D, sample, y, label, tableVDM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vdm_+3A_d">D</code></td>
<td>
<p>mld <code>mldr</code> object with the multilabel dataset to preprocess</p>
</td></tr>
<tr><td><code id="vdm_+3A_sample">sample</code></td>
<td>
<p>Index of the first sample</p>
</td></tr>
<tr><td><code id="vdm_+3A_y">y</code></td>
<td>
<p>Index of the second sample</p>
</td></tr>
<tr><td><code id="vdm_+3A_label">label</code></td>
<td>
<p>Label that will be considered in calculations</p>
</td></tr>
<tr><td><code id="vdm_+3A_tablevdm">tableVDM</code></td>
<td>
<p>Dataframe object containing previous calculations for faster processing. If it is empty, the algorithm will be slower</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value for the distance
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
