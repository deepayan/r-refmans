<!DOCTYPE html><html><head><title>Help for package ordr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ordr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ordr'><p><strong>ordr</strong> package</p></a></li>
<li><a href='#annotation'><p>Annotate factors of 'tbl_ord' objects</p></a></li>
<li><a href='#augmentation'><p>Augment factors and coordinates of 'tbl_ord' objects</p></a></li>
<li><a href='#biplot-geoms'><p>Convenience geoms for row and column matrix factors</p></a></li>
<li><a href='#biplot-stats'><p>Convenience stats for row and column matrix factors</p></a></li>
<li><a href='#conference'><p>Confer inertia to factors of a 'tbl_ord' object</p></a></li>
<li><a href='#dplyr-verbs'><p><strong>dplyr</strong> verbs for tbl_ord factors</p></a></li>
<li><a href='#draw-key'><p>Biplot key drawing functions</p></a></li>
<li><a href='#format'><p>Format a tbl_ord for printing</p></a></li>
<li><a href='#geom_axis'><p>Axes through the origin</p></a></li>
<li><a href='#geom_isoline'><p>Isolines (contour lines)</p></a></li>
<li><a href='#geom_lineranges'><p>Intervals depicting ranges, usually about center points</p></a></li>
<li><a href='#geom_origin'><p>Crosshairs or circle at the origin</p></a></li>
<li><a href='#geom_text_radiate'><p>Text radiating outward from the origin</p></a></li>
<li><a href='#geom_unit_circle'><p>Unit circle</p></a></li>
<li><a href='#geom_vector'><p>Vectors from the origin</p></a></li>
<li><a href='#ggbiplot'><p>Biplots following the grammar of graphics</p></a></li>
<li><a href='#glass'><p>Glass composition data</p></a></li>
<li><a href='#lda-ord'><p>Augmented implementation of linear discriminant analysis</p></a></li>
<li><a href='#lra-ord'><p>Log-ratio analysis</p></a></li>
<li><a href='#methods-cancor'><p>Functionality for canonical correlations</p></a></li>
<li><a href='#methods-cmds'><p>Functionality for classical multidimensional scaling objects</p></a></li>
<li><a href='#methods-correspondence'><p>Functionality for correspondence analysis ('correspondence') objects</p></a></li>
<li><a href='#methods-eigen'><p>Functionality for eigen-decompositions</p></a></li>
<li><a href='#methods-factanal'><p>Functionality for factor analysis ('factanal') objects</p></a></li>
<li><a href='#methods-kmeans'><p>Functionality for k-means clustering ('kmeans') objects</p></a></li>
<li><a href='#methods-lda'><p>Functionality for linear discriminant analysis ('lda') objects</p></a></li>
<li><a href='#methods-lm'><p>Functionality for linear model objects</p></a></li>
<li><a href='#methods-lra'><p>Functionality for log-ratio analysis ('lra') objects</p></a></li>
<li><a href='#methods-mca'><p>Functionality for multiple correspondence analysis ('mca') objects</p></a></li>
<li><a href='#methods-prcomp'><p>Functionality for principal components analysis ('prcomp') objects</p></a></li>
<li><a href='#methods-princomp'><p>Functionality for principal components analysis ('princomp') objects</p></a></li>
<li><a href='#methods-svd'><p>Functionality for singular value decompositions</p></a></li>
<li><a href='#negation'><p>Negation of ordination axes</p></a></li>
<li><a href='#ordinate'><p>Fit an ordination model to a data object</p></a></li>
<li><a href='#ordr-ggproto'><p>ggproto classes created and adapted for ordr</p></a></li>
<li><a href='#plot.tbl_ord'><p>Plot and biplot methods for 'tbl_ord' objects</p></a></li>
<li><a href='#qswur_usa'><p>U.S. university rankings</p></a></li>
<li><a href='#recoverers'><p>Access factors, coordinates, and metadata from ordination objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#stat_center'><p>Compute geometric centers and spreads for ordination factors</p></a></li>
<li><a href='#stat_chull'><p>Restrict geometric data to boundary points for its convex hull</p></a></li>
<li><a href='#stat_cone'><p>Restrict geometric data to boundary points for its conical hull</p></a></li>
<li><a href='#stat_rows'><p>Render plot elements for one matrix of an ordination</p></a></li>
<li><a href='#stat_scale'><p>Multiply artificial coordinates by a scale factor</p></a></li>
<li><a href='#stat_spantree'><p>Calculate a minimum spanning tree among cases or variables</p></a></li>
<li><a href='#supplementation'><p>Supplement 'tbl_ord' objects with new data</p></a></li>
<li><a href='#tbl_ord'><p>A unified ordination object class</p></a></li>
<li><a href='#theme_biplot'><p>Biplot theme</p></a></li>
<li><a href='#tidiers'><p>Tidiers for 'tbl_ord' objects</p></a></li>
<li><a href='#wrap-ord'><p>Wrappers for lossy ordination methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A 'tidyverse' Extension for Ordinations and Biplots</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Ordination comprises several multivariate exploratory and
    explanatory techniques with theoretical foundations in geometric data
    analysis; see Podani (2000, ISBN:90-5782-067-6) for techniques and
    applications and Le Roux &amp; Rouanet (2005) &lt;<a href="https://doi.org/10.1007%2F1-4020-2236-0">doi:10.1007/1-4020-2236-0</a>&gt; for
    foundations.
    Greenacre (2010, ISBN:978-84-923846) shows how the most established of
    these, including principal components analysis, correspondence analysis,
    multidimensional scaling, factor analysis, and discriminant analysis,
    rely on eigen-decompositions or singular value decompositions of
    pre-processed numeric matrix data.
    These decompositions give rise to a set of shared coordinates along which
    the row and column elements can be measured. The overlay of their
    scatterplots on these axes, introduced by Gabriel (1971)
    &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F58.3.453">doi:10.1093/biomet/58.3.453</a>&gt;, is called a biplot.
    'ordr' provides inspection, extraction, manipulation, and visualization
    tools for several popular ordination classes supported by a set of recovery
    methods. It is inspired by and designed to integrate into 'tidyverse'
    workflows provided by Wickham et al (2019) &lt;<a href="https://doi.org/10.21105%2Fjoss.01686">doi:10.21105/joss.01686</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, stringr, tidyselect, scales, generics, magrittr,
tibble, tidyr, dplyr, purrr, labeling, ggrepel,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, sessioninfo, gridExtra, MASS, mlpack, vegan,
heplots, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/corybrunson/ordr">https://github.com/corybrunson/ordr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/corybrunson/ordr/issues">https://github.com/corybrunson/ordr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa-.r' 'biplot-key.r' 'biplot.r' 'data.r' 'dplyr-verbs.r'
'utils.r' 'ord-recoverers.r' 'ord-augmentation.r'
'ord-conference.r' 'ord-tbl.r' 'fun-lda.r' 'fun-lra.r'
'fun-wrap.r' 'geom-axis.r' 'geom-intervals.r' 'geom-isoline.r'
'geom-origin.r' 'geom-text-radiate.r' 'geom-unit-circle.r'
'geom-utils.r' 'geom-vector.r' 'methods-base-eigen.r'
'methods-base-svd.r' 'methods-mass-correspondence.r'
'methods-mass-lda.r' 'methods-mass-mca.r' 'methods-ordr-lra.r'
'methods-stats-cancor.r' 'methods-stats-cmds.r'
'methods-stats-factanal.r' 'methods-stats-kmeans.r'
'methods-stats-lm.r' 'methods-stats-prcomp.r'
'methods-stats-princomp.r' 'ord-annotation.r' 'ord-format.r'
'ord-negation.r' 'ord-plot.r' 'ord-supplementation.r'
'ord-tidiers.r' 'ordinate.r' 'ordr.r' 'stat-center.r'
'stat-chull.r' 'stat-cone.r' 'stat-matrix.r' 'stat-scale.r'
'stat-spantree.r' 'themes.r' 'zzz-biplot-geoms.r'
'zzz-biplot-stats.r' 'zzz.r'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-20 16:03:50 UTC; jason.brunson</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Cory Brunson
    <a href="https://orcid.org/0000-0003-3126-9494"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Emily Paul [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Cory Brunson &lt;cornelioid@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-20 20:52:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='ordr'><strong>ordr</strong> package</h2><span id='topic+ordr'></span><span id='topic+ordr-package'></span>

<h3>Description</h3>

<p>This is a <strong><a href="https://www.tidyverse.org/">tidyverse</a></strong> extension
for handling, manipulating, and visualizing ordination models with
consistent conventions and in a tidy workflow.
</p>


<h3>Details</h3>

<p>This package is designed to integrate ordination analysis and biplot
visualization into a <strong>tidyverse</strong> workflow. It is inspired in particular by
the extensions <strong>ggbiplot</strong> and <strong>tidygraph</strong>.
</p>
<p>The package consists in several modules:
</p>

<ul>
<li><p> the '<a href="#topic+tbl_ord">tbl_ord</a>' class, a wrapper for various ordination object classes
</p>
</li>
<li><p> extracting <a href="#topic+augmentation">augmentation</a> for the factors of an ordination
</p>
</li>
<li><p> using <a href="#topic+dplyr-verbs">dplyr-verbs</a> to add <a href="#topic+annotation">annotation</a> to the factors
</p>
</li>
<li><p> adjusting the <a href="#topic+conference">conference</a> of inertia between the factors
</p>
</li>
<li><p> methods of the above generics for several widely-used object classes
</p>
</li>
<li><p> convenient <a href="#topic+format">formatting</a> of ordination objects
</p>
</li>
<li> <p><code><a href="#topic+ggbiplot">ggbiplot()</a></code>, a <strong>ggplot2</strong> extension for rendering biplots
</p>
</li>
<li><p> additional <a href="#topic+biplot-stats">stats</a> and <a href="#topic+biplot-geoms">geoms</a> for biplots
</p>
</li></ul>



<h3>Ordinations and biplots</h3>

<p><em>Ordination</em> encompasses a variety of techniques for data compression,
dimension reduction, feature extraction, and visualization. Well-known
ordination techniques are predominantly unsupervised and include principal
components analysis, multidimensional scaling, and correspondence analyis
(Podani, 2000, Chapter 7; Palmer, n.d.). These methods are theoretically
grounded in geometric data analysis (Le Roux &amp; Rouanet, 2004) and powered by
the matrix factorizations described below. A variety of other techniques may
also be viewed, or treated using the same tools, as ordination, including
linear regression, linear discriminant analysis, k-means clustering, and
non-negative matrix factorization.
</p>
<p><em>Biplots</em> are two-layered scatterplots widely used to visualize unsupervised
SVD-based ordinations. Gabriel (1971) introduced biplots to represent the
scores and loadings of PCA on a single set of axes. They have also been used
to visualize generalized linear regression and linear discriminant analysis
(Greenacre, 2010) and can adapted to any 2-factor matrix decomposition.
</p>


<h3>Singular value decomposition</h3>

<p>The most popular ordination techniques use singular value decomposition (SVD)
to factor a data matrix <code class="reqn">X</code> into a product <code class="reqn">X=UDV'</code> of two orthogonal
(rotation) matrices <code class="reqn">U</code> and <code class="reqn">V</code> and a diagonal (scaling) matrix
<code class="reqn">D</code>, with <code class="reqn">V'</code> the transpose of <code class="reqn">V</code>. In most cases, the data
matrix <code class="reqn">X</code> is transformed from an original data matrix, e.g. by
centering, scaling, double-centering, or log-transforming. The SVD introduces
a set of shared orthogonal coordinates in which <code class="reqn">U</code> encodes the rows of
<code class="reqn">X</code> and <code class="reqn">V</code> encodes the columns of <code class="reqn">X</code>. The singular values in
<code class="reqn">D</code> are the variances of <code class="reqn">X</code> along each of these coordinates, and
they proceed in decreasing order, so that the first <code class="reqn">r</code> (for &quot;rank&quot;)
columns of <code class="reqn">U</code> and of <code class="reqn">V</code> produce a geometrically optimized
approximation to <code class="reqn">X</code>.
</p>
<p>Biplots of SVD-based ordinations usually plot the rows and columns of <code class="reqn">X</code>
on these <code class="reqn">r</code> coordinate axes. For an SVD-based biplot to be truly
geometric, the total variance contained in <code class="reqn">D</code> must be conferred onto
<code class="reqn">U</code> or <code class="reqn">V</code>, or distributed over both (Orlov, 2015). When <code class="reqn">D</code> is
conferred onto <code class="reqn">U</code>, the rows of <code class="reqn">X</code> are represented by the rows of
<code class="reqn">UD</code>, and their distances in the biplot approximate their distances in
the original column space of <code class="reqn">X</code>. Meanwhile, the columns of <code class="reqn">X</code> are
represented by the rows of <code class="reqn">V</code>. These are unit vectors in the full space
of shared coordinates, so their squared lengths in the biplot indicate the
proportion of their variance captured by the biplot axes and their cosines
with each other approximate the correlations between the columns. Finally,
the projection of a row's coordinates (point) onto a column's coordinates
(vector) approximates the corresponding entry of <code class="reqn">X</code>.
</p>


<h3>References</h3>

<p>Podani J (2000) &quot;Ordination&quot;. <em>Introduction to the Exploration of
Multivariate Biological Data</em> Chapter 7, 215&ndash;284. Backhuys Publishers, ISBN
90-5782-067-6.
<a href="https://web.archive.org/web/20200221000313/http://ramet.elte.hu/~podani/books.html">https://web.archive.org/web/20200221000313/http://ramet.elte.hu/~podani/books.html</a>
</p>
<p>Palmer M <em>Ordination Methods for Ecologists</em>. Website, accessed 2019-07-12.
<a href="http://ordination.okstate.edu/">http://ordination.okstate.edu/</a>
</p>
<p>Le Roux B &amp; Rouanet H (2004) <em>Geometric Data Analysis: From Correspondence
Analysis to Stsructured Data Analysis</em>. Springer Dordrecht, ISBN:
978-1-4020-2236-4. <a href="https://doi.org/10.1007/1-4020-2236-0">doi:10.1007/1-4020-2236-0</a>
<a href="https://link.springer.com/book/10.1007/1-4020-2236-0">https://link.springer.com/book/10.1007/1-4020-2236-0</a>
</p>
<p>Gabriel KR (1971) &quot;The biplot graphic display of matrices with application to
principal component analysis&quot;. <em>Biometrika</em> 58(3), 453&ndash;467.
<a href="https://doi.org/10.1093/biomet/58.3.453">doi:10.1093/biomet/58.3.453</a>
</p>
<p>Greenacre MJ (2010) <em>Biplots in Practice</em>. Fundacion BBVA, ISBN:
978-84-923846.
<a href="https://www.fbbva.es/microsite/multivariate-statistics/biplots.html">https://www.fbbva.es/microsite/multivariate-statistics/biplots.html</a>
</p>
<p>Orlov K (2015) <em>Answer to</em> &quot;PCA and Correspondence analysis in their relation
to Biplot&quot;. CrossValidated, accessed 2019-07-12.
<a href="https://stats.stackexchange.com/a/141755/68743">https://stats.stackexchange.com/a/141755/68743</a>
</p>

<hr>
<h2 id='annotation'>Annotate factors of 'tbl_ord' objects</h2><span id='topic+annotation'></span>

<h3>Description</h3>

<p>These functions annotate the matrix factors of <a href="#topic+tbl_ord">tbl_ord</a>s with
additional variables, and retrieve these annotations.
</p>
<p>The unexported <code style="white-space: pre;">&#8288;annotation_*()&#8288;</code> and <code style="white-space: pre;">&#8288;set_annotation_*()&#8288;</code> functions assign and
retrieve values of the <code>"*_annotation"</code> attributes of <code>x</code>, which must have
the same number of rows as <code>get_*(x)</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotation_+3A_annot">annot</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> having the same number of rows
as <code>get_*(x)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+augmentation">augmentation</a> methods that must interface with annotation.
</p>

<hr>
<h2 id='augmentation'>Augment factors and coordinates of 'tbl_ord' objects</h2><span id='topic+augmentation'></span><span id='topic+recover_aug_rows'></span><span id='topic+recover_aug_cols'></span><span id='topic+recover_aug_coord'></span><span id='topic+augment_ord'></span>

<h3>Description</h3>

<p>These functions return data associated with the cases,
variables, and coordinates of an ordination object, and attach it to the
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_aug_rows(x)

recover_aug_cols(x)

recover_aug_coord(x)

augment_ord(x, .matrix = "dims")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augmentation_+3A_x">x</code></td>
<td>
<p>An object of class '<a href="#topic+tbl_ord">tbl_ord</a>'.</p>
</td></tr>
<tr><td><code id="augmentation_+3A_.matrix">.matrix</code></td>
<td>
<p>A character string partially matched (lowercase) to several
indicators for one or both matrices in a matrix decomposition used for
ordination. The standard values are <code>"rows"</code>, <code>"cols"</code>, and <code>"dims"</code> (for
both).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code style="white-space: pre;">&#8288;recover_aug_*()&#8288;</code> <a href="base.html#topic+UseMethod">S3 methods</a> produce
<a href="tibble.html#topic+tibble">tibble</a>s of values associated with the rows, columns, and
artificial coordinates of an object of class '<a href="#topic+tbl_ord">tbl_ord</a>'. The first field of
each tibble is <code>name</code>, which contains the row, column, or coordinate names.
Additional fields contain information about the rows, columns, or coordinates
extracted from the ordination object.
</p>
<p>The function <code>augment_ord()</code> returns the ordination with either or both
matrix factors annotated with the result of <code style="white-space: pre;">&#8288;recover_aug_*()&#8288;</code>. In this way
<code>augment_ord()</code> works like <code><a href="generics.html#topic+augment">generics::augment()</a></code>, as popularized by the
<strong>broom</strong> package, by extracting information about the rows and columns, but
it differs in returning an annotated 'tbl_ord' rather than a
<a href="tibble.html#topic+tbl_df-class">'tbl_df'</a> object. The advantage of implementing separate
methods for the rows, columns, and artificial coordinates is that more
information contained in the original object becomes accessible to the user.
</p>


<h3>Value</h3>

<p>The <code style="white-space: pre;">&#8288;recover_aug_*()&#8288;</code> functions return <a href="tibble.html#topic+tibble">tibble</a>s
having the same numbers of rows as <code style="white-space: pre;">&#8288;recover_*()&#8288;</code>. <code>augment_ord()</code> returns
an augmented tbl_ord with the wrapped model unchanged.
</p>


<h3>See Also</h3>

<p><a href="#topic+tidiers">tidiers</a> and <a href="#topic+annotation">annotation</a> methods that interface with augmentation.
</p>
<p>Other generic recoverers: 
<code><a href="#topic+conference">conference</a></code>,
<code><a href="#topic+recoverers">recoverers</a></code>,
<code><a href="#topic+supplementation">supplementation</a></code>
</p>

<hr>
<h2 id='biplot-geoms'>Convenience geoms for row and column matrix factors</h2><span id='topic+biplot-geoms'></span><span id='topic+geom_rows_point'></span><span id='topic+geom_cols_point'></span><span id='topic+geom_rows_path'></span><span id='topic+geom_cols_path'></span><span id='topic+geom_rows_polygon'></span><span id='topic+geom_cols_polygon'></span><span id='topic+geom_rows_text'></span><span id='topic+geom_cols_text'></span><span id='topic+geom_rows_label'></span><span id='topic+geom_cols_label'></span><span id='topic+geom_rows_text_repel'></span><span id='topic+geom_cols_text_repel'></span><span id='topic+geom_rows_label_repel'></span><span id='topic+geom_cols_label_repel'></span><span id='topic+geom_rows_axis'></span><span id='topic+geom_cols_axis'></span><span id='topic+geom_rows_lineranges'></span><span id='topic+geom_cols_lineranges'></span><span id='topic+geom_rows_pointranges'></span><span id='topic+geom_cols_pointranges'></span><span id='topic+geom_rows_isoline'></span><span id='topic+geom_cols_isoline'></span><span id='topic+geom_rows_text_radiate'></span><span id='topic+geom_cols_text_radiate'></span><span id='topic+geom_rows_vector'></span><span id='topic+geom_cols_vector'></span>

<h3>Description</h3>

<p>These geometric element layers (geoms) pair
conventional <strong>ggplot2</strong> geoms with <code><a href="#topic+stat_rows">stat_rows()</a></code> or
<code><a href="#topic+stat_cols">stat_cols()</a></code> in order to render elements for one or the other
matrix factor of a tbl_ord. They understand the same aesthetics
as their corresponding conventional geoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_rows_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_path(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_path(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_polygon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  rule = "evenodd",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_polygon(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  rule = "evenodd",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_text(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_text(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_label(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_label(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_text_repel(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  parse = FALSE,
  ...,
  box.padding = 0.25,
  point.padding = 1e-06,
  min.segment.length = 0.5,
  arrow = NULL,
  force = 1,
  force_pull = 1,
  max.time = 0.5,
  max.iter = 10000,
  max.overlaps = getOption("ggrepel.max.overlaps", default = 10),
  nudge_x = 0,
  nudge_y = 0,
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  na.rm = FALSE,
  show.legend = NA,
  direction = c("both", "y", "x"),
  seed = NA,
  verbose = FALSE,
  inherit.aes = TRUE
)

geom_cols_text_repel(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  parse = FALSE,
  ...,
  box.padding = 0.25,
  point.padding = 1e-06,
  min.segment.length = 0.5,
  arrow = NULL,
  force = 1,
  force_pull = 1,
  max.time = 0.5,
  max.iter = 10000,
  max.overlaps = getOption("ggrepel.max.overlaps", default = 10),
  nudge_x = 0,
  nudge_y = 0,
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  na.rm = FALSE,
  show.legend = NA,
  direction = c("both", "y", "x"),
  seed = NA,
  verbose = FALSE,
  inherit.aes = TRUE
)

geom_rows_label_repel(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  parse = FALSE,
  ...,
  box.padding = 0.25,
  label.padding = 0.25,
  point.padding = 1e-06,
  label.r = 0.15,
  label.size = 0.25,
  min.segment.length = 0.5,
  arrow = NULL,
  force = 1,
  force_pull = 1,
  max.time = 0.5,
  max.iter = 10000,
  max.overlaps = getOption("ggrepel.max.overlaps", default = 10),
  nudge_x = 0,
  nudge_y = 0,
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  na.rm = FALSE,
  show.legend = NA,
  direction = c("both", "y", "x"),
  seed = NA,
  verbose = FALSE,
  inherit.aes = TRUE
)

geom_cols_label_repel(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  parse = FALSE,
  ...,
  box.padding = 0.25,
  label.padding = 0.25,
  point.padding = 1e-06,
  label.r = 0.15,
  label.size = 0.25,
  min.segment.length = 0.5,
  arrow = NULL,
  force = 1,
  force_pull = 1,
  max.time = 0.5,
  max.iter = 10000,
  max.overlaps = getOption("ggrepel.max.overlaps", default = 10),
  nudge_x = 0,
  nudge_y = 0,
  xlim = c(NA, NA),
  ylim = c(NA, NA),
  na.rm = FALSE,
  show.legend = NA,
  direction = c("both", "y", "x"),
  seed = NA,
  verbose = FALSE,
  inherit.aes = TRUE
)

geom_rows_axis(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  axis_labels = TRUE,
  axis_ticks = TRUE,
  axis_text = TRUE,
  by = NULL,
  num = NULL,
  tick_length = 0.025,
  text_dodge = 0.03,
  label_dodge = 0.03,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_axis(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  axis_labels = TRUE,
  axis_ticks = TRUE,
  axis_text = TRUE,
  by = NULL,
  num = NULL,
  tick_length = 0.025,
  text_dodge = 0.03,
  label_dodge = 0.03,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_lineranges(
  mapping = NULL,
  data = NULL,
  stat = "center",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_lineranges(
  mapping = NULL,
  data = NULL,
  stat = "center",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_pointranges(
  mapping = NULL,
  data = NULL,
  stat = "center",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_pointranges(
  mapping = NULL,
  data = NULL,
  stat = "center",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_isoline(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  isoline_text = TRUE,
  by = NULL,
  num = NULL,
  label_dodge = 0.03,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_isoline(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  isoline_text = TRUE,
  by = NULL,
  num = NULL,
  label_dodge = 0.03,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_text_radiate(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_text_radiate(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rows_vector(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  arrow = default_arrow,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_cols_vector(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  arrow = default_arrow,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biplot-geoms_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_lineend">lineend</code></td>
<td>
<p>Line end style (round, butt, square).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_linejoin">linejoin</code></td>
<td>
<p>Line join style (round, mitre, bevel).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_linemitre">linemitre</code></td>
<td>
<p>Line mitre limit (number greater than 1).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_rule">rule</code></td>
<td>
<p>Either <code>"evenodd"</code> or <code>"winding"</code>. If polygons with holes are
being drawn (using the <code>subgroup</code> aesthetic) this argument defines how the
hole coordinates are interpreted. See the examples in <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code> for
an explanation.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_nudge_x">nudge_x</code>, <code id="biplot-geoms_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_label.padding">label.padding</code></td>
<td>
<p>Amount of padding around label. Defaults to 0.25 lines.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_label.r">label.r</code></td>
<td>
<p>Radius of rounded corners. Defaults to 0.15 lines.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_box.padding">box.padding</code></td>
<td>
<p>Amount of padding around bounding box, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_point.padding">point.padding</code></td>
<td>
<p>Amount of padding around labeled point, as unit or
number. Defaults to 0. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_min.segment.length">min.segment.length</code></td>
<td>
<p>Skip drawing segments shorter than this, as unit or
number. Defaults to 0.5. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_force">force</code></td>
<td>
<p>Force of repulsion between overlapping text labels. Defaults
to 1.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_force_pull">force_pull</code></td>
<td>
<p>Force of attraction between a text label and its
corresponding data point. Defaults to 1.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_max.time">max.time</code></td>
<td>
<p>Maximum number of seconds to try to resolve overlaps.
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations to try to resolve overlaps.
Defaults to 10000.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_max.overlaps">max.overlaps</code></td>
<td>
<p>Exclude text labels that overlap too many things.
Defaults to 10.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_xlim">xlim</code>, <code id="biplot-geoms_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes. Text labels will be constrained
to these limits. By default, text labels are constrained to the entire plot
area.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_direction">direction</code></td>
<td>
<p>direction of stairs: 'vh' for vertical then horizontal,
'hv' for horizontal then vertical, or 'mid' for step half-way between
adjacent x-values.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_seed">seed</code></td>
<td>
<p>Random seed passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Defaults to
<code>NA</code>, which means that <code>set.seed</code> will not be called.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, some diagnostics of the repel algorithm are printed</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_axis_labels">axis_labels</code>, <code id="biplot-geoms_+3A_axis_ticks">axis_ticks</code>, <code id="biplot-geoms_+3A_axis_text">axis_text</code></td>
<td>
<p>Logical; whether to include labels,
tick marks, and text value marks along the axes.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_by">by</code>, <code id="biplot-geoms_+3A_num">num</code></td>
<td>
<p>Intervals between elements or number of elements; specify only
one.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_tick_length">tick_length</code></td>
<td>
<p>Numeric; the length of the tick marks, as a proportion of
the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_text_dodge">text_dodge</code></td>
<td>
<p>Numeric; the orthogonal distance of the text from the axis,
as a proportion of the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_label_dodge">label_dodge</code></td>
<td>
<p>Numeric; the orthogonal distance of the text from the axis
or isoline, as a proportion of the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="biplot-geoms_+3A_isoline_text">isoline_text</code></td>
<td>
<p>Logical; whether to include text value marks along the
isolines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>See Also</h3>

<p>Other biplot layers: 
<code><a href="#topic+biplot-stats">biplot-stats</a></code>,
<code><a href="#topic+stat_rows">stat_rows</a>()</code>
</p>

<hr>
<h2 id='biplot-stats'>Convenience stats for row and column matrix factors</h2><span id='topic+biplot-stats'></span><span id='topic+stat_rows_ellipse'></span><span id='topic+stat_cols_ellipse'></span><span id='topic+stat_rows_center'></span><span id='topic+stat_cols_center'></span><span id='topic+stat_rows_star'></span><span id='topic+stat_cols_star'></span><span id='topic+stat_rows_chull'></span><span id='topic+stat_cols_chull'></span><span id='topic+stat_rows_cone'></span><span id='topic+stat_cols_cone'></span><span id='topic+stat_rows_scale'></span><span id='topic+stat_cols_scale'></span><span id='topic+stat_rows_spantree'></span><span id='topic+stat_cols_spantree'></span>

<h3>Description</h3>

<p>These statistical transformations (stats) adapt
conventional <strong>ggplot2</strong> stats to one or the other matrix factor
of a tbl_ord, in lieu of <code><a href="#topic+stat_rows">stat_rows()</a></code> or <code><a href="#topic+stat_cols">stat_cols()</a></code>. They
accept the same parameters as their corresponding conventional
stats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_rows_ellipse(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  type = "t",
  level = 0.95,
  segments = 51,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_cols_ellipse(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  ...,
  type = "t",
  level = 0.95,
  segments = 51,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_rows_center(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  fun.data = NULL,
  fun.center = NULL,
  fun.min = NULL,
  fun.max = NULL,
  fun.args = list()
)

stat_cols_center(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  fun.data = NULL,
  fun.center = NULL,
  fun.min = NULL,
  fun.max = NULL,
  fun.args = list()
)

stat_rows_star(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  fun.data = NULL,
  fun.center = NULL,
  fun.args = list()
)

stat_cols_star(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  fun.data = NULL,
  fun.center = NULL,
  fun.args = list()
)

stat_rows_chull(
  mapping = NULL,
  data = NULL,
  geom = "polygon",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_cols_chull(
  mapping = NULL,
  data = NULL,
  geom = "polygon",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_rows_cone(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  origin = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_cols_cone(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  origin = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_rows_scale(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  mult = 1
)

stat_cols_scale(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  mult = 1
)

stat_rows_spantree(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  engine = "mlpack",
  method = "euclidean",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

stat_cols_spantree(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  engine = "mlpack",
  method = "euclidean",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biplot-stats_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_type">type</code></td>
<td>
<p>The type of ellipse.
The default <code>"t"</code> assumes a multivariate t-distribution, and
<code>"norm"</code> assumes a multivariate normal distribution.
<code>"euclid"</code> draws a circle with the radius equal to <code>level</code>,
representing the euclidean distance from the center.
This ellipse probably won't appear circular unless <code>coord_fixed()</code> is applied.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_level">level</code></td>
<td>
<p>The level at which to draw an ellipse,
or, if <code>type="euclid"</code>, the radius of the circle to be drawn.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_segments">segments</code></td>
<td>
<p>The number of segments to be used in drawing the ellipse.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_fun.data">fun.data</code>, <code id="biplot-stats_+3A_fun.center">fun.center</code>, <code id="biplot-stats_+3A_fun.min">fun.min</code>, <code id="biplot-stats_+3A_fun.max">fun.max</code>, <code id="biplot-stats_+3A_fun.args">fun.args</code></td>
<td>
<p>Functions and arguments
treated as in <code><a href="ggplot2.html#topic+stat_summary">ggplot2::stat_summary()</a></code>, with <code>fun.center</code>, <code>fun.min</code>, and
<code>fun.max</code> behaving as <code>fun.y</code>, <code>fun.ymin</code>, and <code>fun.ymax</code>.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_origin">origin</code></td>
<td>
<p>Logical; whether to include the origin with the transformed
data. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_mult">mult</code></td>
<td>
<p>Numeric value used to scale the coordinates.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying the package implementation
to use; <code>"mlpack"</code>, <code>"vegan"</code>, or <code>"ade4"</code>.</p>
</td></tr>
<tr><td><code id="biplot-stats_+3A_method">method</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code> if <code>engine</code> is <code>"vegan"</code> or <code>"ade4"</code>,
ignored if <code>"mlpack"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Ordination aesthetics</h3>

<p>The convenience function <code><a href="#topic+ord_aes">ord_aes()</a></code> can be used to incorporate all
coordinates of the ordination model into a statistical transformation. It
maps the coordinates to the custom aesthetics <code>..coord1</code>, <code>..coord2</code>, etc.
</p>
<p>Some transformations, e.g. <code><a href="#topic+stat_center">stat_center()</a></code>, are commutative with projection
to the 'x' and 'y' coordinates. If they detect aesthetics of the form
<code style="white-space: pre;">&#8288;..coord[0-9]+&#8288;</code>, then <code>..coord1</code> and <code>..coord2</code> are converted to <code>x</code> and <code>y</code>
while any remaining are ignored.
</p>
<p>Other transformations, e.g. <code><a href="#topic+stat_spantree">stat_spantree()</a></code>, yield different results in a
planar biplot when they are computer before or after projection. If such a
stat layer detects these aesthetics, then the lot of them are used in the
transformation.
</p>
<p>In either case, the stat layer returns a data frame with position aesthetics
<code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other biplot layers: 
<code><a href="#topic+biplot-geoms">biplot-geoms</a></code>,
<code><a href="#topic+stat_rows">stat_rows</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute row-principal components of scaled iris measurements
iris[, -5] %&gt;%
  prcomp(scale = TRUE) %&gt;%
  as_tbl_ord() %&gt;%
  mutate_rows(species = iris$Species) %&gt;%
  print() -&gt; iris_pca

# row-principal biplot with centroids and confidence elliptical disks
iris_pca %&gt;%
  ggbiplot(aes(color = species)) +
  theme_bw() +
  geom_rows_point() +
  geom_polygon(
    aes(fill = species),
    color = NA, alpha = .25, stat = "rows_ellipse"
  ) +
  geom_cols_vector(color = "#444444") +
  scale_color_brewer(
    type = "qual", palette = 2,
    aesthetics = c("color", "fill")
  ) +
  ggtitle(
    "Row-principal PCA biplot of Anderson iris measurements",
    "Overlaid with 95% confidence disks"
  )
</code></pre>

<hr>
<h2 id='conference'>Confer inertia to factors of a 'tbl_ord' object</h2><span id='topic+conference'></span><span id='topic+recover_conference'></span><span id='topic+recover_conference.default'></span><span id='topic+get_conference'></span><span id='topic+revert_conference'></span><span id='topic+confer_inertia'></span>

<h3>Description</h3>

<p>Re-distribute inertia between rows and columns in an
ordination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_conference(x)

## Default S3 method:
recover_conference(x)

get_conference(x)

revert_conference(x)

confer_inertia(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conference_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tbl_ord">tbl_ord</a>.</p>
</td></tr>
<tr><td><code id="conference_+3A_p">p</code></td>
<td>
<p>Numeric vector of length 1 or 2. If length 1, the proportion of the
inertia assigned to the cases, with the remainder <code>1 - p</code> assigned to the
variables. If length 2, the proportions of the inertia assigned to the
cases and to the variables, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>inertia</em> of a singular value decomposition <code class="reqn">X=UDV'</code> consists in the
squares of the singular values (the diagonal elements of <code class="reqn">D</code>), and
represents the variance, likened to the physical inertia, in the directions
of the orthogonal singular vectors (the columns of <code class="reqn">U</code> or of <code class="reqn">V</code>).
Biplots superimpose the projections of the rows and the columns of <code class="reqn">X</code>
onto these coordinate vectors, scaled by some proportion of the total
inertia: <code class="reqn">UD^p</code> and <code class="reqn">VD^q</code>. A biplot is <em>balanced</em> if <code class="reqn">p+q=1</code>.
Read Orlov (2013) for more on conferring inertia in PCA.
</p>
<p><code>recover_conference()</code>, like the other recoverers, is an <a href="base.html#topic+UseMethod">S3 method</a> that is exported for convenience but not intended to
be used directly.
</p>
<p><em>Note: In case the <code>"inertia"</code> attribute is a rectangular matrix, one may
only be able to confer it entirely to the cases (<code>p = 1</code>) or entirely to the
variables (<code>p = 0</code>).</em>
</p>


<h3>Value</h3>

<p><code>recover_conference()</code> returns the (statically implemented)
distribution of inertia between the rows and the columns as stored in the
model. <code>confer_inertia()</code> returns a tbl_ord with a specified distribution
of inertia but the wrapped model unchanged. <code>get_conference()</code> returns the
distribution currently conferred.
</p>


<h3>References</h3>

<p>Orlov K (2013) <em>Answer to</em> &quot;Algebra of LDA. Fisher discrimination power of a
variable and Linear Discriminant Analysis&quot;. CrossValidated, accessed
2019-07-26. <a href="https://stats.stackexchange.com/a/83114/68743">https://stats.stackexchange.com/a/83114/68743</a>
</p>


<h3>See Also</h3>

<p>Other generic recoverers: 
<code><a href="#topic+augmentation">augmentation</a></code>,
<code><a href="#topic+recoverers">recoverers</a></code>,
<code><a href="#topic+supplementation">supplementation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustrative ordination: correspendence analysis of hair &amp; eye data
haireye_ca &lt;- ordinate(
  as.data.frame(rowSums(HairEyeColor, dims = 2L)),
  cols = everything(), model = MASS::corresp
)
print(haireye_ca)

# check distribution of inertia
get_conference(haireye_ca)
# confer inertia to rows, then to columns
confer_inertia(haireye_ca, "rows")
confer_inertia(haireye_ca, "columns")
# confer inertia symmetrically
(haireye_ca &lt;- confer_inertia(haireye_ca, "symmetric"))
# check redistributed inertia
get_conference(haireye_ca)
# restore default distribution of inertia
revert_conference(haireye_ca)
</code></pre>

<hr>
<h2 id='dplyr-verbs'><strong>dplyr</strong> verbs for tbl_ord factors</h2><span id='topic+dplyr-verbs'></span><span id='topic+pull_factor'></span><span id='topic+pull_rows'></span><span id='topic+pull_cols'></span><span id='topic+rename_rows'></span><span id='topic+rename_cols'></span><span id='topic+select_rows'></span><span id='topic+select_cols'></span><span id='topic+mutate_rows'></span><span id='topic+mutate_cols'></span><span id='topic+transmute_rows'></span><span id='topic+transmute_cols'></span><span id='topic+cbind_rows'></span><span id='topic+cbind_cols'></span><span id='topic+left_join_rows'></span><span id='topic+left_join_cols'></span>

<h3>Description</h3>

<p>These functions adapt <a href="dplyr.html#topic+dplyr-package">dplyr</a> verbs to the factors
of a <a href="#topic+tbl_ord">tbl_ord</a>.
</p>
<p>The raw verbs are not defined for tbl_ords; instead, each verb
has two analogues, corresponding to the two matrix factors. They each rely
on a common workhorse function, which takes the composition of the
<strong>dplyr</strong> verb with <code style="white-space: pre;">&#8288;annotation_*&#8288;</code>, applied to the factor, removes any
variables corresponding to coordinates or already annotated, and only then
assigns it as the new <code>"*_annotation"</code> attribute of <code>.data</code> (see
<a href="#topic+annotation">annotation</a>). Note that these functions are not generics and so cannot be
extended to other classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_factor(.data, var = -1, .matrix)

pull_rows(.data, var = -1)

pull_cols(.data, var = -1)

rename_rows(.data, ...)

rename_cols(.data, ...)

select_rows(.data, ...)

select_cols(.data, ...)

mutate_rows(.data, ...)

mutate_cols(.data, ...)

transmute_rows(.data, ...)

transmute_cols(.data, ...)

cbind_rows(.data, ..., elements = "all")

cbind_cols(.data, ..., elements = "all")

left_join_rows(.data, ...)

left_join_cols(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr-verbs_+3A_.data">.data</code></td>
<td>
<p>An object of class '<a href="#topic+tbl_ord">tbl_ord</a>'.</p>
</td></tr>
<tr><td><code id="dplyr-verbs_+3A_var">var</code></td>
<td>
<p>A variable specified as in <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>.</p>
</td></tr>
<tr><td><code id="dplyr-verbs_+3A_.matrix">.matrix</code></td>
<td>
<p>A character string partially matched (lowercase) to several
indicators for one or both matrices in a matrix decomposition used for
ordination. The standard values are <code>"rows"</code>, <code>"cols"</code>, and <code>"dims"</code> (for
both).</p>
</td></tr>
<tr><td><code id="dplyr-verbs_+3A_...">...</code></td>
<td>
<p>Comma-separated unquoted expressions as in, e.g.,
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.</p>
</td></tr>
<tr><td><code id="dplyr-verbs_+3A_elements">elements</code></td>
<td>
<p>Character vector; which elements of each factor for which to
render graphical elements. One of <code>"all"</code> (the default), <code>"active"</code>, or any
supplementary element type defined by the specific class methods (e.g.
<code>"score"</code> for 'factanal', 'lda_ord', and 'cancord_ord' and <code>"intraset"</code> and
<code>"interset"</code> for 'cancor_ord').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_ord; the wrapped model is unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustrative ordination: LDA of iris data
(iris_lda &lt;- ordinate(iris, cols = 1:4, lda_ord, grouping = iris$Species))

# extract a coordinate or annotation
head(pull_rows(iris_lda, Species))
pull_cols(iris_lda, LD2)

# rename an annotation
rename_cols(iris_lda, species = name)

# select annotations
select_rows(iris_lda, species = name, .element)

# create, modify, and delete annotations
mutate_cols(iris_lda, vec.length = sqrt(LD1^2 + LD2^2))
transmute_cols(iris_lda, vec.length = sqrt(LD1^2 + LD2^2))

# bind data frames of annotations
iris_medians &lt;-
  stats::aggregate(iris[, 1:4], median, by = iris[, 5, drop = FALSE])
iris_lda %&gt;%
  # retain '.element' in order to match by `elements`
  select_rows(.element) %&gt;%
  cbind_rows(iris_medians, elements = "active")
</code></pre>

<hr>
<h2 id='draw-key'>Biplot key drawing functions</h2><span id='topic+draw-key'></span><span id='topic+draw_key_line'></span><span id='topic+draw_key_crosslines'></span><span id='topic+draw_key_crosspoint'></span>

<h3>Description</h3>

<p>These key drawing functions supplement those built into
<strong><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></strong> for producing legends suitable to biplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_key_line(data, params, size)

draw_key_crosslines(data, params, size)

draw_key_crosspoint(data, params, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw-key_+3A_data">data</code></td>
<td>
<p>A single row data frame containing the scaled aesthetics to
display in this key</p>
</td></tr>
<tr><td><code id="draw-key_+3A_params">params</code></td>
<td>
<p>A list of additional parameters supplied to the geom.</p>
</td></tr>
<tr><td><code id="draw-key_+3A_size">size</code></td>
<td>
<p>Width and height of key in mm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>draw_key_line()</code> is a horizontal counterpart to <code><a href="ggplot2.html#topic+draw_key">ggplot2::draw_key_vline()</a></code>.
<code>draw_key_crosslines()</code> superimposes these two keys, and
<code>draw_key_crosspoint()</code> additionally superimposes an oversized
<code><a href="ggplot2.html#topic+draw_key">ggplot2::draw_key_point()</a></code>.
</p>


<h3>Value</h3>

<p>A grid grob.
</p>


<h3>See Also</h3>

<p><a href="ggplot2.html#topic+draw_key">ggplot2::draw_key</a> for key glyphs installed with <strong>ggplot2</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># scaled PCA of Anderson iris data with ranges and confidence intervals
iris[, -5] %&gt;%
  prcomp(scale = TRUE) %&gt;%
  as_tbl_ord() %&gt;%
  confer_inertia(1) %&gt;%
  augment_ord() %&gt;%
  mutate_rows(species = iris$Species) %&gt;%
  ggbiplot(aes(color = species)) +
  theme_bw() +
  scale_color_brewer(type = "qual", palette = 2) +
  geom_rows_lineranges(fun.data = mean_sdl, linewidth = .75) +
  geom_rows_point(alpha = .5) +
  geom_cols_vector(color = "#444444") +
  geom_cols_text_radiate(aes(label = name), color = "#444444", size = 3) +
  ggtitle(
    "Row-principal PCA biplot of Anderson iris data",
    "Ranges 2 sample standard deviations from centroids"
  )
</code></pre>

<hr>
<h2 id='format'>Format a tbl_ord for printing</h2><span id='topic+format'></span><span id='topic+format.tbl_ord'></span><span id='topic+print.tbl_ord'></span>

<h3>Description</h3>

<p>These methods of <code><a href="base.html#topic+format">base::format()</a></code> and <code><a href="base.html#topic+print">base::print()</a></code> render a
(usually more) tidy readout of a <a href="#topic+tbl_ord">tbl_ord</a> that is consistent across all
original ordination classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_ord'
format(
  x,
  width = NULL,
  ...,
  n = NULL,
  max_extra_cols = NULL,
  max_footer_lines = NULL
)

## S3 method for class 'tbl_ord'
print(
  x,
  width = NULL,
  ...,
  n = NULL,
  max_extra_cols = NULL,
  max_footer_lines = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tbl_ord">tbl_ord</a>.</p>
</td></tr>
<tr><td><code id="format_+3A_width">width</code></td>
<td>
<p>Width of text output to generate. This defaults to <code>NULL</code>, which
means use the <code>width</code> <a href="pillar.html#topic+pillar_options">option</a>.</p>
</td></tr>
<tr><td><code id="format_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="format_+3A_n">n</code></td>
<td>
<p>Number of rows to show. If <code>NULL</code>, the default, will print all rows
if less than the <code>print_max</code> <a href="pillar.html#topic+pillar_options">option</a>.
Otherwise, will print as many rows as specified by the
<code>print_min</code> <a href="pillar.html#topic+pillar_options">option</a>.</p>
</td></tr>
<tr><td><code id="format_+3A_max_extra_cols">max_extra_cols</code></td>
<td>
<p>Number of extra columns to print abbreviated information for,
if the width is too small for the entire tibble. If <code>NULL</code>,
the <code>max_extra_cols</code> <a href="pillar.html#topic+pillar_options">option</a> is used.
The previously defined <code>n_extra</code> argument is soft-deprecated.</p>
</td></tr>
<tr><td><code id="format_+3A_max_footer_lines">max_footer_lines</code></td>
<td>
<p>Maximum number of footer lines. If <code>NULL</code>,
the <code>max_footer_lines</code> <a href="pillar.html#topic+pillar_options">option</a> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>format</code> and <code>print</code> methods for class 'tbl_ord' are adapted from those
for class '<a href="tibble.html#topic+tbl_df-class">tbl_df</a>' and for class 'tbl_graph' from the
<strong>tidygraph</strong> package.
</p>
<p><strong>Note:</strong> The <code>format()</code> function is tedius but cannot be easily modularized
without invoking <a href="#topic+recoverers">recoverers</a>, <a href="#topic+annotation">annotation</a>, and <a href="#topic+augmentation">augmentation</a> multiple
times, thereby significantly reducing performance.
</p>


<h3>Value</h3>

<p>The <code>format()</code> method returns a vector of strings that are more
elegantly printed by the <code>print()</code> method, which itself returns the tbl_ord
invisibly.
</p>

<hr>
<h2 id='geom_axis'>Axes through the origin</h2><span id='topic+geom_axis'></span>

<h3>Description</h3>

<p><code>geom_axis()</code> renders lines through the origin and the position
of each case or variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_axis(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  axis_labels = TRUE,
  axis_ticks = TRUE,
  axis_text = TRUE,
  by = NULL,
  num = NULL,
  tick_length = 0.025,
  text_dodge = 0.03,
  label_dodge = 0.03,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_axis_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_axis_labels">axis_labels</code>, <code id="geom_axis_+3A_axis_ticks">axis_ticks</code>, <code id="geom_axis_+3A_axis_text">axis_text</code></td>
<td>
<p>Logical; whether to include labels,
tick marks, and text value marks along the axes.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_by">by</code>, <code id="geom_axis_+3A_num">num</code></td>
<td>
<p>Intervals between elements or number of elements; specify only
one.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_tick_length">tick_length</code></td>
<td>
<p>Numeric; the length of the tick marks, as a proportion of
the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_text_dodge">text_dodge</code></td>
<td>
<p>Numeric; the orthogonal distance of the text from the axis,
as a proportion of the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_label_dodge">label_dodge</code></td>
<td>
<p>Numeric; the orthogonal distance of the text from the axis
or isoline, as a proportion of the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_axis_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_axis()</code> understands the following aesthetics (required aesthetics are
in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>linewidth</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>label</code>
</p>
</li>
<li> <p><code>center</code>, <code>scale</code>
</p>
</li>
<li> <p><code>label_colour</code>, <code>label_alpha</code>, <code>label_size</code>, <code>label_angle</code>,
<code>label_hjust</code>, <code>label_vjust</code>, <code>label_family</code>, <code>label_fontface</code>
</p>
</li>
<li> <p><code>tick_colour</code>, <code>tick_alpha</code>, <code>tick_linewidth</code>, <code>tick_linetype</code>
</p>
</li>
<li> <p><code>text_colour</code>, <code>text_alpha</code>, <code>text_size</code>, <code>text_angle</code>,
<code>text_hjust</code>, <code>text_vjust</code>, <code>text_family</code>, <code>text_fontface</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li></ul>

<p>The prefixed aesthetics <code style="white-space: pre;">&#8288;label_*&#8288;</code>, <code style="white-space: pre;">&#8288;tick_*&#8288;</code>, and <code style="white-space: pre;">&#8288;text_*&#8288;</code> are used by the
text elements and will inherit any values passed to their un-prefixed
counterparts, if recognized.
</p>


<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_isoline">geom_isoline</a>()</code>,
<code><a href="#topic+geom_lineranges">geom_lineranges</a>()</code>,
<code><a href="#topic+geom_origin">geom_origin</a>()</code>,
<code><a href="#topic+geom_text_radiate">geom_text_radiate</a>()</code>,
<code><a href="#topic+geom_unit_circle">geom_unit_circle</a>()</code>,
<code><a href="#topic+geom_vector">geom_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reaven &amp; Miller overt &amp; chemical diabetes test data and group classification
head(heplots::Diabetes)

# default (standardized) linear discriminant analysis of groups on tests
diabetes_lda &lt;- MASS::lda(group ~ ., heplots::Diabetes)
# bestow 'tbl_ord' class &amp; augment observation, centroid, and variable fields
as_tbl_ord(diabetes_lda) %&gt;%
  augment_ord() %&gt;%
  mutate_rows(discriminant = ifelse(
    .element == "active",
    "centroid", "case"
  )) %&gt;%
  print() -&gt; diabetes_lda
# row-standard biplot
diabetes_lda %&gt;%
  confer_inertia(1) %&gt;%
  ggbiplot() +
  theme_bw() + theme_biplot() +
  geom_rows_point(aes(shape = grouping, size = discriminant), alpha = .5) +
  geom_cols_axis(aes(label = name), color = "#888888", num = 8L,
                 text_size = 2.5, label_dodge = .02) +
  ggtitle(
    "LDA of Reaven &amp; Miller diabetes groups",
    "Row-standard biplot of standardized LDA"
  )

# contribution LDA of groups on tests
diabetes_lda &lt;-
  lda_ord(group ~ ., heplots::Diabetes, axes.scale = "contribution")
# bestow 'tbl_ord' class &amp; augment observation, centroid, and variable fields
as_tbl_ord(diabetes_lda) %&gt;%
  augment_ord() %&gt;%
  mutate_rows(discriminant = ifelse(
    .element == "active",
    "centroid", "case"
  )) %&gt;%
  print() -&gt; diabetes_lda
# symmetric biplot
diabetes_lda %&gt;%
  confer_inertia(.5) %&gt;%
  ggbiplot() +
  theme_bw() + theme_biplot() +
  geom_rows_point(aes(shape = grouping, alpha = discriminant)) +
  geom_cols_axis(color = "#888888", num = 8L,
                 text_size = 2.5, text_dodge = .025) +
  ggtitle(
    "LDA of Reaven &amp; Miller diabetes groups",
    "Symmetric biplot of contribution LDA"
  )
</code></pre>

<hr>
<h2 id='geom_isoline'>Isolines (contour lines)</h2><span id='topic+geom_isoline'></span>

<h3>Description</h3>

<p><code>geom_isoline()</code> renders isolines along row or column axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_isoline(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  isoline_text = TRUE,
  by = NULL,
  num = NULL,
  label_dodge = 0.03,
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_isoline_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_isoline_text">isoline_text</code></td>
<td>
<p>Logical; whether to include text value marks along the
isolines.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_by">by</code>, <code id="geom_isoline_+3A_num">num</code></td>
<td>
<p>Intervals between elements or number of elements; specify only
one.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_label_dodge">label_dodge</code></td>
<td>
<p>Numeric; the orthogonal distance of the text from the axis
or isoline, as a proportion of the minimum of the plot width and height.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_isoline_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_isoline()</code> understands the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>linewidth</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>center</code>, <code>scale</code>
</p>
</li>
<li> <p><code>angle</code>
</p>
</li>
<li> <p><code>hjust</code>
</p>
</li>
<li> <p><code>vjust</code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li>
<li> <p><code>text_colour</code>, <code>text_alpha</code>, <code>text_size</code>,
</p>
</li>
<li> <p><code>group</code>
</p>
</li></ul>

<p>The prefixed aesthetics <code style="white-space: pre;">&#8288;text_*&#8288;</code> are used by the text elements and will
inherit any values passed to their un-prefixed counterparts.
</p>


<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_axis">geom_axis</a>()</code>,
<code><a href="#topic+geom_lineranges">geom_lineranges</a>()</code>,
<code><a href="#topic+geom_origin">geom_origin</a>()</code>,
<code><a href="#topic+geom_text_radiate">geom_text_radiate</a>()</code>,
<code><a href="#topic+geom_unit_circle">geom_unit_circle</a>()</code>,
<code><a href="#topic+geom_vector">geom_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reaven &amp; Miller overt &amp; chemical diabetes test data and group classification
head(heplots::Diabetes)
# default (standardized) linear discriminant analysis of groups on tests
diabetes_lda &lt;- MASS::lda(group ~ ., heplots::Diabetes)

# bestow 'tbl_ord' class &amp; augment observation, centroid, and variable fields
as_tbl_ord(diabetes_lda) %&gt;%
  augment_ord() %&gt;%
  print() -&gt; diabetes_lda

# row-standard biplot
diabetes_lda %&gt;%
  confer_inertia(1) %&gt;%
  ggbiplot(aes(label = name), elements = "active") +
  theme_bw() + theme_biplot() +
  geom_rows_text() +
  geom_cols_vector(subset = c(1, 3, 4)) +
  geom_cols_text_radiate(subset = c(1, 3, 4), size = 3) +
  geom_cols_isoline(subset = c(1, 3, 4), alpha = .25, num = 4L,
                    label_dodge = -.03, text_alpha = .5, text_size = 3) +
  ggtitle(
    "LDA of Reaven &amp; Miller diabetes groups",
    "Row-standard biplot of standardized LDA"
  )
</code></pre>

<hr>
<h2 id='geom_lineranges'>Intervals depicting ranges, usually about center points</h2><span id='topic+geom_lineranges'></span><span id='topic+geom_pointranges'></span>

<h3>Description</h3>

<p><code>geom_lineranges()</code> renders horizontal and vertical intervals
for a specified subject or variable; <code>geom_pointranges()</code> additionally
renders a point at their crosshairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_lineranges(
  mapping = NULL,
  data = NULL,
  stat = "center",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_pointranges(
  mapping = NULL,
  data = NULL,
  stat = "center",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_lineranges_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_lineranges_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_lineranges()</code> and <code>geom_pointranges()</code> understand the following
aesthetics (required aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>xmin</code></strong>
</p>
</li>
<li> <p><strong><code>xmax</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><strong><code>ymin</code></strong>
</p>
</li>
<li> <p><strong><code>ymax</code></strong>'
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linewidth</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_axis">geom_axis</a>()</code>,
<code><a href="#topic+geom_isoline">geom_isoline</a>()</code>,
<code><a href="#topic+geom_origin">geom_origin</a>()</code>,
<code><a href="#topic+geom_text_radiate">geom_text_radiate</a>()</code>,
<code><a href="#topic+geom_unit_circle">geom_unit_circle</a>()</code>,
<code><a href="#topic+geom_vector">geom_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute log-ratio analysis of Freestone primary class composition measurements
glass %&gt;%
  ordinate(cols = c(SiO2, Al2O3, CaO, FeO, MgO),
           model = lra, compositional = TRUE) %&gt;%
  confer_inertia("rows") %&gt;%
  print() -&gt; glass_lra

# row-principal biplot with ordinate-wise standard deviations
glass_lra %&gt;%
  ggbiplot(aes(color = Site), sec.axes = "cols", scale.factor = .05) +
  theme_biplot() +
  scale_color_brewer(type = "qual", palette = 6) +
  geom_cols_text(stat = "chull", aes(label = name), color = "#444444") +
  geom_rows_lineranges(fun.data = mean_sdl, linewidth = .75) +
  geom_rows_point(alpha = .5) +
  ggtitle(
    "Row-principal LRA biplot of Freestone glass measurements",
    "Ranges 2 sample standard deviations from centroids"
  )
</code></pre>

<hr>
<h2 id='geom_origin'>Crosshairs or circle at the origin</h2><span id='topic+geom_origin'></span>

<h3>Description</h3>

<p><code>geom_origin()</code> renders a symbol, either a set of crosshairs or
a circle, at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_origin(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  marker = "crosshairs",
  radius = unit(0.04, "snpc"),
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_origin_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_marker">marker</code></td>
<td>
<p>The symbol to be drawn at the origin; matched to <code>"crosshairs"</code>
or <code>"circle"</code>.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_radius">radius</code></td>
<td>
<p>A <code><a href="grid.html#topic+unit">grid::unit()</a></code> object that sets the radius of the crosshairs
or of the circle.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_origin_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_origin()</code> accepts no aesthetics.
</p>


<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_axis">geom_axis</a>()</code>,
<code><a href="#topic+geom_isoline">geom_isoline</a>()</code>,
<code><a href="#topic+geom_lineranges">geom_lineranges</a>()</code>,
<code><a href="#topic+geom_text_radiate">geom_text_radiate</a>()</code>,
<code><a href="#topic+geom_unit_circle">geom_unit_circle</a>()</code>,
<code><a href="#topic+geom_vector">geom_vector</a>()</code>
</p>

<hr>
<h2 id='geom_text_radiate'>Text radiating outward from the origin</h2><span id='topic+geom_text_radiate'></span>

<h3>Description</h3>

<p><code>geom_text_radiate()</code> is adapted from <code>ggbiplot()</code> in the
off-CRAN extensions of the same name (Vu, 2014; Telford, 2017; Gegzna,
2018). It renders text at specified positions and angles that radiate out
from the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_text_radiate(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_text_radiate_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function. Cannot be jointy specified with
<code>nudge_x</code> or <code>nudge_y</code>.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_parse">parse</code></td>
<td>
<p>If <code>TRUE</code>, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_text_radiate_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_text_radiate()</code> understands the following aesthetics (required
aesthetics are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><strong><code>label</code></strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>angle</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li>
<li> <p><code>hjust</code>
</p>
</li>
<li> <p><code>lineheight</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>vjust</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li></ul>



<h3>References</h3>

<p>Vincent Q. Vu (2014). ggbiplot: A 'ggplot2' based biplot. R package version
0.55. <a href="https://github.com/vqv/ggbiplot">https://github.com/vqv/ggbiplot</a>, <code>experimental</code> branch
</p>
<p>Richard J Telford (2017). ggbiplot: A 'ggplot2' based biplot. R package
version 0.6. <a href="https://github.com/richardjtelford/ggbiplot">https://github.com/richardjtelford/ggbiplot</a> (fork),
<code>experimental</code> branch
</p>
<p>Vilmantas Gegzna (2018). ggbiplot: A 'ggplot2' based biplot. R package
version 0.55. <a href="https://github.com/forked-packages/ggbiplot">https://github.com/forked-packages/ggbiplot</a> (fork), <code>experimental</code>
branch
</p>


<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_axis">geom_axis</a>()</code>,
<code><a href="#topic+geom_isoline">geom_isoline</a>()</code>,
<code><a href="#topic+geom_lineranges">geom_lineranges</a>()</code>,
<code><a href="#topic+geom_origin">geom_origin</a>()</code>,
<code><a href="#topic+geom_unit_circle">geom_unit_circle</a>()</code>,
<code><a href="#topic+geom_vector">geom_vector</a>()</code>
</p>

<hr>
<h2 id='geom_unit_circle'>Unit circle</h2><span id='topic+geom_unit_circle'></span>

<h3>Description</h3>

<p><code>geom_unit_circle()</code> renders the unit circle, centered at the
origin with radius 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_unit_circle(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  segments = 60,
  scale.factor = 1,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_unit_circle_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_segments">segments</code></td>
<td>
<p>The number of segments to be used in drawing the circle.</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_scale.factor">scale.factor</code></td>
<td>
<p>The circle radius; should remain at its default value 1
or passed the same value as <code><a href="#topic+ggbiplot">ggbiplot()</a></code>. (This is an imperfect fix that
may be changed in a future version.)</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_unit_circle_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_unit_circle()</code> understands the following aesthetics (none required):
</p>

<ul>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_axis">geom_axis</a>()</code>,
<code><a href="#topic+geom_isoline">geom_isoline</a>()</code>,
<code><a href="#topic+geom_lineranges">geom_lineranges</a>()</code>,
<code><a href="#topic+geom_origin">geom_origin</a>()</code>,
<code><a href="#topic+geom_text_radiate">geom_text_radiate</a>()</code>,
<code><a href="#topic+geom_vector">geom_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># principal components analysis of overt &amp; chemical diabetes test values
heplots::Diabetes[, seq(5L)] %&gt;%
  princomp(cor = TRUE) %&gt;%
  as_tbl_ord() %&gt;%
  cbind_rows(group = heplots::Diabetes$group) %&gt;%
  augment_ord() %&gt;%
  print() -&gt; diabetes_pca

# note that column standard coordinates are unit vectors
rowSums(get_cols(diabetes_pca)^2)

# plot column standard coordinates with a unit circle underlaid
diabetes_pca %&gt;%
  ggbiplot(aes(label = name), sec.axes = "cols", scale.factor = 3) +
  geom_rows_point(aes(color = group), alpha = .25) +
  geom_unit_circle(alpha = .5, scale.factor = 3) +
  geom_cols_vector() +
  geom_cols_text_radiate()
</code></pre>

<hr>
<h2 id='geom_vector'>Vectors from the origin</h2><span id='topic+geom_vector'></span>

<h3>Description</h3>

<p><code>geom_vector()</code> renders arrows from the origin to points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_vector(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  arrow = default_arrow,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_vector_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_arrow">arrow</code></td>
<td>
<p>Specification for arrows, as created by <code><a href="grid.html#topic+arrow">grid::arrow()</a></code>, or else
<code>NULL</code> for no arrows.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_vector_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Aesthetics</h3>

<p><code>geom_vector()</code> understands the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>group</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other geom layers: 
<code><a href="#topic+geom_axis">geom_axis</a>()</code>,
<code><a href="#topic+geom_isoline">geom_isoline</a>()</code>,
<code><a href="#topic+geom_lineranges">geom_lineranges</a>()</code>,
<code><a href="#topic+geom_origin">geom_origin</a>()</code>,
<code><a href="#topic+geom_text_radiate">geom_text_radiate</a>()</code>,
<code><a href="#topic+geom_unit_circle">geom_unit_circle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute unscaled row-principal components of scaled measurements
(iris_pca &lt;- ordinate(iris, cols = 1:4, princomp))

# row-principal biplot with coordinate-wise standard deviations
iris_pca %&gt;%
  ggbiplot(aes(color = Species)) +
  theme_bw() +
  scale_color_brewer(type = "qual", palette = 2) +
  geom_unit_circle() +
  geom_rows_point(alpha = .5) +
  geom_cols_vector(color = "#444444") +
  geom_cols_text_radiate(aes(label = name), color = "#444444") +
  ggtitle("Row-principal unscaled PCA biplot of Anderson iris measurements") +
  expand_limits(y = c(NA, 2))
</code></pre>

<hr>
<h2 id='ggbiplot'>Biplots following the grammar of graphics</h2><span id='topic+ggbiplot'></span><span id='topic+ord_aes'></span>

<h3>Description</h3>

<p>Build a biplot visualization from ordination data wrapped as a
<a href="#topic+tbl_ord">tbl_ord</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggbiplot(
  ordination = NULL,
  mapping = aes(x = 1, y = 2),
  axis.type = "interpolative",
  xlim = NULL,
  ylim = NULL,
  expand = TRUE,
  clip = "on",
  axis.percents = TRUE,
  sec.axes = NULL,
  scale.factor = NULL,
  scale_rows = NULL,
  scale_cols = NULL,
  ...
)

ord_aes(ordination, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggbiplot_+3A_ordination">ordination</code></td>
<td>
<p>A <a href="#topic+tbl_ord">tbl_ord</a>.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_mapping">mapping</code></td>
<td>
<p>List of default aesthetic mappings to use for the biplot. The
default assigns the first two coordinates to the aesthetics <code>x</code> and <code>y</code>.
Other assignments must be supplied in each layer added to the plot.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_axis.type">axis.type</code></td>
<td>
<p>Character, partially matched; whether to build an
<code>"interpolative"</code> (the default) or a <code>"predictive"</code> biplot. The latter
requires that <code>x</code> and <code>y</code> are mapped to shared coordinates, that no other
shared coordinates are mapped to, and inertia is conferred entirely onto
one matrix factor. <strong>NB:</strong> This option is only implemented for linear
techniques (ED, SVD, &amp; PCA).</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_xlim">xlim</code>, <code id="ggbiplot_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_expand">expand</code></td>
<td>
<p>If <code>TRUE</code>, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If <code>FALSE</code>,
limits are taken exactly from the data or <code>xlim</code>/<code>ylim</code>.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_clip">clip</code></td>
<td>
<p>Should drawing be clipped to the extent of the plot panel? A
setting of <code>"on"</code> (the default) means yes, and a setting of <code>"off"</code>
means no. In most cases, the default of <code>"on"</code> should not be changed,
as setting <code>clip = "off"</code> can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via <code>xlim</code> and <code>ylim</code> and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_axis.percents">axis.percents</code></td>
<td>
<p>Whether to concatenate default axis labels with inertia
percentages.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_sec.axes">sec.axes</code></td>
<td>
<p>Matrix factor character to specify a secondary set of axes.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Numeric value used to scale the secondary axes against
the primary axes; ignored if <code>sec.axes</code> is not specified.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_scale_rows">scale_rows</code>, <code id="ggbiplot_+3A_scale_cols">scale_cols</code></td>
<td>
<p>Either the character name of a numeric variable
in <code>get_*(ordination)</code> or a numeric vector of length
<code>nrow(get_*(ordination))</code>, used to scale the coordinates of the matrix
factors.</p>
</td></tr>
<tr><td><code id="ggbiplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code>; see
<code><a href="#topic+fortify.tbl_ord">fortify.tbl_ord()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggbiplot()</code> produces a <a href="ggplot2.html#topic+ggplot">ggplot</a> object from a <a href="#topic+tbl_ord">tbl_ord</a>
object <code>ordination</code>. The baseline object is the default unadorned
<code>"ggplot"</code>-class object <code>p</code> with the following differences from what
<code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> returns:
</p>

<ul>
<li> <p><code>p$mapping</code> is augmented with <code>.matrix = .matrix</code>, which expects either
<code>.matrix = "rows"</code> or <code>.matrix = "cols"</code> from the biplot.
</p>
</li>
<li> <p><code>p$coordinates</code> is defaulted to <code><a href="ggplot2.html#topic+coord_fixed">ggplot2::coord_equal()</a></code> in order to
faithfully render the geometry of an ordination. The optional parameters
<code>xlim</code>, <code>ylim</code>, <code>expand</code>, and <code>clip</code> are passed to <code>coord_equal()</code> and
default to its <strong>ggplot2</strong> defaults.
</p>
</li>
<li><p> When <code>x</code> or <code>y</code> are mapped to coordinates of <code>ordination</code>, and if
<code>axis.percents</code> is <code>TRUE</code>, <code>p$labels$x</code> or <code>p$labels$y</code> are defaulted to the
coordinate names concatenated with the percentages of <a href="#topic+conference">inertia</a>
captured by the coordinates.
</p>
</li>
<li> <p><code>p</code> is assigned the class <code>"ggbiplot"</code> in addition to <code>"ggplot"</code>. This
serves no functional purpose currently.
</p>
</li></ul>

<p>Furthermore, the user may feed single integer values to the <code>x</code> and <code>y</code>
aesthetics, which will be interpreted as the corresponding coordinates in the
ordination. Currently only 2-dimensional biplots are supported, so both <code>x</code>
and <code>y</code> must take coordinate values.
</p>
<p><code>ord_aes()</code> is a convenience function that generates a full-rank set of
coordinate aesthetics <code>..coord1</code>, <code>..coord2</code>, etc. mapped to the shared
coordinates of the ordination object, along with any additional aesthetics
that are processed internally by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>.
</p>
<p>The <code>axis.type</code> parameter controls whether the biplot is interpolative or
predictive, though predictive biplots are still experimental and limited to
linear methods like PCA. Gower &amp; Hand (1996) and Gower, Gardner&ndash;Lubbe, &amp; le
Roux (2011) thoroughly explain the construction and interpretation of
predictive biplots.
</p>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>References</h3>

<p>Gower JC &amp; Hand DJ (1996) <em>Biplots</em>. Chapman &amp; Hall, ISBN: 0-412-71630-5.
</p>
<p>Gower JC, Gardner&ndash;Lubbe S, &amp; le Roux NJ (2011) <em>Understanding Biplots</em>.
Wiley, ISBN: 978-0-470-01255-0. <a href="https://www.wiley.com/go/biplots">https://www.wiley.com/go/biplots</a>
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot2-package">ggplot2::ggplot2()</a></code>, on which <code>ggbiplot()</code> is built
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute PCA of Anderson iris measurements
iris[, -5] %&gt;%
  princomp(cor = TRUE) %&gt;%
  as_tbl_ord() %&gt;%
  confer_inertia(1) %&gt;%
  mutate_rows(species = iris$Species) %&gt;%
  mutate_cols(measure = gsub("\\.", " ", tolower(names(iris)[-5]))) %&gt;%
  print() -&gt; iris_pca

# row-principal biplot with rescaled secondary axis
iris_pca %&gt;%
  ggbiplot(aes(color = species), sec.axes = "cols", scale.factor = 2) +
  theme_bw() +
  scale_color_brewer(type = "qual", palette = 2) +
  geom_rows_point() +
  geom_cols_vector(color = "#444444") +
  geom_cols_text_radiate(aes(label = measure), color = "#444444") +
  ggtitle(
    "Row-principal PCA biplot of Anderson iris measurements",
    "Variable loadings scaled to secondary axes"
  ) +
  expand_limits(y = c(-1, 3.5))
# Performance measures can be regressed on the artificial coordinates of
# ordinated vehicle specs. Because the ordination of specs ignores performance,
# these coordinates will probably not be highly predictive. The gradient of each
# performance measure along the artificial axes is visualized by projecting the
# regression coefficients onto the ordination biplot.

# scaled principal components analysis of vehicle specs
mtcars_specs_pca &lt;- ordinate(
  mtcars, cols = c(cyl, disp, hp, drat, wt, vs, carb),
  model = ~ princomp(., cor = TRUE)
)
# data frame of vehicle performance measures
mtcars %&gt;%
  subset(select = c(mpg, qsec)) %&gt;%
  as.matrix() %&gt;%
  print() -&gt; mtcars_perf
# regress performance measures on principal components
lm(mtcars_perf ~ get_rows(mtcars_specs_pca)) %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  print() -&gt; mtcars_pca_lm
# regression biplot
ggbiplot(mtcars_specs_pca, aes(label = name),
         sec.axes = "rows", scale.factor = .5) +
  theme_minimal() +
  geom_rows_text(size = 3) +
  geom_cols_vector(data = mtcars_pca_lm) +
  geom_cols_text_radiate(data = mtcars_pca_lm) +
  expand_limits(x = c(-2.5, 2))

# multidimensional scaling based on a scaled cosine distance of vehicle specs
cosine_dist &lt;- function(x) {
  x &lt;- as.matrix(x)
  num &lt;- x %*% t(x)
  denom_rt &lt;- as.matrix(rowSums(x^2))
  denom &lt;- sqrt(denom_rt %*% t(denom_rt))
  as.dist(1 - num / denom)
}
mtcars %&gt;%
  subset(select = c(cyl, disp, hp, drat, wt, vs, carb)) %&gt;%
  scale() %&gt;%
  cosine_dist() %&gt;%
  cmdscale() %&gt;%
  as.data.frame() -&gt;
  mtcars_specs_cmds
# names must be consistent with `cmdscale_ord()` below
names(mtcars_specs_cmds) &lt;- c("PCo1", "PCo2")
# regress performance measures on principal coordinates
lm(mtcars_perf ~ as.matrix(mtcars_specs_cmds)) %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  print() -&gt; mtcars_cmds_lm
# multidimensional scaling using `cmdscale_ord()`
mtcars %&gt;%
  subset(select = c(cyl, disp, hp, drat, wt, vs, carb)) %&gt;%
  scale() %&gt;%
  cosine_dist() %&gt;%
  cmdscale_ord() %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  print() -&gt; mtcars_specs_cmds_ord
# regression biplot
ggbiplot(mtcars_specs_cmds_ord, aes(label = name),
         sec.axes = "rows", scale.factor = 3) +
  theme_minimal() +
  geom_rows_text(size = 3) +
  geom_cols_vector(data = mtcars_cmds_lm) +
  geom_cols_text_radiate(data = mtcars_cmds_lm) +
  expand_limits(x = c(-2.25, 1.25), y = c(-2, 1.5))
# PCA of iris data
iris_pca &lt;- ordinate(iris, cols = 1:4, prcomp, scale = TRUE)

# row-principal predictive biplot
iris_pca %&gt;%
  augment_ord() %&gt;%
  ggbiplot(axis.type = "predictive") +
  theme_bw() +
  scale_color_brewer(type = "qual", palette = 2) +
  geom_cols_axis(aes(label = name, center = center, scale = scale)) +
  geom_rows_point(aes(color = Species), alpha = .5) +
  ggtitle("Predictive biplot of Anderson iris measurements")
</code></pre>

<hr>
<h2 id='glass'>Glass composition data</h2><span id='topic+glass'></span>

<h3>Description</h3>

<p>Sites, types, and compositions of glass samples from
archaeological sites in Israel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glass)
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> with 68 cases and 16 variables:
</p>

<dl>
<dt>Site</dt><dd><p>site at which sample was found</p>
</dd>
<dt>Anal</dt><dd><p>analysis identifier</p>
</dd>
<dt>Context</dt><dd><p>furnace identifier</p>
</dd>
<dt>Form</dt><dd><p>type of sample</p>
</dd>
<dt>SiO2, TiO2, Al2O3, FeO, MnO, MgO, CaO, Na2O, K2O, P2O5, Cl, SO3</dt><dd>
<p>normalized weight percent oxide of each component</p>
</dd>
</dl>



<h3>Details</h3>

<p>Chunks of unformed glass from several furnaces found at the primary
Byzantine-era site of Bet Eli'ezer, along with samples from other sites with
weaker evidence of glass-making (Apollonia and Dor) and and from an
Islamic-era site (Banias), were analyzed using X-ray spectrometry to
determine their major components.
</p>
<p>Baxter &amp; Freestone (2006) used these data to illustrate <a href="#topic+lra-ord">log-ratio analysis</a>.
</p>


<h3>Source</h3>

<p>Freestone &amp;al (2000), Table 2.
</p>


<h3>References</h3>

<p>Freestone IC, Gorin-Rosen Y, &amp; Hughes MJ (2000) &quot;Primary glass from Israel
and the production of glass in Late Antiquity and the early Islamic period&quot;.
<em>La route du verre: Ateliers primaires et secondaires du second millénaire
av. J.-C. au Moyen Âge</em>: 65&ndash;83.
<a href="https://pascal-francis.inist.fr/vibad/index.php?action=getRecordDetail&amp;idt=1158762">https://pascal-francis.inist.fr/vibad/index.php?action=getRecordDetail&amp;idt=1158762</a>
</p>
<p>Baxter MJ &amp; Freestone IC (2006) &quot;Log-Ratio Compositional Data Analysis in
Archaeometry&quot;. <em>Archaeometry</em>, <strong>48</strong>(3): 511&ndash;531.
<a href="https://doi.org/10.1111/j.1475-4754.2006.00270.x">doi:10.1111/j.1475-4754.2006.00270.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset glass data to one site and major components
head(glass)
glass_main &lt;- subset(
  glass,
  Site == "Bet Eli'ezer",
  select = c("SiO2", "Na2O", "CaO", "Al2O3", "MgO", "K2O")
)
# format as a data frame with row names
glass_main &lt;- as.data.frame(glass_main)
rownames(glass_main) &lt;- subset(glass, Site == "Bet Eli'ezer")$Anal

# perform log-ratio analysis
glass_lra &lt;- lra(glass_main, compositional = TRUE, weighted = FALSE)
# inspect LRA row and column coordinates
head(glass_lra$row.coords)
glass_lra$column.coords
# inspect singular values of LRA
glass_lra$sv

# plot samples and measurements in a biplot
biplot(
  x = glass_lra$row.coords %*% diag(glass_lra$sv),
  y = glass_lra$column.coords,
  xlab = "Sample (principal coord.)", ylab = ""
)
mtext("Component (standard coord.)", side = 4L, line = 3L)
</code></pre>

<hr>
<h2 id='lda-ord'>Augmented implementation of linear discriminant analysis</h2><span id='topic+lda-ord'></span><span id='topic+lda_ord'></span><span id='topic+lda_ord.formula'></span><span id='topic+lda_ord.data.frame'></span><span id='topic+lda_ord.matrix'></span><span id='topic+lda_ord.default'></span><span id='topic+predict.lda_ord'></span>

<h3>Description</h3>

<p>This function replicates <code><a href="MASS.html#topic+lda">MASS::lda()</a></code> with options to retain
elements useful to the <a href="#topic+tbl_ord">tbl_ord</a> class and biplot calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lda_ord(x, ...)

## S3 method for class 'formula'
lda_ord(formula, data, ..., subset, na.action)

## S3 method for class 'data.frame'
lda_ord(x, ...)

## S3 method for class 'matrix'
lda_ord(x, grouping, ..., subset, na.action)

## Default S3 method:
lda_ord(
  x,
  grouping,
  prior = proportions,
  tol = 1e-04,
  method = c("moment", "mle", "mve", "t"),
  CV = FALSE,
  nu = 5,
  ...,
  ret.x = FALSE,
  ret.grouping = FALSE,
  axes.scale = "unstandardized"
)

## S3 method for class 'lda_ord'
predict(
  object,
  newdata,
  prior = object$prior,
  dimen,
  method = c("plug-in", "predictive", "debiased"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lda-ord_+3A_x">x</code></td>
<td>

<p>(required if no formula is given as the principal argument.)
a matrix or data frame or Matrix containing the explanatory variables.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_...">...</code></td>
<td>

<p>arguments passed to or from other methods.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_formula">formula</code></td>
<td>

<p>A formula of the form <code>groups ~ x1 + x2 + ...</code>  That is, the
response is the grouping factor and the right hand side specifies
the (non-factor) discriminators.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_data">data</code></td>
<td>

<p>An optional data frame, list or environment from which variables
specified in <code>formula</code> are preferentially to be taken.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_subset">subset</code></td>
<td>

<p>An index vector specifying the cases to be used in the training
sample.  (NOTE: If given, this argument must be named.)
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_na.action">na.action</code></td>
<td>

<p>A function to specify the action to be taken if <code>NA</code>s are found.
The default action is for the procedure to fail.  An alternative is
<code>na.omit</code>, which leads to rejection of cases with missing values on
any required variable.  (NOTE: If given, this argument must be named.)
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_grouping">grouping</code></td>
<td>

<p>(required if no formula principal argument is given.)
a factor specifying the class for each observation.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_prior">prior</code></td>
<td>

<p>the prior probabilities of class membership.  If unspecified, the
class proportions for the training set are used.  If present, the
probabilities should be specified in the order of the factor
levels.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_tol">tol</code></td>
<td>

<p>A tolerance to decide if a matrix is singular; it will reject variables
and linear combinations of unit-variance variables whose variance is
less than <code>tol^2</code>.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_method">method</code></td>
<td>

<p><code>"moment"</code> for standard estimators of the mean and variance,
<code>"mle"</code> for MLEs, <code>"mve"</code> to use <code><a href="MASS.html#topic+cov.mve">cov.mve</a></code>, or
<code>"t"</code> for robust estimates based on a <code class="reqn">t</code> distribution.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_cv">CV</code></td>
<td>

<p>If true, returns results (classes and posterior probabilities) for
leave-one-out cross-validation. Note that if the prior is estimated,
the proportions in the whole dataset are used.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_nu">nu</code></td>
<td>

<p>degrees of freedom for <code>method = "t"</code>.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_ret.x">ret.x</code>, <code id="lda-ord_+3A_ret.grouping">ret.grouping</code></td>
<td>
<p>Logical; whether to retain as attributes the data
matrix (<code>x</code>) and the class assignments (<code>grouping</code>) on which LDA is
performed. Methods like <code>predict()</code> access these objects by name in the
parent environment, and retaining them as attributes prevents errors that
arise if these objects are reassigned.</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_axes.scale">axes.scale</code></td>
<td>
<p>Character string indicating how to left-transform the
<code>scaling</code> value when rendering biplots using <code><a href="#topic+ggbiplot">ggbiplot()</a></code>. Options include
<code>"unstandardized"</code>, <code>"standardized"</code>, and <code>"contribution"</code>.</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_object">object</code></td>
<td>

<p>object  of class <code>"lda"</code>
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_newdata">newdata</code></td>
<td>

<p>data frame of cases to be classified or, if <code>object</code>
has a formula, a data frame with columns of the same names as the
variables used.  A vector will be interpreted
as a row vector.  If newdata is missing, an attempt will be
made to retrieve the data used to fit the <code>lda</code> object.
</p>
</td></tr>
<tr><td><code id="lda-ord_+3A_dimen">dimen</code></td>
<td>

<p>the dimension of the space to be used. If this is less than <code>min(p, ng-1)</code>,
only the first <code>dimen</code> discriminant components are used (except for
<code>method="predictive"</code>), and only those dimensions are returned in <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linear discriminant analysis relies on an eigendecomposition of the product
<code class="reqn">W^{-1}B</code> of the inverse of the within-class covariance matrix <code class="reqn">W</code> by
the between-class covariance matrix <code class="reqn">B</code>. This eigendecomposition can be
motivated as the right (<code class="reqn">V</code>) half of the singular value decomposition of
the matrix of <em>Mahalanobis distances</em> between the cases after &quot;sphering&quot;
(linearly transforming them so that the within-class covariance is the
identity matrix). LDA are not traditionally represented as biplots, with some
exceptions (Gardner &amp; le Roux, 2005; Greenacre, 2010, p. 109&ndash;117).
</p>
<p>LDA is implemented as <code><a href="MASS.html#topic+lda">MASS::lda()</a></code> in the <strong>MASS</strong> package, in which the
variables are transformed by a sphering matrix <code class="reqn">S</code> (Venables &amp; Ripley,
2003, p. 331&ndash;333). The returned element <code>scaling</code> contains the
unstandardized <em>discriminant coefficients</em>, which define the discriminant
scores of the cases and their centroids as linear combinations of the
original variables.
</p>
<p>The discriminant coefficients constitute one of several possible choices of
axes for a biplot representation of the LDA. The slightly modified function
<code><a href="#topic+lda_ord">lda_ord()</a></code> provides additional options:
</p>

<ul>
<li><p> The <em>standardized discriminant coefficients</em> are obtained by (re)scaling
the coefficients by the variable standard deviations. These coefficients
indicate the contributions of the variables to the discriminant scores after
controlling for their variances (Orlov, 2013).
</p>
</li>
<li><p> The variables' <em>contributions</em> to the Mahalanobis variance along each
discriminant axis are obtained by transforming the coefficients by the
inverse of the sphering matrix <code class="reqn">S</code>. Because the contribution biplot
derives from the eigendecomposition of the Mahalanobis distance matrix, the
projections of the centroids and cases onto the variable axes approximate
their variable values after centering and sphering (Greenacre, 2013).
</p>
</li></ul>



<h3>Value</h3>

<p>Output from <code><a href="MASS.html#topic+lda">MASS::lda()</a></code> with an additional preceding <a href="base.html#topic+class">class</a>
'lda_ord' and up to three <a href="base.html#topic+attributes">attributes</a>:
</p>

<ul>
<li><p> the input data <code>x</code>, if <code>ret.x = TRUE</code>
</p>
</li>
<li><p> the class assignments <code>grouping</code>, if <code>ret.grouping = TRUE</code>
</p>
</li>
<li><p> if the parameter <code>axes.scale</code> is not 'unstandardized', a matrix
<code>axes.scale</code> that encodes the transformation of the row space
</p>
</li></ul>



<h3>References</h3>

<p>Gardner S &amp; le Roux NJ (2005) &quot;Extensions of Biplot Methodology to
Discriminant Analysis&quot;. <em>Journal of Classification</em> <strong>22</strong>(1): 59&ndash;86.
<a href="https://doi.org/10.1007/s00357-005-0006-7">doi:10.1007/s00357-005-0006-7</a>
<a href="https://link.springer.com/article/10.1007/s00357-005-0006-7">https://link.springer.com/article/10.1007/s00357-005-0006-7</a>
</p>
<p>Greenacre MJ (2010) <em>Biplots in Practice</em>. Fundacion BBVA, ISBN:
978-84-923846.
<a href="https://www.fbbva.es/microsite/multivariate-statistics/biplots.html">https://www.fbbva.es/microsite/multivariate-statistics/biplots.html</a>
</p>
<p>Venables WN &amp; Ripley BD (2003) <em>Modern Applied Statistics with S</em>, Fourth
Edition. Springer Science &amp; Business Media, ISBN: 0387954570, 9780387954578.
<a href="https://www.mimuw.edu.pl/~pokar/StatystykaMgr/Books/VenablesRipley_ModernAppliedStatisticsS02.pdf">https://www.mimuw.edu.pl/~pokar/StatystykaMgr/Books/VenablesRipley_ModernAppliedStatisticsS02.pdf</a>
</p>
<p>Orlov K (2013) <em>Answer to</em> &quot;Algebra of LDA. Fisher discrimination power of a
variable and Linear Discriminant Analysis&quot;. CrossValidated, accessed
2019-07-26. <a href="https://stats.stackexchange.com/a/83114/68743">https://stats.stackexchange.com/a/83114/68743</a>
</p>
<p>Greenacre M (2013) &quot;Contribution Biplots&quot;. <em>Journal of Computational and
Graphical Statistics</em>, <strong>22</strong>(1): 107&ndash;122.
<a href="https://amstat.tandfonline.com/doi/full/10.1080/10618600.2012.702494">https://amstat.tandfonline.com/doi/full/10.1080/10618600.2012.702494</a>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+lda">MASS::lda()</a></code>, from which <code>lda_ord()</code> is adapted
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Anderson iris species data centroid
iris_centroid &lt;- t(apply(iris[, 1:4], 2, mean))
# unstandardized discriminant coefficients: the discriminant axes are linear
# combinations of the centered variables
iris_lda &lt;- lda_ord(iris[, 1:4], iris[, 5], axes.scale = "unstandardized")
# linear combinations of centered variables
print(sweep(iris_lda$means, 2, iris_centroid, "-") %*% get_cols(iris_lda))
# discriminant centroids
print(get_rows(iris_lda, elements = "active"))

# unstandardized coefficient LDA biplot
iris_lda %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  mutate_rows(
    species = grouping,
    discriminant = ifelse(.element == "active", "centroid", "case")
  ) %&gt;%
  ggbiplot() +
  theme_bw() +
  geom_rows_point(aes(
    color = grouping,
    size = discriminant, alpha = discriminant
  )) +
  geom_cols_vector(color = "#888888") +
  geom_cols_text_radiate(aes(label = name), size = 3) +
  scale_color_brewer(type = "qual", palette = 2) +
  ggtitle("Unstandardized coefficient biplot of iris LDA") +
  expand_limits(y = c(-3, 5))

# standardized discriminant coefficients: permit comparisons across the
# variables
iris_lda &lt;- lda_ord(iris[, 1:4], iris[, 5], axes.scale = "standardized")
# standardized variable contributions to discriminant axes
iris_lda %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  fortify(.matrix = "cols") %&gt;%
  dplyr::mutate(variable = name) %&gt;%
  tidyr::gather(discriminant, coefficient, LD1, LD2) %&gt;%
  ggplot(aes(x = discriminant, y = coefficient, fill = variable)) +
  geom_bar(position = "dodge", stat = "identity") +
  labs(y = "Standardized coefficient", x = "Linear discriminant") +
  theme_bw() +
  coord_flip()
# standardized coefficient LDA biplot
iris_lda %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  mutate_rows(
    species = grouping,
    discriminant = ifelse(.element == "active", "centroid", "case")
  ) %&gt;%
  ggbiplot() +
  theme_bw() +
  geom_rows_point(aes(
    color = grouping,
    size = discriminant, alpha = discriminant
  )) +
  geom_cols_vector(color = "#888888") +
  geom_cols_text_radiate(aes(label = name), size = 3) +
  scale_color_brewer(type = "qual", palette = 2) +
  ggtitle("Standardized coefficient biplot of iris LDA") +
  expand_limits(y = c(-2, 3))

# variable contributions (de-sphered discriminant coefficients): recover the
# inner product relationship with the centered class centroids
iris_lda &lt;- lda_ord(iris[, 1:4], iris[, 5], axes.scale = "contribution")
# symmetric square root of within-class covariance
C_W_eig &lt;- eigen(cov(iris[, 1:4] - iris_lda$means[iris[, 5], ]))
C_W_sqrtinv &lt;-
  C_W_eig$vectors %*% diag(1/sqrt(C_W_eig$values)) %*% t(C_W_eig$vectors)
# product of matrix factors (scores and loadings)
print(get_rows(iris_lda, elements = "active") %*% t(get_cols(iris_lda)))
# "asymmetric" square roots of Mahalanobis distances between variables
print(sweep(iris_lda$means, 2, iris_centroid, "-") %*% C_W_sqrtinv)
# contribution LDA biplot
iris_lda %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  mutate_rows(
    species = grouping,
    discriminant = ifelse(.element == "active", "centroid", "case")
  ) %&gt;%
  ggbiplot() +
  theme_bw() +
  geom_rows_point(aes(
    color = grouping,
    size = discriminant, alpha = discriminant
  )) +
  geom_cols_vector(color = "#888888") +
  geom_cols_text_radiate(aes(label = name), size = 3) +
  scale_color_brewer(type = "qual", palette = 2) +
  ggtitle("Contribution biplot of iris LDA") +
  expand_limits(y = c(-2, 3.5))
</code></pre>

<hr>
<h2 id='lra-ord'>Log-ratio analysis</h2><span id='topic+lra-ord'></span><span id='topic+lra'></span><span id='topic+print.lra'></span><span id='topic+screeplot.lra'></span><span id='topic+biplot.lra'></span><span id='topic+plot.lra'></span>

<h3>Description</h3>

<p>Represent log-ratios between variables based on their values on
a population of cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lra(x, compositional = FALSE, weighted = TRUE)

## S3 method for class 'lra'
print(x, nd = length(x$sv), n = 6L, ...)

## S3 method for class 'lra'
screeplot(x, main = deparse1(substitute(x)), ...)

## S3 method for class 'lra'
biplot(
  x,
  choices = c(1L, 2L),
  scale = c(0, 0),
  main = deparse1(substitute(x)),
  var.axes = FALSE,
  ...
)

## S3 method for class 'lra'
plot(x, main = deparse1(substitute(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lra-ord_+3A_x">x</code></td>
<td>
<p>A numeric matrix or rectangular data set.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_compositional">compositional</code></td>
<td>
<p>Logical; whether to normalize rows of <code>x</code> to sum to 1.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_weighted">weighted</code></td>
<td>
<p>Logical; whether to weight rows and columns by their sums.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_nd">nd</code></td>
<td>
<p>Integer; number of shared dimensions to include in print.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_n">n</code></td>
<td>
<p>Integer; number of rows of each factor to print.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_main">main</code>, <code id="lra-ord_+3A_var.axes">var.axes</code>, <code id="lra-ord_+3A_...">...</code></td>
<td>
<p>Parameters passed to other plotting methods (in the
case of <code>main</code>, after being <code><a href="base.html#topic+force">force()</a></code>d.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_choices">choices</code></td>
<td>
<p>Integer; length-2 vector specifying the components to plot.</p>
</td></tr>
<tr><td><code id="lra-ord_+3A_scale">scale</code></td>
<td>
<p>Numeric; values between 0 and 1 that control how inertia is
conferred unto the points: Row (<code>i = 1L</code>) and column (<code>i = 2L</code>) coordinates
are scaled by <code>sv ^ scale[[i]]</code>. If a single value <code>scale</code> is passed, it is
assigned to the rows while <code>1 - scale</code> is assigned to the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Log-ratio analysis (LRA) is based on a double-centering of log-transformed
data, usually weighted by row and column totals. The technique is suitable
for positive-valued variables on a common scale (e.g. percentages). The
distances between variables' coordinates (in the full-dimensional space) are
their pairwise log-ratios. The distances between cases' coordinates are
called their <em>log-ratio distances</em>, and the total variance is the weighted
sum of their squares.
</p>
<p>LRA is not implemented in standard R distributions but is a useful member of
the ordination toolkit. This is a minimal implementation following
Greenacre's (2010) exposition in Chapter 7.
</p>


<h3>Value</h3>

<p>Given an <code class="reqn">n * p</code> data matrix and setting <code class="reqn">r=min(n,p)</code>,
<code>lra()</code> returns a list of class <code>"lra"</code> containing three elements:
</p>

<ul>
<li><p>svThe <code class="reqn">r-1</code> singular values
</p>
</li>
<li><p>row.coordsThe <code class="reqn">n * (r-1)</code> matrix
of row standard coordinates.
</p>
</li>
<li><p>column.coordsThe <code class="reqn">p * (r-1)</code> matrix
of column standard coordinates.
</p>
</li>
<li><p>row.weightsThe weights used to scale the row coordinates.
</p>
</li>
<li><p>column.weightsThe weights used to scale the column coordinates.
</p>
</li></ul>



<h3>References</h3>

<p>Greenacre MJ (2010) <em>Biplots in Practice</em>. Fundacion BBVA, ISBN:
978-84-923846.
<a href="https://www.fbbva.es/microsite/multivariate-statistics/biplots.html">https://www.fbbva.es/microsite/multivariate-statistics/biplots.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># U.S. 1973 violent crime arrests
head(USArrests)
# row and column subsets
state_examples &lt;- c("Hawaii", "Mississippi", "North Dakota")
arrests &lt;- c(1L, 2L, 4L)

# pairwise log-ratios of violent crime arrests for two states
arrest_pairs &lt;- combn(arrests, 2L)
arrest_ratios &lt;-
  USArrests[, arrest_pairs[1L, ]] / USArrests[, arrest_pairs[2L, ]]
colnames(arrest_ratios) &lt;- paste(
  colnames(USArrests)[arrest_pairs[1L, ]], "/",
  colnames(USArrests)[arrest_pairs[2L, ]], sep = ""
)
arrest_logratios &lt;- log(arrest_ratios)
arrest_logratios[state_examples, ]

# non-compositional log-ratio analysis
(arrests_lra &lt;- lra(USArrests[, arrests]))
screeplot(arrests_lra)
biplot(arrests_lra, scale = c(1, 0))

# compositional log-ratio analysis
(arrests_lra &lt;- lra(USArrests[, arrests], compositional = TRUE))
biplot(arrests_lra, scale = c(1, 0))
</code></pre>

<hr>
<h2 id='methods-cancor'>Functionality for canonical correlations</h2><span id='topic+methods-cancor'></span><span id='topic+as_tbl_ord.cancor_ord'></span><span id='topic+recover_rows.cancor_ord'></span><span id='topic+recover_cols.cancor_ord'></span><span id='topic+recover_inertia.cancor_ord'></span><span id='topic+recover_coord.cancor_ord'></span><span id='topic+recover_conference.cancor_ord'></span><span id='topic+recover_supp_rows.cancor_ord'></span><span id='topic+recover_supp_cols.cancor_ord'></span><span id='topic+recover_aug_rows.cancor_ord'></span><span id='topic+recover_aug_cols.cancor_ord'></span><span id='topic+recover_aug_coord.cancor_ord'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"cancor_ord"</code>. This is a class introduced in this package
to identify objects returned by <code><a href="#topic+cancor_ord">cancor_ord()</a></code>, which wraps
<code><a href="stats.html#topic+cancor">stats::cancor()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cancor_ord'
as_tbl_ord(x)

## S3 method for class 'cancor_ord'
recover_rows(x)

## S3 method for class 'cancor_ord'
recover_cols(x)

## S3 method for class 'cancor_ord'
recover_inertia(x)

## S3 method for class 'cancor_ord'
recover_coord(x)

## S3 method for class 'cancor_ord'
recover_conference(x)

## S3 method for class 'cancor_ord'
recover_supp_rows(x)

## S3 method for class 'cancor_ord'
recover_supp_cols(x)

## S3 method for class 'cancor_ord'
recover_aug_rows(x)

## S3 method for class 'cancor_ord'
recover_aug_cols(x)

## S3 method for class 'cancor_ord'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-cancor_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The canonical coefficients (loadings) are obtained directly from the
underlying singular value decomposition and constitute the active elements.
If canonical scores are returned, then they and the structure correlations
are made available as supplementary elements. <strong>ordr</strong> takes rows and columns
from the intraset correlations <code style="white-space: pre;">&#8288;$xstructure&#8288;</code> and <code style="white-space: pre;">&#8288;$ystructure&#8288;</code>, on which no
intertia is conferred; the interset correlations can be obtained by
<a href="#topic+conference">conferring inertia</a> onto these.
</p>
<p>A biplot of the canonical coefficients can be interpreted as approximating
the <code class="reqn">X</code>-<code class="reqn">Y</code> inner product matrix, inversely weighted by the <code class="reqn">X</code>
and <code class="reqn">Y</code> variances. The canonical scores and structure coefficients are
available as supplementary points if returned by <code><a href="#topic+cancor_ord">cancor_ord()</a></code>. These can be
used to create biplots of the case scores as linear combinations of loadings
(the coefficients, in standard coordinates, overlaid with the scores) or of
intraset and interset correlations with respect to either data set (the
correlations with inertia conferred entirely onto rows or onto columns).
Greenacre (1984) and ter Braak (1990) describe these families, though ter
Braak recommends against the first.
</p>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>References</h3>

<p>Greenacre MJ (1984) <em>Theory and applications of correspondence analysis</em>.
London: Academic Press, ISBN 0-12-299050-1.
<a href="http://www.carme-n.org/?sec=books5">http://www.carme-n.org/?sec=books5</a>
</p>
<p>ter Braak CJF (1990) &quot;Interpreting canonical correlation analysis through
biplots of structure correlations and weights&quot;. <em>Psychometrika</em> 55(3),
519&ndash;531. <a href="https://doi.org/10.1007/BF02294765">doi:10.1007/BF02294765</a>
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>,
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>,
<code><a href="#topic+methods-lm">methods-lm</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of life-cycle savings across countries
class(LifeCycleSavings)
head(LifeCycleSavings)
savings_pop &lt;- LifeCycleSavings[, c("pop15", "pop75")]
savings_oec &lt;- LifeCycleSavings[, c("sr", "dpi", "ddpi")]

# canonical correlation analysis with scores and correlations included
savings_cca &lt;- cancor_ord(savings_pop, savings_oec, scores = TRUE)
savings_cca &lt;- augment_ord(as_tbl_ord(savings_cca))
head(get_cols(savings_cca))
head(get_cols(savings_cca, elements = "score"))
get_rows(savings_cca, elements = "structure")
get_cols(savings_cca, elements = "structure")

# biplot of interset and intraset correlations with the population data
savings_cca %&gt;%
  confer_inertia("cols") %&gt;%
  ggbiplot(aes(label = name, color = .matrix)) +
  theme_bw() + theme_biplot() +
  geom_unit_circle() +
  geom_rows_vector(arrow = NULL, elements = "structure") +
  geom_cols_vector(arrow = NULL, elements = "structure", linetype = "dashed") +
  geom_rows_text(elements = "structure", hjust = "outward") +
  geom_cols_text(elements = "structure", hjust = "outward") +
  scale_color_brewer(limits = c("rows", "cols"), type = "qual") +
  expand_limits(x = c(-1, 1), y = c(-1, 1))

# biplot with scores as supplemental elements
savings_cca %&gt;%
  confer_inertia("rows") %&gt;%
  ggbiplot(aes(label = name), sec.axes = "cols", scale.factor = 5L) +
  theme_biplot() +
  geom_cols_vector(elements = "active") +
  geom_cols_text_radiate(elements = "active") +
  geom_rows_text(elements = "score", subset = seq(50L))
</code></pre>

<hr>
<h2 id='methods-cmds'>Functionality for classical multidimensional scaling objects</h2><span id='topic+methods-cmds'></span><span id='topic+as_tbl_ord.cmds_ord'></span><span id='topic+recover_rows.cmds_ord'></span><span id='topic+recover_cols.cmds_ord'></span><span id='topic+recover_inertia.cmds_ord'></span><span id='topic+recover_coord.cmds_ord'></span><span id='topic+recover_conference.cmds_ord'></span><span id='topic+recover_aug_rows.cmds_ord'></span><span id='topic+recover_aug_cols.cmds_ord'></span><span id='topic+recover_aug_coord.cmds_ord'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"cmds_ord"</code>. This is a class introduced in this package
to identify objects returned by <code><a href="#topic+cmdscale_ord">cmdscale_ord()</a></code>, which wraps
<code><a href="stats.html#topic+cmdscale">stats::cmdscale()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmds_ord'
as_tbl_ord(x)

## S3 method for class 'cmds_ord'
recover_rows(x)

## S3 method for class 'cmds_ord'
recover_cols(x)

## S3 method for class 'cmds_ord'
recover_inertia(x)

## S3 method for class 'cmds_ord'
recover_coord(x)

## S3 method for class 'cmds_ord'
recover_conference(x)

## S3 method for class 'cmds_ord'
recover_aug_rows(x)

## S3 method for class 'cmds_ord'
recover_aug_cols(x)

## S3 method for class 'cmds_ord'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-cmds_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for eigen-decomposition-based techniques: 
<code><a href="#topic+methods-eigen">methods-eigen</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>,
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>,
<code><a href="#topic+methods-lm">methods-lm</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 'dist' object (matrix of road distances) of large American cities
class(UScitiesD)
print(UScitiesD)

# use multidimensional scaling to infer artificial planar coordinates
UScitiesD %&gt;%
  cmdscale_ord(k = 2) %&gt;%
  as_tbl_ord() %&gt;%
  print() -&gt; usa_mds

# recover (equivalent) matrices of row and column artificial coordinates
get_rows(usa_mds)
get_cols(usa_mds)

# augment ordination with point names
(usa_mds &lt;- augment_ord(usa_mds))

# reorient biplot to conventional compass
usa_mds %&gt;%
  negate_ord(c(1, 2)) %&gt;%
  ggbiplot() +
  geom_cols_text(aes(label = name), size = 3) +
  ggtitle("MDS biplot of distances between U.S. cities")
</code></pre>

<hr>
<h2 id='methods-correspondence'>Functionality for correspondence analysis ('correspondence') objects</h2><span id='topic+methods-correspondence'></span><span id='topic+as_tbl_ord.correspondence'></span><span id='topic+recover_rows.correspondence'></span><span id='topic+recover_cols.correspondence'></span><span id='topic+recover_inertia.correspondence'></span><span id='topic+recover_conference.correspondence'></span><span id='topic+recover_coord.correspondence'></span><span id='topic+recover_aug_rows.correspondence'></span><span id='topic+recover_aug_cols.correspondence'></span><span id='topic+recover_aug_coord.correspondence'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"correspondence"</code> from the <strong><a href="MASS.html#topic+corresp">MASS</a></strong>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'correspondence'
as_tbl_ord(x)

## S3 method for class 'correspondence'
recover_rows(x)

## S3 method for class 'correspondence'
recover_cols(x)

## S3 method for class 'correspondence'
recover_inertia(x)

## S3 method for class 'correspondence'
recover_conference(x)

## S3 method for class 'correspondence'
recover_coord(x)

## S3 method for class 'correspondence'
recover_aug_rows(x)

## S3 method for class 'correspondence'
recover_aug_cols(x)

## S3 method for class 'correspondence'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-correspondence_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>
<p>Other models from the MASS package: 
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># table of hair and eye color data collapsed by sex
data(quine, package = "MASS")
class(quine)
head(quine)

# use correspondence analysis to construct row and column profiles
(quine_ca &lt;- MASS::corresp(~ Age + Eth, data = quine))
(quine_ca &lt;- as_tbl_ord(quine_ca))

# recover row and column profiles
get_rows(quine_ca)
get_cols(quine_ca)

# augment profiles with names, masses, distances, and inertias
(quine_ca &lt;- augment_ord(quine_ca))
</code></pre>

<hr>
<h2 id='methods-eigen'>Functionality for eigen-decompositions</h2><span id='topic+methods-eigen'></span><span id='topic+as_tbl_ord.eigen'></span><span id='topic+recover_rows.eigen'></span><span id='topic+recover_cols.eigen'></span><span id='topic+recover_inertia.eigen'></span><span id='topic+recover_coord.eigen'></span><span id='topic+recover_conference.eigen'></span><span id='topic+recover_aug_rows.eigen_ord'></span><span id='topic+recover_aug_cols.eigen_ord'></span><span id='topic+recover_aug_coord.eigen'></span><span id='topic+as_tbl_ord.eigen_ord'></span><span id='topic+recover_rows.eigen_ord'></span><span id='topic+recover_cols.eigen_ord'></span><span id='topic+recover_inertia.eigen_ord'></span><span id='topic+recover_coord.eigen_ord'></span><span id='topic+recover_conference.eigen_ord'></span><span id='topic+recover_aug_coord.eigen_ord'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"eigen"</code> returned by <code><a href="base.html#topic+eigen">base::eigen()</a></code> when the parameter
<code>only.values</code> is set to <code>FALSE</code> or of class <code>"eigen_ord"</code> returned by
<code><a href="#topic+eigen_ord">eigen_ord()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eigen'
as_tbl_ord(x)

## S3 method for class 'eigen'
recover_rows(x)

## S3 method for class 'eigen'
recover_cols(x)

## S3 method for class 'eigen'
recover_inertia(x)

## S3 method for class 'eigen'
recover_coord(x)

## S3 method for class 'eigen'
recover_conference(x)

## S3 method for class 'eigen_ord'
recover_aug_rows(x)

## S3 method for class 'eigen_ord'
recover_aug_cols(x)

## S3 method for class 'eigen'
recover_aug_coord(x)

## S3 method for class 'eigen_ord'
as_tbl_ord(x)

## S3 method for class 'eigen_ord'
recover_rows(x)

## S3 method for class 'eigen_ord'
recover_cols(x)

## S3 method for class 'eigen_ord'
recover_inertia(x)

## S3 method for class 'eigen_ord'
recover_coord(x)

## S3 method for class 'eigen_ord'
recover_conference(x)

## S3 method for class 'eigen_ord'
recover_aug_rows(x)

## S3 method for class 'eigen_ord'
recover_aug_cols(x)

## S3 method for class 'eigen_ord'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-eigen_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+eigen">base::eigen()</a></code> usually returns an object of class <code>"eigen"</code>, which contains
the numerical eigendecomposition without annotations such as row and column
names. To facilitate downstream analysis, <code><a href="#topic+eigen_ord">eigen_ord()</a></code> returns a modified
'eigen' object with row names taken (if available) from the original data and
column names indicating the integer index of each eigenvector.
</p>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for eigen-decomposition-based techniques: 
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>
</p>
<p>Other models from the base package: 
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset QS data to rank variables
qs_ranks &lt;- subset(
  qswur_usa,
  complete.cases(qswur_usa),
  select = 8:13
)
head(qs_ranks)

# eigendecomposition of Kendall correlation matrix
qs_ranks %&gt;%
  cor(method = "kendall") %&gt;%
  eigen() %&gt;%
  print() -&gt; qs_eigen

# recover eigenvectors
get_rows(qs_eigen)
identical(get_cols(qs_eigen), get_rows(qs_eigen))

# wrap as a 'tbl_ord'
as_tbl_ord(qs_eigen)

# same eigendecomposition, preserving row names and adding column names
qs_ranks %&gt;%
  cor(method = "kendall") %&gt;%
  eigen_ord() %&gt;%
  print() -&gt; qs_eigen

# wrap as a 'tbl_ord' and augment with dimension names
augment_ord(as_tbl_ord(qs_eigen))

# decomposition returns pure eigenvectors
get_conference(qs_eigen)
</code></pre>

<hr>
<h2 id='methods-factanal'>Functionality for factor analysis ('factanal') objects</h2><span id='topic+methods-factanal'></span><span id='topic+as_tbl_ord.factanal'></span><span id='topic+recover_rows.factanal'></span><span id='topic+recover_cols.factanal'></span><span id='topic+recover_inertia.factanal'></span><span id='topic+recover_coord.factanal'></span><span id='topic+recover_conference.factanal'></span><span id='topic+recover_supp_rows.factanal'></span><span id='topic+recover_aug_rows.factanal'></span><span id='topic+recover_aug_cols.factanal'></span><span id='topic+recover_aug_coord.factanal'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"factanal"</code> as returned by <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factanal'
as_tbl_ord(x)

## S3 method for class 'factanal'
recover_rows(x)

## S3 method for class 'factanal'
recover_cols(x)

## S3 method for class 'factanal'
recover_inertia(x)

## S3 method for class 'factanal'
recover_coord(x)

## S3 method for class 'factanal'
recover_conference(x)

## S3 method for class 'factanal'
recover_supp_rows(x)

## S3 method for class 'factanal'
recover_aug_rows(x)

## S3 method for class 'factanal'
recover_aug_cols(x)

## S3 method for class 'factanal'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-factanal_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factor analysis of a data matrix relies on an an eigendecomposition of its
correlation matrix, whose eigenvectors (up to weighting) comprise the
variable loadings. For this reason, both row and column recoverers retrieve
the loadings and inertia is evenly distributed between them. When computed
and returned by <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>, the case scores are accessible as
supplementary elements. Redistribution of inertia commutes through both
score calculations.
</p>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for eigen-decomposition-based techniques: 
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-eigen">methods-eigen</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>,
<code><a href="#topic+methods-lm">methods-lm</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of Swiss fertility and socioeconomic indicators
class(swiss)
head(swiss)
# perform factor analysis
swiss_fa &lt;- factanal(~ ., factors = 2L, data = swiss, scores = "regression")

# wrap as a 'tbl_ord' object
(swiss_fa &lt;- as_tbl_ord(swiss_fa))

# recover loadings
get_rows(swiss_fa, elements = "active")
get_cols(swiss_fa)
# recover scores
head(get_rows(swiss_fa, elements = "score"))

# augment column loadings with uniquenesses
(swiss_fa &lt;- augment_ord(swiss_fa))

# symmetric biplot
swiss_fa %&gt;%
  ggbiplot() +
  theme_bw() +
  geom_cols_vector(aes(color = uniqueness)) +
  geom_cols_text_radiate(aes(label = name)) +
  expand_limits(x = c(-2, 2.5), y = c(-1.5, 2))
</code></pre>

<hr>
<h2 id='methods-kmeans'>Functionality for k-means clustering ('kmeans') objects</h2><span id='topic+methods-kmeans'></span><span id='topic+as_tbl_ord.kmeans'></span><span id='topic+recover_rows.kmeans'></span><span id='topic+recover_cols.kmeans'></span><span id='topic+recover_coord.kmeans'></span><span id='topic+recover_aug_rows.kmeans'></span><span id='topic+recover_aug_cols.kmeans'></span><span id='topic+recover_aug_coord.kmeans'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"kmeans"</code> as returned by <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans'
as_tbl_ord(x)

## S3 method for class 'kmeans'
recover_rows(x)

## S3 method for class 'kmeans'
recover_cols(x)

## S3 method for class 'kmeans'
recover_coord(x)

## S3 method for class 'kmeans'
recover_aug_rows(x)

## S3 method for class 'kmeans'
recover_aug_cols(x)

## S3 method for class 'kmeans'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-kmeans_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for idiosyncratic techniques: 
<code><a href="#topic+methods-lm">methods-lm</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>,
<code><a href="#topic+methods-lm">methods-lm</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of Anderson iris species measurements
class(iris)
head(iris)
# compute 3-means clustering on scaled iris measurements
set.seed(5601L)
iris %&gt;%
  subset(select = -Species) %&gt;%
  scale() %&gt;%
  kmeans(centers = 3) %&gt;%
  print() -&gt; iris_km

# visualize clusters using PCA
iris %&gt;%
  subset(select = -Species) %&gt;%
  prcomp() %&gt;%
  as_tbl_ord() %&gt;%
  mutate_rows(cluster = iris_km$cluster) %&gt;%
  ggbiplot() +
  geom_rows_point(aes(color = factor(as.character(as.integer(cluster)),
                                     levels = as.character(seq(3L))))) +
  scale_color_brewer(type = "qual", name = "cluster")

# wrap as a 'tbl_ord' object
(iris_km_ord &lt;- as_tbl_ord(iris_km))

# augment everything with names, observations with cluster assignment
(iris_km_ord &lt;- augment_ord(iris_km_ord))

# summarize clusters with standard deviation
iris_km_ord %&gt;%
  tidy() %&gt;%
  transform(sdev = sqrt(withinss / size))

# discriminate between clusters 2 and 3
iris_km_ord %&gt;%
  ggbiplot(aes(x = `2`, y = `3`), color = factor(.cluster)) +
  geom_jitter(stat = "rows", aes(shape = cluster), width = .2, height = .2) +
  geom_cols_axis(aes(color = `1`, label = name),
                 text_size = 2, text_dodge = .1,
                 label_size = 3, label_alpha = .5) +
  scale_x_continuous(expand = expansion(mult = .8)) +
  scale_y_continuous(expand = expansion(mult = .5)) +
  ggtitle(
    "Measurement loadings onto clusters 2 and 3",
    "Color indicates loadings onto cluster 1"
  )
</code></pre>

<hr>
<h2 id='methods-lda'>Functionality for linear discriminant analysis ('lda') objects</h2><span id='topic+methods-lda'></span><span id='topic+as_tbl_ord.lda'></span><span id='topic+as_tbl_ord.lda_ord'></span><span id='topic+recover_rows.lda'></span><span id='topic+recover_rows.lda_ord'></span><span id='topic+recover_cols.lda'></span><span id='topic+recover_cols.lda_ord'></span><span id='topic+recover_inertia.lda'></span><span id='topic+recover_inertia.lda_ord'></span><span id='topic+recover_coord.lda'></span><span id='topic+recover_coord.lda_ord'></span><span id='topic+recover_conference.lda'></span><span id='topic+recover_conference.lda_ord'></span><span id='topic+recover_aug_rows.lda'></span><span id='topic+recover_aug_rows.lda_ord'></span><span id='topic+recover_aug_cols.lda'></span><span id='topic+recover_aug_cols.lda_ord'></span><span id='topic+recover_aug_coord.lda'></span><span id='topic+recover_aug_coord.lda_ord'></span><span id='topic+recover_supp_rows.lda'></span><span id='topic+recover_supp_rows.lda_ord'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"lda"</code> and <code>"lda_ord"</code> as returned by <code><a href="MASS.html#topic+lda">MASS::lda()</a></code> and
<code><a href="#topic+lda_ord">lda_ord()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lda'
as_tbl_ord(x)

## S3 method for class 'lda_ord'
as_tbl_ord(x)

## S3 method for class 'lda'
recover_rows(x)

## S3 method for class 'lda_ord'
recover_rows(x)

## S3 method for class 'lda'
recover_cols(x)

## S3 method for class 'lda_ord'
recover_cols(x)

## S3 method for class 'lda'
recover_inertia(x)

## S3 method for class 'lda_ord'
recover_inertia(x)

## S3 method for class 'lda'
recover_coord(x)

## S3 method for class 'lda_ord'
recover_coord(x)

## S3 method for class 'lda'
recover_conference(x)

## S3 method for class 'lda_ord'
recover_conference(x)

## S3 method for class 'lda'
recover_aug_rows(x)

## S3 method for class 'lda_ord'
recover_aug_rows(x)

## S3 method for class 'lda'
recover_aug_cols(x)

## S3 method for class 'lda_ord'
recover_aug_cols(x)

## S3 method for class 'lda'
recover_aug_coord(x)

## S3 method for class 'lda_ord'
recover_aug_coord(x)

## S3 method for class 'lda'
recover_supp_rows(x)

## S3 method for class 'lda_ord'
recover_supp_rows(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-lda_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+lda-ord">lda-ord</a> for details.
</p>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>
<p>Other models from the MASS package: 
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of Anderson iris species measurements
class(iris)
head(iris)

# default (unstandardized discriminant) coefficients
lda_ord(iris[, 1:4], iris[, 5]) %&gt;%
  as_tbl_ord() %&gt;%
  print() -&gt; iris_lda

# recover centroid coordinates and measurement discriminant coefficients
get_rows(iris_lda, elements = "active")
head(get_rows(iris_lda, elements = "score"))
get_cols(iris_lda)

# augment ordination with centroid and measurement names
augment_ord(iris_lda)
</code></pre>

<hr>
<h2 id='methods-lm'>Functionality for linear model objects</h2><span id='topic+methods-lm'></span><span id='topic+as_tbl_ord.lm'></span><span id='topic+recover_rows.lm'></span><span id='topic+recover_cols.lm'></span><span id='topic+recover_coord.lm'></span><span id='topic+recover_aug_rows.lm'></span><span id='topic+recover_aug_cols.lm'></span><span id='topic+recover_aug_coord.lm'></span><span id='topic+recover_aug_rows.glm'></span><span id='topic+recover_rows.mlm'></span><span id='topic+recover_cols.mlm'></span><span id='topic+recover_coord.mlm'></span><span id='topic+recover_aug_rows.mlm'></span><span id='topic+recover_aug_cols.mlm'></span><span id='topic+recover_aug_coord.mlm'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"lm"</code>, <code>"glm"</code>, and <code>"mlm"</code> as returned by <code><a href="stats.html#topic+lm">stats::lm()</a></code>
and <code><a href="stats.html#topic+glm">stats::glm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
as_tbl_ord(x)

## S3 method for class 'lm'
recover_rows(x)

## S3 method for class 'lm'
recover_cols(x)

## S3 method for class 'lm'
recover_coord(x)

## S3 method for class 'lm'
recover_aug_rows(x)

## S3 method for class 'lm'
recover_aug_cols(x)

## S3 method for class 'lm'
recover_aug_coord(x)

## S3 method for class 'glm'
recover_aug_rows(x)

## S3 method for class 'mlm'
recover_rows(x)

## S3 method for class 'mlm'
recover_cols(x)

## S3 method for class 'mlm'
recover_coord(x)

## S3 method for class 'mlm'
recover_aug_rows(x)

## S3 method for class 'mlm'
recover_aug_cols(x)

## S3 method for class 'mlm'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-lm_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for idiosyncratic techniques: 
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>,
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Motor Trend design and performance data
head(mtcars)
# regression analysis of performance measures on design specifications
mtcars_centered &lt;- scale(mtcars, scale = FALSE)
mtcars_centered %&gt;%
  as.data.frame() %&gt;%
  lm(formula = mpg ~ wt + cyl) %&gt;%
  print() -&gt; mtcars_lm

# wrap as a 'tbl_ord' object
(mtcars_lm_ord &lt;- as_tbl_ord(mtcars_lm))
# augment everything with names, predictors with observation stats
augment_ord(mtcars_lm_ord)
# calculate influences as the squares of weighted residuals
mutate_rows(augment_ord(mtcars_lm_ord), influence = wt.res^2)

# regression biplot with performance isolines
mtcars_lm_ord %&gt;%
  augment_ord() %&gt;%
  mutate_cols(center = attr(mtcars_centered, "scaled:center")[name]) %&gt;%
  mutate_rows(influence = wt.res^2) %T&gt;% print() %&gt;%
  ggbiplot(aes(x = wt, y = cyl, intercept = `(Intercept)`)) +
  #theme_biplot() +
  geom_origin(marker = "circle", radius = unit(0.02, "snpc")) +
  geom_rows_point(aes(color = influence)) +
  geom_cols_vector() +
  geom_cols_isoline(aes(center = center), by = .5, hjust = -.1) +
  ggtitle(
    "Weight isolines with data colored by importance",
    "Regressing gas mileage onto weight and number of cylinders"
  )
</code></pre>

<hr>
<h2 id='methods-lra'>Functionality for log-ratio analysis ('lra') objects</h2><span id='topic+methods-lra'></span><span id='topic+as_tbl_ord.lra'></span><span id='topic+recover_rows.lra'></span><span id='topic+recover_cols.lra'></span><span id='topic+recover_inertia.lra'></span><span id='topic+recover_coord.lra'></span><span id='topic+recover_conference.lra'></span><span id='topic+recover_aug_rows.lra'></span><span id='topic+recover_aug_cols.lra'></span><span id='topic+recover_aug_coord.lra'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"lra"</code>, a class introduced in this package to organize
the singular value decomposition of a double-centered log-transformed data
matrix output by <code><a href="#topic+lra">lra()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lra'
as_tbl_ord(x)

## S3 method for class 'lra'
recover_rows(x)

## S3 method for class 'lra'
recover_cols(x)

## S3 method for class 'lra'
recover_inertia(x)

## S3 method for class 'lra'
recover_coord(x)

## S3 method for class 'lra'
recover_conference(x)

## S3 method for class 'lra'
recover_aug_rows(x)

## S3 method for class 'lra'
recover_aug_cols(x)

## S3 method for class 'lra'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-lra_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of violent crime arrests in the United States
class(USArrests)
head(USArrests)
# get state abbreviation data
state &lt;- data.frame(
  name = state.name,
  abb = state.abb
)

# compute (non-compositional, unweighted) log-ratio analysis
USArrests %&gt;%
  subset(select = -UrbanPop) %&gt;%
  lra() %&gt;%
  as_tbl_ord() %&gt;%
  print() -&gt; arrests_lra

# augment log-ratio profiles with names and join state abbreviations
arrests_lra %&gt;%
  augment_ord() %&gt;%
  left_join_rows(state, by = "name") %&gt;%
  print() -&gt; arrests_lra

# recover state and arrest profiles
head(get_rows(arrests_lra))
get_cols(arrests_lra)
# initially, inertia is conferred on neither factor
get_conference(arrests_lra)

# row-principal biplot
arrests_lra %&gt;%
  confer_inertia("rows") %&gt;%
  ggbiplot(aes(color = .matrix), sec.axes = "cols", scale.factor = 1/20) +
  scale_color_manual(values = c("tomato4", "turquoise4")) +
  theme_bw() +
  geom_rows_text(aes(label = abb), size = 3, alpha = .75) +
  geom_cols_polygon(fill = NA, linetype = "dashed") +
  geom_cols_text(aes(label = name, size = weight), fontface = "bold") +
  scale_size_area(guide = "none") +
  ggtitle(
    "Non-compositional LRA of violent crime arrest rates",
    "United States, 1973"
  ) +
  expand_limits(x = c(-.35)) +
  guides(color = "none")
</code></pre>

<hr>
<h2 id='methods-mca'>Functionality for multiple correspondence analysis ('mca') objects</h2><span id='topic+methods-mca'></span><span id='topic+as_tbl_ord.mca'></span><span id='topic+recover_rows.mca'></span><span id='topic+recover_cols.mca'></span><span id='topic+recover_inertia.mca'></span><span id='topic+recover_conference.mca'></span><span id='topic+recover_coord.mca'></span><span id='topic+recover_supp_rows.mca'></span><span id='topic+recover_aug_rows.mca'></span><span id='topic+recover_aug_cols.mca'></span><span id='topic+recover_aug_coord.mca'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"mca"</code> from the <strong><a href="MASS.html#topic+mca">MASS</a></strong> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mca'
as_tbl_ord(x)

## S3 method for class 'mca'
recover_rows(x)

## S3 method for class 'mca'
recover_cols(x)

## S3 method for class 'mca'
recover_inertia(x)

## S3 method for class 'mca'
recover_conference(x)

## S3 method for class 'mca'
recover_coord(x)

## S3 method for class 'mca'
recover_supp_rows(x)

## S3 method for class 'mca'
recover_aug_rows(x)

## S3 method for class 'mca'
recover_aug_cols(x)

## S3 method for class 'mca'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-mca_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple correspondence analysis (MCA) relies on a singular value
decomposition of the indicator matrix <code class="reqn">X</code> of a table of several
categorical variables, scaled by its column totals. <code><a href="MASS.html#topic+mca">MASS::mca()</a></code> returns the
SVD factors <code class="reqn">UD</code> and <code class="reqn">V</code> as the row weights <code style="white-space: pre;">&#8288;$fs&#8288;</code>, on which the
inertia is conferred, and the column coordinates <code style="white-space: pre;">&#8288;$cs&#8288;</code>. The row coordinates
<code style="white-space: pre;">&#8288;$rs&#8288;</code> are obtained as <code class="reqn">XV</code> and accessible as supplementary elements.
</p>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>
<p>Other models from the MASS package: 
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># table of admissions and rejections from UC Berkeley
class(UCBAdmissions)
ucb_admissions &lt;- as.data.frame(UCBAdmissions)
ucb_admissions &lt;-
  ucb_admissions[rep(seq(nrow(ucb_admissions)), ucb_admissions$Freq), -4L]
head(ucb_admissions)
# perform multiple correspondence analysis
ucb_admissions %&gt;%
  MASS::mca() %&gt;%
  as_tbl_ord() %&gt;%
  # augment profiles with names, masses, distances, and inertias
  augment_ord() %&gt;%
  print() -&gt; admissions_mca

# recover row and column coordinates and row weights
head(get_rows(admissions_mca, elements = "score"))
get_cols(admissions_mca)
head(get_rows(admissions_mca))

# column-standard biplot of factor levels
admissions_mca %&gt;%
  ggbiplot() +
  theme_bw() + theme_biplot() +
  geom_origin() +
  #geom_rows_point(stat = "unique") +
  geom_cols_point(aes(color = factor, shape = factor)) +
  geom_cols_text_repel(aes(label = level, color = factor),
                       show.legend = FALSE) +
  scale_color_brewer(palette = "Dark2") +
  scale_size_area(guide = "none") +
  labs(color = "Factor level", shape = "Factor level")
</code></pre>

<hr>
<h2 id='methods-prcomp'>Functionality for principal components analysis ('prcomp') objects</h2><span id='topic+methods-prcomp'></span><span id='topic+as_tbl_ord.prcomp'></span><span id='topic+recover_rows.prcomp'></span><span id='topic+recover_cols.prcomp'></span><span id='topic+recover_inertia.prcomp'></span><span id='topic+recover_coord.prcomp'></span><span id='topic+recover_conference.prcomp'></span><span id='topic+recover_aug_rows.prcomp'></span><span id='topic+recover_aug_cols.prcomp'></span><span id='topic+recover_aug_coord.prcomp'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"prcomp"</code> as returned by <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcomp'
as_tbl_ord(x)

## S3 method for class 'prcomp'
recover_rows(x)

## S3 method for class 'prcomp'
recover_cols(x)

## S3 method for class 'prcomp'
recover_inertia(x)

## S3 method for class 'prcomp'
recover_coord(x)

## S3 method for class 'prcomp'
recover_conference(x)

## S3 method for class 'prcomp'
recover_aug_rows(x)

## S3 method for class 'prcomp'
recover_aug_cols(x)

## S3 method for class 'prcomp'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-prcomp_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>Author(s)</h3>

<p>Emily Paul
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>,
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>,
<code><a href="#topic+methods-lm">methods-lm</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of Anderson iris species measurements
class(iris)
head(iris)

# compute scaled row-principal components of scaled measurements
iris[, -5] %&gt;%
  prcomp(scale = TRUE) %&gt;%
  as_tbl_ord() %&gt;%
  print() -&gt; iris_pca

# recover observation principal coordinates and measurement standard coordinates
head(get_rows(iris_pca))
get_cols(iris_pca)

# augment measurements with names and scaling parameters
(iris_pca &lt;- augment_ord(iris_pca))
</code></pre>

<hr>
<h2 id='methods-princomp'>Functionality for principal components analysis ('princomp') objects</h2><span id='topic+methods-princomp'></span><span id='topic+as_tbl_ord.princomp'></span><span id='topic+recover_rows.princomp'></span><span id='topic+recover_cols.princomp'></span><span id='topic+recover_inertia.princomp'></span><span id='topic+recover_coord.princomp'></span><span id='topic+recover_conference.princomp'></span><span id='topic+recover_aug_rows.princomp'></span><span id='topic+recover_aug_cols.princomp'></span><span id='topic+recover_aug_coord.princomp'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"princomp"</code> as returned by <code><a href="stats.html#topic+princomp">stats::princomp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'princomp'
as_tbl_ord(x)

## S3 method for class 'princomp'
recover_rows(x)

## S3 method for class 'princomp'
recover_cols(x)

## S3 method for class 'princomp'
recover_inertia(x)

## S3 method for class 'princomp'
recover_coord(x)

## S3 method for class 'princomp'
recover_conference(x)

## S3 method for class 'princomp'
recover_aug_rows(x)

## S3 method for class 'princomp'
recover_aug_cols(x)

## S3 method for class 'princomp'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-princomp_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>Author(s)</h3>

<p>Emily Paul
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-svd">methods-svd</a></code>
</p>
<p>Other models from the stats package: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-cmds">methods-cmds</a></code>,
<code><a href="#topic+methods-factanal">methods-factanal</a></code>,
<code><a href="#topic+methods-kmeans">methods-kmeans</a></code>,
<code><a href="#topic+methods-lm">methods-lm</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frame of Anderson iris species measurements
class(iris)
head(iris)

# compute unscaled row-principal components of scaled measurements
iris[, -5] %&gt;%
  princomp() %&gt;%
  as_tbl_ord() %&gt;%
  print() -&gt; iris_pca

# recover observation principal coordinates and measurement standard coordinates
head(get_rows(iris_pca))
get_cols(iris_pca)

# augment measurement coordinates with names and scaling parameters
(iris_pca &lt;- augment_ord(iris_pca))
</code></pre>

<hr>
<h2 id='methods-svd'>Functionality for singular value decompositions</h2><span id='topic+methods-svd'></span><span id='topic+as_tbl_ord.svd_ord'></span><span id='topic+recover_rows.svd_ord'></span><span id='topic+recover_cols.svd_ord'></span><span id='topic+recover_inertia.svd_ord'></span><span id='topic+recover_coord.svd_ord'></span><span id='topic+recover_conference.svd_ord'></span><span id='topic+recover_aug_rows.svd_ord'></span><span id='topic+recover_aug_cols.svd_ord'></span><span id='topic+recover_aug_coord.svd_ord'></span>

<h3>Description</h3>

<p>These methods extract data from, and attribute new data to,
objects of class <code>"svd_ord"</code> returned by <code><a href="#topic+svd_ord">svd_ord()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svd_ord'
as_tbl_ord(x)

## S3 method for class 'svd_ord'
recover_rows(x)

## S3 method for class 'svd_ord'
recover_cols(x)

## S3 method for class 'svd_ord'
recover_inertia(x)

## S3 method for class 'svd_ord'
recover_coord(x)

## S3 method for class 'svd_ord'
recover_conference(x)

## S3 method for class 'svd_ord'
recover_aug_rows(x)

## S3 method for class 'svd_ord'
recover_aug_cols(x)

## S3 method for class 'svd_ord'
recover_aug_coord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-svd_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recovery generics <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> return <a href="#topic+recoverers">core model components</a>, <a href="#topic+conference">distribution of inertia</a>,
<a href="#topic+supplementation">supplementary elements</a>, and <a href="#topic+augmentation">intrinsic metadata</a>; but they require methods for each model class to
tell them what these components are.
</p>
<p>The generic <code><a href="#topic+as_tbl_ord">as_tbl_ord()</a></code> returns its input wrapped in the 'tbl_ord'
class. Its methods determine what model classes it is allowed to wrap. It
then provides 'tbl_ord' methods with access to the recoverers and hence to
the model components.
</p>


<h3>See Also</h3>

<p>Other methods for singular value decomposition-based techniques: 
<code><a href="#topic+methods-cancor">methods-cancor</a></code>,
<code><a href="#topic+methods-correspondence">methods-correspondence</a></code>,
<code><a href="#topic+methods-lda">methods-lda</a></code>,
<code><a href="#topic+methods-lra">methods-lra</a></code>,
<code><a href="#topic+methods-mca">methods-mca</a></code>,
<code><a href="#topic+methods-prcomp">methods-prcomp</a></code>,
<code><a href="#topic+methods-princomp">methods-princomp</a></code>
</p>
<p>Other models from the base package: 
<code><a href="#topic+methods-eigen">methods-eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix of U.S. personal expenditure data
class(USPersonalExpenditure)
print(USPersonalExpenditure)
# singular value decomposition into row and column coordinates
USPersonalExpenditure %&gt;%
  svd_ord() %&gt;%
  as_tbl_ord() %&gt;%
  print() -&gt; spend_svd

# recover matrices of row and column coordinates
get_rows(spend_svd)
get_cols(spend_svd)

# augment with row and column names
augment_ord(spend_svd)
# initial matrix decomposition confers no inertia to coordinates
get_conference(spend_svd)
</code></pre>

<hr>
<h2 id='negation'>Negation of ordination axes</h2><span id='topic+negation'></span><span id='topic+get_negation'></span><span id='topic+revert_negation'></span><span id='topic+negate_ord'></span><span id='topic+negate_to_first_orthant'></span>

<h3>Description</h3>

<p>Negate the coordinates of a subset of ordination axes in both
row and column singular vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_negation(x)

revert_negation(x)

negate_ord(x, negation = NULL)

negate_to_first_orthant(x, .matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negation_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tbl_ord">tbl_ord</a>.</p>
</td></tr>
<tr><td><code id="negation_+3A_negation">negation</code></td>
<td>
<p>Integer vector of coordinates to negate.</p>
</td></tr>
<tr><td><code id="negation_+3A_.matrix">.matrix</code></td>
<td>
<p>A character string partially matched (lowercase) to several
indicators for one or both matrices in a matrix decomposition used for
ordination. The standard values are <code>"rows"</code>, <code>"cols"</code>, and <code>"dims"</code> (for
both).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For purposes of comparison and visualization, it can be useful to negate the
(already artificial) coordinates of an ordination, either by fixed criteria
or to better align with another basis (matrix) of coordinates. <code>negate_ord()</code>
allows the user to negate specified coordinates of an ordination.
</p>
<p><code>get_negation()</code> accesses the negations of an ordination, an integer vector
of <code>1</code>s and <code>-1</code>s stored as a <code>"negate"</code> attribute.
</p>


<h3>Value</h3>

<p><code>negate_ord()</code> and <code>negate_to_first_orthant()</code> return a tbl_ord with
certain axes negated but the wrapped model unchanged. <code>get_negation()</code>
returns the current negations. <code>revert_negation()</code> returns the tbl_ord
without any manual negations.
</p>
<p>A tbl_ord; the wrapped model is unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(pca &lt;- ordinate(iris, cols = 1:4, prcomp))
ggbiplot(pca) + geom_rows_point() + geom_cols_vector()

# manually negate second coordinate
(pca_neg &lt;- negate_ord(pca, 2))
ggbiplot(pca_neg) + geom_rows_point() + geom_cols_vector()

# NB: 'prcomp' method takes precedence; negations are part of the wrapper
biplot(pca)
biplot(pca_neg)

# negate to the first orthant
(pca_orth &lt;- negate_to_first_orthant(pca, "v"))
get_negation(pca_orth)
</code></pre>

<hr>
<h2 id='ordinate'>Fit an ordination model to a data object</h2><span id='topic+ordinate'></span><span id='topic+ordinate.default'></span><span id='topic+ordinate.array'></span><span id='topic+ordinate.table'></span><span id='topic+ordinate.data.frame'></span><span id='topic+ordinate.dist'></span>

<h3>Description</h3>

<p>This is a convenience function to fit an ordination model to a
data object, wrap the result as a tbl_ord, and annotate this output with
metadata from the model and possibly from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinate(x, model, ...)

## Default S3 method:
ordinate(x, model, ...)

## S3 method for class 'array'
ordinate(x, model, ...)

## S3 method for class 'table'
ordinate(x, model, ...)

## S3 method for class 'data.frame'
ordinate(x, model, cols, augment, ...)

## S3 method for class 'dist'
ordinate(x, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinate_+3A_x">x</code></td>
<td>
<p>A data object to be passed to the <code>model</code>, such as an <a href="base.html#topic+array">array</a>,
<a href="base.html#topic+table">table</a>, <a href="base.html#topic+data.frame">data.frame</a>, or <a href="stats.html#topic+dist">stats::dist</a>.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_model">model</code></td>
<td>
<p>An ordination function whose output is coercible to class
'<a href="#topic+tbl_ord">tbl_ord</a>', or a symbol or character string (handled by <code><a href="base.html#topic+match.fun">match.fun()</a></code>).
Alternatively, a formula <code>~ fun(., ...)</code> where <code>fun</code> is such a function and
other arguments are explicit, which will be evaluated with <code>x</code> in place of
<code>.</code>.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>model</code>.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; If <code>x</code> is a data
frame, columns to pass to <code>model</code>. If missing, all columns are used.</p>
</td></tr>
<tr><td><code id="ordinate_+3A_augment">augment</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; If <code>x</code> is a data frame,
columns to augment to the row data of the ordination. If missing, all
columns not included in <code>cols</code> will be augmented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method fits the specified model to the provided data object,
wraps the result as a <a href="#topic+tbl_ord">tbl_ord</a>, and augments this output with any intrinsic
metadata from the model via <code><a href="#topic+augment_ord">augment_ord()</a></code>.
</p>
<p>The default method is used for most classes, though this may change in
future. The <a href="base.html#topic+data.frame">data.frame</a> method allows the user to specify what columns to
include in the model and what columns with which to annotate the output.
</p>


<h3>Value</h3>

<p>An augmented tbl_ord.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># LRA of arrest data
ordinate(USArrests, cols = c(Murder, Rape, Assault), lra)

# CMDS of inter-city distance data
ordinate(UScitiesD, cmdscale_ord, k = 3L)

# PCA of iris data
ordinate(iris, princomp, cols = -Species, augment = c(Sepal.Width, Species))
ordinate(iris, cols = 1:4, ~ prcomp(., center = TRUE, scale. = TRUE))

# CA of hair &amp; eye color data
haireye &lt;- as.data.frame(rowSums(HairEyeColor, dims = 2L))
ordinate(haireye, MASS::corresp, cols = everything())

# FA of Swiss social data
ordinate(swiss, model = factanal, factors = 2L, scores = "Bartlett")

# LDA of iris data
ordinate(iris, ~ lda_ord(.[, 1:4], .[, 5], ret.x = TRUE))

# CCA of savings data
ordinate(
  LifeCycleSavings[, c("pop15", "pop75")],
  # second data set must be handled as an additional parameter to `model`
  y = LifeCycleSavings[, c("sr", "dpi", "ddpi")],
  model = cancor_ord, scores = TRUE
)
</code></pre>

<hr>
<h2 id='ordr-ggproto'>ggproto classes created and adapted for ordr</h2><span id='topic+ordr-ggproto'></span><span id='topic+GeomAxis'></span><span id='topic+GeomPointranges'></span><span id='topic+GeomLineranges'></span><span id='topic+GeomIsoline'></span><span id='topic+GeomOrigin'></span><span id='topic+GeomTextRadiate'></span><span id='topic+GeomUnitCircle'></span><span id='topic+GeomVector'></span><span id='topic+StatCenter'></span><span id='topic+StatStar'></span><span id='topic+StatChull'></span><span id='topic+StatCone'></span><span id='topic+StatRows'></span><span id='topic+StatCols'></span><span id='topic+StatScale'></span><span id='topic+StatRowsScale'></span><span id='topic+StatColsScale'></span><span id='topic+StatSpantree'></span><span id='topic+StatRowsEllipse'></span><span id='topic+StatColsEllipse'></span><span id='topic+StatRowsCenter'></span><span id='topic+StatColsCenter'></span><span id='topic+StatRowsStar'></span><span id='topic+StatColsStar'></span><span id='topic+StatRowsChull'></span><span id='topic+StatColsChull'></span><span id='topic+StatRowsCone'></span><span id='topic+StatColsCone'></span><span id='topic+StatRowsSpantree'></span><span id='topic+StatColsSpantree'></span>

<h3>Description</h3>

<p>In addition to geometric element layers (geoms) based on
base-<strong>ggplot2</strong> layers like <code>geom_point()</code> but specified to matrix factors
as <code>geom_row_point()</code>, <strong>ordr</strong> introduces <a href="ggplot2.html#topic+ggproto">ggproto</a>
classes for some additional geometric elements commonly used in biplots.
The factor-specific geoms invoke the statistical transformation layers
(stats) <code>stat_rows()</code> and <code>stat_cols()</code>, which specify the matrix factor.
Because each ggplot layer consists of only one stat and one geom, this
necessitates that ggproto classes for new stats must also come in <code style="white-space: pre;">&#8288;*Rows&#8288;</code>
and <code style="white-space: pre;">&#8288;*Cols&#8288;</code> flavors.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2::ggplot2-ggproto</a></code> and <a href="ggplot2.html#topic+ggproto">ggplot2::ggproto</a> for explanations
of base ggproto classes in <strong>ggplot2</strong> and how to create new ones.
</p>

<hr>
<h2 id='plot.tbl_ord'>Plot and biplot methods for 'tbl_ord' objects</h2><span id='topic+plot.tbl_ord'></span>

<h3>Description</h3>

<p>Adapt <strong>stats</strong> 'prcomp' and 'princomp' methods for <code>plot()</code>,
<code>screeplot()</code>, and <code>biplot()</code> generics to 'tbl_ord' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_ord'
plot(x, main = deparse(substitute(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tbl_ord_+3A_x">x</code></td>
<td>
<p>A 'tbl_ord' object.</p>
</td></tr>
<tr><td><code id="plot.tbl_ord_+3A_main">main</code></td>
<td>
<p>A main title for the plot, passed to other methods (included to
enable parsing of object name).</p>
</td></tr>
<tr><td><code id="plot.tbl_ord_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods defer to any <code>plot()</code> and <code>biplot()</code> methods for the original,
underlying model classes of 'tbl_ord' objects. If none are found: Following
the examples of <code><a href="stats.html#topic+prcomp">stats::plot.prcomp()</a></code> and <code><a href="stats.html#topic+princomp">stats::plot.princomp()</a></code>,
<code>plot.tbl_ord()</code> calls on <code><a href="stats.html#topic+screeplot">stats::screeplot()</a></code> to produce a scree plot of the
decomposition of variance in the singular value decomposition. Similarly
following <code><a href="stats.html#topic+biplot.princomp">stats::biplot.prcomp()</a></code> and <code><a href="stats.html#topic+biplot.princomp">stats::biplot.princomp()</a></code>,
<code>biplot.tbl_ord()</code> produces a biplot of both rows and columns, using text
labels when available and markers otherwise, with rows and columns
distinguished by color and no additional annotation (e.g. vectors). The
biplot confers inertia according to <code><a href="#topic+get_conference">get_conference()</a></code> unless the proportions
do not sum to 1, in which case it produces a symmetric biplot (inertia
conferred equally to rows and columns).
</p>


<h3>Value</h3>

<p>Nothing, but a plot is produced on the current graphics device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># note: behavior depends on installed packages with class-specific methods

# class 'prcomp'
iris_pca &lt;- prcomp(iris[, -5L], scale = TRUE)
iris_pca_ord &lt;- as_tbl_ord(iris_pca)
plot(iris_pca)
plot(iris_pca_ord)
screeplot(iris_pca)
screeplot(iris_pca_ord)
biplot(iris_pca)
biplot(iris_pca_ord)

# class 'correspondence'
haireye_ca &lt;- MASS::corresp(rowSums(HairEyeColor, dims = 2L), nf = 2L)
haireye_ca_ord &lt;- as_tbl_ord(haireye_ca)
plot(haireye_ca)
plot(haireye_ca_ord)
# no `screeplot()` method for class 'correspondence'
screeplot(haireye_ca_ord)
biplot(haireye_ca)
biplot(haireye_ca_ord)
</code></pre>

<hr>
<h2 id='qswur_usa'>U.S. university rankings</h2><span id='topic+qswur_usa'></span>

<h3>Description</h3>

<p>Classifications and rankings of U.S. universities for the years
2017&ndash;2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(qswur_usa)
</code></pre>


<h3>Format</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a> of 13 variables on 612 cases:
</p>

<dl>
<dt>year</dt><dd><p>year of rankings</p>
</dd>
<dt>institution</dt><dd><p>institution of higher learning</p>
</dd>
<dt>size</dt><dd><p>size category of institution</p>
</dd>
<dt>focus</dt><dd><p>subject range of institution</p>
</dd>
<dt>res</dt><dd><p>research intensity of institution</p>
</dd>
<dt>age</dt><dd><p>age classification of institution</p>
</dd>
<dt>status</dt><dd><p>status of institution</p>
</dd>
<dt>rk_academic</dt><dd><p>rank by academic reputation</p>
</dd>
<dt>rk_employer</dt><dd><p>rank by employer reputation</p>
</dd>
<dt>rk_ratio</dt><dd><p>rank by faculty&ndash;student ratio</p>
</dd>
<dt>rk_citations</dt><dd><p>rank by citations per faculty</p>
</dd>
<dt>rk_intl_faculty</dt><dd><p>rank by international faculty ratio</p>
</dd>
<dt>rk_intl_students</dt><dd><p>rank by international student ratio</p>
</dd>
</dl>



<h3>Details</h3>

<p>Ranking data were obtained from the public QS website.
</p>


<h3>Source</h3>

<p>Quacquarelli Symonds (2021).
</p>


<h3>References</h3>

<p>Quacquarelli Symonds (2021) &quot;University Rankings&quot;. TopUniversities.com
<a href="https://www.topuniversities.com/university-rankings">https://www.topuniversities.com/university-rankings</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset QS data to rank variables
head(qswur_usa)
qs_ranks &lt;- subset(
  qswur_usa,
  complete.cases(qswur_usa),
  select = 8:13
)
# calculate Kendall correlation matrix
qs_cor &lt;- cor(qs_ranks, method = "kendall")

# calculate eigendecomposition
qs_eigen &lt;- eigen_ord(qs_cor)
# view correlations as cosines of biplot vectors
biplot(x = qs_eigen$vectors, y = qs_eigen$vectors, col = c(NA, "black"))
</code></pre>

<hr>
<h2 id='recoverers'>Access factors, coordinates, and metadata from ordination objects</h2><span id='topic+recoverers'></span><span id='topic+recover_rows'></span><span id='topic+recover_cols'></span><span id='topic+recover_rows.default'></span><span id='topic+recover_cols.default'></span><span id='topic+recover_rows.data.frame'></span><span id='topic+recover_cols.data.frame'></span><span id='topic+get_rows'></span><span id='topic+get_cols'></span><span id='topic+as.matrix.tbl_ord'></span><span id='topic+recover_inertia'></span><span id='topic+recover_inertia.default'></span><span id='topic+recover_coord'></span><span id='topic+recover_coord.default'></span><span id='topic+recover_coord.data.frame'></span><span id='topic+get_coord'></span><span id='topic+get_inertia'></span><span id='topic+dim.tbl_ord'></span>

<h3>Description</h3>

<p>These functions return information about the matrix
factorization underlying an ordination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_rows(x)

recover_cols(x)

## Default S3 method:
recover_rows(x)

## Default S3 method:
recover_cols(x)

## S3 method for class 'data.frame'
recover_rows(x)

## S3 method for class 'data.frame'
recover_cols(x)

get_rows(x, elements = "all")

get_cols(x, elements = "all")

## S3 method for class 'tbl_ord'
as.matrix(x, ..., .matrix, elements = "all")

recover_inertia(x)

## Default S3 method:
recover_inertia(x)

recover_coord(x)

## Default S3 method:
recover_coord(x)

## S3 method for class 'data.frame'
recover_coord(x)

get_coord(x)

get_inertia(x)

## S3 method for class 'tbl_ord'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recoverers_+3A_x">x</code></td>
<td>
<p>An object of class '<a href="#topic+tbl_ord">tbl_ord</a>'.</p>
</td></tr>
<tr><td><code id="recoverers_+3A_elements">elements</code></td>
<td>
<p>Character vector; which elements of each factor for which to
render graphical elements. One of <code>"all"</code> (the default), <code>"active"</code>, or any
supplementary element type defined by the specific class methods (e.g.
<code>"score"</code> for 'factanal', 'lda_ord', and 'cancord_ord' and <code>"intraset"</code> and
<code>"interset"</code> for 'cancor_ord').</p>
</td></tr>
<tr><td><code id="recoverers_+3A_...">...</code></td>
<td>
<p>Additional arguments from <code><a href="base.html#topic+matrix">base::as.matrix()</a></code>; ignored.</p>
</td></tr>
<tr><td><code id="recoverers_+3A_.matrix">.matrix</code></td>
<td>
<p>A character string partially matched (lowercase) to several
indicators for one or both matrices in a matrix decomposition used for
ordination. The standard values are <code>"rows"</code>, <code>"cols"</code>, and <code>"dims"</code> (for
both).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> <a href="base.html#topic+UseMethod">S3 methods</a> extract one or both of the
row and column matrix factors that constitute the original ordination. These
are interpreted as the case scores (rows) and the variable loadings
(columns). The <code style="white-space: pre;">&#8288;get_*()&#8288;</code> functions optionally (and by default) include any
supplemental observations (see <a href="#topic+supplementation">supplementation</a>).
</p>
<p>The <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> functions are generics that require methods for each
ordination class. They are not intended to be called directly but are
exported so that users can query <code>methods("recover_*")</code>.
</p>
<p><code>get_coord()</code> retrieves the names of the coordinates shared by the matrix
factors on which the original data were ordinated, and <code>get_inertia()</code>
retrieves a vector of the inertia with these names. <code>dim()</code> retrieves the
dimensions of the row and column factors, which reflect the dimensions of the
matrix they reconstruct&mdash;<strong>not</strong> the original data matrix. (This matters for
techniques that rely on eigendecomposition, for which the decomposed matrix
is square.)
</p>


<h3>Value</h3>

<p>The <code style="white-space: pre;">&#8288;recover_*()&#8288;</code> functions are generics whose methods return base R
objects retrieved from the model wrapped in the 'tbl_ord' class:
</p>

<ul>
<li> <p><code>rows</code>: the row matrix as stored in the model
</p>
</li>
<li> <p><code>cols</code>: the column matrix as stored in the model
</p>
</li>
<li> <p><code>inertia</code>: the vector of eigen-values or squared singular values,
often known by other names depending on the model
</p>
</li>
<li> <p><code>coord</code>: names for the artificial axes, from the model if available
The <code style="white-space: pre;">&#8288;get_*()&#8288;</code> functions (which are not generics) return modifications of
these objects:
</p>
</li>
<li> <p><code>rows</code>: the recovered rows,
adjusted according to any negation of axes or conference of inertia
</p>
</li>
<li> <p><code>cols</code>: the recovered columns,
adjusted according to any negation of axes or conference of inertia
</p>
</li>
<li> <p><code>inertia</code>: the recovered inertia, named by the recovered coordinates
</p>
</li>
<li> <p><code>coord</code>: the recovered coordinates (unmodified)
<code>dim()</code> returns the dimensions of the decomposed matrix, i.e. the numbers of
rows of <code>recover_rows()</code> and of <code>recover_cols()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other generic recoverers: 
<code><a href="#topic+augmentation">augmentation</a></code>,
<code><a href="#topic+conference">conference</a></code>,
<code><a href="#topic+supplementation">supplementation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example ordination: LRA of U.S. arrests data
arrests_lra &lt;- ordinate(USArrests, cols = c(Murder, Rape, Assault), lra)

# extract matrix factors
as.matrix(arrests_lra, .matrix = "rows")
as.matrix(arrests_lra, .matrix = "cols")
# special named functions
get_rows(arrests_lra)
get_cols(arrests_lra)
# get dimensions of underlying matrix factorization (not of original data)
dim(arrests_lra)

# get names of artificial / latent coordinates
get_coord(arrests_lra)
# get distribution of inertia
get_inertia(arrests_lra)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+geom_text_repel'></span><span id='topic+geom_label_repel'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>ggrepel</dt><dd><p><code><a href="ggrepel.html#topic+geom_text_repel">geom_label_repel</a></code>, <code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='stat_center'>Compute geometric centers and spreads for ordination factors</h2><span id='topic+stat_center'></span><span id='topic+stat_star'></span>

<h3>Description</h3>

<p>Compute geometric centers and spreads for ordination factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_center(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  fun.data = NULL,
  fun.center = NULL,
  fun.min = NULL,
  fun.max = NULL,
  fun.args = list()
)

stat_star(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  fun.data = NULL,
  fun.center = NULL,
  fun.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_center_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_center_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_center_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_center_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_center_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_center_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_center_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_center_+3A_fun.data">fun.data</code>, <code id="stat_center_+3A_fun.center">fun.center</code>, <code id="stat_center_+3A_fun.min">fun.min</code>, <code id="stat_center_+3A_fun.max">fun.max</code>, <code id="stat_center_+3A_fun.args">fun.args</code></td>
<td>
<p>Functions and arguments
treated as in <code><a href="ggplot2.html#topic+stat_summary">ggplot2::stat_summary()</a></code>, with <code>fun.center</code>, <code>fun.min</code>, and
<code>fun.max</code> behaving as <code>fun.y</code>, <code>fun.ymin</code>, and <code>fun.ymax</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Ordination aesthetics</h3>

<p>The convenience function <code><a href="#topic+ord_aes">ord_aes()</a></code> can be used to incorporate all
coordinates of the ordination model into a statistical transformation. It
maps the coordinates to the custom aesthetics <code>..coord1</code>, <code>..coord2</code>, etc.
</p>
<p>Some transformations, e.g. <code><a href="#topic+stat_center">stat_center()</a></code>, are commutative with projection
to the 'x' and 'y' coordinates. If they detect aesthetics of the form
<code style="white-space: pre;">&#8288;..coord[0-9]+&#8288;</code>, then <code>..coord1</code> and <code>..coord2</code> are converted to <code>x</code> and <code>y</code>
while any remaining are ignored.
</p>
<p>Other transformations, e.g. <code><a href="#topic+stat_spantree">stat_spantree()</a></code>, yield different results in a
planar biplot when they are computer before or after projection. If such a
stat layer detects these aesthetics, then the lot of them are used in the
transformation.
</p>
<p>In either case, the stat layer returns a data frame with position aesthetics
<code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other stat layers: 
<code><a href="#topic+stat_chull">stat_chull</a>()</code>,
<code><a href="#topic+stat_cone">stat_cone</a>()</code>,
<code><a href="#topic+stat_scale">stat_scale</a>()</code>,
<code><a href="#topic+stat_spantree">stat_spantree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># scaled PCA of Anderson iris measurements
iris[, -5] %&gt;%
  princomp(cor = TRUE) %&gt;%
  as_tbl_ord() %&gt;%
  mutate_rows(species = iris$Species) %&gt;%
  print() -&gt; iris_pca

# row-principal biplot with centroid-based stars
iris_pca %&gt;%
  ggbiplot(aes(color = species)) +
  theme_bw() +
  scale_color_brewer(type = "qual", palette = 2) +
  stat_rows_star(alpha = .5, fun.center = "mean") +
  geom_rows_point(alpha = .5) +
  stat_rows_center(fun.center = "mean", size = 4, shape = 1L) +
  ggtitle(
    "Row-principal PCA biplot of Anderson iris measurements",
    "Segments connect each observation to its within-species centroid"
  )
</code></pre>

<hr>
<h2 id='stat_chull'>Restrict geometric data to boundary points for its convex hull</h2><span id='topic+stat_chull'></span>

<h3>Description</h3>

<p>As used in a <strong><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></strong> vignette, this stat
layer restricts a dataset with <code>x</code> and <code>y</code> variables to the points that lie
on its convex hull. The biplot extension restricts each matrix factor to
its own hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_chull(
  mapping = NULL,
  data = NULL,
  geom = "polygon",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_chull_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_chull_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_chull_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_chull_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_chull_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_chull_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_chull_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Ordination aesthetics</h3>

<p>The convenience function <code><a href="#topic+ord_aes">ord_aes()</a></code> can be used to incorporate all
coordinates of the ordination model into a statistical transformation. It
maps the coordinates to the custom aesthetics <code>..coord1</code>, <code>..coord2</code>, etc.
</p>
<p>Some transformations, e.g. <code><a href="#topic+stat_center">stat_center()</a></code>, are commutative with projection
to the 'x' and 'y' coordinates. If they detect aesthetics of the form
<code style="white-space: pre;">&#8288;..coord[0-9]+&#8288;</code>, then <code>..coord1</code> and <code>..coord2</code> are converted to <code>x</code> and <code>y</code>
while any remaining are ignored.
</p>
<p>Other transformations, e.g. <code><a href="#topic+stat_spantree">stat_spantree()</a></code>, yield different results in a
planar biplot when they are computer before or after projection. If such a
stat layer detects these aesthetics, then the lot of them are used in the
transformation.
</p>
<p>In either case, the stat layer returns a data frame with position aesthetics
<code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other stat layers: 
<code><a href="#topic+stat_center">stat_center</a>()</code>,
<code><a href="#topic+stat_cone">stat_cone</a>()</code>,
<code><a href="#topic+stat_scale">stat_scale</a>()</code>,
<code><a href="#topic+stat_spantree">stat_spantree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># correspondence analysis of combined female and male hair and eye color data
HairEyeColor %&gt;%
  rowSums(dims = 2L) %&gt;%
  MASS::corresp(nf = 2L) %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  print() -&gt; hec_ca
# inertia across artificial coordinates (all singular values &lt; 1)
get_inertia(hec_ca)

# in row-principal biplot, row coordinates are weighted averages of columns
hec_ca %&gt;%
  confer_inertia("rows") %&gt;%
  ggbiplot(aes(color = .matrix, fill = .matrix, shape = .matrix)) +
  theme_bw() +
  stat_cols_chull(alpha = .1) +
  geom_cols_point() +
  geom_rows_point() +
  ggtitle("Row-principal CA of hair &amp; eye color")
# in column-principal biplot, column coordinates are weighted averages of rows
hec_ca %&gt;%
  confer_inertia("cols") %&gt;%
  ggbiplot(aes(color = .matrix, fill = .matrix, shape = .matrix)) +
  theme_bw() +
  stat_rows_chull(alpha = .1) +
  geom_rows_point() +
  geom_cols_point() +
  ggtitle("Column-principal CA of hair &amp; eye color")
</code></pre>

<hr>
<h2 id='stat_cone'>Restrict geometric data to boundary points for its conical hull</h2><span id='topic+stat_cone'></span>

<h3>Description</h3>

<p>This stat layer restricts a dataset with <code>x</code> and <code>y</code> variables
to the points that lie on its conical hull (other than the origin).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_cone(
  mapping = NULL,
  data = NULL,
  geom = "path",
  position = "identity",
  origin = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_cone_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_origin">origin</code></td>
<td>
<p>Logical; whether to include the origin with the transformed
data. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cone_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Ordination aesthetics</h3>

<p>The convenience function <code><a href="#topic+ord_aes">ord_aes()</a></code> can be used to incorporate all
coordinates of the ordination model into a statistical transformation. It
maps the coordinates to the custom aesthetics <code>..coord1</code>, <code>..coord2</code>, etc.
</p>
<p>Some transformations, e.g. <code><a href="#topic+stat_center">stat_center()</a></code>, are commutative with projection
to the 'x' and 'y' coordinates. If they detect aesthetics of the form
<code style="white-space: pre;">&#8288;..coord[0-9]+&#8288;</code>, then <code>..coord1</code> and <code>..coord2</code> are converted to <code>x</code> and <code>y</code>
while any remaining are ignored.
</p>
<p>Other transformations, e.g. <code><a href="#topic+stat_spantree">stat_spantree()</a></code>, yield different results in a
planar biplot when they are computer before or after projection. If such a
stat layer detects these aesthetics, then the lot of them are used in the
transformation.
</p>
<p>In either case, the stat layer returns a data frame with position aesthetics
<code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other stat layers: 
<code><a href="#topic+stat_center">stat_center</a>()</code>,
<code><a href="#topic+stat_chull">stat_chull</a>()</code>,
<code><a href="#topic+stat_scale">stat_scale</a>()</code>,
<code><a href="#topic+stat_spantree">stat_spantree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># centered principal components analysis of U.S. personal expenditure data
USPersonalExpenditure %&gt;%
  prcomp() %&gt;%
  as_tbl_ord() %&gt;%
  augment_ord() %&gt;%
  # allow radiating text to exceed plotting window
  ggbiplot(aes(label = name), clip = "off",
           sec.axes = "cols", scale.factor = 50) +
  geom_rows_label(size = 3) +
  geom_cols_vector() +
  # omit labels in the conical hull without the origin
  stat_cols_cone(linetype = "dotted") +
  geom_cols_text_radiate(stat = "cone") +
  ggtitle(
    "U.S. Personal Expenditure data, 1940-1960",
    "Row-principal biplot of centered PCA"
  )
</code></pre>

<hr>
<h2 id='stat_rows'>Render plot elements for one matrix of an ordination</h2><span id='topic+stat_rows'></span><span id='topic+stat_cols'></span>

<h3>Description</h3>

<p>These stats merely tell <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> which factor of an
ordination to pull data from for a plot layer. They are invoked internally
by the various <code><a href="#topic+biplot-geoms">geom_*_*()</a></code> layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_rows(
  mapping = NULL,
  data = data,
  geom = "point",
  position = "identity",
  subset = NULL,
  elements = "all",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_cols(
  mapping = NULL,
  data = data,
  geom = "axis",
  position = "identity",
  subset = NULL,
  elements = "all",
  ...,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_rows_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_subset">subset</code></td>
<td>
<p>An integer, logical, or character vector indicating a subset of
rows or columns for which to render graphical elements. NB: Internally, the
<code>subset</code> will be taken from the rows of the <a href="#topic+fortify.tbl_ord">fortified</a>
'tbl_ord' comprising rows from only one of the matrix factors. It is still
possible to pass a formula to the <code>data</code> parameter, but it will act on the
fortified data <em>before</em> it has been restricted to one matrix factor.</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_elements">elements</code></td>
<td>
<p>Character vector; which elements of each factor for which to
render graphical elements. One of <code>"all"</code> (the default), <code>"active"</code>, or any
supplementary element type defined by the specific class methods (e.g.
<code>"score"</code> for 'factanal', 'lda_ord', and 'cancord_ord' and <code>"intraset"</code> and
<code>"interset"</code> for 'cancor_ord').</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_rows_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>See Also</h3>

<p>Other biplot layers: 
<code><a href="#topic+biplot-geoms">biplot-geoms</a></code>,
<code><a href="#topic+biplot-stats">biplot-stats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># FA of Swiss social data
swiss_fa &lt;-
  ordinate(swiss, model = factanal, factors = 2L, scores = "regression")
# active and supplementary elements
get_rows(swiss_fa, elements = "active")
head(get_rows(swiss_fa, elements = "score"))

# biplot using element filters and selection
# (note that filter precedes selection)
ggbiplot(swiss_fa) +
  geom_rows_point(elements = "score") +
  geom_rows_text(aes(label = name), elements = "score", subset = c(1, 4, 18)) +
  scale_alpha_manual(values = c(0, 1), guide = "none") +
  geom_cols_vector() +
  geom_cols_text_radiate(aes(label = name))
</code></pre>

<hr>
<h2 id='stat_scale'>Multiply artificial coordinates by a scale factor</h2><span id='topic+stat_scale'></span>

<h3>Description</h3>

<p>Multiply artificial coordinates by a scale factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_scale(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...,
  mult = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_scale_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_scale_+3A_mult">mult</code></td>
<td>
<p>Numeric value used to scale the coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Ordination aesthetics</h3>

<p>The convenience function <code><a href="#topic+ord_aes">ord_aes()</a></code> can be used to incorporate all
coordinates of the ordination model into a statistical transformation. It
maps the coordinates to the custom aesthetics <code>..coord1</code>, <code>..coord2</code>, etc.
</p>
<p>Some transformations, e.g. <code><a href="#topic+stat_center">stat_center()</a></code>, are commutative with projection
to the 'x' and 'y' coordinates. If they detect aesthetics of the form
<code style="white-space: pre;">&#8288;..coord[0-9]+&#8288;</code>, then <code>..coord1</code> and <code>..coord2</code> are converted to <code>x</code> and <code>y</code>
while any remaining are ignored.
</p>
<p>Other transformations, e.g. <code><a href="#topic+stat_spantree">stat_spantree()</a></code>, yield different results in a
planar biplot when they are computer before or after projection. If such a
stat layer detects these aesthetics, then the lot of them are used in the
transformation.
</p>
<p>In either case, the stat layer returns a data frame with position aesthetics
<code>x</code> and <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other stat layers: 
<code><a href="#topic+stat_center">stat_center</a>()</code>,
<code><a href="#topic+stat_chull">stat_chull</a>()</code>,
<code><a href="#topic+stat_cone">stat_cone</a>()</code>,
<code><a href="#topic+stat_spantree">stat_spantree</a>()</code>
</p>

<hr>
<h2 id='stat_spantree'>Calculate a minimum spanning tree among cases or variables</h2><span id='topic+stat_spantree'></span>

<h3>Description</h3>

<p>This stat layer identifies the <code class="reqn">n-1</code> pairs among <code class="reqn">n</code>
points that form a minimum spanning tree, then calculates the segments
between these poirs in the two dimensions <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_spantree(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  position = "identity",
  engine = "mlpack",
  method = "euclidean",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_spantree_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying the package implementation
to use; <code>"mlpack"</code>, <code>"vegan"</code>, or <code>"ade4"</code>.</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_method">method</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code> if <code>engine</code> is <code>"vegan"</code> or <code>"ade4"</code>,
ignored if <code>"mlpack"</code>.</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_spantree_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A minimum spanning tree (MST) on the point cloud <code class="reqn">X</code> is a minimal
connected graph on <code class="reqn">X</code> with the smallest possible sum of distances (or
dissimilarities) between linked points. These layers call <code><a href="stats.html#topic+dist">stats::dist()</a></code> to
calculate a distance/dissimilarity object and an engine from <strong>mlpack</strong>,
<strong>vegan</strong>, or <strong>ade4</strong> to calculate the MST. The result is formatted with
position aesthetics readable by <code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment()</a></code>.
</p>
<p>An MST calculated on <code>x</code> and <code>y</code> reflects the distances among the points in
<code class="reqn">X</code> in the reduced-dimension plane of the biplot. In contrast, one
calculated on the full set of coordinates reflects distances in
higher-dimensional space. Plotting this high-dimensional MST on the
2-dimensional biplot provides a visual cue as to how faithfully two
dimensions can encapsulate the &quot;true&quot; distances between points (Jolliffe,
2002).
</p>


<h3>Value</h3>

<p>A ggproto <a href="ggplot2.html#topic+layer">layer</a>.
</p>


<h3>Biplot layers</h3>

<p><code><a href="#topic+ggbiplot">ggbiplot()</a></code> uses <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> internally to produce a single data
frame with a <code>.matrix</code> column distinguishing the subjects (<code>"rows"</code>) and
variables (<code>"cols"</code>). The stat layers <code>stat_rows()</code> and <code>stat_cols()</code> simply
filter the data frame to one of these two.
</p>
<p>The geom layers <code style="white-space: pre;">&#8288;geom_rows_*()&#8288;</code> and <code style="white-space: pre;">&#8288;geom_cols_*()&#8288;</code> call the corresponding
stat in order to render plot elements for the corresponding factor matrix.
<code style="white-space: pre;">&#8288;geom_dims_*()&#8288;</code> selects a default matrix based on common practice, e.g.
points for rows and arrows for columns.
</p>


<h3>Ordination aesthetics</h3>

<p>The convenience function <code><a href="#topic+ord_aes">ord_aes()</a></code> can be used to incorporate all
coordinates of the ordination model into a statistical transformation. It
maps the coordinates to the custom aesthetics <code>..coord1</code>, <code>..coord2</code>, etc.
</p>
<p>Some transformations, e.g. <code><a href="#topic+stat_center">stat_center()</a></code>, are commutative with projection
to the 'x' and 'y' coordinates. If they detect aesthetics of the form
<code style="white-space: pre;">&#8288;..coord[0-9]+&#8288;</code>, then <code>..coord1</code> and <code>..coord2</code> are converted to <code>x</code> and <code>y</code>
while any remaining are ignored.
</p>
<p>Other transformations, e.g. <code><a href="#topic+stat_spantree">stat_spantree()</a></code>, yield different results in a
planar biplot when they are computer before or after projection. If such a
stat layer detects these aesthetics, then the lot of them are used in the
transformation.
</p>
<p>In either case, the stat layer returns a data frame with position aesthetics
<code>x</code> and <code>y</code>.
</p>


<h3>References</h3>

<p>Jolliffe IT (2002) <em>Principal Component Analysis</em>, Second Edition.
Springer Series in Statistics, ISSN 0172-7397. <a href="https://doi.org/10.1007/b98835">doi:10.1007/b98835</a>
<a href="https://link.springer.com/book/10.1007/b98835">https://link.springer.com/book/10.1007/b98835</a>
</p>


<h3>See Also</h3>

<p>Other stat layers: 
<code><a href="#topic+stat_center">stat_center</a>()</code>,
<code><a href="#topic+stat_chull">stat_chull</a>()</code>,
<code><a href="#topic+stat_cone">stat_cone</a>()</code>,
<code><a href="#topic+stat_scale">stat_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# classical multidimensional scaling of road distances between European cities
euro_mds &lt;- ordinate(eurodist, cmdscale_ord, k = 11)

# biplot with minimal spanning tree based on full-dimensional distances
# (as implemented in {mlpack})
euro_mds %&gt;%
  negate_ord("PCo2") %&gt;%
  ggbiplot() +
  stat_cols_spantree(
    ord_aes(euro_mds), engine = "mlpack",
    alpha = .5, linetype = "dotted"
  ) +
  geom_cols_text(aes(label = name), size = 3) +
  ggtitle(
    "MDS biplot of road distances between European cities",
    "Dotted segments constitute the minimal spanning tree"
  )

## End(Not run)
</code></pre>

<hr>
<h2 id='supplementation'>Supplement 'tbl_ord' objects with new data</h2><span id='topic+supplementation'></span><span id='topic+recover_supp_rows'></span><span id='topic+recover_supp_rows.default'></span><span id='topic+recover_supp_cols'></span><span id='topic+recover_supp_cols.default'></span>

<h3>Description</h3>

<p>These functions attach supplementary rows or columns to an
ordination object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recover_supp_rows(x)

## Default S3 method:
recover_supp_rows(x)

recover_supp_cols(x)

## Default S3 method:
recover_supp_cols(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supplementation_+3A_x">x</code></td>
<td>
<p>An object of class '<a href="#topic+tbl_ord">tbl_ord</a>'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code style="white-space: pre;">&#8288;recover_supp_*()&#8288;</code> <a href="base.html#topic+UseMethod">S3 methods</a> produce matrices of
supplemental rows or columns of a <a href="#topic+tbl_ord">tbl_ord</a> object from the object itself.
The motivating example is linear discriminant analysis, which produces a
natural biplot of class discriminant centroids and variable axes but is
usually supplemented with case discriminant scores. The supplementary values
are augmented with an <code>.element</code> column whose value indicates their source
and can be incorporated into a <a href="ggplot2.html#topic+fortify">tidied form</a>. If no supplementary
rows of a factor are produced, the functions return <code>NULL</code>.
</p>


<h3>Value</h3>

<p>Matrices having the same numbers of columns as returned by
<code><a href="#topic+recover_rows">recover_rows()</a></code> and <code><a href="#topic+recover_cols">recover_cols()</a></code>, or else <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other generic recoverers: 
<code><a href="#topic+augmentation">augmentation</a></code>,
<code><a href="#topic+conference">conference</a></code>,
<code><a href="#topic+recoverers">recoverers</a></code>
</p>

<hr>
<h2 id='tbl_ord'>A unified ordination object class</h2><span id='topic+tbl_ord'></span><span id='topic+as_tbl_ord'></span><span id='topic+as_tbl_ord.tbl_ord'></span><span id='topic+make_tbl_ord'></span><span id='topic+is_tbl_ord'></span><span id='topic+is.tbl_ord'></span><span id='topic+valid_tbl_ord'></span><span id='topic+un_tbl_ord'></span>

<h3>Description</h3>

<p>These functions wrap ordination objects in the class <a href="#topic+tbl_ord">tbl_ord</a>,
create tbl_ords directly from matrices, and test for the class and basic
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tbl_ord(x)

## S3 method for class 'tbl_ord'
as_tbl_ord(x)

make_tbl_ord(rows = NULL, cols = NULL, ...)

is_tbl_ord(x)

is.tbl_ord(x)

valid_tbl_ord(x)

un_tbl_ord(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_ord_+3A_x">x</code></td>
<td>
<p>An ordination object.</p>
</td></tr>
<tr><td><code id="tbl_ord_+3A_rows">rows</code>, <code id="tbl_ord_+3A_cols">cols</code></td>
<td>
<p>Matrices to be used as factors of a tbl_ord.</p>
</td></tr>
<tr><td><code id="tbl_ord_+3A_...">...</code></td>
<td>
<p>Additional elements of a custom tbl_ord.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tbl_ord class wraps around a range of ordination classes, making
available a suite of ordination tools that specialize to each original object
class. These tools include <code><a href="#topic+format">format()</a></code> and <code><a href="ggplot2.html#topic+fortify">fortify()</a></code> methods, which
facilitate the <code><a href="base.html#topic+print">print()</a></code> method and the <code><a href="#topic+ggbiplot">ggbiplot()</a></code> function.
</p>
<p>No default method is provided for <code>as_tbl_ord()</code>, despite most defined
methods being equivalent (simply appending 'tbl_ord' to the vector of object
classes). This prevents objects for which other methods are not defined from
being re-classed as tbl_ords.
</p>
<p>The function <code>make_tbl_ord()</code> creates a tbl_ord structured as a list of two
matrices, <code>u</code> and <code>v</code>, which must have the same number of columns and the
same column names.
</p>
<p><code>is_tbl_ord()</code> checks an object <code>x</code> for the tbl_ord class; <code>valid_tbl_ord()</code>
additionally checks for consistency between <code>recover_coord(x)</code> and the
columns of <code>recover_rows(x)</code> and <code>recover_cols(x)</code>, using the <a href="#topic+recoverers">recoverers</a>.
<code>un_tbl_ord()</code> removes attributes associated with the tbl_ord class in order
to restore an object that was originally passed to <code>as_tbl_ord</code>.
</p>


<h3>Value</h3>

<p>A tbl_ord (<code style="white-space: pre;">&#8288;as*()&#8288;</code>, <code style="white-space: pre;">&#8288;make*()&#8288;</code>), an S3-class model object that can be
wrapped as one (<code style="white-space: pre;">&#8288;un*()&#8288;</code>), or a logical value (<code style="white-space: pre;">&#8288;is*()&#8288;</code>, <code style="white-space: pre;">&#8288;value*()&#8288;</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustrative ordination: FA of Swiss social data
swiss_fa &lt;- factanal(swiss, factors = 3L, scores = "regression")
print(swiss_fa)

# add the 'tbl_ord' wrapper
swiss_fa_ord &lt;- as_tbl_ord(swiss_fa)
# inspect wrapped model
is_tbl_ord(swiss_fa_ord)
print(swiss_fa_ord)
valid_tbl_ord(swiss_fa_ord)
# unwrap the model
un_tbl_ord(swiss_fa_ord)

# create a 'tbl_ord' directly from row and column factors
# (missing inertia &amp; other attributes)
swiss_fa_ord2 &lt;- make_tbl_ord(rows = swiss_fa$scores, cols = swiss_fa$loadings)
# inspect wrapped factors
is_tbl_ord(swiss_fa_ord2)
print(swiss_fa_ord2)
valid_tbl_ord(swiss_fa_ord2)
# unwrap factors
un_tbl_ord(swiss_fa_ord2)
</code></pre>

<hr>
<h2 id='theme_biplot'>Biplot theme</h2><span id='topic+theme_biplot'></span>

<h3>Description</h3>

<p>Omit coordinate visual aids from biplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_biplot()
</code></pre>


<h3>Details</h3>

<p>Because the artificial axes often go uninterpreted, biplots may omit the
visual aids (tick marks and labels, grid lines) used to recover the
artificial coordinates of the row and column markers The biplot (partial)
theme removes these elements from the current theme. This can be especially
helpful when plotting <a href="#topic+geom_axis">axes</a> or <a href="#topic+geom_isoline">isolines</a>.
</p>


<h3>Value</h3>

<p>A ggplot <a href="ggplot2.html#topic+theme">theme</a>.
</p>

<hr>
<h2 id='tidiers'>Tidiers for 'tbl_ord' objects</h2><span id='topic+tidiers'></span><span id='topic+tidy.tbl_ord'></span><span id='topic+glance.tbl_ord'></span><span id='topic+fortify.tbl_ord'></span>

<h3>Description</h3>

<p>These functions return <a href="tibble.html#topic+tibble">tibbles</a> that summarize
an object of class '<a href="#topic+tbl_ord">tbl_ord</a>'. <code>tidy()</code> output contains one row per
artificial coordinate and <code>glance()</code> output contains one row for the whole
ordination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_ord'
tidy(x, ...)

## S3 method for class 'tbl_ord'
glance(x, ...)

## S3 method for class 'tbl_ord'
fortify(model, data, ..., .matrix = "dims", elements = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidiers_+3A_x">x</code>, <code id="tidiers_+3A_model">model</code></td>
<td>
<p>An object of class '<a href="#topic+tbl_ord">tbl_ord</a>'.</p>
</td></tr>
<tr><td><code id="tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments allowed by generics; currently ignored.</p>
</td></tr>
<tr><td><code id="tidiers_+3A_data">data</code></td>
<td>
<p>Passed to generic methods; currently ignored.</p>
</td></tr>
<tr><td><code id="tidiers_+3A_.matrix">.matrix</code></td>
<td>
<p>A character string partially matched (lowercase) to several
indicators for one or both matrices in a matrix decomposition used for
ordination. The standard values are <code>"rows"</code>, <code>"cols"</code>, and <code>"dims"</code> (for
both).</p>
</td></tr>
<tr><td><code id="tidiers_+3A_elements">elements</code></td>
<td>
<p>Character vector; which elements of each factor for which to
render graphical elements. One of <code>"all"</code> (the default), <code>"active"</code>, or any
supplementary element type defined by the specific class methods (e.g.
<code>"score"</code> for 'factanal', 'lda_ord', and 'cancord_ord' and <code>"intraset"</code> and
<code>"interset"</code> for 'cancor_ord').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three generics popularized by the <strong>ggplot2</strong> and <strong>broom</strong> packages make use
of the <a href="#topic+augmentation">augmentation</a> methods:
</p>

<ul>
<li><p> The <code><a href="generics.html#topic+tidy">generics::tidy()</a></code> method
summarizes information about model components, which here are the
artificial coordinates created by ordinations. The output can be passed to
<code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> to generate scree plots.
The returned columns are
</p>

<ul>
<li> <p><code>name</code>: (the name of) the coordinate
</p>
</li>
<li><p> other columns extracted from the model,
usually a single additional column of the singular or eigen values
</p>
</li>
<li> <p><code>inertia</code>: the multidimensional variance
</p>
</li>
<li> <p><code>prop_var</code>: the proportion of inertia
</p>
</li>
<li> <p><code>quality</code>: the cumulative proportion of variance
</p>
</li></ul>

</li>
<li><p> The <code><a href="generics.html#topic+glance">generics::glance()</a></code> method
reports information about the entire model, here always treated as one of a
broader class of ordination models.
The returned columns are
</p>

<ul>
<li> <p><code>rank</code>: the rank of the ordination model, i.e. the number of ordinates
</p>
</li>
<li> <p><code>n.row</code>,<code>n.col</code>: the dimensions of the decomposed matrix
</p>
</li>
<li> <p><code>inertia</code>: the total inertia in the ordination
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;prop.var.*&#8288;</code>: the proportion of variance in the first 2 ordinates
</p>
</li>
<li> <p><code>class</code>: the class of the wrapped model object
</p>
</li></ul>

</li>
<li><p> The <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> method
augments and collapses row and/or column data, depending on <code>.matrix</code> and
<code>.element</code>, into a single tibble, in preparation for <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
Its output resembles that of <code><a href="generics.html#topic+augment">generics::augment()</a></code>, though rows in the
output may correspond to rows, columns, or both of the original data. If
<code>.matrix</code> is passed <code>"rows"</code>, <code>"cols"</code>, or <code>"dims"</code> (for both), then
<code>fortify()</code> returns a tibble whose fields are obtained, in order, via
<code style="white-space: pre;">&#8288;get_*()&#8288;</code>, <code style="white-space: pre;">&#8288;recover_aug_*()&#8288;</code>, and <code style="white-space: pre;">&#8288;annotation_*()&#8288;</code>.
</p>
</li></ul>

<p>The tibble is assigned a <code>"coordinates"</code> attribute whose value is obtained
via <code><a href="#topic+get_coord">get_coord()</a></code>. This facilitates some downstream functionality that relies
on more than those coordinates used as position aesthetics in a biplot, in
particular <code><a href="#topic+stat_spantree">stat_spantree()</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+augmentation">augmentation</a> methods that must interface with tidiers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># illustrative ordination: PCA of iris data
iris_pca &lt;- ordinate(iris, ~ prcomp(., center = TRUE, scale. = TRUE), seq(4L))

# use `tidy()` to summarize distribution of inertia
tidy(iris_pca)
# this facilitates scree plots
tidy(iris_pca) %&gt;%
  ggplot(aes(x = name, y = prop_var)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent) +
  labs(x = NULL, y = "Proportion of variance")

# use `fortify()` to prepare either matrix factor for `ggplot()`
fortify(iris_pca, .matrix = "V") %&gt;%
  ggplot(aes(x = name, y = PC1)) +
  geom_col() +
  coord_flip() +
  labs(x = "Measurement")
iris_pca %&gt;%
  fortify(.matrix = "U") %&gt;%
  ggplot(aes(x = PC1, fill = Species)) +
  geom_histogram() +
  labs(y = NULL)
# ... or to prepare both for `ggbiplot()`
fortify(iris_pca)

# use `glance()` to summarize the model as an ordination
glance(iris_pca)
# this enables comparisons to other models
rbind(
  glance(ordinate(subset(iris, Species == "setosa"), prcomp, seq(4L))),
  glance(ordinate(subset(iris, Species == "versicolor"), prcomp, seq(4L))),
  glance(ordinate(subset(iris, Species == "virginica"), prcomp, seq(4L)))
)
</code></pre>

<hr>
<h2 id='wrap-ord'>Wrappers for lossy ordination methods</h2><span id='topic+wrap-ord'></span><span id='topic+eigen_ord'></span><span id='topic+svd_ord'></span><span id='topic+cmdscale_ord'></span><span id='topic+cancor_ord'></span>

<h3>Description</h3>

<p>These <code style="white-space: pre;">&#8288;*_ord&#8288;</code> functions wrap core R functions with modifications
for use with '<a href="#topic+tbl_ord">tbl_ord</a>' methods. Some parameters are hidden from the user
and set to settings required for these methods, some matrix outputs are
given row or column names to be used by them, and new '*_ord' S3 class
attributes are added to enable them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_ord(x, symmetric = isSymmetric.matrix(x))

svd_ord(x, nu = min(dim(x)), nv = min(dim(x)))

cmdscale_ord(d, k = 2, add = FALSE)

cancor_ord(x, y, xcenter = TRUE, ycenter = TRUE, scores = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap-ord_+3A_x">x</code></td>
<td>
<p>a numeric or complex matrix whose spectral decomposition is to
be computed.  Logical matrices are coerced to numeric.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_symmetric">symmetric</code></td>
<td>
<p>if <code>TRUE</code>, the matrix is assumed to be symmetric
(or Hermitian if complex) and only its lower triangle (diagonal
included) is used.  If <code>symmetric</code> is not specified,
<code><a href="base.html#topic+isSymmetric">isSymmetric</a>(x)</code> is used.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_nu">nu</code></td>
<td>
<p>the number of left  singular vectors to be computed.
This must between <code>0</code> and <code>n = nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_nv">nv</code></td>
<td>
<p>the number of right singular vectors to be computed.
This must be between <code>0</code> and <code>p = ncol(x)</code>.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by <code>dist</code>
or a full symmetric matrix containing the dissimilarities.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_k">k</code></td>
<td>
<p>the maximum dimension of the space which the data are to be
represented in; must be in <code class="reqn">\{1, 2, \ldots, n-1\}</code>.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_add">add</code></td>
<td>
<p>logical indicating if an additive constant <code class="reqn">c*</code> should
be computed, and added to the non-diagonal dissimilarities such that
the modified dissimilarities are Euclidean.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_y">y</code></td>
<td>
<p>numeric matrix (<code class="reqn">n \times p_2</code>), containing the
y coordinates.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_xcenter">xcenter</code></td>
<td>
<p>logical or numeric vector of length <code class="reqn">p_1</code>,
describing any centering to be done on the x values before the
analysis.  If <code>TRUE</code> (default), subtract the column means.
If <code>FALSE</code>, do not adjust the columns.  Otherwise, a vector
of values to be subtracted from the columns.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_ycenter">ycenter</code></td>
<td>
<p>analogous to <code>xcenter</code>, but for the y values.</p>
</td></tr>
<tr><td><code id="wrap-ord_+3A_scores">scores</code></td>
<td>
<p>Logical; whether to return canonical scores and structure
correlations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following table summarizes the wrapped functions:</p>

<table>
<tr>
 <td style="text-align: left;">
   Original function </td><td style="text-align: left;"> Hide params </td><td style="text-align: left;"> New params </td><td style="text-align: left;"> Add names </td><td style="text-align: left;"> New class </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="base.html#topic+eigen">base::eigen()</a></code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="base.html#topic+svd">base::svd()</a></code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="stats.html#topic+cmdscale">stats::cmdscale()</a></code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="stats.html#topic+cancor">stats::cancor()</a></code> </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>By default, <code><a href="#topic+cancor_ord">cancor_ord()</a></code> returns the same data as <code><a href="stats.html#topic+cancor">stats::cancor()</a></code>: the
canonical correlations (<code>cor</code>), the canonical coefficients (<code style="white-space: pre;">&#8288;$xcoef&#8288;</code> and
<code style="white-space: pre;">&#8288;$ycoef&#8288;</code>), and the variable means (<code style="white-space: pre;">&#8288;$xcenter&#8288;</code>, <code style="white-space: pre;">&#8288;$ycenter&#8288;</code>). If <code>scores = TRUE</code>, then <code><a href="#topic+cancor_ord">cancor_ord()</a></code> also returns the scores <code style="white-space: pre;">&#8288;$xscores&#8288;</code> and <code style="white-space: pre;">&#8288;$yscores&#8288;</code>
calculated from the (appropriately centered) data and the coefficients and
the intraset structure correlations <code style="white-space: pre;">&#8288;$xstructure&#8288;</code> and <code style="white-space: pre;">&#8288;$ystructure&#8288;</code> between
these and the data. These modifications are inspired by the <code>cancor()</code>
function in <strong>candisc</strong>, though two caveats should be noted: First, the
canonical coefficients (hence the canonical scores) are scaled by <code class="reqn">n - 1</code>
compared to these, though the intraset structure correlations are the same.
Second, the <em>interset</em> structure correlations are not returned, as these may
be obtained by conferring inertia unto the intraset ones.
</p>


<h3>Value</h3>

<p>Objects slightly modified from the outputs of the original functions,
with new '*-ord' classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># glass composition data from one furnace
glass_banias &lt;- subset(
  glass,
  Context == "L.15;B.166",
  select = c("SiO2", "Na2O", "CaO", "Al2O3", "MgO", "K2O")
)
# eigendecomposition of a covariance matrix
(glass_cov &lt;- cov(glass_banias))
eigen_ord(glass_cov)
# singular value decomposition of a data matrix
svd_ord(glass_banias)
# classical multidimensional scaling of a distance matrix
cmdscale_ord(dist(glass_banias))

# canonical correlation analysis with trace components
glass_banias_minor &lt;- subset(
  glass,
  Context == "L.15;B.166",
  select = c("TiO2", "FeO", "MnO", "P2O5", "Cl", "SO3")
)
# impute half of detection threshold
glass_banias_minor$TiO2[[1L]] &lt;- 0.5
cancor_ord(glass_banias, glass_banias_minor)

# calculate canonical scores and structure correlations
glass_cca &lt;-
  cancor_ord(glass_banias[, 1:3], glass_banias_minor[, 1:3], scores = TRUE)
# scores
glass_cca$xscores
# intraset correlations
glass_cca$xstructure
# interset correlations
glass_cca$xstructure %*% diag(glass_cca$cor)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
