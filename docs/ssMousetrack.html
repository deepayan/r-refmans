<!DOCTYPE html><html><head><title>Help for package ssMousetrack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ssMousetrack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ssMousetrack-package'><p>Bayesian State-Space Modeling of Mouse-Tracking Experiments Via Stan</p></a></li>
<li><a href='#check_prior'><p>Check prior distributions</p></a></li>
<li><a href='#compute_D'><p>Compute the matrix of distances D for kappa parameters</p></a></li>
<li><a href='#congruency'><p>Mouse-tracking experiment of a memory task</p></a></li>
<li><a href='#evaluate_ssm'><p>Evaluate the adequacy of the state-space model to reproduce the observed data</p></a></li>
<li><a href='#generate_data'><p>Generate datasets according to the model structure</p></a></li>
<li><a href='#generate_design'><p>Generate the design of a mouse-tracking experiment</p></a></li>
<li><a href='#generate_Z'><p>Generate a row-wise stacked boolean partition matrix of JI rows and K columns</p></a></li>
<li><a href='#language'><p>Mouse-tracking experiment of a lexical decision task</p></a></li>
<li><a href='#prepare_data'><p>Prepare mouse-tracking trajectories for state-space modeling via Stan</p></a></li>
<li><a href='#run_ssm'><p>State-space modeling of mouse-tracking trajectories via Stan</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian State-Space Modeling of Mouse-Tracking Experiments via
Stan</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-05</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates previously compiled state-space modeling for mouse-tracking experiments using the 'rstan' package, which provides the R interface to the Stan C++ library for Bayesian estimation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.4.0), Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.18.2), rstantools (&ge; 1.5.1), CircStats, dtw,
ggplot2, cowplot, RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0-1), Rcpp (&ge; 1.0.0), RcppEigen (&ge; 0.3.3.5.0),
rstan (&ge; 2.18.2), StanHeaders (&ge; 2.18.0), RcppParallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Calcagnì, Massimiliano Pastore</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Calcagnì &lt;ant.calcagni@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/antcalcagni/ssMousetrack/issues">https://github.com/antcalcagni/ssMousetrack/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-05 14:54:02 UTC; antonio</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-05 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ssMousetrack-package'>Bayesian State-Space Modeling of Mouse-Tracking Experiments Via Stan</h2><span id='topic+ssMousetrack-package'></span><span id='topic+ssMousetrack'></span>

<h3>Description</h3>

<p>The <span class="pkg">ssMousetrack</span> package allows analysing mouse-tracking experiments via Bayesian state-space modeling.
The package estimates the model using Markov Chain Monte Carlo, variational approximations to the posterior distribution, or optimization,
as implemented in the <span class="pkg">rstan</span> package. The user can use the customary R modeling syntax to define equations of the model and Stan syntax to
specify priors over the model parameters.
</p>
<p>The sections below provide an overview of the state-space model implemented by the <span class="pkg">ssMousetrack</span> package.
</p>


<h3>Details</h3>

<p><em>(i) Mouse-tracking data</em>
</p>
<p>The raw data of a mouse-tracking experiment for <em>I</em> individuals and <em>J</em> stimuli consist of a collection of arrays
<code class="reqn">(x,y)_{ij} = (x_0,...,x_{N_{ij}}; y_0,...,y_{N_{ij}})</code> which contain ordered <code class="reqn">N_{ij}</code> x 1 sequences of x-y Cartesian coordinates as mapped to the
computer-mouse pointer. The x-y coordinates are pre-processed according to the following steps:
</p>

<ol>
<li> <p><em>Realigning</em>: the arrays <code class="reqn">(x,y)_{ij}</code> are re-aligned on a common sampling scale, so that <em>N</em> indicates the cumulative amount of progressive time from 0% to N = 100%, with <em>N</em> being the same over <code class="reqn">i=1,...,I</code> and <code class="reqn">j=1,...,J</code>
</p>
</li>
<li> <p><em>Normalization</em>: the aligned arrays <code class="reqn">(x,y)_{ij}</code> are normalized so that <code class="reqn">(x_0,y_0)_{ij}=(0,0)</code> and <code class="reqn">(x_N,y_N)_{ij}=(1,1)</code> for each <code class="reqn">i=1,...,I</code> and <code class="reqn">j=1,...,J</code>
</p>
</li>
<li> <p><em>Translation</em>: the normalized arrays <code class="reqn">(x,y)_{ij}</code> are translated into the quadrant <code class="reqn">[-1,1]</code>x<code class="reqn">[0,1]</code>
</p>
</li>
<li> <p><em>atan2 projection</em>: the final arrays <code class="reqn">(x,y)_{ij}</code> are projected onto a lower-subspace via the <em>atan2</em> function by getting the ordered collection
of radians <code class="reqn">(y)_{ij} = (y_0,...,y_N)</code> in the subset of reals <code class="reqn">(0,\pi]^N</code>, for each <code class="reqn">i=1,...,I</code> and <code class="reqn">j=1,...,J</code>.
</p>
</li></ol>

<p>The final I x J x N array of data <strong>Y</strong> contains the mouse-tracking trajectories expressed in terms of angles. These trajectories lie on the arc defined by
the union of two disjoint sets, namely the sets <code class="reqn">\{y_0,...,y_N: y_n \geq \pi/2 \}</code> (target's hemispace) and <code class="reqn">\{y_0,...,y_N: y_n &lt; (3\pi)/4 \}</code> (distractor's hemispace), with <code class="reqn">\pi/2</code> and <code class="reqn">(3\pi)/4</code> being the location points for target and distractor, respectively.
</p>
<p>Note that, the current version of <span class="pkg">ssMousetrack</span> package requires the number of stimuli J to be the same over the subjects <code class="reqn">i=1,...,I</code>.
</p>
<p>The pre-processed mouse-tracking trajectories are analysed using the state-space modeling described below.
</p>
<p><em>(ii) Model representation</em>
</p>
<p>The array <strong>Y</strong> contains the <em>observed data</em> expressed in angles. The <em>measurement equation</em> of the model is:
</p>
<p style="text-align: center;"><code class="reqn"> y_{ij}^{(n)} \sim vonMises\big(\mu_{ij}^{(n)},\kappa_{ij}^{(n)}\big) </code>
</p>

<p>where <code class="reqn">\mu_{ij}^{(n)}</code> and <code class="reqn">\kappa_{ij}^{(n)}</code> are the location and the concentration parameters for the vonMises probability law.
The moving mean on the arc <code class="reqn">\mu_{ij}^{(n)}</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> \mu_{ij}^{(n)} := G(\beta,x_{i}^{(n)})</code>
</p>

<p>with <code class="reqn">\beta</code> being a J x 1 array of real parameters representing the contribution of the <em>j</em>-th stimulus on the observed trajectory <code class="reqn">y_{ij} = (y^{(0)},...,y^{(N)})</code>
whereas <code class="reqn">G</code> is a non-linear function mapping reals to the subset <code class="reqn">(0,\pi]</code> of the form: (i) <code class="reqn">\big[ (1 + \exp(\beta - x_{i}^{(n)})) \big]\pi^{-1} </code> (logistic), (ii) <code class="reqn">\big[ \exp(-\beta \exp(-x_{i}^{(n)})) \big]\pi</code> (gompertz).
In the <code class="reqn">G</code> equation, <code class="reqn">x_i^{(n)}</code> is a real random quantity obeying to the law:
</p>
<p style="text-align: center;"><code class="reqn"> x_i^{(n)} \sim Normal\big( x_i^{(n-1)},\sigma^2_i \big) </code>
</p>

<p>which represents a random walk process with time-fixed variance <code class="reqn">\sigma^2_i</code>. The terms <code class="reqn">x_{i} = (x_{i}^{(0)},...,x_{i}^{(N)})</code> are the individual latent dynamics
unaffected by the stimuli (i.e., how individual differ in executing the task) whereas <code class="reqn">\beta</code> contains the experimental effects regardless to the individual dynamic (i.e., how experimental variables act on the individual dynamics to produce the observed responses).
</p>
<p>The terms <code class="reqn">\beta = (\beta_1,...,\beta_J)</code> are defined according to the following linear combination:
</p>
<p style="text-align: center;"><code class="reqn"> \beta_j :=  \sum_{k=1}^K z_{jk}\gamma_k</code>
</p>

<p>where <code class="reqn">z_{jk}</code> is an element of the J x K <em>dummy matrix</em> <strong>Z</strong> representing main and high-order effects of the experimental design.
</p>
<p>The terms <code class="reqn">\kappa_{ij} = (\kappa_{ij}^{(0)},...,\kappa_{ij}^{(N)})</code> are computed as follows:
</p>
<p style="text-align: center;"><code class="reqn"> \kappa_{ij}^{(n)} := \exp^{o}\big(\delta_{ij}^{(n)}\big) </code>
</p>

<p>where <code class="reqn">\delta^{(n)}_{ij} = |y_{ij}^{(n)}-(3\pi)/4|</code> (if <code class="reqn">y_{ij}^{(n)} &lt; \pi/2</code>) or <code class="reqn">\delta^{(n)}_{ij} = |y_{ij}^{(n)}-\pi/4|</code> (if <code class="reqn">y_{ij}^{(n)} \geq \pi/2</code>). The function <code class="reqn">\exp^o</code> is the exponential function scaled in the natural range of the parameters <code class="reqn">\kappa_{ij}</code> (positive real numbers).
</p>
<p><em>(iii) Bayesian formulation</em>
</p>
<p>The state-space model in the <span class="pkg">ssMousetrack</span> package requires estimating the array of latent trajectories <strong>X</strong> and the K x 1 parameters <code class="reqn">\gamma</code>.
Let <code class="reqn">\Theta</code> representing both the unknown quantities, the posterior density after factorization is:
</p>
<p style="text-align: center;"><code class="reqn"> f(\Theta|Y) \propto f(\gamma) \prod_{i=1}^I \prod_{j=1}^J f(\gamma|y_{ij}) \prod_{i=1}^I \prod_{j=1}^J f(x_i|y_{ij}) </code>
</p>

<p>Sampling from <code class="reqn">f(\Theta|Y)</code> is solved via <em>marginal MCMC</em> where the term <code class="reqn">f(x_i|y_{ij})</code> is approximated by means of Kalman filtering/smoothing. The marginal Likelihood of the model used for the rejection criterion of the MCMC sampler is approximated with the Normal distribution using the Kalman filter theory.
</p>


<h3>References</h3>

<p>Calcagnì, A., Lombardi, L., &amp; D'Alessandro, M. (2018). A state space approach to dynamic modeling of mouse-tracking data. <em>Frontiers in Psychology: Quantitative Psychology and Measurement</em>, 10, 2716
</p>
<p>Calcagnì, A., Lombardi, L., &amp; D'Alessandro, M. (2018). A state space approach to dynamic modeling of mouse-tracking data. <em>Under review</em>
</p>
<p>Calcagnì, A., Lombardi, L., &amp; D'Alessandro (2018, August). Probabilistic modeling of mouse-tracking data: A statespace approach. Paper presented at the <em>2018 European Mathematical Psychology Group Meeting</em> (EMPG 2018), Genova, Italy
</p>
<p>Calcagnì, A., Lombardi, L., D'Alessandro, M., &amp; Sulpizio S. (2018, March). A subject oriented state-space approach to model mouse-tracking data. Paper presented at the <em>60th Conference of Experimental Psychologists</em> (TeaP 2018), Marburg, Germany
</p>
<p>Freeman, J. B. (2018). Doing psychological science by hand. <em>Current Directions in Psychological Science</em>, In press, 1-9
</p>
<p>Särkkä, S. (2013). Bayesian Filtering and Smoothing. <em>Cambridge University Press</em>
</p>
<p>Durbin, J., &amp; Koopman, S. J. (2012). Time series analysis by state space methods (Vol. 38). <em>Oxford University Press</em>
</p>
<p>Andrieu, C., Doucet, A., &amp; Holenstein, R. (2010). Particle markov chain monte carlo methods. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 72(3), 269s-342
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., &amp; Rubin, D. B. (2004). Bayesian Data Analysis (Second edition). Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><a href="https://mc-stan.org/">https://mc-stan.org/</a> for more information on the Stan C++ language used by <span class="pkg">ssMousetrack</span> package
</p>
<p>Jokkala, J. (2016). Github repository: <em>kalman-stan-randomwalk</em>, <a href="https://github.com/juhokokkala/kalman-stan-randomwalk">https://github.com/juhokokkala/kalman-stan-randomwalk</a>
</p>

<hr>
<h2 id='check_prior'>Check prior distributions</h2><span id='topic+check_prior'></span>

<h3>Description</h3>

<p>Check prior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prior(priors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_prior_+3A_priors">priors</code></td>
<td>
<p>(list) a list of arguments specifying priors for each parameter involved in the model (see Details). If <code>priors=NULL</code> then predefined priors will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to specify the prior-related arguments of the state-space modeling function <code><a href="#topic+run_ssm">run_ssm</a></code>. Priors are specified in terms of distributions and associated parameters as implemented in the <span class="pkg">rstan</span> package.
The available options are as follows:
</p>

<ul>
<li> <p><code>lognormal(mu,sigma)</code> (code = 1, required parameters = 2)
</p>
</li>
<li> <p><code>normal(mu,sigma)</code> (code = 2, required parameters = 2)
</p>
</li>
<li> <p><code>normal(mu,sigma)T(min,max)</code> (code = 201, required parameters = 4)
</p>
</li>
<li> <p><code>chi_square(df)</code> (code = 3, required parameters = 1)
</p>
</li>
<li> <p><code>inv_chi_square(df)</code> (code = 4, required parameters = 1)
</p>
</li>
<li> <p><code>gamma(alpha,beta)</code> (code = 5, required parameters = 2)
</p>
</li>
<li> <p><code>pareto(min,alpha)</code> (code = 6, required parameters = 2)
</p>
</li>
<li> <p><code>uniform(min,max)</code> (code = 7, required parameters = 2)
</p>
</li></ul>

<p>This is an internal function, generally not to be called by the user.
</p>


<h3>Value</h3>

<p>a matrix contatining priors (numeric codes, see Details) and their parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Define priors for all the paramaters 
priors_list &lt;- list("lognormal(1,1)","normal(2,3)T(0,10)","normal(3,1)")
priors_out &lt;- check_prior(priors_list)
print(priors_out)

## Define priors for some of the paramaters 
priors_list &lt;- list(NULL,"pareto(1,1.2)",NULL)
priors_out &lt;- check_prior(priors_list)
print(priors_out)

## Use pre-defined vague priors for all the parameters
priors_list &lt;- list(NULL,NULL,NULL)
priors_out &lt;- check_prior(priors_list)
print(priors_out)

## End(Not run)
</code></pre>

<hr>
<h2 id='compute_D'>Compute the matrix of distances D for kappa parameters</h2><span id='topic+compute_D'></span>

<h3>Description</h3>

<p>Compute the matrix of distances D for kappa parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_D(Y = NULL, y_T = pi/4, y_D = (3 * pi)/4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_D_+3A_y">Y</code></td>
<td>
<p>(matrix) N x JI matrix of observed trajectories</p>
</td></tr>
<tr><td><code id="compute_D_+3A_y_t">y_T</code></td>
<td>
<p>(numeric) position in angles of the target</p>
</td></tr>
<tr><td><code id="compute_D_+3A_y_d">y_D</code></td>
<td>
<p>(numeric) position in angles of the distractor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compute the distance of the Y-trajectories from the distractor and target points. This is an internal function, generally not to be called by the user.
</p>


<h3>Value</h3>

<p>a N x JI matrix containing the delta values for each data point in Y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a generic matrix Y of I = 5 individuals and J = 1 trajectories (N = 61)
I &lt;- 5; N &lt;- 61
y_T &lt;- pi/4; y_D &lt;- (3*pi)/4
Y &lt;- matrix(stats::rnorm(n = N*I,mean = (y_T+y_D)/2,sd = 10),N,I)
DY &lt;- compute_D(Y=Y,y_T=y_T,y_D=y_D)

</code></pre>

<hr>
<h2 id='congruency'>Mouse-tracking experiment of a memory task</h2><span id='topic+congruency'></span>

<h3>Description</h3>

<p>This dataset contains a subset of data originally presented in Coco &amp; Duran (2016). In this task 
participants see sentence and scene pairs that varied in plausibility and are requested 
to classify the pairs as congruent or incongruent. The experimental variables are <em>congruency</em> with two categorical levels (i.e., congruent, incongruent) and
<em>plausibility</em> with two categorical levels (i.e., plausible, implausible). Participants have to classify each stimulus as belonging to one of these four levels. 
</p>
<p>The dataset contains two participants (I=2), each measured along three trials, two categorical variables (Q=2) each with two levels (K=2). The total number of trials is J=12.
Mouse-tracking trajectories are raw-data, i.e. they have not been previously pre-processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruency
</code></pre>


<h3>Format</h3>

<p>A long-format dataframe of 728 observations containing 
information on the following variables.
</p>

<dl>
<dt>sbj</dt><dd><p>The ID number of participants</p>
</dd>
<dt>trial</dt><dd><p>The ID number of trials</p>
</dd>
<dt>congruency</dt><dd><p>A factor of levels <code>congruent</code>, <code>incongruent</code></p>
</dd>
<dt>plausibility</dt><dd><p>A factor of levels <code>plausible</code>, <code>implausible</code></p>
</dd>
<dt>timestep</dt><dd><p>The ID number of the recorded x-y trajectories</p>
</dd> 
<dt>x</dt><dd><p>The recorded x-trajectories</p>
</dd>
<dt>y</dt><dd><p>The recorded y-trajectories</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coco, M. I., &amp; Duran, N. D. (2016). When expectancies collide: 
Action dynamics reveal the interaction between stimulus plausibility and congruency. 
<em>Psychonomic bulletin &amp; review</em>, 23(6), 1920-1931.
</p>

<hr>
<h2 id='evaluate_ssm'>Evaluate the adequacy of the state-space model to reproduce the observed data</h2><span id='topic+evaluate_ssm'></span>

<h3>Description</h3>

<p>Evaluate the adequacy of the state-space model to reproduce the observed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_ssm(ssmfit = NULL, M = 100, plotx = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_ssm_+3A_ssmfit">ssmfit</code></td>
<td>
<p>(list) output of <code><a href="#topic+run_ssm">run_ssm</a></code> function</p>
</td></tr>
<tr><td><code id="evaluate_ssm_+3A_m">M</code></td>
<td>
<p>(integer) number of replications</p>
</td></tr>
<tr><td><code id="evaluate_ssm_+3A_plotx">plotx</code></td>
<td>
<p>(boolean) if <code>plotx=TRUE</code> the function returns a graphical representation for the fit indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a simulated-based method for assessing the adequacy of the model to reproduce the observed data. In particular,
the function provides two type of model adequacy, i.e. overall (PA_ov) and by-subject (PA_sbj). In the overall case the function provides the total amount of data reconstruction 
based on the I x J x N matrix Y of observed data. By contrast, in the second case the function provides the adequacy of the model to reconstruct the individual-based set of data
as it works on the matrix J x N over i=1,...,I. Both the indices are in the range 0% - 100%, with 100% indicating perfect fit. In addition, the function returns a by-subject distance-based index (Dynamic Timw Warp distance) between observed and reproduced trajectories using <code><a href="dtw.html#topic+dtw">dtw</a></code> function.
</p>


<h3>Value</h3>

<p>a datalist containing the adequacy indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Fit a state-space model using simulated data 
# Generate mouse-tracking data for an univariate experimental design with K = 3 categorical levels, 
## J = 12 trials, I = 5 subjects
X1 &lt;- generate_data(I=5,J=12,K=3,Z.formula="~Z1")
iid &lt;- 23 # keep just one dataset from the simulated set of datasets
# Run the state-space model on the chosen dataset
X1_fit &lt;- run_ssm(N = X1$N,I = X1$I,J = X1$J,Y = X1$data$Y[iid,,],D = X1$data$D[iid,,],
Z = X1$data$Z,niter=100,nwarmup=25)
# Evaluate the state-space model
evaluate_ssm(ssmfit = X1_fit,M = 10,plotx=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='generate_data'>Generate datasets according to the model structure</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p>Generate datasets according to the model structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(
  M = 100,
  N = 61,
  I = 10,
  J = 12,
  K = c(4),
  Z.type = c("symmetric"),
  Z.contrast = "treatment",
  Z.formula = NULL,
  sigmax = 1,
  lambda = 1,
  yT = pi/4,
  yD = (3 * pi)/4,
  kappa_bnds = c(120, 300),
  priors = "default",
  gfunction = c("logistic", "gompertz"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_data_+3A_m">M</code></td>
<td>
<p>(integer) number of simulated datasets</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n">N</code></td>
<td>
<p>(integer) length of the Y-trajectories</p>
</td></tr>
<tr><td><code id="generate_data_+3A_i">I</code></td>
<td>
<p>(integer) number of individuals</p>
</td></tr>
<tr><td><code id="generate_data_+3A_j">J</code></td>
<td>
<p>(integer) number of trials</p>
</td></tr>
<tr><td><code id="generate_data_+3A_k">K</code></td>
<td>
<p>(array of integers) list of length Q of the number of levels for each categorical variable</p>
</td></tr>
<tr><td><code id="generate_data_+3A_z.type">Z.type</code></td>
<td>
<p>(array of characters) list of length Q of the methods (symmetric or random) to generate the matrix (see <code><a href="#topic+generate_Z">generate_Z</a></code>)</p>
</td></tr>
<tr><td><code id="generate_data_+3A_z.contrast">Z.contrast</code></td>
<td>
<p>(character) type of contrasts (default: treatment) for the model matrix Z (see <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>)</p>
</td></tr>
<tr><td><code id="generate_data_+3A_z.formula">Z.formula</code></td>
<td>
<p>(character) a formula of the contrasts for the model matrix Z (see <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>)</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sigmax">sigmax</code></td>
<td>
<p>(numeric) fixed value for the model parameter sigmax</p>
</td></tr>
<tr><td><code id="generate_data_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) fixed value for the model parameter lambda</p>
</td></tr>
<tr><td><code id="generate_data_+3A_yt">yT</code></td>
<td>
<p>(numeric) position in angles of the target</p>
</td></tr>
<tr><td><code id="generate_data_+3A_yd">yD</code></td>
<td>
<p>(numeric) position in angles of the distractor</p>
</td></tr>
<tr><td><code id="generate_data_+3A_kappa_bnds">kappa_bnds</code></td>
<td>
<p>(array) array containing the lower and upper bounds for the kappa parameter (<code>default = c(120,300)</code>)</p>
</td></tr>
<tr><td><code id="generate_data_+3A_priors">priors</code></td>
<td>
<p>(list) a list of arguments specifying priors for each parameter involved in the model (see <code><a href="#topic+check_prior">check_prior</a></code>). If <code>priors="default"</code> then pre-defined priors will be used.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_gfunction">gfunction</code></td>
<td>
<p>(character) type of link function between latent states and observed data: 'logistic', 'gompertz' (<code>default = 'logistic'</code>).</p>
</td></tr>
<tr><td><code id="generate_data_+3A_...">...</code></td>
<td>
<p>other stan arguments (e.g., 'init', 'algorithm', 'sample_file'. See <code><a href="rstan.html#topic+sampling">sampling</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates simulated datasets via Stan according to the model structure.
</p>


<h3>Value</h3>

<p>a datalist containing simulated data and parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Generate mouse-tracking data for an univariate experimental design 
## with K = 3 categorical levels, J = 30 trials, I = 8 subjects
X1 &lt;- generate_data(I=5,J=12,K=3,Z.formula="~Z1",M=50)

## Generate mouse-tracking data for an univariate experimental design 
## by varying priors of parameters
priors_list = list("normal(0,1)T(0,Inf)","normal(0,1)","normal(-2,0.5)")
X1 &lt;- generate_data(I=5,J=12,K=3,Z.formula="~Z1",M=50,priors=priors_list)

## Generate mouse-tracking data with two experimental factors Z1 and Z2, J = 9 trials, 
## K_Z1 = 3, K_Z2 = 3, I = 5 subjects
X2 &lt;- generate_data(I=5,J=9,K=c(3,3),Z.formula="~Z1*Z2",
Z.type=c("symmetric","random"),M=50) # design with interaction

## End(Not run)
</code></pre>

<hr>
<h2 id='generate_design'>Generate the design of a mouse-tracking experiment</h2><span id='topic+generate_design'></span>

<h3>Description</h3>

<p>Generate the design of a mouse-tracking experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_design(I = 10, J = 12, K = c(4), Z.type = c("symmetric"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_design_+3A_i">I</code></td>
<td>
<p>(integer) number of individuals</p>
</td></tr>
<tr><td><code id="generate_design_+3A_j">J</code></td>
<td>
<p>(integer) number of trials</p>
</td></tr>
<tr><td><code id="generate_design_+3A_k">K</code></td>
<td>
<p>(list of integers) list of length Q of the number of levels for each categorical variable</p>
</td></tr>
<tr><td><code id="generate_design_+3A_z.type">Z.type</code></td>
<td>
<p>(list of characters) list of length Q of the methods (symmetric or random) to generate the matrix (see <code><a href="#topic+generate_Z">generate_Z</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a dataframe containing the experimental design of a mouse-tracking study. The design is of the order (sbj,trial,variable1,...variableQ), where variable1,...,variableQ are Q categorical variables each with K_1,...,K_Q levels. The levels are codified using hundreds.
This is an internal function, generally not to be called by the user.
</p>


<h3>Value</h3>

<p>a dataframe of the order (sbj,trial,variable1,...variableQ)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a design with Q = 2 categorical variables:
## the first variable has K = 4 levels generated via symmetric method
## the second variable has K = 3 levels generated via random method.
X &lt;- generate_design(I = 10, J = 12, K = c(4,3), Z.type = c("symmetric","random"))
print(X)
</code></pre>

<hr>
<h2 id='generate_Z'>Generate a row-wise stacked boolean partition matrix of JI rows and K columns</h2><span id='topic+generate_Z'></span>

<h3>Description</h3>

<p>Generate a row-wise stacked boolean partition matrix of JI rows and K columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_Z(I, J, K, type = c("symmetric", "random"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_Z_+3A_i">I</code></td>
<td>
<p>(integer) number of individuals</p>
</td></tr>
<tr><td><code id="generate_Z_+3A_j">J</code></td>
<td>
<p>(integer) number of trials</p>
</td></tr>
<tr><td><code id="generate_Z_+3A_k">K</code></td>
<td>
<p>(integer) number of levels for a categorical variables</p>
</td></tr>
<tr><td><code id="generate_Z_+3A_type">type</code></td>
<td>
<p>(character) method to generate the matrix: symmetric (default) or random</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a (JI x K) boolean partition matrix for I individuals, J stimuli and K categories. Note that J and K must be chosen so that J
This is an internal function, generally not to be called by the user.
</p>


<h3>Value</h3>

<p>a (JI x K) boolean matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- generate_Z(I = 2,J = 12,K = 4,type="symmetric")
print(Z)

</code></pre>

<hr>
<h2 id='language'>Mouse-tracking experiment of a lexical decision task</h2><span id='topic+language'></span>

<h3>Description</h3>

<p>This dataset contains a subset of data originally presented in Barca &amp; Pezzullo (2012). In this task 
participants see a printed stimulus on the screen (e.g., water) and are requested 
to perform a dichotomous choice task where the stimulus can be classified as word or non-word. The experimental variable is the <em>stimulus type</em> with four categorical levels (i.e., high-frequency word, low-frequency word, pseudowords, and strings of letters). 
Participants have to classify each stimulus as belonging to word or non-word categories. 
</p>
<p>The dataset contains five participants (I=5), each measured along three trials, one categorical variable (Q=1) with four levels (K=4). The total number of trials is J=12. 
Mouse-tracking trajectories have previously been pre-processed with N=101 timesteps, translated into the first quadrant,
and rotated so that the Target point (y_T) is always on the right-side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language
</code></pre>


<h3>Format</h3>

<p>A long-format dataframe of 6060 observations containing 
information on the following variables.
</p>

<dl>
<dt>sbj</dt><dd><p>The ID number of participants</p>
</dd>
<dt>condition</dt><dd><p>A factor of levels <code>HF</code>, <code>LF</code>, <code>PW</code>, <code>NW</code> indicating the type of stimulus</p>
</dd>
<dt>timestep</dt><dd><p>The ID number of the recorded x-y trajectories</p>
</dd> 
<dt>x</dt><dd><p>The recorded x-trajectories</p>
</dd>
<dt>y</dt><dd><p>The recorded y-trajectories</p>
</dd>
<dt>trial</dt><dd><p>The ID number of trials</p>
</dd>
</dl>



<h3>Source</h3>

<p>Barca, L., &amp; Pezzulo, G. (2012). 
Unfolding visual lexical decision in time. 
<em>PloS one</em>, 7(4), e35932.
</p>

<hr>
<h2 id='prepare_data'>Prepare mouse-tracking trajectories for state-space modeling via Stan</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>Prepare mouse-tracking trajectories for state-space modeling via Stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(
  X = NULL,
  preprocess = TRUE,
  N = 61,
  Z.formula = NULL,
  Z.contrast = "treatment",
  yT = "AUTO",
  yD = "AUTO"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_x">X</code></td>
<td>
<p>(dataframe) a data frame of x-y trajectories and experimental design (see <code>Details</code>)</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_preprocess">preprocess</code></td>
<td>
<p>(boolean) indicates whether x-y trajectories should be pre-processed (default <code>preprocess=TRUE</code>)</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_n">N</code></td>
<td>
<p>(integer) number of timesteps for trajectory normalization (default <code>N=61</code>)</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_z.formula">Z.formula</code></td>
<td>
<p>(character) a formula of the contrasts for the model matrix Z (see <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>)</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_z.contrast">Z.contrast</code></td>
<td>
<p>(character) type of contrasts (default: treatment) for the model matrix Z (see <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>)</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_yt">yT</code></td>
<td>
<p>(numeric) position in angles of the target. The default option yT=&quot;AUTO&quot; will automatically determine the target position from the observed data</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_yd">yD</code></td>
<td>
<p>(numeric) position in angles of the distractor. The default option yD=&quot;AUTO&quot; will automatically determine the target position from the observed data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prepares the mouse-tracking trajectories to be modeled for the state-space analysis. It automatically processes trajectories according to time-normalization, translation, and atan2 conversion. 
Users can skip pre-processing by setting <code>preprocess=FALSE</code>.
</p>
<p>The input dataframe <code>X</code> needs to be organized using the long format with information being organized as nested. In particular, <code>X</code> must contains the following variables:
</p>

<dl>
<dt>sbj</dt><dd><p>The ID number of participants</p>
</dd>
<dt>trial</dt><dd><p>The ID number of trials</p>
</dd>
<dt>factors</dt><dd><p>1,...,Q factors for the categorical variables of the design. They may have different levels.  </p>
</dd>
<dt>timestep</dt><dd><p>The ID number of the recorded x-y trajectories</p>
</dd>
<dt>x</dt><dd><p>The recorded x-trajectories associated to trials and experimental levels</p>
</dd>
<dt>y</dt><dd><p>The recorded y-trajectories associated to trials and experimental levels</p>
</dd>
</dl>

<p>See <code><a href="#topic+language">language</a></code> and <code><a href="#topic+congruency">congruency</a></code> as examples of datasets format required by <span class="pkg">ssMousetrack</span> package.
</p>


<h3>Value</h3>

<p>a list containing (i) the new dataframe of the pre-processed dataset (<code>X_processed</code>) and (ii) the needed data for <code><a href="#topic+run_ssm">run_ssm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(congruency)
dataout &lt;- prepare_data(X = congruency,preprocess = TRUE,Z.formula = "~congruency*plausibility")
str(dataout)

</code></pre>

<hr>
<h2 id='run_ssm'>State-space modeling of mouse-tracking trajectories via Stan</h2><span id='topic+run_ssm'></span>

<h3>Description</h3>

<p>State-space modeling of mouse-tracking trajectories via Stan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_ssm(
  N,
  I,
  J,
  Y = NULL,
  D = NULL,
  Z = NULL,
  sigmax = 1,
  lambda = 1,
  y_T = pi/4,
  y_D = (3 * pi)/4,
  priors = "default",
  gfunction = c("logistic", "gompertz"),
  kappa_bnds = c(5, 300),
  nchains = 1,
  niter = 2000,
  nwarmup = 500,
  ncores = "AUTO",
  stan_object = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_ssm_+3A_n">N</code></td>
<td>
<p>(integer) length of the Y-trajectories</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_i">I</code></td>
<td>
<p>(integer) number of individuals</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_j">J</code></td>
<td>
<p>(integer) number of trials</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_y">Y</code></td>
<td>
<p>(matrix) N x JI matrix of observed trajectories</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_d">D</code></td>
<td>
<p>(matrix) N x JI matrix of delta values for the observed trajectories</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_z">Z</code></td>
<td>
<p>(matrix) matrix of contrasts associated to the experimental design (see <code><a href="#topic+generate_design">generate_design</a></code>)</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_sigmax">sigmax</code></td>
<td>
<p>(numeric) fixed value for the model parameter sigmax</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) fixed value for the model parameter lambda</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_y_t">y_T</code></td>
<td>
<p>(numeric) position in angles of the target</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_y_d">y_D</code></td>
<td>
<p>(numeric) position in angles of the distractor</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_priors">priors</code></td>
<td>
<p>(list) a list of arguments specifying priors for each parameter involved in the model (see <code><a href="#topic+check_prior">check_prior</a></code>). If <code>priors="default"</code> then pre-defined tpriors will be used.</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_gfunction">gfunction</code></td>
<td>
<p>(character) type of link function between latent states and observed data: 'logistic', 'gompertz' (<code>default = 'logistic'</code>).</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_kappa_bnds">kappa_bnds</code></td>
<td>
<p>(array) array containing the lower and upper bounds for the kappa parameter (<code>default = c(5,300)</code>)</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_nchains">nchains</code></td>
<td>
<p>(integer) number of chains for the MCMC algorithm</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_niter">niter</code></td>
<td>
<p>(integer) number of iterations for each chain</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_nwarmup">nwarmup</code></td>
<td>
<p>(integer) number of warmup/burnin iterations per chain</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_ncores">ncores</code></td>
<td>
<p>(integer) number of cores to use when executing the chains in parallel. The default option ncores=&quot;AUTO&quot; will automatically determine the number of cores via the <code>parallel</code> package</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_stan_object">stan_object</code></td>
<td>
<p>(boolean) if <code>stan_object=TRUE</code>, the object of S4 class stanfit representing the fitted results will be saved as stan_object.rda</p>
</td></tr>
<tr><td><code id="run_ssm_+3A_...">...</code></td>
<td>
<p>other stan arguments (e.g., 'init', 'algorithm', 'sample_file'. See <code><a href="rstan.html#topic+sampling">sampling</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function drawns samples from the posterior distribution of the model parameters. Note that, the current version of <span class="pkg">ssMousetrack</span> package requires the number of stimuli J to be the same over the subjects <code class="reqn">i=1,...,I</code>.
</p>


<h3>Value</h3>

<p>a datalist containing the posterior samples for the model parameters along with the main Stan output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Fit a state-space model using simulated data 
# Generate mouse-tracking data for an univariate experimental design with K = 3 categorical levels, 
# J = 12 trials, I = 5 subjects
X1 &lt;- generate_data(I=5,J=12,K=3,Z.formula="~Z1")
iid &lt;- 23 # keep just one dataset from the simulated set of datasets
# Run the state-space model on the chosen dataset
X1_fit &lt;- run_ssm(N = X1$N,I = X1$I,J = X1$J,Y = X1$data$Y[iid,,],D = X1$data$D[iid,,],
Z = X1$data$Z)

## Fit a state-space model using the experimental dataset language
# The dataset is ready to be used and it does not need to be pre-processed (preprocess=FALSE). 
# In this case, the function prepare_data just computes the observed radians from 
# the x-y trajectories
X2 &lt;- prepare_data(X = language, preprocess = FALSE, Z.formula = "~condition")
# Run the state-space model on the chosen dataset
X2_fit &lt;- run_ssm(N = X2$N,I = X2$I,J = X2$J,Y = X2$Y,D = X2$D,Z = X2$Z,
niter=5000,nchains=2)

## Fit a state-space model using the experimental dataset congruency
# The dataset needs to be pre-processed (preprocess=TRUE)
X3 &lt;- prepare_data(X = congruency, preprocess = TRUE, 
Z.formula = "~congruency+plausibility") # additive design
# Define priors of the model parameters 
KK &lt;- dim(X3$Z)[2] # number of model parameters implied by the design matrix Z
priors_list &lt;- list("lognormal(1,0.5)","pareto(3,5.25)","normal(0,2.5)")
# note that length(priors_list) = KK 
# Run the state-space model on the chosen dataset
X3_fit &lt;- run_ssm(N = X3$N,I = X3$I,J = X3$J,Y = X3$Y,D = X3$D,Z = X3$Z,
niter=10000,nwarmup=3500,priors=priors_list,nchains=4)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
