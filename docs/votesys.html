<!DOCTYPE html><html><head><title>Help for package votesys</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {votesys}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approval_method'><p>Approval Method</p></a></li>
<li><a href='#as_complete'><p>Convert Incomplete ranking/rating matrix into full matrix</p></a></li>
<li><a href='#borda_method'><p>Borda Count Method</p></a></li>
<li><a href='#cdc_copeland'><p>Copeland Method</p></a></li>
<li><a href='#cdc_dodgson'><p>Dodgson Method</p></a></li>
<li><a href='#cdc_kemenyyoung'><p>Kemeny-Young Method</p></a></li>
<li><a href='#cdc_minmax'><p>Minmax Method</p></a></li>
<li><a href='#cdc_rankedpairs'><p>Ranked Pairs Method</p></a></li>
<li><a href='#cdc_schulze'><p>Schulze Method</p></a></li>
<li><a href='#cdc_simple'><p>Ordinary Condorcet Method</p></a></li>
<li><a href='#check_dup_wrong'><p>Check Ballots with Duplicated Values, Mistakes, or without Any Valid Entry</p></a></li>
<li><a href='#create_vote'><p>Create a vote Object that can be used in counting methods</p></a></li>
<li><a href='#dowdall_method'><p>Dowdall Method</p></a></li>
<li><a href='#irv_method'><p>Instant-Runoff Voting Method</p></a></li>
<li><a href='#list2ballot'><p>Repeat ith element of list x or row of matrix/data.frames</p>
for j times</a></li>
<li><a href='#plurality_method'><p>Plurality Method to Find Absolute or Relative Majority</p></a></li>
<li><a href='#star_rating'><p>User Preference Aggregation</p></a></li>
<li><a href='#votesys-package'><p>Voting Systems, Instant-Runoff Voting, Borda Method, Various Condorcet Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Voting Systems, Instant-Runoff Voting, Borda Method, Various
Condorcet Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jiang Wu &lt;textidea@sina.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Various methods to count ballots in voting systems are provided.
	Functions to check validity of ballots are also provided to ensure flexibility.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, gtools, Matrix</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-20 09:20:37 UTC; useruser</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiang Wu [aut, cre] (from Capital Normal University)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-20 09:56:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='approval_method'>Approval Method</h2><span id='topic+approval_method'></span>

<h3>Description</h3>

<p>In approval method, each voter is required to mention 
one or more candidates, and the winner is the one 
who gets the top frequency. For this function, a ballot 
with candidates more than required and 
different scores is also valid. For a score matrix, the function will 
check the positions j, k...which have the 
lowest scores (in a <code>vote</code> object, 
the lower, the better) in the ith row. However, the function will 
first check the <code>approval_able</code> element of 
the <code>vote</code> object. If it is FALSE, the winner will be NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approval_method(x, min_valid = 1, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approval_method_+3A_x">x</code></td>
<td>
<p>an object of class <code>vote</code>.</p>
</td></tr>
<tr><td><code id="approval_method_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, the ballot will not be used.</p>
</td></tr>
<tr><td><code id="approval_method_+3A_n">n</code></td>
<td>
<p>the number of candidates written down by a 
voter should not larger than this value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
used to compute the result.
</p>
</li>
<li><p> (7) <code>winner</code> the winners, may be one, more than one or NULL.
</p>
</li>
<li><p> (8) <code>n</code> equal to the argument <code>n</code>.
</p>
</li>
<li><p> (9) <code>other_info</code> frequencies of candidates mentioned 
by voters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- matrix(NA, nrow = 22, ncol = 5)
for (i in 1: 20){
   set.seed(i)
   raw[i, ] &lt;- sample(c(1: 5, NA, NA, NA), 5)
}
raw[21, ] &lt;- c(4, 5, 3, 1, 2)
raw[22, ] &lt;- c(3, 5, 1, 2, 4)
vote &lt;- create_vote(raw, xtype = 1)
y &lt;- approval_method(vote, n = 3)
y &lt;- approval_method(vote, n = 3, min_valid = 5)
y &lt;- approval_method(vote, n = 4, min_valid = 3)
</code></pre>

<hr>
<h2 id='as_complete'>Convert Incomplete ranking/rating matrix into full matrix</h2><span id='topic+as_complete'></span>

<h3>Description</h3>

<p>This function deals with incomplete ranking and rating matrix 
(e. g., created by <code>create_vote</code> and stored in <code>$ballot</code>), 
so as to convert it into full ranking and rating. 
In each row of the score matrix, the 
smallest value represents the most preferred 
and the biggest value represents the most hated.
For the methods used by this function, see Details.
See Examples for how to modify an object of class 
vote created with incomplete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_complete(x, method = c("valid", "max", "len"), plus = 0, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_complete_+3A_x">x</code></td>
<td>
<p>the score matrix, should be a matrix, data.frame, 
or data.table.</p>
</td></tr>
<tr><td><code id="as_complete_+3A_method">method</code></td>
<td>
<p>see Details, default is &quot;valid&quot;.</p>
</td></tr>
<tr><td><code id="as_complete_+3A_plus">plus</code></td>
<td>
<p>see Details, default is 0.</p>
</td></tr>
<tr><td><code id="as_complete_+3A_n">n</code></td>
<td>
<p>see Details, default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three methods are used and you should choose 
according to your need.
</p>

<ul>
<li><p> (1) &quot;valid&quot;: the default method. For the vector 
<code>c(3, 1, 2, 2, NA, NA)</code>, as there should be 6 values 
but only 4 are given, 4 is the valid number, and the NAs 
will be converted to 4. However, if the argument 
<code>plus</code> is a value other than 0, than NAs will be 
equal to the valid number plus that value. For example, 
if <code>plus = 10</code>, the NAs will be 14 (4 + 10).
</p>
</li>
<li><p> (2) &quot;max&quot;: the maximum value in each row plus the value 
given by <code>plus</code>. So for <code>c(3, 1, 2, 2, NA, NA)</code>, 
and <code>plus = 0</code>, NAs will be 3 (3 + 0).
</p>
</li>
<li><p> (3) &quot;len&quot;: In the case of topKlist, 
interviewees may, for example, choose 4 or 5 items 
from a 20-item list. When the method is &quot;len&quot;, use <code>n</code> to 
indicate the total number of items or any other number. 
The default value of <code>n</code> is <code>ncol(x)</code>, 
which is equivalent to the way <code>create_vote</code> used to 
convert NAs so as to 
calculate the Condorcet matrix.
</p>
</li></ul>



<h3>Value</h3>

<p>Always a matrix. NAs are converted to numbers. 
However, if all entries in a row of the input data are NAs, 
then that row will NOT be modified. NOTE: the order of 
the returned matrix (the 1st row, the 2nd row, the 3rd row, etc) 
is DIFFERENT from the input data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- list2ballot(string = c("1: a, b, c", "2: b, c", "3: a, b"))
vote &lt;- create_vote(raw, xtype = 3, candidate = c("a", "b", "c"))
ballot &lt;- as_complete(vote$ballot, method = "max", plus = 5)
ballot &lt;- as_complete(vote$ballot, method = "len", n = 10)
# Now re-create the vote object
vote &lt;- create_vote(ballot, xtype = 1)

m &lt;- matrix(c(
    1, 2, 3, NA, NA, NA,
    1, 1.1, 2.2, 8.8, NA, NA, 
    1, 1.1, 2.2, 8.8, NA, NA, 
    1, 1.1, 2.2, 8.8, NA, NA, 
    1, 1.1, 2.2, 8.8, NA, NA, 		
    NA, NA, NA, NA, NA, NA,
    3, 2, NA, NA, NA, NA, 
    3, 2, NA, NA,NA,NA,
    1, 2, 3, 4, 5, 6), ncol = 6, byrow = TRUE)
colnames(m) &lt;- LETTERS[1: 6]
y &lt;- as_complete(m, method = "valid", plus = 30)
</code></pre>

<hr>
<h2 id='borda_method'>Borda Count Method</h2><span id='topic+borda_method'></span>

<h3>Description</h3>

<p>Both ordinary Borda method and modified Borda method are 
available. In an ordinary Borda system, voters are required to 
assign score values to candidates. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>borda_method(x, allow_dup = TRUE, min_valid = 1, modified = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="borda_method_+3A_x">x</code></td>
<td>
<p>an object of class <code>vote</code>.</p>
</td></tr>
<tr><td><code id="borda_method_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="borda_method_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, the ballot will not be used.</p>
</td></tr>
<tr><td><code id="borda_method_+3A_modified">modified</code></td>
<td>
<p>if the modified Borda is to be used. Default 
is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose there are 5 
candidates. A voter's 1st choice gets 1 point, the 2nd choice 
gets 2 points... Candidate with the smallest total score wins. 
The function does not require voters to assign scores to all 
candidates, for NAs are automatically assigned the 
highest (worst) score. Duplicated values  (two 
or more candidates share 
the same score) are also allowed (note: NAs and ties may 
not be allowed in real ballots).
</p>
<p>In modified Borda, 
the rule changes. Suppose there are 5 candidates. A voter 
writes down 5 candidates and his 1st choice gets 5 points. 
The one who gets the largest total score wins. However, 
if the voter only write down 2 names, then, his 1st choice 
gets only 2 points rather than 5 points. Thus the modified 
Borda encourages voters to write down more names.
Besides, in modified Borda, only the ranks of true scores, 
rather than the true scores themselves, are used.
If the raw data is a list each ballot of which 
contains candidate names, scores can also be extracted, that 
is, the 1st position is the 1st choice which gets 1 point, the 
2nd position, 2 points, and so on.
</p>


<h3>Value</h3>

<p>a list object.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
used to compute the result.
</p>
</li>
<li><p> (7) <code>winner</code> the winners.
</p>
</li>
<li><p> (8) <code>modified</code> whether the modified Borda is used.
</p>
</li>
<li><p> (9) <code>other_info</code> a list with 2 elements, if <code>modified</code> 
is FALSE, then <code>count_min</code> records the total 
scores, <code>count_max</code> 
is NULL; if <code>modified</code> is TRUE, the vice versa.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- c(
    rep(c('m', 'n', 'c', 'k'), 42), 
    rep(c('n', 'c', 'k', 'm'), 26), 
    rep(c('c', 'k', 'n', 'm'), 15), 
    rep(c('k', 'c', 'n', 'm'), 17)
) 
raw &lt;- matrix(raw, ncol = 4, byrow = TRUE)
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'c', 'k'))
y &lt;- borda_method(vote)

raw &lt;- list(c('a', 'e', 'c', 'd', 'b'), c('b', 'a', 'e'), 
    c('c', 'd', 'b'), c('d', 'a', 'e')
)
vote &lt;- create_vote(raw, xtype = 3, candidate = c('a', 'b', 'c', 'd', 'e'))
y &lt;- borda_method(vote, modified = TRUE)
</code></pre>

<hr>
<h2 id='cdc_copeland'>Copeland Method</h2><span id='topic+cdc_copeland'></span>

<h3>Description</h3>

<p>Candidates enter into pairwise comparison. 
if the number of voters who prefer a is larger than the 
number of voters who prefer b, then a wins b, a gets 1 
point, b gets -1 point. If the numbers are equal, then both 
of them gets 0 point.
Then, sum up each one's comparison points. 
For example, a wins 3 times, loses 1 time, has equal 
votes with 2 candidate, his score is 
3 * 1 + (-1) * 1 + 0 * 2 = 2. 
The one gets the most points wins. Essentially, this 
is a way to solve ties in ordinary Condorcet method.
However, there may be 2 or more winners. The other 
type of Copeland method is to count only the times of wins, 
that is, the loser in pairwise comparison gets 0 point 
rather than -1 point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_copeland(x, allow_dup = TRUE, min_valid = 1, lose = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_copeland_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_copeland_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_copeland_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
<tr><td><code id="cdc_copeland_+3A_lose">lose</code></td>
<td>
<p>the point the pairwise loser gets, should be 
-1 (default) or 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in <code>x</code>. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winners.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of <code>x</code>. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> a list with 2 elements, the 1st is the point
the loser gets, it is equal to <code>lose</code>. The 2nd contains the scores.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Merlin, V. &amp; Saari, D. 1996. The Copeland 
method: I.: Relationships and the dictionary. 
Economic Theory, 8(1), 51-76.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- c(
    rep(c('m', 'n', 'c', 'k'), 42), rep(c('n', 'c', 'k', 'm'), 26), 
    rep(c('c', 'k', 'n', 'm'), 15), rep(c('k', 'c', 'n', 'm'), 17)
) 
raw &lt;- matrix(raw, ncol = 4, byrow = TRUE)
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'k', 'c'))
win1 &lt;- cdc_simple(vote)
win2 &lt;- cdc_copeland(vote) # winner is n
win2 &lt;- cdc_copeland(win1$cdc)
win3 &lt;- cdc_copeland(win2, lose = 0)
</code></pre>

<hr>
<h2 id='cdc_dodgson'>Dodgson Method</h2><span id='topic+cdc_dodgson'></span>

<h3>Description</h3>

<p>The original Dodgson method checks the number of 
votes each candidate has to rob from other candidates; 
the winner is with the smallest number. However, the 
function <code>cdc_dodgson</code> uses two alternative methods 
rather than the original Dodgson method. The two methods 
are Tideman score method and Dodgson Quick method. 
See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_dodgson(x, allow_dup = TRUE, min_valid = 1, dq_t = "dq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_dodgson_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_dodgson_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_dodgson_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
<tr><td><code id="cdc_dodgson_+3A_dq_t">dq_t</code></td>
<td>
<p>the alternative Dodgson methods to be used. 
Default is &quot;dq&quot;, for Dodgson Quick method; it can also be &quot;t&quot;, 
Tideman score method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose the candidates are A, B, C and D. If A wins B in pairwise 
comparison or has equal votes with B, then add 0 to A. If C wins A, 
then add to A adv(C, A), that is, the number of voters that prefer 
C than A, minus the number of voters that prefer A than A.  
Again, if D wins A, then add to A that number. Then, we sum up 
the points belong to A. We do the same thing to B, C and D. The one 
gets the least points is the winner. This is what we do in Tideman
score method. In Dodgson Quick method, we first compute the number 
of votes, then divide it by 2 and get the ceiling, and sum 
all of them up.
</p>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winners.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of x. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> a list with four elements. The 1st 
indicates the method used to compute score. The 2nd is the score 
for pairwise comparison
(number of votes one has to rob). The 3rd is Tideman score 
summary (the smaller the better). 
The 4th is Dodgson Quick summary (the smaller the better).
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> McCabe-Dansted, J. &amp; Slinko, A. 2008. Approximability of Dodgson's Rule. Social Choice and Welfare, Feb, 1-26.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- list2ballot(
    x = list(
        c('A', 'B', 'C', 'D', 'E', 'F'), 
        c('F', 'A', 'B', 'C', 'D', 'E'),
        c('E', 'D', 'C', 'B', 'F', 'A'),
        c('B', 'A', 'C', 'D', 'E', 'F'),
        c('F', 'E', 'D', 'C', 'B', 'A'),
        c('F', 'B', 'A', 'C', 'D', 'E'),
        c('E', 'D', 'C', 'A', 'F', 'B'),
        c('E', 'B', 'A', 'C', 'D', 'F'),
        c('F', 'D', 'C', 'A', 'E', 'B'),
        c('D', 'B', 'A', 'C', 'E', 'F'),
        c('F', 'E', 'C', 'A', 'D', 'B')
    ), 
    n = c(19, 12, 12, 9, 9, 10, 10 , 10 , 10, 10, 10)
)
vote &lt;- create_vote(raw, xtype = 3, candidate = c('A', 'B', 'C', 'D', 'E', 'F'))
win1 &lt;- cdc_simple(vote) # no winner
win2 &lt;- cdc_dodgson(vote, dq_t = "dq") # A
win2 &lt;- cdc_dodgson(win1, dq_t = "dq") # A
win3 &lt;- cdc_dodgson(vote, dq_t = "t") # B
win3 &lt;- cdc_dodgson(win2, dq_t = "t") # B
</code></pre>

<hr>
<h2 id='cdc_kemenyyoung'>Kemeny-Young Method</h2><span id='topic+cdc_kemenyyoung'></span>

<h3>Description</h3>

<p>Kemeny-Young method first lists all the permutations of 
candidates, that is, all possible orders, or possible ordered 
links. Then, it computes the sums of strength of these links.
The top link is the one with the highest strength score, and 
the winner is the first one in this link. Currently, the maximum 
candidate number is 8 for speed and memory reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_kemenyyoung(x, allow_dup = TRUE, min_valid = 1, margin = FALSE,
  keep_all_link = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_kemenyyoung_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_kemenyyoung_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_kemenyyoung_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
<tr><td><code id="cdc_kemenyyoung_+3A_margin">margin</code></td>
<td>
<p>if it is FALSE (default), the values in Condorcet 
matrix are used, that is: if A vs. B is 30, B vs. A is 18, then 30 and 18 are 
used to calculate link strength; if it is TRUE, then 30 - 18 = 12 and 
-12 are used.</p>
</td></tr>
<tr><td><code id="cdc_kemenyyoung_+3A_keep_all_link">keep_all_link</code></td>
<td>
<p>if TRUE, the result will store 
all the links and their strength. However, it is quite memory-costing, 
so the default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in <code>x</code>. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winner.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of <code>x</code>. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> a list with 3 elements. <code>win_link</code> 
is the link with the highest strength. Note: it is a matrix, maybe with 2
or more rows. <code>win_link_value</code> is the strength of the link. 
<code>all_link</code> is NULL when <code>keep_all_link</code> is FALSE. if TRUE,  
it stores all the links and scores sorted by scores in decreasing order (this 
costs much memory on your computer).
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Young, H. &amp; Levenglick, A. 1978. 
A consistent extension of Condorcet's election principle. 
Society for Industrial and Applied Mathematics, 35(2), 285-300.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 58, 58, 58, 42, 0, 32, 32, 42, 68, 0, 17, 42, 68, 83, 0), nr = 4)
colnames(m) &lt;- c('m', 'n', 'c', 'k')
rownames(m) &lt;- c('m', 'n', 'c', 'k')
y &lt;- cdc_kemenyyoung(m, keep_all_link = TRUE) # winner is n
</code></pre>

<hr>
<h2 id='cdc_minmax'>Minmax Method</h2><span id='topic+cdc_minmax'></span>

<h3>Description</h3>

<p>Minmax method (also known as Simpson-Kramer method, 
successive reversal method) 
means three different methods.
The first is winning votes method. In pairwise comparison, 
if a wins b, a gets 0 point, the number of points for b is the 
number of voters who prefer a than b. 
The second method is to use margins. In pairwise comparison, 
a gets b - a points and b gets a - b points. 
The third method is pairwise opposition method. The number 
of points for a is the number of voters who prefer b than a; the 
number of points for b is the number of voters who prefer a 
than b. 
Although the point-assigning methods are different for the 
above three methods, they nonetheless do the same thing: 
to check to what extent one candidate is defeated by others. 
So the summarizing method is the same: for each candidate, 
we extract the maximum target points, and the one with the 
minimum points wins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_minmax(x, allow_dup = TRUE, min_valid = 1, variant = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_minmax_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_minmax_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_minmax_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
<tr><td><code id="cdc_minmax_+3A_variant">variant</code></td>
<td>
<p>should be 1, 2 or 3. 1 (default) for winning votes 
method, 2 for margins method, 3 for pairwise comparison method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winners.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of x. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> a list of 4 elements. The 1st is 
the method, which is equal to <code>variant</code>. The 2nd is the 
winning votes matrix. The 3rd is the margins matrix. The 4th 
is the pairwise comparison matrix.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> https://en.wikipedia.org/wiki/Minimax_Condorcet_method
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- c(
    rep(c('m', 'n', 'c', 'k'), 42), rep(c('n', 'c', 'k', 'm'), 26), 
    rep(c('c', 'k', 'n', 'm'), 15), rep(c('k', 'c', 'n', 'm'), 17)
) 
raw &lt;- matrix(raw, ncol = 4, byrow = TRUE)
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'k', 'c'))
win1 &lt;- cdc_simple(vote)
win2 &lt;- cdc_minmax(vote) # winner is n
win3 &lt;- cdc_minmax(win1, variant = 2)
win4 &lt;- cdc_minmax(win3$cdc, variant = 3)
</code></pre>

<hr>
<h2 id='cdc_rankedpairs'>Ranked Pairs Method</h2><span id='topic+cdc_rankedpairs'></span>

<h3>Description</h3>

<p>It is also called Tideman method. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_rankedpairs(x, allow_dup = TRUE, min_valid = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_rankedpairs_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_rankedpairs_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_rankedpairs_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method first summarizes the result of pairwise comparison, 
the order used is the order of winning votes from large to small. 
So if pairwise comparison has ties (that is, the number of voters 
who prefer a than b is equal to the number of voters who prefer 
b than a, the method will fail, and the winner will be NULL).
</p>
<p>The second step is called tally. 
If a wins b with 100 votes, b wins c with 80 votes, then 
we put a-b-100 ahead of b-c-80. Suppose a wins b with 100 votes, 
a wins c with 100 votes, then we have a tie; so we have to check 
the relation between b and c. If b wins c, then we put a-c-100 
ahead of a-b-100. Suppose a wins b with 100 votes, d wins b with 
100 votes, then again we have a tie and have to check the a-d 
relation. If d wins a, then we put d-b-100 ahead of a-b-100. Suppose 
a wins b with 100 votes, e wins f with 100 votes, then the ties cannot 
be solved, so the winner will be NULL.
</p>
<p>The third step, after the above mentioned tally, is called lock-in.
As the relations have been sorted according to their strength 
from large to small in the tally step, we now add them one 
by one. The rule is: if a relation is contradictory with those 
already locked in relations, this relation will be discarded.
</p>
<p>For example, suppose we have already add relation a &gt; b and 
b &gt; c, then the two relations are locked in. As a result, we should 
not add b &gt; a. Also, as a &gt; b and b &gt; c indicate a &gt; c, so we should 
not add c &gt; a. After this process, we will finally find the winner who 
defeats all others.
</p>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> the number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winner, may be NULL.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of x. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> a list of 3 elements. The 1st 
is the reason of failure. If winner exists, it will be blank. The 2nd 
is the tally result (it may contain unsolved ties). 
The 3rd is the lock-in result; if the method fails, 
it will be NULL.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Tideman, T. 1987. Independence of clones as a 
criterion for voting rules. Social Choice and Welfare, 4(3), 185-206.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- rbind(c('m', 'n', 'c', 'k'), c('n', 'c', 'k', 'm'), 
    c('c', 'k', 'n', 'm'), c('k', 'c', 'n', 'm')) 
raw &lt;- list2ballot(m = raw, n = c(42, 26, 15, 17))
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'c', 'k'))
y &lt;- cdc_rankedpairs(vote)
</code></pre>

<hr>
<h2 id='cdc_schulze'>Schulze Method</h2><span id='topic+cdc_schulze'></span>

<h3>Description</h3>

<p>Schulze method is essentially a widest path problem.
With the Condorcet matrix, we must find the so called 
the strongest path a &gt; b &gt; c &gt; d, and the winner is a. 
The strength of a path is the strength of its weakest link.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_schulze(x, allow_dup = TRUE, min_valid = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_schulze_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_schulze_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_schulze_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winners, may be NULL.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of x. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> a list of 2 elements. The 1st is the strength 
comparison matrix. The 2nd is the strength comparison matrix in binary 
mode, 1 for win, 0 for else.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Schulze, M. 2010. A new monotonic, 
clone-independent, reversal symmetric, 
and Condorcet-consistent single-winner election method. 
Social Choice and Welfare, 36(2), 267-303.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- list2ballot(
    x = list(
        c('a', 'c', 'b', 'e', 'd'), 
        c('a', 'd', 'e', 'c', 'b'), 
        c('b', 'e', 'd', 'a', 'c'), 
        c('c', 'a', 'b', 'e', 'd'), 
        c('c', 'a', 'e', 'b', 'd'), 
        c('c', 'b', 'a', 'd', 'e'), 
        c('d', 'c', 'e', 'b', 'a'), 
        c('e', 'b', 'a', 'd', 'c')
    ), 
    n = c(5, 5, 8, 3, 7, 2, 7, 8)
)
vote &lt;- create_vote(raw, xtype = 3, candidate = c('a', 'b', 'c', 'd', 'e'))
win1 &lt;- cdc_simple(vote) # no winner
win2 &lt;- cdc_schulze(vote) # winner is e
win2 &lt;- cdc_schulze(win1)
</code></pre>

<hr>
<h2 id='cdc_simple'>Ordinary Condorcet Method</h2><span id='topic+cdc_simple'></span>

<h3>Description</h3>

<p>Candidates enter into pairwise comparison. 
if the number of voters who prefer a is larger than the 
number of voters who prefer b, then a wins b, a gets 1 
point, b gets 0 point. If the numbers are equal, then both 
of them gets 0 point.
Suppose there are n candidates, the one gets n-1 
points wins (that is, he wins in all pairwise comparison).
There may be no Condorcet winner. If thus, you can 
try other Condorcet family methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdc_simple(x, allow_dup = TRUE, min_valid = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdc_simple_+3A_x">x</code></td>
<td>
<p>it accepts the following types of input:
1st, it can be an object of class <code>vote</code>. 
2nd, it can be a user-given Condorcet matrix, 
3rd, it can be a result of another Condorcet method, 
which is of class <code>condorcet</code>.</p>
</td></tr>
<tr><td><code id="cdc_simple_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="cdc_simple_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, it will not be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>condorcet</code> object, which is essentially 
a list.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in <code>x</code>. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
actually used to compute the result. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (7) <code>winner</code> the winner; may be NULL.
</p>
</li>
<li><p> (8) <code>input_object</code> the class of <code>x</code>. 
</p>
</li>
<li><p> (9) <code>cdc</code> the Condorcet matrix which is actually used.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix. When 
x is not a <code>vote</code> object, it may be NULL.
</p>
</li>
<li><p> (11) <code>binary</code> win and loss recorded with 1 (win), 
0 (equal) and -1 (loss).
</p>
</li>
<li><p> (12) <code>summary_m</code> times of win (1), equal (0) 
and loss (-1).
</p>
</li>
<li><p> (13) <code>other_info</code> currently nothing.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- c(
    rep(c('m', 'n', 'c', 'k'), 42), rep(c('n', 'c', 'k', 'm'), 26), 
    rep(c('c', 'k', 'n', 'm'), 15), rep(c('k', 'c', 'n', 'm'), 17)
) 
raw &lt;- matrix(raw, ncol = 4, byrow = TRUE)
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'k', 'c'))
win1 &lt;- cdc_simple(vote) # winner is n
win2 &lt;- cdc_simple(win1$cdc) # use a Condorceit matrix
win2 &lt;- cdc_simple(win1) # use an existent result
</code></pre>

<hr>
<h2 id='check_dup_wrong'>Check Ballots with Duplicated Values, Mistakes, or without Any Valid Entry</h2><span id='topic+check_dup_wrong'></span>

<h3>Description</h3>

<p>The function simply checks validity of ballots and shows the check result. If 
you want a one-step clean, set <code>clean</code> to TRUE and a set of cleaned ballots
will be returned. Here, duplicated values mean that the voter write the 
same candidate more than one time, or, when 
he assigns scores, he assigns the same score
to more than one candidates. Mistakes are names that do not appear in the candidate 
list, or score values that are illegal (e.g., if voters are required to assign 1-5 to candidates, 
then 6 is an illegal value). Ballots without a valid entry (that is, all entries are NAs) are also
to be picked out. Different formats can be input into the function, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dup_wrong(x, xtype = 2, candidate = NULL, vv = NULL, isna = NULL,
  clean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dup_wrong_+3A_x">x</code></td>
<td>
<p>a data.frame, matrix or list of raw ballots. See Details.</p>
</td></tr>
<tr><td><code id="check_dup_wrong_+3A_xtype">xtype</code></td>
<td>
<p>should be 1, 2 (default) or 3, designating the type of x. See Details.</p>
</td></tr>
<tr><td><code id="check_dup_wrong_+3A_candidate">candidate</code></td>
<td>
<p>if <code>xtype</code> is 1, this argument is ignored. 
If <code>xtype</code> is 2 or3, candidate names
must be given as a character or numeric vector. If a name is not given, 
but is still on a ballot, then the ballot is labelled as wrong.</p>
</td></tr>
<tr><td><code id="check_dup_wrong_+3A_vv">vv</code></td>
<td>
<p>if <code>xtype</code> is 2 or 3, it is ignored. 
If <code>xtype</code> is 1, this gives the valid score values for x.</p>
</td></tr>
<tr><td><code id="check_dup_wrong_+3A_isna">isna</code></td>
<td>
<p>entries which should be taken as NAs. <code>NA</code> in <code>x</code>
be taken as missing value, 
however, you can add more (e.g., you may use 99, 999 as missing values). 
If x contains characters, 
this argument should also be provided with a character vector, and 
if numeric, then numeric vector. Do 
not add NA to <code>isna</code>, because the default (NULL) 
means <code>NA</code> is already included.</p>
</td></tr>
<tr><td><code id="check_dup_wrong_+3A_clean">clean</code></td>
<td>
<p>the default is FALSE, that is, it does not return the cleaned data. If it is TRUE, 
a set of ballots without duplicated values, without mistakes and with 
at least one valid value, is 
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts the following input:
</p>

<ul>
<li><p> (1) when <code>xtype</code> is 1, x must be a matrix. Column names are candidate names (if
column names are NULL, they will be created: x1, x2, x3...). Candidate number is the number 
of columns of the matrix. Entry ij is the numeric score assigned 
by the ith voter to the jth candidate.
</p>
</li>
<li><p> (2) when <code>xtype</code> is 2, x can be a matrix or data.frame. Candidate 
number is the length of <code>candidate</code>.
Entries are names (character or numeric) of candidates. 
The i1, i2, i3... entries are the 1st, 2nd, 
3rd... preferences of voter i.
</p>
</li>
<li><p> (3) when <code>xtype</code> is 3, <code>x</code> should be a list. 
Each element of the list is a ballot, a vector 
contains the names (character or numeric) of candidates. The 1st 
preference is in the 1st position of 
the vector, the 2nd preference is in the 2nd position... The number of candidates is the length 
of <code>candidate</code>; as a result, a ballot with number of names larger than candidate number is 
labelled as wrong.
</p>
</li></ul>



<h3>Value</h3>

<p>a list with 3 or 4 elements: <code>row_with_dup</code> is 
the rows (not row names) of rows that have 
duplicated values; <code>row_with_wrong</code> is the rows with illegal names or the 
lengths of them are larger than candidate number (this could only happen when x 
is a list). <code>row_all_na</code> is the rows the entries of which are all NAs. For a list, 
elements with NULL are also taken as all-NA ballots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw=list(
    c('a', 'e', 'c', 'd', 'b'), 
    c('b', 'a', 'e'), 
    c('c', 'd', 'b'), 
    c('d', 'a', 'b'), 
    c('a', 'a', 'b', 'b', 'b'), 
    c(NA, NA, NA, NA), 
    v7=NULL, 
    v8=c('a', NA, NA, NA, NA, NA, NA), 
    v9=rep(" ", 3)
)
y=check_dup_wrong(raw, xtype=3, candidate=letters[1: 5])
y=check_dup_wrong(raw, xtype=3, candidate=letters[1: 4]) 
</code></pre>

<hr>
<h2 id='create_vote'>Create a vote Object that can be used in counting methods</h2><span id='topic+create_vote'></span>

<h3>Description</h3>

<p>Some counting methods in this package only accept <code>vote</code> object created by 
this function. So the first step should always be using this function. The function 
will return the modified ballots and some other helpful information. See Details 
and Values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_vote(x, xtype = 2, candidate = NULL, isna = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_vote_+3A_x">x</code></td>
<td>
<p>a data.frame, matrix or list of raw ballots. See Details.</p>
</td></tr>
<tr><td><code id="create_vote_+3A_xtype">xtype</code></td>
<td>
<p>should be 1, 2 (default) or 3, designating the 
type of <code>x</code>. See Details.</p>
</td></tr>
<tr><td><code id="create_vote_+3A_candidate">candidate</code></td>
<td>
<p>if <code>xtype</code> is 1, this argument is ignored. 
If <code>xtype</code> is 2 or 3, candidate names
must be given as a character or numeric vector. If a name is not given, 
but is still on a ballot, then the name is ignored !</p>
</td></tr>
<tr><td><code id="create_vote_+3A_isna">isna</code></td>
<td>
<p>entries which should be taken as NAs. 
<code>NA</code> in <code>x</code> will always be taken as missing value, 
however, you can add more (e.g., you may use 99, 999 as missing values). 
If x contains characters, 
this argument should also be provided with a 
character vector, and if numeric, then numeric vector. Do 
not add <code>NA</code> to <code>isna</code>, because the default (NULL)  
means <code>NA</code> is already included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts the following input:
</p>

<ul>
<li><p> (1) when <code>xtype</code> is 1, x must be a matrix. Column names are candidate names (if
column names are NULL, they will be created: x1, x2, x3...). Candidate number is the number 
of columns of the matrix. Entry ij is the numeric score assigned by 
the ith voter to the jth candidate.
</p>
</li>
<li><p> (2) when <code>xtype</code> is 2, x can be a matrix or data.frame. 
Candidate number is the length of <code>candidate</code>. 
Entries are names (character or numeric) of candidates. 
The i1, i2, i3... entries are the 1st, 2nd, 
3rd... preferences of voter i.
</p>
</li>
<li><p> (3) when <code>xtype</code> is 3, x should be a list. 
Each element of the list is a ballot, a vector 
contains the names (character or numeric) of candidates. 
The 1st preference is in the 1st position of 
the vector, the 2nd preference is in the 2nd position... The number of candidates is the length 
of <code>candidate</code>; as a result, a ballot with number of names 
larger than candidate number is 
labelled as wrong.
</p>
</li></ul>

<p>The function also returns Condorcet matrix. Suppose candidates are i, j, k. 
The voter likes i best, so he assigns 1 to i. The 2nd choice is j, so 
he assigns 2 to j, leaving k as NA. Now computing the Condorcet matrix: 
since i's score is smaller than j' score, we add 1 to the ij cell of the matrix, 
and add 0 to the ji cell. Candidate k's NA is automatically set to the 
highest (that is, the worst) score: 3 (since there are 3 candidates); i &lt; k, so 
we add 1 to the ik cell and add 0 to ki cell. Besides, there is also a score 
difference matrix: we add 2 - 1 = 1 to the ij cell of score difference matrix, 
and add 3 - 1 = 2 to the ik cell. If tie appears, both sides acquire 0.
</p>
<p>Note the ways we calculate the Condorcet matrix. (1) It allow ties, that is, 
duplicated score values. (2) NA is deems as the worst, which means: if a 
voter does not mention a candidate, the candidate will be given the 
highest (worst) score. (3) Ballots mention only one name are assumed 
to express preference, since unmentioned candidates are assumed to 
be equally hated. (4) The Condorcet matrix returned 
by <code>create_vote</code> uses ballots that may have duplicated values 
and have only one valid entry. However, Condorcet family 
methods in this package provide possibility to recalculate the matrix. 
And, the simplest way to get rid of duplicated values and NAs is 
to delete some ballots.
</p>


<h3>Value</h3>

<p>an object of class <code>vote</code> is returned, which 
is essentially a list. It has the following elements.
</p>

<ul>
<li><p> (1) <code>call</code> the call.
</p>
</li>
<li><p> (2) <code>ballot</code> the returned ballot. It is always a score matrix. 
The column names are candidate names; entries are numeric scores 
assigned by voters. Missing values are all set to NA.
</p>
</li>
<li><p> (3) <code>nas</code> those which are taken as NA in data cleaning.
</p>
</li>
<li><p> (4) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (5) <code>candidate_num</code> number of candidates.
</p>
</li>
<li><p> (6) <code>ballot_num</code> number of ballots.
</p>
</li>
<li><p> (7) <code>ballot_at_least_one</code> number of ballots that mention
at least one candidate.
</p>
</li>
<li><p> (8) <code>cdc</code> the Condorcet matrix calculated with ballots 
that have no NA entries.
</p>
</li>
<li><p> (9) <code>cdc_with_na</code> the Condorcet matrix calculated with 
ballots that have at least one valid entry.
</p>
</li>
<li><p> (10) <code>dif</code> the score difference matrix calculated with 
ballots that have no NA entries.
</p>
</li>
<li><p> (11) <code>dif_with_na</code> the score difference matrix calculated 
with ballots that have at least one valid entry.
</p>
</li>
<li><p> (12) <code>row_with_na</code> rows of <code>ballot</code> with NAs.
</p>
</li>
<li><p> (13) <code>row_non_na</code> for rows with NAs, the number of 
non-NA entries of them.
</p>
</li>
<li><p> (14) <code>row_with_dup</code> rows of <code>ballot</code> with 
duplicated score values.
</p>
</li>
<li><p> (15) <code>approval_able</code> if length of <code>row_non_dup</code> 
is 0, then it is TRUE, else, FALSE. It indicates whether approval 
method can be used. When <code>xtype</code> is 2 or 3, it is always TRUE.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># xtype is 2
raw &lt;- c(
    rep(c('m', 'n', 'c', 'k'), 42), 
    rep(c('n', 'c', 'k', 'm'), 26), 
    rep(c('c', 'k', 'n', 'm'), 15), 
    rep(c('k', 'c', 'n', 'm'), 17)
) 
raw &lt;- matrix(raw, ncol = 4, byrow = TRUE)
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'k', 'c'))

# xtype is 3
raw &lt;- list(
    c('a', 'e', 'c', 'd', 'b'), 
    c('b', 'a', 'e'), 
    c('c', 'd', 'b'), 
    c('d', 'a', 'b'), 
    c('a', 'a', 'b', 'b', 'b'), 
    c(NA, NA, NA, NA), 
    v7 = NULL, 
    v8 = c('a', NA, NA, NA, NA, NA, NA), 
    v9 = rep(" ", 3)
)
y &lt;- check_dup_wrong(raw, xtype = 3, candidate = letters[1: 4])
raw2 &lt;- raw[-y$row_with_wrong]
vote &lt;- create_vote(raw2, xtype = 3, candidate = letters[1: 4])

# xtype is 1
raw &lt;- rbind(
    c(1, 2, 5, 3, 3), 	
    c(2, 1, 1, 3, 5), 	
    c(1, 2, 5, 3, 4), 
    c(1, 2, 5, 3, 4), 
    c(NA, NA, NA, NA, NA),		
    c(NA, 3, 5, 1, 2), 
    c(NA, 999, NA, 1, 5)
)
vote &lt;- create_vote(raw, xtype = 1, isna = 999)
</code></pre>

<hr>
<h2 id='dowdall_method'>Dowdall Method</h2><span id='topic+dowdall_method'></span>

<h3>Description</h3>

<p>This is an alternative Borda method. Voters are required 
to assign preference scores to every candidate and one 
score value cannot be shared by two or more candidates. 
For a voter, his 1st choice gets 1, his 2nd choice gets 
1/2, his 3rd choice gets 1/3... The candidate who gets 
the most points wins. For the function 
<code>dowdall_method</code>, ranks, rather than true 
values, are used. So 1, 3, 5 are ranked as 1, 2, 3, and the 
scores are 1/1, 1/2, 1/3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dowdall_method(x, stop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dowdall_method_+3A_x">x</code></td>
<td>
<p>an object of class <code>vote</code>. The ballots in 
the object should not have duplicated values and NAs.</p>
</td></tr>
<tr><td><code id="dowdall_method_+3A_stop">stop</code></td>
<td>
<p>default is FALSE, when ballots do have 
duplicated values or NAs, error will not be raised, but 
the winner will be NULL. If TRUE, an error will be raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
used to compute the result.
</p>
</li>
<li><p> (7) <code>winner</code> the winners.
</p>
</li>
<li><p> (8) <code>other_info</code> total scores.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> https://en.wikipedia.org/wiki/Borda_count
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- list2ballot(string = 
    c("51: a&gt;c&gt;b&gt;d", "5: c&gt;b&gt;d&gt;a", "23: b&gt;c&gt;d&gt;a", "21: d&gt;c&gt;b&gt;a")
)
vote &lt;- create_vote(raw, xtype = 3, candidate = c("a", "b", "c", "d"))
y1 &lt;- borda_method(vote) # winner is c
y2 &lt;- dowdall_method(vote) # winner is a
</code></pre>

<hr>
<h2 id='irv_method'>Instant-Runoff Voting Method</h2><span id='topic+irv_method'></span>

<h3>Description</h3>

<p>Instant-runoff voting (IRV) method is also 
called alternative voting, 
transferable voting, ranked-choice voting, 
single-seat ranked-choice voting, or preferential voting.
In the 1st round, the candidate with absolute majority (that 
is, with more than 50 percent) wins. If no absolute winner exists, 
the one who gets the least votes is deleted, all other 
candidates enter into the 2nd round. Again, if no 
absolute winner exists, let the one with the least votes go and 
start the 3rd round... Finally, an absolute winner will 
appear. Ties are solved with different methods in reality; however, 
this function applies the following rules: (a) if more than 
one candidate gets the least votes, let all of them go; (b) if 
all the candidates get the same number of votes in a certain round, 
then all of them are winners. Note: the function accepts 
object of class <code>vote</code> and the method can only be 
used when x$approval_able is TRUE, that is, there is 
no duplicated values in the score matrix; otherwise, 
the winner will be NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irv_method(x, min_valid = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irv_method_+3A_x">x</code></td>
<td>
<p>an object of class <code>vote</code>.</p>
</td></tr>
<tr><td><code id="irv_method_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, the ballot will not be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
used to compute the result.
</p>
</li>
<li><p> (7) <code>winner</code> the winners, may be NULL.
</p>
</li>
<li><p> (8) <code>absolute</code> whether the winner wins absolute majority in the
1st round.
</p>
</li>
<li><p> (9) <code>other_info</code> the IRV may run for 2 or more rounds. So here 
the summary information of each round is recorded. The length of the list is 
equal to the number of rounds.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Reilly, B. 2004. The global spread of preferential 
voting: Australian institutional imperialism? 
Australian Journal of Political Science, 39(2), 253-266.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- c(
   rep(c('m', 'n', 'c', 'k'), 42), rep(c('n', 'c', 'k', 'm'), 26), 
   rep(c('c', 'k', 'n', 'm'), 15), rep(c('k', 'c', 'n', 'm'), 17)
) 
raw &lt;- matrix(raw, ncol = 4, byrow = TRUE)
vote &lt;- create_vote(raw, xtype = 2, candidate = c('m', 'n', 'k', 'c'))
y &lt;- irv_method(vote) # winner is k
</code></pre>

<hr>
<h2 id='list2ballot'>Repeat ith element of list x or row of matrix/data.frames 
for j times</h2><span id='topic+list2ballot'></span>

<h3>Description</h3>

<p>Suppose you have 3 different unique ballots and the amount 
of each ballot is 10, 20, 30. Now you want to create raw 
ballots as a list. Then you can use this function. See examples
for usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2ballot(x = NULL, n = rep(1, length(x)), m = NULL, string = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2ballot_+3A_x">x</code></td>
<td>
<p>a list, each element of which should be a vector. Note: 
only one of <code>x</code>, <code>m</code> and <code>string</code> 
can be a non-NULL object</p>
</td></tr>
<tr><td><code id="list2ballot_+3A_n">n</code></td>
<td>
<p>how many times each element of <code>x</code> 
or each row of <code>m</code> should be replicated.
It should be a numeric vector of non-negative integers and the 
length of it should be equal to that of <code>x</code> or the row number 
of <code>m</code>. 
The default is 1 for each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="list2ballot_+3A_m">m</code></td>
<td>
<p>a matrix or dataframe, the number of rows should be 
equal to the length of n.</p>
</td></tr>
<tr><td><code id="list2ballot_+3A_string">string</code></td>
<td>
<p>default is NULL. If it is not NULL,  <code>x</code>, <code>m</code> 
and <code>n</code> are ignored. It should be a character vector. Each 
one contains two parts, the 1st is the amount of 
that ballot, and the 2nd part contains the names. The 1st and 
2nd parts, as well as the names, should be split by spaces 
or punctuations. But no space and punctuation is allowed 
inside the names (&quot;_&quot; is not taken to be 
a punctuation). See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with replicated vectors, if <code>x</code> is not NULL, 
or a matrix/data.frame with duplicated rows, if 
<code>m</code> is not NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use x and n
unique_ballot &lt;- list(
    c("A", "B", "C"), c("F", "A", "B"),
    c("E", "D", "C", "B", "F", "A"), c("x","x", "A")
)
r &lt;- c(1, 2, 3, 0)
y &lt;- list2ballot(unique_ballot, r)

# Use string, x and n will be ignored.
# The characters can be written in a very loose way as follows, 
# for the function will automatically delete unwanted parts.
# But do make sure there is no space or punctuation
# inside the names.
unique_ballot &lt;- c(
	"2, Bob, Mike Jane", 	"3: barack_obama;;Bob&gt;Jane", 
	"0 Smith   Jane", "  1 Mike???!!!"
)
y &lt;- list2ballot(string = unique_ballot)
# Use a matrix.
m &lt;- matrix(c(1, 2, 3, 3, 1, 2), nrow = 2, byrow = TRUE)
colnames(m) &lt;- c("p1", "p2", "p3")
r &lt;- c(3, 5)
y &lt;- list2ballot(m = m, n = r)
</code></pre>

<hr>
<h2 id='plurality_method'>Plurality Method to Find Absolute or Relative Majority</h2><span id='topic+plurality_method'></span>

<h3>Description</h3>

<p>Although with plurality method each voter is required to mention 
only one candidate, a ballot with more than one candidate and 
different scores is also valid. For a score matrix, the function will 
check the position j which has the lowest score (in a <code>vote</code> object, 
the lower, the better) in the ith row. Duplicated values may or may 
not be a problem. For instance, <code>c(2, 3, 3)</code> is valid, for the 
lowest value is 2 and it is in the 1st position. However, 
<code>c(2, 2, 3)</code> is a problem, for the 1st and 2nd positions 
all have the lowest value 2. If this problem exists, the winner 
returned by this function will be NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plurality_method(x, allow_dup = TRUE, min_valid = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plurality_method_+3A_x">x</code></td>
<td>
<p>an object of class <code>vote</code>.</p>
</td></tr>
<tr><td><code id="plurality_method_+3A_allow_dup">allow_dup</code></td>
<td>
<p>whether ballots with duplicated score values 
are taken into account. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plurality_method_+3A_min_valid">min_valid</code></td>
<td>
<p>default is 1. If the number of valid entries of 
a ballot is less than this value, the ballot will not be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
used to compute the result.
</p>
</li>
<li><p> (7) <code>winner</code> the winners, may be one, more than one or NULL.
</p>
</li>
<li><p> (8) <code>absolute</code> whether the winner is of absolute majority.
</p>
</li>
<li><p> (9) <code>other_info</code> a list with 2 elements, the 1st is the 
frequencies of candidates mentioned as 1st choice; the second element is 
the percentage. If winner is NULL, these two are NULL.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- rbind(
    c(1, 2, 5, 3, 3), c(1, 2, 5, 3, 4), c(1, 2, 5, 3, 4), 
    c(NA, NA, NA, NA, NA), c(NA, 3, 5, 1, 2), 
    c(NA, NA, NA, 2, 3), c(NA, NA, 1, 2, 3), 
    c(NA, NA, NA, NA, 2), c(NA, NA, NA, 2, 2), 
    c(NA, NA, 1, 1, 2), c(1, 1, 5, 5, NA)
)
vote &lt;- create_vote(raw, xtype = 1)
y &lt;- plurality_method(vote, allow_dup = FALSE)
y &lt;- plurality_method(vote, allow_dup=FALSE, min_valid = 3)
</code></pre>

<hr>
<h2 id='star_rating'>User Preference Aggregation</h2><span id='topic+star_rating'></span>

<h3>Description</h3>

<p>The function uses a simple method to 
calculate the aggregation scores of user 
ratings, which is described 
in Langville, A. and Meyer, C. (2012: 128). 
Input data can be stored in a sparse matrix.
Suppose there are 100 films and users are required to assign 
scores. However, each user only watched several of them. Thus, 
when comparing two films A and B, the method only takes account 
ratings from those who watched both A and B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>star_rating(x, show_name = FALSE, check_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="star_rating_+3A_x">x</code></td>
<td>
<p>a numeric matrix, or, <code>dgCMatrix</code> and 
<code>dgeMatrix</code> matrix created with the Matrix package.
0 in the data means no score is given; and valid score values 
should all be larger than 0. The function will do NOTHING
to check the validity.
Besides, NA also means no score is given. If your data has NA, 
set <code>check_na</code> to TRUE so as to convert NA to 0.</p>
</td></tr>
<tr><td><code id="star_rating_+3A_show_name">show_name</code></td>
<td>
<p>the default is FALSE, that is to say, the function 
does not store and show candidate names in the result and you 
cannot see them. However, you can set it to TRUE.</p>
</td></tr>
<tr><td><code id="star_rating_+3A_check_na">check_na</code></td>
<td>
<p>if it is TRUE, the function will check NAs and convert 
them to 0s. If NAs do exist and <code>check_na</code> is FALSE, error will be 
raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object.
</p>

<ul>
<li><p> (1) <code>call</code> the function call.
</p>
</li>
<li><p> (2) <code>method</code> the counting method.
</p>
</li>
<li><p> (3) <code>candidate</code> candidate names. If 
<code>show_name</code> is FALSE, this will be NULL.
</p>
</li>
<li><p> (4) <code>candidate_num</code> number of candidate.
</p>
</li>
<li><p> (5) <code>ballot_num</code> number of ballots in x.
</p>
</li>
<li><p> (6) <code>valid_ballot_num</code> number of ballots that are 
used to compute the result.
</p>
</li>
<li><p> (7) <code>winner</code> the winner. If <code>show_name</code> is FALSE, 
this only shows the number in <code>1: ncol(x)</code>.
</p>
</li>
<li><p> (8) <code>winner_score</code> the winner's score, which is the highest score.
</p>
</li>
<li><p> (9) <code>other_info</code> scores of all the candidates.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Langville, A. and Meyer, C. 2012. 
Who's #1? The Science of Rating and Ranking. 
Princeton University Press, p. 128.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example from Langville and Meyer, 2012: 128. 
# 4 films are rated by 10 users; 0 means no score.
raw &lt;- c(4, 3, 1, 2, 0, 2, 0, 3, 0, 2, 2, 1, 0, 4, 3, 3, 4, 
    1, 3, 0, 2, 0, 2, 2, 2, 0, 1, 1, 2, 2, 0, 2, 0, 0, 5, 0, 3, 
    0, 5, 4
)
m &lt;- matrix(raw, ncol = 4)
colnames(m) &lt;- paste("film", 1: 4, sep = "")
y &lt;- star_rating(m, show_name = TRUE) # winner is film4
</code></pre>

<hr>
<h2 id='votesys-package'>Voting Systems, Instant-Runoff Voting, Borda Method, Various Condorcet Methods</h2><span id='topic+votesys-package'></span><span id='topic+votesys'></span>

<h3>Description</h3>

<p>This package provides different methods for counting ballots, which 
can be used in election, decision making and evaluation. The basic 
idea is: different forms of ballots can all be transformed into a 
score matrix; then the score matrix can be put into different 
counting methods. The functions 
in this package provide more flexibility to deal with duplicated 
values (ties) and missing values. And the comparison of results 
of different methods is also made easy.
</p>


<h3>Author(s)</h3>

<p>Jiang Wu
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Suppose we have the following ballot data
raw &lt;- list2ballot(
    x = list(
        c('m', 'n', 'c', 'k'), c('n', 'c', 'k', 'm'), 
        c('c', 'k', 'n', 'm'), c('k', 'c', 'n', 'm'), c(NA, NA, NA, NA)
    ) , 
    n = c(42, 26, 15, 17, 3)
)

# Step 1: check validity of ballots. Delete  
# some of them, if needed.
check_validity &lt;- check_dup_wrong(raw, 
    xtype = 3, 
    candidate = c("m", "n", "k", "c")
)
raw &lt;- raw[- check_validity$row_all_na]

# Step 2: create a vote object
vote &lt;- create_vote(raw, xtype = 3, candidate = c("m", "n", "k", "c"))

# Step 3: use one or more methods
y &lt;- plurality_method(vote) # winner is m
y &lt;- irv_method(vote) # winner is k
y &lt;- cdc_simple(vote) # winner is n
y &lt;- cdc_rankedpairs(vote) # winner is n
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
