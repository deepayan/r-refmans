<!DOCTYPE html><html><head><title>Help for package magicaxis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {magicaxis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#magaxis'>
<p>Magically pretty axes</p></a></li>
<li><a href='#magbar'>
<p>Pretty colour bar</p></a></li>
<li><a href='#magbin'>
<p>2D Binning Routines</p></a></li>
<li><a href='#magclip'>
<p>Magical sigma clipping</p></a></li>
<li><a href='#magcon'>
<p>2D quantile images and contours</p></a></li>
<li><a href='#magcurve'><p>Draw Function Plots</p></a></li>
<li><a href='#magcutout'>
<p>Image Cutout Utility</p></a></li>
<li><a href='#magerr'>
<p>Error bar plotting</p></a></li>
<li><a href='#maghist'>
<p>Magically pretty histograms</p></a></li>
<li><a href='#magimage'>
<p>Magically pretty images</p></a></li>
<li><a href='#maglab'>
<p>Pretty scientific labelling</p></a></li>
<li><a href='#magmap'>
<p>Value remapper</p></a></li>
<li><a href='#magplot'>
<p>Magically pretty plots</p></a></li>
<li><a href='#magproj'>
<p>Magic longitude / latitude projection function</p></a></li>
<li><a href='#magprojextra'>
<p>Attractive great circles and thick bands on magproj plots</p></a></li>
<li><a href='#magrun'>
<p>Running averages</p></a></li>
<li><a href='#magtri'>
<p>High level triangle plotting code for MCMC chains</p></a></li>
<li><a href='#plot.magbin'>
<p>Plot 2D Histogram or Bin Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pretty Scientific Plotting with Minor-Tick and Log Minor-Tick
Support</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Robotham</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Robotham &lt;aaron.robotham@uwa.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to make useful (and pretty) plots for scientific plotting. Additional plotting features are added for base plotting, with particular emphasis on making attractive log axis plots.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>imager, fst</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, celestial (&ge; 1.4.1), MASS,
plotrix, sm, mapproj, RANN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 13:17:42 UTC; aaron</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='magaxis'>
Magically pretty axes
</h2><span id='topic+magaxis'></span>

<h3>Description</h3>

<p>This function generates nicely arranged axes for scientific plots, including minor tick marks. It supports log settings and can unclog axes that have been logged inline by the user. When the dynamic range is 50 or less and axis is logged, axis range factors of 10 times 1, 2 and 5 are used instead of powers of 10 alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magaxis(side = 1:2, majorn = 5, minorn = 'auto', tcl = 0.5, ratio = 0.5, labels = TRUE,
unlog = 'auto', mgp = c(2,0.5,0), mtline = 2, xlab = NULL, ylab = NULL, crunch = TRUE,
logpretty = TRUE, prettybase = 10, powbase = 10, hersh = FALSE, family = 'sans',
frame.plot = FALSE, usepar = FALSE, grid = FALSE, grid.col = 'grey', grid.lty = 1,
grid.lwd = 1, axis.lwd = 1, ticks.lwd = axis.lwd, axis.col = 'black', do.tick = TRUE,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magaxis_+3A_side">side</code></td>
<td>

<p>The side to be used for axis labelling in the same sense as the base axis function (1=bottom, 2=left, 3=top, 4=right). A vector of multiple entries is allowed. By default, bottom and left axes are drawn (i.e. side 1 and 2).
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_majorn">majorn</code></td>
<td>

<p>The target number of major-axis sub-divisions for pretty plotting. If length is 1 and length of side is longer than this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. Obvious reason for varying this is different pretty labelling between x and y axes.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_minorn">minorn</code></td>
<td>

<p>The exact number of minor-axis divisions (i.e. desired minor ticks + 1) to display in plotting. Auto will produce <code><a href="base.html#topic+pretty">pretty</a></code> ticks for linear scaling, and powbase-2 minor ticks for logged (this might seem odd, but for base 10 this means ticks at 2/3/4/5/6/7/8/9, which is probably as desired). If set manually, must be greater than 1 to have a visible effect. Minor ticks are always calculated to be equally spaced in linear space, so tick spaces vary when using log plotting. If length is 1 and length of side is longer than this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. An obvious reason for varying this is different pretty labelling between x and y axes.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_tcl">tcl</code></td>
<td>

<p>The length of major tick marks as a fraction of the height of a line of text. By default these face into the plot (in common with scientific plotting) with a value of 0.5, rather than the R default of -0.5. It is possible to force magaxis to inherit directly from par by setting usepar=TRUE (see below). See <code><a href="graphics.html#topic+par">par</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_ratio">ratio</code></td>
<td>

<p>Ratio of minor to major tick mark lengths.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_labels">labels</code></td>
<td>

<p>Specifies whether major-axis ticks should be labelled for each axis. If length is 1 and length of side is longer than this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. Default is to label all axes.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_unlog">unlog</code></td>
<td>

<p>Determines if axis labels should be unlogged. If axis is found to be logged in par('usr') then the minor ticks are automatically log spaced, however &quot;unlog&quot; still controls how the labelling is done: either logged form (FALSE) or exponent form (TRUE). If axis has been explicitly logged (e.g. log10(x)) then this will can produce exponential axis marking/ labelling if set to TRUE. This case will also produce log minor tick marks. If length of unlog is 1 and length of side is longer than 1 then the assigned unlog value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. Can also take the text argument 'x', 'y', 'xy' or 'yx', where these refer to which axes have been logged. If left at the default of &lsquo;Auto&rsquo; then unlog is assumed to be true when the axis in question is logged, and false otherwise.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_mgp">mgp</code></td>
<td>

<p>The margin line (in mex units) for the axis title, axis labels and axis line. This has different (i.e. prettier) defaults than R of c(2,0.5,0) rather than c(3,1,0). This pushes the numbers and labels nearer to the plot compared to the defaults. It is possible to force magaxis to inherit directly from par by setting usepar=TRUE (see below). See <code><a href="graphics.html#topic+par">par</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_mtline">mtline</code></td>
<td>

<p>Number of lines separating axis name from axis. If length 2 then specifies x and y axis separation respectively (else these are the same).
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_xlab">xlab</code></td>
<td>

<p>x axis name.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_ylab">ylab</code></td>
<td>

<p>y axis name.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_crunch">crunch</code></td>
<td>

<p>In cases where the scientific text would be written as 1x10^8, should the 1x be removed so it reads 10^8. If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. TRUE by default.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_logpretty">logpretty</code></td>
<td>

<p>Should the major-ticks only be located at powers of 10. This changes cases where ticks are placed at 1, 3.1, 10, 31, 100 etc to 1, 10, 100. If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. TRUE by default.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_prettybase">prettybase</code></td>
<td>

<p>The unit of repitition desired. By default it is 10, implying a pretty plot is one with marks at 10, 20, 30 etc. If you are plotting degrees then it might be prettier to display 90, 180, 270 etc. In which case prettybase should be set to 90. If log=TRUE then the reference location of 10 is changed, so in the previous example the labels generated would be at 9, 90, 900 etc rather than the deafult of 1, 10, 100 etc. If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_powbase">powbase</code></td>
<td>

<p>Set the base to use for logarithmic axes. Default is to use 10.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_hersh">hersh</code></td>
<td>

<p>To determines whether all plot text should be passed using Hershey vector fonts. This applies to the axis labels (which are handled automatically) and the axis names. In the case of axis names the user must be careful to use the correct plot utils escape characters: http://www.gnu.org/software/plotutils/manual/en/html_node/Text-String-Format.html.
magaxis will return back to the current plotting family after the function has executed.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_family">family</code></td>
<td>

<p>Specifies the plotting family to be used. Allowed options are 'sans' and 'serif'. Depending on whether hersh is TRUE or FALSE these otions are either applied to the Hershey vector fonts (hersh=TRUE) or the default R Helvetica font (hersh=FALSE). magaxis will return back to the current plotting family after the function has executed.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Logical indicating whether a box should be drawn around the plot.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_usepar">usepar</code></td>
<td>

<p>Logical indicating whether tcl and mgp should be forced to inherit the global par values. This might be preferred when you want to define global plot settings at the start of a script.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_grid">grid</code></td>
<td>

<p>Logical indicating whether a background grid should be drawn onto the plotting area. This will only be done for side=1 (i.e. vertical grid lines) and side=2 (i.e. horizontal grid lines). If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. FALSE by default.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_grid.col">grid.col</code></td>
<td>

<p>The colour of the grid to be drawn.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_grid.lty">grid.lty</code></td>
<td>

<p>The line type of the grid to be drawn.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_grid.lwd">grid.lwd</code></td>
<td>

<p>The line width of the grid to be drawn.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_axis.lwd">axis.lwd</code></td>
<td>

<p>The line width of the axis to be drawn. This is passed to <span class="option">lwd</span> argument in <code><a href="graphics.html#topic+axis">axis</a></code>.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_ticks.lwd">ticks.lwd</code></td>
<td>

<p>The line width of the ticks to be drawn. This is passed to <span class="option">ticks.lwd</span> argument in <code><a href="graphics.html#topic+axis">axis</a></code>.
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_axis.col">axis.col</code></td>
<td>

<p>Colour argument to pass directly to <span class="option">col</span> in axis. It is a bit clunky to have to specify this, but the option 'col' clashes too much with line and point colours.  
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_do.tick">do.tick</code></td>
<td>

<p>Logical; should ticks be drawn? Passed to <code><a href="graphics.html#topic+axis">axis</a></code> argument <span class="option">tick</span>.  
</p>
</td></tr>
<tr><td><code id="magaxis_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to base <code><a href="graphics.html#topic+axis">axis</a></code> and <code><a href="graphics.html#topic+mtext">mtext</a></code> functions as relevant. Options for axis are as described in <code><a href="graphics.html#topic+axis">axis</a></code>, but note <span class="option">cex.lab</span>, <span class="option">col.lab</span> and <span class="option">font.lab</span> are parsed as <span class="option">cex</span>, <span class="option">col</span> and <span class="option">font</span> into <code><a href="graphics.html#topic+mtext">mtext</a></code> as required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries hard to make nice plots for scientific papers.
</p>


<h3>Value</h3>

<p>No output. Run for the side effect of producing nice plotting axes.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magerr">magerr</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=10^{1:9}
y=1:9
plot(log10(x),y,axes=FALSE)
magaxis(unlog='x')

plot(log10(x),y,axes=FALSE)
magaxis(side=c(1,3),unlog=c(TRUE,FALSE))

plot(x,y,axes=FALSE,log='x')
magaxis()

</code></pre>

<hr>
<h2 id='magbar'>
Pretty colour bar
</h2><span id='topic+magbar'></span>

<h3>Description</h3>

<p>This function is a high level interface to the plotrix 'color.legend' function. It makes reasonable assumptions on the plottin window to place the colour and allows the user to specify log spacing for the colour gradient and labels, as well as add a title.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magbar(position = "topright", range = c(0, 1), orient = "v", log = FALSE,
  col = hcl.colors(21), scale = c(1/4, 1/20), inset = 1/40, labN = 5, title = "",
  titleshift = 0, centrealign = "rb", clip = '', cex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magbar_+3A_position">position</code></td>
<td>

<p>Relative position of the colour bar. This argument is used like the 'legend' function. Specify one of 'bottom', 'bottomleft', 'left', 'topleft', 'top', 'topright', 'right', 'bottomright' and 'centre'.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_range">range</code></td>
<td>

<p>The text label limits used to label the colour bar.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_orient">orient</code></td>
<td>

<p>Orientation. Allowed options are 'v' for vertical and 'h' for horizontal.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_log">log</code></td>
<td>

<p>Should the colour spacing and labelling be log spaced.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_col">col</code></td>
<td>

<p>Colour palette to use for the colouring of the bar.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_scale">scale</code></td>
<td>

<p>The relative (to the plot window) length and width of the colour bar.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_inset">inset</code></td>
<td>

<p>Relative (to the plot window) inset of the colour bar.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_labn">labN</code></td>
<td>

<p>The number of text labels to draw on the colour bar.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_title">title</code></td>
<td>

<p>Optional title (or axis label for the labels) to add to the colour bar.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_titleshift">titleshift</code></td>
<td>

<p>Extra shift to apply to the 'title' position.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_centrealign">centrealign</code></td>
<td>

<p>Option to control the labeling position used when the position='centre'.
</p>
</td></tr>
<tr><td><code id="magbar_+3A_clip">clip</code></td>
<td>

<p>Setting clip='bg' will set values outside the 'range' values to be blank on the magbar (i.e. you can see through to the background).
</p>
</td></tr>
<tr><td><code id="magbar_+3A_cex">cex</code></td>
<td>

<p>Character expansion factor for the labels.  
</p>
</td></tr>
<tr><td><code id="magbar_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the <code><a href="#topic+maglab">maglab</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates pretty default colour bars by assessing the current plot window. It is a higher level implementation of the plotrix 'color.legend' function.
</p>


<h3>Value</h3>

<p>Called for the side effect of plotting a colour bar.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>magplot(sin)
magbar('top')
magbar('right',title='Just looking',titleshift=0.5)
magbar('topleft',orient='h',title='Hello!')
magbar('bottom',range=c(0.3,30),orient='h',log=TRUE,title='Log test col')
magbar('bottomleft',range=c(0.3,30),orient='v',log=TRUE,title='Log test bg',clip='bg')

</code></pre>

<hr>
<h2 id='magbin'>
2D Binning Routines
</h2><span id='topic+magbin'></span>

<h3>Description</h3>

<p>Allows for 2D binning (counts) and summary statistics on 2D bins (medians etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magbin(x, y, z = NULL, xlim = NULL, ylim = NULL, zlim = NULL, Nbin = 50, step = NULL,
  log = '', unlog = log, clustering = 10, dustlim = 0.1, shape = "hex",
  plot = TRUE, colramp = hcl.colors(21), colstretch = "lin", sizestretch = "lin",
  colref = "count", sizeref = "none", funstat = function(x) median(x, na.rm=TRUE),
  direction = 'h', offset = 0, jitterseed = 666, projden = FALSE, projsig = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magbin_+3A_x">x</code></td>
<td>

<p>Numeric vector or matrix/data.frame; x values to 2D bin. If x is a two (or more) column matrix or data.frame and y/z is missing as an argument, then the first column is used for x and the second/third column for y/z.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_y">y</code></td>
<td>

<p>Numeric vector; the y coordinates of points in the plot, optional if <span class="option">x</span> is an appropriate structure.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_z">z</code></td>
<td>

<p>Numeric vector; the z coordinates of points in the plot (optional), optional if <span class="option">x</span> is an appropriate structure.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_xlim">xlim</code></td>
<td>

<p>Numeric vector; the x limits to use for the data. Default of NULL calculates the range based on the provided <span class="option">x</span> data vector. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code><a href="#topic+magclip">magclip</a></code>.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_ylim">ylim</code></td>
<td>

<p>Numeric vector; the y limits to use for the data. Default of NULL calculates the range based on the provided <span class="option">y</span> data vector. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code><a href="#topic+magclip">magclip</a></code>.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_zlim">zlim</code></td>
<td>

<p>Numeric vector; the z limits to use for the data. Default of NULL calculates the range based on the provided <span class="option">z</span> data vector. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code><a href="#topic+magclip">magclip</a></code>.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_nbin">Nbin</code></td>
<td>

<p>Integer vector; The number of bins to (approximately) split the x/y axes into. If length 1 then this value is used by both (default is 50 bin in x/y), if length 2 then Nbin[1] is used for the x-axis and Nbin[2] is used for the y-axis.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_step">step</code></td>
<td>

<p>Numeric vector; grid steps in x and y directions. If NULL then this is c(diff(xlim), diff(ylim))/Nbin. If length 1, then this value is repeated. Overrides <span class="option">Nbin</span> if supplied.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_log">log</code></td>
<td>

<p>Character scalar; log axis arguments to be passed to used. E.g. use 'x', 'y', 'xy' or 'yx' as appropriate. Default &rdquo; assumes no logging of any axes. For convenience you can specify the 'z' axis too, which somewhat replaces the <span class="option">colstretch</span> argument. Note that in all cases the <span class="option">x</span>/<span class="option">y</span>/<span class="option">z</span> data is explictly logged, which means the plotting window does not know it is in logged space (via the par()$xlag and par()$ylog structures). This means is you want to add points etc to the plot you will need to apply log10 yourself, so a point with coordinates [10^2,10^-3] should be plotted at [2,-3].
</p>
</td></tr>
<tr><td><code id="magbin_+3A_unlog">unlog</code></td>
<td>

<p>Character scalar; determines if x/y axis labels should be unlogged (z is ignored here). By default inherits <span class="option">log</span>, since that is usually what you would want.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_clustering">clustering</code></td>
<td>

<p>Numeric scalar; excess counts in densist bin relative to Uniform data. This is to optimise the binning, so can probably be ignored.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_dustlim">dustlim</code></td>
<td>

<p>Numeric scalar; if between 0 and 1 then the 2D bin count quantile to switch to showing the individual points (which visually look like 'dust'), if larger than 1 then the exact counts threshold. If this is NA or 0 then all cells are shown.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_shape">shape</code></td>
<td>

<p>Character scalar; type of binning, either hex/hexagon; sq/square; tri/triangle or trihex. 'trihex' is a triangle tessellation that is also arranged to have hexagonal packing (so 6 triangles can form a hexagon).
</p>
</td></tr>
<tr><td><code id="magbin_+3A_plot">plot</code></td>
<td>

<p>Logical; create a plot? If FALSE then just the binning output list is created.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_colramp">colramp</code></td>
<td>

<p>Vector; a colour scaling to use. Must be a vector and not a function.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_colstretch">colstretch</code></td>
<td>

<p>Character scalar; colour stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td></tr>
<tr><td><code id="magbin_+3A_sizestretch">sizestretch</code></td>
<td>

<p>Character scalar; size stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td></tr>
<tr><td><code id="magbin_+3A_colref">colref</code></td>
<td>

<p>Character scalar; colour reference for call, either it should be based on the counts (count, default) or the z-axis statistic (zstat)?
</p>
</td></tr>
<tr><td><code id="magbin_+3A_sizeref">sizeref</code></td>
<td>

<p>Character scalar; size reference for call, either it should be ignored (none, so all are the same size and closely packed), based on the counts (count) or the z-axis statistic (zstat)?
</p>
</td></tr>
<tr><td><code id="magbin_+3A_funstat">funstat</code></td>
<td>

<p>Function; function to use to compute a statistic over the <span class="option">z</span> axis. The default is <code><a href="stats.html#topic+median">median</a></code>, but other good options might be <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>. Note, to change default arguments you might need to send through a new function, e.g. <span class="option">funstat</span> = function(x) median(x, na.rm=TRUE) and similar, but if you are happy with the defaults then you can use the simpler <span class="option">funstat</span> = mean etc.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_direction">direction</code></td>
<td>

<p>Character scalar;  should there be a shape side aligned horizontally ('h', the default) or vertically ('v')? This is only relevant for hexagon and triangle bin shapes, and has the effect of leading the eye differently with some scatter structures.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_offset">offset</code></td>
<td>

<p>Numeric/character scalar; only relevant for <span class="option">shape</span>='sq' or <span class="option">shape</span>='tri'. Either a numeric value specifying the offset (relative to <span class="option">step</span>) to apply to alternating rows (<span class="option">direction</span>='h') or columns (<span class="option">direction</span>='v'); or 'jitter' which means the rows or columns are randomly jittered (only used for <span class="option">shape</span>='sq' bins. This option is useful for visually breaking up strong patterns in certain types of data.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_jitterseed">jitterseed</code></td>
<td>

<p>Integer scalar; the random seed to use for jittering (means you can recreate your plots exactly if the seed is the same). This argument is only used for <span class="option">shape</span>='sq' bins.
</p>
</td></tr>
<tr><td><code id="magbin_+3A_projden">projden</code></td>
<td>

<p>Logical; do you want projected density PDFs to be displayed above and to the side of the standard <code>plot.magbin</code> plot? If so you also need to pass the same <span class="option">xdata</span> and <span class="option">ydata</span> that you originally sent to <code><a href="#topic+magbin">magbin</a></code>, since this is not stored in the object output from <code><a href="#topic+magbin">magbin</a></code>. 
</p>
</td></tr>
<tr><td><code id="magbin_+3A_projsig">projsig</code></td>
<td>

<p>Logical; if <span class="option">projden</span> = TRUE then this will optionally add lines to show the pseudo 1-sigma range (15.9% to 84.1% quantiles).
</p>
</td></tr>
<tr><td><code id="magbin_+3A_...">...</code></td>
<td>

<p>Dots to be passed to <code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magmap">magmap</a></code> and <code><a href="#topic+magbar">magbar</a></code>. Relevant arguments are matched, so look in those functions for optional arguments to pass.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mostly run for the side effect of making a nice plot, but the output bin statistics might also be useful.
</p>
<p>Re performance, <code>magbin</code> works pretty well on a modern computer for up to ~1e6 points, taking only a few seconds to run usually. Beyond this you might need to carefully tune the performance with <span class="option">clutering</span> otherwise it might run very slower and/or you run out of memory.
</p>


<h3>Value</h3>

<p>List of class 'magbin' containing:
</p>
<table>
<tr><td><code>bins</code></td>
<td>
<p>Bin x / y / count / and zstat info</p>
</td></tr>
<tr><td><code>dust</code></td>
<td>
<p>Dust x / y / z info</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>Links input <span class="option">x</span> and <span class="option">y</span> data to the nearest grid cell by row number of <span class="option">bins</span></p>
</td></tr>
<tr><td><code>xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p><span class="option">step</span> size</p>
</td></tr>
<tr><td><code>dustlim</code></td>
<td>
<p><span class="option">dustlim</span></p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p><span class="option">shape</span></p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p><span class="option">direction</span></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.magbin">plot.magbin</a></code>, <code><a href="#topic+maghist">maghist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)
xydata = cbind(rnorm(1e4), rnorm(1e4))
magbin(xydata, shape='hexagon') #default
magbin(xydata, shape='hexagon', Nbin=25) #A bit coarser
magbin(xydata, shape='square')
magbin(xydata, shape='triangle')
magbin(xydata, shape='trihex')
magbin(xydata, shape='hexagon', direction='v')
magbin(xydata, shape='triangle', direction='v')
magbin(xydata, shape='trihex', direction='v')

magbin(xydata, shape='hexagon', step=c(0.2,0.4)) #different aspect ratio hexagons

magbin(xydata, z=xydata[,1]^2-xydata[,2]^2, colref='zstat', sizeref='count')

magbin(xydata, z=xydata[,1]^2-xydata[,2]^2, colref='zstat', sizeref='count',
funstat=mad)
magbin(xydata, z=xydata[,1]^2-xydata[,2]^2, colref='zstat', sizeref='count',
funstat=function(x){quantile(x,0.9)})

xydata = cbind(10^rnorm(1e4), 10^rnorm(1e4))
magbin(xydata, log='xy')
magbin(xydata, z=xydata[,1]*xydata[,2], colref='zstat', sizeref='count',
log='xyz')
magbin(xydata, log='xy', unlog='xy', xlim=3, ylim=3)
</code></pre>

<hr>
<h2 id='magclip'>
Magical sigma clipping
</h2><span id='topic+magclip'></span>

<h3>Description</h3>

<p>This function does intelligent autoamtic sigma-clipping of data. This is optionally used by <code><a href="#topic+magplot">magplot</a></code> and <code><a href="#topic+maghist">maghist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magclip(x, sigma = 'auto', clipiters = 5, sigmasel = 1, estimate = 'both', extra = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magclip_+3A_x">x</code></td>
<td>

<p>Numeric; the values to be clipped. This can reasonably be a vector, a matrix or a dataframe.
</p>
</td></tr>
<tr><td><code id="magclip_+3A_sigma">sigma</code></td>
<td>

<p>The level of sigma clipping to be done. If set to default of 'auto' it will dynamically choose a sigma level to cut at based on the length of x (or the clipped version once iterations have started), i.e.: sigma=qnorm(1-2/length(x)). This have the effect of removing unlikely values based on the chance of them occurring, i.e. there is roughly a 50% chance of a 3.5 / 4.6 sigma Normal fluctuation occurring when you have 10,000 / 10,000,000 values, hence choosing this value dynamically is usually the best option.
</p>
</td></tr>
<tr><td><code id="magclip_+3A_clipiters">clipiters</code></td>
<td>

<p>The maximum number of sigma clipping iterations to attempt. It will break out sooner than this if the iterations have converged. The default of 5 is usually plenty (up to the contamination being towards the 50% level). The number of actual iterations is returns as <span class="option">clipiters</span>.
</p>
</td></tr>
<tr><td><code id="magclip_+3A_sigmasel">sigmasel</code></td>
<td>

<p>The quantile to use when trying to estimate the true standard-deviation of the Normal distribution. if contamination is low then the default of 1 is about optimal in terms of S/N, but you might need to make the value lower when contamination is very high.
</p>
</td></tr>
<tr><td><code id="magclip_+3A_estimate">estimate</code></td>
<td>

<p>Character; determines which side/s of the distribution are used to estimate Normal properties. The default is to use both sides (both) giving better S/N, but if you know that your contamination only comes from positive flux sources (e.g., astronomical data when trying to select sky pixels) then you should only use the lower side to determine Normal statistics (lo). Similarly if the contamination is on the low side then you should use the higher side to determine Normal statistics (hi).
</p>
</td></tr>
<tr><td><code id="magclip_+3A_extra">extra</code></td>
<td>

<p>Logical; if TRUE then <span class="option">clip</span> and <span class="option">range</span> are computed and returns, else these are set to NA to reduce computation and memory.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you know more sepcific details about your data then you should probably carry out a thorough likelihood analysis, but the ad-hoc clipping done in <code>magclip</code> works pretty well in practice.
</p>


<h3>Value</h3>

<p>A list containing three items:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Numeric vector; the cliped <span class="option">x</span> values.</p>
</td></tr>
<tr><td><code>clip</code></td>
<td>
<p>Locial; logic of which values were clipped with the same type and shape attributes as the input <span class="option">x</span> (i.e. if the original <span class="option">x</span> was a matrix then <span class="option">clip</span> would also be a matrix that matches element to element).</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>The data range of clipped <span class="option">x</span> values returned.</p>
</td></tr>
<tr><td><code>clipiters</code></td>
<td>
<p>The number of iterations made, which might be less than the input <span class="option">clipiters</span> since it might converge faster.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maghist">maghist</a></code>, <code><a href="#topic+magplot">magplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A highly contaminated Normal distribution:
temp=c(rnorm(1e3),runif(500,-10,10))
magplot(density(temp))
lines(seq(-5,5,len=1e3),dnorm(seq(-5,5,len=1e3)),col='red')

magplot(density(magclip(temp)$x))
lines(seq(-5,5,len=1e3),dnorm(seq(-5,5,len=1e3)),col='red')

#Now we put the contamination on the high side:

temp=c(rnorm(1e3),runif(500,0,10))
magplot(density(magclip(temp)$x))
lines(seq(-5,5,len=1e3),dnorm(seq(-5,5,len=1e3)),col='red')

#Setting estimate to 'lo' in this case should work better:

magplot(density(magclip(temp, estimate='lo')$x))
lines(seq(-5,5,len=1e3),dnorm(seq(-5,5,len=1e3)),col='red')
</code></pre>

<hr>
<h2 id='magcon'>
2D quantile images and contours
</h2><span id='topic+magcon'></span>

<h3>Description</h3>

<p>This function generates pretty images and contours that reflect the 2D quantile levels of the data. This means the user can immediately assess the 2D regime that contains an arbitrary percentage of the data. This function was designed particularly with the output of MCMC posteriors in mind, where visualising the location of the 68% and 95% 2D quantiles for covariant parameters is a necessary part of the post MCMC analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magcon(x, y, h, doim = TRUE, docon = TRUE, dobar = TRUE, ngrid = 100, add = FALSE,
  xlab = '', ylab = '', imcol = c(NA,rev(rainbow(1000, start = 0, end = 2/3))),
  conlevels = c(0.5, pnorm(1) - pnorm(-1), 0.95), barposition = "topright",
  barorient = "v",bartitle = "Contained %", bartitleshift = 0, xlim = NULL, ylim = NULL,
  weights = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magcon_+3A_x">x</code></td>
<td>

<p>x values to contour. If x is a two (or more) column matrix or data.frame and y is missing as an argument, then the first column is used for x and the second column for y.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_y">y</code></td>
<td>

<p>y values to contour.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_h">h</code></td>
<td>

<p>Smoothing parameter to pass to kde2d. Can take 1 or 2 arguments for x and optionally y smoothing.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_doim">doim</code></td>
<td>

<p>Should an image be generated.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_docon">docon</code></td>
<td>

<p>Should contours be overlain.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_dobar">dobar</code></td>
<td>

<p>Should a magbar colour bar be added describing the image levels (doim must also be true for this to appear).
</p>
</td></tr>
<tr><td><code id="magcon_+3A_ngrid">ngrid</code></td>
<td>

<p>The ngrid to send to kde2d / sm.density to determine the resolution of the smoothing.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_add">add</code></td>
<td>

<p>Should the output of this function be added to the current plot. If FALSE then a new plot is generated.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_xlab">xlab</code></td>
<td>

<p>Label for x-axis, only used if add=FALSE.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_ylab">ylab</code></td>
<td>

<p>Label for y-axis, only used if add=FALSE.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_imcol">imcol</code></td>
<td>

<p>The colour palette to use for the image (this is also sent to magbar).
</p>
</td></tr>
<tr><td><code id="magcon_+3A_conlevels">conlevels</code></td>
<td>

<p>Specific quantile contours to add. Default is for 50%, 68% and 95% contours, i.e. these contours contain that perecentage of the data.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_barposition">barposition</code></td>
<td>

<p>The position to use for magbar. See magbar help for more details.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_barorient">barorient</code></td>
<td>

<p>The orientation to use for magbar. See magbar help for more details.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_bartitle">bartitle</code></td>
<td>

<p>Title to use for magbar.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_bartitleshift">bartitleshift</code></td>
<td>

<p>Control of how far the magbar title is shifted away from its default position.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_xlim">xlim</code></td>
<td>

<p>The x limits to use for the data. Default of NULL calculates the range based on the provided x data vector. Data will be clipped between the extremes given. If xlim[1]&gt;xlim[2] plotted axes will be flipped compared to default.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_ylim">ylim</code></td>
<td>

<p>The y limits to use for the data. Default of NULL calculates the range based on the provided y data vector. Data will be clipped between the extremes given. If ylim[1]&gt;ylim[2] plotted axes will be flipped compared to default.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_weights">weights</code></td>
<td>

<p>A vector of weights to pass onto sm.density (that does the 2D density estimate). This must be the same length as the x and y vectors if specified.
</p>
</td></tr>
<tr><td><code id="magcon_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the <code><a href="graphics.html#topic+contour">contour</a></code> function, e.g. lty=c(2,1,3).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly designed to assess the output for MCMC posteriors since it highlights the confidence regimes quite clearly. More generally it can show the quantile distributions for any 2D data.
</p>


<h3>Value</h3>

<p>Called for the side effect of generating images and contours representing quantile in 2D data.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>, <code><a href="#topic+magbar">magbar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
temp = cbind(rnorm(1e3),rnorm(1e3))
magcon(temp[,1],temp[,2])

## End(Not run)
</code></pre>

<hr>
<h2 id='magcurve'>Draw Function Plots</h2><span id='topic+magcurve'></span>

<h3>Description</h3>

<p>Draws a curve corresponding to a function over the interval <code>[from, to]</code> using <code><a href="#topic+magplot">magplot</a></code>. <code>curve</code> can plot also an expression in the variable <code>xname</code>, default &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;. This is almost a direct port of <code><a href="graphics.html#topic+curve">curve</a></code>, with use of <code><a href="#topic+magplot">magplot</a></code> rather than <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magcurve(expr, from = NULL, to = NULL, n = 101, add = FALSE,
      type = "l", xname = "x", xlab = xname, ylab = NULL,
      log = NULL, xlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magcurve_+3A_expr">expr</code></td>
<td>
<p>The name of a function, or a <a href="base.html#topic+call">call</a> or an
<a href="base.html#topic+expression">expression</a> written as a function of <code>x</code> which will
evaluate to an object of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_x">x</code></td>
<td>
<p>a &lsquo;vectorizing&rsquo; numeric <span class="rlang"><b>R</b></span> function.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_from">from</code>, <code id="magcurve_+3A_to">to</code></td>
<td>
<p>the range over which the function will be plotted.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_n">n</code></td>
<td>
<p>integer; the number of x values at which to evaluate.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> add to an already existing plot; if
<code>NA</code> start a new plot taking the defaults for the limits and
log-scaling of the x-axis from the previous plot.  Taken as
<code>FALSE</code> (with a warning if a different value is supplied) if no
graphics device is open.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_xlim">xlim</code></td>
<td>
<p><code>NULL</code> or a numeric vector of length 2;
if non-<code>NULL</code> it provides the defaults for <code>c(from, to)</code>
and, unless <code>add = TRUE</code>, selects the x-limits of the plot &ndash; see
<code><a href="graphics.html#topic+plot.window">plot.window</a></code>.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_type">type</code></td>
<td>
<p>magplot type: see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_xname">xname</code></td>
<td>
<p>character string giving the name to be used for the x axis.</p>
</td></tr>
<tr><td><code id="magcurve_+3A_xlab">xlab</code>, <code id="magcurve_+3A_ylab">ylab</code>, <code id="magcurve_+3A_log">log</code>, <code id="magcurve_+3A_...">...</code></td>
<td>
<p>labels and <a href="graphics.html#topic+graphical+20parameters">graphical parameters</a>
can also be specified as arguments.  See &lsquo;Details&rsquo; for the
interpretation of the default for <code>log</code>.
</p>
<p>For the <code>"function"</code> method of <code>magplot</code>, <code>...</code> can
include any of the other arguments of <code>magcurve</code>, except
<code>expr</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function or expression <code>expr</code> (for <code>magcurve</code>) or function
<code>x</code> (for <code>magplot</code>) is evaluated at <code>n</code> points equally
spaced over the range <code>[from, to]</code>.  The points determined in
this way are then plotted.
</p>
<p>If either <code>from</code> or <code>to</code> is <code>NULL</code>, it defaults to the
corresponding element of <code>xlim</code> if that is not <code>NULL</code>.
</p>
<p>What happens when neither <code>from</code>/<code>to</code> nor <code>xlim</code>
specifies both x-limits is a complex story.  For
<code>magplot(&lt;function&gt;)</code> and for <code>magcurve(add = FALSE)</code> the defaults
are <code class="reqn">(0, 1)</code>.  For <code>magcurve(add = NA)</code> and <code>magcurve(add =
  TRUE)</code> the defaults are taken from the x-limits used for the previous
plot.  (This differs from versions of <span class="rlang"><b>R</b></span> prior to 2.14.0.)
</p>
<p>The value of <code>log</code> is used both to specify the plot axes (unless
<code>add = TRUE</code>) and how &lsquo;equally spaced&rsquo; is interpreted: if
the x component indicates log-scaling, the points at which the
expression or function is plotted are equally spaced on log scale.
</p>
<p>The default value of <code>log</code> is taken from the current plot when
<code>add = TRUE</code>, whereas if <code>add = NA</code> the x component is taken
from the existing plot (if any) and the y component defaults to
linear.  For <code>add = FALSE</code> the default is <code>""</code>
</p>
<p>This used to be a quick hack which now seems to serve a useful purpose,
but can give bad results for functions which are not smooth.
</p>
<p>For expensive-to-compute <code>expr</code>essions, you should use smarter tools.
</p>
<p>The way <code>magcurve</code> handles <code>expr</code> has caused confusion.  It
first looks to see if <code>expr</code> is a <a href="base.html#topic+name">name</a> (also known as a
symbol), in which case it is taken to be the name of a function, and
<code>expr</code> is replaced by a call to <code>expr</code> with a single
argument with name given by <code>xname</code>.  Otherwise it checks that
<code>expr</code> is either a <a href="base.html#topic+call">call</a> or an <a href="base.html#topic+expression">expression</a>, and that
it contains a reference to the variable given by <code>xname</code> (using
<code><a href="base.html#topic+all.vars">all.vars</a></code>): anything else is an error.  Then <code>expr</code>
is evaluated in an environment which supplies a vector of name given
by <code>xname</code> of length <code>n</code>, and should evaluate to an object
of length <code>n</code>.  Note that this means that <code>magcurve(x, ...)</code> is
taken as a request to plot a function named <code>x</code> (and it is used
as such in the <code>function</code> method for <code>magplot</code>).
</p>


<h3>Value</h3>

<p>A list with components <code>x</code> and <code>y</code> of the points that were 
drawn is returned invisibly.
</p>


<h3>Warning</h3>

<p>For historical reasons, <code>add</code> is allowed as an argument to the
<code>"function"</code> method of <code>plot</code>, but its behaviour may surprise
you.  It is recommended to use <code>add</code> only with <code>magcurve</code>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+curve">curve</a></code>, <code><a href="#topic+magplot">magplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>magcurve(sin, -2*pi, 2*pi, xname = "t")
magcurve(tan, xname = "t", add = NA,
      main = "magcurve(tan)  --&gt; same x-scale as previous plot")

op &lt;- par(mfrow = c(2, 2))
magcurve(x^3 - 3*x, -2, 2, ylab='y')
magcurve(x^2 - 2, add = TRUE, col = "violet")

## simple and advanced versions, quite similar:
magcurve(cos, xlim = c(-pi, 3*pi), n = 1001, col = "blue", add = TRUE)

chippy &lt;- function(x) sin(cos(x)*exp(-x/2))
magcurve(chippy, -8, 7, n = 2001)

for(ll in c("", "x", "y", "xy"))
   magcurve(log(1+x), 1, 100, log = ll,
         sub = paste("log= '", ll, "'", sep = ""))
par(op)
</code></pre>

<hr>
<h2 id='magcutout'>
Image Cutout Utility
</h2><span id='topic+magcutout'></span>

<h3>Description</h3>

<p>Function to subset raw images/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magcutout(image, loc = dim(image)/2, box = c(100, 100), shiftloc = FALSE, paddim = TRUE,
  padval = NA, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magcutout_+3A_image">image</code></td>
<td>

<p>Numeric matrix; required, the image we want to cutout. If <span class="option">image</span> is a path to an <code>fst</code> format file then the cutout can be done on disk directly.
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_loc">loc</code></td>
<td>

<p>Numeric vector; the [x,y] location where we want to cutout the image.
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_box">box</code></td>
<td>

<p>Numeric vector; the dimensions of the box to cut out from <span class="option">image</span> centred on <span class="option">loc</span>. For <code>magcutout</code> the <span class="option">box</span> unit is always pixels.
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_shiftloc">shiftloc</code></td>
<td>

<p>Logical; should the cutout centre shift from <span class="option">loc</span> away from the <span class="option">image</span> edge if the desired <span class="option">box</span> size extends beyond the edge of the <span class="option">image</span>?
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_paddim">paddim</code></td>
<td>

<p>Logical; should the cutout dimensions be padded with with value of <span class="option">padval</span> for data outside the <span class="option">image</span> boundary (TRUE)? If FALSE the dimensions will truncate when the edge of the input <span class="option">image</span> has been reached.
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_padval">padval</code></td>
<td>

<p>Numeric scalar; the value to use for padding if <span class="option">paddim</span>=TRUE.
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_plot">plot</code></td>
<td>

<p>Logical; should a <code><a href="#topic+magimage">magimage</a></code> plot of the output be generated?
</p>
</td></tr>
<tr><td><code id="magcutout_+3A_...">...</code></td>
<td>

<p>Dots are parsed to <code><a href="#topic+magimage">magimage</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is on a level trivial, since it is easy to subset matrices and therefore images within R. However <code>magcutout</code> tracks important properties of the subset region that makes it easy to track its location with respect to the original matrix/image. Also, it allows direct plotting of the resultant cutout with the most appropriate image functions. In many cases these functions will be used purely for their plotting side effects.
</p>
<p>The <span class="option">shiftloc</span> and <span class="option">paddim</span> control the behaviour of the function in the non-trivial case when the desired box size extendeds beyond the edge of the image. If <span class="option">shiftloc</span> is FALSE (the default behaviour), the cutout is guaranteed to be centred on the pixel specified by <span class="option">loc</span>. Then, if <span class="option">paddim</span> is FALSE, the cutout extends only as far as possible until it reaches the edge of the image; otherwise if <span class="option">paddim</span> is TRUE the cutout image is padded with NAs in regions outside the supplied <span class="option">image</span> (the default behaviour). If <span class="option">shiftloc</span> is TRUE, the centre of the cutout will be shifted. In this case, if <span class="option">paddim</span> is FALSE, the cutout will extend at most half of the supplied <span class="option">box</span> size from the given <span class="option">loc</span>; otherwise if <span class="option">paddim</span> is TRUE the cutout will be expanded until it reaches the desired <span class="option">box</span> size or spans the entire image.
</p>
<p>Note that if <span class="option">shiftloc</span> is TRUE and <span class="option">paddim</span> is FALSE, the cutout can be larger than <span class="option">box</span>; otherwise, the cutout is guaranteed to be no larger than the specified <span class="option">box</span> size.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>image</code></td>
<td>
<p>Numeric matrix; the cutout region of interst centred around <span class="option">loc</span>.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>The new <span class="option">loc</span> vector that tranforms the input <span class="option">loc</span> x and y location to the new <span class="option">cutim</span> coordinates. This is in ProFit coordinates, so these values can be used when, e.g., constructing a ProFit modellist structure.</p>
</td></tr>
<tr><td><code>loc.orig</code></td>
<td>
<p>The original location is provided by the input <span class="option">loc</span>.</p>
</td></tr>
<tr><td><code>loc.diff</code></td>
<td>
<p>The x and y offsets of the cutout compared to the original image, where <span class="option">loc</span> + <span class="option">loc.diff</span> = <span class="option">loc.orig</span> exactly.</p>
</td></tr>
<tr><td><code>xsel</code></td>
<td>
<p>Integer vector; the extracted x pixels from the original <span class="option">image</span> that form <span class="option">cutim</span>.</p>
</td></tr>
<tr><td><code>ysel</code></td>
<td>
<p>Integer vector; the extracted y pixels from the original <span class="option">image</span> that form <span class="option">cutim</span>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>By R convention the bottom-left part of the bottom-left pixel when plotting the image matrix is c(0,0) and the top-right part of the bottom-left pixel is c(1,1), i.e. the mid-point of pixels are half integer values in x and y. This differs to the FITS convention of pixel mid points being integer values. As such the R [x,y] = FITS [x-0.5,y-0.5]. This rarely matters too much in practice, but for accurate overlays you will want to get it right (see Examples).
</p>
<p>It is ambiguous what the desired outcome is in some cutting scenarios, e.g. what should be returned if a 3x3 cutout is requested at the &quot;centre&quot; of a 8x8 image? For this reason, and to avoid unexpected results due to numerical precision, you should only cut out even pixel dimensions if integer pixel coordinates are provided, and odd pixel dimensions if half-integer pixel coordinates are provided. Regardless, the <span class="option">loc</span> and <span class="option">loc.orig</span> outputs will always help you locate the absolute coordinates of your desired cut out centre in both the cut out and the original image coordinate system.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham &amp; Dan Taranu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp=matrix(1:121,11)

#The central value is at:

temp[6,6]

print(magcutout(temp, dim(temp)/2, box=c(3,3))$image)

#Given we cutout around the centre of the central pixel [5.5,5.5], the new centre
#relative to the cutout image output should be at [1.5,1.5]:

print(magcutout(temp, dim(temp)/2, box=c(3,3))$loc.orig)
print(magcutout(temp, dim(temp)/2, box=c(3,3))$loc)
</code></pre>

<hr>
<h2 id='magerr'>
Error bar plotting
</h2><span id='topic+magerr'></span>

<h3>Description</h3>

<p>A function to add x and y error bars to plots. Low and high error bars can be generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magerr(x, y, xlo, ylo, xhi = xlo, yhi = ylo, corxy, length = 0.02,
col = 'black', fill = FALSE, poly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magerr_+3A_x">x</code></td>
<td>

<p>Numeric vector; x location of data.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_y">y</code></td>
<td>

<p>Numeric vector; y location of data.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_xlo">xlo</code></td>
<td>

<p>Numeric vector; error on the low side for x values. This can be positive or negative- the absolute vaue is used. If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_ylo">ylo</code></td>
<td>

<p>Numeric vector; error on the low side for y values. This can be positive or negative- the absolute vaue is used. If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_xhi">xhi</code></td>
<td>

<p>Numeric vector; error on the high side for x values. This can be positive or negative- the absolute vaue is used. By default this will inherit the xlo value. If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_yhi">yhi</code></td>
<td>

<p>Numeric vector; error on the high side for y values. This can be positive or negative- the absolute vaue is used. By default this will inherit the ylo value. If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_corxy">corxy</code></td>
<td>

<p>Numeric vector; if this parameter exists then error ellipses will be drawn instead of error bars. It takes the value of the sigma_x sigma_y correlation, i.e. corxy=covxy/(xlo*ylo). If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_length">length</code></td>
<td>

<p>Numeric vector; length of error bar ends. If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_col">col</code></td>
<td>

<p>Either the colour of the error bars or the outline colour of the error ellipses.  If length 1, then will be repeated length(<span class="option">x</span>) times.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_fill">fill</code></td>
<td>

<p>Logical; if TRUE then the error ellipses will be filled, if FALSE then only the border will be drawn.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_poly">poly</code></td>
<td>

<p>Logical; is FALSE then error bars or ellipses will be drawn, if TRUE then approximate error polygon will be shown instead.
</p>
</td></tr>
<tr><td><code id="magerr_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to the <code><a href="graphics.html#topic+arrows">arrows</a></code> / <code><a href="plotrix.html#topic+draw.ellipse">draw.ellipse</a></code> / <code><a href="graphics.html#topic+polygon">polygon</a></code> functions used to draw the error bars / error ellipses (<span class="option">corxy</span> not missing) / error polygon (<span class="option">poly</span>=TRUE).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that with <span class="option">poly</span>=TRUE the x values are used igoring any error terms, and the point value y errors are used to define the limits of the polygon, with straight lines joining the points. The <span class="option">col</span> option is used to fill the polygon with a colour (so the default black is probably not a great choice). The <code><a href="graphics.html#topic+polygon">polygon</a></code> function takes the argument <span class="option">border</span> (parsed by dots from the <code>magerr</code> function) to colour the outer lines, so for a more subtle error polygon you might want to use <span class="option">col</span>=lightgrey, <span class="option">border</span>=NA, where NA means no outer border lines are drawn.
</p>


<h3>Value</h3>

<p>Called for the side effect of plotting error bars.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>, <code><a href="graphics.html#topic+arrows">arrows</a></code>, <code><a href="plotrix.html#topic+draw.ellipse">draw.ellipse</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic x and y errors added to plot
temp=cbind(x=runif(10),y=runif(10),xerr=runif(10,0.05,0.2),yerr=runif(10,0.1,0.3),
corxy=runif(10,-1,1))
magplot(temp[,1:2])
magerr(x=temp[,1],y=temp[,2],xlo=temp[,3],ylo=temp[,4])
# Example of errors on plots wityh log axes
magplot(temp[,1:2],log='xy')
magerr(x=temp[,1],y=temp[,2],xlo=temp[,3],ylo=temp[,4])

#Example of error ellipses

magplot(temp[,1:2])
magerr(x=temp[,1],y=temp[,2],xlo=temp[,3],ylo=temp[,4])
magerr(x=temp[,1],y=temp[,2],xlo=temp[,3],ylo=temp[,4],corxy=temp[,5])

</code></pre>

<hr>
<h2 id='maghist'>
Magically pretty histograms
</h2><span id='topic+maghist'></span>

<h3>Description</h3>

<p>A fairly simple function that produces pretty histograms. The main difference to base <code><a href="graphics.html#topic+hist">hist</a></code> is that it allows for easy truncation of the data provided via <span class="option">xlim</span> and useful logging options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maghist(x, breaks = "Sturges", freq = TRUE, include.lowest = TRUE, right = TRUE,
density = NULL, angle = 45, col = NULL, border = NULL, xlim = NULL, ylim = NULL,
plot = TRUE, verbose = TRUE, add = FALSE, log = '', unlog = log, scale = 1,
cumsum = FALSE, p.test = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maghist_+3A_x">x</code></td>
<td>

<p>A vector of values for which the histogram is desired.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_breaks">breaks</code></td>
<td>

<p>One of:
</p>

<ul>
<li><p> A vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p> A function to compute the vector of breakpoints,
</p>
</li>
<li><p> A single number giving the number of cells for the histogram,
</p>
</li>
<li><p> A character string naming an algorithm to compute the number of cells,
</p>
</li>
<li><p> A function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; the breakpoints will be set to <code><a href="base.html#topic+pretty">pretty</a></code> values. If breaks is a function, the x vector is supplied to it as the only argument.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_freq">freq</code></td>
<td>

<p>Logical; if TRUE, the histogram graphic is a representation of frequencies, the counts component of the result; if FALSE, probability densities, component density, are plotted (so that the histogram has a total area of one). Defaults to TRUE if and only if breaks are equidistant (and probability is not specified).
</p>
</td></tr>
<tr><td><code id="maghist_+3A_include.lowest">include.lowest</code></td>
<td>

<p>Logical; if TRUE, an x[i] equal to the breaks value will be included in the first (or last, for right = FALSE) bar. This will be ignored (with a warning) unless breaks is a vector.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_right">right</code></td>
<td>

<p>Logical; if TRUE, the histogram cells are right-closed (left open) intervals.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_density">density</code></td>
<td>

<p>The density of shading lines, in lines per inch. The default value of NULL means that no shading lines are drawn. Non-positive values of density also inhibit the drawing of shading lines.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_angle">angle</code></td>
<td>

<p>The slope of shading lines, given as an angle in degrees (counter-clockwise).
</p>
</td></tr>
<tr><td><code id="maghist_+3A_col">col</code></td>
<td>

<p>A colour to be used to fill the bars. The default of NULL yields unfilled bars.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_border">border</code></td>
<td>

<p>The color of the border around the bars. The default is to use the standard foreground color.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_xlim">xlim</code></td>
<td>

<p>Vector; range of <span class="option">x</span> values to use for both counting and plotting. The default NULL will span the range of histogram breaks. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code><a href="#topic+magclip">magclip</a></code>. If this is set to 'auto' then the limits will be estimated from the data dynamically. See examples.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_ylim">ylim</code></td>
<td>

<p>Vector; range of y limits to show in the histogram plot.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_plot">plot</code></td>
<td>

<p>Logical; draw the histogram (otherwise it just returns the count data).
</p>
</td></tr>
<tr><td><code id="maghist_+3A_verbose">verbose</code></td>
<td>

<p>Logical; if TRUE and <span class="option">xlim</span> is used then the followign is printed out: summary of the data selected, standard-deviation the 1/2-sigma implied quantiles, and number and fraction of displayed data. Note all numbers are computed for the logged values of the <span class="option">x</span> input if <span class="option">log</span>= x | xy | yx.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_add">add</code></td>
<td>

<p>Logical, if TRUE the histogram will be added to the current plot. Be careful to match <span class="option">log</span> properties if adding, else the comparison will be of little use and hard to interpret.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_log">log</code></td>
<td>

<p>Log axis arguments to be passed to hist and plot. E.g. use 'x', 'y', 'xy' or 'yx' as appropriate. Default &rdquo; assumes no logging of any axes. If the x axis is logged then the histogram will be calculated in log-space.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_unlog">unlog</code></td>
<td>

<p>Determines if axis labels should be unlogged. E.g. use 'x', 'y', 'xy' or 'yx' as appropriate. See <code><a href="#topic+magaxis">magaxis</a></code>.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_scale">scale</code></td>
<td>

<p>Numeric scalar; an additional scaling parameter to apply to the frequnecy counts. This is useful if you want to get the y axis in to certain units, e.g. the counts represent objects in 10 square degrees of sky, so to get the y-axis into units of N/sq.deg you would set <span class="option">scale</span>=1/10.  
</p>
</td></tr>
<tr><td><code id="maghist_+3A_cumsum">cumsum</code></td>
<td>

<p>Logical; if FALSE (default) then <span class="option">counts</span> and <span class="option">density</span> are totals for the current bin (usual sense of a histogram), if TRUE then <span class="option">counts</span> and <span class="option">density</span> are cumulative totals of all counts up to and including the current bin (always from lowest <span class="option">x</span> upwards).
</p>
</td></tr>
<tr><td><code id="maghist_+3A_p.test">p.test</code></td>
<td>

<p>Function; optionally the user can provide a standard (or custom) p-test to be computed on the display (i.e. trimmed) data. This might be e.g. a Normality test with the <code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> function etc. The results are printed to screen below the other standard summary information if <span class="option">verbose</span>=TRUE.
</p>
</td></tr>
<tr><td><code id="maghist_+3A_...">...</code></td>
<td>

<p>Arguments to be parsed to <code><a href="#topic+magplot">magplot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To better replicate the base <code><a href="graphics.html#topic+hist">hist</a></code> plot you might consider setting <span class="option">frame.plot</span>=FALSE, which will be parsed to <code><a href="#topic+magplot">magplot</a></code> and turn off the outer box. The default behaviour might change in the future.
</p>


<h3>Value</h3>

<p>An object of class &quot;histogram&quot;, basically the same output as produced by <code><a href="graphics.html#topic+hist">hist</a></code>. Note where axes are logged, the corresponding hist list values will not be logged when returned. This is to make it easy to take a histogram object and plot it with different log scalings on the axes (see Examples). For the x axis this means the &quot;breaks&quot; and the &quot;mids&quot; items, and for the y axis this means the &quot;counts&quot; and the &quot;density&quot; items.
</p>
<p>Appended to the end of the usual <code><a href="graphics.html#topic+hist">hist</a></code> output are the summary of the sample (list element &quot;summary&quot;) and the standard-deviation / 1 and 2-sigma quantile range (list element &quot;ranges&quot;).
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maghist(rnorm(1e4))
maghist(rnorm(1e4), xlim=c(-2,4))

#Notice the x-limits are close to -3/3, since  if we ask for xlim=3 (a 3-sigma range)

maghist(rnorm(1e4), xlim=3, verbose = FALSE)

#The 'auto' option allows magclip to dynamically estimate a clip value (which is similar
#in this case, but need not be in general).

maghist(rnorm(1e4), xlim='auto', verbose = FALSE)

#Test of log histograms:

testdata=10^(runif(1e3,0,4))
maghist(testdata)
maghist(testdata,log='x')
maghist(testdata,log='y')
maghist(testdata,log='xy')

maghist(testdata,freq=FALSE)
maghist(testdata,freq=FALSE,log='x')
maghist(testdata,freq=FALSE,log='y')
maghist(testdata,freq=FALSE,log='xy')

#Test of plotting histogram objects:

testhist=maghist(testdata,log='xy')
maghist(testhist)
maghist(testhist,log='x')
magplot(testhist,log='y')
magplot(testhist,log='xy')

#Nice to see a grid with large ranges:

maghist(rnorm(1e6), grid=TRUE)
maghist(rnorm(1e6), log='y', grid=TRUE)
</code></pre>

<hr>
<h2 id='magimage'>
Magically pretty images
</h2><span id='topic+magimage'></span><span id='topic+magimageRGB'></span>

<h3>Description</h3>

<p><code>magimage</code> is a level replacement for base image with hooks into magaxis for the tick marks and magmap for the image scaling. The default behavious is a bit different to base (e.g. x/y scales are automatically the number of pixels in the image matrix). <code>magimageRGB</code> is similar, but is for the creation colour images where the user can provide R G B input matrix chanels (or similar).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magimage(x, y, z, zlim, xlim, ylim, col = grey((0:1000)/1000), add = FALSE,
  useRaster = TRUE, asp = 1, magmap = TRUE, locut = 0.4, hicut = 0.995, flip = FALSE,
  range = c(0, 1), type = "quan", stretch = "asinh", stretchscale = 'auto', bad = NA,
  clip = "", axes = TRUE, frame.plot = TRUE, sparse = 'auto', qdiff = FALSE,
  rem_med = FALSE, doplot = TRUE, ...)

magimageRGB(x, y, R, G, B, saturation = 1, zlim, xlim, ylim, add = FALSE,
  useRaster = TRUE, asp = 1, magmap = TRUE, locut = 0.4, hicut = 0.995, flip = FALSE,
  range = c(0, 1), type = "quan", stretch = "asinh", stretchscale = "auto",
  bad = range[1], clip = "", axes = TRUE, frame.plot = TRUE, sparse = 'auto', ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magimage_+3A_x">x</code>, <code id="magimage_+3A_y">y</code></td>
<td>

<p>Locations of grid lines at which the values in z are measured. These must be finite and non-missing (order may be reversed). By default, equally spaced values from 0 to dim(z)[1] are used. If x is a list, its components x$x and x$y are used for x and y, respectively. If the list has component z/R/G/B this is used for z/R/G/B.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_z">z</code></td>
<td>

<p>A numeric or logical matrix containing the values to be plotted (NAs are allowed). Note that x can be used instead of z for convenience.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_r">R</code></td>
<td>

<p>A numeric or logical matrix containing the red colour values to be plotted (NAs are allowed). Note that <span class="option">x</span> can be a 3D array or list (containing elements R/G/B) instead of R for convenience, where R=x[,,1].
</p>
</td></tr>
<tr><td><code id="magimage_+3A_g">G</code></td>
<td>

<p>A numeric or logical matrix containing the green colour values to be plotted (NAs are allowed).  Note that <span class="option">x</span> can be a 3D array or list (containing elements R/G/B) instead of G for convenience, where G=x[,,2].
</p>
</td></tr>
<tr><td><code id="magimage_+3A_b">B</code></td>
<td>

<p>A numeric or logical matrix containing the blue colour values to be plotted (NAs are allowed).  Note that <span class="option">x</span> can be a 3D array or list (containing elements R/G/B) instead of B for convenience, where B=x[,,3].
</p>
</td></tr>
<tr><td><code id="magimage_+3A_saturation">saturation</code></td>
<td>

<p>The visual saturation of the colours, a bit like the dial on a TV. 1 is native, 0 is black and white, 2 is very intense nigh-on trippy.   
</p>
</td></tr>
<tr><td><code id="magimage_+3A_zlim">zlim</code></td>
<td>

<p>The z limit with respect to the output of magmap$map. If <span class="option">magmap</span>=FALSE (default) <span class="option">zlim</span> should be with respect to the provided z matrix (like base <code>image</code>). If <span class="option">magmap</span>=TRUE <span class="option">zlim</span> should be with respect to the <span class="option">range</span> output of <code>magmap</code>. By default the <code>magmap</code> function scales between 0 and 1, so to only show the brighter pixels <span class="option">zlim</span> could be set to c(0.5,1).
</p>
</td></tr>
<tr><td><code id="magimage_+3A_xlim">xlim</code>, <code id="magimage_+3A_ylim">ylim</code></td>
<td>

<p>Ranges for the plotted x and y values, defaulting to the ranges of x and y.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_col">col</code></td>
<td>

<p>A list of colours for the <code>magmap</code> re-mapping of z to be parsed into (e.g. <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>, <code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> or similar).
</p>
</td></tr>
<tr><td><code id="magimage_+3A_add">add</code></td>
<td>

<p>If true add the new image to the current plot.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_useraster">useRaster</code></td>
<td>

<p>If TRUE a bitmap raster is used to plot the image instead of polygons. The grid must be regular in that case, otherwise an error is raised. Raster is much faster, so use when pixels are equal sized.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_asp">asp</code></td>
<td>

<p>The y/x aspect ratio
</p>
</td></tr>
<tr><td><code id="magimage_+3A_magmap">magmap</code></td>
<td>

<p>If TRUE then <code><a href="#topic+magmap">magmap</a></code> scaling is applied to the z dimension (default), if FALSE then it is not.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_locut">locut</code></td>
<td>

<p>The low limit to clip the z data at (what this means varies depending on the 'type' option). For <code>magimageRGB</code> this can be a single value (used for <span class="option">R</span>, <span class="option">G</span> and <span class="option">B</span>) or a vector of length 3 (used for <span class="option">R</span>, <span class="option">G</span> and <span class="option">B</span> respectively). See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_hicut">hicut</code></td>
<td>

<p>The high limit to clip the z data at (what this means varies depending on the 'type' option). For <code>magimageRGB</code> this can be a single value (used for <span class="option">R</span>, <span class="option">G</span> and <span class="option">B</span>) or a vector of length 3 (used for <span class="option">R</span>, <span class="option">G</span> and <span class="option">B</span> respectively). See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_flip">flip</code></td>
<td>

<p>Should the z scaling be flipped. This allows numbers from 0 to 10 to be mapped from 1 to 0 (so ordered back to front with respect to the input). See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_range">range</code></td>
<td>

<p>The numerical range of the output z mapping which should be a vector of length two specifying c(low,high). See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_type">type</code></td>
<td>

<p>The type of z mapping attempted. Options are 'quan' (default), 'num', 'sig' and 'rank'. See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_stretch">stretch</code></td>
<td>

<p>stretch='lin' gives linear mapping. stretch='log' gives logarithmic mapping. stretch='atan' gives atan mapping. stretch='asinh' gives asinh mapping. stretch='sqrt' gives sqrt mapping. See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_stretchscale">stretchscale</code></td>
<td>

<p>A number to multiply the z data by before applying the stretch. This only has a user impact for stretch='atan' and stretch='asinh' since it controls what parts of the data is in the linear or logarithmic regime of the stretch procedure. If set to 'auto' (the default) it uses 1/median(abs(data)) to find a useful scale.See <code><a href="#topic+magmap">magmap</a></code> for more information. For <code>magimageRGB</code> this can be a single value (used for <span class="option">R</span>, <span class="option">G</span> and <span class="option">B</span>) or a vector of length 3 (used for <span class="option">R</span>, <span class="option">G</span> and <span class="option">B</span> respectively). See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_bad">bad</code></td>
<td>

<p>Sets the value that NA, NaN and infinite input z data should be set to in the final map output. This should be thought of in the context of the range argument, i.e. if bad=range[1] then bad values will be the low range value and if bad=range[2] bad values will be the high range value. See <code><a href="#topic+magmap">magmap</a></code> for more information. For <code>magimageRGB</code> bad is set to range[1] by default since this removes RGB conversion errors that would be experiences with NA values (i.e. negative values when <span class="option">stretch</span>='log').
</p>
</td></tr>
<tr><td><code id="magimage_+3A_clip">clip</code></td>
<td>

<p>By default clipped z values inherit the nearest lo/hi value (depending on which side they are clipped). Setting clip='NA' will set values outside the 'lo' and 'hi' values to be NA (currently this is the only other clip option). See <code><a href="#topic+magmap">magmap</a></code> for more information.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_axes">axes</code></td>
<td>

<p>Specify if any axes be drawn on the image. If FALSE then only the pixels (with appropriate <code>magmap</code> scaling) are shown.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Specify if a box be drawn around the image frame. Only happens if <span class="option">add</span>=TRUE and <span class="option">axes</span>=TRUE.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_sparse">sparse</code></td>
<td>

<p>Determines whether the image pixels are sparse sampled to speed up plotting. If set to 2 it will only determine every 2nd pixel, and if 3 every 3rd etc. The default 'auto' means it will scale to produce a maximum number of 1,000 pixels on any side (on most monitors this is a fairly useful maximum, and ensures quick displaying of even very large images).
</p>
</td></tr>
<tr><td><code id="magimage_+3A_qdiff">qdiff</code></td>
<td>

<p>Logical; if the z axis being plotted, this will set all the various parameters that make for a visually useful difference plot, where -ve difference values become blue, 0 difference values are yellow, and +ve difference values are red.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_rem_med">rem_med</code></td>
<td>

<p>Logical; should the <code>median</code> of the <span class="option">image</span> be subtracted or not? This is often useful in conjunction with <span class="option">qdiff</span> = TRUE.
</p>
</td></tr>
<tr><td><code id="magimage_+3A_doplot">doplot</code></td>
<td>

<p>Logical; if TRUE then gnerates the image. If FALSE then just return the output below (with z scaled as request).  
</p>
</td></tr>
<tr><td><code id="magimage_+3A_...">...</code></td>
<td>

<p>Arguments to be parsed to <code>image</code> and <code>magaxis</code> as relevant (this is checked for internally by argument name). See <code><a href="Matrix.html#topic+image">image</a></code> and <code><a href="#topic+magaxis">magaxis</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="#topic+magmap">magmap</a></code> and <code><a href="#topic+magaxis">magaxis</a></code> for more details.
</p>


<h3>Value</h3>

<p>Outputs the final image list containing x,y and z (magimage) or R/G/B (magimageRGB). z is the scaled output (not the native input). Generally run for the side effect of producing rapid and well-scaled image plots.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="#topic+magcutout">magcutout</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Basic
magimage(matrix(1:9,3))

#Mid pixel versus pixel edge:
magimage(3:0,1:3,matrix(1:9,3))

#Standard scaling is not very useful in this instance:
magimage(matrix(10^(1:9),3))
#Linear scaling is not very useful in this instance, though it does now map from [0,1]:
magimage(matrix(10^(1:9),3),magmap=TRUE,zlim=c(0,0.5))
#Log scaling with magmap makes it much clearer:
magimage(matrix(10^(1:9),3),magmap=TRUE,stretch='log')
#And it's easy just to show the lowest half now:
magimage(matrix(10^(1:9),3),magmap=TRUE,stretch='log',zlim=c(0,0.5))

## Not run: 
#Some astro data:
library(Rfits)
image = Rfits_read_image(system.file("extdata", 'image.fits', package = "Rfits"))

#A monotone image:
magimage(image$imDat)
#A faked colour image (this won't look great):
magimageRGB(R=image$imDat^3, G=image$imDat^1.5, B=image$imDat^2)

## End(Not run)
</code></pre>

<hr>
<h2 id='maglab'>
Pretty scientific labelling
</h2><span id='topic+maglab'></span>

<h3>Description</h3>

<p>Utilises pretty for the major-tick locations, but makes prettier decisions if log axes are being used. Translates the default text into nicely formatted expressions- this is particularly successful when axes are logged and exponents are used since formats like 1e5 should not be used in scientific academic journals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maglab(lims, n, log=FALSE, exptext = TRUE, crunch = TRUE, logpretty = TRUE,
usemultloc = FALSE, multloc = c(1,2,5), prettybase = 10, powbase = 10, hersh = FALSE,
trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maglab_+3A_lims">lims</code></td>
<td>
	
<p>Limits over which pretty major-tick locations will be calculated.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_n">n</code></td>
<td>

<p>The target number of major-axis sub-divisions. Will not necessarily be achieved.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_log">log</code></td>
<td>

<p>Should the limits be evenly distributed over log space. Usually what you want if an axis has been logged.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_exptext">exptext</code></td>
<td>

<p>Should log==TRUE then should the text be written in exponent form (e.g. 10^8, default when exptext==TRUE) or logged (e.g. 8 in this case).
</p>
</td></tr>
<tr><td><code id="maglab_+3A_crunch">crunch</code></td>
<td>

<p>In cases where the scientific text would be written as 1x10^8, should the 1x be removed so it reads 10^8. TRUE by default.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_logpretty">logpretty</code></td>
<td>

<p>Should the major-ticks only be located at powers of 10, or when dynamic range is small (less than 50) powers of 10 times 1, 2 and 5. This changes cases where ticks are placed at 1, 3.1, 10, 31, 100 etc to 1, 10, 100.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_usemultloc">usemultloc</code></td>
<td>

<p>For log=TRUE, if usemultloc=FALSE then label locations are only at powers of 10, if usemultloc=TRUE then they are at multiples of powers of 10 as defined by multloc.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_multloc">multloc</code></td>
<td>

<p>If usemultloc is TRUE then multloc provides the multiples of powers of 10 for the location of labels. Default will give them at 0.1, 0.2, 0.5, 1 etc.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_prettybase">prettybase</code></td>
<td>

<p>The unit of repitition desired. By default it is 10, implying a pretty plot is one with marks at 10, 20, 30 etc. If you are plotting degrees then it might be prettier to display 90, 180, 270 etc. In which case prettybase should be set to 90. If log=TRUE then the reference location of 10 is changed, so in the previous example the labels generated would be at 9, 90, 900 etc rather than the deafult of 1, 10, 100 etc.
</p>
</td></tr>
<tr><td><code id="maglab_+3A_powbase">powbase</code></td>
<td>

<p>Set the base to use for logarithmic axes. Default is to use 10.   
</p>
</td></tr>
<tr><td><code id="maglab_+3A_hersh">hersh</code></td>
<td>

<p>Determines whether the text format output by maglab should be Hershey vector font compatable text (TRUE), or normal plotmath style expressions (FALSE).
</p>
</td></tr>
<tr><td><code id="maglab_+3A_trim">trim</code></td>
<td>

<p>If trim is TRUE the outputs are not allowed to exceed the stated limits, if FALSE then the whole range of pretty values calculated are used. This will usually extend beyond the limits to ensure the plots look pretty, but if maglab is being used for something other than plotting axis labels then trimmed values might be useful.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a mid level routine for producing nice ticks and text, with particularly effort on improving the outcome of logged axis cases. The end user will probably not require axis to it except in unusual circumstances. I note that my method of translating the default representation of the exponents is not very elegant, so any suggestions for improvement are welcome!
</p>


<h3>Value</h3>

<table>
<tr><td><code>tickat</code></td>
<td>

<p>Location of proposed major-tick marks.
</p>
</td></tr>
<tr><td><code>labat</code></td>
<td>

<p>Location of proposed label locations (not necessarily the same as major-tick locations).
</p>
</td></tr>
<tr><td><code>exp</code></td>
<td>

<p>Expressions to be used at label locations.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+magerr">magerr</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=10^{1:9}
y=1:9
plot(log10(x),y,axes=FALSE)
ticks=maglab(range(x),log=TRUE)
print(ticks)
axis(1,at=log10(ticks$labat),labels=ticks$exp)

# Same outcome a different way:

plot(x,y,axes=FALSE,log='x')
ticks=maglab(range(x),log=TRUE)
print(ticks)
axis(1,at=ticks$labat,labels=ticks$exp)

# For small dynamic range

x=seq(1,40,len=9)
y=1:9
plot(x,y,axes=FALSE,log='x')
ticks=maglab(range(x),log=TRUE,usemultloc=TRUE)
axis(1,at=ticks$labat,labels=ticks$exp,tick=FALSE)
axis(1,at=ticks$tickat,labels=FALSE)

# Different base prettiness

x=0:270
y=sin(x*pi/180)
plot(x,y,axes=FALSE,type='l')
ticks=maglab(range(x))
axis(1,at=ticks$labat,labels=ticks$exp)
# Not very pretty for degree plotting
ticks=maglab(range(x),prettybase=45)
axis(3,at=ticks$labat,labels=ticks$exp)
# Much nicer!

</code></pre>

<hr>
<h2 id='magmap'>
Value remapper
</h2><span id='topic+magmap'></span>

<h3>Description</h3>

<p>This function allows the use to remap a vector of values onto a different system. For instance you might have values stretching from -10 to 100 which you want mapped from 0 to 2/3 so you can then sue the output as an input for point colour or size. It allows clipping of values, rejection of bad values, and log stretching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magmap(data, locut = 0, hicut = 1, flip = FALSE, range = c(0, 2/3), type = "quan",
stretch = 'lin', stretchscale = 1, bad = NA, clip = '')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magmap_+3A_data">data</code></td>
<td>

<p>A vector of values. This can contain bad values (NA, NaN, infinite), but these will be ignored during mapping and set to the value of input parameter 'bad'.
</p>
</td></tr>
<tr><td><code id="magmap_+3A_locut">locut</code></td>
<td>

<p>The low limit to clip the data at (what this means varies depending on the 'type' option). This should be a single value.
</p>
</td></tr>
<tr><td><code id="magmap_+3A_hicut">hicut</code></td>
<td>

<p>The high limit to clip the data at (what this means varies depending on the 'type' option). This should be a single value.
</p>
</td></tr>
<tr><td><code id="magmap_+3A_flip">flip</code></td>
<td>

<p>Should the scaling be flipped. This allows numbers from 0 to 10 to be mapped from 1 to 0 (so ordered back to front with respect to the input).
</p>
</td></tr>
<tr><td><code id="magmap_+3A_range">range</code></td>
<td>

<p>The numerical range of the output mapping which should be a vector of length two specifying c(low,high).
</p>
</td></tr>
<tr><td><code id="magmap_+3A_type">type</code></td>
<td>

<p>The type of mapping attempted. Options are 'quan' (default), 'num', 'sig' and 'rank'.
</p>
</td></tr>
<tr><td><code id="magmap_+3A_stretch">stretch</code></td>
<td>

<p><span class="option">stretch</span>='lin'  gives linear mapping. <span class="option">stretch</span>='log' gives logarithmic mapping. <span class="option">stretch</span>='atan' gives atan mapping. <span class="option">stretch</span>='asinh' gives asinh mapping. <span class="option">stretch</span>='sqrt' gives sqrt mapping. <span class="option">stretch</span>='cdf' gives CDF mapping onto the cumulative range 0-1
</p>
</td></tr>
<tr><td><code id="magmap_+3A_stretchscale">stretchscale</code></td>
<td>

<p>A number to multiply the data by before applying the stretch. This only has a user impact for stretch='atan' and stretch='asinh' since it controls what parts of the data is in the linear or logarithmic regime of the stretch procedure. If set to 'auto' it uses 1/median(abs(data)) to find a useful scale.
</p>
</td></tr>
<tr><td><code id="magmap_+3A_bad">bad</code></td>
<td>

<p>Sets the value that NA, NaN and infinite input data should be set to in the final map output. This should be thought of in the context of the range argument, i.e. if bad=range[1] then bad values will be the low range value and if bad=range[2] bad values will be the high range value.
</p>
</td></tr>
<tr><td><code id="magmap_+3A_clip">clip</code></td>
<td>

<p>By default clipped values inherit the nearest lo/hi value (depending on which side they are clipped). Setting clip='NA' will set values outside the 'lo' and 'hi' values to be NA (currently this is the only other clip option).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="option">type</span>='quan' means the <span class="option">lo</span> and <span class="option">hi</span> options are interpreted as the quantile limits to clip the data at (so lo=0.05 and hi 0.95 would clip the data at the 5% and 95% quantile limits and scale values between these). <span class="option">type</span>='num' interprets <span class="option">lo</span> and <span class="option">hi</span> as the exact values to clip the data at and scale between. <span class="option">type</span>='sig' treats <span class="option">lo</span> and <span class="option">hi</span> as the sigma offsets in a Normal distribution, with the probabilities at these positions used to clip and scale that data (so <span class="option">lo</span>=-1 and <span class="option">hi</span>=1 is interpretted as +/- 1 sigma, so the data is clipped and scaled at the 16% and 84% levels, i.e. the 1 sigma range). <span class="option">type</span>='rank' means the data mapping is done by rank value only, with <span class="option">lo</span> and <span class="option">hi</span> specifying the quantile limits used to clip and scale the ranks. In all cases lo and hi clipped values are set to the relevant extreme values of 'range'.
</p>
<p>If range is between 1 and 100 and stretch='lin' the midpoint in the mapping will be 50.5. If stretch='log' the midpoint becomes 10. This enhances the local dynamic range of the mapping for data that has a logarithmic distribution.
</p>


<h3>Value</h3>

<table>
<tr><td><code>map</code></td>
<td>

<p>The remapped data. This is the same length and order as the input data.
</p>
</td></tr>
<tr><td><code>datalim</code></td>
<td>

<p>The a vector of the low and high limits actually applied to the data. Unless type='num' this will probably be different to the lo and hi arguments provided.
</p>
</td></tr>
<tr><td><code>maplim</code></td>
<td>

<p>The output range (same is the requested input range, but included for book-keeping).
</p>
</td></tr>
<tr><td><code>loclip</code></td>
<td>

<p>The fraction of objects clipped from the input data at the low end.
</p>
</td></tr>
<tr><td><code>hiclip</code></td>
<td>

<p>The fraction of objects clipped from the input data at the high end.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magimage">magimage</a></code>, <code><a href="#topic+magbar">magbar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(650)
temp=cbind(runif(100),runif(100))
temp=cbind(temp,sqrt(temp[,1]^2+temp[,2]^2))
magplot(temp)
magplot(temp[,1:2],col=hsv(h=magmap(temp[,3])$map))

# A different mapping type:
magplot(temp[,1:2],col=hsv(h=magmap(temp[,3],type='rank')$map))

# Flipped:
magplot(temp[,1:2],col=hsv(h=magmap(temp[,3],flip=TRUE,type='rank')$map))

# Example of linear/log/atan/asinh mapping:
temp=cbind(temp,10^temp[,3])
magplot(temp[,1:2],col=hsv(h=magmap(temp[,4])$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,4],stretch='log')$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,4],stretch='atan')$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,4],stretch='asinh')$map))

#atan and asinh can be useful when data spans negative to positive:
temp=cbind(temp,temp[,4]-10)
magplot(temp[,1:2],col=hsv(h=magmap(temp[,5],stretch='atan')$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,5],stretch='asinh')$map))
#effect of stretchscale
magplot(temp[,1:2],col=hsv(h=magmap(temp[,5],stretch='atan',stretchscale=0.5)$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,5],stretch='atan',stretchscale=2)$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,5],stretch='asinh',stretchscale=0.5)$map))
magplot(temp[,1:2],col=hsv(h=magmap(temp[,5],stretch='asinh',stretchscale=2)$map))

#Using multiple mappings for plots:
magplot(temp[,1:2],col=hsv(h=magmap(temp[,4],stretch='log')$map),
cex=magmap(temp[,3],lo=0.5,hi=1,range=c(1,6),type='num')$map)

#Different combinations of mapping options:
magmap(c(-1,0.1,1,NA,0.3,3),lo=0,hi=2.5,type='num',stretch='lin',bad=0.5)$map
magmap(c(-1,0.1,1,NA,0.3,3),lo=0.1,hi=0.9,type='quan',stretch='log',bad=0.8)$map
magmap(c(-1,0.1,1,NA,0.3,3),lo=-1,hi=1,type='sig',stretch='asinh',bad=0,stretchscale=2)$map
magmap(c(-1,0.1,1,NA,0.3,3),type='rank',stretch='atan',bad=NA,stretchscale=2)$map

#Example showing using asinh to generate a different axis mapping:
datastretch=cbind(runif(1e3),10^runif(1e3,0,4)-10^runif(1e3,0,4))
#This isn't a very helpful view of the data
magplot(datastretch[,1:2])
#This only shows the positive half of the data:
magplot(datastretch[,1:2],log='y')
#We can do a better job by remapping using the asinh option in magmap:
datastretch=cbind(datastretch,magmap(datastretch[,2],lo=-1e4,hi=1e4,range=c(0,1),
type='num',stretch='asinh')$map)
asinhticks=magmap(c(-10^(4:0),0,10^(0:4)),lo=-1e4,hi=1e4,range=c(0,1),type='num',
stretch='asinh')$map
magplot(datastretch[,1],datastretch[,3],side=1)
axis(2,asinhticks,labels=c(-10^(4:0),0,10^(0:4)))
abline(h=magmap(0,lo=-1e4,hi=1e4,range=c(0,1),type='num',stretch='asinh')$map)

</code></pre>

<hr>
<h2 id='magplot'>
Magically pretty plots
</h2><span id='topic+magplot'></span>

<h3>Description</h3>

<p>Makes scientific plots based on magaxis axes. Particularly designed for log plotting. Utilises base plot for the most part, but the axis drawing is replaced by a call to the magaxis fuction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magplot(x, y, z = NULL, log = "", main = "", side = 1:2, majorn = 5, minorn = 'auto',
  tcl = 0.5, ratio = 0.5, labels = TRUE, unlog = "auto", mgp = c(2,0.5,0), mtline = 2,
  xlab = '', ylab = '', crunch = TRUE, logpretty = TRUE, prettybase = 10, powbase = 10,
  hersh = FALSE, family = "sans", frame.plot = TRUE, usepar = FALSE, grid = TRUE,
  grid.col = 'grey90', grid.lty = 1, grid.lwd = 1, xlim = NULL, ylim = NULL, lwd = 1,
  axis.lwd = 1, ticks.lwd = axis.lwd, axis.col = 'black', zcol = hcl.colors(21),
  zstretch = 'lin', dobar = TRUE,  ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magplot_+3A_x">x</code></td>
<td>
	
<p>The x coordinates of points/lines in the plot. Alternatively, a single plotting structure, function or any R object with a plot method can be provided.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_y">y</code></td>
<td>

<p>The y coordinates of points/lines in the plot, optional if x is an appropriate structure.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_z">z</code></td>
<td>

<p>The z coordinates for colour scaling of points in the plot. This will be passed through <code><a href="#topic+magmap">magmap</a></code>, with dots passed as relevant.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_log">log</code></td>
<td>

<p>Log axis arguments to be passed to plot. E.g. use 'x', 'y', 'xy' or 'yx' as appropriate. Default &rdquo; assumes no logging of any axes.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_main">main</code></td>
<td>

<p>Title for the plot. Default is no title.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_side">side</code></td>
<td>

<p>The side to be used for axis labelling in the same sense as the base axis function (1=bottom, 2=left, 3=top, 4=right). A vector of multiple entries is allowed. By default, bottom and left axes are drawn (i.e. side 1 and 2). If <span class="option">side</span>=FALSE then no sides or labels will be drawn.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_majorn">majorn</code></td>
<td>

<p>The target number of major-axis sub-divisions for pretty plotting. If length is 1 and length of side is longer than this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. Obvious reason for varying this is different pretty labelling between a and y axes.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_minorn">minorn</code></td>
<td>

<p>The exact number of minor-axis divisions (i.e. desired minor ticks + 1) to display in plotting. Auto will produce <code><a href="base.html#topic+pretty">pretty</a></code> ticks for linear scaling, and powbase-2 minor ticks for logged (this might seem odd, but for base 10 this means ticks at 2/3/4/5/6/7/8/9, which is probably as desired). If set manually, must be greater than 1 to have a visible effect. Minor ticks are always calculated to be equally spaced in linear space, so tick spaces vary when using log plotting. If length is 1 and length of side is longer than this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. An obvious reason for varying this is different pretty labelling between x and y axes.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_tcl">tcl</code></td>
<td>

<p>The length of major tick marks as a fraction of the height of a line of text. By default these face into the plot (in common with scientific plotting) with a value of 0.5, rather than the R default of -0.5. It is possible to force magaxis to inherit directly from par by setting usepar=TRUE (see below). See <code><a href="graphics.html#topic+par">par</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_ratio">ratio</code></td>
<td>

<p>Ratio of minor to major tick mark lengths.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_labels">labels</code></td>
<td>

<p>Specifies whether major-axis ticks should be labelled for each axis. If length is 1 and length of side is longer than this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. Default is to label all axes.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_unlog">unlog</code></td>
<td>

<p>Determines if axis labels should be unlogged. If axis is found to be logged in par('usr') then the minor ticks are automatically log spaced, however &quot;unlog&quot; still controls how the labelling is done: either logged form (FALSE) or exponent form (TRUE). If axis has been explicitly logged (e.g. log10(x)) then this will can produce exponential axis marking/labelling if set to TRUE. This case will also produce log minor tick marks. If length of unlog is 1 and length of side is longer than 1 then the assigned unlog value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. Can also take the text argument 'x', 'y', 'xy' or 'yx', where these refer to which axes have been logged. If left at the default of &lsquo;auto&rsquo; then unlog is assumed to be true when the axis in question is logged, and false otherwise.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_mgp">mgp</code></td>
<td>

<p>The margin line (in mex units) for the axis title, axis labels and axis line. This has different (i.e. prettier) defaults than R of c(2,0.5,0) rather than c(3,1,0). This pushes the numbers and labels nearer to the plot compared to the defaults. It is possible to force magaxis to inherit directly from par by setting usepar=TRUE (see below). See <code><a href="graphics.html#topic+par">par</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_mtline">mtline</code></td>
<td>

<p>Number of lines separating axis name from axis. If length 2 then specifies x and y axis separation respectively (else these are the same).
</p>
</td></tr>
<tr><td><code id="magplot_+3A_xlab">xlab</code></td>
<td>

<p>x axis name.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_ylab">ylab</code></td>
<td>

<p>y axis name.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_crunch">crunch</code></td>
<td>

<p>In cases where the scientific text would be written as 1x10^8, should the 1x be removed so it reads 10^8. If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. TRUE by default.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_logpretty">logpretty</code></td>
<td>

<p>Should the major-ticks only be located at powers of 10. This changes cases where ticks are placed at 1, 3.1, 10, 31, 100 etc to 1, 10, 100. If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side. TRUE by default.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_prettybase">prettybase</code></td>
<td>

<p>The unit of repitition desired. By default it is 10, implying a pretty plot is one with marks at 10, 20, 30 etc. If you are plotting degrees then it might be prettier to display 90, 180, 270 etc. In which case prettybase should be set to 90. If log=TRUE then the reference location of 10 is changed, so in the previous example the labels generated would be at 9, 90, 900 etc rather than the deafult of 1, 10, 100 etc. If length is 1 and length of side is longer then this value is used for all axes. If length of arguments is longer than 1 then these should tally with the relevant axes in side.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_powbase">powbase</code></td>
<td>

<p>Set the base to use for logarithmic axes. Default is to use 10.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_hersh">hersh</code></td>
<td>

<p>To determines whether all plot text should be passed using Hershey vector fonts. This applies to the axis labels (which are handled automatically) and the axis names. In the case of axis names the user must be careful to use the correct plot utils escape characters: http://www.gnu.org/software/plotutils/manual/en/html_node/Text-String-Format.html.
magaxis will return back to the current plotting family after the function has executed.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_family">family</code></td>
<td>

<p>Specifies the plotting family to be used. Allowed options are 'sans' and 'serif'. Depending on whether hersh is TRUE or FALSE these otions are either applied to the Hershey vector fonts (hersh=TRUE) or the default R Helvetica font (hersh=FALSE). magaxis will return back to the current plotting family after the function has executed.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_frame.plot">frame.plot</code></td>
<td>

<p>Logical indicating whether a box should be drawn around the plot.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_usepar">usepar</code></td>
<td>

<p>Logical indicating whether tcl and mgp should be forced to inherit the global par values. This might be preferred when you want to define global plot settings at the start of a script.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_grid">grid</code></td>
<td>

<p>Logical indicating whether a background grid should be drawn onto the plotting area. If true this will generate vertical and horiztonal grid lines. For more control (i.e. to only draw horizontal or verical lines) see <code>link{magaxis}</code>.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_grid.col">grid.col</code></td>
<td>

<p>The colour of the grid to be drawn.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_grid.lty">grid.lty</code></td>
<td>

<p>The line type of the grid to be drawn.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_grid.lwd">grid.lwd</code></td>
<td>

<p>The line width of the grid to be drawn.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_xlim">xlim</code></td>
<td>

<p>Vector; range of data to display. If this is set to NULL (default) then the limits will be estimated from the data dynamically. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code><a href="#topic+magclip">magclip</a></code>.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_ylim">ylim</code></td>
<td>

<p>Vector; range of data to display. If this is set to NULL (default) then the limits will be estimated from the data dynamically. If length equals 1 then the argument is taken to mean the sigma range to select for plotting and the clipping is done by <code><a href="#topic+magclip">magclip</a></code>.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_lwd">lwd</code></td>
<td>

<p>The width of plot lines to be drawn. This has different behaviour depending on the plot type.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_axis.lwd">axis.lwd</code></td>
<td>

<p>The line width of the axis to be drawn. This is passed to <span class="option">lwd</span> argument in <code><a href="graphics.html#topic+axis">axis</a></code>.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_ticks.lwd">ticks.lwd</code></td>
<td>

<p>The line width of the ticks to be drawn. This is passed to <span class="option">ticks.lwd</span> argument in <code><a href="graphics.html#topic+axis">axis</a></code>.
</p>
</td></tr>
<tr><td><code id="magplot_+3A_axis.col">axis.col</code></td>
<td>

<p>Colour argument to pass directly to <span class="option">col</span> in axis. It is a bit clunky to have to specify this, but the option 'col' clashes too much with line and point colours.  
</p>
</td></tr>
<tr><td><code id="magplot_+3A_zcol">zcol</code></td>
<td>

<p>Vector; a colour palette to use for <span class="option">z</span> mapped colours. Must be a vector and not a function.. Only relevant if data has been passed to <span class="option">z</span>  
</p>
</td></tr>
<tr><td><code id="magplot_+3A_zstretch">zstretch</code></td>
<td>

<p>Character scalar; <span class="option">z</span> colour stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td></tr>
<tr><td><code id="magplot_+3A_dobar">dobar</code></td>
<td>

<p>Logical; should a colour bar be added to the plot?  
</p>
</td></tr>
<tr><td><code id="magplot_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to: base <code><a href="graphics.html#topic+plot">plot</a></code>; <code><a href="#topic+magaxis">magaxis</a></code> -&gt; <code><a href="graphics.html#topic+axis">axis</a></code>; <code><a href="#topic+magmap">magmap</a></code> and <code><a href="#topic+magbar">magbar</a></code> if <span class="option">z</span> scaling is being used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple function that just turns off most of the plotting output of base plot, and replaces where possible those present in magaxis.
</p>
<p>If <span class="option">x</span> is a data.frame with more than 2 columns then the utility base <code><a href="graphics.html#topic+plot">plot</a></code> data.frame plotting function is used to create a full plotting grid. This ignores <code><a href="#topic+magaxis">magaxis</a></code> settings entirely.
</p>
<p>Setting <span class="option">xlim</span> and <span class="option">ylim</span>
</p>


<h3>Value</h3>

<p>No output. Run for the side effect of producing nice plotting axes.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magerr">magerr</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=10^{1:9}
y=1:9
magplot(log10(x),y,unlog='x')
magplot(x,y,log='x')

#Not ideal to have two decades between major labels:

magplot(x,y,log='x',majorn=c(10,5))
magplot(x,y,log='xy',majorn=c(10,5,5,5),side=1:4)

#Sometimes it is helpful to focus on where most of the data actually is.
#Using a single value for xlim and ylim sigma clips the data to that range.
#Here a value of 2 means we only show the inner 2-sigma (2% to 98%) range.
#The 'auto' option allows magclip to dynamically estimate a clip value.

temp=cbind(rt(1e3,1.5),rt(1e3,1.5))
magplot(temp)
magplot(temp, xlim=2, ylim=2)
magplot(temp, xlim='auto', ylim='auto')

#Some astronomy related examples (and how to display the solar symbol):

## Not run: 
temp=cbind(runif(10,8,12),runif(10,0,5))

magplot(temp[,1:2], xlab=expression(M['\u0298']), ylab=expression(M['\u0298']/Yr), unlog='xy')

## End(Not run)

#With z scaling

z=sqrt(9:1)
magplot(x, y, z, log='x', position='topleft')
</code></pre>

<hr>
<h2 id='magproj'>
Magic longitude / latitude projection function
</h2><span id='topic+magproj'></span><span id='topic+magprojgrid'></span><span id='topic+magprojlabels'></span>

<h3>Description</h3>

<p>High level methods for producing pretty plot of projected data. Particularly useful in astronomy or geography, where many datasets are in longitude (right ascension) / latitude (declination) format. magproj is the highest level function, creating a projected image grid with labels and data. magprojgrid and magprojlabels are functions to simply overplot a grid and add labels respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magproj(long, lat, type = "b", plottext, longlim = c(-180, 180), latlim = c(-90, 90),
  projection = "aitoff", parameters = NULL, centre = c(0, 0), add = FALSE,
  fliplong = FALSE, nlat = 6, nlong = 6, prettybase = 30, labels = TRUE, grid = TRUE,
  grid.col = "grey", grid.lty = 2, auto = FALSE, upres = 100, box = TRUE,
  labloc = c(90, -45), labeltype = "deg", crunch = FALSE, ...)
  
magprojgrid(nlat = 6, nlong = 6, prettybase = 30, box = TRUE, ...)

magprojlabels(nlat = 6, nlong = 6, prettybase = 30, labloc = c(90, -45),
  labeltype = 'deg', crunch=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magproj_+3A_long">long</code></td>
<td>

<p>Vector of longitude values to use. If this is a matrix or data.frame with two columns and <span class="option">lat</span> is missing then column 1 is taken to be longitude values and column 2 is taken to be latitude values. long should have 2 elements only when <span class="option">type</span>=&quot;b&quot;.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_lat">lat</code></td>
<td>

<p>Vector of latitude values to use. If the input for <span class="option">long</span> is a matrix or data.frame with two columns and lat is missing then column 1 is taken to be longitude values and column 2 is taken to be latitude values. lat should have 2 elements only when type=&quot;b&quot;.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_type">type</code></td>
<td>

<p>The display type, either points (p), lines (l), polygon (pl), text (t), or box (b, the default). Points simply projects longitude and latitude positions into particle positions. Lines will join the positions together into a line, using <code>approxfun</code> to interpolate between positions at resolution <span class="option">upres</span>. Polygon will join the positions together into a polygon, using <code>approxfun</code> to interpolate between positions at resolution <span class="option">upres</span>. Text will display the text provided in plottext at the positions. Box will draw a polygon box, where the limits are given as a two element vector for <span class="option">long</span> and a two element vector for <span class="option">lat</span>.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_plottext">plottext</code></td>
<td>

<p>A vector of text to display at the provided longitude and latitude positions. Only used if <span class="option">type='t'</span>.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_longlim">longlim</code></td>
<td>

<p>The longitude limits to use in the plot. Vector of length 2.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_latlim">latlim</code></td>
<td>

<p>The latitude limits to use in the plot. Vector of length 2.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_projection">projection</code></td>
<td>

<p>Map projection to use. This function directly uses <code><a href="mapproj.html#topic+mapproject">mapproject</a></code>, and all of the inputs allowed for the <span class="option">projection</span> argument in that function are also allowed here.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_parameters">parameters</code></td>
<td>

<p>Map parameters to use. For details see the <span class="option">parameters</span> argument in <code><a href="mapproj.html#topic+mapproject">mapproject</a></code>.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_centre">centre</code></td>
<td>

<p>For most popular projections this argument specifies the longitude and latitude that is centred in the plot. Strictly <span class="option">orientation</span> in <code><a href="mapproj.html#topic+mapproject">mapproject</a></code> is set to <code>c(90+centre[2], centre[1], 0)</code>.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_add">add</code></td>
<td>

<p>Should a fresh plot be drawn (<span class="option">add=FALSE</span>), or should the new data be added to the current plot (<span class="option">add=TRUE</span>).
</p>
</td></tr>
<tr><td><code id="magproj_+3A_fliplong">fliplong</code></td>
<td>

<p>Should the the longitude axis be flipped so that low values are on the right hand side (normal for celestial sphere plots in astronomy).
</p>
</td></tr>
<tr><td><code id="magproj_+3A_nlong">nlong</code></td>
<td>

<p>The target number of gridlines in the longitude direction. Uses <code><a href="base.html#topic+pretty">pretty</a></code>, so the result may not be what is requested.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_nlat">nlat</code></td>
<td>

<p>The target number of gridlines in the latitude direction. Uses <code><a href="base.html#topic+pretty">pretty</a></code>, so the result may not be what is requested.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_prettybase">prettybase</code></td>
<td>

<p>The unit of repitition desired for the grid lines and labels. See <span class="option">prettybase</span> in <code><a href="#topic+maglab">maglab</a></code>. By default it is 30, implying a pretty plot is one with marks at 30, 60, 90 etc (i.e. attractive for large scale plots covering large longitude and latitude limits).
</p>
</td></tr>
<tr><td><code id="magproj_+3A_labels">labels</code></td>
<td>

<p>Should text coordinate labels be added to the plot.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_grid">grid</code></td>
<td>

<p>Should a background grid be drawn.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_grid.col">grid.col</code></td>
<td>

<p>The colour of the background grid.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_grid.lty">grid.lty</code></td>
<td>

<p>The line type for the background grid.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_auto">auto</code></td>
<td>

<p>If <span class="option">auto=FALSE</span> the plot is set up using all options specified. If <span class="option">auto=TRUE</span> then <span class="option">longlim</span>, <span class="option">latlim</span>, <span class="option">centre</span> and <span class="option">labloc</span> is estimated from the data. This mostly behaves sensibly, but do not be too surprised if the automatic plot is not ideal, and some manual tweaking is required.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_upres">upres</code></td>
<td>

<p>The resolution at which to do internal interpolation when drawing lines and boxes.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_box">box</code></td>
<td>

<p>Should a black outline be drawn following the <span class="option">longlim</span> and <span class="option">latlim</span> limits.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_labloc">labloc</code></td>
<td>

<p>The longitude and latitude at which labels should be drawn.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_labeltype">labeltype</code></td>
<td>

<p>Should the labels be drawn using degrees (deg) or colon delimited sexigesimal (sex).
</p>
</td></tr>
<tr><td><code id="magproj_+3A_crunch">crunch</code></td>
<td>

<p>If set to FALSE the full output of <code><a href="celestial.html#topic+deg2hms">deg2hms</a></code> and <code><a href="celestial.html#topic+deg2dms">deg2dms</a></code> is printed. If set to TRUE a simplified output is used, where only the hours and degrees parts are extracted and appended with a 'h' and a degree symbol respectively.
</p>
</td></tr>
<tr><td><code id="magproj_+3A_...">...</code></td>
<td>

<p>For magproj, Extra options that are either passed to <code><a href="graphics.html#topic+points">points</a></code> (<span class="option">type='p'</span>), <code><a href="graphics.html#topic+lines">lines</a></code> (<span class="option">type='l'</span>), <code><a href="graphics.html#topic+polygon">polygon</a></code> (<span class="option">type='pl'</span>), <code><a href="graphics.html#topic+text">text</a></code> (<span class="option">type='t'</span>), or <code><a href="graphics.html#topic+polygon">polygon</a></code> (<span class="option">type='b'</span>). For magprojgrid dots are pased to <code><a href="graphics.html#topic+lines">lines</a></code> for drawing the grid lines. For magprojlabels dots are passed to <code><a href="graphics.html#topic+text">text</a></code> for adding text labels.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output. Run for the side effect of producing nice projected plots.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>, <code><a href="#topic+magbar">magbar</a></code>, <code><a href="#topic+magprojextra">magprojextra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GAMA fields:
par(mar=c(0.1,0.1,0.1,0.1))
magproj(c(129,141), c(-2,3), type='b', projection='aitoff', centre=c(180,0),
fliplong=TRUE, labloc=c(90,-45), col='red', labeltype = 'sex', crunch=TRUE)
magproj(c(211.5,223.5), c(-2,3), col='red', add=TRUE)
magproj(c(30.2,38.8), c(-10.25,-3.72), col='red', add=TRUE)
magproj(c(30.2,38.8), -6, type='l', add=TRUE, col='grey')
magproj(c(339,351), c(-35,-30), col='red', add=TRUE)

magecliptic(width=10,col=hsv(1/12,alpha=0.3),border=NA)
magecliptic(width=0,col='orange')
magMWplane(width=20,col=hsv(v=0,alpha=0.1),border=NA)
magMWplane(width=0,col='darkgrey')
magMW(pch=16, cex=2, col='darkgrey')
magsun(c(7,26), pch=16, cex=2, col='orange2') #An important date!

magproj(c(174,186), c(-3,2), col='red', add=TRUE)

#Plus SDSS:
magproj(c(110,260), c(-4,70), border='blue', add=TRUE)

magproj(c(35,135,180,217.5,345), c(-3.72,3,2,3,-30)+10, type='t',
plottext=c('G02','G09','G12','G15','G23'), add=TRUE)

legend('topleft', legend=c('GAMA Regions','SDSS Main Survey'), col=c('red','blue'),
pch=c(15,NA), lty=c(NA,1), bty='n')
legend('topright', legend=c('Ecliptic','MW Plane'), col=c(hsv(c(1/12,0), v=c(1,0),
alpha=0.5)), pch=c(15,15), lty=c(1,1), bty='n')
legend('bottomleft', legend=c('Sun', 'MW Centre'), col=c('orange2','darkgrey'), pch=16,
bty='n')
</code></pre>

<hr>
<h2 id='magprojextra'>
Attractive great circles and thick bands on magproj plots
</h2><span id='topic+magprojextra'></span><span id='topic+magband'></span><span id='topic+magring'></span><span id='topic+magMW'></span><span id='topic+magsun'></span><span id='topic+magMWplane'></span><span id='topic+magecliptic'></span>

<h3>Description</h3>

<p>High level functions to add great circles and thick bands on projections plots. In astronomy these are popular for indicating regions of exclusion surrounding the ecliptic or the Milky-Way plane. Also simple functions to add either the MW bluge to the current projection (magMW) or the sun on a given date (magsun).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magring(crosseq = 0, peaklat = 0, offset = 0, res = 1000, ...)
magband(crosseq = 0, peaklat = 0, width = 10, res = 1000, ...)
magecliptic(width = 10, ...)
magMWplane(width = 10, ...)
magsun(Ydate = 'get', anti = FALSE, ...)
magMW(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magprojextra_+3A_crosseq">crosseq</code></td>
<td>

<p>The longitude below the latitude peak of the great circle (or centre of the band) where the centre crosses the equator. See examples to see how this is used in practice.
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_peaklat">peaklat</code></td>
<td>

<p>The positive maximum latitude obtained by the great circle (or centre of the band). See examples to see how this is used in practice.
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_offset">offset</code></td>
<td>

<p>Whether the ring drawn if systematically offset from the great cirlce defined by <span class="option">crosseq</span> and <span class="option">peaklat</span>. Leave at 0 to draw a great circle.
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_width">width</code></td>
<td>

<p>How wide whould the band be in degrees. For <code>magecliptic</code> and <code>magMWplane</code>, if this is zero it will draw a line instead.
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_res">res</code></td>
<td>

<p>Number of elements making up each side of the band (default should be fine for most plots).
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_ydate">Ydate</code></td>
<td>

<p>The date for the location of the Sun on the spherical grid. Vector in c(M,D) format. If set to 'get' then the function will return the Sun's location for today.  
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_anti">anti</code></td>
<td>

<p>Should the anti-sun position be computed (i.e. the RA and Dec of the position diametrically opposed to the Sun).  
</p>
</td></tr>
<tr><td><code id="magprojextra_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="graphics.html#topic+lines">lines</a></code> (<code><a href="#topic+magring">magring</a></code>), <code><a href="graphics.html#topic+polygon">polygon</a></code> (<code><a href="#topic+magband">magband</a></code>), <code><a href="graphics.html#topic+points">points</a></code> (<code><a href="#topic+magMW">magMW</a></code> and <code><a href="#topic+magsun">magsun</a></code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output. Run for the side effect of producing nice projected plots.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magmap">magmap</a></code>, <code><a href="#topic+magrun">magrun</a></code>, <code><a href="#topic+magbar">magbar</a></code>, <code><a href="#topic+magproj">magproj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GAMA fields:
par(mar=c(0.1,0.1,0.1,0.1))
magproj(c(129,141), c(-2,3), type='b', projection='aitoff', centre=c(180,0),
fliplong=TRUE, labloc=c(90,-45), col='red', labeltype = 'sex', crunch=TRUE)
magproj(c(211.5,223.5), c(-2,3), col='red', add=TRUE)
magproj(c(30.2,38.8), c(-10.25,-3.72), col='red', add=TRUE)
magproj(c(30.2,38.8), -6, type='l', add=TRUE, col='grey')
magproj(c(339,351), c(-35,-30), col='red', add=TRUE)

magecliptic(width=10,col=hsv(1/12,alpha=0.3),border=NA)
magecliptic(width=0,col='orange')
# Note this a shortcut for: magring(0,23.4,col='orange')
magMWplane(width=20,col=hsv(v=0,alpha=0.1),border=NA)
magMWplane(width=0,col='darkgrey')
# Note this a shortcut for: magring(76.75,62.6,col='darkgrey')
magMW(pch=16, cex=2, col='darkgrey')
magsun(c(7,26), pch=16, cex=2, col='orange2') #An important date!

magproj(c(174,186), c(-3,2), col='red', add=TRUE)

#Plus SDSS:
magproj(c(110,260), c(-4,70), border='blue', add=TRUE)

magproj(c(35,135,180,217.5,345), c(-3.72,3,2,3,-30)+10, type='t',
plottext=c('G02','G09','G12','G15','G23'), add=TRUE)

legend('topleft', legend=c('GAMA Regions','SDSS Main Survey'), col=c('red','blue'),
pch=c(15,NA), lty=c(NA,1), bty='n')
legend('topright', legend=c('Ecliptic','MW Plane'), col=c(hsv(c(1/12,0), v=c(1,0),
alpha=0.5)), pch=c(15,15), lty=c(1,1), bty='n')
legend('bottomleft', legend=c('Sun', 'MW Centre'), col=c('orange2','darkgrey'), pch=16,
bty='n')
</code></pre>

<hr>
<h2 id='magrun'>
Running averages
</h2><span id='topic+magrun'></span>

<h3>Description</h3>

<p>Computes running averages (medians / means / modes), user defined quantiles and standard deviations for x and y scatter data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magrun(x, y, bins = 10, type='median', ranges = pnorm(c(-1, 1)), binaxis = "x",
equalN = TRUE, xcut, ycut, log = '', Nscale = FALSE, diff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magrun_+3A_x">x</code></td>
<td>

<p>Data x coordinates. This can be a 1D vector (in which case y is required) or a 2D matrix or data frame, where the first two columns will be treated as x and y.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_y">y</code></td>
<td>

<p>Data y coordinates, optional if x is an appropriate structure.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_bins">bins</code></td>
<td>

<p>If a single integer value, how many bins the data should be split into. If a vector is provoided then these values are treated as the explicit bin limits to use.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_type">type</code></td>
<td>

<p>The type of running average to determine. Options are 'median' (the default), 'mean', 'mode' and 'mode2d'. 'median' calculates the median for binned x and y values. 'mean' calculates the mean for binned x and y values. 'mode' uses the default R 'density' function, and finds the mode of the resulting smoothed 1D distributions for binned x and y values. 'mode2d' uses the MASS package 'kde2d' function, and finds the mode of the resulting smoothed 2d distribution for binned x and y values. 'cen' just calucates the geometric centre of the bin in x and y directions and is useful for using in conjuction with another 'type' option for plotting purposes. 'mean', 'mode' and 'mode2d' should be used with some thought if 'log' is used, since the central values will be determined for the logged data, which may or may not be desired.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_ranges">ranges</code></td>
<td>

<p>The quantile ranges desired, can set to NULL if quantiles are not desired. The default adds 1-sigma equivilant quantile ranges.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_binaxis">binaxis</code></td>
<td>

<p>Which axis to bin across. Must be set to 'x' or 'y'.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_equaln">equalN</code></td>
<td>

<p>Should the data be split into bins with equal numbers of objects (default, TRUE), or into regular spaces from min to max (FALSE). Only relevant if 'bins' paramter is set to a single integer value and 'magrun' is determining the explicit bin limits automatically.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_xcut">xcut</code></td>
<td>

<p>A two element vector containing optional lower and upper x limits to apply to the data.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_ycut">ycut</code></td>
<td>

<p>A two element vector containing optional lower and upper y limits to apply to the data.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_log">log</code></td>
<td>

<p>Specify axes that should be logged. Allowed arguments are 'x', 'y' and 'xy'
</p>
</td></tr>
<tr><td><code id="magrun_+3A_nscale">Nscale</code></td>
<td>

<p>Sets whether the quantile ranges and standard deviations calculated are reduced with respect to the median by the square-root of the number of contributing data within each bin. The result of setting Nscale to TRUE is to scale the data like you are calculating the error-in-the-mean, rather than the scatter. For describing the 'significance' of trends in scatter data this is often what you want to show.
</p>
</td></tr>
<tr><td><code id="magrun_+3A_diff">diff</code></td>
<td>

<p>Should the output quantiles and standard deviations be expressed as differences from the chosen type of running avergage (TRUE) or the actual values (default, FALSE). The advantage of the former is plotting the results as errorbars using magerr, which expects differences (so error like values). If set to TRUE then the output of 'xsd' and 'ysd' is a 1D vector rather than a data.frame with x/y-sd and x/y+sd columns. See the examples below for usage guidance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will be default calculate the running median along the x axis for y values, it is intended to be used to trace the spread in scattered data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>

<p>The chosen averages (default median) of the x bins.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The chosen averages (default median) of the y bins.
</p>
</td></tr>
<tr><td><code>xquan</code></td>
<td>

<p>Matrix containing the extra user defined x quantile ranges (columns are in the same order as the requested quantiles). If Nscale is set to TRUE then this is also divided by sqrt the contributing objects in each bin.
</p>
</td></tr>
<tr><td><code>yquan</code></td>
<td>

<p>Matrix containing the extra user defined y quantile ranges (columns are in the same order as the requested quantiles). If Nscale is set to TRUE then this is also divided by sqrt the contributing objects in each bin.
</p>
</td></tr>
<tr><td><code>xsd</code></td>
<td>

<p>The standard deviations in the x bins. This is a two column data.frame if 'diff' is set to FALSE, giving the x-sd and x+sd values, or a single vector if 'diff' is set to TRUE. If Nscale is set to TRUE then this is also divided by sqrt the contributing objects in each bin.
</p>
</td></tr>
<tr><td><code>ysd</code></td>
<td>

<p>The standard deviations in the y bins. This is a two column data.frame if 'diff' is set to FALSE, giving the y-sd and y+sd values, or a single vector if 'diff' is set to TRUE. If Nscale is set to TRUE then this is also divided by sqrt the contributing objects in each bin.
</p>
</td></tr>
<tr><td><code>bincen</code></td>
<td>

<p>The bin centres used in the chosen binning direction.
</p>
</td></tr>
<tr><td><code>binlim</code></td>
<td>

<p>The bin limits used in the chosen binning direction.
</p>
</td></tr>
<tr><td><code>Nbins</code></td>
<td>

<p>The number of items contributing to each running bin. This effectively produces a histogram counts output for the final bin limits.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magaxis">magaxis</a></code>, <code><a href="#topic+maglab">maglab</a></code>, <code><a href="#topic+magerr">magerr</a></code>, <code><a href="#topic+magmap">magmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple example

temp=cbind(seq(0,2,len=1e4),rnorm(1e4))
temprun=magrun(temp)
magplot(temp,col='lightgreen',pch='.')
lines(temprun,col='red')
lines(temprun$x,temprun$yquan[,1],lty=2,col='red')
lines(temprun$x,temprun$yquan[,2],lty=2,col='red')
temprun=magrun(temp,binaxis='y')
lines(temprun,col='blue')
lines(temprun$xquan[,1],temprun$y,lty=2,col='blue')
lines(temprun$xquan[,2],temprun$y,lty=2,col='blue')

#Now with a gradient- makes it clear why the axis choice matters for simple line fitting.

temp=cbind(seq(0,2,len=1e4),rnorm(1e4)+1+seq(0,2,len=1e4))
temprun=magrun(temp)
magplot(temp,col='lightgreen',pch='.')
lines(temprun,col='red')
lines(temprun$x,temprun$yquan[,1],lty=2,col='red')
lines(temprun$x,temprun$yquan[,2],lty=2,col='red')
temprun=magrun(temp,binaxis='y')
lines(temprun,col='blue')
lines(temprun$xquan[,1],temprun$y,lty=2,col='blue')
lines(temprun$xquan[,2],temprun$y,lty=2,col='blue')

#Compare the different centres.

temp=cbind(seq(0,2,len=1e4),rnorm(1e4)^2+seq(0,2,len=1e4))
temprunmedian=magrun(temp,type='median')
temprunmean=magrun(temp,type='mean')
temprunmode=magrun(temp,type='mode')
temprunmode2d=magrun(temp,type='mode2d')
magplot(temp,col='grey',pch='.',ylim=c(-2,5))
lines(temprunmedian,col='red')
lines(temprunmean,col='green')
lines(temprunmode,col='blue')
lines(temprunmode2d,col='orange')

#Choose your own bins.

temp=cbind(seq(0,2,len=1e4),rnorm(1e4)+1+seq(0,2,len=1e4))
temprun=magrun(temp,bins=c(0.1,0.5,0.7,1.2,1.3,2))
magplot(temp,col='lightgreen',pch='.')
points(temprun,col='red')

#Show the 'error in the mean' type data points. Comparing to the best fit line,
#it is clear they are much more meaningful at reflecting the error in the trend seen,
#but not the distribution (or scatter) of data around this.

temp=cbind(seq(0,2,len=1e3),rnorm(1e3)+1+seq(0,2,len=1e3))
temprun=magrun(temp,bins=5)
temprunNscale=magrun(temp,bins=5,Nscale=TRUE)
magplot(temp,col='lightgreen',pch='.')
magerr(temprun$x,temprun$y,temprun$x-temprun$xquan[,1], temprun$y-temprun$yquan[,1],
temprun$xquan[,2]-temprun$x, temprun$yquan[,2]-temprun$y, lty=2,length=0,col='blue')
magerr(temprunNscale$x,temprunNscale$y,temprunNscale$x-temprunNscale$xquan[,1],
temprunNscale$y-temprunNscale$yquan[,1],temprunNscale$xquan[,2]-temprunNscale$x,
temprunNscale$yquan[,2]-temprunNscale$y,col='red')
abline(lm(temp[,2]~temp[,1]),col='black')

#Or the above type of plot can be done more simply using the 'diff' flag.

temprun=magrun(temp,bins=5,diff=TRUE)
temprunNscale=magrun(temp,bins=5,Nscale=TRUE,diff=TRUE)
magplot(temp,col='lightgreen',pch='.')
magerr(temprun$x,temprun$y,temprun$xquan[,1], temprun$yquan[,1], temprun$xquan[,2],
temprun$yquan[,2],lty=2,length=0,col='blue')
magerr(temprunNscale$x,temprunNscale$y,temprunNscale$xquan[,1], temprunNscale$yquan[,1],
temprunNscale$xquan[,2],temprunNscale$yquan[,2],col='red')
abline(lm(temp[,2]~temp[,1]),col='black')

#Similar, but using the 'sd' output.

magplot(temp,col='lightgreen',pch='.')
magerr(temprun$x,temprun$y,temprun$xsd,temprun$ysd,lty=2,length=0,col='blue')
magerr(temprunNscale$x,temprunNscale$y,temprunNscale$xsd,temprunNscale$ysd,col='red')
abline(lm(temp[,2]~temp[,1]),col='black')
</code></pre>

<hr>
<h2 id='magtri'>
High level triangle plotting code for MCMC chains
</h2><span id='topic+magtri'></span>

<h3>Description</h3>

<p>A very high level (minimal options) MCMC chain triangle (AKA corner) plot function. The default is deliberately spartan in terms of options, but the result should be a clear set of covariance plots that should give quick insight into the stationary sampling quality of a set of MCMC posterior chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magtri(chains, samples = 1000, thin = 1, samptype = 'end', grid = FALSE, do.tick = FALSE,
refvals = NULL, lab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magtri_+3A_chains">chains</code></td>
<td>

<p>A matrix or data.frame of the posterior chains, arranged so that the columns are the parameters and rows are the individual chain samples. The column names are inherited as the parameter names from the input to <code>chains</code>.
</p>
</td></tr>
<tr><td><code id="magtri_+3A_samples">samples</code></td>
<td>

<p>Specify the number of sub-samples desired. To speed up plotting it is often a good idea not to plot all chain samples (the reduced set is plotted as the top-left points and used to generate the bottom-right contours). The default plot 1000 samples.
</p>
</td></tr>
<tr><td><code id="magtri_+3A_thin">thin</code></td>
<td>

<p>Specify the thinning of chain samples, default (1) processes the whole chain.
</p>
</td></tr>
<tr><td><code id="magtri_+3A_samptype">samptype</code></td>
<td>

<p>Specifies whether to take all of the samples from the end of the supplied <code>chains</code> ('end', the default since samples are usually better towards the end of a set of psoterior chain samples), randomly selected ('ran', should only be used if you are confident the posterior chains supplied are true stationary samples) or evenly selected ('thin', which behaves much like thinning except we specify the target number of outputs, not the fraction of samples kept).
</p>
</td></tr>
<tr><td><code id="magtri_+3A_grid">grid</code></td>
<td>

<p>Should a background grid be added to the sub-panels? See <code><a href="#topic+magaxis">magaxis</a></code> for details.  
</p>
</td></tr>
<tr><td><code id="magtri_+3A_do.tick">do.tick</code></td>
<td>

<p>Logical; should ticks be drawn on each sub-panel? Passed to <code><a href="graphics.html#topic+axis">axis</a></code> argument <span class="option">tick</span>.  
</p>
</td></tr>
<tr><td><code id="magtri_+3A_refvals">refvals</code></td>
<td>

<p>Numeric vector; this gives reference values to overdraw. If provided it must be the same length as dim(chains)[2], i.e. this would usually be the number of parameters being compared in the triangle plot.
</p>
</td></tr>
<tr><td><code id="magtri_+3A_lab">lab</code></td>
<td>

<p>Character vector; optional over-ride for column names when plotting the grid of scatter plots.  
</p>
</td></tr>
<tr><td><code id="magtri_+3A_...">...</code></td>
<td>

<p>Extra arguments are passed to <span class="option">\link{magcon}</span> for plotting.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This interface is deliberately very high level with few options. It is really designed to allow quick exploratory views of posterior samples from MCMC chains, and publication grade plots should be designed by the user. That said, in many situations the plots generated are of pleasant, clear and publishable quality.
</p>
<p>Other types of data can be plotted using this function of course, but the default setup is tuned towards being useful for MCMC posterior chain samples.
</p>
<p>The contour levels shown are the defaults for magcon, i.e. they contain 50% (lty=2), 68% (lty=1) and 95% (lty=3) of the posterior chains.
</p>
<p>The red cross shows the mean for the sampled posterior chain. The red vertical dashed line traces this over the contour plots. The red dotted line shows the +/- SD range of the sampled posterior chain.
</p>


<h3>Value</h3>

<p>Outputs a two column matrix containing the means and standard deviations fo the parameters. Generally run for the side effect of producing nice projected plots.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magcon">magcon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma=matrix(c(10,3,-5,3,12,8,-5,8,20),3,3)
chains=MASS::mvrnorm(n=1000, mu=1:3, Sigma=Sigma)
magtri(chains,tick=TRUE)
</code></pre>

<hr>
<h2 id='plot.magbin'>
Plot 2D Histogram or Bin Data
</h2><span id='topic+plot.magbin'></span>

<h3>Description</h3>

<p>Plot 2D histogram counts or a third (z) axis summary statistic in 2D cells of different shapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'magbin'
plot(x, colramp = hcl.colors(21), colstretch = "lin",
  sizestretch = "lin", colref = "count", sizeref = "none", add = FALSE,
  dobar = TRUE, title = colref, colnorm = FALSE, projden = FALSE, projsig = FALSE,
  xdata = NULL, ydata = NULL, pch.dust = '.', cex.dust = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.magbin_+3A_x">x</code></td>
<td>

<p>Object of class 'magbin'.
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_colramp">colramp</code></td>
<td>

<p>Vector; a colour palette to use. Must be a vector and not a function.
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_colstretch">colstretch</code></td>
<td>

<p>Character scalar; colour stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_sizestretch">sizestretch</code></td>
<td>

<p>Character scalar; size stretch, either linear (lin, default) or logarithmic (log, good for large dynamic ranges).
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_colref">colref</code></td>
<td>

<p>Character scalar; colour reference for call, either it should be based on the counts (count) or the z-axis statistic (zstat)?
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_sizeref">sizeref</code></td>
<td>

<p>Character scalar; colour reference for call, either it should be ignored (none, so all are the same size and closely packed), based on the counts (count) or the z-axis statistic (zstat)?
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_add">add</code></td>
<td>

<p>Logical; should bins be added to the current plot? If FALSE then a new plot will be made.  
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_dobar">dobar</code></td>
<td>

<p>Logical; should a colour bar be added to the plot?  
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_title">title</code></td>
<td>

<p>Character scalar; title to use for the <span class="option">\link{magbar}</span> label.  
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_colnorm">colnorm</code></td>
<td>

<p>Logical; should the colour bar be normalised so the maximum value equals 1?  
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_projden">projden</code></td>
<td>

<p>Logical; do you want projected density PDFs to be displayed above and to the side of the standard <code>plot.magbin</code> plot? If so you also need to pass the same <span class="option">xdata</span> and <span class="option">ydata</span> that you originally sent to <code><a href="#topic+magbin">magbin</a></code>, since this is not stored in the object output from <code><a href="#topic+magbin">magbin</a></code>. 
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_projsig">projsig</code></td>
<td>

<p>Logical; if <span class="option">projden</span> = TRUE then this will optionally add lines to show the pseudo 1-sigma range (15.9% to 84.1% quantiles).
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_xdata">xdata</code></td>
<td>

<p>Numeric vector; the original x data sent to <code><a href="#topic+magbin">magbin</a></code>. Only relevant if <span class="option">projden</span>=TRUE.
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_ydata">ydata</code></td>
<td>

<p>Numeric vector; the original y data sent to <code><a href="#topic+magbin">magbin</a></code>. Only relevant if <span class="option">projden</span>=TRUE.
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_pch.dust">pch.dust</code></td>
<td>

<p>Scalar; pch symbol to use for the dust points.
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_cex.dust">cex.dust</code></td>
<td>

<p>Scalar; cex size to use for the dust points.
</p>
</td></tr>
<tr><td><code id="plot.magbin_+3A_...">...</code></td>
<td>

<p>Dots to be passed to <code><a href="#topic+magplot">magplot</a></code>, <code><a href="#topic+magmap">magmap</a></code> and <code><a href="#topic+magmap">magmap</a></code>. Relevant arguments are matched, so look in those functions for optional arguments to pass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Run for the side effect of making a nice plot.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+magbin">magbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp = magbin(rnorm(1e4), rnorm(1e4), plot=FALSE)
plot(temp, xlab='x', ylab='y')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
