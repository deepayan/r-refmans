<!DOCTYPE html><html><head><title>Help for package binspp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {binspp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binspp'><p>Bayesian inference for Neyman-Scott point processes</p></a></li>
<li><a href='#cov_refor'><p>Distance to the reforestration polygon</p></a></li>
<li><a href='#cov_reserv'><p>Distance to the reservoir</p></a></li>
<li><a href='#cov_slope'><p>Slope of the area</p></a></li>
<li><a href='#cov_tdensity'><p>Trees density</p></a></li>
<li><a href='#cov_tmi'><p>Topographic moisture index</p></a></li>
<li><a href='#estgtp'><p>Bayesian MCMC estimation of parameters of generalized Thomas process</p></a></li>
<li><a href='#estgtpr'><p>Results for Bayesian MCMC estimation of parameters of generalized Thomas process</p></a></li>
<li><a href='#estintp'><p>Estimation of Thomas-type cluster point process with complex inhomogeneities</p></a></li>
<li><a href='#first_step'><p>Estimate the first-order inhomogeneity</p></a></li>
<li><a href='#plot_outputs'><p>Graphical output describing the posterior distributions</p></a></li>
<li><a href='#print_outputs'><p>Text output describing the posterior distributions</p></a></li>
<li><a href='#re_estimate'><p>Re-estimate the posterior distributions with different burn-in</p></a></li>
<li><a href='#rgtp'><p>Simulation of generalized Thomas process</p></a></li>
<li><a href='#rThomasInhom'><p>Simulate a realization of Thomas-type cluster point process with complex inhomogeneities</p></a></li>
<li><a href='#trees_N4'><p>Spanish oak trees</p></a></li>
<li><a href='#x_left_N4'><p>Left horizontal corners for trees_N4 dataset</p></a></li>
<li><a href='#x_right_N4'><p>Right horizontal corners for trees_N4 dataset</p></a></li>
<li><a href='#y_bottom_N4'><p>Bottom vertical corners for trees_N4 dataset</p></a></li>
<li><a href='#y_top_N4'><p>Vertical corners for trees_N4 dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Inference for Neyman-Scott Point Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.26</td>
</tr>
<tr>
<td>Description:</td>
<td>The Bayesian MCMC estimation of parameters for Thomas-type cluster
    point process with various inhomogeneities. It allows for inhomogeneity in
    (i) distribution of parent points, (ii) mean number of points in a cluster,
    (iii) cluster spread. The package also allows for the Bayesian MCMC
    algorithm for the homogeneous generalized Thomas process. The cluster size
    is allowed to have a variance that is greater or less than the expected
    value (cluster sizes are over or under dispersed). Details are described in
    Dvořák, Remeš, Beránek &amp; Mrkvička (2022) &lt;arXiv: 10.48550/arXiv.2205.07946&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tomasmrkvicka/binspp">https://github.com/tomasmrkvicka/binspp</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, VGAM, cluster, mvtnorm, spatstat, spatstat.model,
spatstat.geom, spatstat.random</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-08 18:05:38 UTC; RR</td>
</tr>
<tr>
<td>Author:</td>
<td>Mrkvicka Tomas [aut],
  Dvorak Jiri [aut],
  Beranek Ladislav [aut],
  Remes Radim [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Remes Radim &lt;inrem@jcu.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-08 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binspp'>Bayesian inference for Neyman-Scott point processes</h2><span id='topic+binspp'></span>

<h3>Description</h3>

<p>The Bayesian MCMC estimation of parameters for Thomas-type cluster
point process with various inhomogeneities. It allows for inhomogeneity in
(i) distribution of parent points, (ii) mean number of points in a cluster,
(iii) cluster spread. The package also allows for the Bayesian MCMC
algorithm for the homogeneous generalized Thomas process.
The cluster size is allowed to have a variance that is greater or less
than the expected value (cluster sizes are over or under dispersed).
Details are described in Dvořák, Remeš, Beránek &amp; Mrkvička (2022)
(<a href="https://doi.org/10.48550/arXiv.2205.07946">doi:10.48550/arXiv.2205.07946</a>).
</p>


<h3>Note</h3>

<p>License: GPL-3
</p>


<h3>Author(s)</h3>

<p>Tomas Mrkvicka &lt;mrkvicka.toma@gmail.com&gt; (author),
Jiri Dvorak &lt;dvorak@karlin.mff.cuni.cz&gt; (author),
Ladislav Beranek &lt;beranek@jcu.cz&gt; (author),
Radim Remes &lt;inrem@jcu.cz&gt; (author, creator)
</p>


<h3>References</h3>

<p>Anderson, C. Mrkvička T. (2020). Inference for cluster point
processes with over- or under-dispersed cluster sizes,
<em>Statistics and computing</em> <strong>30</strong>, 1573–1590,
<a href="https://doi.org/10.1007/s11222-020-09960-8">doi:10.1007/s11222-020-09960-8</a>.
</p>
<p>Kopecký J., Mrkvička T. (2016). On the Bayesian estimation
for the stationary Neyman-Scott point processes,
Applications of Mathematics <strong>61</strong>/<strong>4</strong>, 503-514.
Available from: <a href="https://am.math.cas.cz/am61-4/9.html">https://am.math.cas.cz/am61-4/9.html</a>.
</p>
<p>Dvořák, J., Remeš, R., Beránek, L., Mrkvička, T. (2022). binspp:
An R Package for Bayesian Inference for Neyman-Scott Point Processes
with Complex Inhomogeneity Structure. <em>arXiv</em>.
<a href="https://doi.org/10.48550/ARXIV.2205.07946">doi:10.48550/ARXIV.2205.07946</a>.
</p>

<hr>
<h2 id='cov_refor'>Distance to the reforestration polygon</h2><span id='topic+cov_refor'></span>

<h3>Description</h3>

<p>Covariate for data trees_N4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_refor
</code></pre>


<h3>Format</h3>

<p>An object of class <code>im</code> with 208 rows and 374 columns.
</p>

<hr>
<h2 id='cov_reserv'>Distance to the reservoir</h2><span id='topic+cov_reserv'></span>

<h3>Description</h3>

<p>Covariate for data trees_N4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_reserv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>im</code> with 208 rows and 374 columns.
</p>

<hr>
<h2 id='cov_slope'>Slope of the area</h2><span id='topic+cov_slope'></span>

<h3>Description</h3>

<p>Covariate for data trees_N4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_slope
</code></pre>


<h3>Format</h3>

<p>An object of class <code>im</code> with 208 rows and 374 columns.
</p>

<hr>
<h2 id='cov_tdensity'>Trees density</h2><span id='topic+cov_tdensity'></span>

<h3>Description</h3>

<p>Covariate for data trees_N4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_tdensity
</code></pre>


<h3>Format</h3>

<p>An object of class <code>im</code> with 208 rows and 374 columns.
</p>

<hr>
<h2 id='cov_tmi'>Topographic moisture index</h2><span id='topic+cov_tmi'></span>

<h3>Description</h3>

<p>Covariate for data trees_N4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_tmi
</code></pre>


<h3>Format</h3>

<p>An object of class <code>im</code> with 208 rows and 374 columns.
</p>

<hr>
<h2 id='estgtp'>Bayesian MCMC estimation of parameters of generalized Thomas process</h2><span id='topic+estgtp'></span>

<h3>Description</h3>

<p>Bayesian MCMC estimation of parameters of generalized
Thomas process. The cluster size is allowed to have a variance
that is greater or less than the expected value (cluster sizes are
over or under dispersed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estgtp(
  X,
  kappa0 = exp(a_kappa + ((b_kappa^2)/2)),
  omega0 = exp(a_omega + ((b_omega^2)/2)),
  lambda0 = (l_lambda + u_lambda)/2,
  theta0 = exp(a_theta + ((b_theta^2)/2)),
  skappa,
  somega,
  dlambda,
  stheta,
  smove,
  a_kappa,
  b_kappa,
  a_omega,
  b_omega,
  l_lambda,
  u_lambda,
  a_theta,
  b_theta,
  iter = 5e+05,
  plot.step = 1000,
  save.step = 1000,
  filename
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estgtp_+3A_x">X</code></td>
<td>
<p>A point pattern dataset (object of class <em>ppp</em>) to which the model should be fitted.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_kappa0">kappa0</code></td>
<td>
<p>Initial value for <em>kappa</em>, by default it will be set as expectation of prior for <em>kappa</em>.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_omega0">omega0</code></td>
<td>
<p>Initial value for <em>omega</em>, by default it will be set as expectation of prior for <em>omega</em>.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_lambda0">lambda0</code></td>
<td>
<p>Initial value for <em>lambda</em>, by default it will be set as expectation of prior for <em>lambda</em>.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_theta0">theta0</code></td>
<td>
<p>Initial value for <em>theta</em>, by default it will be set as expectation of prior for <em>theta</em>.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_skappa">skappa</code></td>
<td>
<p>variability of proposal for <em>kappa</em>: second parameter of log-normal distribution</p>
</td></tr>
<tr><td><code id="estgtp_+3A_somega">somega</code></td>
<td>
<p>variability of proposal for <em>omega</em>: second parameter of log-normal distribution</p>
</td></tr>
<tr><td><code id="estgtp_+3A_dlambda">dlambda</code></td>
<td>
<p>variability of proposal for <em>lambda</em>: half of range of uniform distribution</p>
</td></tr>
<tr><td><code id="estgtp_+3A_stheta">stheta</code></td>
<td>
<p>variability of proposal for <em>theta</em>: second parameter of log-normal distribution</p>
</td></tr>
<tr><td><code id="estgtp_+3A_smove">smove</code></td>
<td>
<p>variability of proposal for moving center point: SD of normal distribution</p>
</td></tr>
<tr><td><code id="estgtp_+3A_a_kappa">a_kappa</code></td>
<td>
<p>First parameter of prior distribution for <em>kappa</em>, which is log-normal distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_b_kappa">b_kappa</code></td>
<td>
<p>Second parameter of prior distribution for <em>kappa</em>, which is log-normal distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_a_omega">a_omega</code></td>
<td>
<p>First parameter of prior distribution for <em>omega</em>, which is log-normal distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_b_omega">b_omega</code></td>
<td>
<p>Second parameter of prior distribution for omega, which is log-normal distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_l_lambda">l_lambda</code></td>
<td>
<p>First parameter of prior distribution for <em>lambda</em>, which is uniform distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_u_lambda">u_lambda</code></td>
<td>
<p>Second parameter of prior distribution for <em>lambda</em>, which is uniform distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_a_theta">a_theta</code></td>
<td>
<p>First parameter of prior distribution for <em>theta</em>, which is log-normal distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_b_theta">b_theta</code></td>
<td>
<p>Second parameter of prior distribution for <em>theta</em>, which is log-normal distribution.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_iter">iter</code></td>
<td>
<p>Number of iterations of MCMC.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_plot.step">plot.step</code></td>
<td>
<p>Step for the graph plotting. If the value is greater than <em>iter</em> parameter value, no plots will be visible.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_save.step">save.step</code></td>
<td>
<p>Step for the parameters saving. The file must be specified or has to be set to larger than <em>iter</em>.</p>
</td></tr>
<tr><td><code id="estgtp_+3A_filename">filename</code></td>
<td>
<p>The name of the output RDS file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is an estimated MCMC chain of parameters, centers and connections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
kappa = 10
omega = .1
lambda= .5
theta = 10

X = rgtp(kappa, omega, lambda, theta, win = owin(c(0, 1), c(0, 1)))
plot(X$X)
plot(X$C)

a_kappa = 4
b_kappa = 1
x &lt;- seq(0, 100, length = 100)
hx &lt;- dlnorm(x, a_kappa, b_kappa)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

a_omega = -3
b_omega = 1
x &lt;- seq(0, 1, length = 100)
hx &lt;- dlnorm(x, a_omega, b_omega)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

l_lambda = -1
u_lambda = 0.99
x &lt;- seq(-1, 1, length = 100)

hx &lt;- dunif(x, l_lambda, u_lambda)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

a_theta = 4
b_theta = 1
x &lt;- seq(0, 100, length = 100)
hx &lt;- dlnorm(x, a_theta, b_theta)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

est = estgtp(X$X,
          skappa = exp(a_kappa + ((b_kappa ^ 2) / 2)) / 100,
          somega = exp(a_omega + ((b_omega ^ 2) / 2)) / 100,
          dlambda = 0.01,
          stheta = exp(a_theta + ((b_theta ^ 2) / 2)) / 100, smove = 0.1,
          a_kappa = a_kappa, b_kappa = b_kappa,
          a_omega = a_omega, b_omega = b_omega,
          l_lambda = l_lambda, u_lambda = u_lambda,
          a_theta = a_theta, b_theta = b_theta,
          iter = 50, plot.step = 50, save.step = 1e9,
          filename = "")

</code></pre>

<hr>
<h2 id='estgtpr'>Results for Bayesian MCMC estimation of parameters of generalized Thomas process</h2><span id='topic+estgtpr'></span>

<h3>Description</h3>

<p>Calculates median values for <em>kappa</em>, <em>omega</em>, <em>lambda</em>, <em>theta</em>; calculates 2.5 and 97.5 quantile and draws trace plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estgtpr(est, discard = 100, step = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estgtpr_+3A_est">est</code></td>
<td>
<p>Output from <code><a href="#topic+estgtp">estgtp()</a></code> function.</p>
</td></tr>
<tr><td><code id="estgtpr_+3A_discard">discard</code></td>
<td>
<p>Number of iterations to be discarded as burn in for the estimation.</p>
</td></tr>
<tr><td><code id="estgtpr_+3A_step">step</code></td>
<td>
<p>Every <em>step</em> iteration is taken in the parameter estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Median and quantile values and plots (<em>kappa</em>, <em>omega</em>, <em>lambda</em>, <em>theta</em>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
kappa = 10
omega = .1
lambda= .5
theta = 10

X = rgtp(kappa, omega, lambda, theta, win = owin(c(0, 1), c(0, 1)))
plot(X$X)
plot(X$C)

a_kappa = 4
b_kappa = 1
x &lt;- seq(0, 100, length = 100)
hx &lt;- dlnorm(x, a_kappa, b_kappa)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

a_omega = -3
b_omega = 1
x &lt;- seq(0, 1, length = 100)
hx &lt;- dlnorm(x, a_omega, b_omega)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

l_lambda = -1
u_lambda = 0.99
x &lt;- seq(-1, 1, length = 100)

hx &lt;- dunif(x, l_lambda, u_lambda)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

a_theta = 4
b_theta = 1
x &lt;- seq(0, 100, length = 100)
hx &lt;- dlnorm(x, a_theta, b_theta)
plot(x, hx, type = "l", lty = 1, xlab = "x value",
     ylab = "Density", main = "Prior")

est = estgtp(X$X,
          skappa = exp(a_kappa + ((b_kappa ^ 2) / 2)) / 100,
          somega = exp(a_omega + ((b_omega ^ 2) / 2)) / 100,
          dlambda = 0.01,
          stheta = exp(a_theta + ((b_theta ^ 2) / 2)) / 100, smove = 0.1,
          a_kappa = a_kappa, b_kappa = b_kappa,
          a_omega = a_omega, b_omega = b_omega,
          l_lambda = l_lambda, u_lambda = u_lambda,
          a_theta = a_theta, b_theta = b_theta,
          iter = 50, plot.step = 50, save.step = 1e9,
          filename = "")

discard = 10
step = 10

result = estgtpr(est, discard, step)

</code></pre>

<hr>
<h2 id='estintp'>Estimation of Thomas-type cluster point process with complex inhomogeneities</h2><span id='topic+estintp'></span>

<h3>Description</h3>

<p>The Bayesian MCMC estimation of
parameters for Thomas-type cluster point process with inhomogeneity
is performed in any of the following parts: (i) distribution of parent
points, (ii) mean number of points in a cluster, (iii) cluster spread.
The process is observed in the observation window <em>W</em> which
is a union of aligned rectangles, aligned with the coordinate axes.
The inhomogeneities are described through a parametric model
depending on covariates. The estimation algorithm is described in
Dvořák, Remeš, Beránek &amp; Mrkvička (2022)
(<a href="https://doi.org/10.48550/arXiv.2205.07946">doi:10.48550/arXiv.2205.07946</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estintp(
  X,
  control,
  x_left,
  x_right,
  y_bottom,
  y_top,
  W_dil,
  z_beta = NULL,
  z_alpha = NULL,
  z_omega = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estintp_+3A_x">X</code></td>
<td>
<p>observed point pattern in the <code><a href="spatstat.geom.html#topic+ppp">spatstat.geom::ppp()</a></code> format of
the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="estintp_+3A_control">control</code></td>
<td>
<p>list specifying various tuning constants for the MCMC
estimation. See also Details.</p>
</td></tr>
<tr><td><code id="estintp_+3A_x_left">x_left</code></td>
<td>
<p>vector describing the observation window, contains
the lower x-coordinate of the corners of each rectangle.</p>
</td></tr>
<tr><td><code id="estintp_+3A_x_right">x_right</code></td>
<td>
<p>vector describing the observation window, contains
the higher x-coordinate of the corners of each rectangle.</p>
</td></tr>
<tr><td><code id="estintp_+3A_y_bottom">y_bottom</code></td>
<td>
<p>vector describing the observation window, contains the smaller y-coordinate of the corners of each rectangle.</p>
</td></tr>
<tr><td><code id="estintp_+3A_y_top">y_top</code></td>
<td>
<p>vector describing the observation window, contains the higher y-coordinate of the corners of each rectangle.</p>
</td></tr>
<tr><td><code id="estintp_+3A_w_dil">W_dil</code></td>
<td>
<p>the observation window dilated by the assumed maximal cluster radius.</p>
</td></tr>
<tr><td><code id="estintp_+3A_z_beta">z_beta</code></td>
<td>
<p>list of covariates describing the intensity function of the parent process, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="estintp_+3A_z_alpha">z_alpha</code></td>
<td>
<p>list of covariates describing the location-dependent mean number of points in a cluster, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="estintp_+3A_z_omega">z_omega</code></td>
<td>
<p>list of covariates describing the location-dependent scale of a cluster, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="estintp_+3A_verbose">verbose</code></td>
<td>
<p>logical (TRUE or FALSE). For suppressing information messages to the console set value to FALSE. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the function is given by the list containing
the parameter estimates along with the 2.5% and 97.5% quantiles
of the posterior distributions. Also, several auxiliary objects are
included in the list which are needed for the <code><a href="#topic+print_outputs">print_outputs()</a></code> and
<code><a href="#topic+plot_outputs">plot_outputs()</a></code> functions.
</p>


<h3>Details</h3>



<h4>Parametric model</h4>

<p>The model for the intensity function of the parent process is the following:
<code class="reqn">f(u) = kappa * exp(beta_1 * z\_beta_1(u) + … + beta_k * z\_beta_k(u))</code>,
where <code class="reqn">(kappa, beta_1, …, beta_k)</code> is the vector of parameters
and <code class="reqn">z\_beta = (z\_beta_1, …, z\_beta_k)</code> is the list of covariates.
Note that choosing <code class="reqn">k = 0</code> is acceptable, resulting in a homogeneous
distribution of parents. In such a case <em>z_beta</em> must be an empty list
or NULL. Furthermore, the list z_beta must contain named covariates in order
to properly function with the function <code><a href="spatstat.model.html#topic+ppm">spatstat.model::ppm()</a></code> from the
<span class="pkg">spatstat</span> package
which is used in the first step to estimate the parameters
<code class="reqn">(kappa, beta_1, …, beta_k)</code>. Note that due to identifiability issues
the covariate lists <em>z_beta</em> and <em>z_alpha</em> must be disjoint.
</p>
<p>The model for the mean number of points in a cluster corresponding
to the parent at location <code class="reqn">u</code> is the following:
<code class="reqn">g(u) = exp(alpha + alpha_1 * z\_alpha_1(u) + … + alpha_l * z\_alpha_l(u))</code>,
where <code class="reqn">(alpha, alpha_1, …, alpha_l)</code> is the vector of parameters and
<code class="reqn">z\_alpha = (z\_alpha_1, …, z\_alpha_l)</code> is the list of covariates.
Note that choosing <code class="reqn">l = 0</code> is acceptable, resulting in a constant model.
In such a case <em>z_alpha</em> must be an empty list or NULL. Note that
due to identifiability issues the covariate lists <em>z_beta</em> and
<em>z_alpha</em> must be disjoint.
</p>
<p>The model for the scale of a cluster corresponding to the parent at
location <code class="reqn">u</code> is the following:
<code class="reqn">h(u) = exp(omega + omega_1 * z\_omega_1(u) + … + omega_m * z\_omega_m(u))</code>,
where <br />
<code class="reqn">(omega, omega_1, …, omega_m)</code> is the vector of parameters and <br />
<code class="reqn">z\_omega = (z\_omega_1, …, z\_omega_m)</code> is the list of covariates.
Note that choosing <code class="reqn">m = 0</code> is acceptable, resulting in a constant model.
In such a case <em>z_omega</em> must be an empty list or NULL.
</p>



<h4>Observation window and its dilation</h4>

<p>The observation window must be provided as the union of aligned rectangles,
aligned with the coordinate axes. This, however, allows the analysis
of point patterns observed in rather irregular regions by approximating
the region by a union of aligned rectangles. The structure of the vectors
<em>x_left, x_right, y_bottom</em> and <em>y_top</em> is such that the first
rectangle is constructed using the function <code><a href="spatstat.geom.html#topic+owin">spatstat.geom::owin()</a></code> from the
<span class="pkg">spatstat</span> package as
<code>owin(c(x_left[1], x_right[1]), c(y_bottom[1], y_top[1]))</code>,
and similarly for the other rectangles. Naturally, a rectangular window
can be used and in such a case the vectors <em>x_left</em> to <em>y_top</em>
each contain a single element.
</p>



<h4>Covariates</h4>

<p>The covariates must be provided as pixel images of the class
<code><a href="spatstat.geom.html#topic+im">spatstat.geom::im()</a></code> used in the <span class="pkg">spatstat</span> package. It is recommended
that all the covariates have the same pixel resolution. However, it is
necessary that all the covariates in the list <em>z_beta</em> have the same
resolution, all the covariates in the list <em>z_alpha</em> have the same
resolution and all the covariates in the list <em>z_omega</em> have
the same distribution. The covariates must be provided in the dilated
observation window <em>W_dil</em>, with NA values at pixels lying outside
<em>W_dil</em>.
</p>



<h4>Control</h4>

<p>The control list must contain the following elements: <em>NStep</em>
(the required number of MCMC iterations to be performed), <em>BurnIn</em>
(burn-in, how many iterations at the beginning of the chain will be
disregarded when computing the resulting estimates – note that this choice
can be updated after the computation without re-running the chain,
see the function <code><a href="#topic+re_estimate">re_estimate()</a></code>), <em>SamplingFreq</em> (sampling frequency
for estimating the posterior distributions). Additionally,
the hyperparameters for the prior distributions should be given, see below.
Note that some default values for the hyperparameters are provided but it is
<strong>strongly encouraged</strong> that the hyperparameter values are given
by the user, based on the actual knowledge of the problem at hand.
</p>



<h4>Prior distributions and hyperparameters</h4>

<p>The prior distribution for <em>alpha</em> is normal with
<code>mean = Prior_alpha_mean</code> and <br /> <code>SD = Prior_alpha_SD</code>.
</p>
<p>The prior distribution for the vector <code class="reqn">(alpha_1, …, alpha_l)</code> is
centered normal with diagonal variance matrix and the vector of
<code>SDs = Prior_alphavec_SD</code>.
</p>
<p>The prior distribution for <em>omega</em> is normal with
<code>mean = Prior_omega_mean</code> and <br /> <code>SD = Prior_omega_SD</code>.
</p>
<p>The prior distribution for the vector <code class="reqn">(omega_1, …, omega_m)</code>
is centered normal with diagonal variance matrix and the vector of
<code>SDs = Prior_omegavec_SD</code>.
</p>
<p>The hyperparameters should be provided in the control list. However,
the following default choices are applied if the hyperparameter values
are not provided by user or are given as NULL: <br />
<code>Prior_alpha_mean = 3</code>,
<code>Prior_alpha_SD = 2</code>, <code>Prior_omega_mean = log(sqrt(area(W) / 20))</code>,
<code>Prior_omega_SD = log(3 + sqrt(area(W) / 40))</code>,
<code>Prior_alphavec_SD[i] = 2 / max(z_alpha_i)</code>,
<code>Prior_omegavec_SD[i] = 2 / max(z_omega_i) * log(3 + sqrt(area(W) / 20))</code>.
</p>



<h4>Output</h4>

<p>The output of the function is given by the list containing the parameter
estimates along with the 2.5% and 97.5% quantiles of the posterior
distributions. Also, several auxiliary objects are included in the list
which are needed for the <code><a href="#topic+print_outputs">print_outputs()</a></code> and <code><a href="#topic+plot_outputs">plot_outputs()</a></code> functions.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
# Prepare the dataset:
X = trees_N4
x_left = x_left_N4
x_right = x_right_N4
y_bottom = y_bottom_N4
y_top = y_top_N4

z_beta = list(refor = cov_refor, slope = cov_slope)
z_alpha = list(tmi = cov_tmi, tdensity = cov_tdensity)
z_omega = list(slope = cov_slope, reserv = cov_reserv)

# Determine the union of rectangles:
W = NULL
W = owin(c(x_left[1], x_right[1]), c(y_bottom[1], y_top[1]))
if (length(x_left) &gt;= 2) {
  for (i in 2:length(x_left)) {
    W2 = owin(c(x_left[i], x_right[i]), c(y_bottom[i], y_top[i]))
    W = union.owin(W, W2)
  }
}

# Dilated observation window:
W_dil = dilation.owin(W, 100)


# User-specified hyperparameters for prior distributions:
control = list(NStep = 100, BurnIn = 50, SamplingFreq = 5,
    Prior_alpha_mean = 3, Prior_alpha_SD = 2, Prior_omega_mean = 5.5,
    Prior_omega_SD = 5, Prior_alphavec_SD = c(4.25, 0.012),
    Prior_omegavec_SD = c(0.18,0.009))

# MCMC estimation:
Output = estintp(X, control, x_left, x_right, y_bottom, y_top,
    W_dil, z_beta, z_alpha, z_omega, verbose = FALSE)

# Text output + series of figures:
print_outputs(Output)
plot_outputs(Output)

</code></pre>

<hr>
<h2 id='first_step'>Estimate the first-order inhomogeneity</h2><span id='topic+first_step'></span>

<h3>Description</h3>

<p>For exploratory purposes it may be useful to perform the first
step of the analysis only, to investigate the dependence of
the intensity function of the parent process on given covariates,
without running the MCMC chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_step(X, z_beta, W_dil, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_step_+3A_x">X</code></td>
<td>
<p>observed point pattern in the <code><a href="spatstat.geom.html#topic+ppp">spatstat.geom::ppp()</a></code> format of the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="first_step_+3A_z_beta">z_beta</code></td>
<td>
<p>list of covariates describing the intensity function of the parent process, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="first_step_+3A_w_dil">W_dil</code></td>
<td>
<p>the observation window dilated by the assumed maximal cluster radius.</p>
</td></tr>
<tr><td><code id="first_step_+3A_plot">plot</code></td>
<td>
<p>logical, should the estimates intensity function of the parent process be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calling the <code><a href="spatstat.model.html#topic+ppm">spatstat.model::ppm()</a></code> function from the <span class="pkg">spatstat</span>
package, with some additional computations useful when preparing
the run of the MCMC chain, is mainly performed in this function.
The function also contains a simple way to plot the estimated
intensity function of the parent process.
</p>


<h3>Value</h3>

<p>List containing the output of the <code><a href="spatstat.model.html#topic+ppm">spatstat.model::ppm()</a></code>
function from the <span class="pkg">spatstat</span> package, along with some auxiliary
objects useful for running the MCMC chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
# Prepare the dataset:
X = trees_N4
x_left = x_left_N4
x_right = x_right_N4
y_bottom = y_bottom_N4
y_top = y_top_N4

z_beta = list(refor = cov_refor, slope = cov_slope)

# Determine the union of rectangles:
W = owin(c(x_left[1], x_right[1]), c(y_bottom[1], y_top[1]))
if (length(x_left) &gt;= 2){
  for (i in 2:length(x_left)){
    W2 = owin(c(x_left[i], x_right[i]), c(y_bottom[i], y_top[i]))
    W = union.owin(W, W2)
  }
}

# Dilated observation window:
W_dil = dilation.owin(W, 100)


# Estimating the intensity function of the parent process:
aux = first_step(X, z_beta, W_dil, plot = TRUE)

</code></pre>

<hr>
<h2 id='plot_outputs'>Graphical output describing the posterior distributions</h2><span id='topic+plot_outputs'></span>

<h3>Description</h3>

<p>A graphical representation of the posterior distributions
in terms of histograms and trace plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_outputs(Output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_outputs_+3A_output">Output</code></td>
<td>
<p>list, output of the main function <code><a href="#topic+estintp">estintp()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the covariate list <em>z_beta</em> was non-empty, the estimated
intensity function of the parent process is plotted. Then,
the estimated surface representing the location dependent
mean number of points in a cluster is plotted, and similarly,
the estimated surface representing the location dependent scale
of clusters is plotted. <br />
After that, histograms of the sample posterior distributions
of the individual parameters are plotted, together with
the histograms of p-values giving significance of the individual
covariates in <em>z_beta</em> with respect to the population
of parent points. <br />
Then, the trace plots for individual model parameters are plotted,
with highlighted sample median (full red line) and sample 2.5%
and 97.5% quantiles (dashed red lines), and similarly for
the p-values giving significance of the individual covariates
in <em>z_beta</em> with respect to the population of parent points.
<br />
Additionally, the following graphs are also plotted:
</p>

<ul>
<li><p> trace plot for the log-likelihood of the model,
</p>
</li>
<li><p> trace plot for the number of parent points,
</p>
</li>
<li><p> trace plot for the probability of accepting proposed updates of <code class="reqn">(alpha, alpha_1, …, alpha_l)</code>, 
</p>
</li>
<li><p> trace plot for the fraction of accepted updates of <code class="reqn">alpha, alpha_1, …, alpha_l</code> in the last 1000 iterations,
</p>
</li>
<li><p> trace plot for the probability of accepting proposed updates of <code class="reqn">omega, omega_1, …, omega_m</code>, 
</p>
</li>
<li><p> trace plot for the fraction of accepted updates of <code class="reqn">omega, omega_1, …, omega_m</code> in the last 1000 iterations,
</p>
</li>
<li><p> trace plot for the fraction of accepted updates of parent points in the last 1000 iterations.
</p>
</li></ul>



<h3>Value</h3>

<p>Series of plots providing a graphical representation
of the posterior distributions in terms of histograms and
trace plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
# Prepare the dataset:
X = trees_N4
x_left = x_left_N4
x_right = x_right_N4
y_bottom = y_bottom_N4
y_top = y_top_N4

z_beta = list(refor = cov_refor, slope = cov_slope)
z_alpha = list(tmi = cov_tmi, tdensity = cov_tdensity)
z_omega = list(slope = cov_slope, reserv = cov_reserv)

# Determine the union of rectangles:
W = owin(c(x_left[1], x_right[1]), c(y_bottom[1], y_top[1]))
if (length(x_left) &gt;= 2) {
  for (i in 2:length(x_left)) {
    W2 = owin(c(x_left[i], x_right[i]), c(y_bottom[i], y_top[i]))
    W = union.owin(W, W2)
  }
}

# Dilated observation window:
W_dil = dilation.owin(W, 100)


# Default parameters for prior distributions:
control = list(NStep = 100, BurnIn = 20, SamplingFreq = 5)


# MCMC estimation:
Output = estintp(X, control, x_left, x_right, y_bottom, y_top, W_dil,
                 z_beta, z_alpha, z_omega, verbose = FALSE)

# Text output + series of figures:
print_outputs(Output)
plot_outputs(Output)

</code></pre>

<hr>
<h2 id='print_outputs'>Text output describing the posterior distributions</h2><span id='topic+print_outputs'></span>

<h3>Description</h3>

<p>The summaries of the posterior distributions in the text form
are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_outputs(Output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_outputs_+3A_output">Output</code></td>
<td>
<p>list, output of the main function <code><a href="#topic+estintp">estintp()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter estimates (sample medians
from the empirical posterior distributions) and the 2.5%
and 97.5% quantiles from the empirical posterior
distributions are printed. <br />
Additionally, during the run of the MCMC chain the significance
of the covariates in the list <em>z_beta</em> with respect to the
current population of parent points is repeatedly tested.
This function prints the medians of the series of p-values
obtained in this way, together with the corresponding
2.5% and 97.5% sample quantiles of the p-values for each covariate.
</p>


<h3>Value</h3>

<p>Text output summarizing the posterior distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
# Prepare the dataset:
X = trees_N4
x_left = x_left_N4
x_right = x_right_N4
y_bottom = y_bottom_N4
y_top = y_top_N4

z_beta = list(refor = cov_refor, slope = cov_slope)
z_alpha = list(tmi = cov_tmi, tdensity = cov_tdensity)
z_omega = list(slope = cov_slope, reserv = cov_reserv)

# Determine the union of rectangles:
W = owin(c(x_left[1], x_right[1]), c(y_bottom[1], y_top[1]))
if (length(x_left) &gt;= 2) {
  for (i in 2:length(x_left)) {
    W2 = owin(c(x_left[i], x_right[i]), c(y_bottom[i], y_top[i]))
    W = union.owin(W, W2)
  }
}

# Dilated observation window:
W_dil = dilation.owin(W, 100)


# Default parameters for prior distributions:
control = list(NStep = 100, BurnIn = 20, SamplingFreq = 5)


# MCMC estimation:
Output = estintp(X, control, x_left, x_right, y_bottom, y_top, W_dil,
                 z_beta, z_alpha, z_omega, verbose = FALSE)


# Text output
print_outputs(Output)

</code></pre>

<hr>
<h2 id='re_estimate'>Re-estimate the posterior distributions with different burn-in</h2><span id='topic+re_estimate'></span>

<h3>Description</h3>

<p>After running the MCMC chain for the given number of steps, the trace plots may indicate that too small value of burn-in was used in the first place. This function enables re-estimating the posterior distributions with a different value of burn-in, without the need to run the MCMC chain again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_estimate(Output, BurnIn = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re_estimate_+3A_output">Output</code></td>
<td>
<p>list, output of the main function estintp.</p>
</td></tr>
<tr><td><code id="re_estimate_+3A_burnin">BurnIn</code></td>
<td>
<p>new value of burn-in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the main function binspp contains all
the intermediate states of the chain (sampled with the required
frequency) no matter what the original value of burn-in was.
This enables simple and quick re-estimation of the posterior
distributions with either higher or lower value of burn-in
than the one used originally. The output of this function has
the same structure as the output of the main function <code><a href="#topic+estintp">estintp()</a></code>.
</p>


<h3>Value</h3>

<p>List containing the parameter estimates along
with the 2.5% and 97.5% quantiles of the posterior distributions,
along with auxiliary objects needed for printing and plotting
the outputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
# Prepare the dataset:
X = trees_N4
x_left = x_left_N4
x_right = x_right_N4
y_bottom = y_bottom_N4
y_top = y_top_N4

z_beta = list(refor = cov_refor, slope = cov_slope)
z_alpha = list(tmi = cov_tmi, tdensity = cov_tdensity)
z_omega = list(slope = cov_slope, reserv = cov_reserv)

# Determine the union of rectangles:
W = owin(c(x_left[1], x_right[1]), c(y_bottom[1], y_top[1]))
if (length(x_left) &gt;= 2) {
  for (i in 2:length(x_left)) {
    W2 = owin(c(x_left[i], x_right[i]), c(y_bottom[i], y_top[i]))
    W = union.owin(W, W2)
  }
}

# Dilated observation window:
W_dil = dilation.owin(W, 100)


# Default parameters for prior distributions:
control = list(NStep = 100, BurnIn = 50, SamplingFreq = 5)

# MCMC estimation:
Output = estintp(X, control, x_left, x_right, y_bottom, y_top, W_dil,
                 z_beta, z_alpha, z_omega, verbose = FALSE)

# Text output + series of figures:
print_outputs(Output)
plot_outputs(Output)

# Recompute the outputs when another value of burn-in is desired,
# without running the chain again:
Out2 &lt;- re_estimate(Output, BurnIn = 80)
print_outputs(Out2)
plot_outputs(Out2)

</code></pre>

<hr>
<h2 id='rgtp'>Simulation of generalized Thomas process</h2><span id='topic+rgtp'></span>

<h3>Description</h3>

<p>Simulation of generalized Thomas process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgtp(
  kappa,
  omega,
  lambda,
  theta,
  win = owin(c(0, 1), c(0, 1)),
  nsim = 1,
  expand = 4 * omega
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgtp_+3A_kappa">kappa</code></td>
<td>
<p>intensity of cluster centers.</p>
</td></tr>
<tr><td><code id="rgtp_+3A_omega">omega</code></td>
<td>
<p>standard deviation of normal distribution specifying the clusters spread.</p>
</td></tr>
<tr><td><code id="rgtp_+3A_lambda">lambda</code></td>
<td>
<p>parameter of generalised Poisson distribution controlling over or under dispersion.</p>
</td></tr>
<tr><td><code id="rgtp_+3A_theta">theta</code></td>
<td>
<p>parameter of generalised Poisson distribution controlling the mean number of points in a cluster.</p>
</td></tr>
<tr><td><code id="rgtp_+3A_win">win</code></td>
<td>
<p>window in which to simulate the pattern. An object in the <br /> <code><a href="spatstat.geom.html#topic+owin">spatstat.geom::owin()</a></code> format of the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="rgtp_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="rgtp_+3A_expand">expand</code></td>
<td>
<p>the size of expansion of window to simulate the centers of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list(X, C), where <em>X</em> is Generalized Thomas process, and <em>C</em> is Process of cluster centers for Generalized Thomas process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
kappa = 10
omega = .1
lambda= .5
theta = 10

X = rgtp(kappa, omega, lambda, theta, win = owin(c(0, 1), c(0, 1)))
plot(X$X)
plot(X$C)

</code></pre>

<hr>
<h2 id='rThomasInhom'>Simulate a realization of Thomas-type cluster point process with complex inhomogeneities</h2><span id='topic+rThomasInhom'></span>

<h3>Description</h3>

<p>The means to simulate realizations
from the Thomas-type cluster point process with complex
inhomogeneities are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rThomasInhom(
  kappa,
  alpha,
  omega,
  W,
  W_dil,
  betavec = NULL,
  alphavec = NULL,
  omegavec = NULL,
  z_beta = NULL,
  z_alpha = NULL,
  z_omega = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rThomasInhom_+3A_kappa">kappa</code></td>
<td>
<p>intensity or intensity function of the parent process, scalar or pixel image object of class <code><a href="spatstat.geom.html#topic+im">spatstat.geom::im()</a></code> from the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_alpha">alpha</code></td>
<td>
<p>scalar, influences the mean number of points in individual clusters, see Details.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_omega">omega</code></td>
<td>
<p>scalar, influences the spread of individual clusters, see Details.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_w">W</code></td>
<td>
<p>the observation window where the realization is to be generated, in the <br /> <code><a href="spatstat.geom.html#topic+owin">spatstat.geom::owin()</a></code> format of the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_w_dil">W_dil</code></td>
<td>
<p>the observation window dilated by the assumed maximal cluster radius, as a binary mask with the same resolution as the covariates.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_betavec">betavec</code></td>
<td>
<p>vector of parameters describing the dependence of the intensity function of the parent process on covariates in the list <em>z_beta</em>.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_alphavec">alphavec</code></td>
<td>
<p>vector of parameters describing the dependence of the mean number of points in a cluster on covariates in the list <em>z_alpha</em>.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_omegavec">omegavec</code></td>
<td>
<p>vector of parameters describing the dependence of the spread of the clusters on covariates in the list <em>z_omega</em>.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_z_beta">z_beta</code></td>
<td>
<p>list of covariates describing the intensity function of the parent process, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_z_alpha">z_alpha</code></td>
<td>
<p>list of covariates describing the location-dependent mean number of points in a cluster, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
<tr><td><code id="rThomasInhom_+3A_z_omega">z_omega</code></td>
<td>
<p>list of covariates describing the location-dependent scale of a cluster, each covariate being a pixel image as used in the <span class="pkg">spatstat</span> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A realization of a Thomas-type cluster
point process model with possible inhomogeneity
(described by covariates) are produced in any or all of the following model
components: intensity function of the parent process, mean number
of points in a cluster, scale of the clusters.
Model parametrization is described in the documentation to the
function <code><a href="#topic+estintp">estintp()</a></code>. The parent process is generated in the dilated
observation window <em>W_dil</em> to avoid edge-effects,
the resulting point pattern is eventually truncated to the smaller
observation window <em>W</em>.
</p>


<h3>Value</h3>

<p>A planar point pattern, object of the type <code><a href="spatstat.geom.html#topic+ppp">spatstat.geom::ppp()</a></code>
used in the <span class="pkg">spatstat</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spatstat)
# Unit square observation window:
W &lt;- owin()

# Dilation of the observation window:
W_dil &lt;- dilation(W, 0.1)
W_dil &lt;- as.mask(W_dil)

# Define covariates:
f1 &lt;- function(x, y) { x }
f2 &lt;- function(x, y) { y }
f3 &lt;- function(x, y) { 1 - (y - 0.5) ^ 2 }
cov1 &lt;- as.im(f1, W = W_dil)
cov2 &lt;- as.im(f2, W = W_dil)
cov3 &lt;- as.im(f3, W = W_dil)


# Stationary Thomas process:
X &lt;- rThomasInhom(kappa = 50, alpha = log(10), omega = log(0.01),
       W = W, W_dil = W_dil)
plot(X)


# Thomas-type cluster process with inhomogeneity in all model components:
X &lt;- rThomasInhom(kappa = 10, betavec = c(1), z_beta = list(cov1),
            alpha = log(10), alphavec = c(1), z_alpha = list(cov2),
            omega = log(0.01), omegavec = c(1), z_omega = list(cov3),
            W = W, W_dil = W_dil)
plot(X)

</code></pre>

<hr>
<h2 id='trees_N4'>Spanish oak trees</h2><span id='topic+trees_N4'></span>

<h3>Description</h3>

<p>The oak trees dataset sampled in 2009 in region consisting of 5 rectangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trees_N4
</code></pre>


<h3>Format</h3>

<p>A list with columns:
</p>

<dl>
<dt>window</dt><dd><p>A list of region window definition.</p>
</dd>
<dt>n</dt><dd><p>Number of oak trees in the region.</p>
</dd>
<dt>x</dt><dd><p>Array of x coordinates of oak trees.</p>
</dd>
<dt>y</dt><dd><p>Array of y coordinates of oak trees.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data contains point pattern of trees, 5 covariates
(refor, reserve, slope, tdensity, tmi) and 4 vectors
(x_left, x_right, y_bottom, y_top) of corners of rectangles forming
the observation window.
</p>


<h3>Source</h3>

<p>Jesús Fernández-Habas, Pilar Fernández-Rebollo,
Mónica Rivas Casado, Alma María García Moreno,
Begoña Abellanas. Spatio-temporal analysis of
oak decline process in open woodlands: A case study
in SW Spain, Journal of Environmental Management,
248, 2019, 109308,
<a href="https://doi.org/10.1016/j.jenvman.2019.109308">doi:10.1016/j.jenvman.2019.109308</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(trees_N4)
</code></pre>

<hr>
<h2 id='x_left_N4'>Left horizontal corners for trees_N4 dataset</h2><span id='topic+x_left_N4'></span>

<h3>Description</h3>

<p>The vector of left horizontal corners of rectangles forming observation
window for trees_N4 dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_left_N4
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 5.
</p>

<hr>
<h2 id='x_right_N4'>Right horizontal corners for trees_N4 dataset</h2><span id='topic+x_right_N4'></span>

<h3>Description</h3>

<p>The vector of right horizontal corners of rectangles forming observation
window for trees_N4 dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_right_N4
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 5.
</p>

<hr>
<h2 id='y_bottom_N4'>Bottom vertical corners for trees_N4 dataset</h2><span id='topic+y_bottom_N4'></span>

<h3>Description</h3>

<p>The vector of bottom vertical corners of rectangles forming observation
window for trees_N4 dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y_bottom_N4
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 5.
</p>

<hr>
<h2 id='y_top_N4'>Vertical corners for trees_N4 dataset</h2><span id='topic+y_top_N4'></span>

<h3>Description</h3>

<p>The vector of top vertical corners of rectangles forming observation
window for trees_N4 dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y_top_N4
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 5.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
