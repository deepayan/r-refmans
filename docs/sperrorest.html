<!DOCTYPE html><html><head><title>Help for package sperrorest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sperrorest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sperrorest-package'><p>Spatial Error Estimation and Variable Importance</p></a></li>
<li><a href='#add.distance'><p>Add distance information to resampling objects</p></a></li>
<li><a href='#as.represampling'><p>Resampling objects with repetition, i.e. sets of partitionings or</p>
bootstrap samples</a></li>
<li><a href='#as.resampling'><p>Resampling objects such as partitionings or bootstrap samples</p></a></li>
<li><a href='#as.tilename'><p>Alphanumeric tile names</p></a></li>
<li><a href='#dataset_distance'><p>Calculate mean nearest-neighbour distance between point datasets</p></a></li>
<li><a href='#ecuador'><p>J. Muenchow's Ecuador landslide data set</p></a></li>
<li><a href='#err_default'><p>Default error function</p></a></li>
<li><a href='#get_small_tiles'><p>Identify small partitions that need to be fixed.</p></a></li>
<li><a href='#maipo'><p>Fruit-tree crop classification: the Maipo dataset</p></a></li>
<li><a href='#partition_cv'><p>Partition the data for a (non-spatial) cross-validation</p></a></li>
<li><a href='#partition_cv_strat'><p>Partition the data for a stratified (non-spatial) cross-validation</p></a></li>
<li><a href='#partition_disc'><p>Leave-one-disc-out cross-validation and leave-one-out cross-validation</p></a></li>
<li><a href='#partition_factor'><p>Partition the data for a (non-spatial) leave-one-factor-out</p>
cross-validation based on a given, fixed partitioning</a></li>
<li><a href='#partition_factor_cv'><p>Partition the data for a (non-spatial) k-fold cross-validation at the</p>
group level</a></li>
<li><a href='#partition_kmeans'><p>Partition samples spatially using k-means clustering of the</p>
coordinates</a></li>
<li><a href='#partition_tiles'><p>Partition the study area into rectangular tiles</p></a></li>
<li><a href='#plot.represampling'><p>Plot spatial resampling objects</p></a></li>
<li><a href='#remove_missing_levels'><p>remove_missing_levels</p></a></li>
<li><a href='#represampling_bootstrap'><p>Non-spatial bootstrap resampling</p></a></li>
<li><a href='#represampling_disc_bootstrap'><p>Overlapping spatial block bootstrap using circular blocks</p></a></li>
<li><a href='#represampling_factor_bootstrap'><p>Bootstrap at an aggregated level</p></a></li>
<li><a href='#represampling_kmeans_bootstrap'><p>Spatial block bootstrap at the level of spatial k-means clusters</p></a></li>
<li><a href='#represampling_tile_bootstrap'><p>Spatial block bootstrap using rectangular blocks</p></a></li>
<li><a href='#resample_factor'><p>Draw uniform random (sub)sample at the group level</p></a></li>
<li><a href='#resample_strat_uniform'><p>Draw stratified random sample</p></a></li>
<li><a href='#resample_uniform'><p>Draw uniform random (sub)sample</p></a></li>
<li><a href='#runfolds'><p>runfolds</p></a></li>
<li><a href='#runreps'><p>runreps</p></a></li>
<li><a href='#sperrorest'><p>Perform spatial error estimation and variable importance assessment</p></a></li>
<li><a href='#summary.represampling'><p>title Summary statistics for a resampling objects</p></a></li>
<li><a href='#summary.sperroresterror'><p>Summarize error statistics obtained by sperrorest</p></a></li>
<li><a href='#summary.sperrorestimportance'><p>Summarize variable importance statistics obtained by sperrorest</p></a></li>
<li><a href='#summary.sperrorestreperror'><p>Summary and print methods for sperrorest results</p></a></li>
<li><a href='#tile_neighbors'><p>Determine the names of neighbouring tiles in a rectangular pattern</p></a></li>
<li><a href='#transfer_parallel_output'><p>transfer_parallel_output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Perform Spatial Error Estimation and Variable Importance
Assessment</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements spatial error estimation and
    permutation-based variable importance measures for predictive models
    using spatial cross-validation and spatial block bootstrap.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://giscience-fsu.github.io/sperrorest/">https://giscience-fsu.github.io/sperrorest/</a>,
<a href="https://github.com/giscience-fsu/sperrorest">https://github.com/giscience-fsu/sperrorest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/giscience-fsu/sperrorest/issues">https://github.com/giscience-fsu/sperrorest/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, future, future.apply, graphics, ROCR, stats, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, MASS, nnet, parallel, ranger, rmarkdown, rpart, sp,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-12 16:39:19 UTC; yo54pow</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Brenning
    <a href="https://orcid.org/0000-0001-6640-679X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Patrick Schratz <a href="https://orcid.org/0000-0003-0748-6624"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tobias Herrmann <a href="https://orcid.org/0000-0001-9768-0708"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Brenning &lt;alexander.brenning@uni-jena.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-16 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sperrorest-package'>Spatial Error Estimation and Variable Importance</h2><span id='topic+sperrorest-package'></span>

<h3>Description</h3>

<p>This package implements spatial error estimation and permutation-based
spatial variable importance using different spatial cross-validation
and spatial block bootstrap methods. To cite &lsquo;sperrorest&rsquo; in publications,
reference the paper by Brenning (2012).
</p>


<h3>References</h3>

<p>Brenning, A. 2012. Spatial cross-validation and bootstrap for the
assessment of prediction rules in remote sensing: the R package 'sperrorest'.
2012 IEEE International Geoscience and Remote Sensing Symposium (IGARSS),
23-27 July 2012, p. 5372-5375.
</p>
<p>Brenning, A. 2005. Spatial prediction models for landslide hazards:
review, comparison and evaluation. Natural Hazards and Earth System Sciences,
5(6): 853-862.
</p>
<p>Russ, G. &amp; A. Brenning. 2010a. Data mining in precision agriculture:
Management of spatial information. In 13th International Conference on
Information Processing and Management of Uncertainty, IPMU 2010; Dortmund;
28 June - 2 July 2010.  Lecture Notes in Computer Science,
6178 LNAI: 350-359.
</p>
<p>Russ, G. &amp; A. Brenning. 2010b. Spatial variable importance assessment for
yield prediction in Precision Agriculture. In Advances in Intelligent
Data Analysis IX, Proceedings, 9th International Symposium, IDA 2010,
Tucson, AZ, USA, 19-21 May 2010.
Lecture Notes in Computer Science, 6065 LNCS: 184-195.
</p>

<hr>
<h2 id='add.distance'>Add distance information to resampling objects</h2><span id='topic+add.distance'></span><span id='topic+add.distance.resampling'></span><span id='topic+add.distance.represampling'></span>

<h3>Description</h3>

<p>Add distance information to resampling objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.distance(object, ...)

## S3 method for class 'resampling'
add.distance(object, data, coords = c("x", "y"), ...)

## S3 method for class 'represampling'
add.distance(object, data, coords = c("x", "y"), mode = "future", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.distance_+3A_object">object</code></td>
<td>
<p><a href="#topic+resampling">resampling</a> or <a href="#topic+represampling">represampling</a> object.</p>
</td></tr>
<tr><td><code id="add.distance_+3A_...">...</code></td>
<td>
<p>Additional arguments to <a href="#topic+dataset_distance">dataset_distance</a> and
<a href="#topic+add.distance.resampling">add.distance.resampling</a>, respectively.</p>
</td></tr>
<tr><td><code id="add.distance_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="add.distance_+3A_coords">coords</code></td>
<td>
<p>(ignored by <code>partition_cv</code>)</p>
</td></tr>
<tr><td><code id="add.distance_+3A_mode">mode</code></td>
<td>
<p>Use <code>future.apply::future_lapply()</code> for parallelized
execution if <code>mode = "future"</code>, and <code>lapply</code> for sequential
execution otherwise (<code>mode = "sequential"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nearest-neighbour distances are calculated for each sample in the
test set. These <code style="white-space: pre;">&#8288;nrow(???$test)&#8288;</code> nearest-neighbour distances are then
averaged. Aggregation methods other than <code>mean</code> can be chosen using the
<code>fun</code> argument, which will be passed on to <a href="#topic+dataset_distance">dataset_distance</a>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+resampling">resampling</a> or <a href="#topic+represampling">represampling</a> object containing an additional.
<code style="white-space: pre;">&#8288;$distance&#8288;</code> component in each <a href="#topic+resampling">resampling</a> object. The <code>distance</code> component
is a single numeric value indicating, for each <code>train</code> / <code>test</code> pair, the
(by default, mean) nearest-neighbour distance between the two sets.
</p>


<h3>See Also</h3>

<p><a href="#topic+dataset_distance">dataset_distance</a> <a href="#topic+represampling">represampling</a>
<a href="#topic+resampling">resampling</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Muenchow et al. (2012), see ?ecuador
nsp.parti &lt;- partition_cv(ecuador)
sp.parti &lt;- partition_kmeans(ecuador)
nsp.parti &lt;- add.distance(nsp.parti, data = ecuador)
sp.parti &lt;- add.distance(sp.parti, data = ecuador)
# non-spatial partioning: very small test-training distance:
nsp.parti[[1]][[1]]$distance
# spatial partitioning: more substantial distance, depending on number of
# folds etc.
sp.parti[[1]][[1]]$distance
</code></pre>

<hr>
<h2 id='as.represampling'>Resampling objects with repetition, i.e. sets of partitionings or
bootstrap samples</h2><span id='topic+as.represampling'></span><span id='topic+represampling'></span><span id='topic+as.represampling_list'></span><span id='topic+as.represampling.list'></span><span id='topic+print.represampling'></span><span id='topic+is_represampling'></span>

<h3>Description</h3>

<p>Functions for handling <code>represampling</code> objects, i.e. <code>list</code>s of
<a href="#topic+resampling">resampling</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.represampling(object, ...)

## S3 method for class 'list'
as.represampling(object, ...)

## S3 method for class 'represampling'
print(x, ...)

is_represampling(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.represampling_+3A_object">object</code></td>
<td>
<p>object of class <code>represampling</code>, or a list to be coerced to
this class.</p>
</td></tr>
<tr><td><code id="as.represampling_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="as.represampling_+3A_x">x</code></td>
<td>
<p>object of class <code>represampling</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>represampling</code> objects are (names) lists of <a href="#topic+resampling">resampling</a> objects.
Such objects are typically created by <a href="#topic+partition_cv">partition_cv</a>, <a href="#topic+partition_kmeans">partition_kmeans</a>,
<a href="#topic+represampling_disc_bootstrap">represampling_disc_bootstrap</a> and related functions.
</p>
<p>In <code>r</code>-repeated <code>k</code>-fold cross-validation, for example, the corresponding
<code>represampling</code> object has length <code>r</code>, and each of its <code>r</code> <a href="#topic+resampling">resampling</a>
objects has length <code>k</code>.
</p>
<p><code>as.resampling_list</code> coerces <code>object</code> to class <code>represampling</code> while
coercing its elements to <a href="#topic+resampling">resampling</a> objects. Some validity checks are
performed.
</p>


<h3>Value</h3>

<p><code>as.represampling</code> methods return an object of class <code>represampling</code>
with the contents of <code>object</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+resampling">resampling</a>, <a href="#topic+partition_cv">partition_cv</a>, <a href="#topic+partition_kmeans">partition_kmeans</a>,
<a href="#topic+represampling_disc_bootstrap">represampling_disc_bootstrap</a>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Muenchow et al. (2012), see ?ecuador
# Partitioning by elevation classes in 200 m steps:
fac &lt;- factor(as.character(floor(ecuador$dem / 300)))
summary(fac)
parti &lt;- as.resampling(fac)
# a list of lists specifying sets of training and test sets,
# using each factor at a time as the test set:
str(parti)
summary(parti)
</code></pre>

<hr>
<h2 id='as.resampling'>Resampling objects such as partitionings or bootstrap samples</h2><span id='topic+as.resampling'></span><span id='topic+resampling'></span><span id='topic+as.resampling_default'></span><span id='topic+as.resampling.default'></span><span id='topic+as.resampling.factor'></span><span id='topic+as.resampling_list'></span><span id='topic+as.resampling.list'></span><span id='topic+validate.resampling'></span><span id='topic+is.resampling'></span><span id='topic+print.resampling'></span>

<h3>Description</h3>

<p>Create/coerce and print resampling objects, e.g., partitionings
or bootstrap samples derived from a data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.resampling(object, ...)

## Default S3 method:
as.resampling(object, ...)

## S3 method for class 'factor'
as.resampling(object, ...)

## S3 method for class 'list'
as.resampling(object, ...)

validate.resampling(object)

is.resampling(x, ...)

## S3 method for class 'resampling'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.resampling_+3A_object">object</code></td>
<td>
<p>depending on the function/method, a list or a vector of type
factor defining a partitioning of the dataset.</p>
</td></tr>
<tr><td><code id="as.resampling_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="as.resampling_+3A_x">x</code></td>
<td>
<p>object of class <code>resampling</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>resampling</code> object is a list of lists defining a set of training
and test samples.
</p>
<p>In the case of <code>k</code>-fold cross-validation partitioning, for example, the
corresponding <code>resampling</code> object would be of length <code>k</code>, i.e. contain <code>k</code>
lists. Each of these <code>k</code> lists defines a training set of size <code>n(k-1)/k</code>
(where <code>n</code> is the overall sample size), and a test set of size <code>n/k</code>. The
<code>resampling</code> object does, however, not contain the data itself, but only
indices between <code>1</code> and <code>n</code> identifying the selection (see Examples).
</p>
<p>Another example is bootstrap resampling. <a href="#topic+represampling_bootstrap">represampling_bootstrap</a> with
argument <code>oob = TRUE</code> generates <code><a href="base.html#topic+rep">rep</a></code><code>resampling</code> objects with indices of a
bootstrap sample in the <code>train</code> component and indices of the out-of-bag
sample in the test component (see Examples below).
</p>
<p><code>as.resampling.factor</code>: For each factor level of the input variable,
<code>as.resampling.factor</code> determines the indices of samples in this level (=
test samples) and outside this level (= training samples). Empty levels of
<code>object</code> are dropped without warning.
</p>
<p><code>as.resampling_list</code> checks if the list in <code>object</code> has a valid <code>resampling</code>
object structure (with components <code>train</code> and <code>test</code> etc.) and assigns the
class attribute <code>'resampling'</code> if successful.
</p>


<h3>Value</h3>

<p><code>as.resampling</code> methods: An object of class <code>resampling</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+represampling">represampling</a>, <a href="#topic+partition_cv">partition_cv</a>,
<a href="#topic+partition_kmeans">partition_kmeans</a>, <a href="#topic+represampling_bootstrap">represampling_bootstrap</a>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Muenchow et al. (2012), see ?ecuador

# Partitioning by elevation classes in 200 m steps:
parti &lt;- factor(as.character(floor(ecuador$dem / 200)))
smp &lt;- as.resampling(parti)
summary(smp)
# Compare:
summary(parti)

# k-fold (non-spatial) cross-validation partitioning:
parti &lt;- partition_cv(ecuador)
parti &lt;- parti[[1]] # the first (and only) resampling object in parti
# data corresponding to the test sample of the first fold:
str(ecuador[parti[[1]]$test, ])
# the corresponding training sample - larger:
str(ecuador[parti[[1]]$train, ])

# Bootstrap training sets, out-of-bag test sets:
parti &lt;- represampling_bootstrap(ecuador, oob = TRUE)
parti &lt;- parti[[1]] # the first (and only) resampling object in parti
# out-of-bag test sample: approx. one-third of nrow(ecuador):
str(ecuador[parti[[1]]$test, ])
# bootstrap training sample: same size as nrow(ecuador):
str(ecuador[parti[[1]]$train, ])
</code></pre>

<hr>
<h2 id='as.tilename'>Alphanumeric tile names</h2><span id='topic+as.tilename'></span><span id='topic+tilename'></span><span id='topic+as.tilename_numeric'></span><span id='topic+as.tilename.numeric'></span><span id='topic+as.character.tilename'></span><span id='topic+as.numeric.tilename'></span><span id='topic+as.tilename_character'></span><span id='topic+as.tilename.character'></span><span id='topic+print.tilename'></span>

<h3>Description</h3>

<p>Functions for generating and handling alphanumeric tile names of
the form <code>'X2:Y7'</code> as used by <a href="#topic+partition_tiles">partition_tiles</a> and
<a href="#topic+represampling_tile_bootstrap">represampling_tile_bootstrap</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.tilename(x, ...)

## S3 method for class 'numeric'
as.tilename(x, ...)

## S3 method for class 'tilename'
as.character(x, ...)

## S3 method for class 'tilename'
as.numeric(x, ...)

## S3 method for class 'character'
as.tilename(x, ...)

## S3 method for class 'tilename'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tilename_+3A_x">x</code></td>
<td>
<p>object of class <code>tilename</code>, <code>character</code>, or <code>numeric</code> (of length 2).</p>
</td></tr>
<tr><td><code id="as.tilename_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>tilename</code>, <code>character</code>, or numeric vector of length
2
</p>


<h3>See Also</h3>

<p><a href="#topic+partition_tiles">partition_tiles</a>, <a href="#topic+represampling">represampling</a>,
<a href="#topic+represampling_tile_bootstrap">represampling_tile_bootstrap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnm &lt;- as.tilename(c(2, 3))
tnm # 'X2:Y3'
as.numeric(tnm) # c(2,3)
</code></pre>

<hr>
<h2 id='dataset_distance'>Calculate mean nearest-neighbour distance between point datasets</h2><span id='topic+dataset_distance'></span>

<h3>Description</h3>

<p><code>dataset_distance</code> calculates Euclidean nearest-neighbour
distances between two point datasets and summarizes these distances using
some function, by default the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_distance(
  d1,
  d2,
  x_name = "x",
  y_name = "y",
  fun = mean,
  method = "euclidean",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_distance_+3A_d1">d1</code></td>
<td>
<p>a <code>data.frame</code> with (at least) columns with names given by <code>x_name</code>
and <code>y_name</code>; these contain the x and y coordinates, respectively.</p>
</td></tr>
<tr><td><code id="dataset_distance_+3A_d2">d2</code></td>
<td>
<p>see <code>d1</code>  - second set of points</p>
</td></tr>
<tr><td><code id="dataset_distance_+3A_x_name">x_name</code></td>
<td>
<p>name of column in <code>d1</code> and <code>d2</code> containing the x coordinates of
points.</p>
</td></tr>
<tr><td><code id="dataset_distance_+3A_y_name">y_name</code></td>
<td>
<p>same for y coordinates</p>
</td></tr>
<tr><td><code id="dataset_distance_+3A_fun">fun</code></td>
<td>
<p>function to be applied to the vector of nearest-neighbor
distances of <code>d1</code> from <code>d2</code>.</p>
</td></tr>
<tr><td><code id="dataset_distance_+3A_method">method</code></td>
<td>
<p>type of distance metric to be used; only <code>'euclidean'</code> is
currently supported.</p>
</td></tr>
<tr><td><code id="dataset_distance_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nearest-neighbour distances are calculated for each point in <code>d1</code>,
resulting in a vector of length <code>nrow(d1)</code>, and <code>fun</code> is applied to this
vector.
</p>


<h3>Value</h3>

<p>depends on <code>fun</code>; typically (e.g., <code>mean</code>) a numeric vector
of length 1
</p>


<h3>See Also</h3>

<p><a href="#topic+add.distance">add.distance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = rnorm(100), y = rnorm(100))
dataset_distance(df, df) # == 0
</code></pre>

<hr>
<h2 id='ecuador'>J. Muenchow's Ecuador landslide data set</h2><span id='topic+ecuador'></span>

<h3>Description</h3>

<p>Data set created by Jannes Muenchow, University of Erlangen-Nuremberg,
Germany.
These data should be cited as Muenchow et al. (2012) (see reference below).
This publication also contains additional information on data collection and
the geomorphology of the area. The data set provided here is (a subset of) the
one from the 'natural' part of the RBSF area and corresponds to landslide
distribution in the year 2000.
</p>


<h3>Format</h3>

<p>a <code>data.frame</code> with point samples of landslide and
non-landslide locations in a study area in the Andes of southern Ecuador.
</p>


<h3>References</h3>

<p>Muenchow, J., Brenning, A., Richter, M., 2012. Geomorphic process
rates of landslides along a humidity gradient in the tropical Andes.
<em>Geomorphology</em>, 139-140: 271-284. <a href="https://doi.org/10.1016/j.geomorph.2011.10.029">doi:10.1016/j.geomorph.2011.10.029</a>
</p>
<p>Brenning, A., 2005. Spatial prediction models for landslide hazards:
review, comparison and evaluation.
<em>Natural Hazards and Earth System Sciences</em>, 5(6): 853-862.
<a href="https://doi.org/10.5194/nhess-5-853-2005">doi:10.5194/nhess-5-853-2005</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
str(ecuador)
library(rpart)
ctrl &lt;- rpart.control(cp = 0.02)
fit &lt;- rpart(slides ~ dem + slope + hcurv + vcurv +
  log.carea + cslope, data = ecuador, control = ctrl)
par(xpd = TRUE)
plot(fit, compress = TRUE, main = "Muenchows landslide data set")
text(fit, use.n = TRUE)
</code></pre>

<hr>
<h2 id='err_default'>Default error function</h2><span id='topic+err_default'></span>

<h3>Description</h3>

<p>Calculate a variety of accuracy measures from observations and
predictions of numerical and categorical response variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>err_default(obs, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="err_default_+3A_obs">obs</code></td>
<td>
<p>factor, logical, or numeric vector with observations</p>
</td></tr>
<tr><td><code id="err_default_+3A_pred">pred</code></td>
<td>
<p>factor, logical, or numeric vector with predictions. Must be of
same type as <code>obs</code> with the exception that <code>pred</code> may be numeric if <code>obs</code>
is <code>factor</code> or <code>logical</code> ('soft' classification).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with (currently) the following components, depending on the
type of prediction problem:
</p>

<ul>
<li><p> 'hard' classification: Misclassification error, overall accuracy;
if two classes, sensitivity, specificity, positive predictive value (PPV),
negative predictive value (NPV), kappa
</p>
</li>
<li><p> 'soft' classification: area under the ROC curve, error and accuracy
at a obs&gt;0.5 dichotomization, false-positive rate (FPR; 1-specificity)
at 70, 80 and 90 percent sensitivity, true-positive rate (sensitivity)
at 80, 90 and 95 percent specificity.
</p>
</li>
<li><p> regression: Bias, standard deviation, mean squared error,
MAD (<a href="stats.html#topic+mad">mad</a>), median, interquartile range (<a href="stats.html#topic+IQR">IQR</a>)
of residuals
</p>
</li></ul>



<h3>Note</h3>

<p><code>NA</code> values are currently not handled by this function,
i.e. they will result in an error.
</p>


<h3>See Also</h3>

<p><span class="pkg">ROCR</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(1000)
# Two mock (soft) classification examples:
err_default(obs &gt; 0, rnorm(1000)) # just noise
err_default(obs &gt; 0, obs + rnorm(1000)) # some discrimination
# Three mock regression examples:
err_default(obs, rnorm(1000)) # just noise, but no bias
err_default(obs, obs + rnorm(1000)) # some association, no bias
err_default(obs, obs + 1) # perfect correlation, but with bias
</code></pre>

<hr>
<h2 id='get_small_tiles'>Identify small partitions that need to be fixed.</h2><span id='topic+get_small_tiles'></span>

<h3>Description</h3>

<p><code>get_small_tiles</code> identifies partitions (tiles) that are too
small according to some defined criterion / criteria (minimum number of
samples in tile and/or minimum fraction of entire dataset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_small_tiles(tile, min_n = NULL, min_frac = 0, ignore = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_small_tiles_+3A_tile">tile</code></td>
<td>
<p>factor: tile/partition names for all samples; names must be
coercible to class <a href="#topic+tilename">tilename</a>, i.e. of the form <code>'X4:Y2'</code> etc.</p>
</td></tr>
<tr><td><code id="get_small_tiles_+3A_min_n">min_n</code></td>
<td>
<p>integer (optional): minimum number of samples per partition_</p>
</td></tr>
<tr><td><code id="get_small_tiles_+3A_min_frac">min_frac</code></td>
<td>
<p>numeric &gt;0, &lt;1: minimum relative size of partition as
percentage of sample.</p>
</td></tr>
<tr><td><code id="get_small_tiles_+3A_ignore">ignore</code></td>
<td>
<p>character vector: names of tiles to be ignored, i.e. to be
retained even if the inclusion criteria are not met.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: names of tiles that are considered 'small'
according to these criteria
</p>


<h3>See Also</h3>

<p><a href="#topic+partition_tiles">partition_tiles</a>, <a href="#topic+tilename">tilename</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Muenchow et al. (2012), see ?ecuador
# Rectangular partitioning without removal of small tiles:
parti &lt;- partition_tiles(ecuador, nsplit = c(10, 10), reassign = FALSE)
summary(parti)
length(parti[[1]])
# Same in factor format for the application of get_small_tiles:
parti_fac &lt;- partition_tiles(ecuador,
  nsplit = c(10, 10), reassign = FALSE,
  return_factor = TRUE
)
get_small_tiles(parti_fac[[1]], min_n = 20) # tiles with less than 20 samples
parti2 &lt;- partition_tiles(ecuador,
  nsplit = c(10, 10), reassign = TRUE,
  min_n = 20, min_frac = 0
)
length(parti2[[1]]) # &lt; length(parti[[1]])
</code></pre>

<hr>
<h2 id='maipo'>Fruit-tree crop classification: the Maipo dataset</h2><span id='topic+maipo'></span>

<h3>Description</h3>

<p>This dataset is from a case study on fruit-tree crop classification
using a satellite image time series. The dataset should be
cited as Pena &amp; Brenning (2015), reference below. There are
7713 grid cells from 400 fields in this dataset, which makes it
necessary to apply spatial cross-validation at the field level
for model assessment (see <code><a href="#topic+partition_factor_cv">partition_factor_cv()</a></code>).
</p>


<h3>Format</h3>

<p>a <code>data.frame</code> with point samples (grid cells) of crop type
and Landsat-derived remote sensing features (spectral bands
and vegetation indices). In addition, UTM x/y coordinates and
a factor variable indicating which field a grid cell belongs to.
Spectral bands are coded as <code>bij</code> where <code>i</code> represents the image
date (early to late season, dates see paper), and <code>j</code> is the band
number.
</p>


<h3>References</h3>

<p>Pena, M.A., Brenning, A. (2015). Assessing fruit-tree
crop classification from Landsat-8 time series for the Maipo Valley,
Chile. <em>Remote Sensing of Environment</em>, 171: 234-244.
</p>

<hr>
<h2 id='partition_cv'>Partition the data for a (non-spatial) cross-validation</h2><span id='topic+partition_cv'></span>

<h3>Description</h3>

<p><code>partition_cv</code> creates a <a href="#topic+represampling">represampling</a> object for
<code>length(repetition)</code>-repeated <code>nfold</code>-fold cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_cv(
  data,
  coords = c("x", "y"),
  nfold = 10,
  repetition = 1,
  seed1 = NULL,
  return_factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_cv_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_cv_+3A_coords">coords</code></td>
<td>
<p>(ignored by <code>partition_cv</code>)</p>
</td></tr>
<tr><td><code id="partition_cv_+3A_nfold">nfold</code></td>
<td>
<p>number of partitions (folds) in <code>nfold</code>-fold cross-validation
partitioning</p>
</td></tr>
<tr><td><code id="partition_cv_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="partition_cv_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="partition_cv_+3A_return_factor">return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a <a href="#topic+represampling">represampling</a> object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not actually perform a cross-validation or
partition the data set itself; it simply creates a data structure
containing the indices of training and test samples.
</p>


<h3>Value</h3>

<p>If <code>return_factor = FALSE</code> (the default), a <a href="#topic+represampling">represampling</a> object.
Specifically, this is a (named) list of <code>length(repetition)</code> <code>resampling</code>
objects. Each of these <a href="#topic+resampling">resampling</a> objects is a list of length <code>nfold</code>
corresponding to the folds. Each fold is represented by a list of
containing the components <code>train</code> and <code>test</code>, specifying the indices of
training and test samples (row indices for <code>data</code>). If <code>return_factor = TRUE</code> (mainly used internally), a (named) list of length
<code>length(repetition)</code>. Each component of this list is a vector of length
<code>nrow(data)</code> of type <code>factor</code>, specifying for each sample the fold to which
it belongs. The factor levels are <code>factor(1:nfold)</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+represampling">represampling</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
## non-spatial cross-validation:
resamp &lt;- partition_cv(ecuador, nfold = 5, repetition = 5)
# plot(resamp, ecuador)
# first repetition, second fold, test set indices:
idx &lt;- resamp[["1"]][[2]]$test
# test sample used in this particular repetition and fold:
ecuador[idx, ]
</code></pre>

<hr>
<h2 id='partition_cv_strat'>Partition the data for a stratified (non-spatial) cross-validation</h2><span id='topic+partition_cv_strat'></span>

<h3>Description</h3>

<p><code>partition_cv_strat</code> creates a set of sample indices
corresponding to cross-validation test and training sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_cv_strat(
  data,
  coords = c("x", "y"),
  nfold = 10,
  return_factor = FALSE,
  repetition = 1,
  seed1 = NULL,
  strat
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_cv_strat_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_cv_strat_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations</p>
</td></tr>
<tr><td><code id="partition_cv_strat_+3A_nfold">nfold</code></td>
<td>
<p>number of partitions (folds) in <code>nfold</code>-fold cross-validation
partitioning</p>
</td></tr>
<tr><td><code id="partition_cv_strat_+3A_return_factor">return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a <a href="#topic+represampling">represampling</a> object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td></tr>
<tr><td><code id="partition_cv_strat_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="partition_cv_strat_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="partition_cv_strat_+3A_strat">strat</code></td>
<td>
<p>character: column in <code>data</code> containing a factor variable over
which the partitioning should be stratified; or factor vector of length
<code>nrow(data)</code>: variable over which to stratify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object, see also <code><a href="#topic+partition_cv">partition_cv()</a></code>.
<code>partition_strat_cv</code>, however, stratified with respect to the variable
<code>data[,strat]</code>; i.e., cross-validation partitioning is done within each set
<code>data[data[,strat]==i,]</code> (<code>i</code> in <code>levels(data[, strat])</code>), and the <code>i</code>th
folds of all levels are combined into one cross-validation fold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sperrorest">sperrorest()</a></code>, <code><a href="#topic+as.resampling">as.resampling()</a></code>, <code><a href="#topic+resample_strat_uniform">resample_strat_uniform()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
parti &lt;- partition_cv_strat(ecuador,
  strat = "slides", nfold = 5,
  repetition = 1
)
idx &lt;- parti[["1"]][[1]]$train
mean(ecuador$slides[idx] == "TRUE") / mean(ecuador$slides == "TRUE")
# always == 1
# Non-stratified cross-validation:
parti &lt;- partition_cv(ecuador, nfold = 5, repetition = 1)
idx &lt;- parti[["1"]][[1]]$train
mean(ecuador$slides[idx] == "TRUE") / mean(ecuador$slides == "TRUE")
# close to 1 because of large sample size, but with some random variation
</code></pre>

<hr>
<h2 id='partition_disc'>Leave-one-disc-out cross-validation and leave-one-out cross-validation</h2><span id='topic+partition_disc'></span><span id='topic+partition_loo'></span>

<h3>Description</h3>

<p><code>partition_disc</code> partitions the sample into training and tests
set by selecting circular test areas (possibly surrounded by an exclusion
buffer) and using the remaining samples as training samples
(leave-one-disc-out cross-validation). <code>partition_loo</code> creates training and
test sets for leave-one-out cross-validation with (optional) buffer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_disc(
  data,
  coords = c("x", "y"),
  radius,
  buffer = 0,
  ndisc = nrow(data),
  seed1 = NULL,
  return_train = TRUE,
  prob = NULL,
  replace = FALSE,
  repetition = 1
)

partition_loo(data, ndisc = nrow(data), replace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_disc_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_disc_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_radius">radius</code></td>
<td>
<p>radius of test area discs; performs leave-one-out resampling if
radius &lt;0.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_buffer">buffer</code></td>
<td>
<p>radius of additional 'neutral area' around test area discs that
is excluded from training and test sets; defaults to 0, i.e. all samples
are either in the test area or in the training area.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_ndisc">ndisc</code></td>
<td>
<p>Number of discs to be randomly selected; each disc constitutes a
separate test set. Defaults to <code>nrow(data)</code>, i.e. one disc around each
sample.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_return_train">return_train</code></td>
<td>
<p>If <code>FALSE</code>, returns only test sample; if <code>TRUE</code>, also the
training area.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_prob">prob</code></td>
<td>
<p>optional argument to <a href="base.html#topic+sample">sample</a>.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_replace">replace</code></td>
<td>
<p>optional argument to <a href="base.html#topic+sample">sample</a>: sampling with or without
replacement?</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_repetition">repetition</code></td>
<td>
<p>see <code>partition_cv</code>; however, see Note below: <code>repetition</code>
should normally be <code style="white-space: pre;">&#8288;= 1&#8288;</code> in this function.</p>
</td></tr>
<tr><td><code id="partition_disc_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>partition_disc</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object. Contains <code>length(repetition)</code> <code>resampling</code>
objects. Each of these contains <code>ndisc</code> lists with indices of test and (if
<code>return_train = TRUE</code>) training sets.
</p>


<h3>Note</h3>

<p>Test area discs are centered at (random) samples, not at general
random locations. Test area discs may (and likely will) overlap independently
of the value of <code>replace</code>. <code>replace</code> only controls the replacement
of the center point of discs when drawing center points from the samples.
</p>
<p><code>radius &lt; 0</code> does leave-one-out resampling with an optional buffer.
<code>radius = 0</code> is similar except that samples with identical coordinates
would fall within the test area disc.
</p>


<h3>References</h3>

<p>Brenning, A. 2005. Spatial prediction models for landslide
hazards: review, comparison and evaluation. Natural Hazards and Earth System
Sciences, 5(6): 853-862.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+partition_cv">partition_cv</a>, <a href="#topic+partition_kmeans">partition_kmeans</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
parti &lt;- partition_disc(ecuador,
  radius = 200, buffer = 200,
  ndisc = 5, repetition = 1:2
)
# plot(parti,ecuador)
summary(parti)

# leave-one-out with buffer:
parti.loo &lt;- partition_loo(ecuador, buffer = 200)
summary(parti)
</code></pre>

<hr>
<h2 id='partition_factor'>Partition the data for a (non-spatial) leave-one-factor-out
cross-validation based on a given, fixed partitioning</h2><span id='topic+partition_factor'></span>

<h3>Description</h3>

<p><code>partition_factor</code> creates a <a href="#topic+represampling">represampling</a> object, i.e. a set
of sample indices defining cross-validation test and training sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_factor(
  data,
  coords = c("x", "y"),
  fac,
  return_factor = FALSE,
  repetition = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_factor_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_factor_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="partition_factor_+3A_fac">fac</code></td>
<td>
<p>either the name of a variable (column) in <code>data</code>, or a vector of
type factor and length <code>nrow(data)</code> that contains the partitions to be used
for defining training and test samples.</p>
</td></tr>
<tr><td><code id="partition_factor_+3A_return_factor">return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a <a href="#topic+represampling">represampling</a> object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td></tr>
<tr><td><code id="partition_factor_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object, see also <a href="#topic+partition_cv">partition_cv</a> for details.
</p>


<h3>Note</h3>

<p>In this partitioning approach, all <code>repetition</code>s are identical and
therefore pseudo-replications.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+partition_cv">partition_cv</a>, <a href="#topic+as.resampling.factor">as.resampling.factor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
# I don't recommend using this partitioning for cross-validation,
# this is only for demonstration purposes:
breaks &lt;- quantile(ecuador$dem, seq(0, 1, length = 6))
ecuador$zclass &lt;- cut(ecuador$dem, breaks, include.lowest = TRUE)
summary(ecuador$zclass)
parti &lt;- partition_factor(ecuador, fac = "zclass")
# plot(parti,ecuador)
summary(parti)
</code></pre>

<hr>
<h2 id='partition_factor_cv'>Partition the data for a (non-spatial) k-fold cross-validation at the
group level</h2><span id='topic+partition_factor_cv'></span>

<h3>Description</h3>

<p><code>partition_factor_cv</code> creates a <a href="#topic+represampling">represampling</a> object, i.e. a
set of sample indices defining cross-validation test and training sets,
where partitions are obtained by resampling at the level of groups of
observations as defined by a given factor variable. This can be used, for
example, to resample agricultural data that is grouped by fields, at the
agricultural field level in order to preserve spatial autocorrelation
within fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_factor_cv(
  data,
  coords = c("x", "y"),
  fac,
  nfold = 10,
  repetition = 1,
  seed1 = NULL,
  return_factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_factor_cv_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_factor_cv_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="partition_factor_cv_+3A_fac">fac</code></td>
<td>
<p>either the name of a variable (column) in <code>data</code>, or a vector of
type factor and length <code>nrow(data)</code> that defines groups or clusters of
observations.</p>
</td></tr>
<tr><td><code id="partition_factor_cv_+3A_nfold">nfold</code></td>
<td>
<p>number of partitions (folds) in <code>nfold</code>-fold cross-validation
partitioning</p>
</td></tr>
<tr><td><code id="partition_factor_cv_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="partition_factor_cv_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="partition_factor_cv_+3A_return_factor">return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a <a href="#topic+represampling">represampling</a> object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object, see also <a href="#topic+partition_cv">partition_cv</a> for details.
</p>


<h3>Note</h3>

<p>In this partitioning approach, the number of factor levels in <code>fac</code>
must be large enough for this factor-level resampling to make sense.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+partition_cv">partition_cv</a>, <a href="#topic+partition_factor">partition_factor</a>,
<a href="#topic+as.resampling.factor">as.resampling.factor</a>
</p>

<hr>
<h2 id='partition_kmeans'>Partition samples spatially using k-means clustering of the
coordinates</h2><span id='topic+partition_kmeans'></span>

<h3>Description</h3>

<p><code>partition_kmeans</code> divides the study area into irregularly
shaped spatial partitions based on <em>k</em>-means (<a href="stats.html#topic+kmeans">kmeans</a>) clustering of
spatial coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_kmeans(
  data,
  coords = c("x", "y"),
  nfold = 10,
  repetition = 1,
  seed1 = NULL,
  return_factor = FALSE,
  balancing_steps = 1,
  order_clusters = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_kmeans_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_nfold">nfold</code></td>
<td>
<p>number of cross-validation folds, i.e. parameter <em>k</em> in
<em>k</em>-means clustering.</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_return_factor">return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a <a href="#topic+represampling">represampling</a> object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_balancing_steps">balancing_steps</code></td>
<td>
<p>if <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code>, perform <code>nfold</code>-means clustering
<code>balancing_steps</code> times, and pick the clustering that minimizes the Gini
index of the sample size distribution among the partitions. The idea is
that 'degenerate' partitions will be avoided, but this also has the side
effect of reducing variation among partitioning repetitions. More
meaningful constraints (e.g., minimum number of positive and negative
samples within each partition should be added in the future.</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_order_clusters">order_clusters</code></td>
<td>
<p>if <code>TRUE</code>, clusters are ordered by increasing x
coordinate of center point.</p>
</td></tr>
<tr><td><code id="partition_kmeans_+3A_...">...</code></td>
<td>
<p>additional arguments to <a href="stats.html#topic+kmeans">kmeans</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object, see also <a href="#topic+partition_cv">partition_cv</a> for details.
</p>


<h3>Note</h3>

<p>Default parameter settings may change in future releases.
</p>


<h3>References</h3>

<p>Brenning, A., Long, S., &amp; Fieguth, P. (2012).
Detecting rock glacier flow structures using Gabor filters and IKONOS
imagery. Remote Sensing of Environment, 125, 227-237.
doi:10.1016/j.rse.2012.07.005
</p>
<p>Russ, G. &amp; A. Brenning. 2010a. Data mining in precision agriculture:
Management of spatial information. In 13th International Conference on
Information Processing and Management of Uncertainty,
IPMU 2010; Dortmund; 28 June - 2 July 2010.
Lecture Notes in Computer Science, 6178 LNAI: 350-359.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+partition_cv">partition_cv</a>, <a href="#topic+partition_disc">partition_disc</a>, <a href="#topic+partition_tiles">partition_tiles</a>,
<a href="stats.html#topic+kmeans">kmeans</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
resamp &lt;- partition_kmeans(ecuador, nfold = 5, repetition = 2)
# plot(resamp, ecuador)
</code></pre>

<hr>
<h2 id='partition_tiles'>Partition the study area into rectangular tiles</h2><span id='topic+partition_tiles'></span>

<h3>Description</h3>

<p><code>partition_tiles</code> divides the study area into a specified number
of rectangular tiles. Optionally small partitions can be merged with
adjacent tiles to achieve a minimum number or percentage of samples in each
tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_tiles(
  data,
  coords = c("x", "y"),
  dsplit = NULL,
  nsplit = NULL,
  rotation = c("none", "random", "user"),
  user_rotation,
  offset = c("none", "random", "user"),
  user_offset,
  reassign = TRUE,
  min_frac = 0.025,
  min_n = 5,
  iterate = 1,
  return_factor = FALSE,
  repetition = 1,
  seed1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_tiles_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_dsplit">dsplit</code></td>
<td>
<p>optional vector of length 2: equidistance of splits in
(possibly rotated) x direction (<code>dsplit[1]</code>) and y direction (<code>dsplit[2]</code>)
used to define tiles. If <code>dsplit</code> is of length 1, its value is recycled.
Either <code>dsplit</code> or <code>nsplit</code> must be specified.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_nsplit">nsplit</code></td>
<td>
<p>optional vector of length 2: number of splits in (possibly
rotated) x direction (<code>nsplit[1]</code>) and y direction (<code>nsplit[2]</code>) used to
define tiles. If <code>nsplit</code> is of length 1, its value is recycled.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_rotation">rotation</code></td>
<td>
<p>indicates whether and how the rectangular grid should be
rotated; random rotation is only between <code>-45</code> and <code>+45</code> degrees.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_user_rotation">user_rotation</code></td>
<td>
<p>if <code>rotation='user'</code>, angles (in degrees) by which the
rectangular grid is to be rotated in each repetition. Either a vector of
same length as <code>repetition</code>, or a single number that will be replicated
<code>length(repetition)</code> times.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_offset">offset</code></td>
<td>
<p>indicates whether and how the rectangular grid should be
shifted by an offset.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_user_offset">user_offset</code></td>
<td>
<p>if <code>offset='user'</code>, a list (or vector) of two components
specifying a shift of the rectangular grid in (possibly rotated) x and y
direction. The offset values are relative values, a value of <code>0.5</code>
resulting in a one-half tile shift towards the left, or upward. If this is
a list, its first (second) component refers to the rotated x (y) direction,
and both components must have same length as <code>repetition</code> (or length 1). If
a vector of length 2 (or list components have length 1), the two values
will be interpreted as relative shifts in (rotated) x and y direction,
respectively, and will therefore be recycled as needed
(<code>length(repetition)</code> times each).</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_reassign">reassign</code></td>
<td>
<p>logical (default <code>TRUE</code>): if <code>TRUE</code>, 'small' tiles (as per
<code>min_frac</code> and <code>min_n</code> arguments and <a href="#topic+get_small_tiles">get_small_tiles</a>) are merged with
(smallest) adjacent tiles. If <code>FALSE</code>, small tiles are 'eliminated', i.e.
set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_min_frac">min_frac</code></td>
<td>
<p>numeric &gt;=0, &lt;1: minimum relative size of partition as
percentage of sample; argument passed to <a href="#topic+get_small_tiles">get_small_tiles</a>. Will be ignored
if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_min_n">min_n</code></td>
<td>
<p>integer &gt;=0: minimum number of samples per partition; argument
passed to <a href="#topic+get_small_tiles">get_small_tiles</a>. Will be ignored if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_iterate">iterate</code></td>
<td>
<p>argument to be passed to <a href="#topic+tile_neighbors">tile_neighbors</a></p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_return_factor">return_factor</code></td>
<td>
<p>if <code>FALSE</code> (default), return a <a href="#topic+represampling">represampling</a> object;
if <code>TRUE</code> (used internally by other sperrorest functions), return a
<code>list</code> containing factor vectors (see Value)</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="partition_tiles_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object. Contains <code>length(repetition)</code> <a href="#topic+resampling">resampling</a>
objects as repetitions. The exact number of folds / test-set tiles within
each <a href="#topic+resampling">resampling</a> objects depends on the spatial configuration of the data
set and possible cleaning steps (see <code>min_frac</code>, <code>min_n</code>).
</p>


<h3>Note</h3>

<p>Default parameter settings may change in future releases. This
function, especially the rotation and shifting part of it and the algorithm
for cleaning up small tiles is still a bit experimental. Use with caution.
For non-zero offsets (<code style="white-space: pre;">&#8288;offset!='none')&#8288;</code>), the number of tiles may actually
be greater than <code>nsplit[1]*nsplit[2]</code> because of fractional tiles lurking
into the study region. <code>reassign=TRUE</code> with suitable thresholds is
therefore recommended for non-zero (including random) offsets.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+as.resampling.factor">as.resampling.factor</a>, <a href="#topic+get_small_tiles">get_small_tiles</a>,
<a href="#topic+tile_neighbors">tile_neighbors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
set.seed(42)
parti &lt;- partition_tiles(ecuador, nsplit = c(4, 3), reassign = FALSE)
# plot(parti,ecuador)
# tile A4 has only 55 samples
# same partitioning, but now merge tiles with less than 100 samples to
# adjacent tiles:
parti2 &lt;- partition_tiles(ecuador,
  nsplit = c(4, 3), reassign = TRUE,
  min_n = 100
)
# plot(parti2,ecuador)
summary(parti2)
# tile B4 (in 'parti') was smaller than A3, therefore A4 was merged with B4,
# not with A3
# now with random rotation and offset, and tiles of 2000 m length:
parti3 &lt;- partition_tiles(ecuador,
  dsplit = 2000, offset = "random",
  rotation = "random", reassign = TRUE, min_n = 100
)
# plot(parti3, ecuador)
summary(parti3)
</code></pre>

<hr>
<h2 id='plot.represampling'>Plot spatial resampling objects</h2><span id='topic+plot.represampling'></span><span id='topic+plot.resampling'></span>

<h3>Description</h3>

<p><code>plot.represampling</code> displays the partitions or samples
corresponding arising from the resampling of a data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'represampling'
plot(x, data, coords = c("x", "y"), pch = "+", wiggle_sd = 0, ...)

## S3 method for class 'resampling'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.represampling_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+represampling">represampling</a> resp. <a href="#topic+resampling">resampling</a> object.</p>
</td></tr>
<tr><td><code id="plot.represampling_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> of samples containing at least the x and y
coordinates of samples as specified by <code>coords</code>.</p>
</td></tr>
<tr><td><code id="plot.represampling_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="plot.represampling_+3A_pch">pch</code></td>
<td>
<p>point symbol (to be passed to <a href="graphics.html#topic+points">points</a>).</p>
</td></tr>
<tr><td><code id="plot.represampling_+3A_wiggle_sd">wiggle_sd</code></td>
<td>
<p>'wiggle' the point locations in x and y direction to avoid
overplotting of samples drawn multiple times by bootstrap methods; this is
a standard deviation (in the units of the x/y coordinates) of a normal
distribution and defaults to 0 (no wiggling).</p>
</td></tr>
<tr><td><code id="plot.represampling_+3A_...">...</code></td>
<td>
<p>additional arguments to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not intended for samples obtained by resampling with
replacement (e.g., bootstrap) because training and test points will be
overplotted in that case. The size of the plotting region will also limit
the number of maps that can be displayed at once, i.e., the number of rows
(repetitions) and fields (columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
# non-spatial cross-validation:
resamp &lt;- partition_cv(ecuador, nfold = 5, repetition = 1:2)
# plot(resamp, ecuador)
# spatial cross-validation using k-means clustering:
resamp &lt;- partition_kmeans(ecuador, nfold = 5, repetition = 1:2)
# plot(resamp, ecuador)
</code></pre>

<hr>
<h2 id='remove_missing_levels'>remove_missing_levels</h2><span id='topic+remove_missing_levels'></span>

<h3>Description</h3>

<p>Accounts for missing factor levels present only in test data
but not in train data by setting values to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_missing_levels(fit, test_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_missing_levels_+3A_fit">fit</code></td>
<td>
<p>fitted model on training data</p>
</td></tr>
<tr><td><code id="remove_missing_levels_+3A_test_data">test_data</code></td>
<td>
<p>data to make predictions for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with matching factor levels to fitted model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- data.frame(
  response = rnorm(3),
  predictor = as.factor(c("A", "B", "C"))
)
model &lt;- lm(response ~ predictor, foo)
foo.new &lt;- data.frame(predictor = as.factor(c("A", "B", "C", "D")))
predict(model, newdata = remove_missing_levels(
  fit = model,
  test_data = foo.new
))
</code></pre>

<hr>
<h2 id='represampling_bootstrap'>Non-spatial bootstrap resampling</h2><span id='topic+represampling_bootstrap'></span>

<h3>Description</h3>

<p><code>represampling_bootstrap</code> draws a bootstrap random sample (with
replacement) from <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>represampling_bootstrap(
  data,
  coords = c("x", "y"),
  nboot = nrow(data),
  repetition = 1,
  seed1 = NULL,
  oob = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="represampling_bootstrap_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="represampling_bootstrap_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="represampling_bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>Size of bootstrap sample</p>
</td></tr>
<tr><td><code id="represampling_bootstrap_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="represampling_bootstrap_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="represampling_bootstrap_+3A_oob">oob</code></td>
<td>
<p>logical (default <code>FALSE</code>): if <code>TRUE</code>, use the out-of-bag sample as
the test sample; if <code>FALSE</code>, draw a second bootstrap sample of size <code>nboot</code>
independently to obtain a test sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+represampling">represampling</a> object. This is a (named) list containing
<code>length(repetition)</code>. <a href="#topic+resampling">resampling</a> objects. Each of these contains only one
list with indices of <code>train</code>ing and <code>test</code> samples. Indices are row indices
for <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
# only 10 bootstrap repetitions, normally use &gt;=100:
parti &lt;- represampling_bootstrap(ecuador, repetition = 10)
# plot(parti, ecuador) # careful: overplotting occurs
# because some samples are included in both the training and
# the test sample (possibly even multiple times)
</code></pre>

<hr>
<h2 id='represampling_disc_bootstrap'>Overlapping spatial block bootstrap using circular blocks</h2><span id='topic+represampling_disc_bootstrap'></span>

<h3>Description</h3>

<p><code>represampling_disc_bootstrap</code> performs a spatial block
bootstrap by resampling at the level of rectangular partitions or 'tiles'
generated by <code>partition_tiles</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>represampling_disc_bootstrap(
  data,
  coords = c("x", "y"),
  nboot,
  repetition = 1,
  seed1 = NULL,
  oob = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="represampling_disc_bootstrap_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="represampling_disc_bootstrap_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="represampling_disc_bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples; you may specify different values
for the training sample (<code>nboot[1]</code>) and for the test sample (<code>nboot[2]</code>).</p>
</td></tr>
<tr><td><code id="represampling_disc_bootstrap_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="represampling_disc_bootstrap_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="represampling_disc_bootstrap_+3A_oob">oob</code></td>
<td>
<p>logical (default <code>FALSE</code>): if <code>TRUE</code>, use the out-of-bag sample as
the test sample (the complement of the <code>nboot[1]</code> test set discs, minus the
buffer area as specified in the <code>...</code> arguments to <a href="#topic+partition_disc">partition_disc</a>); if
<code>FALSE</code>, draw a second bootstrap sample of size <code>nboot</code> independently to
obtain a test sample (sets of overlapping discs drawn with replacement).</p>
</td></tr>
<tr><td><code id="represampling_disc_bootstrap_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <a href="#topic+partition_disc">partition_disc</a>; note that a
<code>buffer</code> argument has not effect if <code>oob=FALSE</code>; see example below</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Performs <code>nboot</code> out of <code>nrow(data)</code> resampling of circular discs. This
is an <em>overlapping</em> spatial block bootstrap where the blocks are circular.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
# Overlapping disc bootstrap:
parti &lt;- represampling_disc_bootstrap(ecuador,
  radius = 200, nboot = 20,
  oob = FALSE
)
# plot(parti, ecuador)
# Note that a 'buffer' argument would make no difference because boostrap
# sets of discs are drawn independently for the training and test sample.
#
# Overlapping disc bootstrap for training sample, out-of-bag sample as test
# sample:
parti &lt;- represampling_disc_bootstrap(ecuador,
  radius = 200, buffer = 200,
  nboot = 10, oob = TRUE
)
# plot(parti,ecuador)
</code></pre>

<hr>
<h2 id='represampling_factor_bootstrap'>Bootstrap at an aggregated level</h2><span id='topic+represampling_factor_bootstrap'></span>

<h3>Description</h3>

<p><code>represampling_factor_bootstrap</code> resamples partitions defined by
a factor variable. This can be used for non-overlapping block bootstraps
and similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>represampling_factor_bootstrap(
  data,
  fac,
  repetition = 1,
  nboot = -1,
  seed1 = NULL,
  oob = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="represampling_factor_bootstrap_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="represampling_factor_bootstrap_+3A_fac">fac</code></td>
<td>
<p>defines a grouping or partitioning of the samples in <code>data</code>; three
possible types: (1) the name of a variable in <code>data</code> (coerced to factor if
not already a factor variable); (2) a factor variable (or a vector that can
be coerced to factor); (3) a list of factor variables (or vectors that can
be coerced to factor); this list must be of length <code>length(repetition)</code>,
and if it is named, the names must be equal to <code>as.character(repetition)</code>;
this list will typically be generated by a <code style="white-space: pre;">&#8288;partition.*&#8288;</code> function with
<code>return_factor = TRUE</code> (see Examples below)</p>
</td></tr>
<tr><td><code id="represampling_factor_bootstrap_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="represampling_factor_bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap replications used for generating the
bootstrap training sample (<code>nboot[1]</code>) and the test sample (<code>nboot[2]</code>);
<code>nboot[2]</code> is ignored (with a warning) if <code>oob = TRUE</code>. A value of <code>-1</code>
will be substituted with the number of levels of the factor variable,
corresponding to an <em>n</em> out of <em>n</em> bootstrap at the grouping level defined
by <code>fac</code>.</p>
</td></tr>
<tr><td><code id="represampling_factor_bootstrap_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="represampling_factor_bootstrap_+3A_oob">oob</code></td>
<td>
<p>if <code>TRUE</code>, the test sample will be the out-of-bag sample; if
<code>FALSE</code> (default), the test sample is an independently drawn bootstrap
sample of size <code>nboot[2]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nboot</code> refers to the number of groups (as defined by the factors)
to be drawn with replacement from the set of groups. I.e., if <code>fac</code> is a
factor variable, <code>nboot</code> would normally not be greater than <code>nlevels(fac)</code>,
<code>nlevels(fac)</code> being the default as per <code>nboot = -1</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+represampling_disc_bootstrap">represampling_disc_bootstrap</a>,
<a href="#topic+represampling_tile_bootstrap">represampling_tile_bootstrap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador)
# a dummy example for demonstration, performing bootstrap
# at the level of an arbitrary factor variable:
parti &lt;- represampling_factor_bootstrap(ecuador,
  factor(floor(ecuador$dem / 100)),
  oob = TRUE
)
# plot(parti,ecuador)
# using the factor bootstrap for a non-overlapping block bootstrap
# (see also represampling_tile_bootstrap):
fac &lt;- partition_tiles(ecuador,
  return_factor = TRUE, repetition = c(1:3),
  dsplit = 500, min_n = 200, rotation = "random",
  offset = "random"
)
parti &lt;- represampling_factor_bootstrap(ecuador, fac,
  oob = TRUE,
  repetition = c(1:3)
)
# plot(parti, ecuador)
</code></pre>

<hr>
<h2 id='represampling_kmeans_bootstrap'>Spatial block bootstrap at the level of spatial k-means clusters</h2><span id='topic+represampling_kmeans_bootstrap'></span>

<h3>Description</h3>

<p><code>represampling_kmeans_bootstrap</code> performs a non-overlapping
spatial block bootstrap by resampling at the level of irregularly-shaped
partitions generated by <a href="#topic+partition_kmeans">partition_kmeans</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>represampling_kmeans_bootstrap(
  data,
  coords = c("x", "y"),
  repetition = 1,
  nfold = 10,
  nboot = nfold,
  seed1 = NULL,
  oob = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_nfold">nfold</code></td>
<td>
<p>see <a href="#topic+partition_kmeans">partition_kmeans</a></p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>see <a href="#topic+represampling_factor_bootstrap">represampling_factor_bootstrap</a></p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_oob">oob</code></td>
<td>
<p>see <a href="#topic+represampling_factor_bootstrap">represampling_factor_bootstrap</a></p>
</td></tr>
<tr><td><code id="represampling_kmeans_bootstrap_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <a href="#topic+partition_kmeans">partition_kmeans</a></p>
</td></tr>
</table>

<hr>
<h2 id='represampling_tile_bootstrap'>Spatial block bootstrap using rectangular blocks</h2><span id='topic+represampling_tile_bootstrap'></span>

<h3>Description</h3>

<p><code>represampling_tile_bootstrap</code> performs a non-overlapping
spatial block bootstrap by resampling at the level of rectangular
partitions or 'tiles' generated by <a href="#topic+partition_tiles">partition_tiles</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>represampling_tile_bootstrap(
  data,
  coords = c("x", "y"),
  repetition = 1,
  nboot = -1,
  seed1 = NULL,
  oob = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="represampling_tile_bootstrap_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing at least the columns specified by
<code>coords</code></p>
</td></tr>
<tr><td><code id="represampling_tile_bootstrap_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="represampling_tile_bootstrap_+3A_repetition">repetition</code></td>
<td>
<p>numeric vector: cross-validation repetitions to be
generated. Note that this is not the number of repetitions, but the indices
of these repetitions. E.g., use <code>repetition = c(1:100)</code> to obtain (the
'first') 100 repetitions, and <code>repetition = c(101:200)</code> to obtain a
different set of 100 repetitions.</p>
</td></tr>
<tr><td><code id="represampling_tile_bootstrap_+3A_nboot">nboot</code></td>
<td>
<p>see <a href="#topic+represampling_factor_bootstrap">represampling_factor_bootstrap</a></p>
</td></tr>
<tr><td><code id="represampling_tile_bootstrap_+3A_seed1">seed1</code></td>
<td>
<p><code>seed1+i</code> is the random seed that will be used by <a href="base.html#topic+set.seed">set.seed</a> in
repetition <code>i</code> (<code>i</code> in <code>repetition</code>) to initialize the random number
generator before sampling from the data set.</p>
</td></tr>
<tr><td><code id="represampling_tile_bootstrap_+3A_oob">oob</code></td>
<td>
<p>see <a href="#topic+represampling_factor_bootstrap">represampling_factor_bootstrap</a></p>
</td></tr>
<tr><td><code id="represampling_tile_bootstrap_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <a href="#topic+partition_tiles">partition_tiles</a></p>
</td></tr>
</table>

<hr>
<h2 id='resample_factor'>Draw uniform random (sub)sample at the group level</h2><span id='topic+resample_factor'></span>

<h3>Description</h3>

<p><code>resample_factor</code> draws a random (sub)sample (with or without
replacement) of the groups or clusters identified by the <code>fac</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_factor(data, param = list(fac = "class", n = Inf, replace = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_factor_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>, rows represent samples</p>
</td></tr>
<tr><td><code id="resample_factor_+3A_param">param</code></td>
<td>
<p>a list with the following components: <code>fac</code> is a factor variable
of length <code>nrow(data)</code> or the name of a factor variable in <code>data</code>; <code>n</code> is a
numeric value specifying the size of the subsample (in terms of groups, not
observations); <code>replace</code> determines if resampling of groups is to be done
with or without replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>param$replace=FALSE</code>, a subsample of
<code>min(param$n,nlevel(data[,fac]))</code> groups will be drawn from <code>data</code>. If
<code>param$replace=TRUE</code>, the number of groups to be drawn is <code>param$n</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing a subset of the rows of <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample_strat_uniform">resample_strat_uniform()</a></code>, <code><a href="base.html#topic+sample">sample()</a></code>
</p>

<hr>
<h2 id='resample_strat_uniform'>Draw stratified random sample</h2><span id='topic+resample_strat_uniform'></span>

<h3>Description</h3>

<p><code>resample_strat_uniform</code> draws a stratified random sample (with
or without replacement) from the samples in <code>data</code>. Stratification is over
the levels of <code>data[, param$response]</code>. The same number of samples is drawn
within each level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_strat_uniform(
  data,
  param = list(strat = "class", nstrat = Inf, replace = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_strat_uniform_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>, rows represent samples</p>
</td></tr>
<tr><td><code id="resample_strat_uniform_+3A_param">param</code></td>
<td>
<p>a list with the following components: <code>strat</code> is either the name
of a factor variable in <code>data</code> that defines the stratification levels, or a
vector of type factor and length <code>nrow(data)</code>; <code>n</code> is a numeric value
specifying the size of the subsample; <code>replace</code> determines if sampling is
with or without replacement</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>param$replace=FALSE</code>, a subsample of size
<code>min(param$n,nrow(data))</code> will be drawn from <code>data</code>. If <code>param$replace=TRUE</code>,
the size of the subsample is <code>param$n</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing a subset of the rows of <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample_uniform">resample_uniform()</a></code>, <code><a href="base.html#topic+sample">sample()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecuador) # Muenchow et al. (2012), see ?ecuador
d &lt;- resample_strat_uniform(ecuador,
  param = list(strat = "slides", nstrat = 100)
)
nrow(d) # == 200
sum(d$slides == "TRUE") # == 100
</code></pre>

<hr>
<h2 id='resample_uniform'>Draw uniform random (sub)sample</h2><span id='topic+resample_uniform'></span>

<h3>Description</h3>

<p><code>resample_uniform</code> draws a random (sub)sample (with or without
replacement) from the samples in <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_uniform(data, param = list(n = Inf, replace = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_uniform_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>, rows represent samples</p>
</td></tr>
<tr><td><code id="resample_uniform_+3A_param">param</code></td>
<td>
<p>a list with the following components: <code>n</code> is a numeric value
specifying the size of the subsample; <code>replace</code> determines if sampling is
with or without replacement</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>param$replace=FALSE</code>, a subsample of size
<code>min(param$n,nrow(data))</code> will be drawn from <code>data</code>. If
<code>param$replace=TRUE</code>, the size of the subsample is <code>param$n</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing a subset of the rows of <code>data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample_strat_uniform">resample_strat_uniform()</a></code>, <code><a href="base.html#topic+sample">sample()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Muenchow et al. (2012), see ?ecuador
d &lt;- resample_uniform(ecuador, param = list(strat = "slides", n = 200))
# == 200
sum(d$slides == "TRUE")
</code></pre>

<hr>
<h2 id='runfolds'>runfolds</h2><span id='topic+runfolds'></span>

<h3>Description</h3>

<p>Runs model fitting, error estimation and variable importance on
fold level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runfolds(
  j = NULL,
  current_sample = NULL,
  data = NULL,
  i = NULL,
  formula = NULL,
  model_args = NULL,
  model_fun = NULL,
  pred_fun = NULL,
  imp_variables = NULL,
  imp_permutations = NULL,
  imp_sample_from = "test",
  err_fun = NULL,
  train_fun = NULL,
  importance = NULL,
  current_res = NULL,
  current_impo = NULL,
  pred_args = NULL,
  pooled_obs_train = NULL,
  pooled_obs_test = NULL,
  pooled_pred_train = NULL,
  response = NULL,
  progress = NULL,
  pooled_pred_test = NULL,
  coords = NULL,
  test_fun = NULL,
  imp_one_rep = NULL,
  do_gc = NULL,
  test_param = NULL,
  train_param = NULL
)
</code></pre>

<hr>
<h2 id='runreps'>runreps</h2><span id='topic+runreps'></span>

<h3>Description</h3>

<p>Runs model fitting, error estimation and variable importance
on fold level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runreps(
  current_sample = NULL,
  data = NULL,
  formula = NULL,
  model_args = NULL,
  do_gc = NULL,
  imp_one_rep = NULL,
  model_fun = NULL,
  pred_fun = NULL,
  imp_variables = NULL,
  imp_permutations = NULL,
  imp_sample_from = "test",
  err_fun = NULL,
  importance = NULL,
  current_res = NULL,
  current_impo = NULL,
  pred_args = NULL,
  progress = NULL,
  mode_fold = "sequential",
  pooled_obs_train = NULL,
  pooled_obs_test = NULL,
  pooled_pred_train = NULL,
  response = NULL,
  pooled_pred_test = NULL,
  test_fun = NULL,
  test_param = NULL,
  train_fun = NULL,
  train_param = NULL,
  coords = NULL,
  i = NULL
)
</code></pre>

<hr>
<h2 id='sperrorest'>Perform spatial error estimation and variable importance assessment</h2><span id='topic+sperrorest'></span>

<h3>Description</h3>

<p>sperrorest is a flexible interface for multiple types of
parallelized spatial and non-spatial cross-validation and bootstrap error
estimation and parallelized permutation-based assessment of spatial variable
importance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sperrorest(
  formula,
  data,
  coords = c("x", "y"),
  model_fun,
  model_args = list(),
  pred_fun = NULL,
  pred_args = list(),
  smp_fun = partition_cv,
  smp_args = list(),
  train_fun = NULL,
  train_param = NULL,
  test_fun = NULL,
  test_param = NULL,
  err_fun = err_default,
  imp_variables = NULL,
  imp_permutations = 1000,
  imp_sample_from = c("test", "train", "all"),
  importance = !is.null(imp_variables),
  distance = FALSE,
  do_gc = 1,
  progress = "all",
  benchmark = FALSE,
  mode_rep = c("future", "sequential", "loop"),
  mode_fold = c("sequential", "future", "loop"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sperrorest_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the variables used by the <code>model</code>. Only
simple formulas without interactions or nonlinear terms should be used,
e.g. <code>y~x1+x2+x3</code> but not <code>y~x1*x2+log(x3)</code>. Formulas involving interaction
and nonlinear terms may possibly work for error estimation but not for
variable importance assessment, but should be used with caution.
The formula <code>y~...</code> is not supported, but <code>y~1</code> (i.e. no predictors) is.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> with predictor and response variables. Training
and test samples will be drawn from this data set by <code>train_fun</code> and
<code>test_fun</code>, respectively.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_coords">coords</code></td>
<td>
<p>vector of length 2 defining the variables in <code>data</code> that
contain the x and y coordinates of sample locations.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_model_fun">model_fun</code></td>
<td>
<p>Function that fits a predictive model, such as <code>glm</code> or
<code>rpart</code>. The function must accept at least two arguments, the first one
being a formula and the second a data.frame with the learning sample.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_model_args">model_args</code></td>
<td>
<p>Arguments to be passed to <code>model_fun</code> (in addition to the
<code>formula</code> and <code>data</code> argument, which are provided by sperrorest)</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_pred_fun">pred_fun</code></td>
<td>
<p>Prediction function for a fitted model object created by
<code>model</code>. Must accept at least two arguments: the fitted <code>object</code> and a
<code>data.frame</code> <code>newdata</code> with data on which to predict the outcome.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_pred_args">pred_args</code></td>
<td>
<p>(optional) Arguments to <code>pred_fun</code> (in addition to the
fitted model object and the <code>newdata</code> argument, which are provided by
sperrorest).</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_smp_fun">smp_fun</code></td>
<td>
<p>A function for sampling training and test sets from <code>data</code>.
E.g. <a href="#topic+partition_kmeans">partition_kmeans</a> for spatial cross-validation using spatial
<em>k</em>-means clustering.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_smp_args">smp_args</code></td>
<td>
<p>(optional) Arguments to be passed to <code>smp_fun</code>.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_train_fun">train_fun</code></td>
<td>
<p>(optional) A function for resampling or subsampling the
training sample in order to achieve, e.g., uniform sample sizes on all
training sets, or maintaining a certain ratio of positives and negatives in
training sets. E.g. <a href="#topic+resample_uniform">resample_uniform</a> or <a href="#topic+resample_strat_uniform">resample_strat_uniform</a>.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_train_param">train_param</code></td>
<td>
<p>(optional) Arguments to be passed to <code>resample_fun</code>.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_test_fun">test_fun</code></td>
<td>
<p>(optional) Like <code>train_fun</code> but for the test set.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_test_param">test_param</code></td>
<td>
<p>(optional) Arguments to be passed to <code>test_fun</code>.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_err_fun">err_fun</code></td>
<td>
<p>A function that calculates selected error measures from the
known responses in <code>data</code> and the model predictions delivered by
<code>pred_fun</code>. E.g. <a href="#topic+err_default">err_default</a> (the default).</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_imp_variables">imp_variables</code></td>
<td>
<p>(optional; used if <code>importance = TRUE</code>). Variables for
which permutation-based variable importance assessment is performed. If
<code>importance = TRUE</code> and <code>imp_variables</code> == <code>NULL</code>, all variables in
<code>formula</code> will be used.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_imp_permutations">imp_permutations</code></td>
<td>
<p>(optional; used if <code>importance = TRUE</code>). Number of
permutations used for variable importance assessment.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_imp_sample_from">imp_sample_from</code></td>
<td>
<p>(default: <code>"test"</code>): specified if the permuted feature
values should be taken from the test set, the training set (a rather unlikely
choice), or the entire sample (<code>"all"</code>). The latter is useful in
leave-one-out resampling situations where the test set is simply too small
to perform any kind of resampling. In any case importances are
always estimates on the test set. (Note that resampling with replacement is
used if the test set is larger than the set from which the permuted values
are to be taken.)</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_importance">importance</code></td>
<td>
<p>logical (default: <code>FALSE</code>): perform permutation-based
variable importance assessment?</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_distance">distance</code></td>
<td>
<p>logical (default: <code>FALSE</code>): if <code>TRUE</code>, calculate mean
nearest-neighbour distances from test samples to training samples using
<a href="#topic+add.distance.represampling">add.distance.represampling</a>.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_do_gc">do_gc</code></td>
<td>
<p>numeric (default: 1): defines frequency of memory garbage
collection by calling <a href="base.html#topic+gc">gc</a>; if <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>, no garbage collection; if <code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code>, run
a <a href="base.html#topic+gc">gc</a> after each repetition; if <code style="white-space: pre;">&#8288;&gt;= 2&#8288;</code>, after each fold.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_progress">progress</code></td>
<td>
<p>character (default: <code>all</code>): Whether to show progress
information (if possible). Default shows repetition, fold and (if enabled)
variable importance progress. Set to <code>"rep"</code> for repetition information
only or <code>FALSE</code> for no progress information.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_benchmark">benchmark</code></td>
<td>
<p>(optional) logical (default: <code>FALSE</code>): if <code>TRUE</code>, perform
benchmarking and return <code>sperrorestbenchmark</code> object.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_mode_rep">mode_rep</code>, <code id="sperrorest_+3A_mode_fold">mode_fold</code></td>
<td>
<p>character (default: <code>"future"</code> and <code>"sequential"</code>,
respectively): specifies whether to parallelize the execution at the repetition
level, at the fold level, or not at all.
Parallel execution uses <code>future.apply::future_lapply()</code> (see details below).
It is only possible to parallelize at the repetition level or at
the fold level.
The <code>"loop"</code> option uses a <code>for</code> loop instead of an <code>lappy</code>
function; this option is for debugging purposes.</p>
</td></tr>
<tr><td><code id="sperrorest_+3A_verbose">verbose</code></td>
<td>
<p>Controls the amount of information printed while processing.
Defaults to 0 (no output).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Custom predict functions passed to <code>pred_fun</code>, which consist of
multiple child functions, must be defined in one function.
</p>


<h3>Value</h3>

<p>A list (object of class sperrorest) with (up to) six components:
</p>

<ul>
<li><p> error_rep: <code>sperrorestreperror</code> containing
predictive performances at the repetition level
</p>
</li>
<li><p> error_fold: <code>sperroresterror</code> object containing predictive
performances at the fold level
</p>
</li>
<li><p> represampling: <a href="#topic+represampling">represampling</a> object
</p>
</li>
<li><p> importance: <code>sperrorestimportance</code> object containing
permutation-based variable importances at the fold level
</p>
</li>
<li><p> benchmark: <code>sperrorestbenchmark</code> object containing
information on the system the code is running on, starting and
finishing times, number of available CPU cores and runtime performance
</p>
</li>
<li><p> package_version: <code>sperrorestpackageversion</code> object containing
information about the sperrorest package version
</p>
</li></ul>



<h3>Parallelization</h3>

<p>Running in parallel is supported via package <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a>.
Have a look at <code>vignette("future-1-overview", package = "future")</code>.
In short: Choose a backend and specify the number of workers, then call
<code>sperrorest()</code> as usual. Example:
</p>
<div class="sourceCode r"><pre>future::plan(future.callr::callr, workers = 2)
sperrorest()
</pre></div>
<p>Parallelization at the repetition is recommended when using
repeated cross-validation. If the 'granularity' of parallelized
function calls is too fine, the overall runtime will be very
poor since the overhead for passing arguments and handling
environments becomes too large. Use fold-level parallelization
only when the processing time of individual folds is very
large and the number of repetitions is small or equals 1.
</p>
<p>Note that nested calls to <code>future</code> are not possible.
Therefore a sequential <code>sperrorest</code> call should be used for
hyperparameter tuning in a nested cross-validation.
</p>


<h3>References</h3>

<p>Brenning, A. 2012. Spatial cross-validation and bootstrap for
the assessment of prediction rules in remote sensing: the R package
'sperrorest'.
2012 IEEE International Geoscience and Remote Sensing Symposium (IGARSS),
23-27 July 2012, p. 5372-5375.
<a href="https://ieeexplore.ieee.org/document/6352393">https://ieeexplore.ieee.org/document/6352393</a>
</p>
<p>Brenning, A. 2005. Spatial prediction models for landslide hazards: review,
comparison and evaluation. Natural Hazards and Earth System Sciences,
5(6), 853-862. <a href="https://doi.org/10.5194/nhess-5-853-2005">doi:10.5194/nhess-5-853-2005</a>
</p>
<p>Brenning, A., S. Long &amp; P. Fieguth. 2012. Detecting rock glacier
flow structures using Gabor filters and IKONOS imagery.
Remote Sensing of Environment, 125, 227-237.
<a href="https://doi.org/10.1016/j.rse.2012.07.005">doi:10.1016/j.rse.2012.07.005</a>
</p>
<p>Russ, G. &amp; A. Brenning. 2010a. Data mining in precision agriculture:
Management of spatial information. In 13th International Conference on
Information Processing and Management of Uncertainty, IPMU 2010; Dortmund;
28 June - 2 July 2010. Lecture Notes in Computer Science, 6178 LNAI: 350-359.
</p>
<p>Russ, G. &amp; A. Brenning. 2010b. Spatial variable importance assessment for
yield prediction in Precision Agriculture. In Advances in Intelligent
Data Analysis IX, Proceedings, 9th International Symposium,
IDA 2010, Tucson, AZ, USA, 19-21 May 2010.
Lecture Notes in Computer Science, 6065 LNCS: 184-195.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------------------
## Classification tree example using non-spatial partitioning
## ------------------------------------------------------------

# Muenchow et al. (2012), see ?ecuador
fo &lt;- slides ~ dem + slope + hcurv + vcurv + log.carea + cslope

library(rpart)
mypred_part &lt;- function(object, newdata) predict(object, newdata)[, 2]
ctrl &lt;- rpart.control(cp = 0.005) # show the effects of overfitting
# show the effects of overfitting
fit &lt;- rpart(fo, data = ecuador, control = ctrl)

### Non-spatial cross-validation:
mypred_part &lt;- function(object, newdata) predict(object, newdata)[, 2]
nsp_res &lt;- sperrorest(
  data = ecuador, formula = fo,
  model_fun = rpart,
  model_args = list(control = ctrl),
  pred_fun = mypred_part,
  progress = TRUE,
  smp_fun = partition_cv,
  smp_args = list(repetition = 1:2, nfold = 3)
)
summary(nsp_res$error_rep)
summary(nsp_res$error_fold)
summary(nsp_res$represampling)
# plot(nsp_res$represampling, ecuador)

### Spatial cross-validation:
sp_res &lt;- sperrorest(
  data = ecuador, formula = fo,
  model_fun = rpart,
  model_args = list(control = ctrl),
  pred_fun = mypred_part,
  progress = TRUE,
  smp_fun = partition_kmeans,
  smp_args = list(repetition = 1:2, nfold = 3)
)
summary(sp_res$error_rep)
summary(sp_res$error_fold)
summary(sp_res$represampling)
# plot(sp_res$represampling, ecuador)

smry &lt;- data.frame(
  nonspat_training = unlist(summary(nsp_res$error_rep,
    level = 1
  )$train_auroc),
  nonspat_test = unlist(summary(nsp_res$error_rep,
    level = 1
  )$test_auroc),
  spatial_training = unlist(summary(sp_res$error_rep,
    level = 1
  )$train_auroc),
  spatial_test = unlist(summary(sp_res$error_rep,
    level = 1
  )$test_auroc)
)
boxplot(smry,
  col = c("red", "red", "red", "green"),
  main = "Training vs. test, nonspatial vs. spatial",
  ylab = "Area under the ROC curve"
)
</code></pre>

<hr>
<h2 id='summary.represampling'>title Summary statistics for a resampling objects</h2><span id='topic+summary.represampling'></span><span id='topic+summary.resampling'></span>

<h3>Description</h3>

<p>Calculates sample sizes of training and test sets within
repetitions and folds of a <code>resampling</code> or <code>represampling</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'represampling'
summary(object, ...)

## S3 method for class 'resampling'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.represampling_+3A_object">object</code></td>
<td>
<p>A <code>resampling</code> or <code>represampling</code> object.</p>
</td></tr>
<tr><td><code id="summary.represampling_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s summarizing the sample sizes of training and
test sets in each fold of each repetition.
</p>

<hr>
<h2 id='summary.sperroresterror'>Summarize error statistics obtained by sperrorest</h2><span id='topic+summary.sperroresterror'></span>

<h3>Description</h3>

<p><code>summary.sperroresterror</code> calculates mean, standard deviation,
median etc. of the calculated error measures at the specified level
(overall, repetition, or fold). <code>summary.sperrorestreperror</code> does the same
with the pooled error, at the overall or repetition level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sperroresterror'
summary(object, level = 0, pooled = TRUE, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sperroresterror_+3A_object">object</code></td>
<td>
<p><code>sperroresterror</code> resp. <code>sperrorestcombinederror</code> error object
calculated by <a href="#topic+sperrorest">sperrorest</a></p>
</td></tr>
<tr><td><code id="summary.sperroresterror_+3A_level">level</code></td>
<td>
<p>Level at which errors are summarized: 0: overall (i.e. across
all repetitions); 1: repetition; 2: fold</p>
</td></tr>
<tr><td><code id="summary.sperroresterror_+3A_pooled">pooled</code></td>
<td>
<p>If <code>TRUE</code> (default), mean and standard deviation etc are
calculated between fold-level error estimates. If <code>FALSE</code>, apply first a
<a href="stats.html#topic+weighted.mean">weighted.mean</a> among folds before calculating mean, standard deviation etc
among repetitions. See also Details.</p>
</td></tr>
<tr><td><code id="summary.sperroresterror_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove <code>NA</code> values? See <a href="base.html#topic+mean">mean</a> etc.</p>
</td></tr>
<tr><td><code id="summary.sperroresterror_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let's use an example to explain the <code>error_rep</code> argument. E.g.,
assume we are using 100-repeated 10-fold cross-validation. If <code>error_rep = TRUE</code> (default), the mean and standard deviation calculated when
summarizing at <code>level = 0</code> are calculated across the error estimates
obtained for each of the <code>100*10 = 1000</code> folds. If <code>error_rep = FALSE</code>,
mean and standard deviation are calculated across the <code>100</code> repetitions,
using the weighted average of the fold-level errors to calculate an error
value for the entire sample. This will essentially not affect the mean
value but of course the standard deviation of the error.
</p>
<p><code>error_rep = FALSE</code> is not recommended, it is mainly for testing purposes;
when the test sets are small (as in leave-one-out cross-validation, in the
extreme case), consider running <a href="#topic+sperrorest">sperrorest</a> with <code>error_rep = TRUE</code> and
examine only the <code>error_rep</code> component of its result.
</p>


<h3>Value</h3>

<p>Depending on the level of aggregation, a <code>list</code> or <code>data.frame</code> with
mean, and at level 0 also standard deviation, median and IQR of the error
measures.
</p>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>
</p>

<hr>
<h2 id='summary.sperrorestimportance'>Summarize variable importance statistics obtained by sperrorest</h2><span id='topic+summary.sperrorestimportance'></span>

<h3>Description</h3>

<p><code>summary.sperrorestimportance</code> calculated mean, standard
deviation, median etc. of the calculated error measures at the specified
level (overall, repetition, or fold).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sperrorestimportance'
summary(object, level = 0, na.rm = TRUE, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sperrorestimportance_+3A_object">object</code></td>
<td>
<p><code>sperrorestimportance</code> object calculated by <a href="#topic+sperrorest">sperrorest</a> called
with argument <code>importance = TRUE</code></p>
</td></tr>
<tr><td><code id="summary.sperrorestimportance_+3A_level">level</code></td>
<td>
<p>Level at which errors are summarized: 0: overall (i.e. across
all repetitions); 1: repetition; 2: fold</p>
</td></tr>
<tr><td><code id="summary.sperrorestimportance_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove <code>NA</code> values? See <a href="base.html#topic+mean">mean</a> etc.</p>
</td></tr>
<tr><td><code id="summary.sperrorestimportance_+3A_which">which</code></td>
<td>
<p>optional character vector specifying selected variables for
which the importances should be summarized</p>
</td></tr>
<tr><td><code id="summary.sperrorestimportance_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list or data.frame, depending on the <code>level</code> of aggregation
</p>

<hr>
<h2 id='summary.sperrorestreperror'>Summary and print methods for sperrorest results</h2><span id='topic+summary.sperrorestreperror'></span><span id='topic+summary.sperrorest'></span><span id='topic+print.sperrorestimportance'></span><span id='topic+print.sperroresterror'></span><span id='topic+print.sperrorestreperror'></span><span id='topic+print.sperrorest'></span><span id='topic+print.sperrorestbenchmarks'></span><span id='topic+print.sperrorestpackageversion'></span>

<h3>Description</h3>

<p>Summary methods provide varying level of detail while print
methods provide full details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sperrorestreperror'
summary(object, level = 0, na.rm = TRUE, ...)

## S3 method for class 'sperrorest'
summary(object, ...)

## S3 method for class 'sperrorestimportance'
print(x, ...)

## S3 method for class 'sperroresterror'
print(x, ...)

## S3 method for class 'sperrorestreperror'
print(x, ...)

## S3 method for class 'sperrorest'
print(x, ...)

## S3 method for class 'sperrorestbenchmarks'
print(x, ...)

## S3 method for class 'sperrorestpackageversion'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sperrorestreperror_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+sperrorest">sperrorest</a> object</p>
</td></tr>
<tr><td><code id="summary.sperrorestreperror_+3A_level">level</code></td>
<td>
<p>Level at which errors are summarized: 0: overall (i.e. across
all repetitions); 1: repetition; 2: fold</p>
</td></tr>
<tr><td><code id="summary.sperrorestreperror_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove <code>NA</code> values? See <a href="base.html#topic+mean">mean</a> etc.</p>
</td></tr>
<tr><td><code id="summary.sperrorestreperror_+3A_...">...</code></td>
<td>
<p>additional arguments for <a href="#topic+summary.sperroresterror">summary.sperroresterror</a> or
<a href="#topic+summary.sperrorestimportance">summary.sperrorestimportance</a></p>
</td></tr>
<tr><td><code id="summary.sperrorestreperror_+3A_x">x</code></td>
<td>
<p>Depending on method, a <a href="#topic+sperrorest">sperrorest</a>, <code>sperroresterror</code> or
<code>sperrorestimportance</code> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+sperrorest">sperrorest</a>, <a href="#topic+summary.sperroresterror">summary.sperroresterror</a>,
<a href="#topic+summary.sperrorestimportance">summary.sperrorestimportance</a>
</p>

<hr>
<h2 id='tile_neighbors'>Determine the names of neighbouring tiles in a rectangular pattern</h2><span id='topic+tile_neighbors'></span>

<h3>Description</h3>

<p>This based on 'counting' up and down based on the tile name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile_neighbors(nm, tileset, iterate = 0, diagonal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile_neighbors_+3A_nm">nm</code></td>
<td>
<p>Character string or factor: name of a tile, e.g., <code>'X4:Y6'</code></p>
</td></tr>
<tr><td><code id="tile_neighbors_+3A_tileset">tileset</code></td>
<td>
<p>Admissible tile names; if missing and <code>nm</code> is a factor
variable, then <code>levels(nm)</code> is used as a default for <code>tileset</code>.</p>
</td></tr>
<tr><td><code id="tile_neighbors_+3A_iterate">iterate</code></td>
<td>
<p>internal - do not change default: to control behaviour in an
interactive call to this function.</p>
</td></tr>
<tr><td><code id="tile_neighbors_+3A_diagonal">diagonal</code></td>
<td>
<p>if <code>TRUE</code>, diagonal neighbours are also considered
neighbours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string.
</p>

<hr>
<h2 id='transfer_parallel_output'>transfer_parallel_output</h2><span id='topic+transfer_parallel_output'></span>

<h3>Description</h3>

<p>transfers output of parallel calls to runreps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfer_parallel_output(
  my_res = NULL,
  res = NULL,
  impo = NULL,
  pooled_error = NULL
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
