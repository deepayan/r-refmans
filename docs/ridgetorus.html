<!DOCTYPE html><html><head><title>Help for package ridgetorus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ridgetorus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biv_lrt'><p>Tests of homogeneity and independence in bivariate sine von</p>
Mises and wrapped Cauchy distributions</a></li>
<li><a href='#bvm'><p>Density evaluation, sampling, and parameter estimation of the</p>
bivariate sine von Mises distribution</a></li>
<li><a href='#bwc'><p>Density evaluation, sampling, and parameter estimation of the</p>
bivariate wrapped Cauchy distribution</a></li>
<li><a href='#bwn'><p>Density evaluation, sampling, and parameter estimation of the</p>
bivariate wrapped normal distribution</a></li>
<li><a href='#earthquakes'><p>Japanese earthquakes dataset</p></a></li>
<li><a href='#frechet'><p>Fréchet statistics on the torus</p></a></li>
<li><a href='#ridge_curve'><p>Fourier-fitted ridge curve and related utilities</p></a></li>
<li><a href='#ridge_distr'><p>Connected component of the toroidal density ridge of a bivariate sine</p>
von Mises, bivariate wrapped Cauchy, and bivariate wrapped normal</a></li>
<li><a href='#ridge_fourier_fit'><p>Fourier expansion of a given curve</p></a></li>
<li><a href='#ridge_pca'><p>Toroidal PCA via density ridges</p></a></li>
<li><a href='#ridge_scores'><p>Scores and scales for Fourier-fitted ridge curves</p></a></li>
<li><a href='#ridgetorus-package'><p><code>ridgetorus</code>: PCA on the Torus via Density Ridges</p></a></li>
<li><a href='#santabarbara'><p>Santa Barbara currents</p></a></li>
<li><a href='#show_ridge_pca'><p>Illustration of toroidal PCA via density ridges</p></a></li>
<li><a href='#torus_dist'><p>Toroidal distances</p></a></li>
<li><a href='#torus_pairs'><p>Toroidal pairs plot</p></a></li>
<li><a href='#wind'><p>Texas wind dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>PCA on the Torus via Density Ridges</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of a Principal Component Analysis (PCA) in the
    torus via density ridge estimation. The main function, ridge_pca(), obtains
    the relevant density ridge for bivariate sine von Mises and bivariate
    wrapped Cauchy distribution models and provides the associated scores and
    variance decomposition. Auxiliary functions for evaluating, fitting, and
    sampling these models are also provided. The package provides replicability
    to García-Portugués and Prieto-Tirado (2023) 
    &lt;<a href="https://doi.org/10.1007%2Fs11222-023-10273-9">doi:10.1007/s11222-023-10273-9</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>rootSolve, sdetorus, sphunif, circular</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BAMBI, covr, DirStats, GGally, ggplot2, knitr, markdown,
mvtnorm, numDeriv, rmarkdown, testthat, viridisLite</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/ridgetorus">https://github.com/egarpor/ridgetorus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/ridgetorus">https://github.com/egarpor/ridgetorus</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 16:09:54 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Arturo Prieto-Tirado
    <a href="https://orcid.org/0000-0003-0193-2988"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='biv_lrt'>Tests of homogeneity and independence in bivariate sine von
Mises and wrapped Cauchy distributions</h2><span id='topic+biv_lrt'></span>

<h3>Description</h3>

<p>Performs the following likelihood ratio tests for the
concentrations in bivariate sine von Mises and wrapped Cauchy distributions:
(1) <em>homogeneity</em>: <code class="reqn">H_0:\kappa_1=\kappa_2</code> vs.
<code class="reqn">H_1:\kappa_1\neq\kappa_2</code>, and <code class="reqn">H_0:\xi_1=\xi_2</code> vs.
<code class="reqn">H_1:\xi_1\neq\xi_2</code>, respectively;
(2) <em>independence</em>: <code class="reqn">H_0:\lambda=0</code> vs.
<code class="reqn">H_1:\lambda\neq0</code>, and <code class="reqn">H_0:\rho=0</code> vs. <code class="reqn">H_1:\rho\neq0</code>.
The tests (1) and (2) can be performed simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biv_lrt(x, hom = FALSE, indep = FALSE, fit_mle = NULL, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biv_lrt_+3A_x">x</code></td>
<td>
<p>matrix of dimension  <code>c(n, 2)</code> containing the <code>n</code>
observations of the pair of angles.</p>
</td></tr>
<tr><td><code id="biv_lrt_+3A_hom">hom</code></td>
<td>
<p>test the homogeneity hypothesis? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biv_lrt_+3A_indep">indep</code></td>
<td>
<p>test the independence hypothesis? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="biv_lrt_+3A_fit_mle">fit_mle</code></td>
<td>
<p>output of <code><a href="#topic+fit_bvm_mle">fit_bvm_mle</a></code> or
<code><a href="#topic+fit_bwc_mle">fit_bwc_mle</a></code> with <code>hom = FALSE</code>. Computed internally if
not provided.</p>
</td></tr>
<tr><td><code id="biv_lrt_+3A_type">type</code></td>
<td>
<p>either <code>"bvm"</code> (bivariate sine von Mises) or <code>"bwc"</code>
(bivariate wrapped Cauchy).</p>
</td></tr>
<tr><td><code id="biv_lrt_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code><a href="#topic+fit_bvm_mle">fit_bvm_mle</a></code> and
<code><a href="#topic+fit_bwc_mle">fit_bwc_mle</a></code>, such as <code>start</code>, <code>lower</code>, or
<code>upper</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code>:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the likelihood ratio test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the <code class="reqn">p</code>-value of the test (computed using the asymptotic
distribution).</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>description of the type of test performed.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of <code>theta</code>.</p>
</td></tr>
<tr><td><code>fit_mle</code></td>
<td>
<p>maximum likelihood fit.</p>
</td></tr>
<tr><td><code>fit_null</code></td>
<td>
<p>maximum likelihood fit under the null hypothesis.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kato, S. and Pewsey, A. (2015). A Möbius transformation-induced distribution
on the torus. <em>Biometrika</em>, 102(2):359&ndash;370. <a href="https://doi.org/10.1093/biomet/asv003">doi:10.1093/biomet/asv003</a>
</p>
<p>Singh, H., Hnizdo, V., and Demchuk, E. (2002). Probabilistic model for two
dependent circular variables. <em>Biometrika</em>, 89(3):719&ndash;723.
<a href="https://doi.org/10.1093/biomet/89.3.719">doi:10.1093/biomet/89.3.719</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Bivariate sine von Mises

# Homogeneity
n &lt;- 200
mu &lt;- c(0, 0)
kappa_0 &lt;- c(1, 1, 0.5)
kappa_1 &lt;- c(0.7, 0.1, 0.25)
samp_0 &lt;- r_bvm(n = n, mu = mu, kappa = kappa_0)
samp_1 &lt;- r_bvm(n = n, mu = mu, kappa = kappa_1)
biv_lrt(x = samp_0, hom = TRUE, type = "bvm")
biv_lrt(x = samp_1, hom = TRUE, type = "bvm")

# Independence
kappa_0 &lt;- c(0, 1, 0)
kappa_1 &lt;- c(1, 0, 1)
samp_0 &lt;- r_bvm(n = n, mu = mu, kappa = kappa_0)
samp_1 &lt;- r_bvm(n = n, mu = mu, kappa = kappa_1)
biv_lrt(x = samp_0, indep = TRUE, type = "bvm")
biv_lrt(x = samp_1, indep = TRUE, type = "bvm")

# Independence and homogeneity
kappa_0 &lt;- c(3, 3, 0)
kappa_1 &lt;- c(3, 1, 0)
samp_0 &lt;- r_bvm(n = n, mu = mu, kappa = kappa_0)
samp_1 &lt;- r_bvm(n = n, mu = mu, kappa = kappa_1)
biv_lrt(x = samp_0, indep = TRUE, hom = TRUE, type = "bvm")
biv_lrt(x = samp_1, indep = TRUE, hom = TRUE, type = "bvm")

## Bivariate wrapped Cauchy

# Homogeneity
xi_0 &lt;- c(0.5, 0.5, 0.25)
xi_1 &lt;- c(0.7, 0.1, 0.5)
samp_0 &lt;- r_bwc(n = n, mu = mu, xi = xi_0)
samp_1 &lt;- r_bwc(n = n, mu = mu, xi = xi_1)
biv_lrt(x = samp_0, hom = TRUE, type = "bwc")
biv_lrt(x = samp_1, hom = TRUE, type = "bwc")

# Independence
xi_0 &lt;- c(0.1, 0.5, 0)
xi_1 &lt;- c(0.3, 0.5, 0.2)
samp_0 &lt;- r_bwc(n = n, mu = mu, xi = xi_0)
samp_1 &lt;- r_bwc(n = n, mu = mu, xi = xi_1)
biv_lrt(x = samp_0, indep = TRUE, type = "bwc")
biv_lrt(x = samp_1, indep = TRUE, type = "bwc")

# Independence and homogeneity
xi_0 &lt;- c(0.2, 0.2, 0)
xi_1 &lt;- c(0.1, 0.2, 0.1)
samp_0 &lt;- r_bwc(n = n, mu = mu, xi = xi_0)
samp_1 &lt;- r_bwc(n = n, mu = mu, xi = xi_1)
biv_lrt(x = samp_0, indep = TRUE, hom = TRUE, type = "bwc")
biv_lrt(x = samp_1, indep = TRUE, hom = TRUE, type = "bwc")
</code></pre>

<hr>
<h2 id='bvm'>Density evaluation, sampling, and parameter estimation of the
bivariate sine von Mises distribution</h2><span id='topic+bvm'></span><span id='topic+d_bvm'></span><span id='topic+const_bvm'></span><span id='topic+r_bvm'></span><span id='topic+fit_bvm_mm'></span><span id='topic+fit_bvm_mle'></span>

<h3>Description</h3>

<p>Computation of the density and normalizing constant
<code class="reqn">T(\kappa_1, \kappa_2, \lambda)</code> of the bivariate sine von Mises
</p>
<p style="text-align: center;"><code class="reqn">f(\theta_1, \theta_2)= T(\kappa_1, \kappa_2, \lambda)
\exp\{\kappa_1 \cos(\theta_1-\mu_1) +
\kappa_2 \cos(\theta_2-\mu_2) +
\lambda \sin(\theta_1-\mu_1) \sin(\theta_2-\mu_2)\}.</code>
</p>

<p>Simulation of samples from a bivariate sine von Mises.
</p>
<p>Maximum likelihood and method of moments estimation of the
parameters <code class="reqn">(\mu_1, \mu_2, \kappa_1, \kappa_2, \lambda)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_bvm(x, mu, kappa, log_const = NULL)

const_bvm(kappa, M = 25, MC = 10000)

r_bvm(n, mu, kappa)

fit_bvm_mm(
  x,
  lower = c(0, 0, -30),
  upper = c(30, 30, 30),
  start = NULL,
  M = 25,
  hom = FALSE,
  indep = FALSE,
  ...
)

fit_bvm_mle(
  x,
  start = NULL,
  M = 25,
  lower = c(-pi, -pi, 0, 0, -30),
  upper = c(pi, pi, 30, 30, 30),
  hom = FALSE,
  indep = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvm_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(nx, 2)</code> with the angles on which the density
is evaluated.</p>
</td></tr>
<tr><td><code id="bvm_+3A_mu">mu</code></td>
<td>
<p>circular means of the density, a vector of length <code>2</code>.</p>
</td></tr>
<tr><td><code id="bvm_+3A_kappa">kappa</code></td>
<td>
<p>vector of length <code>3</code> with the concentrations
<code class="reqn">(\kappa_1, \kappa_2)</code> and the dependence parameter <code class="reqn">\lambda</code>
of the density.</p>
</td></tr>
<tr><td><code id="bvm_+3A_log_const">log_const</code></td>
<td>
<p>logarithm of the normalizing constant. Computed internally
if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="bvm_+3A_m">M</code></td>
<td>
<p>truncation of the series expansion for computing the normalizing
constant. Defaults to <code>25</code>.</p>
</td></tr>
<tr><td><code id="bvm_+3A_mc">MC</code></td>
<td>
<p>Monte Carlo replicates for computing the normalizing
constant when there is no series expansion. Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="bvm_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="bvm_+3A_lower">lower</code>, <code id="bvm_+3A_upper">upper</code></td>
<td>
<p>vectors of length <code>5</code> with the bounds for the
likelihood optimizer. Default to <code>c(-pi, -pi, 0, 0, -30)</code> and
<code>c(pi, pi, 30, 30, 30)</code>.</p>
</td></tr>
<tr><td><code id="bvm_+3A_start">start</code></td>
<td>
<p>a vector of length <code>5</code> with the initial values for the
maximum likelihood optimizer. The first two entries are disregarded in
<code>fit_bvm_mm</code>. If <code>NULL</code> (default), the starting values are taken
from the estimation of marginal von Mises in <code>fit_bvm_mm</code>. In
<code>fit_bvm_mle</code>, the method of moments estimates are employed.</p>
</td></tr>
<tr><td><code id="bvm_+3A_hom">hom</code></td>
<td>
<p>assume a homogeneous distribution with equal marginal
concentrations? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bvm_+3A_indep">indep</code></td>
<td>
<p>set the dependence parameter to zero? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bvm_+3A_...">...</code></td>
<td>
<p>further parameters passed to
<code><a href="sdetorus.html#topic+sdetorus">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>d_bvm</code>: a vector of length <code>nx</code> with the density evaluated
at <code>x</code>.
</p>
</li>
<li> <p><code>const_bvm</code>: the value of the normalizing constant
<code class="reqn">T(\kappa_1, \kappa_2, \lambda)</code>.
</p>
</li>
<li> <p><code>r_bvm</code>: a matrix of size <code>c(n, 2)</code> with the random sample.
</p>
</li>
<li> <p><code>fit_mme_bvm, fit_mle_bvm</code>: a list with the estimated parameters
<code class="reqn">(\mu_1, \mu_2, \kappa_1, \kappa_2, \lambda)</code> and the object <code>opt</code>
containing the optimization summary.
</p>
</li></ul>



<h3>References</h3>

<p>Mardia, K. V., Hughes, G., Taylor, C. C., and Singh, H. (2008).
A multivariate von Mises with applications to bioinformatics.
<em>Canadian Journal of Statistics</em>, 36(1):99&ndash;109.
<a href="https://doi.org/10.1002/cjs.5550360110">doi:10.1002/cjs.5550360110</a>
</p>
<p>Singh, H., Hnizdo, V., and Demchuk, E. (2002). Probabilistic model for two
dependent circular variables. <em>Biometrika</em>, 89(3):719&ndash;723.
<a href="https://doi.org/10.1093/biomet/89.3.719">doi:10.1093/biomet/89.3.719</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Density evaluation

mu &lt;- c(0, 0)
kappa &lt;- 3:1
nth &lt;- 50
th &lt;- seq(-pi, pi, l = nth)
x &lt;- as.matrix(expand.grid(th, th))
const &lt;- const_bvm(kappa = kappa)
d &lt;- d_bvm(x = x, mu = mu, kappa = kappa, log_const = log(const))
filled.contour(th, th, matrix(d, nth, nth), col = viridisLite::viridis(31),
               levels = seq(0, max(d), l = 30))

## Sampling and estimation

n &lt;- 100
samp &lt;- r_bvm(n = n, mu = mu, kappa = kappa)
(param_mm &lt;- fit_bvm_mm(samp)$par)
(param_mle &lt;- fit_bvm_mle(samp)$par)
</code></pre>

<hr>
<h2 id='bwc'>Density evaluation, sampling, and parameter estimation of the
bivariate wrapped Cauchy distribution</h2><span id='topic+bwc'></span><span id='topic+d_bwc'></span><span id='topic+r_bwc'></span><span id='topic+fit_bwc_mm'></span><span id='topic+fit_bwc_mle'></span>

<h3>Description</h3>

<p>Computation of the density of a bivariate wrapped Cauchy:
</p>
<p style="text-align: center;"><code class="reqn">f(\theta_1, \theta_2)=c(\xi_1,\xi_2,\rho)\{c_0(\xi_1,\xi_2,\rho)-
c_1(\xi_1,\xi_2,\rho) \cos (\theta_1-\mu_1)-
c_2(\xi_1,\xi_2,\rho)\cos (\theta_2-\mu_2)-\\
c_3(\xi_1,\xi_2,\rho) \cos (\theta_1-\mu_1) \cos (\theta_2-\mu_2)-
c_4(\xi_1,\xi_2,\rho) \sin (\theta_1-\mu_1) \sin (\theta_2-\mu_2)\}^{-1}.</code>
</p>

<p>Simulation of samples from a bivariate wrapped Cauchy.
</p>
<p>Maximum likelihood and method of moments estimation of the
parameters <code class="reqn">(\mu_1, \mu_2, \xi_1, \xi_2, \rho)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_bwc(x, mu, xi)

r_bwc(n, mu, xi)

fit_bwc_mm(x, hom = FALSE, indep = FALSE)

fit_bwc_mle(
  x,
  start = NULL,
  lower = c(-pi, -pi, 0, 0, -1 + 0.001),
  upper = c(pi, pi, 1 - 0.001, 1 - 0.001, 1 - 0.001),
  hom = FALSE,
  indep = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwc_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(nx, 2)</code> with the angles on which the density
is evaluated.</p>
</td></tr>
<tr><td><code id="bwc_+3A_mu">mu</code></td>
<td>
<p>circular means of the density, a vector of length <code>2</code>.</p>
</td></tr>
<tr><td><code id="bwc_+3A_xi">xi</code></td>
<td>
<p>a vector of length <code>3</code> with the marginal concentrations
<code class="reqn">(\xi_1, \xi_2)</code>, and the dependence parameter <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code id="bwc_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="bwc_+3A_hom">hom</code></td>
<td>
<p>assume a homogeneous distribution with equal marginal
concentrations? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bwc_+3A_indep">indep</code></td>
<td>
<p>set the dependence parameter to zero? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bwc_+3A_start">start</code></td>
<td>
<p>a vector of length <code>5</code> with the initial values for the
maximum likelihood optimizer. If <code>NULL</code> (default), the method of
moments estimates are employed.</p>
</td></tr>
<tr><td><code id="bwc_+3A_lower">lower</code>, <code id="bwc_+3A_upper">upper</code></td>
<td>
<p>vectors of length <code>5</code> with the bounds for the
likelihood optimizer. Default to <code>c(-pi, -pi, 0, 0, -1 + 1e-3)</code> and
<code>c(pi, pi, 1 - 1e-3, 1 - 1e-3, 1 - 1e-3)</code>.</p>
</td></tr>
<tr><td><code id="bwc_+3A_...">...</code></td>
<td>
<p>further parameters passed to
<code><a href="sdetorus.html#topic+sdetorus">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>d_bwc</code>: a vector of length <code>nx</code> with the density evaluated
at <code>x</code>.
</p>
</li>
<li> <p><code>r_bwc</code>: a matrix of size <code>c(n, 2)</code> with the random sample.
</p>
</li>
<li> <p><code>fit_mme_bwc, fit_mle_bwc</code>: a list with the parameters
<code class="reqn">(\mu_1, \mu_2, \xi_1, \xi_2, \rho)</code> and the object <code>opt</code>
containing the optimization summary.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>The original code for <code>r_bwc</code> was supplied by
Arthur Pewsey.
</p>


<h3>References</h3>

<p>Kato, S. and Pewsey, A. (2015). A Möbius transformation-induced distribution
on the torus. <em>Biometrika</em>, 102(2):359&ndash;370. <a href="https://doi.org/10.1093/biomet/asv003">doi:10.1093/biomet/asv003</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Density evaluation

mu &lt;- c(0, 0)
xi &lt;- c(0.3, 0.5, 0.4)
nth &lt;- 50
th &lt;- seq(-pi, pi, l = nth)
x &lt;- as.matrix(expand.grid(th, th))
d &lt;- d_bwc(x = x, mu = mu, xi = xi)
filled.contour(th, th, matrix(d, nth, nth), col = viridisLite::viridis(20),
               levels = seq(0, max(d), l = 20))

## Sampling and estimation

n &lt;- 100
samp &lt;- r_bwc(n = n, mu = mu, xi = xi)
(param_mm &lt;- fit_bwc_mm(samp)$par)
(param_mle &lt;- fit_bwc_mle(samp)$par)
</code></pre>

<hr>
<h2 id='bwn'>Density evaluation, sampling, and parameter estimation of the
bivariate wrapped normal distribution</h2><span id='topic+bwn'></span><span id='topic+d_bwn'></span><span id='topic+r_bwn'></span><span id='topic+fit_bwn_mle'></span>

<h3>Description</h3>

<p>Computation of the density of the bivariate wrapped normal.
</p>
<p>Simulation of pairs of samples from a bivariate wrapped normal.
</p>
<p>Maximum likelihood estimation of the parameters
<code class="reqn">(\boldsymbol{\mu}, \boldsymbol{\Sigma})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_bwn(x, mu, Sigma, kmax = 2)

r_bwn(n, mu, Sigma)

fit_bwn_mle(
  x,
  kmax = 2,
  lower = c(-pi, -pi, 0.001, 0.001, -1),
  upper = c(pi, pi, 20, 20, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwn_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(nx, 2)</code> with the angles on which the density
is evaluated.</p>
</td></tr>
<tr><td><code id="bwn_+3A_mu">mu</code></td>
<td>
<p>circular means of the density, a vector of length <code>2</code>.</p>
</td></tr>
<tr><td><code id="bwn_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="bwn_+3A_kmax">kmax</code></td>
<td>
<p>integer number up to truncate the wrapped normal series in
<code>-kmax:kmax</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="bwn_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="bwn_+3A_lower">lower</code>, <code id="bwn_+3A_upper">upper</code></td>
<td>
<p>vector of length <code>5</code> with the bounds of the
parameters for the maximum likelihood optimizer.</p>
</td></tr>
<tr><td><code id="bwn_+3A_...">...</code></td>
<td>
<p>further parameters passed to
<code><a href="sdetorus.html#topic+sdetorus">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>d_bwn</code>: a vector of length <code>nx</code> with the density evaluated
at <code>x</code>.
</p>
</li>
<li> <p><code>r_bwn</code>: a matrix of size <code>c(n, 2)</code> with the random sample.
</p>
</li>
<li> <p><code>fit_bwn_mle</code>: a list with the parameters
<code class="reqn">(\boldsymbol{\mu}, \boldsymbol{\Sigma})</code> and the object <code>opt</code>
containing the optimization summary.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Density evaluation

mu &lt;- c(0, 0)
Sigma &lt;- 3 * matrix(c(1.5, 0.75, 0.75, 1), nrow = 2, ncol = 2)
nth &lt;- 50
th &lt;- seq(-pi, pi, l = nth)
x &lt;- as.matrix(expand.grid(th, th))
d &lt;- d_bwn(x = x, mu = mu, Sigma = Sigma)
filled.contour(th, th, matrix(d, nth, nth), col = viridisLite::viridis(31),
               levels = seq(0, max(d), l = 30))

## Sampling and estimation

n &lt;- 100
samp &lt;- r_bwn(n = 100, mu = mu, Sigma = Sigma)
(param_mle &lt;- fit_bwn_mle(samp)$par)
</code></pre>

<hr>
<h2 id='earthquakes'>Japanese earthquakes dataset</h2><span id='topic+earthquakes'></span>

<h3>Description</h3>

<p>Pre-earthquake direction of steepest descent and the direction
of lateral ground movement before and after, respectively, an earthquake in
Noshiro (Japan) in 1983.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>earthquakes
</code></pre>


<h3>Format</h3>

<p>A data frame with 678 rows and 2 variables:
</p>

<dl>
<dt>theta1</dt><dd><p>Direction of steepest descent.</p>
</dd>
<dt>theta2</dt><dd><p>Direction of lateral ground movement.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The direction is measured in radians in <code class="reqn">[0, 2\pi)</code> with <code class="reqn">0</code> /
<code class="reqn">\frac{\pi}{2}</code> / <code class="reqn">\pi</code> / <code class="reqn">\frac{3\pi}{2}</code> / <code class="reqn">2\pi</code>
representing the East / North / West / South / East directions.
</p>


<h3>References</h3>

<p>Hamada, M. and O'Rourke, T. (1992). Case Studies of Liquefaction &amp; Lifeline
Performance During Past Earthquake. Volume 1: Japanese Case Studies.
Technical Report NCEER-92-0001. National Center for Earthquake Engineering
Research, University at Buffalo. <a href="https://doi.org/10.1016/0886-7798%2893%2990146-m">doi:10.1016/0886-7798(93)90146-m</a>
</p>
<p>Jones, M. C., Pewsey, A., and Kato, S. (2015). On a class of circulas:
copulas for circular distributions. <em>Annals of the Institute of
Statistical Mathematics</em>, 67(5):843&ndash;862. <a href="https://doi.org/10.1007/s10463-014-0493-6">doi:10.1007/s10463-014-0493-6</a>
</p>
<p>Rivest, L.-P. (1997). A decentred predictor for circular-circular
regression. <em>Biometrika</em>, 84(3):717&ndash;726. <a href="https://doi.org/10.1093/biomet/84.3.717">doi:10.1093/biomet/84.3.717</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("earthquakes")

# Transform the data into [-pi, pi)
earthquakes &lt;- sdetorus::toPiInt(earthquakes)
plot(earthquakes, xlab = expression(theta[1]), ylab = expression(theta[2]),
     xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE)
sdetorus::torusAxis()


# Perform TR-PCA
fit &lt;- ridge_pca(x = earthquakes)
show_ridge_pca(fit)
</code></pre>

<hr>
<h2 id='frechet'>Fréchet statistics on the torus</h2><span id='topic+frechet'></span><span id='topic+frechet_mean'></span><span id='topic+frechet_ss'></span>

<h3>Description</h3>

<p>Computes the Fréchet mean, variance, and standard deviation of
a sample on the <code class="reqn">d</code>-torus <code class="reqn">[-l, l)^d</code>, <code class="reqn">d\geq 1</code>, with
<code class="reqn">-l \equiv l</code> identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechet_mean(x, l = pi, N = 500, draw_plot = FALSE)

frechet_ss(x, l = pi, N = 500, draw_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frechet_+3A_x">x</code></td>
<td>
<p>sample of angles on <code class="reqn">[-l, l)</code>, a vector or a matrix.</p>
</td></tr>
<tr><td><code id="frechet_+3A_l">l</code></td>
<td>
<p>half-period of the circular data. Can be a vector of length
<code>ncol(x)</code> if <code>x</code> is a matrix. Defaults to <code>pi</code>.</p>
</td></tr>
<tr><td><code id="frechet_+3A_n">N</code></td>
<td>
<p>size of the grid in <code class="reqn">[-l, l)</code> for the exhaustive search of
the mean. Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="frechet_+3A_draw_plot">draw_plot</code></td>
<td>
<p>draw a diagnostic plot showing the Fréchet loss function?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>frechet_mean</code>: a list with the marginal Fréchet means
(<code>mu</code>), variances (<code>var</code>), and standard deviations (<code>sd</code>).
</p>
</li>
<li> <p><code>frechet_ss</code>: a list with the Fréchet variances (<code>var</code>)
and the cumulative proportion of total variance explained (<code>var_exp</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Circular data

# Sample from a wrapped normal
x &lt;- sdetorus::toPiInt(rnorm(n = 5e2, mean = 2, sd = 1))
frechet_mean(x = x)

# Sample from a bimodal distribution
x &lt;- sdetorus::toPiInt(rnorm(n = 5e2, mean = c(1, -2), sd = c(0.5, 0.75)))
frechet_mean(x = x)

# Periodic data in [-2, 2)
x &lt;- sdetorus::toInt(rnorm(n = 5e2, mean = c(-2, 1), sd = 2:1),
                     a = -2, b = 2)
frechet_mean(x = x, l = 2)

## Toroidal data

# Sample from a multivariate wrapped normal
n &lt;- 50
S &lt;- rbind(c(2.5, -0.2, 0.5),
           c(-0.2, 1.5, -0.5),
           c(0.5, -0.5, 0.75))
x &lt;- sdetorus::toPiInt(mvtnorm::rmvnorm(n, mean = c(0, 1.5, -2), sigma = S))
(f &lt;- frechet_mean(x = x))

# Total Fréchet variance is sum of marginal variances
sum(torus_dist(x, y = f$mu, squared = TRUE)) / n
sum(f$var)

# Cumulative proportion of variances
frechet_ss(x)
</code></pre>

<hr>
<h2 id='ridge_curve'>Fourier-fitted ridge curve and related utilities</h2><span id='topic+ridge_curve'></span><span id='topic+der_ridge_curve'></span><span id='topic+dist_ridge_curve'></span><span id='topic+arclength_ridge_curve'></span><span id='topic+proj_ridge_curve'></span>

<h3>Description</h3>

<p>Given the angles <code>theta</code> in <code class="reqn">[-\pi, \pi)</code>,
<code>ridge_curve</code> computes the Fourier-fitted ridge curve
<code class="reqn">(\theta, r_1(\theta))</code> or <code class="reqn">(r_2(\theta), \theta)</code>, where
</p>
<p style="text-align: center;"><code class="reqn">r_j(\theta):=\mathrm{atan2}(S_m (\theta),
C_m (\theta))</code>
</p>
<p> with <code class="reqn">C_m(x) :=
a_0/2 + \sum_{k=1}^m a_k \cos(kx)</code> and <code class="reqn">S_m(x) :=
\sum_{k=1}^m b_k \sin(kx)</code> for <code class="reqn">j = 1,2</code>. <code>der_ridge_curve</code> and
<code>dist_ridge_curve</code> compute the derivatives of and the distances along
these curves, respectively. <code>alpha_ridge_curve</code> provides a uniform
grid of the ridge curve using the arc-length parametrization.
<code>proj_ridge_curve</code> gives the ridge's <code class="reqn">\theta</code> for which the curve
is closer to any point on <code class="reqn">[-\pi, \pi)^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge_curve(
  theta,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  at2 = TRUE
)

der_ridge_curve(
  theta,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  norm = NULL,
  at2 = TRUE
)

dist_ridge_curve(
  alpha,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  der = TRUE,
  shortest = TRUE,
  at2 = TRUE
)

arclength_ridge_curve(
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  L = 500,
  at2 = TRUE
)

proj_ridge_curve(
  x,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  ridge_curve_grid = NULL,
  arclength = FALSE,
  at2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridge_curve_+3A_theta">theta</code></td>
<td>
<p>vector <code class="reqn">\theta</code> of size <code>nth</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_mu">mu</code></td>
<td>
<p>a vector of size <code>2</code> giving <code class="reqn">(\mu_1, \mu_2)</code>. Defaults
to <code>c(0, 0)</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_coefs">coefs</code></td>
<td>
<p>list of coefficients <code>cos_a</code> (<code class="reqn">a_k</code>) and
<code>sin_b</code> (<code class="reqn">b_k</code> giving the Fourier fit of the ridge curve.
Defaults to <code>list(cos_a = c(0, 0), sin_b = 0)</code>. See examples.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_ind_var">ind_var</code></td>
<td>
<p>index <code class="reqn">j</code> of the variable that parametrizes the ridge.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_at2">at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_norm">norm</code></td>
<td>
<p>normalize tangent vectors? If different from <code>NULL</code>
(the default), the vectors are normalized to have the given <code>norm</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_alpha">alpha</code></td>
<td>
<p>a vector of size <code>2</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_n">N</code></td>
<td>
<p>number of discretization points for approximating curve lengths.
Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_der">der</code></td>
<td>
<p>use derivatives to approximate curve lengths? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_shortest">shortest</code></td>
<td>
<p>return the shortest possible distance? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_l">L</code></td>
<td>
<p>number of discretization points for computing the arc-length
parametrization curve lengths. Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> with angular coordinates.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_ridge_curve_grid">ridge_curve_grid</code></td>
<td>
<p>if provided, the <code>ridge_curve</code> evaluated at
a grid of size <code>N</code>. If not provided, it is computed internally.
Useful for saving computations.</p>
</td></tr>
<tr><td><code id="ridge_curve_+3A_arclength">arclength</code></td>
<td>
<p>use the arc-length parametrization to compute the
projections? This yields a more uniform grid for searching the projections.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>ridge_curve</code>: a matrix of size <code>c(nth, 2)</code> with the ridge
curve evaluated at <code>theta</code>.
</p>
</li>
<li> <p><code>der_ridge_curve</code>: a matrix of size <code>c(nth, 2)</code> with the
derivatives of the ridge curve evaluated at <code>theta</code>.
</p>
</li>
<li> <p><code>dist_ridge_curve</code>: the distance between two points along
the ridge curve, a non-negative scalar.
</p>
</li>
<li> <p><code>proj_ridge_curve</code>: a list with (1) the <code>theta</code>'s that
give the points in the ridge curve that are the closest (in the flat torus
distance) to <code>x</code> (a matrix of size <code>c(nx, 2)</code>); (2) the indexes
of <code>ridge_curve_grid</code> in which those <code>theta</code>'s were obtained.
</p>
</li>
<li> <p><code>arclength_ridge_curve</code>: a vector of size <code>N</code> giving the
<code>theta</code> angles that yield a uniform-length grid of the ridge curve.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(-0.5, 1.65)
th &lt;- seq(-pi, pi, l = 200)
K &lt;- 5
coefs &lt;- list(cos_a = 1 / (1:(K + 1))^3, sin_b = 1 / (1:K)^3)
rid1 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 1)
rid2 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 2)
plot(mu[1], mu[2], xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
     xlab = expression(theta[1]), ylab = expression(theta[2]),
     pch = "*", col = 5, cex = 3)
sdetorus::linesTorus(rid1[, 1], rid1[, 2], col = 1)
sdetorus::linesTorus(rid2[, 1], rid2[, 2], col = 2)
abline(v = mu[1], lty = 3, col = 5)
abline(h = mu[2], lty = 3, col = 5)
points(ridge_curve(theta = mu[1], mu = mu, coefs = coefs, ind_var = 1),
       col = 1)
points(ridge_curve(theta = mu[2], mu = mu, coefs = coefs, ind_var = 2),
       col = 2)
sdetorus::torusAxis()

## der_ridge_curve

th &lt;- seq(-pi, pi, l = 10)
mu &lt;- c(0.5, 1.5)
K &lt;- 5
coefs &lt;- list(cos_a = 1 / (1:(K + 1))^3, sin_b = 1 / (1:K)^3)
rid1 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 1)
rid2 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 2)
v1 &lt;- der_ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 1,
                      norm = 0.5)
v2 &lt;- der_ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 2,
                      norm = 0.5)
points(rid1, pch = 16, col = 1)
points(rid2, pch = 16, col = 2)
arrows(x0 = rid1[, 1], y0 = rid1[, 2],
       x1 = (rid1 + v1)[, 1], y1 = (rid1 + v1)[, 2],
       col = 3, angle = 5, length = 0.1)
arrows(x0 = rid2[, 1], y0 = rid2[, 2],
       x1 = (rid2 + v2)[, 1], y1 = (rid2 + v2)[, 2],
       col = 4, angle = 5, length = 0.1)

## dist_ridge_curve

# Distances accuracy
a &lt;- c(-pi / 2, pi)
mu &lt;- c(-pi / 2, pi / 2)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = TRUE, N = 1e6)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = FALSE, N = 1e6)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = TRUE, N = 1e2)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = FALSE, N = 1e2)

## arclength_ridge_curve

mu &lt;- c(-pi / 2, pi / 2)
alpha &lt;- arclength_ridge_curve(mu = mu, coefs = coefs, ind_var = 1, N = 25)
alpha &lt;- sdetorus::toPiInt(c(alpha, alpha[1]))
rid &lt;- ridge_curve(theta = alpha, mu = mu, coefs = coefs, ind_var = 1)
plot(mu[1], mu[2], pch = "*", col = 5, cex = 3, xlim = c(-pi, pi),
     ylim = c(-pi, pi), axes = FALSE, xlab = expression(theta[1]),
     ylab = expression(theta[2]))
sdetorus::linesTorus(rid[, 1], rid[, 2], col = 1, pch = 16)
points(rid[, 1], rid[, 2], pch = 16, col = 1)
abline(v = mu[1], lty = 3, col = 5)
abline(h = mu[2], lty = 3, col = 5)
sdetorus::torusAxis()

## proj_ridge_curve

mu &lt;- c(0, 0)
n &lt;- 25
x &lt;- matrix(runif(2 * n, -pi, pi), nrow = n, ncol = 2)
col &lt;- rainbow(n)
th &lt;- seq(-pi, pi, l = 100)
old_par &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
for (j in 1:2) {

  plot(x, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
       xlab = expression(theta[1]), ylab = expression(theta[2]), col = col)
  rid &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = j)
  sdetorus::linesTorus(x = rid[, 1], y = rid[, 2], lwd = 2)
  abline(v = mu[1], lty = 3)
  abline(h = mu[2], lty = 3)
  points(mu[1], mu[2], pch = "*", cex = 3)
  sdetorus::torusAxis()
  theta_projs &lt;- proj_ridge_curve(x = x, mu = mu, coefs = coefs, ind_var = j,
                                  ridge_curve_grid = rid)$theta_proj
  projs &lt;- ridge_curve(theta = theta_projs, mu = mu, coefs = coefs,
                       ind_var = j)
  points(projs, col = col, pch = 3)
  for (i in 1:n) {

    sdetorus::linesTorus(x = c(x[i, 1], projs[i, 1]),
                         y = c(x[i, 2], projs[i, 2]), col = col[i], lty = 3)

  }

}
par(old_par)
</code></pre>

<hr>
<h2 id='ridge_distr'>Connected component of the toroidal density ridge of a bivariate sine
von Mises, bivariate wrapped Cauchy, and bivariate wrapped normal</h2><span id='topic+ridge_distr'></span><span id='topic+ridge_bvm'></span><span id='topic+ridge_bwc'></span><span id='topic+ridge_bwn'></span>

<h3>Description</h3>

<p>Computation of the connected component of the density ridge of
in a given set of points or, if not specified, in a regular grid on
<code class="reqn">[-\pi, \pi)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge_bvm(mu, kappa, eval_points, subint_1, subint_2)

ridge_bwc(mu, xi, eval_points, subint_1, subint_2)

ridge_bwn(mu, Sigma, kmax = 2, eval_points, subint_1, subint_2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridge_distr_+3A_mu">mu</code></td>
<td>
<p>circular means of the density, a vector of length <code>2</code>.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_kappa">kappa</code></td>
<td>
<p>vector of length <code>3</code> with the concentrations
<code class="reqn">(\kappa_1, \kappa_2)</code> and the dependence parameter <code class="reqn">\lambda</code>
of the density.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_eval_points">eval_points</code></td>
<td>
<p>evaluation points for the ridge.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_subint_1">subint_1</code></td>
<td>
<p>number of points for <code class="reqn">\theta_1</code>.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_subint_2">subint_2</code></td>
<td>
<p>number of points for <code class="reqn">\theta_2</code> at each <code class="reqn">\theta_1</code>.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_xi">xi</code></td>
<td>
<p>a vector of length <code>3</code> with the marginal concentrations
<code class="reqn">(\xi_1, \xi_2)</code>, and the dependence parameter <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="ridge_distr_+3A_kmax">kmax</code></td>
<td>
<p>integer number up to truncate the wrapped normal series in
<code>-kmax:kmax</code>. Defaults to <code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(subint_1, 2)</code> containing the points of the
connected component of the ridge.
</p>


<h3>References</h3>

<p>Ozertem, U. and Erdogmus, D. (2011). Locally defined principal curves and
surfaces. <em>Journal of Machine Learning Research</em>, 12(34):1249&ndash;1286.
<a href="https://doi.org/10.6083/M4ZG6Q60">doi:10.6083/M4ZG6Q60</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bivariate von Mises
mu &lt;- c(0, 0)
kappa &lt;- c(0.3, 0.5, 0.4)
nth &lt;- 100
th &lt;- seq(-pi, pi, l = nth)
x &lt;- as.matrix(expand.grid(th, th))
d &lt;- d_bvm(x = x, mu = mu, kappa = kappa)
image(th, th, matrix(d, nth, nth), col = viridisLite::viridis(20))
ridge &lt;- ridge_bvm(mu = mu, kappa = kappa, subint_1 = 5e2,
                   subint_2 = 5e2)
points(ridge)

# Bivariate wrapped Cauchy
mu &lt;- c(0, 0)
xi &lt;- c(0.3, 0.6, 0.25)
nth &lt;- 100
th &lt;- seq(-pi, pi, l = nth)
x &lt;- as.matrix(expand.grid(th, th))
d &lt;- d_bwc(x = x, mu = mu, xi = xi)
image(th, th, matrix(d, nth, nth), col = viridisLite::viridis(20))
ridge &lt;- ridge_bwc(mu = mu, xi = xi, subint_1 = 5e2, subint_2 = 5e2)
points(ridge)

# Bivariate wrapped normal
mu &lt;- c(0, 0)
Sigma &lt;- matrix(c(10, 3, 3, 5), nrow = 2)
nth &lt;- 100
th &lt;- seq(-pi, pi, l = nth)
x &lt;- as.matrix(expand.grid(th, th))
d &lt;- d_bwn(x = x, mu = mu, Sigma = Sigma)
image(th, th, matrix(d, nth, nth), col = viridisLite::viridis(20))
ridge &lt;- ridge_bwn(mu = mu, Sigma = Sigma, subint_1 = 5e2,
                   subint_2 = 5e2)
points(ridge)
</code></pre>

<hr>
<h2 id='ridge_fourier_fit'>Fourier expansion of a given curve</h2><span id='topic+ridge_fourier_fit'></span>

<h3>Description</h3>

<p>Computation of the Fourier expansion coefficients of a
given curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge_fourier_fit(curve, K = 15, norm_prop = 1, N = 1280, at2 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridge_fourier_fit_+3A_curve">curve</code></td>
<td>
<p>points of the curve.</p>
</td></tr>
<tr><td><code id="ridge_fourier_fit_+3A_k">K</code></td>
<td>
<p>number of terms in the Fourier expansion. Defaults to <code>15</code>.</p>
</td></tr>
<tr><td><code id="ridge_fourier_fit_+3A_norm_prop">norm_prop</code></td>
<td>
<p>percentage of explained norm. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="ridge_fourier_fit_+3A_n">N</code></td>
<td>
<p>number of Gaussian quadrature points, passed to
<a href="sphunif.html#topic+sphunif">Gauss_Legen_nodes</a>. Defaults to <code>1280</code>.</p>
</td></tr>
<tr><td><code id="ridge_fourier_fit_+3A_at2">at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficients of the fit (see <code><a href="#topic+ridge_curve">ridge_curve</a></code>). A list
with entries:
</p>
<table>
<tr><td><code>cos_a</code></td>
<td>
<p>contains <code class="reqn">a_0,a_1,\ldots,a_m</code>.</p>
</td></tr>
<tr><td><code>sin_b</code></td>
<td>
<p>contains <code class="reqn">b_1,\ldots,b_m</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Zero mean
ridge0 &lt;- ridge_bvm(mu = c(0, 0), kappa = c(1, 2, -5), subint_1 = 5e2,
                    subint_2 = 5e2)
coefs &lt;- ridge_fourier_fit(ridge0)
th &lt;- seq(-pi, pi, l = 500)
plot(ridge0, xlim = c(-pi, pi), ylim = c(-pi, pi))
points(ridge_curve(th, mu = c(0, 0), coefs = coefs, at2 = TRUE), col = 3,
       cex = 0.5)

# Non-zero mean from a zero-mean ridge
mu &lt;- c(1.4, 2)
ridge1 &lt;- ridge_bvm(mu = mu, kappa = c(1, 2, -5), subint_1 = 5e2,
                    subint_2 = 5e2) # Just for plot
plot(ridge1, xlim = c(-pi, pi), ylim = c(-pi, pi))
points(mu[1], mu[2], col = 4, pch = "*", cex = 5)
points(ridge_curve(th, mu = mu, coefs = coefs), col = 3, cex = 0.5)

# Other zero-mean example
mu &lt;- c(0, 0)
ridge &lt;- ridge_bwc(mu = mu, xi = c(0.3, 0.5, 0.7), subint_1 = 5e2,
                   subint_2 = 5e2)
plot(ridge, xlim = c(-pi, pi), ylim = c(-pi, pi))
coefs &lt;- ridge_fourier_fit(ridge)
points(ridge_curve(th, mu = mu, coefs = coefs), col = 4, cex = 0.5)

# Another zero-mean example
mu &lt;- c(0, 0)
ridge &lt;- ridge_bwc(mu = mu, xi = c(0.8, 0.1, 0.75), subint_1 = 5e2,
                   subint_2 = 5e2)
plot(ridge, xlim = c(-pi, pi), ylim = c(-pi, pi))
coefs &lt;- ridge_fourier_fit(ridge)
points(ridge_curve(th, mu = mu, coefs = coefs), col = 4, cex = 0.5)
</code></pre>

<hr>
<h2 id='ridge_pca'>Toroidal PCA via density ridges</h2><span id='topic+ridge_pca'></span>

<h3>Description</h3>

<p>This function computes the whole process of toroidal PCA
via density ridges on a given sample: parameter estimation of the
underlying distribution, estimation of the connected component of the ridge,
and determination of its Fourier expansion from which to obtain the first
and second scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge_pca(
  x,
  type = c("auto", "bvm", "bwc")[1],
  N = 500,
  K = 15,
  scale = TRUE,
  lrts = TRUE,
  alpha = 0.05,
  at2 = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridge_pca_+3A_x">x</code></td>
<td>
<p>matrix of dimension  <code>c(n, 2)</code> containing the <code>n</code>
observations of the pair of angles.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_type">type</code></td>
<td>
<p>either <code>"bvm"</code> (bivariate sine von Mises), <code>"bwc"</code>
(bivariate wrapped Cauchy), or <code>"auto"</code> (default). <code>"auto"</code>
performs both fits and uses the one with lowest BIC.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_n">N</code></td>
<td>
<p>number of discretization points for approximating curve lengths.
Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_k">K</code></td>
<td>
<p>number of terms in the Fourier expansion. Defaults to <code>15</code>.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_scale">scale</code></td>
<td>
<p>scale the resulting scores to <code class="reqn">[-\pi, \pi)^2</code>? Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_lrts">lrts</code></td>
<td>
<p>run <code><a href="#topic+biv_lrt">biv_lrt</a></code> to check the null hypothesis of
homogeneous concentration parameters using likelihood ratio tests? If
<code>TRUE</code> (default), enforces the special horizontal/vertical/diagonal
cases to become &quot;sticky&quot; fits.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_alpha">alpha</code></td>
<td>
<p>significance level for the homogeneity test.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_at2">at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td></tr>
<tr><td><code id="ridge_pca_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code><a href="#topic+fit_bvm_mle">fit_bvm_mle</a></code> and
<code><a href="#topic+fit_bwc_mle">fit_bwc_mle</a></code>, such as <code>start</code>, <code>lower</code>, or
<code>upper</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>
<table>
<tr><td><code>mu_hat</code></td>
<td>
<p>estimated circular means of the sample.</p>
</td></tr>
<tr><td><code>coefs_hat</code></td>
<td>
<p>estimated Fourier coefficients.</p>
</td></tr>
<tr><td><code>ind_var</code></td>
<td>
<p>indexing variable.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>scores for each of the sample points.</p>
</td></tr>
<tr><td><code>var_exp</code></td>
<td>
<p>percentage of explained variance.</p>
</td></tr>
<tr><td><code>fit_mle</code></td>
<td>
<p>maximum likelihood fit.</p>
</td></tr>
<tr><td><code>bic_fit</code></td>
<td>
<p>BIC of the fit.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original sample.</p>
</td></tr>
<tr><td><code>scales</code></td>
<td>
<p>vector of length 2 with the scale limits for the axes.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of fit performed.</p>
</td></tr>
<tr><td><code>p_hom</code></td>
<td>
<p><code class="reqn">p</code>-value of the homogeneity test.</p>
</td></tr>
<tr><td><code>p_indep</code></td>
<td>
<p><code class="reqn">p</code>-value of the independence test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Bivariate von Mises

n &lt;- 100
x &lt;- r_bvm(n = n, mu = c(1, 2), kappa = c(0.4, 0.4, 0.5))
fit &lt;- ridge_pca(x = x, type = "bvm")
show_ridge_pca(fit = fit, col_data = "red")

x &lt;- r_bvm(n = n, mu = c(2, 1), kappa = c(1, 2, 0))
fit &lt;- ridge_pca(x = x, type = "bvm")
show_ridge_pca(fit = fit, col_data = "red")

x &lt;- r_bvm(n = n, mu = c(2, 1), kappa = c(3, 2, 0))
fit &lt;- ridge_pca(x = x, type = "bvm")
show_ridge_pca(fit = fit, col_data = "red")

## Bivariate wrapped Cauchy

x &lt;- r_bwc(n = n, mu = c(1, 2), xi = c(0.2, 0.2, 0.5))
fit &lt;- ridge_pca(x = x, type = "bwc")
show_ridge_pca(fit = fit, col_data = "red")

x &lt;- r_bwc(n = n, mu = c(1, 2), xi = c(0.2, 0.8, 0))
fit &lt;- ridge_pca(x = x, type = "bwc")
show_ridge_pca(fit = fit, col_data = "red")

x &lt;- r_bwc(n = n, mu = c(1, 2), xi = c(0.5, 0.2, 0))
fit &lt;- ridge_pca(x = x, type = "bwc")
show_ridge_pca(fit = fit, col_data = "red")
</code></pre>

<hr>
<h2 id='ridge_scores'>Scores and scales for Fourier-fitted ridge curves</h2><span id='topic+ridge_scores'></span><span id='topic+max_score_2'></span>

<h3>Description</h3>

<p>Computation of PCA scores for <a href="#topic+ridge_curve">
Fourier-fitted ridge curves</a>. The scores are defined as follows:
</p>

<ul>
<li><p> First scores: signed distances along the ridge curve of the data
projections to <code class="reqn">\mu</code>.
</p>
</li>
<li><p> Second scores: signed toroidal distances from the data points to
their ridge projections.
</p>
</li></ul>

<p>The scores can be scaled to <code class="reqn">(-\pi, \pi)</code> or remain as
<code class="reqn">(l / 2, m_2)</code>, where <code class="reqn">l</code> is the length of the curve and <code class="reqn">m_2</code>
is the maximal absolute second score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge_scores(
  x,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  scale = TRUE,
  at2 = TRUE
)

max_score_2(
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  L = 25,
  f = 2,
  at2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridge_scores_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> with angular coordinates.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_mu">mu</code></td>
<td>
<p>a vector of size <code>2</code> giving <code class="reqn">(\mu_1, \mu_2)</code>. Defaults
to <code>c(0, 0)</code>.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_coefs">coefs</code></td>
<td>
<p>list of coefficients <code>cos_a</code> (<code class="reqn">a_k</code>) and
<code>sin_b</code> (<code class="reqn">b_k</code> giving the Fourier fit of the ridge curve.
Defaults to <code>list(cos_a = c(0, 0), sin_b = 0)</code>. See examples.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_ind_var">ind_var</code></td>
<td>
<p>index <code class="reqn">j</code> of the variable that parametrizes the ridge.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_n">N</code></td>
<td>
<p>number of discretization points for approximating curve lengths.
Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_scale">scale</code></td>
<td>
<p>scale the resulting scores to <code class="reqn">[-\pi, \pi)^2</code>? Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_at2">at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_l">L</code></td>
<td>
<p>grid along he variable <code>ind_var</code> used for searching the
maximum allowed second score. Defaults to <code>25</code>.</p>
</td></tr>
<tr><td><code id="ridge_scores_+3A_f">f</code></td>
<td>
<p>factor for shrinking the grid on the variable that is different to
<code>ind_var</code>. Defaults to <code>2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean <code class="reqn">\mu</code> corresponds to the first score being null.
</p>


<h3>Value</h3>

<p><code>ridge_scores</code> returns a list with:
</p>
<table>
<tr><td><code>scores</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> with the ridge scores.</p>
</td></tr>
<tr><td><code>scales</code></td>
<td>
<p>a vector of length 2 with the scale limits for the axes.</p>
</td></tr>
</table>
<p><code>max_score_2</code> computes the maximum allowed second score to rescale if
<code>scale = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(-0.5, 1.65)
th &lt;- seq(-pi, pi, l = 200)
K &lt;- 5
coefs &lt;- list(cos_a = 1 / (1:(K + 1))^3, sin_b = 1 / (1:K)^3)
n &lt;- 10
col &lt;- rainbow(n)

set.seed(13213)
old_par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2, 2))
for (j in 1:2) {

  # Simulate synthetic data close to the ridge curve
  rid &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = j)
  ind &lt;- sort(sample(length(th), size = n))
  eps &lt;- 0.25 * matrix(runif(2 * n, -1, 1), nrow = n, ncol = 2)
  x &lt;- sdetorus::toPiInt(rid[ind, ] + eps)

  # Plot ridge and synthetic data, with signs from the second scores
  s &lt;- ridge_scores(x, mu = mu, coefs = coefs, ind_var = j)$scores
  plot(x, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
       xlab = expression(theta[1]), ylab = expression(theta[2]), col = col,
       pch = ifelse(sign(s[, 2]) == 1, "+", "-"), cex = 1.25)
  sdetorus::linesTorus(rid[, 1], rid[, 2], lwd = 2)
  abline(v = mu[1], lty = 3)
  abline(h = mu[2], lty = 3)
  points(mu[1], mu[2], pch = "*", cex = 3)
  sdetorus::torusAxis()

  # Projections
  theta_projs &lt;- proj_ridge_curve(x = x, mu = mu, coefs = coefs,
                                  ind_var = j, ridge_curve_grid = rid,
                                  )$theta_proj
  projs &lt;- ridge_curve(theta = theta_projs, mu = mu, coefs = coefs,
                       ind_var = j)
  for (i in 1:n) {

    sdetorus::linesTorus(x = c(x[i, 1], projs[i, 1]),
                         y = c(x[i, 2], projs[i, 2]),
                         col = col[i], lty = 3)

  }

  # Scores plot
  plot(s, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
       xlab = "Score 1", ylab = "Score 2", col = col,
       pch = ifelse(sign(s[, 2]) == 1, "+", "-"))
  sdetorus::torusAxis()
  abline(v = 0, lty = 3)
  abline(h = 0, lty = 3)
  points(0, 0, pch = "*", cex = 3)

}
par(old_par)
</code></pre>

<hr>
<h2 id='ridgetorus-package'><code>ridgetorus</code>: PCA on the Torus via Density Ridges</h2><span id='topic+ridgetorus-package'></span><span id='topic+ridgetorus'></span>

<h3>Description</h3>

<p>Implementation of a Principal Component Analysis (PCA) in the
torus via density ridge estimation. The main function, ridge_pca(), obtains
the relevant density ridge for bivariate sine von Mises and bivariate wrapped
Cauchy distribution models and provides the associated scores and variance
decomposition. Auxiliary functions for evaluating, fitting, and sampling
these models are also provided. The package provides replicability to
García-Portugués and Prieto-Tirado (2023) &lt;doi:10.1007/s11222-023-10273-9&gt;.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués and Arturo Prieto-Tirado.
</p>


<h3>References</h3>

<p>García-Portugués, E. and Prieto-Tirado, A. (2023). Toroidal PCA via density
ridges. <em>Statistics and Computing</em>, 33(5):107.
<a href="https://doi.org/10.1007/s11222-023-10273-9">doi:10.1007/s11222-023-10273-9</a>
</p>

<hr>
<h2 id='santabarbara'>Santa Barbara currents</h2><span id='topic+santabarbara'></span>

<h3>Description</h3>

<p>The Santa Barbara Channel is a coastal area in California. This
dataset contains the sea currents in the four areas present in the
data application in García-Portugués and Prieto-Tirado (2022). Precisely,
it contains the 24-hour speed-weighted mean of the currents' direction in
each of the four areas downloaded from the
<a href="https://hfradar.ndbc.noaa.gov/">
NOAA High Frequency Radar National Server</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santabarbara
</code></pre>


<h3>Format</h3>

<p>A data frame with 1092 rows and 4 variables:
</p>

<dl>
<dt>A</dt><dd><p>Sea current direction at zone A.</p>
</dd>
<dt>B</dt><dd><p>Sea current direction at zone B.</p>
</dd>
<dt>C</dt><dd><p>Sea current direction at zone C.</p>
</dd>
<dt>D</dt><dd><p>Sea current direction at zone D.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The selection of these four areas is motivated by previous studies on the
Santa Barbara currents, like Auad et al. (1998). The direction is measured
in radians in <code class="reqn">[-\pi, \pi)</code> with <code class="reqn">-\pi</code> / <code class="reqn">-\frac{\pi}{2}</code> /
<code class="reqn">0</code> / <code class="reqn">\frac{\pi}{2}</code> / <code class="reqn">\pi</code> representing the
East / South / West / North / East directions. The script performing the data
preprocessing is available at
<a href="https://github.com/egarpor/ridgetorus/blob/master/data-raw/data-acquisition.R">
<code>data-acquisition.R</code></a>. The data was retrieved on 2022-10-21.
</p>


<h3>References</h3>

<p>Auad, G., Hendershott, M. C., and Winant, C. D. (1998). Wind-induced currents
and bottom-trapped waves in the Santa Barbara Channel. <em>Journal of
Physical Oceanography</em>, 28(1):85&ndash;102.
<a href="https://doi.org/10.1175/1520-0485%281998%29028%3C0085%3AWICABT%3E2.0.CO%3B2">doi:10.1175/1520-0485(1998)028&lt;0085:WICABT&gt;2.0.CO;2</a>
</p>
<p>García-Portugués, E. and Prieto-Tirado, A. (2023). Toroidal PCA via density
ridges. <em>Statistics and Computing</em>, 33(5):107.
<a href="https://doi.org/10.1007/s11222-023-10273-9">doi:10.1007/s11222-023-10273-9</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("santabarbara")
AB_zone &lt;- santabarbara[c("A","B")]


# Perform TR-PCA
fit &lt;- ridge_pca(x = AB_zone)
show_ridge_pca(fit)
</code></pre>

<hr>
<h2 id='show_ridge_pca'>Illustration of toroidal PCA via density ridges</h2><span id='topic+show_ridge_pca'></span>

<h3>Description</h3>

<p>Shows the scores computation for PCA via density ridges on
<code class="reqn">[-\pi, \pi)^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_ridge_pca(
  fit,
  n_max = 500,
  projs = TRUE,
  projs_lines = TRUE,
  signs = TRUE,
  col_data = 1,
  col_projs = c(3, 4),
  main = "",
  N = 500,
  at2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_ridge_pca_+3A_fit">fit</code></td>
<td>
<p>the output of <code><a href="#topic+ridge_pca">ridge_pca</a></code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_n_max">n_max</code></td>
<td>
<p>maximum number of data points to draw. These are sampled from
the data provided. Defaults to <code>500</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_projs">projs</code></td>
<td>
<p>draw projections? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_projs_lines">projs_lines</code></td>
<td>
<p>draw projection lines? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_signs">signs</code></td>
<td>
<p>plot the original data points with <code>+</code> and <code>-</code> facets
depending on the signs of the second scores? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_col_data">col_data</code></td>
<td>
<p>color(s) for the data points. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_col_projs">col_projs</code></td>
<td>
<p>a vector of size <code>2</code> giving the colors for the
curve-projected data and the ridge curve, respectively. Defaults to
<code>c(3, 4)</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_main">main</code></td>
<td>
<p>caption of the plot. Empty by default.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_n">N</code></td>
<td>
<p>number of discretization points for approximating curve lengths.
Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="show_ridge_pca_+3A_at2">at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, the functions are called to produce plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate data
set.seed(987654321)
n &lt;- 50
S1 &lt;- rbind(c(1, -0.7), c(-0.7, 1))
S2 &lt;- rbind(c(1, 0.5), c(0.5, 1))
x &lt;- rbind(mvtnorm::rmvnorm(n, mean = c(0, pi / 2), sigma = S1),
           mvtnorm::rmvnorm(n, mean = c(pi, -pi / 2), sigma = S2))
x &lt;- sdetorus::toPiInt(x)
col &lt;- rainbow(2)[rep(1:2, each = n)]

# ridge_pca and its visualization
fit &lt;- ridge_pca(x = x, at2 = FALSE)
show_ridge_pca(fit = fit, col_data = col, at2 = FALSE)
fit2 &lt;- ridge_pca(x = x, at2 = TRUE)
show_ridge_pca(fit = fit2, col_data = col, at2 = TRUE)
</code></pre>

<hr>
<h2 id='torus_dist'>Toroidal distances</h2><span id='topic+torus_dist'></span>

<h3>Description</h3>

<p>Computation of distances on <code class="reqn">[-\pi, \pi)^d</code>, <code class="reqn">d\geq 1</code>,
between two sets of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torus_dist(x, y, squared = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torus_dist_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, d)</code> with angles on <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
<tr><td><code id="torus_dist_+3A_y">y</code></td>
<td>
<p>either a matrix with the same size as <code>x</code> or a vector of
size <code>nx</code>.</p>
</td></tr>
<tr><td><code id="torus_dist_+3A_squared">squared</code></td>
<td>
<p>return the squared distance? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximal distance on <code class="reqn">[-\pi, \pi)^d</code> is <code class="reqn">\sqrt{d}\pi</code>.
</p>


<h3>Value</h3>

<p>A vector of size <code>nx</code> with the distances between the
observations of <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Illustration of torus distances
n &lt;- 10
x &lt;- matrix(runif(2 * n, -pi, pi), nrow = n, ncol = 2)
y &lt;- c(pi / 2, pi / 3)
col &lt;- rainbow(n)
plot(x, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE, col = col,
     xlab = expression(theta[1]), ylab = expression(theta[2]), pch = 16)
sdetorus::torusAxis()
points(y[1], y[2], col = 1, pch = 17)
for (i in 1:n) {

  sdetorus::linesTorus(x = c(x[i, 1], y[1]),
                       y = c(x[i, 2], y[2]), lty = 2, col = col[i])

}
text(x = x, labels = sprintf("%.2f", torus_dist(x, y)), col = col, pos = 1)
</code></pre>

<hr>
<h2 id='torus_pairs'>Toroidal pairs plot</h2><span id='topic+torus_pairs'></span>

<h3>Description</h3>

<p>Pairs plots for data on <code class="reqn">[-\pi, \pi)^d</code>, <code class="reqn">d\geq 2</code>.
The diagonal panels contain kernel density estimates tailored to
circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torus_pairs(
  x,
  max_dim = 10,
  columns = NULL,
  col_data = 1,
  ylim_dens = c(0, 1.5),
  bwd = "ROT",
  scales = rep(pi, ncol(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torus_pairs_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, d)</code> with angles on <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
<tr><td><code id="torus_pairs_+3A_max_dim">max_dim</code></td>
<td>
<p>the maximum number of scores to produce the scores plot.
Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="torus_pairs_+3A_columns">columns</code></td>
<td>
<p>if specified, the variables to be plotted. If <code>NULL</code>
(the default), the first <code>max_dim</code> variables are plotted.</p>
</td></tr>
<tr><td><code id="torus_pairs_+3A_col_data">col_data</code></td>
<td>
<p>color(s) for the data points. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="torus_pairs_+3A_ylim_dens">ylim_dens</code></td>
<td>
<p>common <code>ylim</code> for the diagonal plots. Defaults to
<code>c(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="torus_pairs_+3A_bwd">bwd</code></td>
<td>
<p>type of bandwidth selector used in the kernel density plots.
Either <code>"ROT"</code>, <code>"EMI"</code>, <code>"AMI"</code>, <code>"LSCV"</code>, or
<code>"LCV"</code>. See <code><a href="DirStats.html#topic+bw_dir_pi">bw_dir_pi</a></code> and
<code><a href="DirStats.html#topic+bw_dir_pi">bw_dir_cv</a></code>. Defaults to <code>"ROT"</code>.</p>
</td></tr>
<tr><td><code id="torus_pairs_+3A_scales">scales</code></td>
<td>
<p>scales of the torus. Defaults to <code>rep(pi, ncol(x))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default bandwidth selector is the Rule-Of-Thumb (ROT) selector in
García-Portugués (2013). It is fast, yet it may oversmooth non-unimodal
densities. The EMI selector gives more flexible fits.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot</a></code>. The density plots show the
<a href="#topic+frechet_mean">Fréchet means</a> (red bars) and the Fréchet standard
deviations (gray text).
</p>


<h3>References</h3>

<p>García-Portugués, E. (2013). Exact risk improvement of bandwidth selectors
for kernel density estimation with directional data. <em>Electronic Journal
of Statistics</em>, 7:1655&ndash;1685. <a href="https://doi.org/10.1214/13-ejs821">doi:10.1214/13-ejs821</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
n &lt;- 50
set.seed(123456)
x &lt;- sdetorus::toPiInt(rbind(
  mvtnorm::rmvnorm(n = n, mean = c(-pi, -pi) / 2,
                   sigma = diag(0.1, nrow = 2)),
  mvtnorm::rmvnorm(n = n, mean = c(-3 * pi / 2, 0) / 2,
          sigma = diag(0.1, nrow = 2)),
  mvtnorm::rmvnorm(n = n, mean = c(0, pi / 2),
                   sigma = diag(0.1, nrow = 2))
))
col &lt;- rainbow(3)[rep(1:3, each = n)]

# Torus pairs
torus_pairs(x, col_data = col)

fit &lt;- ridge_pca(x = x)
torus_pairs(fit$scores, col_data = col)
</code></pre>

<hr>
<h2 id='wind'>Texas wind dataset</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>Wind direction at 6:00 and 7:00 from June 1, 2003 to June 30,
2003, in radians, measured at a weather station in Texas coded as C28-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wind
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 2 variables:
</p>

<dl>
<dt>theta1</dt><dd><p>Direction at 6:00 am.</p>
</dd>
<dt>theta2</dt><dd><p>Direction at 12:00 noon.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The direction is measured in radians in <code class="reqn">[-\pi, \pi)</code> with
<code class="reqn">-\pi</code>/<code class="reqn">-\frac{-\pi}{2}</code>/<code class="reqn">0</code>/<code class="reqn">-\frac{\pi}{2}</code>/<code class="reqn">\pi</code>
representing the East/South/West/North/East directions.
</p>


<h3>References</h3>

<p>Johnson, R. A. and Wehrly, T. (1977). Measures and models for angular
correlation and angular-linear correlation. <em>Journal of the Royal
Statistical Society. Series B (Methodological)</em>, 39(2):222&ndash;229.
<a href="https://www.jstor.org/stable/2984799">https://www.jstor.org/stable/2984799</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("wind")
plot(wind, xlab = expression(theta[1]), ylab = expression(theta[2]),
     xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE)
sdetorus::torusAxis()


# Perform TR-PCA
fit &lt;- ridge_pca(x = wind)
show_ridge_pca(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
