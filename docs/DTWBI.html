<!DOCTYPE html><html><head><title>Help for package DTWBI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DTWBI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DTWBI-package'>
<p>Imputation of Time Series Based on Dynamic Time Warping</p></a></li>
<li><a href='#compute.fa2'><p>FA2</p></a></li>
<li><a href='#compute.fb'><p>Fractional Bias (FB)</p></a></li>
<li><a href='#compute.fsd'><p>Fraction of Standard Deviation (FSD)</p></a></li>
<li><a href='#compute.nmae'><p>Normalized Mean Absolute Error (NMAE)</p></a></li>
<li><a href='#compute.rmse'><p>Root Mean Square Error (RMSE)</p></a></li>
<li><a href='#compute.sim'><p>Similarity</p></a></li>
<li><a href='#dataDTWBI'><p>Six univariate signals as example for DTWBI package</p></a></li>
<li><a href='#dist_afbdtw'><p>Adaptive Feature Based Dynamic Time Warping algorithm</p></a></li>
<li><a href='#DTWBI_univariate'><p>DTWBI algorithm for univariate signals</p></a></li>
<li><a href='#gapCreation'><p>Gap creation</p></a></li>
<li><a href='#local.derivative.ddtw'><p>Local derivative estimate to compute DDTW</p></a></li>
<li><a href='#minCost'><p>DTW-based methods for univariate signals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imputation of Time Series Based on Dynamic Time Warping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Camille Dezecache, T. T. Hong Phan, Emilie Poisson-Caillault</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emilie Poisson-Caillault &lt;emilie.poisson@univ-littoral.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to impute large gaps within time series based on Dynamic Time Warping methods. It contains all required functions to create large missing consecutive values within time series and to fill them, according to the paper Phan et al. (2017), &lt;<a href="https://doi.org/10.1016%2Fj.patrec.2017.08.019">doi:10.1016/j.patrec.2017.08.019</a>&gt;. Performance criteria are added to compare similarity between two signals (query and reference).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dtw, rlist, stats, e1071, entropy, lsa</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mawenzi.univ-littoral.fr/DTWBI/">http://mawenzi.univ-littoral.fr/DTWBI/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-10 14:10:33 UTC; camille</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-11 10:50:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='DTWBI-package'>
Imputation of Time Series Based on Dynamic Time Warping
</h2><span id='topic+DTWBI-package'></span><span id='topic+DTWBI'></span>

<h3>Description</h3>

<p>Functions to impute large gaps within time series based on Dynamic Time Warping methods. It contains all required functions to create large missing consecutive values within time series and to fill them, according to the paper Phan et al. (2017), &lt;DOI:10.1016/j.patrec.2017.08.019&gt;. Performance criteria are added to compare similarity between two signals (query and reference).
</p>


<h3>Details</h3>

<p>Index of help topics:
</p>
<pre>
DTWBI-package           Imputation of Time Series Based on Dynamic Time
                        Warping
DTWBI_univariate        DTWBI algorithm for univariate signals
compute.fa2             FA2
compute.fb              Fractional Bias (FB)
compute.fsd             Fraction of Standard Deviation (FSD)
compute.nmae            Normalized Mean Absolute Error (NMAE)
compute.rmse            Root Mean Square Error (RMSE)
compute.sim             Similarity
dataDTWBI               Six univariate signals as example for DTWBI
                        package
dist_afbdtw             Adaptive Feature Based Dynamic Time Warping
                        algorithm
gapCreation             Gap creation
local.derivative.ddtw   Local derivative estimate to compute DDTW
minCost                 DTW-based methods for univariate signals
</pre>


<h3>Author(s)</h3>

<p>Camille Dezecache, T. T. Hong Phan, Emilie Poisson-Caillault
</p>
<p>Maintainer: Emilie Poisson-Caillault &lt;emilie.poisson@univ-littoral.fr&gt;
</p>


<h3>References</h3>

<p>Thi-Thu-Hong Phan, Emilie Poisson-Caillault, Alain Lefebvre, Andre Bigand. Dynamic time warping-
based imputation for univariate time series data.  Pattern Recognition Letters, Elsevier, 2017,
&lt;DOI:10.1016/j.patrec.2017.08.019&gt;. &lt;hal-01609256&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load package dataset
data(dataDTWBI)

# Create a query and a reference signal
query &lt;- dataDTWBI$query
ref &lt;- dataDTWBI$query

# Create a gap within query (10% of signal size)
query &lt;- gapCreation(query, rate = 0.1)
data &lt;- query$output_vector
begin_gap &lt;- query$begin_gap
size_gap &lt;- query$gap_size

# Fill gap using DTWBI algorithm
results_DTWBI &lt;- DTWBI_univariate(data, t_gap = begin_gap, T_gap = size_gap)

# Plot
plot(ref, type = "l")
lines(results_DTWBI$output_vector, col = "red", lty = "dashed")

# Compute the similarity of imputed vector and reference
compute.sim(ref, results_DTWBI$output_vector)
</code></pre>

<hr>
<h2 id='compute.fa2'>FA2</h2><span id='topic+compute.fa2'></span>

<h3>Description</h3>

<p>Estimates the FA2 of two univariate signals Y (imputed values) and X (true values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.fa2(Y, X, verbose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.fa2_+3A_y">Y</code></td>
<td>
<p>vector of imputed values</p>
</td></tr>
<tr><td><code id="compute.fa2_+3A_x">X</code></td>
<td>
<p>vector of true values</p>
</td></tr>
<tr><td><code id="compute.fa2_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, print advice about the quality of the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of FA2 of two vectors corresponding to univariate signals X (true values) and Y (imputed values).
This FA2 corresponds to the percentage of pairs of values (<code class="reqn">x_{i}, y_{i}</code>) satisfying the condition <code class="reqn">0,5 &lt;= (Y_{i}/X_{i}) &lt;= 2</code>.
The closer FA2 is to 1, the more accurate is the imputation model.
Both vectors Y and X must be of equal length, on the contrary an error will be displayed.
In both input vectors, eventual NA will be exluded with a warning diplayed.
</p>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
compute.fa2(Y,X)
compute.fa2(Y,X, verbose = TRUE)

# By definition, if pairs of true and imputed values are zero,
# FA2 corresponding to this pair of values equals 1.
X[1] &lt;- 0
Y[1] &lt;- 0
compute.fa2(Y,X)
</code></pre>

<hr>
<h2 id='compute.fb'>Fractional Bias (FB)</h2><span id='topic+compute.fb'></span>

<h3>Description</h3>

<p>Estimates the Fractional Bias (FB) of two univariate signals Y (imputed values) and X (true values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.fb(Y, X, verbose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.fb_+3A_y">Y</code></td>
<td>
<p>vector of imputed values</p>
</td></tr>
<tr><td><code id="compute.fb_+3A_x">X</code></td>
<td>
<p>vector of true values</p>
</td></tr>
<tr><td><code id="compute.fb_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, print advice about the quality of the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of FB of two vectors corresponding to univariate signals, indicating whether predicted values are underestimated or overestimated compared to true values.
A perfect imputation model gets <code class="reqn">FB = 0</code>.
An acceptable imputation model gives <code class="reqn">FB &lt;= 0.3</code>.
Both vectors Y and X must be of equal length, on the contrary an error will be displayed.
In both input vectors, eventual NA will be exluded with a warning diplayed.
</p>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
compute.fb(Y,X)
compute.fb(Y,X, verbose = TRUE)

# If mean(X)=mean(Y)=0, it is impossible to estimate FB,
# unless both true and imputed values vectors are constant.
# By definition, in this case, FB = 0.
X &lt;- rep(0, 10) ; Y &lt;- rep(0, 10)
compute.fb(Y,X)

# If true and imputed values are not zero and are opposed, FB = Inf.
X &lt;- rep(runif(1), 10)
Y &lt;- -X
compute.fb(Y,X)
</code></pre>

<hr>
<h2 id='compute.fsd'>Fraction of Standard Deviation (FSD)</h2><span id='topic+compute.fsd'></span>

<h3>Description</h3>

<p>Estimates the Fraction of Standard Deviation (FSD) of two univariate signals Y (imputed values) and X (true values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.fsd(Y, X, verbose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.fsd_+3A_y">Y</code></td>
<td>
<p>vector of imputed values</p>
</td></tr>
<tr><td><code id="compute.fsd_+3A_x">X</code></td>
<td>
<p>vector of true values</p>
</td></tr>
<tr><td><code id="compute.fsd_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, print advice about the quality of the model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of FSD of two vectors corresponding to univariate signals.
Values of FSD closer to zero indicate a better performance method for the imputation task.
Both vectors Y and X must be of equal length, on the contrary an error will be displayed.
In both input vectors, eventual NA will be exluded with a warning diplayed.
</p>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
compute.fsd(Y,X)
compute.fsd(Y,X, verbose = TRUE)

# By definition, if true and imputed values are equal and constant,
# FSD = 0.
X &lt;- rep(runif(1), 10)
Y &lt;- X
compute.fsd(Y,X)

# However, if true and imputed values are constant but different,
# FSD is not calculable. An error is displayed.
## Not run: 
X &lt;- rep(runif(1), 10);Y &lt;- rep(runif(1), 10)
compute.fsd(Y,X)
## End(Not run)
</code></pre>

<hr>
<h2 id='compute.nmae'>Normalized Mean Absolute Error (NMAE)</h2><span id='topic+compute.nmae'></span>

<h3>Description</h3>

<p>Estimates the Normalized Mean Absolute Error of two univariate signals Y (imputed values) and X (true values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.nmae(Y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.nmae_+3A_y">Y</code></td>
<td>
<p>vector of imputed values</p>
</td></tr>
<tr><td><code id="compute.nmae_+3A_x">X</code></td>
<td>
<p>vector of true values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of NMAE of two vectors corresponding to univariate signals.
A lower NMAE (<code class="reqn">NMAE \in [0, \inf]</code>) value indicates a better performance method for the imputation task.
Both vectors Y and X must be of equal length, on the contrary an error will be displayed.
In both input vectors, eventual NA will be exluded with a warning diplayed.
</p>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
compute.nmae(Y,X)

# If true values is a constant vector, NMAE = Inf.
# A warning is displayed and MAE is estimated instead of NMAE,
# unless true and imputed values are equal. In this case,
# by definition, NMAE = 0.
X &lt;- rep(0, 10)
Y &lt;- runif(10)
compute.nmae(Y,X) # MAE computed
Y &lt;- X
compute.nmae(Y,X) # By definition, NMAE = 0
</code></pre>

<hr>
<h2 id='compute.rmse'>Root Mean Square Error (RMSE)</h2><span id='topic+compute.rmse'></span>

<h3>Description</h3>

<p>Estimates the Root Mean Square Error of two univariate signals Y (imputed values) and X (true values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.rmse(Y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.rmse_+3A_y">Y</code></td>
<td>
<p>vector of imputed values</p>
</td></tr>
<tr><td><code id="compute.rmse_+3A_x">X</code></td>
<td>
<p>vector of true values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of RMSE of two vectors corresponding to univariate signals.
A lower RMSE (<code class="reqn">RMSE \in [0, \inf]</code>) value indicates a better performance method for the imputation task.
Both vectors Y and X must be of equal length, on the contrary an error will be displayed.
In both input vectors, eventual NA will be exluded with a warning diplayed.
</p>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
compute.rmse(Y,X)
</code></pre>

<hr>
<h2 id='compute.sim'>Similarity</h2><span id='topic+compute.sim'></span>

<h3>Description</h3>

<p>Estimates the percentage of similarity of two univariate signals Y (imputed values) and X (true values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.sim(Y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.sim_+3A_y">Y</code></td>
<td>
<p>vector of imputed values</p>
</td></tr>
<tr><td><code id="compute.sim_+3A_x">X</code></td>
<td>
<p>vector of true values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of similarity of two vectors corresponding to univariate signals.
A higher similarity (<code class="reqn">Similarity \in [0, 1]</code>) highlights a more accurate method for completing missing values in univariate datasets.
Both vectors Y and X must be of equal length, on the contrary an error will be displayed.
In both input vectors, eventual NA will be excluded with a warning diplayed.
</p>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
compute.sim(Y,X)

# By definition, if true values is a constant vector
# and one or more imputed values are equal to the true values,
# similarity = 1.
X &lt;- rep(2, 10)
Y &lt;- X
compute.sim(Y,X)
</code></pre>

<hr>
<h2 id='dataDTWBI'>Six univariate signals as example for DTWBI package</h2><span id='topic+dataDTWBI'></span>

<h3>Description</h3>

<p>Query and ref1 are two dephased sigmoidal signals.
Ref2 presents a linear decrease.
Ref3 and ref4 are constant signals of value 3 and 0 respectively.
Ref5 is similar to the query with small noise added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataDTWBI
</code></pre>


<h3>Format</h3>

<p>A data frame with six variables: <code>query</code>, <code>ref1</code>,
<code>ref2</code>, <code>ref3</code>, <code>ref4</code> and <code>ref5</code>.</p>

<hr>
<h2 id='dist_afbdtw'>Adaptive Feature Based Dynamic Time Warping algorithm</h2><span id='topic+dist_afbdtw'></span>

<h3>Description</h3>

<p>This function estimates a distance matrix which is used as an input in dtw() function (package dtw) to align two univariate signals following Adaptative Feature Based Dynamic Time Warping algorithm (AFBDTW).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_afbdtw(q, r, w1 = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_afbdtw_+3A_q">q</code></td>
<td>
<p>query vector</p>
</td></tr>
<tr><td><code id="dist_afbdtw_+3A_r">r</code></td>
<td>
<p>reference vector</p>
</td></tr>
<tr><td><code id="dist_afbdtw_+3A_w1">w1</code></td>
<td>
<p>weight of local feature VS global feature.
By default, w1 = 0.5, and by definition, w2 = 1 - w1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p>query: the query vector
</p>
</li>
<li><p>response: the response vector
</p>
</li>
<li><p>query_local: local feature of the query
</p>
</li>
<li><p>response_local: local feature of the response vector
</p>
</li>
<li><p>query_global: global feature of the query
</p>
</li>
<li><p>response_global: global feature of the response vector
</p>
</li>
<li><p>dist_local: distance matrix of the local feature
</p>
</li>
<li><p>dist_local: distance matrix of the global feature
</p>
</li>
<li><p>distAFBDTW: AFBDTW distance matrix
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]
AFBDTW_Dist &lt;- dist_afbdtw(X, Y)
</code></pre>

<hr>
<h2 id='DTWBI_univariate'>DTWBI algorithm for univariate signals</h2><span id='topic+DTWBI_univariate'></span>

<h3>Description</h3>

<p>Imputes values of a gap of position t_gap and size T in a univariate signal based on DTW algorithm.
For more details on the method, see Phan et al. (2017) DOI: &lt;10.1016/j.patrec.2017.08.019&gt;.
Default arguments of dtw() function are used but can be manually explicited and modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTWBI_univariate(data, t_gap, T_gap, DTW_method = "DTW",
  threshold_cos = NULL, step_threshold = NULL, thresh_cos_stop = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTWBI_univariate_+3A_data">data</code></td>
<td>
<p>input vector containing a large and continuous gap (eventually derived from local.derivative.ddtw() function)</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_t_gap">t_gap</code></td>
<td>
<p>location of the begining of the gap (eventually extracted from gapCreation function)</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_t_gap">T_gap</code></td>
<td>
<p>gap size (eventually extracted from gapCreation function)</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_dtw_method">DTW_method</code></td>
<td>
<p>DTW method used for imputation (&quot;DTW&quot;, &quot;DDTW&quot;, &quot;AFBDTW&quot;). By default &quot;DTW&quot;.</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_threshold_cos">threshold_cos</code></td>
<td>
<p>threshold used to define similar sequences to the query. By default, threshold_cos=0.9995 if sequence is longer than 10'000, and threshold_cos=0.995 if shorter.</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_step_threshold">step_threshold</code></td>
<td>
<p>step used within the loop determining the threshold. By default, step_threshold=50 if sequence is longer than 10'000, step_threshold=10 if sequence length is between 1'000 and 10'000. Else, step_threshold=2.</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_thresh_cos_stop">thresh_cos_stop</code></td>
<td>
<p>Define the lowest cosine threshold acceptable to find a similar window to the query. By default, thresh_cos_stop=0.8.</p>
</td></tr>
<tr><td><code id="DTWBI_univariate_+3A_...">...</code></td>
<td>
<p>additional arguments from the dtw() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>DTWBI_univariate returns a list containing the following elements:
</p>

<ul>
<li><p>output_vector: output vector containing complete data including the imputation proposal
</p>
</li>
<li><p>input_vector: original vector used as input
</p>
</li>
<li><p>query: the query i.e. the adjacent sequence to the gap
</p>
</li>
<li><p>pos_query: index of the begining and end of the query
</p>
</li>
<li><p>sim_window: vector containing the values of the most similar sequence to the query
</p>
</li>
<li><p>pos_sim_window: index of the begining and end of the similar window
</p>
</li>
<li><p>imputation_window: vector containing imputed values
</p>
</li>
<li><p>pos_imp_window: index of the begining and end of the imputation window
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1]

rate &lt;- 0.1
output &lt;- gapCreation(X, rate)
data &lt;- output$output_vector
gap_begin &lt;- output$begin_gap
gap_size &lt;- output$gap_size
imputed_data &lt;- DTWBI_univariate(data, t_gap=gap_begin, T_gap=gap_size)
plot(imputed_data$input_vector, type = "l", lwd = 2) # Uncomplete signal
lines(imputed_data$output_vector, col = "red") # Imputed signal
lines(y = imputed_data$query,
      x = imputed_data$pos_query[1]:imputed_data$pos_query[2],
      col = "green", lwd = 4) # Query
lines(y = imputed_data$sim_window,
      x = imputed_data$pos_sim_window[1]:imputed_data$pos_sim_window[2],
      col = "orange", lwd = 4) # Similar sequence to the query
lines(y = imputed_data$imputation_window,
      x = imputed_data$pos_imp_window[1]:imputed_data$pos_imp_window[2],
      col = "blue", lwd = 4) # Imputing proposal
</code></pre>

<hr>
<h2 id='gapCreation'>Gap creation</h2><span id='topic+gapCreation'></span>

<h3>Description</h3>

<p>This function creates a large continuous gap within a univariate signal.
Gap size is defined as a percentage of input vector length.
By default, the created gap starts at a random location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapCreation(X, rate, begin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapCreation_+3A_x">X</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="gapCreation_+3A_rate">rate</code></td>
<td>
<p>size of desired gap, as a percentage of input vector size</p>
</td></tr>
<tr><td><code id="gapCreation_+3A_begin">begin</code></td>
<td>
<p>location of the begining of the gap (random by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gapCreation returns a list containing the following elements:
</p>

<ul>
<li><p>output_vector: output vector containing the created gap
</p>
</li>
<li><p>input_vector: original vector used as input
</p>
</li>
<li><p>begin_gap: index of the begining of the gap
</p>
</li>
<li><p>rate: size of the created gap in percentage of the input vector length
</p>
</li>
<li><p>gap_size: length of the created gap
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1]
rate &lt;- 0.1
output &lt;- gapCreation(X, rate)
plot(output$input_vector, type = "l", col = "red", lwd = 2)
lines(output$output_vector, lty = "dashed", lwd = 2)
</code></pre>

<hr>
<h2 id='local.derivative.ddtw'>Local derivative estimate to compute DDTW</h2><span id='topic+local.derivative.ddtw'></span>

<h3>Description</h3>

<p>This function estimates the local derivative of a vector.
It can be used as an input in dtw() function (package dtw) to align two univariate signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local.derivative.ddtw(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local.derivative.ddtw_+3A_x">X</code></td>
<td>
<p>input vector from which local derivative has to be calculated</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1]
local.derivative.ddtw(X)

# Plot
plot(X, type = "b", ylim = c(-1, 1))
lines(local.derivative.ddtw(X), col = "red")
</code></pre>

<hr>
<h2 id='minCost'>DTW-based methods for univariate signals</h2><span id='topic+minCost'></span>

<h3>Description</h3>

<p>Finds the optimal alignment between two univariate time series based on DTW methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minCost(X, Y, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minCost_+3A_x">X</code></td>
<td>
<p>query vector</p>
</td></tr>
<tr><td><code id="minCost_+3A_y">Y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="minCost_+3A_method">method</code></td>
<td>
<p>&quot;DTW&quot;, &quot;DDTW&quot;, &quot;AFBDTW&quot;, &quot;DTW-D&quot;</p>
</td></tr>
<tr><td><code id="minCost_+3A_...">...</code></td>
<td>
<p>additional arguments from functions dtw or dist_afbdtw</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camille Dezecache, Hong T. T. Phan, Emilie Poisson-Caillault
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDTWBI)
X &lt;- dataDTWBI[, 1] ; Y &lt;- dataDTWBI[, 2]

# Plot query and reference
plot(X, type = "l", ylim = c(-5,3))
lines(1:length(X), Y, col = "red")

#= Align signals using DTW
align_dtw &lt;- minCost(X, Y, method = "DTW")
#= Align signals using DDTW
align_ddtw &lt;- minCost(X, Y, method = "DDTW")
#= Align signals using AFBDTW
align_afbdtw &lt;- minCost(X, Y, method = "AFBDTW")
#= Align signals using DTW-D
align_dtwd &lt;- minCost(X, Y, method = "DTW-D")

#= Plots
library(dtw)
dtwPlotTwoWay(d = align_dtw, xts &lt;- X, yts = Y, main = "DTW")
dtwPlotTwoWay(d = align_ddtw, xts &lt;- X, yts = Y, main = "DDTW")
dtwPlotTwoWay(d = align_afbdtw, xts &lt;- X, yts = Y, main = "AFBDTW")
dtwPlotTwoWay(d = align_dtwd, xts &lt;- X, yts = Y, main = "DTW-D")

#= Compare cost of each method
comparative_cost &lt;- matrix(c(align_dtw$normalizedDistance,
align_ddtw$normalizedDistance,
align_afbdtw$normalizedDistance,
align_dtwd$normalizedDistance), ncol = 4)
colnames(comparative_cost) &lt;- c("DTW", "DDTW", "AFBDTW", "DTW-D")
comparative_cost
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
