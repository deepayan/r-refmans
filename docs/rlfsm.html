<!DOCTYPE html><html><head><title>Help for package rlfsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rlfsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a_p'><p>Function a_p.</p></a></li>
<li><a href='#a_tilda'><p>Creates the corresponding value from the paper by Stoev and Taqqu (2004).</p></a></li>
<li><a href='#alpha_hat'><p>Statistical estimator for alpha</p></a></li>
<li><a href='#ContinEstim'><p>Parameter estimation procedure in continuous case.</p></a></li>
<li><a href='#GenHighEstim'><p>High frequency estimation procedure for lfsm.</p></a></li>
<li><a href='#GenLowEstim'><p>Low frequency estimation procedure for lfsm.</p></a></li>
<li><a href='#H_hat'><p>Statistical estimator of H in high/low frequency setting</p></a></li>
<li><a href='#h_kr'><p>Function h_kr</p></a></li>
<li><a href='#increment'><p>Higher order increments</p></a></li>
<li><a href='#m_pk'><p>m(-p,k)</p></a></li>
<li><a href='#MCestimLFSM'><p>Numerical properties of statistical estimators operating on the linear fractional stable motion.</p></a></li>
<li><a href='#Norm_alpha'><p>Alpha-norm of an arbitrary function</p></a></li>
<li><a href='#path'><p>Generator of linear fractional stable motion</p></a></li>
<li><a href='#Path_array'><p>Path array generator</p></a></li>
<li><a href='#paths'><p>Generator of a set of lfsm paths.</p></a></li>
<li><a href='#phi'><p>Phi</p></a></li>
<li><a href='#phi_of_alpha'><p>Inverse alpha estimator</p></a></li>
<li><a href='#Plot_dens'><p>(alpha,H,sigma)- density plot</p></a></li>
<li><a href='#Plot_list_paths'><p>Rendering of path lattice</p></a></li>
<li><a href='#Plot_vb'><p>A function to plot variance- and bias dependencies of estimators on the lengths of sample paths. Works in conjunction with <code>MCestimLFSM</code> function.</p></a></li>
<li><a href='#R_hl'><p>R high /low</p></a></li>
<li><a href='#Retrieve_stats'><p>Retrieve statistics(bias, variance) of estimators based on a set of paths</p></a></li>
<li><a href='#sf'><p>Statistic V</p></a></li>
<li><a href='#sigma_hat'><p>Statistical estimator for sigma</p></a></li>
<li><a href='#theta'><p>Function theta</p></a></li>
<li><a href='#U_g'><p>alpha norm of u*g</p></a></li>
<li><a href='#U_gh'><p>alpha-norm of u*g + v*h.</p></a></li>
<li><a href='#U_ghuv'><p>A dependence structure of 2 random variables.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulations and Statistical Inference for Linear Fractional
Stable Motions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dmitry Otryakhin &lt;d.otryakhin.acad@protonmail.ch&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Dmitry Otryakhin <a href="https://orcid.org/0000-0002-4700-7221"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Stepan Mazur <a href="https://orcid.org/0000-0002-1395-9427"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mathias Ljungdahl [ctb]</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for simulating the linear fractional stable motion according to the algorithm developed by Mazur and Otryakhin &lt;<a href="https://doi.org/10.32614%2FRJ-2020-008">doi:10.32614/RJ-2020-008</a>&gt; based on the method from Stoev and Taqqu (2004) &lt;<a href="https://doi.org/10.1142%2FS0218348X04002379">doi:10.1142/S0218348X04002379</a>&gt;, as well as functions for estimation of parameters of these processes introduced by Mazur, Otryakhin and Podolskij (2018) &lt;<a href="https://arxiv.org/abs/1802.06373">arXiv:1802.06373</a>&gt;, and also different related quantities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/Dmitry_Otryakhin/Tools-for-parameter-estimation-of-the-linear-fractional-stable-motion">https://gitlab.com/Dmitry_Otryakhin/Tools-for-parameter-estimation-of-the-linear-fractional-stable-motion</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, foreach, doParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, stabledist, reshape2, plyr, Rdpack, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>elliptic, testthat, stringi</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-27 10:44:26 UTC; d</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-27 13:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='a_p'>Function a_p.</h2><span id='topic+a_p'></span>

<h3>Description</h3>

<p>Computes the corresponding function value from Mazur et al. 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_p(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_p_+3A_p">p</code></td>
<td>
<p>power, real number from (-1,1)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>

<hr>
<h2 id='a_tilda'>Creates the corresponding value from the paper by Stoev and Taqqu (2004).</h2><span id='topic+a_tilda'></span>

<h3>Description</h3>

<p>a_tilda triggers a_tilda_cpp which is written in C++ and essentially
performs the computation of the value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_tilda(N, m, M, alpha, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_tilda_+3A_n">N</code></td>
<td>
<p>a number of points of the lfsm.</p>
</td></tr>
<tr><td><code id="a_tilda_+3A_m">m</code></td>
<td>
<p>discretization. A number of points between two nearby motion points</p>
</td></tr>
<tr><td><code id="a_tilda_+3A_m">M</code></td>
<td>
<p>truncation parameter. A number of points at which the integral representing the definition of lfsm is calculated. So, after M points back we consider the rest of the integral to be 0.</p>
</td></tr>
<tr><td><code id="a_tilda_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="a_tilda_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
</table>


<h3>References</h3>

<p>Stoev S, Taqqu MS (2004).
&ldquo;Simulation methods for linear fractional stable motion and FARIMA using the Fast Fourier Transform.&rdquo;
<em>Fractals</em>, <b>95</b>(1), 95-121.
<a href="https://doi.org/10.1142/S0218348X04002379">https://doi.org/10.1142/S0218348X04002379</a>.
</p>

<hr>
<h2 id='alpha_hat'>Statistical estimator for alpha</h2><span id='topic+alpha_hat'></span>

<h3>Description</h3>

<p>Defined for the two frequencies as
</p>
<p style="text-align: center;"><code class="reqn">\widehat \alpha_{high} := \frac{\log | \log \varphi_{high} (t_2; \widehat H_{high} (p,k)_n, k)_n|  -  \log | \log \varphi_{high} (t_1; \widehat H_{high} (p,k)_n, k)_n|}{\log t_2 - \log t_1}</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat \alpha_{low} := \frac{\log | \log \varphi_{low} (t_2;k)_n|  -  \log | \log \varphi_{low} (t_1; k)_n|}{\log t_2 - \log t_1}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>alpha_hat(t1, t2, k, path, H, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_hat_+3A_t1">t1</code>, <code id="alpha_hat_+3A_t2">t2</code></td>
<td>
<p>real number such that  t2 &gt; t1 &gt; 0</p>
</td></tr>
<tr><td><code id="alpha_hat_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="alpha_hat_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
<tr><td><code id="alpha_hat_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="alpha_hat_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function triggers function <code><a href="#topic+phi">phi</a></code>, thus Hurst parameter is required only in high frequency case. In the low frequency, there is no need to assign H a value because it will not be evaluated.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m&lt;-45; M&lt;-60; N&lt;-2^14-M
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
freq='H'
r=1; k=2; p=0.4; t1=1; t2=2

# Estimating alpha in the high frequency case
# using preliminary estimation of H
lfsm&lt;-path(N=N,m=m,M=M,alpha=alpha,H=H,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm

H_est&lt;-H_hat(p=p,k=k,path=lfsm)
H_est
alpha_est&lt;-alpha_hat(t1=t1,t2=t2,k=k,path=lfsm,H=H_est,freq=freq)
alpha_est

</code></pre>

<hr>
<h2 id='ContinEstim'>Parameter estimation procedure in continuous case.</h2><span id='topic+ContinEstim'></span>

<h3>Description</h3>

<p>Parameter freq is preserved to allow for investigation of the inference procedure in high frequency case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ContinEstim(t1, t2, p, k, path, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ContinEstim_+3A_t1">t1</code>, <code id="ContinEstim_+3A_t2">t2</code></td>
<td>
<p>real number such that  t2 &gt; t1 &gt; 0</p>
</td></tr>
<tr><td><code id="ContinEstim_+3A_p">p</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="ContinEstim_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="ContinEstim_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
<tr><td><code id="ContinEstim_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
alpha&lt;-0.8; H&lt;-0.8; sigma&lt;-0.3
p&lt;-0.3; k=3; t1=1; t2=2

lfsm&lt;-path(N=N,m=m,M=M,alpha=alpha,H=H,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm
ContinEstim(t1,t2,p,k,path=lfsm,freq='L')
</code></pre>

<hr>
<h2 id='GenHighEstim'>High frequency estimation procedure for lfsm.</h2><span id='topic+GenHighEstim'></span>

<h3>Description</h3>

<p>General estimation procedure for high frequency case when 1/alpha is not a natural number.
&quot;Unnecessary&quot; parameter freq is preserved to allow for investigation of the inference procedure in low frequency case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenHighEstim(p, p_prime, path, freq, low_bound = 0.01, up_bound = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenHighEstim_+3A_p">p</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="GenHighEstim_+3A_p_prime">p_prime</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="GenHighEstim_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
<tr><td><code id="GenHighEstim_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
<tr><td><code id="GenHighEstim_+3A_low_bound">low_bound</code></td>
<td>
<p>positive real number</p>
</td></tr>
<tr><td><code id="GenHighEstim_+3A_up_bound">up_bound</code></td>
<td>
<p>positive real number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this algorithm the preliminary estimate of alpha is found via using <code><a href="stats.html#topic+uniroot">uniroot</a></code> function. The latter is
given the lower and the upper bounds for alpha via low_bound and up_bound parameters. It is not possible to
pass 0 as the lower bound because there are numerical limitations on the alpha estimate, caused by the
length of the sample path and by numerical errors. p and p_prime must belong to the interval (0,1/2) (in the notation kept in rlfsm package)
The two powers cannot be equal.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
sigma&lt;-0.3
p&lt;-0.2; p_prime&lt;-0.4

#### Continuous case
lfsm&lt;-path(N=N,m=m,M=M,alpha=1.8,H=0.8,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm

GenHighEstim(p=p,p_prime=p_prime,path=lfsm,freq="H")

#### H-1/alpha&lt;0 case
lfsm&lt;-path(N=N,m=m,M=M,alpha=0.8,H=0.8,
           sigma=sigma,freq='H',disable_X=FALSE,seed=3)$lfsm

GenHighEstim(p=p,p_prime=p_prime,path=lfsm,freq="H")

</code></pre>

<hr>
<h2 id='GenLowEstim'>Low frequency estimation procedure for lfsm.</h2><span id='topic+GenLowEstim'></span>

<h3>Description</h3>

<p>General estimation procedure for low frequency case when 1/alpha is not a natural number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenLowEstim(t1, t2, p, path, freq = "L")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenLowEstim_+3A_t1">t1</code>, <code id="GenLowEstim_+3A_t2">t2</code></td>
<td>
<p>real number such that  t2 &gt; t1 &gt; 0</p>
</td></tr>
<tr><td><code id="GenLowEstim_+3A_p">p</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="GenLowEstim_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
<tr><td><code id="GenLowEstim_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
sigma&lt;-0.3
p&lt;-0.3; k=3; t1=1; t2=2

#### Continuous case
lfsm&lt;-path(N=N,m=m,M=M,alpha=1.8,H=0.8,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm

GenLowEstim(t1=t1,t2=t2,p=p,path=lfsm,freq="L")

#### H-1/alpha&lt;0 case
lfsm&lt;-path(N=N,m=m,M=M,alpha=0.8,H=0.8,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm

GenLowEstim(t1=t1,t2=t2,p=p,path=lfsm,freq="L")

#### The procedure works also for high frequency case
lfsm&lt;-path(N=N,m=m,M=M,alpha=1.8,H=0.8,
           sigma=sigma,freq='H',disable_X=FALSE,seed=3)$lfsm

GenLowEstim(t1=t1,t2=t2,p=p,path=lfsm,freq="H")
</code></pre>

<hr>
<h2 id='H_hat'>Statistical estimator of H in high/low frequency setting</h2><span id='topic+H_hat'></span>

<h3>Description</h3>

<p>The statistic is defined as
</p>
<p style="text-align: center;"><code class="reqn">\widehat{H}_{\textnormal{high}} (p,k)_n:= \frac 1p \log_2  R_{\textnormal{high}} (p,k)_n,
\qquad \widehat{H}_{\textnormal{low}} (p,k)_n:= \frac 1p \log_2  R_{\textnormal{low}} (p,k)_n</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>H_hat(p, k, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_hat_+3A_p">p</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="H_hat_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="H_hat_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>

<hr>
<h2 id='h_kr'>Function h_kr</h2><span id='topic+h_kr'></span>

<h3>Description</h3>

<p>Function <code class="reqn">h_{k,r}: R \to R</code> is given by </p>
<p style="text-align: center;"><code class="reqn">h_{k,r} (x) = \sum_{j=0}^k (-1)^j {{k}\choose{j}} (x-rj)_+^{H-1/\alpha}, \ \ \ x\in R</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>h_kr(k, r, x, H, alpha, l = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_kr_+3A_k">k</code></td>
<td>
<p>order of the increment, a natural number</p>
</td></tr>
<tr><td><code id="h_kr_+3A_r">r</code></td>
<td>
<p>difference step, a natural number</p>
</td></tr>
<tr><td><code id="h_kr_+3A_x">x</code></td>
<td>
<p>real number</p>
</td></tr>
<tr><td><code id="h_kr_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="h_kr_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="h_kr_+3A_l">l</code></td>
<td>
<p>a value by which we shift x. Is used for computing function f_.+l and is passed to integrate function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Plot h_kr ####
s&lt;-seq(0,10, by=0.01)
h_val&lt;-sapply(s,h_kr, k=5, r=1, H=0.3, alpha=1)
plot(s,h_val)
</code></pre>

<hr>
<h2 id='increment'>Higher order increments</h2><span id='topic+increment'></span><span id='topic+increments'></span>

<h3>Description</h3>

<p>Difference of the kth order. Defined as following:
</p>
<p style="text-align: center;"><code class="reqn">\Delta_{i,k}^{n,r} X:= \sum_{j=0}^k (-1)^j{{k}\choose{j}}X_{(i-rj)/n}, i\geq rk.</code>
</p>

<p>Index i here is a coordinate in terms of point_num. Although R uses vector indexes
that start from 1, increment has i varying from 0 to N, so that a
vector has a length N+1. It is done in order to comply with the notation of the paper.
This function doesn't allow for choosing frequency n. The frequency is determined by the
path supplied, thus n equals to either the length of the path in high frequency setting
or 1 in low frequency setting. increment() gives increments at certain point passed as i,
which is a vector here. increments() computes high order increments for the whole sample
path. The first function evaluates the formula above, while the second one uses structure
diff(diff(...)) because the formula is slower at higher k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increment(r, i, k, path)

increments(k, r, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increment_+3A_r">r</code></td>
<td>
<p>difference step, a natural number</p>
</td></tr>
<tr><td><code id="increment_+3A_i">i</code></td>
<td>
<p>index of the point at which the increment is to be computed, a natural number.</p>
</td></tr>
<tr><td><code id="increment_+3A_k">k</code></td>
<td>
<p>order of the increment, a natural number</p>
</td></tr>
<tr><td><code id="increment_+3A_path">path</code></td>
<td>
<p>sample path for which a kth order increment is computed</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m&lt;-45; M&lt;-60; N&lt;-2^10-M
alpha&lt;-0.8; H&lt;-0.8; sigma&lt;-0.3

lfsm&lt;-path(N=N,m=m,M=M,alpha=alpha,H=H,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm

tryCatch(
increment(r=1,i=length(lfsm),k=length(lfsm)+100,path=lfsm),
error=function(c) 'An error occures when k is larger then the length of the sample path')

increment(r=3,i=50,k=3,path=lfsm)


path=c(1,4,3,6,8,5,3,5,8,5,1,8,6)

r=2; k=3
n &lt;- length(path) - 1
DeltaX = increment(seq(r*k, n), path = path, k = k, r = r)
DeltaX == increments(k=k,r=r,path)
</code></pre>

<hr>
<h2 id='m_pk'>m(-p,k)</h2><span id='topic+m_pk'></span>

<h3>Description</h3>

<p>defined as <code class="reqn">m_{p,k} := E[|\Delta_{k,k} X|^p]</code> for positive powers.  When p is negative (-p is positive) the equality does not hold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_pk(k, p, alpha, H, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_pk_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="m_pk_+3A_p">p</code></td>
<td>
<p>a positive number</p>
</td></tr>
<tr><td><code id="m_pk_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="m_pk_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="m_pk_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of lfsm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following identity is used for computations: </p>
<p style="text-align: center;"><code class="reqn">m_{-p,k} =  \frac{(\sigma \|h_k\|_{\alpha})^{-p}}{a_{-p}} \int_{\R} \exp(-|y|^{\alpha}) |y|^{-1+p} dy = \frac{2(\sigma \|h_k\|_{\alpha})^{-p}}{\alpha a_{-p}} \Gamma(p/\alpha)</code>
</p>



<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>

<hr>
<h2 id='MCestimLFSM'>Numerical properties of statistical estimators operating on the linear fractional stable motion.</h2><span id='topic+MCestimLFSM'></span>

<h3>Description</h3>

<p>The function is useful, for instance, when one needs to compute standard deviation of <code class="reqn">\widehat \alpha_{high}</code>
estimator given a fixed set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCestimLFSM(Nmc, s, m, M, alpha, H, sigma, fr, Inference, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCestimLFSM_+3A_nmc">Nmc</code></td>
<td>
<p>Number of Monte Carlo repetitions</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_s">s</code></td>
<td>
<p>sequence of path lengths</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_m">m</code></td>
<td>
<p>discretization. A number of points between two nearby motion points</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_m">M</code></td>
<td>
<p>truncation parameter. A number of points at which the integral representing the definition of lfsm is calculated. So, after M points back we consider the rest of the integral to be 0.</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of lfsm</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_fr">fr</code></td>
<td>
<p>frequency. Either &quot;H&quot; or &quot;L&quot;</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_inference">Inference</code></td>
<td>
<p>statistical function to apply to sample paths</p>
</td></tr>
<tr><td><code id="MCestimLFSM_+3A_...">...</code></td>
<td>
<p>parameters to pass to Inference</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MCestimLFSM  performs Monte-Carlo experiments to compute parameters according to procedure Inference.
More specifically, for each element of s it generates Nmc lfsm sample paths with length equal to s[i], performs the statistical
inference on each, obtaining the estimates, and then returns their different statistics. It is vital that the estimator
returns a list of named parameters (one or several of 'sigma', 'alpha' and 'H'). MCestimLFSM uses the names to lookup the true
parameter value and compute its bias.
</p>
<p>For sample path generation MCestimLFSM uses a light-weight version of path, path_fast. In order to be applied,
function Inference must accept argument 'path' as a sample path.
</p>


<h3>Value</h3>

<p>It returns a list containing the following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a data frame, values of the estimates depending on path length s</p>
</td></tr>
<tr><td><code>data_nor</code></td>
<td>
<p>a data frame, normalized values of the estimates depending on path length s</p>
</td></tr>
<tr><td><code>means</code>, <code>biases</code>, <code>sds</code></td>
<td>
<p>data frames: means, biases and standard deviations of the estimators depending on s</p>
</td></tr>
<tr><td><code>Inference</code></td>
<td>
<p>a function used to obtain estimates</p>
</td></tr>
<tr><td><code>alpha</code>, <code>H</code>, <code>sigma</code></td>
<td>
<p>the parameters for which MCestimLFSM performs path generation</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>frequency, either 'L'  for low- or 'H' for high frequency</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#### Set of global parameters ####
m&lt;-25; M&lt;-60
p&lt;-.4; p_prime&lt;-.2; k&lt;-2
t1&lt;-1; t2&lt;-2
NmonteC&lt;-5e1
S&lt;-c(1e2,3e2)
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3


# How to plot empirical density

theor_3_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,ContinEstim,
                     t1=t1,t2=t2,p=p,k=k)
l_plot&lt;-Plot_dens(par_vec=c('sigma','alpha','H'),
                  MC_data=theor_3_1_H_clt, Nnorm=1e7)



# For MCestimLFSM() it is vital that the estimator returns a list of named parameters

H_hat_f &lt;- function(p,k,path) {hh&lt;-H_hat(p,k,path); list(H=hh)}
theor_3_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,H_hat_f,
                     p=p,k=k)


# The estimator can return one, two or three of the parameters.

est_1 &lt;- function(path) list(H=1)
theor_3_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,est_1)

est_2 &lt;- function(path) list(H=0.8, alpha=1.5)
theor_3_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,est_2)

est_3 &lt;- function(path) list(sigma=5, H=0.8, alpha=1.5)
theor_3_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,est_3)
</code></pre>

<hr>
<h2 id='Norm_alpha'>Alpha-norm of an arbitrary function</h2><span id='topic+Norm_alpha'></span>

<h3>Description</h3>

<p>Alpha-norm of an arbitrary function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Norm_alpha(fun, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Norm_alpha_+3A_fun">fun</code></td>
<td>
<p>a function to compute a norm</p>
</td></tr>
<tr><td><code id="Norm_alpha_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="Norm_alpha_+3A_...">...</code></td>
<td>
<p>a set of parameters to pass to integrate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fun must accept a vector of values for evaluation. See ?integrate for further details.
Most problems with this function appear because of rather high precision. Try to tune rel.tol parameter first.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Norm_alpha(h_kr,alpha=1.8,k=2,r=1,H=0.8,l=4)
</code></pre>

<hr>
<h2 id='path'>Generator of linear fractional stable motion</h2><span id='topic+path'></span>

<h3>Description</h3>

<p>The function creates a 1-dimensional LFSM sample path using the numerical algorithm from the paper by Otryakhin and Mazur. The theoretical foundation of the method comes from the article by Stoev and Taqqu. Linear fractional stable motion is defined as
</p>
<p style="text-align: center;"><code class="reqn">X_t = \int_{\R} \left\{(t-s)_+^{H-1/\alpha} - (-s)_+^{H-1/\alpha} \right\} dL_s</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>path(
  N = NULL,
  m,
  M,
  alpha,
  H,
  sigma,
  freq,
  disable_X = FALSE,
  levy_increments = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_n">N</code></td>
<td>
<p>a number of points of the lfsm.</p>
</td></tr>
<tr><td><code id="path_+3A_m">m</code></td>
<td>
<p>discretization. A number of points between two nearby motion points</p>
</td></tr>
<tr><td><code id="path_+3A_m">M</code></td>
<td>
<p>truncation parameter. A number of points at which the integral representing the definition of lfsm is calculated. So, after M points back we consider the rest of the integral to be 0.</p>
</td></tr>
<tr><td><code id="path_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="path_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="path_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of lfsm</p>
</td></tr>
<tr><td><code id="path_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
<tr><td><code id="path_+3A_disable_x">disable_X</code></td>
<td>
<p>is needed to disable computation of X. The default value is FALSE. When it is TRUE, only a levy motion is returned, which in turn reduces the computation time. The feature is particularly useful for reproducibility when combined with seeding.</p>
</td></tr>
<tr><td><code id="path_+3A_levy_increments">levy_increments</code></td>
<td>
<p>increments of Levy motion underlying the lfsm.</p>
</td></tr>
<tr><td><code id="path_+3A_seed">seed</code></td>
<td>
<p>this parameter performs seeding of path generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list containing the motion, the underlying Levy motion, the point number of the motions from 0 to N and the corresponding coordinate (which depends on the frequency), the parameters that were used to generate the lfsm, and the predefined frequency.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D (2020).
&ldquo;Linear Fractional Stable Motion with the rlfsm R Package.&rdquo;
<em>The R Journal</em>, <b>12</b>(1), 386&ndash;405.
<a href="https://doi.org/10.32614/RJ-2020-008">doi:10.32614/RJ-2020-008</a>.
</p>
<p>Stoev S, Taqqu MS (2004).
&ldquo;Simulation methods for linear fractional stable motion and FARIMA using the Fast Fourier Transform.&rdquo;
<em>Fractals</em>, <b>95</b>(1), 95-121.
<a href="https://doi.org/10.1142/S0218348X04002379">https://doi.org/10.1142/S0218348X04002379</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paths">paths</a></code> simulates a number of lfsm sample paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Path generation

m&lt;-256; M&lt;-600; N&lt;-2^10-M
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
seed=2

List&lt;-path(N=N,m=m,M=M,alpha=alpha,H=H,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)

# Normalized paths
Norm_lfsm&lt;-List[['lfsm']]/max(abs(List[['lfsm']]))
Norm_oLm&lt;-List[['levy_motion']]/max(abs(List[['levy_motion']]))

# Visualization of the paths
plot(Norm_lfsm, col=2, type="l", ylab="coordinate")
lines(Norm_oLm, col=3)
leg.txt &lt;- c("lfsm", "oLm")
legend("topright",legend = leg.txt, col =c(2,3), pch=1)


# Creating Levy motion
levyIncrems&lt;-path(N=N, m=m, M=M, alpha, H, sigma, freq='L',
                  disable_X=TRUE, levy_increments=NULL, seed=seed)

# Creating lfsm based on the levy motion
  lfsm_full&lt;-path(m=m, M=M, alpha=alpha,
                  H=H, sigma=sigma, freq='L',
                  disable_X=FALSE,
                  levy_increments=levyIncrems$levy_increments,
                  seed=seed)

sum(levyIncrems$levy_increments==
    lfsm_full$levy_increments)==length(lfsm_full$levy_increments)




</code></pre>

<hr>
<h2 id='Path_array'>Path array generator</h2><span id='topic+Path_array'></span>

<h3>Description</h3>

<p>The function takes a list of parameters (alpha, H) and uses <code><a href="base.html#topic+expand.grid">expand.grid</a></code> to obtain all possible combinations of them.
Based on each combination, the function simulates an lfsm sample path. It is meant to be used in conjunction with function <code><a href="#topic+Plot_list_paths">Plot_list_paths</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Path_array(N, m, M, l, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Path_array_+3A_n">N</code></td>
<td>
<p>a number of points of the lfsm.</p>
</td></tr>
<tr><td><code id="Path_array_+3A_m">m</code></td>
<td>
<p>discretization. A number of points between two nearby motion points</p>
</td></tr>
<tr><td><code id="Path_array_+3A_m">M</code></td>
<td>
<p>truncation parameter. A number of points at which the integral representing the definition of lfsm is calculated. So, after M points back we consider the rest of the integral to be 0.</p>
</td></tr>
<tr><td><code id="Path_array_+3A_l">l</code></td>
<td>
<p>a list of parameters to expand</p>
</td></tr>
<tr><td><code id="Path_array_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of lfsm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a data frame containing paths and the corresponding values of alpha, H and frequency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l=list(H=c(0.2,0.8),alpha=c(1,1.8), freq="H")
arr&lt;-Path_array(N=300,m=30,M=100,l=l,sigma=0.3)
str(arr)
head(arr)
</code></pre>

<hr>
<h2 id='paths'>Generator of a set of lfsm paths.</h2><span id='topic+paths'></span>

<h3>Description</h3>

<p>It is essentially a wrapper for <code><a href="#topic+path">path</a></code> generator, which exploits the latest to create a matrix with paths in its columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths(N_var, parallel, seed_list = rep(x = NULL, times = N_var), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paths_+3A_n_var">N_var</code></td>
<td>
<p>number of lfsm paths to generate</p>
</td></tr>
<tr><td><code id="paths_+3A_parallel">parallel</code></td>
<td>
<p>a TRUE/FALSE flag which determines if the paths will be created in parallel or sequentially</p>
</td></tr>
<tr><td><code id="paths_+3A_seed_list">seed_list</code></td>
<td>
<p>a numerical vector of seeds to pass to <code><a href="#topic+path">path</a></code></p>
</td></tr>
<tr><td><code id="paths_+3A_...">...</code></td>
<td>
<p>arguments to pass to path</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+path">path</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
freq='L'
r=1; k=2; p=0.4

Y&lt;-paths(N_var=10,parallel=TRUE,N=N,m=m,M=M,
         alpha=alpha,H=H,sigma=sigma,freq='L',
         disable_X=FALSE,levy_increments=NULL)

Hs&lt;-apply(Y,MARGIN=2,H_hat,p=p,k=k)
hist(Hs)

</code></pre>

<hr>
<h2 id='phi'>Phi</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>Defined as
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{\textnormal{high}}(t; H,k)_n := V_{\textnormal{high}}(\psi_t; k)_n \qquad \textnormal{and}
\qquad \varphi_{\textnormal{low}}(t; k)_n := V_{\textnormal{low}}(\psi_t; k)_n</code>
</p>
<p>,
where <code class="reqn">\psi_t(x):=cos(tx)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(t, k, path, H, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_+3A_t">t</code></td>
<td>
<p>positive real number</p>
</td></tr>
<tr><td><code id="phi_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="phi_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
<tr><td><code id="phi_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="phi_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hurst parameter is required only in high frequency case. In the low frequency, there is no need to assign H a value because it will not be evaluated.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>

<hr>
<h2 id='phi_of_alpha'>Inverse alpha estimator</h2><span id='topic+phi_of_alpha'></span>

<h3>Description</h3>

<p>A function from a general estimation procedure which is defined as m^p_-p'_k /m^p'_-p_k, originally proposed in [13].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi_of_alpha(p, p_prime, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_of_alpha_+3A_p">p</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="phi_of_alpha_+3A_p_prime">p_prime</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="phi_of_alpha_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>

<hr>
<h2 id='Plot_dens'>(alpha,H,sigma)- density plot</h2><span id='topic+Plot_dens'></span>

<h3>Description</h3>

<p>Plots the densities of the parameters (alpha,H,sigma) estimated in Monte-Carlo experiment.
Works in conjunction with <code><a href="#topic+MCestimLFSM">MCestimLFSM</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot_dens(par_vec = c("alpha", "H", "sigma"), MC_data, Nnorm = 1e+07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot_dens_+3A_par_vec">par_vec</code></td>
<td>
<p>vector of parameters which are to be plotted</p>
</td></tr>
<tr><td><code id="Plot_dens_+3A_mc_data">MC_data</code></td>
<td>
<p>a list created by <code><a href="#topic+MCestimLFSM">MCestimLFSM</a></code></p>
</td></tr>
<tr><td><code id="Plot_dens_+3A_nnorm">Nnorm</code></td>
<td>
<p>number of point sampled from standard normal distribution</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Plot_vb">Plot_vb</a></code>  to plot variance- and bias dependencies on n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m&lt;-45; M&lt;-60

p&lt;-.4; p_prime&lt;-.2
t1&lt;-1; t2&lt;-2; k&lt;-2

NmonteC&lt;-5e2
S&lt;-c(1e3,1e4)
alpha&lt;-.8; H&lt;-0.8; sigma&lt;-0.3
theor_4_1_clt_new&lt;-MCestimLFSM(s=S,fr='L',Nmc=NmonteC,
                       m=m,M=M,
                       alpha=alpha,H=H,sigma=sigma,
                       GenLowEstim,t1=t1,t2=t2,p=p)
l_plot&lt;-Plot_dens(par_vec=c('sigma','alpha','H'), MC_data=theor_4_1_clt_new, Nnorm=1e7)
l_plot


</code></pre>

<hr>
<h2 id='Plot_list_paths'>Rendering of path lattice</h2><span id='topic+Plot_list_paths'></span>

<h3>Description</h3>

<p>Rendering of path lattice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot_list_paths(arr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot_list_paths_+3A_arr">arr</code></td>
<td>
<p>a data frame produced by <code><a href="#topic+Path_array">Path_array</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>l=list(H=c(0.2,0.8),alpha=c(1,1.8), freq="H")
arr&lt;-Path_array(N=300,m=30,M=100,l=l,sigma=0.3)
p&lt;-Plot_list_paths(arr)
p
</code></pre>

<hr>
<h2 id='Plot_vb'>A function to plot variance- and bias dependencies of estimators on the lengths of sample paths. Works in conjunction with <code><a href="#topic+MCestimLFSM">MCestimLFSM</a></code> function.</h2><span id='topic+Plot_vb'></span>

<h3>Description</h3>

<p>A function to plot variance- and bias dependencies of estimators on the lengths of sample paths. Works in conjunction with <code><a href="#topic+MCestimLFSM">MCestimLFSM</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot_vb(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot_vb_+3A_data">data</code></td>
<td>
<p>a list created by <code><a href="#topic+MCestimLFSM">MCestimLFSM</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a ggplot2 graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Plot_dens">Plot_dens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Light weight computaions

m&lt;-25; M&lt;-50
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
S&lt;-c(1:3)*1e2
p&lt;-.4; p_prime&lt;-.2; t1&lt;-1; t2&lt;-2
k&lt;-2; NmonteC&lt;-50

# Here is the continuous H-1/alpha inference procedure
theor_3_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,ContinEstim,
                     t1=t1,t2=t2,p=p,k=k)
Plot_vb(theor_3_1_H_clt)


# More demanding example (it is better to use multicore setup)
# General low frequency inference

m&lt;-45; M&lt;-60
alpha&lt;-0.8; H&lt;-0.8; sigma&lt;-0.3
S&lt;-c(1:15)*1e2
p&lt;-.4; t1&lt;-1; t2&lt;-2
NmonteC&lt;-50

# Here is the continuous H-1/alpha inference procedure
theor_4_1_H_clt&lt;-MCestimLFSM(s=S,fr='H',Nmc=NmonteC,
                     m=m,M=M,alpha=alpha,H=H,
                     sigma=sigma,GenLowEstim,
                     t1=t1,t2=t2,p=p)
Plot_vb(theor_4_1_H_clt)


</code></pre>

<hr>
<h2 id='R_hl'>R high /low</h2><span id='topic+R_hl'></span>

<h3>Description</h3>

<p>Defined as
</p>
<p style="text-align: center;"><code class="reqn">R_{\textnormal{high}} (p,k)_n := \frac{\sum_{i=2k}^n \left| \Delta_{i,k}^{n,2} X \right|^p}
{\sum_{i=k}^n \left| \Delta_{i,k}^{n,1} X \right|^p}, \qquad</code>
</p>

<p style="text-align: center;"><code class="reqn">R_{\textnormal{low}} (p,k)_n := \frac{\sum_{i=2k}^n \left| \Delta_{i,k}^{2} X \right|^p}
{\sum_{i=k}^n \left| \Delta_{i,k}^{1} X \right|^p}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>R_hl(p, k, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_hl_+3A_p">p</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="R_hl_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="R_hl_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation procedure for high- and low frequency cases is the same, since there is no way to control frequency given a sample path.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
alpha&lt;-0.8; H&lt;-0.8; sigma&lt;-0.3
p&lt;-0.3; k=3

lfsm&lt;-path(N=N,m=m,M=M,alpha=alpha,H=H,
           sigma=sigma,freq='L',disable_X=FALSE,seed=3)$lfsm
R_hl(p=p,k=k,path=lfsm)
</code></pre>

<hr>
<h2 id='Retrieve_stats'>Retrieve statistics(bias, variance) of estimators based on a set of paths</h2><span id='topic+Retrieve_stats'></span>

<h3>Description</h3>

<p>Retrieve statistics(bias, variance) of estimators based on a set of paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Retrieve_stats(paths, true_val, Est, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Retrieve_stats_+3A_paths">paths</code></td>
<td>
<p>real-valued matrix representing sample paths of the stochastic process being studied</p>
</td></tr>
<tr><td><code id="Retrieve_stats_+3A_true_val">true_val</code></td>
<td>
<p>true value of the estimated parameter</p>
</td></tr>
<tr><td><code id="Retrieve_stats_+3A_est">Est</code></td>
<td>
<p>estimator (i.e. H_hat)</p>
</td></tr>
<tr><td><code id="Retrieve_stats_+3A_...">...</code></td>
<td>
<p>parameters to pass to Est</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
freq='L';t1=1; t2=2
r=1; k=2; p=0.4

Y&lt;-paths(N_var=10,parallel=TRUE,N=N,m=m,M=M,
         alpha=alpha,H=H,sigma=sigma,freq='L',
         disable_X=FALSE,levy_increments=NULL)

Retrieve_stats(paths=Y,true_val=sigma,Est=sigma_hat,t1=t1,k=2,alpha=alpha,H=H,freq="L")
</code></pre>

<hr>
<h2 id='sf'>Statistic V</h2><span id='topic+sf'></span>

<h3>Description</h3>

<p>Statistic of the form
</p>
<p style="text-align: center;"><code class="reqn">V_{\textnormal{high}}(f; k,r)_n:=\frac{1}{n}\sum_{i=rk}^n f\left( n^H \Delta_{i,k}^{n,r} X \right),  </code>
</p>

<p style="text-align: center;"><code class="reqn">V_{\textnormal{low}}(f; k,r)_n :=\frac{1}{n}\sum_{i=rk}^n f\left( \Delta_{i,k}^{r} X \right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sf(path, f, k, r, H, freq, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_+3A_path">path</code></td>
<td>
<p>sample path for which the statistic is to be calculated.</p>
</td></tr>
<tr><td><code id="sf_+3A_f">f</code></td>
<td>
<p>function applied to high order increments.</p>
</td></tr>
<tr><td><code id="sf_+3A_k">k</code></td>
<td>
<p>order of the increments.</p>
</td></tr>
<tr><td><code id="sf_+3A_r">r</code></td>
<td>
<p>step of high order increments.</p>
</td></tr>
<tr><td><code id="sf_+3A_h">H</code></td>
<td>
<p>Hurst parameter.</p>
</td></tr>
<tr><td><code id="sf_+3A_freq">freq</code></td>
<td>
<p>frequency.</p>
</td></tr>
<tr><td><code id="sf_+3A_...">...</code></td>
<td>
<p>parameters to pass to function f</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hurst parameter is required only in high frequency case. In the low frequency, there is no need to assign H a value because it will not be evaluated.
</p>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phi">phi</a></code> computes V statistic with f(.)=cos(t.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^10-M
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
freq='L'
r=1; k=2; p=0.4
S&lt;-(1:20)*100

path_lfsm&lt;-function(...){

    List&lt;-path(...)
    List$lfsm

}

Pths&lt;-lapply(X=S,FUN=path_lfsm,
             m=m, M=M, alpha=alpha, sigma=sigma, H=H,
             freq=freq, disable_X = FALSE,
             levy_increments = NULL, seed = NULL)

f_phi&lt;-function(t,x) cos(t*x)
f_pow&lt;-function(x,p) (abs(x))^p

V_cos&lt;-sapply(Pths,FUN=sf,f=f_phi,k=k,r=r,H=H,freq=freq,t=1)
ex&lt;-exp(-(abs(sigma*Norm_alpha(h_kr,alpha=alpha,k=k,r=r,H=H,l=0)$result)^alpha))

 # Illustration of the law of large numbers for phi:
plot(y=V_cos, x=S, ylim = c(0,max(V_cos)+0.1))
abline(h=ex, col='brown')

# Illustration of the law of large numbers for power functions:
Mpk&lt;-m_pk(k=k, p=p, alpha=alpha, H=H, sigma=sigma)

sf_mod&lt;-function(Xpath,...) {

    Path&lt;-unlist(Xpath)
    sf(path=Path,...)
}

V_pow&lt;-sapply(Pths,FUN=sf_mod,f=f_pow,k=k,r=r,H=H,freq=freq,p=p)
plot(y=V_pow, x=S, ylim = c(0,max(V_pow)+0.1))
abline(h=Mpk, col='brown')


</code></pre>

<hr>
<h2 id='sigma_hat'>Statistical estimator for sigma</h2><span id='topic+sigma_hat'></span>

<h3>Description</h3>

<p>Statistical estimator for sigma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_hat(t1, k, path, alpha, H, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma_hat_+3A_t1">t1</code></td>
<td>
<p>real number such that t1 &gt; 0</p>
</td></tr>
<tr><td><code id="sigma_hat_+3A_k">k</code></td>
<td>
<p>increment order</p>
</td></tr>
<tr><td><code id="sigma_hat_+3A_path">path</code></td>
<td>
<p>sample path of lfsm on which the inference is to be performed</p>
</td></tr>
<tr><td><code id="sigma_hat_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="sigma_hat_+3A_h">H</code></td>
<td>
<p>Hurst parameter</p>
</td></tr>
<tr><td><code id="sigma_hat_+3A_freq">freq</code></td>
<td>
<p>Frequency of the motion. It can take two values: &quot;H&quot; for high frequency and &quot;L&quot; for the low frequency setting.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m&lt;-45; M&lt;-60; N&lt;-2^14-M
alpha&lt;-1.8; H&lt;-0.8; sigma&lt;-0.3
freq='H'
r=1; k=2; p=0.4; t1=1; t2=2

# Reproducing the work of ContinEstim
# in high frequency case
lfsm&lt;-path(N=N,m=m,M=M,alpha=alpha,H=H,
           sigma=sigma,freq='L',disable_X=FALSE,seed=1)$lfsm

H_est&lt;-H_hat(p=p,k=k,path=lfsm)
H_est
alpha_est&lt;-alpha_hat(t1=t1,t2=t2,k=k,path=lfsm,H=H_est,freq=freq)
alpha_est

sigma_est&lt;-tryCatch(
                    sigma_hat(t1=t1,k=k,path=lfsm,
                    alpha=alpha_est,H=H_est,freq=freq),
                    error=function(c) 'Impossible to compute sigma_est')
sigma_est
</code></pre>

<hr>
<h2 id='theta'>Function theta</h2><span id='topic+theta'></span>

<h3>Description</h3>

<p>Function of the form
</p>
<p style="text-align: center;"><code class="reqn">\theta(g,h)_{p} = a_p^{-2} \int_{\R^2}  |xy|^{-1-p}U_{g,h}(x,y) dxdy</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>theta(p, alpha, sigma, g, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta_+3A_p">p</code></td>
<td>
<p>power, real number from (-1,1)</p>
</td></tr>
<tr><td><code id="theta_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="theta_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of lfsm</p>
</td></tr>
<tr><td><code id="theta_+3A_g">g</code>, <code id="theta_+3A_h">h</code></td>
<td>
<p>functions <code class="reqn">g,h: \R \to \R</code> with finite alpha-norm (see <code><a href="#topic+Norm_alpha">Norm_alpha</a></code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mazur S, Otryakhin D, Podolskij M (2020).
&ldquo;Estimation of the linear fractional stable motion.&rdquo;
<em>Bernoulli</em>, <b>26</b>(1), 226&ndash;252.
<a href="https://doi.org/10.3150/19-BEJ1124">https://doi.org/10.3150/19-BEJ1124</a>.
</p>

<hr>
<h2 id='U_g'>alpha norm of u*g</h2><span id='topic+U_g'></span>

<h3>Description</h3>

<p>alpha norm of u*g
</p>


<h3>Usage</h3>

<pre><code class='language-R'>U_g(g, u, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="U_g_+3A_g">g</code></td>
<td>
<p>function <code class="reqn">g: \R to \R</code> with finite alpha-norm (see <code><a href="#topic+Norm_alpha">Norm_alpha</a></code>).</p>
</td></tr>
<tr><td><code id="U_g_+3A_u">u</code></td>
<td>
<p>real number</p>
</td></tr>
<tr><td><code id="U_g_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to Norm_alpha</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-function(x) exp(-x^2)
g&lt;-function(x) exp(-abs(x))
U_g(g=g,u=4,alpha=1.7)
</code></pre>

<hr>
<h2 id='U_gh'>alpha-norm of u*g + v*h.</h2><span id='topic+U_gh'></span>

<h3>Description</h3>

<p>alpha-norm of u*g + v*h.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>U_gh(g, h, u, v, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="U_gh_+3A_g">g</code>, <code id="U_gh_+3A_h">h</code></td>
<td>
<p>functions <code class="reqn">g,h: \R \to \R</code> with finite alpha-norm (see <code><a href="#topic+Norm_alpha">Norm_alpha</a></code>).</p>
</td></tr>
<tr><td><code id="U_gh_+3A_v">v</code>, <code id="U_gh_+3A_u">u</code></td>
<td>
<p>real numbers</p>
</td></tr>
<tr><td><code id="U_gh_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to Norm_alpha</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-function(x) exp(-x^2)
h&lt;-function(x) exp(-abs(x))
U_gh(g=g, h=h, u=4, v=3, alpha=1.7)
</code></pre>

<hr>
<h2 id='U_ghuv'>A dependence structure of 2 random variables.</h2><span id='topic+U_ghuv'></span>

<h3>Description</h3>

<p>It is used when random variables do not have finite second moments, and thus, the covariance matrix is not defined.
For <code class="reqn">X= \int_{\R} g_s dL_s</code> and <code class="reqn">Y= \int_{\R} h_s dL_s</code> with <code class="reqn">\| g \|_{\alpha}, \| h\|_{\alpha}&lt; \infty</code>. Then the measure of dependence is given by <code class="reqn">U_{g,h}: \R^2 \to \R</code> via
</p>
<p style="text-align: center;"><code class="reqn">U_{g,h} (u,v)=\exp(- \sigma^{\alpha}{\| ug +vh \|_{\alpha}}^{\alpha} ) - \exp(- \sigma^{\alpha} ({\| ug \|_{\alpha}}^{\alpha} + {\| vh \|_{\alpha}}^{\alpha}))</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>U_ghuv(alpha, sigma, g, h, u, v, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="U_ghuv_+3A_alpha">alpha</code></td>
<td>
<p>self-similarity parameter of alpha stable random motion.</p>
</td></tr>
<tr><td><code id="U_ghuv_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of lfsm</p>
</td></tr>
<tr><td><code id="U_ghuv_+3A_g">g</code>, <code id="U_ghuv_+3A_h">h</code></td>
<td>
<p>functions <code class="reqn">g,h: \R \to \R</code> with finite alpha-norm (see <code><a href="#topic+Norm_alpha">Norm_alpha</a></code>).</p>
</td></tr>
<tr><td><code id="U_ghuv_+3A_v">v</code>, <code id="U_ghuv_+3A_u">u</code></td>
<td>
<p>real numbers</p>
</td></tr>
<tr><td><code id="U_ghuv_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to U_gh and U_g</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-function(x) exp(-x^2)
h&lt;-function(x) exp(-abs(x))
U_ghuv(alpha=1.5, sigma=1, g=g, h=h, u=10, v=15,
rel.tol = .Machine$double.eps^0.25, abs.tol=1e-11)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
