<!DOCTYPE html><html><head><title>Help for package RmarineHeatWaves</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RmarineHeatWaves}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RmarineHeatWaves'><p>RmarineHeatWaves.</p></a></li>
<li><a href='#block_average'><p>Calculate Yearly Means for Event Metrics.</p></a></li>
<li><a href='#detect'><p>Detect heatwaves and cold-spells.</p></a></li>
<li><a href='#event_line'><p>Create a Line Plot of Marine Heat Waves or Cold Spells.</p></a></li>
<li><a href='#exceedance'><p>Detect consecutive days in exceedance of a given threshold.</p></a></li>
<li><a href='#geom_flame'><p>Create 'Flame' Ploygons.</p></a></li>
<li><a href='#geom_lolli'><p>Visualise a Timeline of Several Event Metrics as 'Lollipops'.</p></a></li>
<li><a href='#lolli_plot'><p>Create a Timeline of Selected Event Metrics.</p></a></li>
<li><a href='#make_whole'><p>Constructs a Continuous, Uninterrupted Time Series of Temperatures.</p></a></li>
<li><a href='#sst_Med'><p>Optimally Interpolated 0.25 degree SST for the Mediterranean region.</p></a></li>
<li><a href='#sst_NW_Atl'><p>Optimally Interpolated 0.25 degree SST for the NW Atlantic region.</p></a></li>
<li><a href='#sst_WA'><p>Optimally Interpolated 0.25 degree SST for the Western Australian region.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.17.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-06-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Detect Marine Heat Waves and Marine Cold Spells</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Albertus J. Smit &lt;albertus.smit@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble, ggplot2, lubridate, dplyr, stats, utils, zoo, tidyr,
plyr, raster, grid, lazyeval, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Given a time series of daily temperatures, the package provides tools
    to detect extreme thermal events, including marine heat waves, and to
    calculate the exceedances above or below specified threshold values.
    It outputs the properties of all detected events and exceedances.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ajsmit/RmarineHeatWaves">https://github.com/ajsmit/RmarineHeatWaves</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-04 16:40:29 UTC; ajsmit</td>
</tr>
<tr>
<td>Author:</td>
<td>Albertus J. Smit [aut, cre] (R implementation.),
  Eric C. J. Oliver [aut] (The brain behind the Python implementation.),
  Robert W. Schlegel [ctb] (Graphical and data summaries.)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-04 17:43:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='RmarineHeatWaves'>RmarineHeatWaves.</h2><span id='topic+RmarineHeatWaves'></span><span id='topic+RmarineHeatWaves-package'></span>

<h3>Description</h3>

<p>This package is an R implementation of the python script <code>marineHeatWaves</code>
(<a href="https://github.com/ecjoliver/marineHeatWaves">https://github.com/ecjoliver/marineHeatWaves</a>) written by Eric C. J.
Oliver as part of the marine heat waves definition by Hobday et al. (2016).
</p>


<h3>Details</h3>

<p>Although the title of the package refers to marine heat waves (MHW),
it is equally capable of detecting marine cold spells (MCS). This
functionality to detect cold events is also present in the python package,
where it was implemented as a result of the publication Schlegel et al. (2017)
that discusses the quantification and detection of anomalously cold events.
As of release 0.16.0, the detect function may also be applied to time series
of other natural phenomena which one might want to express in terms of the
summary metrics outlined in the paper by Hobday et al. (2016).
</p>
<p>The main function is the detection function <code><a href="#topic+detect">detect</a></code> which takes as
input a time series of temperature (and a corresponding series of dates)
and outputs a set of detected MHWs or MCS, as well as the climatological
(varying by day-of-year) seasonal cycle and extremes threshold. There are
various helper functions to fascilitate developing an uninterrupted time
series of temperatures (e.g. <code><a href="#topic+make_whole">make_whole</a></code>) and some options to produce
graphical summaries and representations of the detected events such as
<code><a href="#topic+event_line">event_line</a></code> and <code><a href="#topic+lolli_plot">lolli_plot</a></code>, or the ggplot2
equivalents, <code><a href="#topic+geom_flame">geom_flame</a></code> and <code><a href="#topic+geom_lolli">geom_lolli</a></code>.
</p>
<p>This package is demonstrated by applying the MHW definition to observed SST
records and showing how it identifies three historical MHWs: the 2011
Western Australia event, the 2012 Northwest Atlantic event and the 2003
Mediterranean event. These data are included herewith.
</p>
<p>One may also use the <code><a href="#topic+exceedance">exceedance</a></code> function to calculate consecutive
days above or below a given static threshold. The output of this function is
similar to <code><a href="#topic+detect">detect</a></code>.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit &lt;<a href="mailto:albertus.smit@gmail.com">albertus.smit@gmail.com</a>&gt;, Robert W. Schlegel,
Eric C. J. Oliver
</p>


<h3>References</h3>

<p>Hobday, A. J. et al. (2016), A hierarchical approach to defining
marine heatwaves. Progress in Oceanography, 141, pp. 227-238,
&lt;DOI:10.1016/j.pocean.2015.12.014&gt; (official citation for this package).
</p>
<p>Schlegel, R. W., Oliver, E. C. J., Wernberg, T. W., Smit, A. J. (2017)
Coastal and offshore co-occurrences of marine heatwaves and cold-spells.
Progress in Oceanography, 151, pp. 189-205, &lt;DOI:10.1016/j.pocean.2017.01.004&gt;
</p>

<hr>
<h2 id='block_average'>Calculate Yearly Means for Event Metrics.</h2><span id='topic+block_average'></span>

<h3>Description</h3>

<p>Calculate Yearly Means for Event Metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_average(data, x = t, y = temp, report = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_average_+3A_data">data</code></td>
<td>
<p>Accepts the data returned by the <code><a href="#topic+detect">detect</a></code> function.</p>
</td></tr>
<tr><td><code id="block_average_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>make_whole</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be ommitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="block_average_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="block_average_+3A_report">report</code></td>
<td>
<p>Specify either <code>full</code> or <code>partial</code>. Selecting <code>full</code> causes
the report to contain NAs for any years in which no events were detected
(except for <code>count</code>, which will be zero in those years), while <code>partial</code>
reports only the years wherein events were detected. The default is <code>full</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function needs to be provided with the full output from the <code>detect</code>
function. Note that the yearly averages are calculted only for complete years
(i.e. years that start/end part-way through the year at the beginning or end
of the original time series are removed from the calculations).
</p>
<p>This function differs from the python implementation of the function of the
same name (i.e., <code>blockAverage</code>, see <a href="https://github.com/ecjoliver/marineHeatWaves">https://github.com/ecjoliver/marineHeatWaves</a>)
in that we only provide the ability to calculate the average (or aggregate)
event metrics in 'blocks' of one year, while the python version allows
arbitrary (integer) block sizes.
</p>


<h3>Value</h3>

<p>The function will return a data frame of the averaged (or aggregate)
metrics. It includes the following:
</p>
<table>
<tr><td><code>year</code></td>
<td>
<p>The year over which the metrics were averaged.</p>
</td></tr>
<tr><td><code>temp_mean</code></td>
<td>
<p>Seawater temperature for the specified year [deg. C].</p>
</td></tr>
<tr><td><code>temp_min</code></td>
<td>
<p>The minimum temperature for the specified year [deg. C].</p>
</td></tr>
<tr><td><code>temp_max</code></td>
<td>
<p>The maximum temperature for the specified year [deg. C].</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>The number of events per year.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>The average duration of events per year [days].</p>
</td></tr>
<tr><td><code>int_mean</code></td>
<td>
<p>The average event &quot;mean intensity&quot; in each year [deg. C].</p>
</td></tr>
<tr><td><code>int_max</code></td>
<td>
<p>The average event &quot;maximum (peak) intensity&quot; in each year
[deg. C].</p>
</td></tr>
<tr><td><code>int_var</code></td>
<td>
<p>The average event &quot;intensity variability&quot; in each year
[deg. C].</p>
</td></tr>
<tr><td><code>int_cum</code></td>
<td>
<p>The average event &quot;cumulative intensity&quot; in each year
[deg. C x days].</p>
</td></tr>
<tr><td><code>rate_onset</code></td>
<td>
<p>Average event onset rate in each year [deg. C / days].</p>
</td></tr>
<tr><td><code>rate_decline</code></td>
<td>
<p>Average event decline rate in each year [deg. C / days].</p>
</td></tr>
<tr><td><code>total_days</code></td>
<td>
<p>Total number of events days in each year [days].</p>
</td></tr>
<tr><td><code>total_icum</code></td>
<td>
<p>Total cumulative intensity over all events in each year [deg. C x days].</p>
</td></tr>
</table>
<p><code>int_max_rel_thresh</code>, <code>int_mean_rel_thresh</code>,
<code>int_var_rel_thresh</code>, and <code>int_cum_rel_thresh</code>
are as above except relative to the threshold (e.g., 90th percentile) rather
than the seasonal climatology.
</p>
<p><code>int_max_abs</code>, <code>int_mean_abs</code>, <code>int_var_abs</code>, and
<code>int_cum_abs</code> are as above except as absolute magnitudes
rather than relative to the seasonal climatology or threshold.
</p>
<p><code>int_max_norm</code> and <code>int_mean_norm</code> are as above except
units are in multiples of threshold exceedances, i.e., a value of 1.5
indicates the event intensity (relative to the climatology) was 1.5 times the
value of the threshold (relative to climatology,
i.e., threshold - climatology.)
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit, Eric C. J. Oliver
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016), A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi: 10.1016/j.pocean.2015.12.014
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ts_dat &lt;- make_whole(sst_Med)
# res &lt;- detect(ts_dat, climatology_start = "1983-01-01",
#               climatology_end = "2012-12-31")
# out &lt;- block_average(res)
# summary(glm(count ~ year, out, family = "poisson"))

## Not run: 
plot(out$year, out$count, col = "salmon", pch = 16,
     xlab = "Year", ylab = "Number of events")
lines(out$year, out$count)

## End(Not run)
</code></pre>

<hr>
<h2 id='detect'>Detect heatwaves and cold-spells.</h2><span id='topic+detect'></span>

<h3>Description</h3>

<p>Applies the Hobday et al. (2016) marine heat wave definition to an input time
series of temperature along with a daily date vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect(data, doy = doy, x = t, y = temp, climatology_start,
  climatology_end, pctile = 90, window_half_width = 5,
  smooth_percentile = TRUE, smooth_percentile_width = 31,
  clim_only = FALSE, min_duration = 5, join_across_gaps = TRUE,
  max_gap = 2, max_pad_length = 3, cold_spells = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_+3A_data">data</code></td>
<td>
<p>A data frame with three columns. In the default setting (i.e. ommitting
the arguments <code>doy</code>, <code>x</code> and <code>y</code>; see immediately below), the
data set is expected to have the headers <code>doy</code>, <code>t</code> and <code>temp</code>.
<code>doy</code> is the Julian day running from 1 to 366, but modified so that the
day-of-year (doy) vector for non-leap-years runs 1...59 and then 61...366.
For leap years the 60th day is February 29. The <code>t</code> column is a vector
of dates of class <code>Date</code>, while <code>temp</code> is the measured variable (by
default it is assumed to be temperature). Data of the appropriate format are
created by the function <code><a href="#topic+make_whole">make_whole</a></code>, but your own data can be supplied
if they meet the criteria specified by <code><a href="#topic+make_whole">make_whole</a></code>.</p>
</td></tr>
<tr><td><code id="detect_+3A_doy">doy</code></td>
<td>
<p>If a column headed <code>doy</code> is not available, another column with
Julian dates can be supplied. This argument accepts the name of that column. The
default name is, of course, <code>doy</code>.</p>
</td></tr>
<tr><td><code id="detect_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>make_whole</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be ommitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="detect_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="detect_+3A_climatology_start">climatology_start</code></td>
<td>
<p>Required. The start date for the period across which
the (varying by day-of-year) seasonal cycle and extremes threshold are
calculated.</p>
</td></tr>
<tr><td><code id="detect_+3A_climatology_end">climatology_end</code></td>
<td>
<p>Required. The end date for the period across which
the (varying by day-of-year) seasonal cycle and extremes threshold are
calculated.</p>
</td></tr>
<tr><td><code id="detect_+3A_pctile">pctile</code></td>
<td>
<p>Threshold percentile (%) for detection of extreme values.
Default is <code>90</code>th percentile. Please see <code>cold_spells</code> for more
information about the calculation of marine cold spells.</p>
</td></tr>
<tr><td><code id="detect_+3A_window_half_width">window_half_width</code></td>
<td>
<p>Width of sliding window about day-of-year (to one
side of the center day-of-year) used for the pooling of values and
calculation of climatology and threshold percentile. Default is <code>5</code>
days, which gives a window width of 11 days centered on the 6th day of the
series of 11 days.</p>
</td></tr>
<tr><td><code id="detect_+3A_smooth_percentile">smooth_percentile</code></td>
<td>
<p>Boolean switch selecting whether to smooth the
climatology and threshold percentile timeseries with a moving average of
width <code>smooth_percentile</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="detect_+3A_smooth_percentile_width">smooth_percentile_width</code></td>
<td>
<p>Full width of moving average window for smoothing
climatology and threshold. Default is <code>31</code> days.</p>
</td></tr>
<tr><td><code id="detect_+3A_clim_only">clim_only</code></td>
<td>
<p>Choose to calculate only the climatologies and not the
events. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="detect_+3A_min_duration">min_duration</code></td>
<td>
<p>Minimum duration for acceptance of detected MHWs.
Default is <code>5</code> days.</p>
</td></tr>
<tr><td><code id="detect_+3A_join_across_gaps">join_across_gaps</code></td>
<td>
<p>Boolean switch indicating whether to join MHWs which
occur before/after a short gap as specified by <code>max_gap</code>. Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="detect_+3A_max_gap">max_gap</code></td>
<td>
<p>Maximum length of gap allowed for the joining of MHWs. Default
is <code>2</code> days.</p>
</td></tr>
<tr><td><code id="detect_+3A_max_pad_length">max_pad_length</code></td>
<td>
<p>Specifies the maximum length of days over which to
interpolate (pad) missing data (specified as <code>NA</code>) in the input
temperature time series; i.e., any consecutive blocks of NAs with length
greater than <code>max_pad_length</code> will be left as <code>NA</code>. Set as an
integer. Default is <code>3</code> days.</p>
</td></tr>
<tr><td><code id="detect_+3A_cold_spells">cold_spells</code></td>
<td>
<p>Boolean specifying if the code should detect cold events
instead of heat events. Default is <code>FALSE</code>. Please note that the
climatological thresholds for cold-spells are calculated the same as for
heatwaves, meaning that <code>pctile</code> should be set the same regardless
if one is calculating heatwaves or cold-spells. For example, if one wants
to calculate heatwaves above the 90th percentile threshold
(the default) one sets <code>pctile = 90</code>. Likewise, if one would like
identify the most intense cold-spells one must also set <code>pctile = 90</code>,
even though cold spells are in fact simply the coldest extreme events in a
time series, which statistically equate to values below the 10th percentile.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> This function assumes that the input time series consists of continuous
daily values with few missing values. Time ranges which start and end
part-way through the calendar year are supported. The accompanying function
<code><a href="#topic+make_whole">make_whole</a></code> aids in the preparation of a time series that is
suitable for use with <code>detect</code>, although this may also be accomplished
'by hand' as long as the criteria are met as discussed in the documentation
to <code><a href="#topic+make_whole">make_whole</a></code>.
</p>
</li>
<li><p> It is recommended that a climatology period of at least 30 years is
specified in order to capture decadal thermal periodicities. It is further
advised that full the start and end dates for the climatology period result
in full years, e.g. &quot;1982-01-01&quot; to &quot;2011-12-31&quot; or &quot;1982-07-01&quot; to
&quot;2012-06-30&quot;; if not, this may result in an unequal weighting of data
belonging with certain months within a time series.
</p>
</li>
<li><p> This function supports leap years. This is done by ignoring Feb 29s
for the initial calculation of the climatology and threshold. The values for
Feb 29 are then linearly interpolated from the values for Feb 28 and Mar 1.
</p>
</li>
<li><p> The calculation of onset and decline rates assumes that the events
started a half-day before the start day and ended a half-day after the
end-day. This is consistent with the duration definition as implemented,
which assumes duration = end day - start day + 1. As of version 0.15.7, an
event that is already present at the beginning of a time series, or an event
that is still present at the end of a time series, will report the rate of
onset or the rate of decline as <code>NA</code>, as it is impossible to know what
the temperature half a day before or after the start or end of the event is.
This may be a departure from the python marineHeatWaves function.
</p>
</li>
<li><p> For the purposes of event detection, any missing temperature values not
interpolated over (through optional <code>max_pad_length</code>) will be set equal
to the seasonal climatology. This means they will trigger the end/start of
any adjacent temperature values which satisfy the event definition criteria.
</p>
</li>
<li><p> If the code is used to detect cold events (<code>coldSpells</code> = TRUE),
then it works just as for heat waves except that events are detected as
deviations below the (100 - pctile)th percentile  (e.g., the 10th instead of
90th) for at least 5 days. Intensities are reported as negative values and
represent the temperature anomaly below climatology.
</p>
</li>
<li><p> If only the climatology for the time series is required, and not the
events themselves, this may be done by setting <code>clim_only</code> = TRUE.
</p>
</li></ol>

<p>The original Python algorithm was written by Eric Oliver, Institute for
Marine and Antarctic Studies, University of Tasmania, Feb 2015, and is
documented by Hobday et al. (2016). The marine cold spell option was
implemented in version 0.13 (21 Nov 2015) of the Python module as a result
of our preparation of Schlegel et al. (submitted), wherein the cold events
receive a brief overview.
</p>


<h3>Value</h3>

<p>The function will return a list of two tibbles (see the <code>tidyverse</code>),
<code>clim</code> and <code>event</code>, which are the climatology and events,
respectively. The climatology contains the full time series of daily temperatures,
as well as the the seasonal climatology, the threshold and various aspects of the
events that were detected. The software was designed for detecting extreme
thermal events, and the units specified below reflect that intended purpose.
However, the various other kinds of extreme events may be detected according
to the 'marine heat wave' specifications, and if that is the case, the appropriate
units need to be determined by the user.
</p>
<table>
<tr><td><code>doy</code></td>
<td>
<p>Julian day (day-of-year). For non-leap years it runs 1...59 and
61...366, while leap years run 1...366. This column will be named differently if
another name was specified to the <code>doy</code> argument.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The date of the temperature measurement. This column will be
named differently if another name was specified to the <code>x</code> argument.</p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p>If the software was used for the purpose for which it was designed,
seawater temperature [deg. C] on the specified date will be returned. This
column will of course be named differently if another kind of measurement was
specified to the <code>y</code> argument.</p>
</td></tr>
<tr><td><code>seas_clim_year</code></td>
<td>
<p>Climatological seasonal cycle [deg. C].</p>
</td></tr>
<tr><td><code>thresh_clim_year</code></td>
<td>
<p>Seasonally varying threshold (e.g., 90th
percentile) [deg. C].</p>
</td></tr>
<tr><td><code>var_clim_year</code></td>
<td>
<p>Seasonally varying variance (standard deviation) [deg. C].</p>
</td></tr>
<tr><td><code>thresh_criterion</code></td>
<td>
<p>Boolean indicating if <code>temp</code> exceeds
<code>thresh_clim_year</code>.</p>
</td></tr>
<tr><td><code>duration_criterion</code></td>
<td>
<p>Boolean indicating whether periods of consecutive
<code>thresh_criterion</code> are &gt;= <code>min_duration</code>.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>Boolean indicating if all criteria that define a MHW or MCS are
met.</p>
</td></tr>
<tr><td><code>event_no</code></td>
<td>
<p>A sequential number indicating the ID and order of
occurence of the MHWs or MCSs.</p>
</td></tr>
</table>
<p>The events are summarised using a range of event metrics:
</p>
<table>
<tr><td><code>index_start</code></td>
<td>
<p>Start index of event.</p>
</td></tr>
<tr><td><code>index_stop</code></td>
<td>
<p>Stop index of event.</p>
</td></tr>
<tr><td><code>event_no</code></td>
<td>
<p>A sequential number indicating the ID and order of
the events.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>Duration of event [days].</p>
</td></tr>
<tr><td><code>date_start</code></td>
<td>
<p>Start date of event [date].</p>
</td></tr>
<tr><td><code>date_stop</code></td>
<td>
<p>Stop date of event [date].</p>
</td></tr>
<tr><td><code>date_peak</code></td>
<td>
<p>Date of event peak [date].</p>
</td></tr>
<tr><td><code>int_mean</code></td>
<td>
<p>Mean intensity [deg. C].</p>
</td></tr>
<tr><td><code>int_max</code></td>
<td>
<p>Maximum (peak) intensity [deg. C].</p>
</td></tr>
<tr><td><code>int_var</code></td>
<td>
<p>Intensity variability (standard deviation) [deg. C].</p>
</td></tr>
<tr><td><code>int_cum</code></td>
<td>
<p>Cumulative intensity [deg. C x days].</p>
</td></tr>
<tr><td><code>rate_onset</code></td>
<td>
<p>Onset rate of event [deg. C / day].</p>
</td></tr>
<tr><td><code>rate_decline</code></td>
<td>
<p>Decline rate of event [deg. C / day].</p>
</td></tr>
</table>
<p><code>int_max_rel_thresh</code>, <code>int_mean_rel_thresh</code>,
<code>int_var_rel_thresh</code>, and <code>int_cum_rel_thresh</code>
are as above except relative to the threshold (e.g., 90th percentile) rather
than the seasonal climatology.
</p>
<p><code>int_max_abs</code>, <code>int_mean_abs</code>, <code>int_var_abs</code>, and
<code>int_cum_abs</code> are as above except as absolute magnitudes
rather than relative to the seasonal climatology or threshold.
</p>
<p><code>int_max_norm</code> and <code>int_mean_norm</code> are as above except
units are in multiples of threshold exceedances, i.e., a value of 1.5
indicates the event intensity (relative to the climatology) was 1.5 times the
value of the threshold (relative to climatology,
i.e., threshold - climatology.)
</p>
<p>Note that <code>rate_onset</code> and <code>rate_decline</code> will return <code>NA</code>
when the event begins/ends on the first/last day of the time series. This
may be particularly evident when the function is applied to large gridded
data sets. Although the other metrics do not contain any errors and
provide sensible values, please take this into account in its
interpretation.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit, Robert W. Schlegel, Eric C. J. Oliver
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016). A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi:10.1016/j.pocean.2015.12.014
</p>
<p>Schlegel, R. W., Oliver, C. J., Wernberg, T. W., Smit, A. J. (2017).
Coastal and offshore co-occurrences of marine heatwaves and cold-spells.
Progress in Oceanography, 151, pp. 189-205, doi:10.1016/j.pocean.2017.01.004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_dat &lt;- make_whole(sst_WA)
res &lt;- detect(ts_dat, climatology_start = "1983-01-01",
              climatology_end = "2012-12-31")
# show a portion of the climatology:
res$clim[1:10, ]
# show some of the heat waves:
res$event[1:5, 1:10]
</code></pre>

<hr>
<h2 id='event_line'>Create a Line Plot of Marine Heat Waves or Cold Spells.</h2><span id='topic+event_line'></span>

<h3>Description</h3>

<p>Creates a graph of warm or cold events as per the second row of Figure 3 in
Hobday et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_line(data, x = t, y = temp, min_duration = 5, spread = 150,
  metric = "int_cum", start_date, end_date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_line_+3A_data">data</code></td>
<td>
<p>The function receives the output from the <code><a href="#topic+detect">detect</a></code> function.</p>
</td></tr>
<tr><td><code id="event_line_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>make_whole</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be ommitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="event_line_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="event_line_+3A_min_duration">min_duration</code></td>
<td>
<p>The minimum duration that an event has to for it to
qualify as a marine heat wave or marine cold spell.</p>
</td></tr>
<tr><td><code id="event_line_+3A_spread">spread</code></td>
<td>
<p>The the number of days leading and trailing the largest event
(as per <code>metric</code>) detected within the time period specified by
<code>start_date</code> and <code>end_date</code>. The default is 150 days.</p>
</td></tr>
<tr><td><code id="event_line_+3A_metric">metric</code></td>
<td>
<p>One of the following options: <code>int_mean</code>, <code>int_max</code>, <code>int_var</code>,
<code>int_cum</code>, <code>int_mean_rel_thresh</code>, <code>int_max_rel_thresh</code>, <code>int_var_rel_thresh</code>,
<code>int_cum_rel_thresh</code>, <code>int_mean_abs</code>, <code>int_max_abs</code>, <code>int_var_abs</code>,
<code>int_cum_abs</code>, <code>int_mean_norm</code>, <code>int_max_norm</code>, <code>rate_onset</code>, <code>rate_decline</code>.
Partial name matching is currently not supported so please specify the metric
name precisely. The default is <code>int_cum</code>.</p>
</td></tr>
<tr><td><code id="event_line_+3A_start_date">start_date</code></td>
<td>
<p>The start date of a period of time within which the largest
event (as per <code>metric</code>) is retrieved and plotted. This may not necessarily
correspond to the biggest event of the specified metric within the entire
data set. To plot the biggest event within the whole time series, make sure
<code>start_date</code> and <code>end_date</code> straddle this event, or simply specify
the start and end dates of the full time series given to <code><a href="#topic+detect">detect</a></code>.</p>
</td></tr>
<tr><td><code id="event_line_+3A_end_date">end_date</code></td>
<td>
<p>The end date of a period of time within which the largest
event (as per <code>metric</code>) is retrieved and plotted. See <code>start_date</code>
for additional information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will return a line plot indicating the climatology,
threshold and temperature, with the hot or cold events that meet the
specifications of Hobday et al. (2016) shaded in as appropriate. The plotting
of hot or cold events depends on which option is specified in <code><a href="#topic+detect">detect</a></code>.
The top event detect during the selected time period will be visible in a
brighter colour. This function differs in use from <code><a href="#topic+geom_flame">geom_flame</a></code>
in that it creates a stand alone figure. The benefit of this being
that one must not have any prior knowledge of ggplot2 to create the figure.
</p>


<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016), A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi: 10.1016/j.pocean.2015.12.014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_dat &lt;- make_whole(sst_WA)
res &lt;- detect(ts_dat, climatology_start = "1983-01-01",
              climatology_end = "2012-12-31")

## Not run: 
event_line(res, spread = 200, metric = "int_cum",
start_date = "2010-10-01", end_date = "2011-08-30")

## End(Not run)
</code></pre>

<hr>
<h2 id='exceedance'>Detect consecutive days in exceedance of a given threshold.</h2><span id='topic+exceedance'></span>

<h3>Description</h3>

<p>Detect consecutive days in exceedance of a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceedance(data, x = t, y = temp, threshold = 20, below = FALSE,
  min_duration = 5, join_across_gaps = TRUE, max_gap = 2,
  max_pad_length = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exceedance_+3A_data">data</code></td>
<td>
<p>A data frame with at least the two following columns:
a <code>t</code> column which is a vector of dates of class <code>Date</code>,
and a <code>temp</code> column, which is the temperature on those given
dates. If columns are named differently, their names can be supplied as <code>x</code>
and <code>y</code> (see below). The function will not accurately detect consecutive
days of temperatures in exceedance of the <code>threshold</code> if missing days of
data are not filled in with <code>NA</code>. Data of the appropriate format are created
by the function <code><a href="#topic+make_whole">make_whole</a></code>, but your own data may be used
directly if they meet the given criteria.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_x">x</code></td>
<td>
<p>This column is expected to contain a vector of dates as per the
specification of <code>make_whole</code>. If a column headed <code>t</code> is present in
the dataframe, this argument may be ommitted; otherwise, specify the name of
the column with dates here.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_y">y</code></td>
<td>
<p>This is a column containing the measurement variable. If the column
name differs from the default (i.e. <code>temp</code>), specify the name here.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_threshold">threshold</code></td>
<td>
<p>The static threshold used to determine how many consecutive
days are in exceedance of the temperature of interest. Default is
<code>20</code> degrees.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_below">below</code></td>
<td>
<p>Default is <code>FALSE</code>. When set to TRUE, consecutive days of temperature
below the <code>threshold</code> variable are calculated. When set to FALSE,
consecutive days above the <code>threshold</code> variable are calculated.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_min_duration">min_duration</code></td>
<td>
<p>Minimum duration that temperatures must be in exceedance
of the <code>threshold</code> variable. Default is <code>5</code> days.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_join_across_gaps">join_across_gaps</code></td>
<td>
<p>A TRUE/FALSE statement that indicates whether
or not to join consecutive days of temperatures in exceedance of the
<code>threshold</code> across a small gap between groups before/after a short
gap as specified by <code>max_gap</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_max_gap">max_gap</code></td>
<td>
<p>The maximum length of the gap across which to connect
consecutive days in exceedance of the <code>threshold</code> when
<code>join_across_gaps</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="exceedance_+3A_max_pad_length">max_pad_length</code></td>
<td>
<p>Specifies the maximum length of days over which to
interpolate (pad) missing data (specified as <code>NA</code>) in the input
temperature time series; i.e., any consecutive blocks of NAs with length
greater than <code>max_pad_length</code> will be left as <code>NA</code>. Set as an
integer. Default is <code>3</code> days.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> This function assumes that the input time series consists of continuous
daily temperatures, with few missing values. The accompanying function
<code><a href="#topic+make_whole">make_whole</a></code> aids in the preparation of a time series that is
suitable for use with <code>exceedance</code>, although this may also be accomplished
'by hand' as long as the criteria are met as discussed in the documentation
to <code><a href="#topic+make_whole">make_whole</a></code>.
</p>
</li>
<li><p> Future versions seek to accomodate monthly and annual time series, too.
</p>
</li>
<li><p> The calculation of onset and decline rates assumes that exceedance of the
<code>threshold</code> started a half-day before the start day and ended a half-day
after the end-day. This is consistent with the duration definition as implemented,
which assumes duration = end day - start day + 1.
</p>
</li>
<li><p> For the purposes of exceedance detection, any missing temperature values not
interpolated over (through optional <code>max_pad_length</code>) will remain as
<code>NA</code>. This means they will trigger the end of an exceedance if the adjacent
temperature values are in exceedance of the <code>threshold</code>.
</p>
</li>
<li><p> If the function is used to detect consecutive days of temperature under
the given <code>theshold</code>, these temperatures are then taken as being in
exceedance below the <code>threshold</code> as there is no antonym in the English
language for 'exceedance'.
</p>
</li></ol>

<p>This function is based largely on the <code>detect</code> function found in this
package, which was ported from the Python algorithm that was written by Eric
Oliver, Institute for Marine and Antarctic Studies, University of Tasmania,
Feb 2015, and is documented by Hobday et al. (2016).
</p>


<h3>Value</h3>

<p>The function will return a list of two components. The first being
<code>threshold</code>, which shows the daily temperatures and on which specific days
the given <code>threshold</code> was exceeded. The second component of the list is
<code>exceedance</code>, which shows a medley of statistics for each discrete group
of days in exceedance of the given <code>threshold</code>. Note that any additional
columns left in the data frame given to this function will be output in the
<code>threshold</code> component of the output. For example, if one uses
<code><a href="#topic+make_whole">make_whole</a></code> to prepare a time series for analysis and leaves
in the <code>doy</code> column, this column will appear in the output.
</p>
<p>The information shown in the <code>threshold</code> component is:
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>The date of the temperature measurement. This variable may named
differently if an alternative name is supplied to the function's <code>x</code>
argument.</p>
</td></tr>
<tr><td><code>temp</code></td>
<td>
<p>Temperature on the specified date [deg. C]. This variable may
named differently if an alternative name is supplied to the function's <code>y</code>
argument.</p>
</td></tr>
<tr><td><code>thresh</code></td>
<td>
<p>The static <code>threshold</code> chosen by the user [deg. C].</p>
</td></tr>
<tr><td><code>thresh_criterion</code></td>
<td>
<p>Boolean indicating if <code>temp</code> exceeds
<code>threshold</code>.</p>
</td></tr>
<tr><td><code>duration_criterion</code></td>
<td>
<p>Boolean indicating whether periods of consecutive
<code>thresh_criterion</code> are &gt;= <code>min_duration</code>.</p>
</td></tr>
<tr><td><code>exceedance</code></td>
<td>
<p>Boolean indicting if all criteria that define a discrete
group in exceedance of the <code>threshold</code> are met.</p>
</td></tr>
<tr><td><code>exceedance_no</code></td>
<td>
<p>A sequential number indicating the ID and order of
occurence of exceedances.</p>
</td></tr>
</table>
<p>The individual exceedances are summarised using the following metrics:
</p>
<table>
<tr><td><code>index_start</code></td>
<td>
<p>Row number on which exceedance starts.</p>
</td></tr>
<tr><td><code>index_stop</code></td>
<td>
<p>Row number on which exceedance stops.</p>
</td></tr>
<tr><td><code>exceedance_no</code></td>
<td>
<p>The same sequential number indicating the ID and
order of the exceedance as found in the <code>threshold</code> component of the
output list.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>Duration of exceedance [days].</p>
</td></tr>
<tr><td><code>date_start</code></td>
<td>
<p>Start date of exceedance [date].</p>
</td></tr>
<tr><td><code>date_stop</code></td>
<td>
<p>Stop date of exceedance [date].</p>
</td></tr>
<tr><td><code>date_peak</code></td>
<td>
<p>Date of exceedance peak [date].</p>
</td></tr>
<tr><td><code>int_mean</code></td>
<td>
<p>Mean intensity [deg. C].</p>
</td></tr>
<tr><td><code>int_max</code></td>
<td>
<p>Maximum (peak) intensity [deg. C].</p>
</td></tr>
<tr><td><code>int_var</code></td>
<td>
<p>Intensity variability (standard deviation) [deg. C].</p>
</td></tr>
<tr><td><code>int_cum</code></td>
<td>
<p>Cumulative intensity [deg. C x days].</p>
</td></tr>
<tr><td><code>rate_onset</code></td>
<td>
<p>Onset rate of exceedance [deg. C / day].</p>
</td></tr>
<tr><td><code>rate_decline</code></td>
<td>
<p>Decline rate of exceedance [deg. C / day].</p>
</td></tr>
</table>
<p><code>int_max_abs</code>, <code>int_mean_abs</code>, <code>int_var_abs</code>, and
<code>int_cum_abs</code> are as above except as absolute magnitudes
rather than relative to the threshold.
</p>


<h3>Author(s)</h3>

<p>Robert W. Schlegel, Albertus J. Smit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_dat &lt;- make_whole(sst_WA)
res &lt;- exceedance(ts_dat, threshold = 25)
# show first ten days of daily data:
res$threshold[1:10, ]
# show first five exceedances:
res$exceedance[1:5, ]
</code></pre>

<hr>
<h2 id='geom_flame'>Create 'Flame' Ploygons.</h2><span id='topic+geom_flame'></span>

<h3>Description</h3>

<p>This function will create polygons between two lines. If given a
temperature and theshold time series, like that produced by <code><a href="#topic+detect">detect</a></code>,
the output will meet the specifications of Hobday et al. (2016) shown as
'flame polygons.' If one wishes to plot polygons below a given threshold, and not
above, switch the values being fed to the <code>y</code> and <code>y2</code>
aesthetics. This function differs in use from <code><a href="#topic+event_line">event_line</a></code>
in that it must be created as a <code>ggplot</code> 'geom' object. The benefit
of this being that one may add additional information to the figure as geom
layers to ggplot2 graphs as may be necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_flame(mapping = NULL, data = NULL, stat = "identity",
  position = "identity", ..., na.rm = FALSE, show.legend = NA,
  inherit.aes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_flame_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code> or <code>aes_()</code>. If
specified and inherit.aes = TRUE (the default), it is combined with the
default mapping at the top level of the plot. You must supply mapping if
there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three options:
</p>
<p>If NULL, the default, the data is inherited from the plot data as specified
in the call to <code>ggplot()</code>.
</p>
<p>A data.frame, or other object, will override the plot data. All objects will
be fortified to produce a data frame. See <code>fortify()</code> for which variables will
be created.
</p>
<p>A function will be called with a single argument, the plot data. The return
value must be a <code>data.frame</code>, and will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer,
as a string.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call
to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning. If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends? <code>NA</code>,
the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and
<code>TRUE</code> always includes. It can also be a named logical vector to finely select
the aesthetics to display.</p>
</td></tr>
<tr><td><code id="geom_flame_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default plot
specification, e.g. <code>borders()</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_flame</code> understands the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><strong><code>y2</code></strong>
</p>
</li>
<li> <p><code>colour</code>
</p>
</li>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>References</h3>

<p>Hobday, A.J. et al. (2016), A hierarchical approach to defining
marine heatwaves, Progress in Oceanography, 141, pp. 227-238,
doi: 10.1016/j.pocean.2015.12.014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_line">event_line</a></code> for a non-ggplot2 based flame function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_dat &lt;- make_whole(sst_WA)
res &lt;- detect(ts_dat, climatology_start = "1983-01-01",
              climatology_end = "2012-12-31")
mhw &lt;- res$clim
mhw &lt;- mhw[10580:10690,]

## Not run: 
require(ggplot2)
ggplot(mhw, aes(x = t, y = temp)) +
  geom_flame(aes(y2 = thresh_clim_year)) +
  geom_text(aes(x = as.Date("2011-02-01"), y = 28,
  label = "That's not a heatwave.\nThis, is a heatwave.")) +
  xlab("Date") + ylab(expression(paste("Temperature [", degree, "C]")))

## End(Not run)
</code></pre>

<hr>
<h2 id='geom_lolli'>Visualise a Timeline of Several Event Metrics as 'Lollipops'.</h2><span id='topic+geom_lolli'></span>

<h3>Description</h3>

<p>The function will return a graph of the intensity of the selected
metric along the *y*-axis versus a time variable along the *x*-axis.
The number of top events (<code>n</code>) from the chosen metric may be highlighted
in a brighter colour with the aesthetic value <code>colour.n</code>.
This function differs in use from <code><a href="#topic+lolli_plot">lolli_plot</a></code>
in that it must be created as a ggplot2 'geom' object. The benefit of this being
that one may add additional information layer by layer to the figure as
geoms as necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_lolli(mapping = NULL, data = NULL, ..., n = 1, na.rm = FALSE,
  show.legend = NA, inherit.aes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_lolli_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code>aes()</code> or <code>aes_()</code>. If
specified and inherit.aes = TRUE (the default), it is combined with the
default mapping at the top level of the plot. You must supply mapping if
there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three options:
</p>
<p>If NULL, the default, the data is inherited from the plot data as specified
in the call to <code>ggplot()</code>.
</p>
<p>A data.frame, or other object, will override the plot data. All objects will
be fortified to produce a data frame. See <code>fortify()</code> for which variables will
be created.
</p>
<p>A function will be called with a single argument, the plot data. The return
value must be a <code>data.frame</code>, and will be used as the layer data.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>color = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_n">n</code></td>
<td>
<p>The number of top events to highlight. Default is 1. This parameter
has no effect if <code>colour.n</code> is set to <code>NA</code> outside of <code>aes()</code>.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning. If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Should this layer be included in the legends? <code>NA</code>,
the default, includes if any aesthetics are mapped. <code>FALSE</code> never includes, and
<code>TRUE</code> always includes. It can also be a named logical vector to finely select
the aesthetics to display.</p>
</td></tr>
<tr><td><code id="geom_lolli_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that define
both data and aesthetics and shouldn't inherit behaviour from the default plot
specification, e.g. <code>borders()</code>.</p>
</td></tr>
</table>


<h3>Aesthetics</h3>

<p><code>geom_lolli</code> understands the following aesthetics (required aesthetics
are in bold):
</p>

<ul>
<li> <p><strong><code>x</code></strong>
</p>
</li>
<li> <p><strong><code>y</code></strong>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li>
<li> <p><code>color</code>
</p>
</li>
<li> <p><code>linetype</code>
</p>
</li>
<li> <p><code>size</code>
</p>
</li>
<li> <p><code>shape</code>
</p>
</li>
<li> <p><code>stroke</code>
</p>
</li>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>colour.n</code>: While this value may be used as an aesthetic, it also
works as a parameter for this function. If one chooses not to highlight
any events, use <code>colour.n = NA</code> outside of <code>aes()</code>. One may
also provide a non-static value to <code>colour.na</code> but remember that
one may not provide multiple continuous or discrete scales to a single
ggplot2 object. Therefore, if one provides a continuous value to
<code>aes(colour)</code>, the values supplied to <code>colour.n</code> must be
discrete. ggplot2 will attempt to do this automatically.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robert W. Schlegel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lolli_plot">lolli_plot</a></code> for a non-geom based lolliplot function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_dat &lt;- make_whole(sst_NW_Atl)
# with defaults:
res &lt;- detect(ts_dat, climatology_start = "1983-01-01",
              climatology_end = "2012-12-31")
mhw &lt;- res$event

## Not run: 
require(lubridate)
# Height of lollis represent event durations and their colours
# are mapped to the events' cumulative intensity:
ggplot(mhw, aes(x = mhw$date_peak, y = mhw$duration)) +
  geom_lolli(n = 0, shape = 20, aes(colour = mhw$int_cum), colour.n = NA) +
  scale_color_distiller(palette = "Spectral", name = "Cumulative \nintensity") +
  xlab("Date") + ylab("Event duration [days]")

# Height of lollis represent event durations and the top three (longest)
# lollis are highlighted in red:
ggplot(mhw, aes(x = mhw$date_peak, y = mhw$duration)) +
  geom_lolli(n = 3, shape = 20, colour.n = "red") +
  scale_color_distiller(palette = "Spectral", name = "Cumulative \nintensity") +
  xlab("Date") + ylab("Event duration [days]")

## End(Not run)
</code></pre>

<hr>
<h2 id='lolli_plot'>Create a Timeline of Selected Event Metrics.</h2><span id='topic+lolli_plot'></span>

<h3>Description</h3>

<p>Visualise a timeline of several event metrics as 'lollipop' graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lolli_plot(data, metric = "int_max", event_count = 3,
  xaxis = "date_start")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lolli_plot_+3A_data">data</code></td>
<td>
<p>Output from the <code><a href="#topic+detect">detect</a></code> function.</p>
</td></tr>
<tr><td><code id="lolli_plot_+3A_metric">metric</code></td>
<td>
<p>One of <code>int_mean</code>, <code>int_max</code>, <code>int_cum</code> and <code>duration</code>.
Default is <code>int_cum</code>.</p>
</td></tr>
<tr><td><code id="lolli_plot_+3A_event_count">event_count</code></td>
<td>
<p>The number of top events to highlight. Default is 3.</p>
</td></tr>
<tr><td><code id="lolli_plot_+3A_xaxis">xaxis</code></td>
<td>
<p>One of <code>event_no</code>, <code>date_start</code> or <code>date_peak</code>.
Default is <code>date_start</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will return a graph of the intensity of the selected
metric along the y-axis versus either <code>t</code> or <code>event_no</code>.
The number of top events as per <code>event_count</code> will be highlighted
in a brighter colour. This function differs in use from <code><a href="#topic+geom_lolli">geom_lolli</a></code>
in that it creates a stand alone figure. The benefit of this being
that one must not have any prior knowledge of ggplot2 to create the figure.
</p>


<h3>Author(s)</h3>

<p>Albertus J. Smit and Robert W. Schlegel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_dat &lt;- make_whole(sst_NW_Atl)
res &lt;- detect(ts_dat, climatology_start = "1983-01-01",
              climatology_end = "2012-12-31")

## Not run: 
lolli_plot(res, metric = "int_cum", event_count = 3, xaxis = "date_peak")

## End(Not run)
</code></pre>

<hr>
<h2 id='make_whole'>Constructs a Continuous, Uninterrupted Time Series of Temperatures.</h2><span id='topic+make_whole'></span>

<h3>Description</h3>

<p>Takes a series of dates and temperatures, and if irregular (but ordered), inserts
missing dates and fills correpsonding temperatures with NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_whole(data, x = t, y = temp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_whole_+3A_data">data</code></td>
<td>
<p>A data frame with columns for date and temperature data.
Ordered daily data are expected, and although missing values (NA) can be
accommodated, the function is only recommended when NAs occur infrequently,
preferably at no more than 3 consecutive days.</p>
</td></tr>
<tr><td><code id="make_whole_+3A_x">x</code></td>
<td>
<p>A column with the daily time vector (see details). For backwards
compatibility, the column is named <code>t</code> by default.</p>
</td></tr>
<tr><td><code id="make_whole_+3A_y">y</code></td>
<td>
<p>A column with the response vector. RmarineHeatWaves version &lt;= 0.15.9
assumed that this would be daily seawater temperatures, but as of version 0.16.0
it may be any arbitrary measurement taken at a daily frequency. The default
remains temperature, and the default column name is therefore <code>temp</code>, again
hopefully ensuring backwards compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Upon import, the package uses 'zoo' and 'lubridate' to process the input
date and temperature data. It reads in daily data with the time vector
specified as either <code>POSIXct</code> or <code>Date</code>  (e.g. &quot;1982-01-01 02:00:00&quot; or
&quot;1982-01-01&quot;). The data may be an irregular time series, but date must be
ordered. The function constructs a complete time series from the start date
to the end date, and fills in the regions in the time series where temperature
data are missing, with NAs in the temperature vector. There must only be one
temperature value per day otherwise the function will fail. It is up to the
user to calculate daily data from sub-daily measurements. Leap years are
automatically accommodated by 'zoo'.
</p>
<p>This function can handle some of missing days, but this is not a
licence to actually use these data for the detection of anomalous thermal
events. Hobday et al. (2016) recommend gaps of no more than 3 days, which
may be adjusted by setting the <code>max_pad_length</code> argument of the
<code><a href="#topic+detect">detect</a></code> function. The longer and more frequent the gaps become
the lower the fidelity of the annual climatology and threshold that can be
calculated, which will not only have repercussions for the accuracy at which
the event metrics can be determined, but also for the number of events that
can be detected.
</p>
<p>It is recommended that a climatology period of at least 30 years is specified
in order to capture any decadal thermal periodicities.
</p>


<h3>Value</h3>

<p>The function will return a data frame with three columns. The column
headed <code>doy</code> (day-of-year) is the Julian day running from 1 to 366, but
modified so that the day-of-year series for non-leap-years runs 1...59 and
then 61...366. For leap years the 60th day is February 29. See the example,
below. The other two columns take the names of <code>x</code> and <code>y</code>, if supplied,
or it will be <code>t</code> and <code>temp</code> in case the default values were used.
The <code>x</code> (or <code>t</code>) column is a series of dates of class <code>Date</code>,
while <code>y</code> (or <code>temp</code>) is the measured variable. This time series will
be uninterrupted and continuous daily values between the first and last dates
of the input data.
</p>


<h3>Author(s)</h3>

<p>Smit, A. J.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(dplyr); require(tidyr); require(lubridate)
ts_dat &lt;- make_whole(sst_WA) # default columns "t" and "temp", in that order
clim_start &lt;- "1983-01-01"
clim_end &lt;- "2012-12-31"
ts_dat %&gt;%
filter(t &gt;= clim_start &amp; t &lt;= clim_end) %&gt;%
  mutate(t = year(t)) %&gt;%
  spread(t, temp) %&gt;%
  filter(doy &gt;= 55 &amp; doy &lt;= 65)
</code></pre>

<hr>
<h2 id='sst_Med'>Optimally Interpolated 0.25 degree SST for the Mediterranean region.</h2><span id='topic+sst_Med'></span>

<h3>Description</h3>

<p>A dataset containing the sea surface temperature (in degrees Celsius)
and date for the Mediterranean region from 1982-01-01 to 2014-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sst_Med
</code></pre>


<h3>Format</h3>

<p>A data frame with 12053 rows and 2 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as POSIXct</p>
</dd>
<dt>temp</dt><dd><p>SST, in degrees Celsius</p>
</dd>
</dl>
<p>...
</p>


<h3>Source</h3>

<p><a href="https://www.ncdc.noaa.gov/oisst">https://www.ncdc.noaa.gov/oisst</a>
</p>

<hr>
<h2 id='sst_NW_Atl'>Optimally Interpolated 0.25 degree SST for the NW Atlantic region.</h2><span id='topic+sst_NW_Atl'></span>

<h3>Description</h3>

<p>A dataset containing the sea surface temperature (in degrees Celsius) and
date for the Northwest Atlantic region from 1982-01-01 to 2014-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sst_NW_Atl
</code></pre>


<h3>Format</h3>

<p>A data frame with 12053 rows and 2 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as POSIXct</p>
</dd>
<dt>temp</dt><dd><p>SST, in degrees Celsius</p>
</dd>
</dl>
<p>...
</p>


<h3>Source</h3>

<p><a href="https://www.ncdc.noaa.gov/oisst">https://www.ncdc.noaa.gov/oisst</a>
</p>

<hr>
<h2 id='sst_WA'>Optimally Interpolated 0.25 degree SST for the Western Australian region.</h2><span id='topic+sst_WA'></span>

<h3>Description</h3>

<p>A dataset containing the sea surface temperature temperature
(in degrees Celsius) and date for the Western Australian region
for the period 1982-01-01 to 2014-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sst_WA
</code></pre>


<h3>Format</h3>

<p>A data frame with 12053 rows and 2 variables:
</p>

<dl>
<dt>t</dt><dd><p>date, as POSIXct</p>
</dd>
<dt>temp</dt><dd><p>SST, in degrees Celsius</p>
</dd>
</dl>
<p>...
</p>


<h3>Source</h3>

<p><a href="https://www.ncdc.noaa.gov/oisst">https://www.ncdc.noaa.gov/oisst</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
