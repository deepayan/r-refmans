<!DOCTYPE html><html><head><title>Help for package vcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vcr'><p>vcr: Record HTTP Calls to Disk</p></a></li>
<li><a href='#as.cassette'><p>Coerce names, etc. to cassettes</p></a></li>
<li><a href='#Cassette'><p>Cassette handler</p></a></li>
<li><a href='#cassettes'><p>List cassettes, get current cassette, etc.</p></a></li>
<li><a href='#check_cassette_names'><p>Check cassette names</p></a></li>
<li><a href='#crul_request'><p>An HTTP request as prepared by the <span class="pkg">crul</span> package</p></a></li>
<li><a href='#eject_cassette'><p>Eject a cassette</p></a></li>
<li><a href='#FileSystem'><p>File system persister</p></a></li>
<li><a href='#Hooks'><p>Hooks class</p></a></li>
<li><a href='#http_interactions'><p>Get the http interactions of the current cassette</p></a></li>
<li><a href='#HTTPInteraction'><p>HTTPInteraction class</p></a></li>
<li><a href='#HTTPInteractionList'><p>HTTPInteractionList class</p></a></li>
<li><a href='#insert_cassette'><p>Insert a cassette to record HTTP requests</p></a></li>
<li><a href='#JSON'><p>The JSON serializer</p></a></li>
<li><a href='#lightswitch'><p>Turn vcr on and off, check on/off status, and turn off for a given http call</p></a></li>
<li><a href='#Persisters'><p>Cassette persisters</p></a></li>
<li><a href='#real_http_connections_allowed'><p>Are real http connections allowed?</p></a></li>
<li><a href='#recording'><p>vcr recording options</p></a></li>
<li><a href='#Request'><p>The request of an HTTPInteraction</p></a></li>
<li><a href='#request_response'><p>request and response summary methods</p></a></li>
<li><a href='#request-matching'><p>vcr request matching</p></a></li>
<li><a href='#RequestHandler'><p>RequestHandler</p></a></li>
<li><a href='#RequestHandlerCrul'><p>RequestHandlerCrul</p></a></li>
<li><a href='#RequestHandlerHttr'><p>RequestHandlerHttr</p></a></li>
<li><a href='#RequestIgnorer'><p>Request ignorer</p></a></li>
<li><a href='#RequestMatcherRegistry'><p>RequestMatcherRegistry</p></a></li>
<li><a href='#Serializer'><p>Serializer class - base class for JSON/YAML serializers</p></a></li>
<li><a href='#Serializers'><p>Cassette serializers</p></a></li>
<li><a href='#skip_if_vcr_off'><p>Skip tests if vcr is off</p></a></li>
<li><a href='#str_splitter'><p>split string every N characters</p></a></li>
<li><a href='#UnhandledHTTPRequestError'><p>UnhandledHTTPRequestError</p></a></li>
<li><a href='#use_cassette'><p>Use a cassette to record HTTP requests</p></a></li>
<li><a href='#use_vcr'><p>Setup vcr for a package</p></a></li>
<li><a href='#vcr_configure'><p>Global Configuration Options</p></a></li>
<li><a href='#vcr_logging'><p>vcr log file setup</p></a></li>
<li><a href='#vcr_test_path'><p>Locate file in tests directory</p></a></li>
<li><a href='#VcrResponse'><p>The response of an HTTPInteraction</p></a></li>
<li><a href='#YAML'><p>The YAML serializer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Record 'HTTP' Calls to Disk</td>
</tr>
<tr>
<td>Description:</td>
<td>Record test suite 'HTTP' requests and replays them during
    future runs. A port of the Ruby gem of the same name
    (<a href="https://github.com/vcr/vcr/">https://github.com/vcr/vcr/</a>). Works by hooking into the 'webmockr'
    R package for matching 'HTTP' requests by various rules ('HTTP' method,
    'URL', query parameters, headers, body, etc.), and then caching
    real 'HTTP' responses on disk in 'cassettes'. Subsequent 'HTTP' requests
    matching any previous requests in the same 'cassette' use a cached
    'HTTP' response.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/vcr/">https://github.com/ropensci/vcr/</a> (devel)
<a href="https://books.ropensci.org/http-testing/">https://books.ropensci.org/http-testing/</a> (user manual)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/vcr/issues">https://github.com/ropensci/vcr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>crul (&ge; 0.8.4), httr, webmockr (&ge; 0.8.0), urltools, yaml,
R6, base64enc, rprojroot</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2 (&ge; 7.2.1), jsonlite, testthat, knitr, rmarkdown,
desc, crayon, cli, curl, withr</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Web</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>http, https, API, web-services, curl, mock,
mocking, http-mocking, testing, testing-tools, tdd</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-25 04:08:59 UTC; sckott</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Aaron Wolen <a href="https://orcid.org/0000-0003-2542-2202"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  MaÃ«lle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel Possenriede
    <a href="https://orcid.org/0000-0002-6738-9845"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  rOpenSci [fnd] (https://ropensci.org)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Chamberlain &lt;sckott@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-25 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vcr'>vcr: Record HTTP Calls to Disk</h2><span id='topic+vcr'></span><span id='topic+vcr-package'></span>

<h3>Description</h3>

<p><span class="pkg">vcr</span> records test suite 'HTTP' requests and replay them during
future runs.
</p>


<h3>Details</h3>

<p>Check out the <a href="https://books.ropensci.org/http-testing/">http testing book</a>
for a lot more documentation on <code>vcr</code>, <code>webmockr</code>, and <code>crul</code>
</p>


<h3>Backstory</h3>

<p>A Ruby gem of the same name (<code>VCR</code>, <a href="https://github.com/vcr/vcr">https://github.com/vcr/vcr</a>) was
created many years ago and is the original. Ports in many languages
have been done. Check out that GitHub repo for all the details on
how the canonical version works.
</p>


<h3>Main functions</h3>

<p>The <a href="#topic+use_cassette">use_cassette</a> function is most likely what you'll want to use. It
sets the cassette you want to record to, inserts the cassette, and then
ejects the cassette, recording the interactions to the cassette.
</p>
<p>Instead, you can use <a href="#topic+insert_cassette">insert_cassette</a>, but then you have to make sure
to use <a href="#topic+eject_cassette">eject_cassette</a>.
</p>


<h3>vcr configuration</h3>

<p><a href="#topic+vcr_configure">vcr_configure</a> is the function to use to set R session wide settings.
See it's manual file for help.
</p>


<h3>Record modes</h3>

<p>See <a href="#topic+recording">recording</a> for help on record modes.
</p>


<h3>Request matching</h3>

<p>See <a href="#topic+request-matching">request-matching</a> for help on the many request matching options.
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain
</p>

<hr>
<h2 id='as.cassette'>Coerce names, etc. to cassettes</h2><span id='topic+as.cassette'></span><span id='topic+as.cassettepath'></span>

<h3>Description</h3>

<p>Coerce names, etc. to cassettes
</p>
<p>Coerce to a cassette path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.cassette(x, ...)

as.cassettepath(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.cassette_+3A_x">x</code></td>
<td>
<p>Input, a cassette name (character), or something that
can be coerced to a cassette</p>
</td></tr>
<tr><td><code id="as.cassette_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="#topic+cassettes">cassettes()</a></code> or
[read_cassette_meta()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cassette of class <code>Cassette</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(dir = tempfile())
insert_cassette("foobar")
cassettes(on_disk = FALSE)
cassettes(on_disk = TRUE)
as.cassette("foobar", on_disk = FALSE)
eject_cassette() # eject the current cassette

# cleanup
unlink(file.path(tempfile(), "foobar.yml"))

## End(Not run)
</code></pre>

<hr>
<h2 id='Cassette'>Cassette handler</h2><span id='topic+Cassette'></span>

<h3>Description</h3>

<p>Main R6 class that is called from the main user facing
function <code><a href="#topic+use_cassette">use_cassette()</a></code>
</p>


<h3>Value</h3>

<p>an object of class <code>Cassette</code>
</p>


<h3>Points of webmockr integration</h3>


<ul>
<li> <p><code>initialize()</code>: webmockr is used in the <code>initialize()</code> method to
create webmockr stubs. stubs are created on call to <code>Cassette$new()</code>
within <code>insert_cassette()</code>, but then on exiting <code>use_cassette()</code>,
or calling <code>eject()</code> on <code>Cassette</code> class from <code>insert_cassette()</code>,
stubs are cleaned up.
</p>
</li>
<li> <p><code>eject()</code> method: <code><a href="webmockr.html#topic+enable">webmockr::disable()</a></code> is called before exiting
eject to disable webmock so that webmockr does not affect any HTTP
requests that happen afterwards
</p>
</li>
<li> <p><code>call_block()</code> method: call_block is used in the <code><a href="#topic+use_cassette">use_cassette()</a></code>
function to evaluate whatever code is passed to it; within call_block
<code><a href="webmockr.html#topic+webmockr_configure">webmockr::webmockr_allow_net_connect()</a></code> is run before we evaluate
the code block to allow real HTTP requests, then
<code><a href="webmockr.html#topic+webmockr_configure">webmockr::webmockr_disable_net_connect()</a></code> is called after evalulating
the code block to disallow real HTTP requests
</p>
</li>
<li> <p><code>make_http_interaction()</code> method: <code><a href="webmockr.html#topic+pluck_body">webmockr::pluck_body()</a></code> utility
function is used to pull the request body out of the HTTP request
</p>
</li>
<li> <p><code>serialize_to_crul()</code> method: method: <a href="webmockr.html#topic+RequestSignature">webmockr::RequestSignature</a> and
<a href="webmockr.html#topic+Response">webmockr::Response</a> are used to build a request and response,
respectively, then passed to <code><a href="webmockr.html#topic+build_crul_response">webmockr::build_crul_response()</a></code>
to make a complete <code>crul</code> HTTP response object
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>(character) cassette name</p>
</dd>
<dt><code>record</code></dt><dd><p>(character) record mode</p>
</dd>
<dt><code>manfile</code></dt><dd><p>(character) cassette file path</p>
</dd>
<dt><code>recorded_at</code></dt><dd><p>(character) date/time recorded at</p>
</dd>
<dt><code>serialize_with</code></dt><dd><p>(character) serializer to use (yaml|json)</p>
</dd>
<dt><code>serializer</code></dt><dd><p>(character) serializer to use (yaml|json)</p>
</dd>
<dt><code>persist_with</code></dt><dd><p>(character) persister to use (FileSystem only)</p>
</dd>
<dt><code>persister</code></dt><dd><p>(character) persister to use (FileSystem only)</p>
</dd>
<dt><code>match_requests_on</code></dt><dd><p>(character) matchers to use
default: method &amp; uri</p>
</dd>
<dt><code>re_record_interval</code></dt><dd><p>(numeric) the re-record interval</p>
</dd>
<dt><code>tag</code></dt><dd><p>ignored, not used right now</p>
</dd>
<dt><code>tags</code></dt><dd><p>ignored, not used right now</p>
</dd>
<dt><code>root_dir</code></dt><dd><p>root dir, gathered from <code><a href="#topic+vcr_configuration">vcr_configuration()</a></code></p>
</dd>
<dt><code>update_content_length_header</code></dt><dd><p>(logical) Whether to overwrite the
<code>Content-Length</code> header</p>
</dd>
<dt><code>allow_playback_repeats</code></dt><dd><p>(logical) Whether to allow a single HTTP
interaction to be played back multiple times</p>
</dd>
<dt><code>allow_unused_http_interactions</code></dt><dd><p>(logical) ignored, not used right now</p>
</dd>
<dt><code>exclusive</code></dt><dd><p>(logical) ignored, not used right now</p>
</dd>
<dt><code>preserve_exact_body_bytes</code></dt><dd><p>(logical) Whether to base64 encode the
bytes of the requests and responses</p>
</dd>
<dt><code>args</code></dt><dd><p>(list) internal use</p>
</dd>
<dt><code>http_interactions_</code></dt><dd><p>(list) internal use</p>
</dd>
<dt><code>new_recorded_interactions</code></dt><dd><p>(list) internal use</p>
</dd>
<dt><code>clean_outdated_http_interactions</code></dt><dd><p>(logical) Should outdated interactions
be recorded back to file</p>
</dd>
<dt><code>to_return</code></dt><dd><p>(logical) internal use</p>
</dd>
<dt><code>cassette_opts</code></dt><dd><p>(list) various cassette options</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Cassette-new"><code>Cassette$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-print"><code>Cassette$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-call_block"><code>Cassette$call_block()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-eject"><code>Cassette$eject()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-file"><code>Cassette$file()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-recording"><code>Cassette$recording()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-is_empty"><code>Cassette$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-originally_recorded_at"><code>Cassette$originally_recorded_at()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-serializable_hash"><code>Cassette$serializable_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-interactions_to_record"><code>Cassette$interactions_to_record()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-merged_interactions"><code>Cassette$merged_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-up_to_date_interactions"><code>Cassette$up_to_date_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-should_re_record"><code>Cassette$should_re_record()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-should_stub_requests"><code>Cassette$should_stub_requests()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-should_remove_matching_existing_interactions"><code>Cassette$should_remove_matching_existing_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-storage_key"><code>Cassette$storage_key()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-raw_cassette_bytes"><code>Cassette$raw_cassette_bytes()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-make_dir"><code>Cassette$make_dir()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-deserialized_hash"><code>Cassette$deserialized_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-previously_recorded_interactions"><code>Cassette$previously_recorded_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-write_recorded_interactions_to_disk"><code>Cassette$write_recorded_interactions_to_disk()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-record_http_interaction"><code>Cassette$record_http_interaction()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-any_new_recorded_interactions"><code>Cassette$any_new_recorded_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-make_args"><code>Cassette$make_args()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-write_metadata"><code>Cassette$write_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-http_interactions"><code>Cassette$http_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-make_http_interaction"><code>Cassette$make_http_interaction()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-serialize_to_crul"><code>Cassette$serialize_to_crul()</code></a>
</p>
</li>
<li> <p><a href="#method-Cassette-clone"><code>Cassette$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Cassette-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Cassette</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$new(
  name,
  record,
  serialize_with,
  persist_with,
  match_requests_on,
  re_record_interval,
  tag,
  tags,
  update_content_length_header,
  allow_playback_repeats,
  allow_unused_http_interactions,
  exclusive,
  preserve_exact_body_bytes,
  clean_outdated_http_interactions
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>The name of the cassette. vcr will sanitize this to ensure it
is a valid file name.</p>
</dd>
<dt><code>record</code></dt><dd><p>The record mode. Default: &quot;once&quot;. In the future we'll support
&quot;once&quot;, &quot;all&quot;, &quot;none&quot;, &quot;new_episodes&quot;. See <a href="#topic+recording">recording</a> for more information</p>
</dd>
<dt><code>serialize_with</code></dt><dd><p>(character) Which serializer to use.
Valid values are &quot;yaml&quot; (default), the only one supported for now.</p>
</dd>
<dt><code>persist_with</code></dt><dd><p>(character) Which cassette persister to
use. Default: &quot;file_system&quot;. You can also register and use a
custom persister.</p>
</dd>
<dt><code>match_requests_on</code></dt><dd><p>List of request matchers
to use to determine what recorded HTTP interaction to replay. Defaults to
<code style="white-space: pre;">&#8288;["method", "uri"]&#8288;</code>. The built-in matchers are &quot;method&quot;, &quot;uri&quot;,
&quot;headers&quot; and &quot;body&quot; (&quot;host&quot; and &quot;path&quot; not supported yet, but should
be in a future version)</p>
</dd>
<dt><code>re_record_interval</code></dt><dd><p>(numeric) When given, the cassette will be
re-recorded at the given interval, in seconds.</p>
</dd>
<dt><code>tag, tags</code></dt><dd><p>tags ignored, not used right now</p>
</dd>
<dt><code>update_content_length_header</code></dt><dd><p>(logical) Whether or
not to overwrite the <code>Content-Length</code> header of the responses to
match the length of the response body. Default: <code>FALSE</code></p>
</dd>
<dt><code>allow_playback_repeats</code></dt><dd><p>(logical) Whether or not to
allow a single HTTP interaction to be played back multiple times.
Default: <code>FALSE</code>.</p>
</dd>
<dt><code>allow_unused_http_interactions</code></dt><dd><p>(logical) ignored, not used right now</p>
</dd>
<dt><code>exclusive</code></dt><dd><p>(logical) ignored, not used right now</p>
</dd>
<dt><code>preserve_exact_body_bytes</code></dt><dd><p>(logical) Whether or not
to base64 encode the bytes of the requests and responses for
this cassette when serializing it. See also <code>preserve_exact_body_bytes</code>
in <code><a href="#topic+vcr_configure">vcr_configure()</a></code>. Default: <code>FALSE</code></p>
</dd>
<dt><code>clean_outdated_http_interactions</code></dt><dd><p>(logical) Should outdated interactions
be recorded back to file. Default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Cassette</code> object
</p>


<hr>
<a id="method-Cassette-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for <code>Cassette</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cassette-call_block"></a>



<h4>Method <code>call_block()</code></h4>

<p>run code
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$call_block(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>pass in things to be evaluated</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>various
</p>


<hr>
<a id="method-Cassette-eject"></a>



<h4>Method <code>eject()</code></h4>

<p>ejects the current cassette
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$eject()</pre></div>



<h5>Returns</h5>

<p>self
</p>


<hr>
<a id="method-Cassette-file"></a>



<h4>Method <code>file()</code></h4>

<p>get the file path for the cassette
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$file()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-Cassette-recording"></a>



<h4>Method <code>recording()</code></h4>

<p>is the cassette in recording mode?
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$recording()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-Cassette-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>is the cassette on disk empty
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$is_empty()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-Cassette-originally_recorded_at"></a>



<h4>Method <code>originally_recorded_at()</code></h4>

<p>timestamp the cassette was originally recorded at
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$originally_recorded_at()</pre></div>



<h5>Returns</h5>

<p>POSIXct date
</p>


<hr>
<a id="method-Cassette-serializable_hash"></a>



<h4>Method <code>serializable_hash()</code></h4>

<p>Get a list of the http interactions to record + recorded_with
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$serializable_hash()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-Cassette-interactions_to_record"></a>



<h4>Method <code>interactions_to_record()</code></h4>

<p>Get the list of http interactions to record
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$interactions_to_record()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-Cassette-merged_interactions"></a>



<h4>Method <code>merged_interactions()</code></h4>

<p>Get interactions to record
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$merged_interactions()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-Cassette-up_to_date_interactions"></a>



<h4>Method <code>up_to_date_interactions()</code></h4>

<p>Cleans out any old interactions based on the
re_record_interval and clean_outdated_http_interactions settings
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$up_to_date_interactions(interactions)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interactions</code></dt><dd><p>list of http interactions, of class <a href="#topic+HTTPInteraction">HTTPInteraction</a></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list of interactions to record
</p>


<hr>
<a id="method-Cassette-should_re_record"></a>



<h4>Method <code>should_re_record()</code></h4>

<p>Should re-record interactions?
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$should_re_record()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-Cassette-should_stub_requests"></a>



<h4>Method <code>should_stub_requests()</code></h4>

<p>Is record mode NOT &quot;all&quot;?
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$should_stub_requests()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-Cassette-should_remove_matching_existing_interactions"></a>



<h4>Method <code>should_remove_matching_existing_interactions()</code></h4>

<p>Is record mode &quot;all&quot;?
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$should_remove_matching_existing_interactions()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-Cassette-storage_key"></a>



<h4>Method <code>storage_key()</code></h4>

<p>Get the serializer path
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$storage_key()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-Cassette-raw_cassette_bytes"></a>



<h4>Method <code>raw_cassette_bytes()</code></h4>

<p>Get character string of entire cassette; bytes is a misnomer
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$raw_cassette_bytes()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-Cassette-make_dir"></a>



<h4>Method <code>make_dir()</code></h4>

<p>Create the directory that holds the cassettes, if not present
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$make_dir()</pre></div>



<h5>Returns</h5>

<p>no return; creates a directory recursively, if missing
</p>


<hr>
<a id="method-Cassette-deserialized_hash"></a>



<h4>Method <code>deserialized_hash()</code></h4>

<p>get http interactions from the cassette via the serializer
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$deserialized_hash()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-Cassette-previously_recorded_interactions"></a>



<h4>Method <code>previously_recorded_interactions()</code></h4>

<p>get all previously recorded interactions
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$previously_recorded_interactions()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-Cassette-write_recorded_interactions_to_disk"></a>



<h4>Method <code>write_recorded_interactions_to_disk()</code></h4>

<p>write recorded interactions to disk
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$write_recorded_interactions_to_disk()</pre></div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-Cassette-record_http_interaction"></a>



<h4>Method <code>record_http_interaction()</code></h4>

<p>record an http interaction (doesn't write to disk)
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$record_http_interaction(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an crul or httr response object, with the request at <code style="white-space: pre;">&#8288;$request&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-Cassette-any_new_recorded_interactions"></a>



<h4>Method <code>any_new_recorded_interactions()</code></h4>

<p>Are there any new recorded interactions?
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$any_new_recorded_interactions()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-Cassette-make_args"></a>



<h4>Method <code>make_args()</code></h4>

<p>make list of all options
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$make_args()</pre></div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-Cassette-write_metadata"></a>



<h4>Method <code>write_metadata()</code></h4>

<p>write metadata to the cassette
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$write_metadata()</pre></div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-Cassette-http_interactions"></a>



<h4>Method <code>http_interactions()</code></h4>

<p>make <a href="#topic+HTTPInteractionList">HTTPInteractionList</a> object, assign to http_interactions_ var
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$http_interactions()</pre></div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-Cassette-make_http_interaction"></a>



<h4>Method <code>make_http_interaction()</code></h4>

<p>Make an <code>HTTPInteraction</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$make_http_interaction(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an crul or httr response object, with the request at <code style="white-space: pre;">&#8288;$request&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>an object of class <a href="#topic+HTTPInteraction">HTTPInteraction</a>
</p>


<hr>
<a id="method-Cassette-serialize_to_crul"></a>



<h4>Method <code>serialize_to_crul()</code></h4>

<p>Make a crul response object
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$serialize_to_crul()</pre></div>



<h5>Returns</h5>

<p>a crul response
</p>


<hr>
<a id="method-Cassette-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cassette$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+vcr_configure">vcr_configure()</a></code>, <code><a href="#topic+use_cassette">use_cassette()</a></code>, <code><a href="#topic+insert_cassette">insert_cassette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vcr)
vcr_configure(dir = tempdir())

res &lt;- Cassette$new(name = "bob")
res$file()
res$originally_recorded_at()
res$recording()
res$serializable_hash()
res$eject()
res$should_remove_matching_existing_interactions()
res$storage_key()
res$match_requests_on

# record all requests
res &lt;- Cassette$new("foobar", record = "all")
res$eject()

# cleanup
unlink(file.path(tempdir(), c("bob.yml", "foobar.yml")))

library(vcr)
vcr_configure(dir = tempdir())
res &lt;- Cassette$new(name = "jane")
library(crul)
HttpClient$new("https://httpbin.org")$get("get")
</code></pre>

<hr>
<h2 id='cassettes'>List cassettes, get current cassette, etc.</h2><span id='topic+cassettes'></span><span id='topic+current_cassette'></span><span id='topic+cassette_path'></span>

<h3>Description</h3>

<p>List cassettes, get current cassette, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cassettes(on_disk = TRUE, verb = FALSE)

current_cassette()

cassette_path()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cassettes_+3A_on_disk">on_disk</code></td>
<td>
<p>(logical) Check for cassettes on disk + cassettes in session
(<code>TRUE</code>), or check for only cassettes in session (<code>FALSE</code>). Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="cassettes_+3A_verb">verb</code></td>
<td>
<p>(logical) verbose messages</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>cassettes()</code>: returns cassettes found in your R session, you can toggle
whether we pull from those on disk or not
</p>
</li>
<li> <p><code>current_cassette()</code>: returns an empty list when no cassettes are in use,
while it returns the current cassette (a <code>Cassette</code> object) when one is
in use
</p>
</li>
<li> <p><code>cassette_path()</code>: just gives you the current directory path where
cassettes will be stored
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vcr_configure(dir = tempdir())

# list all cassettes
cassettes()
cassettes(on_disk = FALSE)

# list the currently active cassette
insert_cassette("stuffthings")
current_cassette()
eject_cassette()

cassettes()
cassettes(on_disk = FALSE)

# list the path to cassettes
cassette_path()
vcr_configure(dir = file.path(tempdir(), "foo"))
cassette_path()

vcr_configure_reset()
</code></pre>

<hr>
<h2 id='check_cassette_names'>Check cassette names</h2><span id='topic+check_cassette_names'></span>

<h3>Description</h3>

<p>Check cassette names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cassette_names(
  pattern = "test-",
  behavior = "stop",
  allowed_duplicates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cassette_names_+3A_pattern">pattern</code></td>
<td>
<p>(character) regex pattern for file paths to check.
this is done inside of <code style="white-space: pre;">&#8288;tests/testthat/&#8288;</code>. default: &quot;test-&quot;</p>
</td></tr>
<tr><td><code id="check_cassette_names_+3A_behavior">behavior</code></td>
<td>
<p>(character) &quot;stop&quot; (default) or &quot;warning&quot;. if &quot;warning&quot;,
we use <code>immediate.=TRUE</code> so the warning happens at the top of your
tests rather than you seeing it after tests have run (as would happen
by default)</p>
</td></tr>
<tr><td><code id="check_cassette_names_+3A_allowed_duplicates">allowed_duplicates</code></td>
<td>
<p>(character) cassette names that can be duplicated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cassette names:
</p>

<ul>
<li><p> Should be meaningful so that it is obvious to you what test/function
they relate to. Meaningful names are important so that you can quickly
determine to what test file or test block a cassette belongs. Note
that vcr cannot check that your cassette names are meaningful.
</p>
</li>
<li><p> Should not be duplicated. Duplicated cassette names would lead to a
test using the wrong cassette.
</p>
</li>
<li><p> Should not have spaces. Spaces can lead to problems in using file
paths.
</p>
</li>
<li><p> Should not include a file extension. vcr handles file extensions for
the user.
</p>
</li>
<li><p> Should not have illegal characters that can lead to problems in using
file paths: <code>/</code>, <code style="white-space: pre;">&#8288;?&#8288;</code>, <code>&lt;</code>, <code>&gt;</code>, <code style="white-space: pre;">&#8288;\&#8288;</code>, <code>:</code>, <code>*</code>, <code>|</code>, and <code style="white-space: pre;">&#8288;\"&#8288;</code>
</p>
</li>
<li><p> Should not have control characters, e.g., <code style="white-space: pre;">&#8288;\n&#8288;</code>
</p>
</li>
<li><p> Should not have just dots, e.g., <code>.</code> or <code>..</code>
</p>
</li>
<li><p> Should not have Windows reserved words, e.g., <code>com1</code>
</p>
</li>
<li><p> Should not have trailing dots
</p>
</li>
<li><p> Should not be longer than 255 characters
</p>
</li></ul>

<p><code>vcr::check_cassette_names()</code> is meant to be run during your tests, from
a <a href="https://testthat.r-lib.org/reference/test_dir.html#special-files"><code style="white-space: pre;">&#8288;helper-*.R&#8288;</code> file</a>
inside the <code>tests/testthat</code> directory. It only checks that cassette
names are not duplicated. Note that if you do need to have duplicated
cassette names you can do so by using the <code>allowed_duplicates</code> parameter
in <code>check_cassette_names()</code>. A helper function <code>check_cassette_names()</code>
runs inside <code><a href="#topic+insert_cassette">insert_cassette()</a></code> that checks that
cassettes do not have: spaces, file extensions, unaccepted characters
(slashes).
</p>

<hr>
<h2 id='crul_request'>An HTTP request as prepared by the <span class="pkg">crul</span> package</h2><span id='topic+crul_request'></span>

<h3>Description</h3>

<p>The object is a list, and is the object that is passed on to
<span class="pkg">webmockr</span> and <span class="pkg">vcr</span> instead of routing through
<span class="pkg">crul</span> as normal. Used in examples/tests.
</p>


<h3>Format</h3>

<p>A list
</p>

<hr>
<h2 id='eject_cassette'>Eject a cassette</h2><span id='topic+eject_cassette'></span>

<h3>Description</h3>

<p>Eject a cassette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eject_cassette(
  cassette = NULL,
  options = list(),
  skip_no_unused_interactions_assertion = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eject_cassette_+3A_cassette">cassette</code></td>
<td>
<p>(character) a single cassette names to eject; see <code>name</code>
parameter definition in <code><a href="#topic+insert_cassette">insert_cassette()</a></code> for cassette name rules</p>
</td></tr>
<tr><td><code id="eject_cassette_+3A_options">options</code></td>
<td>
<p>(list) a list of options to apply to the eject process</p>
</td></tr>
<tr><td><code id="eject_cassette_+3A_skip_no_unused_interactions_assertion">skip_no_unused_interactions_assertion</code></td>
<td>
<p>(logical) If <code>TRUE</code>, this will
skip the &quot;no unused HTTP interactions&quot; assertion enabled by the
<code>allow_unused_http_interactions = FALSE</code> cassette option. This is intended
for use when your test has had an error, but your test framework has
already handled it - IGNORED FOR NOW</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ejected cassette if there was one
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use_cassette">use_cassette()</a></code>, <code><a href="#topic+insert_cassette">insert_cassette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcr_configure(dir = tempdir())
insert_cassette("hello")
(x &lt;- current_cassette())

# by default does current cassette
x &lt;- eject_cassette()
x
# can also select by cassette name
# eject_cassette(cassette = "hello")
</code></pre>

<hr>
<h2 id='FileSystem'>File system persister</h2><span id='topic+FileSystem'></span>

<h3>Description</h3>

<p>The only built-in cassette persister. Persists cassettes
to the file system.
</p>


<h3>Details</h3>

<p><strong>Private Methods</strong>
</p>

<dl>
<dt><code>storage_location()</code></dt><dd>
<p>Get storage location
</p>
</dd>
<dt><code>absolute_path_to_file()</code></dt><dd>
<p>Get absolute path to the <code>storage_location</code>
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>file_name</code></dt><dd><p>(character) the file name, not whole path</p>
</dd>
<dt><code>write_fxn</code></dt><dd><p>(character) fxn to use for writing to disk</p>
</dd>
<dt><code>content</code></dt><dd><p>(character) content to record to a cassette</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) storage directory for cassettes</p>
</dd>
<dt><code>write2disk</code></dt><dd><p>(character) write to disk or make a new FileSystem</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FileSystem-new"><code>FileSystem$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FileSystem-get_cassette"><code>FileSystem$get_cassette()</code></a>
</p>
</li>
<li> <p><a href="#method-FileSystem-is_empty"><code>FileSystem$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-FileSystem-set_cassette"><code>FileSystem$set_cassette()</code></a>
</p>
</li>
<li> <p><a href="#method-FileSystem-clone"><code>FileSystem$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FileSystem-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>FileSystem</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>FileSystem$new(
  file_name = NULL,
  write_fxn = NULL,
  content = NULL,
  path = NULL,
  write2disk = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file_name</code></dt><dd><p>(character) the file name, not whole path</p>
</dd>
<dt><code>write_fxn</code></dt><dd><p>(character) fxn to use for writing to disk</p>
</dd>
<dt><code>content</code></dt><dd><p>(character) content to record to a cassette</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) storage directory for cassettes</p>
</dd>
<dt><code>write2disk</code></dt><dd><p>(logical) write to disk or just make a new FileSystem
object. Default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>FileSystem</code> object
</p>


<hr>
<a id="method-FileSystem-get_cassette"></a>



<h4>Method <code>get_cassette()</code></h4>

<p>Gets the cassette for the given storage key (file name)
</p>


<h5>Usage</h5>

<div class="r"><pre>FileSystem$get_cassette(file_name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file_name</code></dt><dd><p>(character) the file name, not whole path</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>named list, from <code>yaml::yaml.load_file</code>
</p>


<hr>
<a id="method-FileSystem-is_empty"></a>



<h4>Method <code>is_empty()</code></h4>

<p>Checks if a cassette is empty or not
</p>


<h5>Usage</h5>

<div class="r"><pre>FileSystem$is_empty()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-FileSystem-set_cassette"></a>



<h4>Method <code>set_cassette()</code></h4>

<p>Sets the cassette for the given storage key (file name)
</p>


<h5>Usage</h5>

<div class="r"><pre>FileSystem$set_cassette(file_name = NULL, content)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file_name</code></dt><dd><p>(character) the file name, not whole path</p>
</dd>
<dt><code>content</code></dt><dd><p>(character) content to record to a cassette</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; writes to disk
</p>


<hr>
<a id="method-FileSystem-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FileSystem$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Hooks'>Hooks class</h2><span id='topic+Hooks'></span>

<h3>Description</h3>

<p>Helps define new hooks, hold hooks, and accessors to get and
use hooks.
</p>


<h3>Details</h3>

<p><strong>Private Methods</strong>
</p>

<dl>
<dt><code>make_hook(x, plac, fun)</code></dt><dd>
<p>Make a hook.
- x (character) Hook name
- plac Placement, one of &quot;start&quot; or &quot;end&quot;
- fun a function/callback
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>hooks</code></dt><dd><p>intenal use</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Hooks-invoke_hook"><code>Hooks$invoke_hook()</code></a>
</p>
</li>
<li> <p><a href="#method-Hooks-clear_hooks"><code>Hooks$clear_hooks()</code></a>
</p>
</li>
<li> <p><a href="#method-Hooks-define_hook"><code>Hooks$define_hook()</code></a>
</p>
</li>
<li> <p><a href="#method-Hooks-clone"><code>Hooks$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Hooks-invoke_hook"></a>



<h4>Method <code>invoke_hook()</code></h4>

<p>invoke a hook
</p>


<h5>Usage</h5>

<div class="r"><pre>Hooks$invoke_hook(hook_type, args)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hook_type</code></dt><dd><p>(character) Hook name</p>
</dd>
<dt><code>args</code></dt><dd><p>(named list) Args passed when invoking a hook</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>executes hook
</p>


<hr>
<a id="method-Hooks-clear_hooks"></a>



<h4>Method <code>clear_hooks()</code></h4>

<p>clear all hooks
</p>


<h5>Usage</h5>

<div class="r"><pre>Hooks$clear_hooks()</pre></div>



<h5>Returns</h5>

<p>no return
</p>


<hr>
<a id="method-Hooks-define_hook"></a>



<h4>Method <code>define_hook()</code></h4>

<p>define a hook
</p>


<h5>Usage</h5>

<div class="r"><pre>Hooks$define_hook(hook_type, fun, prepend = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hook_type</code></dt><dd><p>(character) Hook name</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function</p>
</dd>
<dt><code>prepend</code></dt><dd><p>(logical) Whether to prepend or add to the end
of the string. Default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; defines hook internally
</p>


<hr>
<a id="method-Hooks-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hooks$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='http_interactions'>Get the http interactions of the current cassette</h2><span id='topic+http_interactions'></span>

<h3>Description</h3>

<p>Get the http interactions of the current cassette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>http_interactions()
</code></pre>


<h3>Value</h3>

<p>object of class <code>HTTPInteractionList</code> if there is a current
cassette in use, or <code>NullList</code> if no cassette in use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(dir = tempdir())
insert_cassette("foo_bar")
webmockr::webmockr_allow_net_connect()
library(crul)
cli &lt;- crul::HttpClient$new("https://eu.httpbin.org/get")
one &lt;- cli$get(query = list(a = 5))
z &lt;- http_interactions()
z
z$interactions
z$used_interactions
# on eject, request written to the cassette
eject_cassette("foo_bar")

# insert cassette again
insert_cassette("foo_bar")
# now interactions will be present 
z &lt;- http_interactions()
z$interactions
z$used_interactions
invisible(cli$get(query = list(a = 5)))
z$used_interactions

# cleanup
unlink(file.path(tempdir(), "foo_bar.yml"))

## End(Not run)
</code></pre>

<hr>
<h2 id='HTTPInteraction'>HTTPInteraction class</h2><span id='topic+HTTPInteraction'></span>

<h3>Description</h3>

<p>object holds request and response objects
</p>


<h3>Details</h3>

<p><strong>Methods</strong>
</p>

<dl>
<dt><code>to_hash()</code></dt><dd>
<p>Create a hash from the HTTPInteraction object
</p>
</dd>
<dt><code>from_hash(hash)</code></dt><dd>
<p>Create a HTTPInteraction object from a hash
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>request</code></dt><dd><p>A <code>Request</code> class object</p>
</dd>
<dt><code>response</code></dt><dd><p>A <code>VcrResponse</code> class object</p>
</dd>
<dt><code>recorded_at</code></dt><dd><p>(character) Time http interaction recorded at</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HTTPInteraction-new"><code>HTTPInteraction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteraction-to_hash"><code>HTTPInteraction$to_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteraction-from_hash"><code>HTTPInteraction$from_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteraction-clone"><code>HTTPInteraction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HTTPInteraction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HTTPInteraction</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteraction$new(request, response, recorded_at)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>A <code>Request</code> class object</p>
</dd>
<dt><code>response</code></dt><dd><p>A <code>VcrResponse</code> class object</p>
</dd>
<dt><code>recorded_at</code></dt><dd><p>(character) Time http interaction recorded at</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>HTTPInteraction</code> object
</p>


<hr>
<a id="method-HTTPInteraction-to_hash"></a>



<h4>Method <code>to_hash()</code></h4>

<p>Create a hash from the HTTPInteraction object
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteraction$to_hash()</pre></div>



<h5>Returns</h5>

<p>a named list
</p>


<hr>
<a id="method-HTTPInteraction-from_hash"></a>



<h4>Method <code>from_hash()</code></h4>

<p>Create a HTTPInteraction object from a hash
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteraction$from_hash(hash)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hash</code></dt><dd><p>a named list</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>HttpInteraction</code> object
</p>


<hr>
<a id="method-HTTPInteraction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteraction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# make the request
library(vcr)
url &lt;- "https://eu.httpbin.org/post"
body &lt;- list(foo = "bar")
cli &lt;- crul::HttpClient$new(url = url)
res &lt;- cli$post(body = body)

# build a Request object
(request &lt;- Request$new("POST", uri = url,
  body = body, headers = res$response_headers))
# build a VcrResponse object
(response &lt;- VcrResponse$new(
   res$status_http(),
   res$response_headers,
   res$parse("UTF-8"),
   res$response_headers$status))

# make HTTPInteraction object
(x &lt;- HTTPInteraction$new(request = request, response = response))
x$recorded_at
x$to_hash()

# make an HTTPInteraction from a hash with the object already made
x$from_hash(x$to_hash())

# Make an HTTPInteraction from a hash alone
my_hash &lt;- x$to_hash()
HTTPInteraction$new()$from_hash(my_hash)

## End(Not run)
</code></pre>

<hr>
<h2 id='HTTPInteractionList'>HTTPInteractionList class</h2><span id='topic+HTTPInteractionList'></span>

<h3>Description</h3>

<p>keeps track of all <a href="#topic+HTTPInteraction">HTTPInteraction</a> objects
</p>


<h3>Details</h3>

<p><strong>Private Methods</strong>
</p>

<dl>
<dt><code>has_unused_interactions()</code></dt><dd>
<p>Are there any unused interactions? returns boolean
</p>
</dd>
<dt><code>matching_interaction_index_for()</code></dt><dd>
<p>asdfadf
</p>
</dd>
<dt><code>matching_used_interaction_for(request)</code></dt><dd>
<p>asdfadfs
</p>
</dd>
<dt><code>interaction_matches_request(request, interaction)</code></dt><dd>
<p>Check if a request matches an interaction (logical)
</p>
</dd>
<dt><code>from_hash()</code></dt><dd>
<p>Get a hash back.
</p>
</dd>
<dt><code>request_summary(z)</code></dt><dd>
<p>Get a request summary (character)
</p>
</dd>
<dt><code>response_summary(z)</code></dt><dd>
<p>Get a response summary (character)
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>interactions</code></dt><dd><p>(list) list of interaction class objects</p>
</dd>
<dt><code>request_matchers</code></dt><dd><p>(character) vector of request matchers</p>
</dd>
<dt><code>allow_playback_repeats</code></dt><dd><p>whether to allow playback repeats</p>
</dd>
<dt><code>parent_list</code></dt><dd><p>A list for empty objects, see <code>NullList</code></p>
</dd>
<dt><code>used_interactions</code></dt><dd><p>(list) Interactions that have been used</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HTTPInteractionList-new"><code>HTTPInteractionList$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteractionList-response_for"><code>HTTPInteractionList$response_for()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteractionList-has_interaction_matching"><code>HTTPInteractionList$has_interaction_matching()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteractionList-has_used_interaction_matching"><code>HTTPInteractionList$has_used_interaction_matching()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteractionList-remaining_unused_interaction_count"><code>HTTPInteractionList$remaining_unused_interaction_count()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteractionList-assert_no_unused_interactions"><code>HTTPInteractionList$assert_no_unused_interactions()</code></a>
</p>
</li>
<li> <p><a href="#method-HTTPInteractionList-clone"><code>HTTPInteractionList$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HTTPInteractionList-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HTTPInteractionList</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$new(
  interactions,
  request_matchers,
  allow_playback_repeats = FALSE,
  parent_list = NullList$new(),
  used_interactions = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interactions</code></dt><dd><p>(list) list of interaction class objects</p>
</dd>
<dt><code>request_matchers</code></dt><dd><p>(character) vector of request matchers</p>
</dd>
<dt><code>allow_playback_repeats</code></dt><dd><p>whether to allow playback repeats or not</p>
</dd>
<dt><code>parent_list</code></dt><dd><p>A list for empty objects, see <code>NullList</code></p>
</dd>
<dt><code>used_interactions</code></dt><dd><p>(list) Interactions that have been used. That is,
interactions that are on disk in the current cassette, and a
request has been made that matches that interaction</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>HTTPInteractionList</code> object
</p>


<hr>
<a id="method-HTTPInteractionList-response_for"></a>



<h4>Method <code>response_for()</code></h4>

<p>Check if there's a matching interaction, returns a
response object
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$response_for(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request from an object of class <code>HTTPInteraction</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-HTTPInteractionList-has_interaction_matching"></a>



<h4>Method <code>has_interaction_matching()</code></h4>

<p>Check if has a matching interaction
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$has_interaction_matching(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request from an object of class <code>HTTPInteraction</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-HTTPInteractionList-has_used_interaction_matching"></a>



<h4>Method <code>has_used_interaction_matching()</code></h4>

<p>check if has used interactions matching a given request
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$has_used_interaction_matching(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request from an object of class <code>HTTPInteraction</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-HTTPInteractionList-remaining_unused_interaction_count"></a>



<h4>Method <code>remaining_unused_interaction_count()</code></h4>

<p>Number of unused interactions
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$remaining_unused_interaction_count()</pre></div>



<h5>Returns</h5>

<p>integer
</p>


<hr>
<a id="method-HTTPInteractionList-assert_no_unused_interactions"></a>



<h4>Method <code>assert_no_unused_interactions()</code></h4>

<p>Checks if there are no unused interactions left.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$assert_no_unused_interactions()</pre></div>



<h5>Returns</h5>

<p>various
</p>


<hr>
<a id="method-HTTPInteractionList-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTTPInteractionList$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(
 dir = tempdir(),
 record = "once"
)

# make interactions
## make the request
### turn off mocking
crul::mock(FALSE)
url &lt;- "https://eu.httpbin.org/post"
cli &lt;- crul::HttpClient$new(url = url)
res &lt;- cli$post(body = list(a = 5))

## request
(request &lt;- Request$new("POST", url, list(a = 5), res$headers))
## response
(response &lt;- VcrResponse$new(
   res$status_http(),
   res$response_headers,
   res$parse("UTF-8"),
   res$response_headers$status))
## make an interaction
(inter &lt;- HTTPInteraction$new(request = request, response = response))

# make an interactionlist
(x &lt;- HTTPInteractionList$new(
   interactions = list(inter),
   request_matchers = vcr_configuration()$match_requests_on
))
x$interactions
x$request_matchers
x$parent_list
x$parent_list$response_for()
x$parent_list$has_interaction_matching()
x$parent_list$has_used_interaction_matching()
x$parent_list$remaining_unused_interaction_count()
x$used_interactions
x$allow_playback_repeats
x$interactions
x$response_for(request)

## End(Not run)
</code></pre>

<hr>
<h2 id='insert_cassette'>Insert a cassette to record HTTP requests</h2><span id='topic+insert_cassette'></span>

<h3>Description</h3>

<p>Insert a cassette to record HTTP requests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_cassette(
  name,
  record = NULL,
  match_requests_on = NULL,
  update_content_length_header = FALSE,
  allow_playback_repeats = FALSE,
  serialize_with = NULL,
  persist_with = NULL,
  preserve_exact_body_bytes = NULL,
  re_record_interval = NULL,
  clean_outdated_http_interactions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_cassette_+3A_name">name</code></td>
<td>
<p>The name of the cassette. vcr will check this to ensure it
is a valid file name. Not allowed: spaces, file extensions, control
characters (e.g., <code style="white-space: pre;">&#8288;\n&#8288;</code>), illegal characters ('/', '?', '&lt;', '&gt;', '\', ':',
'*', '|', and '\&quot;'), dots alone (e.g., '.', '..'), Windows reserved
words (e.g., 'com1'), trailing dots (can cause problems on Windows),
names longer than 255 characters. See section &quot;Cassette names&quot;</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_record">record</code></td>
<td>
<p>The record mode (default: <code>"once"</code>). See <a href="#topic+recording">recording</a> for a
complete list of the different recording modes.</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_match_requests_on">match_requests_on</code></td>
<td>
<p>List of request matchers
to use to determine what recorded HTTP interaction to replay. Defaults to
<code style="white-space: pre;">&#8288;["method", "uri"]&#8288;</code>. The built-in matchers are &quot;method&quot;, &quot;uri&quot;, &quot;host&quot;,
&quot;path&quot;, &quot;headers&quot;, &quot;body&quot; and &quot;query&quot;</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_update_content_length_header">update_content_length_header</code></td>
<td>
<p>(logical) Whether or
not to overwrite the <code>Content-Length</code> header of the responses to
match the length of the response body. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_allow_playback_repeats">allow_playback_repeats</code></td>
<td>
<p>(logical) Whether or not to
allow a single HTTP interaction to be played back multiple times.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_serialize_with">serialize_with</code></td>
<td>
<p>(character) Which serializer to use.
Valid values are &quot;yaml&quot; (default) and &quot;json&quot;. Note that you can have
multiple cassettes with the same name as long as they use different
serializers; so if you only want one cassette for a given cassette name,
make sure to not switch serializers, or clean up files you no longer need.</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_persist_with">persist_with</code></td>
<td>
<p>(character) Which cassette persister to
use. Default: &quot;file_system&quot;. You can also register and use a
custom persister.</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_preserve_exact_body_bytes">preserve_exact_body_bytes</code></td>
<td>
<p>(logical) Whether or not
to base64 encode the bytes of the requests and responses for
this cassette when serializing it. See also <code>preserve_exact_body_bytes</code>
in <code><a href="#topic+vcr_configure">vcr_configure()</a></code>. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_re_record_interval">re_record_interval</code></td>
<td>
<p>(integer) How frequently (in seconds) the
cassette should be re-recorded. default: <code>NULL</code> (not re-recorded)</p>
</td></tr>
<tr><td><code id="insert_cassette_+3A_clean_outdated_http_interactions">clean_outdated_http_interactions</code></td>
<td>
<p>(logical) Should outdated
interactions be recorded back to file? default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cassette names:
</p>

<ul>
<li><p> Should be meaningful so that it is obvious to you what test/function
they relate to. Meaningful names are important so that you can quickly
determine to what test file or test block a cassette belongs. Note
that vcr cannot check that your cassette names are meaningful.
</p>
</li>
<li><p> Should not be duplicated. Duplicated cassette names would lead to a
test using the wrong cassette.
</p>
</li>
<li><p> Should not have spaces. Spaces can lead to problems in using file
paths.
</p>
</li>
<li><p> Should not include a file extension. vcr handles file extensions for
the user.
</p>
</li>
<li><p> Should not have illegal characters that can lead to problems in using
file paths: <code>/</code>, <code style="white-space: pre;">&#8288;?&#8288;</code>, <code>&lt;</code>, <code>&gt;</code>, <code style="white-space: pre;">&#8288;\&#8288;</code>, <code>:</code>, <code>*</code>, <code>|</code>, and <code style="white-space: pre;">&#8288;\"&#8288;</code>
</p>
</li>
<li><p> Should not have control characters, e.g., <code style="white-space: pre;">&#8288;\n&#8288;</code>
</p>
</li>
<li><p> Should not have just dots, e.g., <code>.</code> or <code>..</code>
</p>
</li>
<li><p> Should not have Windows reserved words, e.g., <code>com1</code>
</p>
</li>
<li><p> Should not have trailing dots
</p>
</li>
<li><p> Should not be longer than 255 characters
</p>
</li></ul>

<p><code>vcr::check_cassette_names()</code> is meant to be run during your tests, from
a <a href="https://testthat.r-lib.org/reference/test_dir.html#special-files"><code style="white-space: pre;">&#8288;helper-*.R&#8288;</code> file</a>
inside the <code>tests/testthat</code> directory. It only checks that cassette
names are not duplicated. Note that if you do need to have duplicated
cassette names you can do so by using the <code>allowed_duplicates</code> parameter
in <code>check_cassette_names()</code>. A helper function <code>check_cassette_names()</code>
runs inside <code><a href="#topic+insert_cassette">insert_cassette()</a></code> that checks that
cassettes do not have: spaces, file extensions, unaccepted characters
(slashes).
</p>


<h3>Value</h3>

<p>an object of class <code>Cassette</code>
</p>


<h3>Cassette options</h3>

<p>Default values for arguments controlling cassette behavior are
inherited from vcr's global configuration. See <code><a href="#topic+vcr_configure">vcr_configure()</a></code> for a
complete list of options and their default settings. You can override these
options for a specific cassette by changing an argument's value to something
other than <code>NULL</code> when calling either <code>insert_cassette()</code> or
<code>use_cassette()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use_cassette">use_cassette()</a></code>, <code><a href="#topic+eject_cassette">eject_cassette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(vcr)
library(crul)
vcr_configure(dir = tempdir())
webmockr::webmockr_allow_net_connect()

(x &lt;- insert_cassette(name = "leo5"))
current_cassette()
x$new_recorded_interactions
x$previously_recorded_interactions()
cli &lt;- crul::HttpClient$new(url = "https://httpbin.org")
cli$get("get")
x$new_recorded_interactions # 1 interaction
x$previously_recorded_interactions() # empty
webmockr::stub_registry() # not empty
# very important when using inject_cassette: eject when done
x$eject() # same as eject_cassette("leo5")
x$new_recorded_interactions # same, 1 interaction
x$previously_recorded_interactions() # now not empty
## stub_registry now empty, eject() calls webmockr::disable(), which
## calls the disable method for each of crul and httr adadapters,
## which calls webmockr's remove_stubs() method for each adapter
webmockr::stub_registry()

# cleanup
unlink(file.path(tempdir(), "leo5.yml"))

## End(Not run)
</code></pre>

<hr>
<h2 id='JSON'>The JSON serializer</h2><span id='topic+JSON'></span>

<h3>Description</h3>

<p>class with methods for serializing via <span class="pkg">jsonlite</span>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Serializer">vcr::Serializer</a></code> -&gt; <code>JSON</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-JSON-new"><code>JSON$new()</code></a>
</p>
</li>
<li> <p><a href="#method-JSON-serialize"><code>JSON$serialize()</code></a>
</p>
</li>
<li> <p><a href="#method-JSON-deserialize"><code>JSON$deserialize()</code></a>
</p>
</li>
<li> <p><a href="#method-JSON-clone"><code>JSON$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-JSON-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>JSON</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>JSON$new(path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) full path to the yaml file</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>JSON</code> object
</p>


<hr>
<a id="method-JSON-serialize"></a>



<h4>Method <code>serialize()</code></h4>

<p>Serializes the given hash using internal fxn write_json
</p>


<h5>Usage</h5>

<div class="r"><pre>JSON$serialize(x, path, bytes)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(list) the object to serialize</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) the file path</p>
</dd>
<dt><code>bytes</code></dt><dd><p>(logical) whether to preserve exact body bytes or not</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(character) the json string to write to disk
</p>


<hr>
<a id="method-JSON-deserialize"></a>



<h4>Method <code>deserialize()</code></h4>

<p>Deserializes the content at the file path using
jsonlite::fromJSON
</p>


<h5>Usage</h5>

<div class="r"><pre>JSON$deserialize(cassette)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cassette</code></dt><dd><p>the current cassette object so it's properties can
be retrieved</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(list) the deserialized object, an R list
</p>


<hr>
<a id="method-JSON-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>JSON$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='lightswitch'>Turn vcr on and off, check on/off status, and turn off for a given http call</h2><span id='topic+lightswitch'></span><span id='topic+turned_off'></span><span id='topic+turn_on'></span><span id='topic+turned_on'></span><span id='topic+turn_off'></span>

<h3>Description</h3>

<p>Turn vcr on and off, check on/off status, and turn off for a given http call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turned_off(..., ignore_cassettes = FALSE)

turn_on()

turned_on()

turn_off(ignore_cassettes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lightswitch_+3A_...">...</code></td>
<td>
<p>Any block of code to run, presumably an http request</p>
</td></tr>
<tr><td><code id="lightswitch_+3A_ignore_cassettes">ignore_cassettes</code></td>
<td>
<p>(logical) Controls what happens when a cassette is
inserted while vcr is turned off. If <code>TRUE</code> is passed, the cassette
insertion will be ignored; otherwise an error will be raised.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes you may need to turn off <code>vcr</code>, either for individual function
calls, individual test blocks, whole test files, or for the entire
package. The following attempts to break down all the options.
</p>
<p><code>vcr</code> has the following four exported functions:
</p>

<ul>
<li> <p><code>turned_off()</code> - Turns vcr off for the duration of a code block
</p>
</li>
<li> <p><code>turn_off()</code> - Turns vcr off completely, so that it no longer handles
every HTTP request
</p>
</li>
<li> <p><code>turn_on()</code> - turns vcr on; the opposite of <code>turn_off()</code>
</p>
</li>
<li> <p><code>turned_on()</code> - Asks if vcr is turned on, returns a boolean
</p>
</li></ul>

<p>Instead of using the above four functions, you could use environment
variables to achieve the same thing. This way you could enable/disable
<code>vcr</code> in non-interactive environments such as continuous integration,
Docker containers, or running R non-interactively from the command line.
The full set of environment variables <code>vcr</code> uses, all of which accept
only <code>TRUE</code> or <code>FALSE</code>:
</p>

<ul>
<li> <p><code>VCR_TURN_OFF</code>: turn off vcr altogether; set to <code>TRUE</code> to skip any vcr
usage; default: <code>FALSE</code>
</p>
</li>
<li> <p><code>VCR_TURNED_OFF</code>: set the <code>turned_off</code> internal package setting; this
does not turn off vcr completely as does <code>VCR_TURN_OFF</code> does, but
rather is looked at together with <code>VCR_IGNORE_CASSETTES</code>
</p>
</li>
<li> <p><code>VCR_IGNORE_CASSETTES</code>: set the <code>ignore_cassettes</code> internal package
setting; this is looked at together with <code>VCR_TURNED_OFF</code>
</p>
</li></ul>



<h4>turned_off</h4>

<p><code>turned_off()</code> lets you temporarily make a real HTTP request without
completely turning <code>vcr</code> off, unloading it, etc.
</p>
<p>What happens internally is we turn off <code>vcr</code>, run your code block, then
on exit turn <code>vcr</code> back on - such that <code>vcr</code> is only turned off for the
duration of your code block. Even if your code block errors, <code>vcr</code> will
be turned back on due to use of <code>on.exit(turn_on())</code>
</p>
<div class="sourceCode r"><pre>library(vcr)
library(crul)
turned_off({
  con &lt;- HttpClient$new(url = "https://httpbin.org/get")
  con$get()
})
</pre></div>
<div class="sourceCode r"><pre>#&gt; &lt;crul response&gt;
#&gt;   url: https://httpbin.org/get
#&gt;   request_headers:
#&gt;     User-Agent: libcurl/7.54.0 r-curl/4.3 crul/0.9.0
#&gt;     Accept-Encoding: gzip, deflate
#&gt;     Accept: application/json, text/xml, application/xml, */*
#&gt;   response_headers:
#&gt;     status: HTTP/1.1 200 OK
#&gt;     date: Fri, 14 Feb 2020 19:44:46 GMT
#&gt;     content-type: application/json
#&gt;     content-length: 365
#&gt;     connection: keep-alive
#&gt;     server: gunicorn/19.9.0
#&gt;     access-control-allow-origin: *
#&gt;     access-control-allow-credentials: true
#&gt;   status: 200
</pre></div>



<h4>turn_off/turn_on</h4>

<p><code>turn_off()</code> is different from <code>turned_off()</code> in that <code>turn_off()</code> is
not aimed at a single call block, but rather it turns <code>vcr</code> off for the
entire package. <code>turn_off()</code> does check first before turning <code>vcr</code> off
that there is not currently a cassette in use. <code>turn_off()</code> is meant to
make R ignore <code>vcr::insert_cassette()</code> and <code>vcr::use_cassette()</code> blocks
in your test suite - letting the code in the block run as if they were
not wrapped in <code>vcr</code> code - so that all you have to do to run your tests
with cached requests/responses AND with real HTTP requests is toggle a
single R function or environment variable.
</p>
<div class="sourceCode r"><pre>library(vcr)
vcr_configure(dir = tempdir())
# real HTTP request works - vcr is not engaged here
crul::HttpClient$new(url = "https://eu.httpbin.org/get")$get()
# wrap HTTP request in use_cassette() - vcr is engaged here
use_cassette("foo_bar", {
  crul::HttpClient$new(url = "https://eu.httpbin.org/get")$get()
})
# turn off &amp; ignore cassettes - use_cassette is ignored, real HTTP request made
turn_off(ignore_cassettes = TRUE)
use_cassette("foo_bar", {
  crul::HttpClient$new(url = "https://eu.httpbin.org/get")$get()
})
# if you turn off and don't ignore cassettes, error thrown
turn_off(ignore_cassettes = FALSE)
use_cassette("foo_bar", {
  res2=crul::HttpClient$new(url = "https://eu.httpbin.org/get")$get()
})
# vcr back on - now use_cassette behaves as before
turn_on()
use_cassette("foo_bar3", {
  res2=crul::HttpClient$new(url = "https://eu.httpbin.org/get")$get()
})
</pre></div>



<h4>turned_on</h4>

<p><code>turned_on()</code> does what it says on the tin - it tells you if <code>vcr</code> is
turned on or not.
</p>
<div class="sourceCode r"><pre>library(vcr)
turn_on()
turned_on()
</pre></div>
<div class="sourceCode"><pre>## [1] TRUE
</pre></div>
<div class="sourceCode r"><pre>turn_off()
</pre></div>
<div class="sourceCode"><pre>## vcr turned off; see ?turn_on to turn vcr back on
</pre></div>
<div class="sourceCode r"><pre>turned_on()
</pre></div>
<div class="sourceCode"><pre>## [1] FALSE
</pre></div>



<h4>Environment variables</h4>

<p>The <code>VCR_TURN_OFF</code> environment variable can be used within R or on the
command line to turn off <code>vcr</code>. For example, you can run tests for a
package that uses <code>vcr</code>, but ignore any <code>use_cassette</code>/<code>insert_cassette</code>
usage, by running this on the command line in the root of your package:
</p>
<div class="sourceCode"><pre>VCR_TURN_OFF=true Rscript -e "devtools::test()"
</pre></div>
<p>Or, similarly within R:
</p>
<div class="sourceCode r"><pre>Sys.setenv(VCR_TURN_OFF = TRUE)
devtools::test()
</pre></div>
<p>The <code>VCR_TURNED_OFF</code> and <code>VCR_IGNORE_CASSETTES</code> environment variables
can be used in combination to achieve the same thing as <code>VCR_TURN_OFF</code>:
</p>
<div class="sourceCode"><pre>VCR_TURNED_OFF=true VCR_IGNORE_CASSETTES=true Rscript -e "devtools::test()"
</pre></div>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(dir = tempdir())

turn_on()
turned_on()
turn_off()

# turn off for duration of a block
library(crul)
turned_off({
 res &lt;- HttpClient$new(url = "https://eu.httpbin.org/get")$get()
})
res

# turn completely off
turn_off()
library(webmockr)
crul::mock()
# HttpClient$new(url = "https://eu.httpbin.org/get")$get(verbose = TRUE)
turn_on()

## End(Not run)
</code></pre>

<hr>
<h2 id='Persisters'>Cassette persisters</h2><span id='topic+Persisters'></span><span id='topic+persister_fetch'></span>

<h3>Description</h3>

<p>Keeps track of the cassette persisters in a hash-like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persister_fetch(x = "FileSystem", file_name)
</code></pre>


<h3>Details</h3>

<p>There's only one option: <code>FileSystem</code>
<strong>Private Methods</strong>
</p>

<dl>
<dt><code>persister_get()</code></dt><dd>
<p>Gets and sets a named persister
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>persisters</code></dt><dd><p>(list) internal use, holds persister object</p>
</dd>
<dt><code>name</code></dt><dd><p>(character)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Persisters-new"><code>Persisters$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Persisters-clone"><code>Persisters$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Persisters-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Persisters</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Persisters$new(persisters = list(), name = "FileSystem")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>persisters</code></dt><dd><p>(list) a list</p>
</dd>
<dt><code>name</code></dt><dd><p>(character) Persister name, only option right now
is &quot;FileSystem&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Persisters</code> object
</p>


<hr>
<a id="method-Persisters-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Persisters$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>(aa &lt;- Persisters$new())
aa$name
aa$persisters
yaml_serializer &lt;- aa$persisters$new()
yaml_serializer
</code></pre>

<hr>
<h2 id='real_http_connections_allowed'>Are real http connections allowed?</h2><span id='topic+real_http_connections_allowed'></span>

<h3>Description</h3>

<p>Are real http connections allowed?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>real_http_connections_allowed()
</code></pre>


<h3>Value</h3>

<p>boolean, <code>TRUE</code> if real HTTP requests allowed; <code>FALSE</code> if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>real_http_connections_allowed()
</code></pre>

<hr>
<h2 id='recording'>vcr recording options</h2><span id='topic+recording'></span>

<h3>Description</h3>

<p>vcr recording options
</p>


<h3>Details</h3>

<p>Record modes dictate under what circumstances http requests/responses
are recorded to cassettes (disk). Set the recording mode with the
parameter <code>record</code> in the <code>use_cassette()</code> and <code>insert_cassette()</code>
functions.
</p>


<h4>once</h4>

<p>The <code>once</code> record mode will:
</p>

<ul>
<li><p> Replay previously recorded interactions.
</p>
</li>
<li><p> Record new interactions if there is no cassette file.
</p>
</li>
<li><p> Cause an error to be raised for new requests if there is a cassette
file.
</p>
</li></ul>

<p>It is similar to the <code>new_episodes</code> record mode, but will prevent new,
unexpected requests from being made (i.e.Â because the request URI
changed or whatever).
</p>
<p><code>once</code> is the default record mode, used when you do not set one.
</p>



<h4>none</h4>

<p>The <code>none</code> record mode will:
</p>

<ul>
<li><p> Replay previously recorded interactions.
</p>
</li>
<li><p> Cause an error to be raised for any new requests.
</p>
</li></ul>

<p>This is useful when your code makes potentially dangerous HTTP requests.
The <code>none</code> record mode guarantees that no new HTTP requests will be
made.
</p>



<h4>new_episodes</h4>

<p>The <code>new_episodes</code> record mode will:
</p>

<ul>
<li><p> Record new interactions.
</p>
</li>
<li><p> Replay previously recorded interactions.
</p>
</li></ul>

<p>It is similar to the <code>once</code> record mode, but will <strong>always</strong> record new
interactions, even if you have an existing recorded one that is similar
(but not identical, based on the <code>match_request_on</code> option).
</p>



<h4>all</h4>

<p>The <code>all</code> record mode will:
</p>

<ul>
<li><p> Record new interactions.
</p>
</li>
<li><p> Never replay previously recorded interactions.
</p>
</li></ul>

<p>This can be temporarily used to force vcr to re-record a cassette
(i.e.Â to ensure the responses are not out of date) or can be used when
you simply want to log all HTTP requests.
</p>


<hr>
<h2 id='Request'>The request of an HTTPInteraction</h2><span id='topic+Request'></span>

<h3>Description</h3>

<p>object that handled all aspects of a request
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>method</code></dt><dd><p>(character) http method</p>
</dd>
<dt><code>uri</code></dt><dd><p>(character) a uri</p>
</dd>
<dt><code>scheme</code></dt><dd><p>(character) scheme (http or https)</p>
</dd>
<dt><code>host</code></dt><dd><p>(character) host (e.g., stuff.org)</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) path (e.g., foo/bar)</p>
</dd>
<dt><code>query</code></dt><dd><p>(character) query params, named list</p>
</dd>
<dt><code>body</code></dt><dd><p>(character) named list</p>
</dd>
<dt><code>headers</code></dt><dd><p>(character) named list</p>
</dd>
<dt><code>skip_port_stripping</code></dt><dd><p>(logical) whether to strip thhe port</p>
</dd>
<dt><code>hash</code></dt><dd><p>(character) a named list - internal use</p>
</dd>
<dt><code>opts</code></dt><dd><p>(character) options - internal use</p>
</dd>
<dt><code>disk</code></dt><dd><p>(logical) xx</p>
</dd>
<dt><code>fields</code></dt><dd><p>(various) request body details</p>
</dd>
<dt><code>output</code></dt><dd><p>(various) request output details, disk, memory, etc</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Request-new"><code>Request$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-to_hash"><code>Request$to_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-from_hash"><code>Request$from_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-Request-clone"><code>Request$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Request-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Request</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$new(method, uri, body, headers, opts, disk, fields, output)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>(character) the HTTP method (i.e. head, options, get,
post, put, patch or delete)</p>
</dd>
<dt><code>uri</code></dt><dd><p>(character) request URI</p>
</dd>
<dt><code>body</code></dt><dd><p>(character) request body</p>
</dd>
<dt><code>headers</code></dt><dd><p>(named list) request headers</p>
</dd>
<dt><code>opts</code></dt><dd><p>(named list) options internal use</p>
</dd>
<dt><code>disk</code></dt><dd><p>(boolean), is body a file on disk</p>
</dd>
<dt><code>fields</code></dt><dd><p>(various) post fields</p>
</dd>
<dt><code>output</code></dt><dd><p>(various) output details</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Request</code> object
</p>


<hr>
<a id="method-Request-to_hash"></a>



<h4>Method <code>to_hash()</code></h4>

<p>Convert the request to a list
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$to_hash()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-Request-from_hash"></a>



<h4>Method <code>from_hash()</code></h4>

<p>Convert the request to a list
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$from_hash(hash)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hash</code></dt><dd><p>a list</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code>Request</code> object
</p>


<hr>
<a id="method-Request-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>url &lt;- "https://eu.httpbin.org/post"
body &lt;- list(foo = "bar")
headers &lt;- list(
  `User-Agent` = "libcurl/7.54.0 r-curl/3.2 crul/0.5.2",
  `Accept-Encoding` = "gzip, deflate",
  Accept = "application/json, text/xml, application/xml, */*"
)

(x &lt;- Request$new("POST", url, body, headers))
x$body
x$method
x$uri
x$host
x$path
x$headers
h &lt;- x$to_hash()
x$from_hash(h)
</code></pre>

<hr>
<h2 id='request_response'>request and response summary methods</h2><span id='topic+request_response'></span><span id='topic+request_summary'></span><span id='topic+response_summary'></span>

<h3>Description</h3>

<p>request and response summary methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request_summary(request, request_matchers = "")

response_summary(response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_response_+3A_request">request</code></td>
<td>
<p>a <a href="#topic+Request">Request</a> object</p>
</td></tr>
<tr><td><code id="request_response_+3A_request_matchers">request_matchers</code></td>
<td>
<p>(character) a vector of matchers.
Default: <code>""</code></p>
</td></tr>
<tr><td><code id="request_response_+3A_response">response</code></td>
<td>
<p>a <a href="#topic+VcrResponse">VcrResponse</a> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, method and uri are included
in the request summary - if body and/or headers are
specified in <code>request_matchers</code>, then they are also
included
</p>
<p>HTTP status code and response body are included in the
response summary. The response body is truncated to a
max of 80 characters
</p>
<p>In <code>response_summary()</code> we use <a href="base.html#topic+gsub">gsub</a> with <code>useBytes=TRUE</code> to avoid
problems sometimes seen with multibyte strings - this shouldn't affect
your data/etc. as this is only for printing a summary of the response
</p>


<h3>Value</h3>

<p>character string, of either request or response
</p>


<h3>Examples</h3>

<pre><code class='language-R'># request
url &lt;- "https://httpbin.org"
body &lt;- list(foo = "bar")
headers &lt;- list(
  `User-Agent` = "r-curl/3.2",
  `Accept-Encoding` = "gzip, deflate",
  Accept = "application/json"
)

(x &lt;- Request$new("POST", url, body, headers))
request_summary(request = x)
request_summary(request = x, c('method', 'uri'))
request_summary(request = x, c('method', 'uri', 'body'))
request_summary(request = x, c('method', 'uri', 'headers'))
request_summary(request = x, c('method', 'uri', 'body', 'headers'))

# response
status &lt;- list(status_code = 200, message = "OK",
  explanation = "Request fulfilled, document follows")
headers &lt;- list(
  status = "HTTP/1.1 200 OK",
  connection = "keep-alive",
  date = "Tue, 24 Apr 2018 04:46:56 GMT"
)
response_body &lt;- 
"{\"args\": {\"q\": \"stuff\"}, \"headers\": {\"Accept\": \"text/html\"}}\n"
(x &lt;- VcrResponse$new(status, headers,
   response_body, "HTTP/1.1 200 OK"))
response_summary(x)

## with binary body
# path &lt;- "tests/testthat/png_eg.rda"
# load(path)
# (x &lt;- VcrResponse$new(status, headers, png_eg, "HTTP/1.1 200 OK"))
# response_summary(x)
</code></pre>

<hr>
<h2 id='request-matching'>vcr request matching</h2><span id='topic+request-matching'></span>

<h3>Description</h3>

<p>There are a number of options, some of which are on by default, some of
which can be used together, and some alone.
</p>


<h3>Details</h3>

<p>To match previously recorded requests, <code>vcr</code> has to try to match new
HTTP requests to a previously recorded one. By default, we match on HTTP
method (e.g., <code>GET</code>) and URI (e.g., <code style="white-space: pre;">&#8288;http://foo.com&#8288;</code>), following Rubyâs
VCR gem.
</p>
<p>You can customize how we match requests with one or more of the
following options, some of which are on by default, some of which can be
used together, and some alone.
</p>

<ul>
<li> <p><code>method</code>: Use the <strong>method</strong> request matcher to match requests on the
HTTP method (i.e.Â GET, POST, PUT, DELETE, etc). You will generally
want to use this matcher. The <strong>method</strong> matcher is used (along with
the <strong>uri</strong> matcher) by default if you do not specify how requests
should match.
</p>
</li>
<li> <p><code>uri</code>: Use the <strong>uri</strong> request matcher to match requests on the
request URI. The <strong>uri</strong> matcher is used (along with the <strong>method</strong>
matcher) by default if you do not specify how requests should match.
</p>
</li>
<li> <p><code>host</code>: Use the <strong>host</strong> request matcher to match requests on the
request host. You can use this (alone, or in combination with
<strong>path</strong>) as an alternative to <strong>uri</strong> so that non-deterministic
portions of the URI are not considered as part of the request
matching.
</p>
</li>
<li> <p><code>path</code>: Use the <strong>path</strong> request matcher to match requests on the path
portion of the request URI. You can use this (alone, or in combination
with <strong>host</strong>) as an alternative to <strong>uri</strong> so that non-deterministic
portions of the URI
</p>
</li>
<li> <p><code>query</code>: Use the <strong>query</strong> request matcher to match requests on the
query string portion of the request URI. You can use this (alone, or
in combination with others) as an alternative to <strong>uri</strong> so that
non-deterministic portions of the URI are not considered as part of
the request matching.
</p>
</li>
<li> <p><code>body</code>: Use the <strong>body</strong> request matcher to match requests on the
request body.
</p>
</li>
<li> <p><code>headers</code>: Use the <strong>headers</strong> request matcher to match requests on
the request headers.
</p>
</li></ul>

<p>You can set your own options by tweaking the <code>match_requests_on</code>
parameter in <code>use_cassette()</code>:
</p>
<div class="sourceCode r"><pre>library(vcr)
</pre></div>
<div class="sourceCode r"><pre>use_cassette(name = "foo_bar", {
    cli$post("post", body = list(a = 5))
  }, 
  match_requests_on = c('method', 'headers', 'body')
)
</pre></div>


<h4>Matching</h4>



<h5>headers</h5>

<div class="sourceCode r"><pre>library(crul)
library(vcr)
cli &lt;- crul::HttpClient$new("https://httpbin.org/get", 
  headers = list(foo = "bar"))
use_cassette(name = "nothing_new", {
    one &lt;- cli$get()
  }, 
  match_requests_on = 'headers'
)
cli$headers$foo &lt;- "stuff"
use_cassette(name = "nothing_new", {
    two &lt;- cli$get()
  }, 
  match_requests_on = 'headers'
)
one$request_headers
two$request_headers
</pre></div>



<hr>
<h2 id='RequestHandler'>RequestHandler</h2><span id='topic+RequestHandler'></span>

<h3>Description</h3>

<p>Base handler for http requests, deciding whether a
request is stubbed, to be ignored, recordable, or unhandled
</p>


<h3>Details</h3>

<p><strong>Private Methods</strong>
</p>

<dl>
<dt><code>request_type(request)</code></dt><dd>
<p>Get the request type
</p>
</dd>
<dt><code>externally_stubbed()</code></dt><dd>
<p>just returns FALSE
</p>
</dd>
<dt><code>should_ignore()</code></dt><dd>
<p>should we ignore the request, depends on request ignorer
infrastructure that's not working yet
</p>
</dd>
<dt><code>has_response_stub()</code></dt><dd>
<p>Check if there is a matching response stub in the
http interaction list
</p>
</dd>
<dt><code>get_stubbed_response()</code></dt><dd>
<p>Check for a response and get it
</p>
</dd>
<dt><code>request_summary(request)</code></dt><dd>
<p>get a request summary
</p>
</dd>
<dt><code>on_externally_stubbed_request(request)</code></dt><dd>
<p>on externally stubbed request do nothing
</p>
</dd>
<dt><code>on_ignored_request(request)</code></dt><dd>
<p>on ignored request, do something
</p>
</dd>
<dt><code>on_recordable_request(request)</code></dt><dd>
<p>on recordable request, record the request
</p>
</dd>
<dt><code>on_unhandled_request(request)</code></dt><dd>
<p>on unhandled request, run UnhandledHTTPRequestError
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>request_original</code></dt><dd><p>original, before any modification</p>
</dd>
<dt><code>request</code></dt><dd><p>the request, after any modification</p>
</dd>
<dt><code>vcr_response</code></dt><dd><p>holds <a href="#topic+VcrResponse">VcrResponse</a> object</p>
</dd>
<dt><code>stubbed_response</code></dt><dd><p>the stubbed response</p>
</dd>
<dt><code>cassette</code></dt><dd><p>the cassette holder</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestHandler-new"><code>RequestHandler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestHandler-handle"><code>RequestHandler$handle()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestHandler-clone"><code>RequestHandler$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestHandler-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RequestHandler</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestHandler$new(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request from an object of class <code>HttpInteraction</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>RequestHandler</code> object
</p>


<hr>
<a id="method-RequestHandler-handle"></a>



<h4>Method <code>handle()</code></h4>

<p>Handle the request (<code>request</code> given in <code style="white-space: pre;">&#8288;$initialize()&#8288;</code>)
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestHandler$handle()</pre></div>



<h5>Returns</h5>

<p>handles a request, outcomes vary
</p>


<hr>
<a id="method-RequestHandler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestHandler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# record mode: once
vcr_configure(
 dir = tempdir(),
 record = "once"
)

data(crul_request)
crul_request$url$handle &lt;- curl::new_handle()
crul_request
x &lt;- RequestHandler$new(crul_request)
# x$handle()

# record mode: none
vcr_configure(
 dir = tempdir(),
 record = "none"
)
data(crul_request)
crul_request$url$handle &lt;- curl::new_handle()
crul_request
insert_cassette("testing_record_mode_none", record = "none")
#file.path(vcr_c$dir, "testing_record_mode_none.yml")
x &lt;- RequestHandlerCrul$new(crul_request)
# x$handle()
crul_request$url$url &lt;- "https://api.crossref.org/works/10.1039/c8sm90002g/"
crul_request$url$handle &lt;- curl::new_handle()
z &lt;- RequestHandlerCrul$new(crul_request)
# z$handle()
eject_cassette("testing_record_mode_none")

## End(Not run)
</code></pre>

<hr>
<h2 id='RequestHandlerCrul'>RequestHandlerCrul</h2><span id='topic+RequestHandlerCrul'></span>

<h3>Description</h3>

<p>Methods for the crul package, building on <a href="#topic+RequestHandler">RequestHandler</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+RequestHandler">vcr::RequestHandler</a></code> -&gt; <code>RequestHandlerCrul</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestHandlerCrul-clone"><code>RequestHandlerCrul$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vcr" data-topic="RequestHandler" data-id="handle"><a href='../../vcr/html/RequestHandler.html#method-RequestHandler-handle'><code>vcr::RequestHandler$handle()</code></a></span></li>
<li><span class="pkg-link" data-pkg="vcr" data-topic="RequestHandler" data-id="initialize"><a href='../../vcr/html/RequestHandler.html#method-RequestHandler-initialize'><code>vcr::RequestHandler$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RequestHandlerCrul-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestHandlerCrul$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(
 dir = tempdir(),
 record = "once"
)

data(crul_request)
crul_request$url$handle &lt;- curl::new_handle()
crul_request
x &lt;- RequestHandlerCrul$new(crul_request)
# x$handle()

# body matching
library(vcr)
library(crul)
vcr_configure(dir = tempdir(), log = TRUE,
 log_opts = list(file = file.path(tempdir(), "vcr.log")))
cli &lt;- HttpClient$new(url = "https://httpbin.org")

## testing, same uri and method, changed body in 2nd block
use_cassette(name = "apple7", {
  resp &lt;- cli$post("post", body = list(foo = "bar"))
}, match_requests_on = c("method", "uri", "body"))
## should error, b/c record="once"
if (interactive()) {
  use_cassette(name = "apple7", {
    resp &lt;- cli$post("post", body = list(foo = "bar"))
    resp2 &lt;- cli$post("post", body = list(hello = "world"))
  }, match_requests_on = c("method", "uri", "body"))
}
cas &lt;- insert_cassette(name = "apple7", 
  match_requests_on = c("method", "uri", "body"))
resp2 &lt;- cli$post("post", body = list(foo = "bar"))
eject_cassette("apple7")

## testing, same body, changed method in 2nd block
if (interactive()) {
use_cassette(name = "apple8", {
  x &lt;- cli$post("post", body = list(hello = "world"))
}, match_requests_on = c("method", "body"))
use_cassette(name = "apple8", {
  x &lt;- cli$get("post", body = list(hello = "world"))
}, match_requests_on = c("method", "body"))
}

## testing, same body, changed uri in 2nd block
# use_cassette(name = "apple9", {
#   x &lt;- cli$post("post", body = list(hello = "world"))
#   w &lt;- cli$post("get", body = list(hello = "world"))
# }, match_requests_on = c("method", "body"))
# use_cassette(name = "apple9", {
#   NOTHING HERE
# }, match_requests_on = c("method", "body"))
# unlink(file.path(vcr_configuration()$dir, "apple9.yml"))

## End(Not run)
</code></pre>

<hr>
<h2 id='RequestHandlerHttr'>RequestHandlerHttr</h2><span id='topic+RequestHandlerHttr'></span>

<h3>Description</h3>

<p>Methods for the httr package, building on <a href="#topic+RequestHandler">RequestHandler</a>
</p>


<h3>Super class</h3>

<p><code><a href="#topic+RequestHandler">vcr::RequestHandler</a></code> -&gt; <code>RequestHandlerHttr</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestHandlerHttr-new"><code>RequestHandlerHttr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestHandlerHttr-clone"><code>RequestHandlerHttr$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="vcr" data-topic="RequestHandler" data-id="handle"><a href='../../vcr/html/RequestHandler.html#method-RequestHandler-handle'><code>vcr::RequestHandler$handle()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RequestHandlerHttr-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RequestHandlerHttr</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestHandlerHttr$new(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>The request from an object of class <code>HttpInteraction</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>RequestHandlerHttr</code> object
</p>


<hr>
<a id="method-RequestHandlerHttr-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestHandlerHttr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(
 dir = tempdir(),
 record = "once"
)

# GET request
library(httr)
load("~/httr_req.rda")
req
x &lt;- RequestHandlerHttr$new(req)
# x$handle()

# POST request
library(httr)
webmockr::httr_mock()
mydir &lt;- file.path(tempdir(), "testing_httr")
invisible(vcr_configure(dir = mydir))
use_cassette(name = "testing2", {
  res &lt;- POST("https://httpbin.org/post", body = list(foo = "bar"))
}, match_requests_on = c("method", "uri", "body"))

load("~/httr_req_post.rda")
insert_cassette("testing3")
httr_req_post
x &lt;- RequestHandlerHttr$new(httr_req_post)
x
# x$handle()
self=x


## End(Not run)
</code></pre>

<hr>
<h2 id='RequestIgnorer'>Request ignorer</h2><span id='topic+RequestIgnorer'></span>

<h3>Description</h3>

<p>request ignorer methods
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>LOCALHOST_ALIASES</code></dt><dd><p>A constant with values: 'localhost', '127.0.0.1',
and '0.0.0.0'</p>
</dd>
<dt><code>ignored_hosts</code></dt><dd><p>vector of ignored host URI's</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestIgnorer-new"><code>RequestIgnorer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestIgnorer-ignore_request"><code>RequestIgnorer$ignore_request()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestIgnorer-ignore_localhost"><code>RequestIgnorer$ignore_localhost()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestIgnorer-ignore_localhost_value"><code>RequestIgnorer$ignore_localhost_value()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestIgnorer-ignore_hosts"><code>RequestIgnorer$ignore_hosts()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestIgnorer-should_be_ignored"><code>RequestIgnorer$should_be_ignored()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestIgnorer-clone"><code>RequestIgnorer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestIgnorer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RequestIgnorer</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$new()</pre></div>



<h5>Returns</h5>

<p>A new <code>RequestIgnorer</code> object
</p>


<hr>
<a id="method-RequestIgnorer-ignore_request"></a>



<h4>Method <code>ignore_request()</code></h4>

<p>Will ignore any request for which the given function
returns <code>TRUE</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$ignore_request()</pre></div>



<h5>Returns</h5>

<p>no return; defines request ignorer hook
</p>


<hr>
<a id="method-RequestIgnorer-ignore_localhost"></a>



<h4>Method <code>ignore_localhost()</code></h4>

<p>ignore all localhost values (localhost, 127.0.0.1, 0.0.0.0)
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$ignore_localhost()</pre></div>



<h5>Returns</h5>

<p>no return; sets to ignore all localhost aliases
</p>


<hr>
<a id="method-RequestIgnorer-ignore_localhost_value"></a>



<h4>Method <code>ignore_localhost_value()</code></h4>

<p>ignore a specific named localhost
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$ignore_localhost_value(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>(character) A localhost value to ignore, e.g., 'localhost'</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; defines request ignorer hook
</p>


<hr>
<a id="method-RequestIgnorer-ignore_hosts"></a>



<h4>Method <code>ignore_hosts()</code></h4>

<p>ignore any named host
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$ignore_hosts(hosts)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hosts</code></dt><dd><p>(character) vector of hosts to ignore</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; adds host to ignore
</p>


<hr>
<a id="method-RequestIgnorer-should_be_ignored"></a>



<h4>Method <code>should_be_ignored()</code></h4>

<p>method to determine whether to ignore a request
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$should_be_ignored(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>request to ignore</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; defines request ignorer hook
</p>


<hr>
<a id="method-RequestIgnorer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestIgnorer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='RequestMatcherRegistry'>RequestMatcherRegistry</h2><span id='topic+RequestMatcherRegistry'></span>

<h3>Description</h3>

<p>handles request matchers
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>registry</code></dt><dd><p>initialze registry list with a request, or leave empty</p>
</dd>
<dt><code>default_matchers</code></dt><dd><p>request matchers to use. default: method, uri</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestMatcherRegistry-new"><code>RequestMatcherRegistry$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestMatcherRegistry-register"><code>RequestMatcherRegistry$register()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestMatcherRegistry-register_built_ins"><code>RequestMatcherRegistry$register_built_ins()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestMatcherRegistry-try_to_register_body_as_json"><code>RequestMatcherRegistry$try_to_register_body_as_json()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestMatcherRegistry-clone"><code>RequestMatcherRegistry$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestMatcherRegistry-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new RequestMatcherRegistry object
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestMatcherRegistry$new(
  registry = list(),
  default_matchers = list("method", "uri")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>registry</code></dt><dd><p>initialze registry list with a request, or leave empty</p>
</dd>
<dt><code>default_matchers</code></dt><dd><p>request matchers to use. default: method, uri</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>RequestMatcherRegistry</code> object
</p>


<hr>
<a id="method-RequestMatcherRegistry-register"></a>



<h4>Method <code>register()</code></h4>

<p>Register a custom matcher
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestMatcherRegistry$register(name, func)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>matcher name</p>
</dd>
<dt><code>func</code></dt><dd><p>function that describes a matcher, should return
a single boolean</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; registers the matcher
</p>


<hr>
<a id="method-RequestMatcherRegistry-register_built_ins"></a>



<h4>Method <code>register_built_ins()</code></h4>

<p>Register all built in matchers
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestMatcherRegistry$register_built_ins()</pre></div>



<h5>Returns</h5>

<p>no return; registers all built in matchers
</p>


<hr>
<a id="method-RequestMatcherRegistry-try_to_register_body_as_json"></a>



<h4>Method <code>try_to_register_body_as_json()</code></h4>

<p>Try to register body as JSON
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestMatcherRegistry$try_to_register_body_as_json(r1, r2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>r1, r2</code></dt><dd><p><a href="#topic+Request">Request</a> class objects</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; registers the matcher
</p>


<hr>
<a id="method-RequestMatcherRegistry-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestMatcherRegistry$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>r1=from new request; r2=from recorded interaction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- RequestMatcherRegistry$new())
x$default_matchers
x$registry

## End(Not run)
</code></pre>

<hr>
<h2 id='Serializer'>Serializer class - base class for JSON/YAML serializers</h2><span id='topic+Serializer'></span>

<h3>Description</h3>

<p>Serializer class - base class for JSON/YAML serializers
</p>
<p>Serializer class - base class for JSON/YAML serializers
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>file_extension</code></dt><dd><p>(character) A file extension</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) full path to the yaml file</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Serializer-new"><code>Serializer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Serializer-serialize"><code>Serializer$serialize()</code></a>
</p>
</li>
<li> <p><a href="#method-Serializer-deserialize"><code>Serializer$deserialize()</code></a>
</p>
</li>
<li> <p><a href="#method-Serializer-clone"><code>Serializer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Serializer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new YAML object
</p>


<h5>Usage</h5>

<div class="r"><pre>Serializer$new(file_extension = NULL, path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file_extension</code></dt><dd><p>(character) A file extension</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) path to the cassette, excluding the cassette
directory and the file extension</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>YAML</code> object
</p>


<hr>
<a id="method-Serializer-serialize"></a>



<h4>Method <code>serialize()</code></h4>

<p>Serializes a hash - REPLACED BY YAML/JSON METHODS
</p>


<h5>Usage</h5>

<div class="r"><pre>Serializer$serialize(x, path, bytes)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(list) the object to serialize</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) the file path</p>
</dd>
<dt><code>bytes</code></dt><dd><p>(logical) whether to preserve exact body bytes or not</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(character) the YAML or JSON string to write to disk
</p>


<hr>
<a id="method-Serializer-deserialize"></a>



<h4>Method <code>deserialize()</code></h4>

<p>Serializes a file - REPLACED BY YAML/JSON METHODS
</p>


<h5>Usage</h5>

<div class="r"><pre>Serializer$deserialize()</pre></div>


<hr>
<a id="method-Serializer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Serializer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Serializers'>Cassette serializers</h2><span id='topic+Serializers'></span><span id='topic+serializer_fetch'></span>

<h3>Description</h3>

<p>Keeps track of the cassette serializers in a hash-like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serializer_fetch(x = "yaml", name)
</code></pre>


<h3>Details</h3>

<p><strong>Private Methods</strong>
</p>

<dl>
<dt><code>serialize_get()</code></dt><dd>
<p>Gets a named serializer. This is also run on <code>Serializers$new()</code>
</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>serializers</code></dt><dd><p>(list) list of serializer names</p>
</dd>
<dt><code>name</code></dt><dd><p>(character) Name of a serializer. &quot;yaml&quot; (default) or &quot;json&quot;</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Serializers-new"><code>Serializers$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Serializers-clone"><code>Serializers$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Serializers-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Serializers object
</p>


<h5>Usage</h5>

<div class="r"><pre>Serializers$new(serializers = list(), name = "yaml")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>serializers</code></dt><dd><p>(list) list of serializer names</p>
</dd>
<dt><code>name</code></dt><dd><p>(character) Name of a serializer. &quot;yaml&quot; (default) or &quot;json&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Serializers</code> object
</p>


<hr>
<a id="method-Serializers-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Serializers$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(aa &lt;- Serializers$new())
aa$name
aa$serializers
yaml_serializer &lt;- aa$serializers$new()
yaml_serializer

x &lt;- Serializers$new(name = "json")
x$serializers$new()
json_serializer &lt;- x$serializers$new()
json_serializer

## End(Not run)
</code></pre>

<hr>
<h2 id='skip_if_vcr_off'>Skip tests if vcr is off</h2><span id='topic+skip_if_vcr_off'></span>

<h3>Description</h3>

<p>Custom testthat skipper to skip tests if vcr is turned off via the
environment variable <code>VCR_TURN_OFF</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_if_vcr_off()
</code></pre>


<h3>Details</h3>

<p>This might be useful if your test will fail with real requests:
when the cassette was e.g. edited (a real request produced a 200 status code
but you made it a 502 status code for testing the behavior of your code
when the API errors)
or if the tests are very specific (e.g. testing a date was correctly parsed,
but making a real request would produce a different date).
</p>


<h3>Value</h3>

<p>Nothing, skip test.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+turn_off">turn_off()</a></code>
</p>

<hr>
<h2 id='str_splitter'>split string every N characters</h2><span id='topic+str_splitter'></span>

<h3>Description</h3>

<p>split string every N characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_splitter(str, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_splitter_+3A_str">str</code></td>
<td>
<p>(character) a string</p>
</td></tr>
<tr><td><code id="str_splitter_+3A_length">length</code></td>
<td>
<p>(integer) number of characters to split by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
str = "XOVEWVJIEWNIGOIWENVOIWEWVWEW"
str_splitter(str, 5)
str_splitter(str, 5L)

## End(Not run)
</code></pre>

<hr>
<h2 id='UnhandledHTTPRequestError'>UnhandledHTTPRequestError</h2><span id='topic+UnhandledHTTPRequestError'></span><span id='topic+vcr_last_error'></span>

<h3>Description</h3>

<p>Handle http request errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcr_last_error()
</code></pre>


<h3>Details</h3>

<p>How this error class is used:
If <code>record="once"</code> we trigger this.
</p>
<p>Users can use vcr in the context of both <code><a href="#topic+use_cassette">use_cassette()</a></code>
and <code><a href="#topic+insert_cassette">insert_cassette()</a></code>
</p>
<p>For the former, all requests go through the call_block
But for the latter, requests go through webmockr.
</p>
<p>Where is one place where we can put UnhandledHTTPRequestError
that will handle both use_cassette and insert_cassette?
</p>


<h3>Error situations where this is invoked</h3>


<ul>
<li> <p><code>record=once</code> AND there's a new request that doesn't match
the one in the cassette on disk
</p>

<ul>
<li><p> in webmockr: if no stub found and there are recorded
interactions on the cassette, and record = once, then
error with UnhandledHTTPRequestError
</p>

<ul>
<li><p> but if record != once, then allow it, unless record == none
</p>
</li></ul>

</li></ul>

</li>
<li><p> others?
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>request</code></dt><dd><p>a <a href="#topic+Request">Request</a> object</p>
</dd>
<dt><code>cassette</code></dt><dd><p>a cassette name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-UnhandledHTTPRequestError-new"><code>UnhandledHTTPRequestError$new()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-run"><code>UnhandledHTTPRequestError$run()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-construct_message"><code>UnhandledHTTPRequestError$construct_message()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-request_description"><code>UnhandledHTTPRequestError$request_description()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-current_matchers"><code>UnhandledHTTPRequestError$current_matchers()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-match_request_on_headers"><code>UnhandledHTTPRequestError$match_request_on_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-match_request_on_body"><code>UnhandledHTTPRequestError$match_request_on_body()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-formatted_headers"><code>UnhandledHTTPRequestError$formatted_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-cassettes_description"><code>UnhandledHTTPRequestError$cassettes_description()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-cassettes_list"><code>UnhandledHTTPRequestError$cassettes_list()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-get_help"><code>UnhandledHTTPRequestError$get_help()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-formatted_suggestions"><code>UnhandledHTTPRequestError$formatted_suggestions()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-format_bullet_point"><code>UnhandledHTTPRequestError$format_bullet_point()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-format_foot_note"><code>UnhandledHTTPRequestError$format_foot_note()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-suggestion_for"><code>UnhandledHTTPRequestError$suggestion_for()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-suggestions"><code>UnhandledHTTPRequestError$suggestions()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-no_cassette_suggestions"><code>UnhandledHTTPRequestError$no_cassette_suggestions()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-record_mode_suggestion"><code>UnhandledHTTPRequestError$record_mode_suggestion()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-has_used_interaction_matching"><code>UnhandledHTTPRequestError$has_used_interaction_matching()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-match_requests_on_suggestion"><code>UnhandledHTTPRequestError$match_requests_on_suggestion()</code></a>
</p>
</li>
<li> <p><a href="#method-UnhandledHTTPRequestError-clone"><code>UnhandledHTTPRequestError$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-UnhandledHTTPRequestError-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>UnhandledHTTPRequestError</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$new(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>(Request) a <a href="#topic+Request">Request</a> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>UnhandledHTTPRequestError</code> object
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-run"></a>



<h4>Method <code>run()</code></h4>

<p>Run unhandled request handling
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$run()</pre></div>



<h5>Returns</h5>

<p>various
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-construct_message"></a>



<h4>Method <code>construct_message()</code></h4>

<p>Construct and execute stop message for why request failed
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$construct_message()</pre></div>



<h5>Returns</h5>

<p>a stop message
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-request_description"></a>



<h4>Method <code>request_description()</code></h4>

<p>construct request description
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$request_description()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-current_matchers"></a>



<h4>Method <code>current_matchers()</code></h4>

<p>get current request matchers
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$current_matchers()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-match_request_on_headers"></a>



<h4>Method <code>match_request_on_headers()</code></h4>

<p>are headers included in current matchers?
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$match_request_on_headers()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-match_request_on_body"></a>



<h4>Method <code>match_request_on_body()</code></h4>

<p>is body includled in current matchers?
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$match_request_on_body()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-formatted_headers"></a>



<h4>Method <code>formatted_headers()</code></h4>

<p>get request headers
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$formatted_headers()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-cassettes_description"></a>



<h4>Method <code>cassettes_description()</code></h4>

<p>construct description of current or lack thereof cassettes
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$cassettes_description()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-cassettes_list"></a>



<h4>Method <code>cassettes_list()</code></h4>

<p>cassette details
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$cassettes_list()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-get_help"></a>



<h4>Method <code>get_help()</code></h4>

<p>get help message for non-verbose error
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$get_help()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-formatted_suggestions"></a>



<h4>Method <code>formatted_suggestions()</code></h4>

<p>make suggestions for what to do
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$formatted_suggestions()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-format_bullet_point"></a>



<h4>Method <code>format_bullet_point()</code></h4>

<p>add bullet point to beginning of a line
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$format_bullet_point(lines, index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lines</code></dt><dd><p>(character) vector of strings</p>
</dd>
<dt><code>index</code></dt><dd><p>(integer) a number</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-format_foot_note"></a>



<h4>Method <code>format_foot_note()</code></h4>

<p>make a foot note
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$format_foot_note(url, index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>(character) a url</p>
</dd>
<dt><code>index</code></dt><dd><p>(integer) a number</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-suggestion_for"></a>



<h4>Method <code>suggestion_for()</code></h4>

<p>get a suggestion by key
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$suggestion_for(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(character) a character string</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-suggestions"></a>



<h4>Method <code>suggestions()</code></h4>

<p>get all suggestions
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$suggestions()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-no_cassette_suggestions"></a>



<h4>Method <code>no_cassette_suggestions()</code></h4>

<p>get all no cassette suggestions
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$no_cassette_suggestions()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-record_mode_suggestion"></a>



<h4>Method <code>record_mode_suggestion()</code></h4>

<p>get the appropriate record mode suggestion
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$record_mode_suggestion()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-has_used_interaction_matching"></a>



<h4>Method <code>has_used_interaction_matching()</code></h4>

<p>are there any used interactions
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$has_used_interaction_matching()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-match_requests_on_suggestion"></a>



<h4>Method <code>match_requests_on_suggestion()</code></h4>

<p>match requests on suggestion
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$match_requests_on_suggestion()</pre></div>



<h5>Returns</h5>

<p>list
</p>


<hr>
<a id="method-UnhandledHTTPRequestError-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>UnhandledHTTPRequestError$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>vcr_configure(dir = tempdir())
cassettes()
insert_cassette("turtle")
request &lt;- Request$new("post", 'https://eu.httpbin.org/post?a=5',
  "", list(foo = "bar"))

err &lt;- UnhandledHTTPRequestError$new(request)
err$request_description()
err$current_matchers()
err$match_request_on_headers()
err$match_request_on_body()
err$formatted_headers()
cat(err$formatted_headers(), "\n")
cat(err$cassettes_description(), "\n")
cat(err$cassettes_list(), "\n")
err$formatted_suggestions()
cat(err$format_bullet_point('foo bar', 1), "\n")
err$suggestion_for("use_new_episodes")
err$suggestions()
err$no_cassette_suggestions()
err$record_mode_suggestion()
err$has_used_interaction_matching()
err$match_requests_on_suggestion()

# err$construct_message()

# cleanup
eject_cassette("turtle")
unlink(tempdir())
## Not run: 
# vcr_last_error()

## End(Not run)
</code></pre>

<hr>
<h2 id='use_cassette'>Use a cassette to record HTTP requests</h2><span id='topic+use_cassette'></span>

<h3>Description</h3>

<p>Use a cassette to record HTTP requests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_cassette(
  name,
  ...,
  record = NULL,
  match_requests_on = NULL,
  update_content_length_header = FALSE,
  allow_playback_repeats = FALSE,
  serialize_with = NULL,
  persist_with = NULL,
  preserve_exact_body_bytes = NULL,
  re_record_interval = NULL,
  clean_outdated_http_interactions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_cassette_+3A_name">name</code></td>
<td>
<p>The name of the cassette. vcr will check this to ensure it
is a valid file name. Not allowed: spaces, file extensions, control
characters (e.g., <code style="white-space: pre;">&#8288;\n&#8288;</code>), illegal characters ('/', '?', '&lt;', '&gt;', '\', ':',
'*', '|', and '\&quot;'), dots alone (e.g., '.', '..'), Windows reserved
words (e.g., 'com1'), trailing dots (can cause problems on Windows),
names longer than 255 characters. See section &quot;Cassette names&quot;</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_...">...</code></td>
<td>
<p>a block of code containing one or more requests (required). Use
curly braces to encapsulate multi-line code blocks. If you can't pass a code
block use <code><a href="#topic+insert_cassette">insert_cassette()</a></code> instead.</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_record">record</code></td>
<td>
<p>The record mode (default: <code>"once"</code>). See <a href="#topic+recording">recording</a> for a
complete list of the different recording modes.</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_match_requests_on">match_requests_on</code></td>
<td>
<p>List of request matchers
to use to determine what recorded HTTP interaction to replay. Defaults to
<code style="white-space: pre;">&#8288;["method", "uri"]&#8288;</code>. The built-in matchers are &quot;method&quot;, &quot;uri&quot;, &quot;host&quot;,
&quot;path&quot;, &quot;headers&quot;, &quot;body&quot; and &quot;query&quot;</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_update_content_length_header">update_content_length_header</code></td>
<td>
<p>(logical) Whether or
not to overwrite the <code>Content-Length</code> header of the responses to
match the length of the response body. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="use_cassette_+3A_allow_playback_repeats">allow_playback_repeats</code></td>
<td>
<p>(logical) Whether or not to
allow a single HTTP interaction to be played back multiple times.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_serialize_with">serialize_with</code></td>
<td>
<p>(character) Which serializer to use.
Valid values are &quot;yaml&quot; (default) and &quot;json&quot;. Note that you can have
multiple cassettes with the same name as long as they use different
serializers; so if you only want one cassette for a given cassette name,
make sure to not switch serializers, or clean up files you no longer need.</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_persist_with">persist_with</code></td>
<td>
<p>(character) Which cassette persister to
use. Default: &quot;file_system&quot;. You can also register and use a
custom persister.</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_preserve_exact_body_bytes">preserve_exact_body_bytes</code></td>
<td>
<p>(logical) Whether or not
to base64 encode the bytes of the requests and responses for
this cassette when serializing it. See also <code>preserve_exact_body_bytes</code>
in <code><a href="#topic+vcr_configure">vcr_configure()</a></code>. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="use_cassette_+3A_re_record_interval">re_record_interval</code></td>
<td>
<p>(integer) How frequently (in seconds) the
cassette should be re-recorded. default: <code>NULL</code> (not re-recorded)</p>
</td></tr>
<tr><td><code id="use_cassette_+3A_clean_outdated_http_interactions">clean_outdated_http_interactions</code></td>
<td>
<p>(logical) Should outdated
interactions be recorded back to file? default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A run down of the family of top level <span class="pkg">vcr</span> functions
</p>

<ul>
<li> <p><code>use_cassette</code> Initializes a cassette. Returns the inserted
cassette.
</p>
</li>
<li> <p><code>insert_cassette</code> Internally used within <code>use_cassette</code>
</p>
</li>
<li> <p><code>eject_cassette</code> ejects the current cassette. The cassette
will no longer be used. In addition, any newly recorded HTTP interactions
will be written to disk.
</p>
</li></ul>



<h3>Value</h3>

<p>an object of class <code>Cassette</code>
</p>


<h3>Cassette options</h3>

<p>Default values for arguments controlling cassette behavior are
inherited from vcr's global configuration. See <code><a href="#topic+vcr_configure">vcr_configure()</a></code> for a
complete list of options and their default settings. You can override these
options for a specific cassette by changing an argument's value to something
other than <code>NULL</code> when calling either <code>insert_cassette()</code> or
<code>use_cassette()</code>.
</p>


<h3>Behavior</h3>

<p>This function handles a few different scenarios:
</p>

<ul>
<li><p> when everything runs smoothly, and we return a <code>Cassette</code> class object
so you can inspect the cassette, and the cassette is ejected
</p>
</li>
<li><p> when there is an invalid parameter input on cassette creation,
we fail with a useful message, we don't return a cassette, and the
cassette is ejected
</p>
</li>
<li><p> when there is an error in calling your passed in code block,
we return with a useful message, and since we use <code>on.exit()</code>
the cassette is still ejected even though there was an error,
but you don't get an object back
</p>
</li>
<li><p> whenever an empty cassette (a yml/json file) is found, we delete it
before returning from the <code>use_cassette()</code> function call. we achieve
this via use of <code>on.exit()</code> so an empty cassette is deleted even
if there was an error in the code block you passed in
</p>
</li></ul>



<h3>Cassettes on disk</h3>

<p>Note that <em>&quot;eject&quot;</em> only means that the R session cassette is no longer
in use. If any interactions were recorded to disk, then there is a file
on disk with those interactions.
</p>


<h3>Using with tests (specifically <span class="pkg">testthat</span>)</h3>

<p>There's a few ways to get correct line numbers for failed tests and
one way to not get correct line numbers:
</p>
<p><em>Correct</em>: Either wrap your <code>test_that()</code> block inside your <code>use_cassette()</code>
block, OR if you put your <code>use_cassette()</code> block inside your <code>test_that()</code>
block put your <code>testthat</code> expectations outside of the <code>use_cassette()</code>
block.
</p>
<p><em>Incorrect</em>: By wrapping the <code>use_cassette()</code> block inside your
<code>test_that()</code> block with your <span class="pkg">testthat</span> expectations inside the
<code>use_cassette()</code> block, you'll only get the line number that the
<code>use_cassette()</code> block starts on.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insert_cassette">insert_cassette()</a></code>, <code><a href="#topic+eject_cassette">eject_cassette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(vcr)
library(crul)
vcr_configure(dir = tempdir())

use_cassette(name = "apple7", {
  cli &lt;- HttpClient$new(url = "https://httpbin.org")
  resp &lt;- cli$get("get")
})
readLines(file.path(tempdir(), "apple7.yml"))

# preserve exact body bytes - records in base64 encoding
use_cassette("things4", {
  cli &lt;- crul::HttpClient$new(url = "https://httpbin.org")
  bbb &lt;- cli$get("get")
}, preserve_exact_body_bytes = TRUE)
## see the body string value in the output here
readLines(file.path(tempdir(), "things4.yml"))

# cleanup
unlink(file.path(tempdir(), c("things4.yml", "apple7.yml")))


# with httr
library(vcr)
library(httr)
vcr_configure(dir = tempdir(), log = TRUE, log_opts = list(file = file.path(tempdir(), "vcr.log")))

use_cassette(name = "stuff350", {
  res &lt;- GET("https://httpbin.org/get")
})
readLines(file.path(tempdir(), "stuff350.yml"))

use_cassette(name = "catfact456", {
  res &lt;- GET("https://catfact.ninja/fact")
})

# record mode: none
library(crul)
vcr_configure(dir = tempdir())

## make a connection first
conn &lt;- crul::HttpClient$new("https://eu.httpbin.org")
## this errors because 'none' disallows any new requests
# use_cassette("none_eg", (res2 &lt;- conn$get("get")), record = "none")
## first use record mode 'once' to record to a cassette
one &lt;- use_cassette("none_eg", (res &lt;- conn$get("get")), record = "once")
one; res
## then use record mode 'none' to see it's behavior
two &lt;- use_cassette("none_eg", (res2 &lt;- conn$get("get")), record = "none")
two; res2

## End(Not run)
</code></pre>

<hr>
<h2 id='use_vcr'>Setup vcr for a package</h2><span id='topic+use_vcr'></span>

<h3>Description</h3>

<p>Setup vcr for a package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_vcr(dir = ".", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_vcr_+3A_dir">dir</code></td>
<td>
<p>(character) path to package root. default's to
current directory</p>
</td></tr>
<tr><td><code id="use_vcr_+3A_verbose">verbose</code></td>
<td>
<p>(logical) print progress messages. default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets a mimimum vcr version, which is usually the latest
(stable) version on CRAN. You can of course easily remove or change
the version requirement yourself after running this function.
</p>


<h3>Value</h3>

<p>only messages about progress, returns invisible()
</p>

<hr>
<h2 id='vcr_configure'>Global Configuration Options</h2><span id='topic+vcr_configure'></span><span id='topic+vcr_configure_reset'></span><span id='topic+vcr_configuration'></span><span id='topic+vcr_config_defaults'></span>

<h3>Description</h3>

<p>Configurable options that define vcr's default behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcr_configure(...)

vcr_configure_reset()

vcr_configuration()

vcr_config_defaults()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcr_configure_+3A_...">...</code></td>
<td>
<p>configuration settings used to override defaults. See below for a
complete list of valid arguments.</p>
</td></tr>
</table>


<h3>Configurable settings</h3>



<h4>vcr options</h4>



<h5>File locations</h5>


<ul>
<li> <p><code>dir</code> Cassette directory
</p>
</li>
<li> <p><code>write_disk_path</code> (character) path to write files to
for any requests that write responses to disk. by default this parameter
is <code>NULL</code>. For testing a package, you'll probably want this path to
be in your <code style="white-space: pre;">&#8288;tests/&#8288;</code> directory, perhaps next to your cassettes
directory, e.g., where your cassettes are in <code>tests/fixtures</code>, your
files from requests that write to disk are in <code>tests/files</code>.
If you want to ignore these files in your installed package,
add them to <code>.Rinstignore</code>. If you want these files ignored on build
then add them to <code>.Rbuildignore</code> (though if you do, tests that depend
on these files probably will not work because they won't be found; so
you'll likely have to skip the associated tests as well).
</p>
</li></ul>




<h5>Contexts</h5>


<ul>
<li> <p><code>turned_off</code> (logical) VCR is turned on by default. Default:
<code>FALSE</code>
</p>
</li>
<li> <p><code>allow_unused_http_interactions</code> (logical) Default: <code>TRUE</code>
</p>
</li>
<li> <p><code>allow_http_connections_when_no_cassette</code> (logical) Determines how vcr
treats HTTP requests that are made when no vcr cassette is in use. When
<code>TRUE</code>, requests made when there is no vcr cassette in use will be allowed.
When <code>FALSE</code> (default), an <a href="#topic+UnhandledHTTPRequestError">UnhandledHTTPRequestError</a> error will be raised
for any HTTP request made when there is no cassette in use
</p>
</li></ul>




<h5>Filtering</h5>


<ul>
<li> <p><code>ignore_hosts</code> (character) Vector of hosts to ignore. e.g., localhost, or
google.com. These hosts are ignored and real HTTP requests allowed to go
through
</p>
</li>
<li> <p><code>ignore_localhost</code> (logical) Default: <code>FALSE</code>
</p>
</li>
<li> <p><code>ignore_request</code> List of requests to ignore. NOT USED RIGHT NOW, sorry
</p>
</li>
<li> <p><code>filter_sensitive_data</code> named list of values to replace. Format is:
</p>
<div class="sourceCode"><pre>list(thing_to_replace_it_with = thing_to_replace)
</pre></div>
<p>We replace all instances of <code>thing_to_replace</code> with
<code>thing_to_replace_it_with</code>. Uses <code><a href="base.html#topic+gsub">gsub()</a></code> internally, with <code>fixed=TRUE</code>;
so does exact matches. Before recording (writing to a cassette) we do
the replacement and then when reading from the cassette we do the reverse
replacement to get back to the real data. Before record replacement happens
in internal function <code>write_interactions()</code>, while before playback
replacement happens in internal function <code>YAML$deserialize()</code>
</p>
</li>
<li> <p><code>filter_sensitive_data_regex</code> named list of values to replace. Follows
<code>filter_sensitive_data</code> format, except uses <code>fixed=FALSE</code> in the <code><a href="base.html#topic+gsub">gsub()</a></code>
function call; this means that the value in <code>thing_to_replace</code> is a regex
pattern.
</p>
</li>
<li> <p><code>filter_request_headers</code> (character/list) <strong>request</strong> headers to filter.
A character vector of request headers to remove - the headers will not be
recorded to disk. Alternatively, a named list similar to
<code>filter_sensitive_data</code> instructing vcr with what value to replace the
real value of the request header.
</p>
</li>
<li> <p><code>filter_response_headers</code> (named list) <strong>response</strong> headers to filter.
A character vector of response headers to remove - the headers will not be
recorded to disk. Alternatively, a named list similar to
<code>filter_sensitive_data</code> instructing vcr with what value to replace the
real value of the response header.
</p>
</li>
<li> <p><code>filter_query_parameters</code> (named list) query parameters to filter.
A character vector of query parameters to remove - the query parameters
will not be recorded to disk. Alternatively, a named list similar to
<code>filter_sensitive_data</code> instructing vcr with what value to replace the
real value of the query parameter.
</p>
</li></ul>





<h4>Errors</h4>


<ul>
<li> <p><code>verbose_errors</code> Do you want more verbose errors or less verbose
errors when cassette recording/usage fails? Default is <code>FALSE</code>, that is,
less verbose errors. If <code>TRUE</code>, error messages will include more details
about what went wrong and suggest possible solutions. For testing
in an interactive R session, if <code>verbose_errors=FALSE</code>, you can run
<code>vcr_last_error()</code> to get the full error. If in non-interactive mode,
which most users will be in when running the entire test suite for a
package, you can set an environment variable (<code>VCR_VERBOSE_ERRORS</code>)
to toggle this setting (e.g.,
<code style="white-space: pre;">&#8288;Sys.setenv(VCR_VERBOSE_ERRORS=TRUE); devtools::test()&#8288;</code>)
</p>
</li></ul>



<h5>Internals</h5>


<ul>
<li> <p><code>cassettes</code> (list) don't use
</p>
</li>
<li> <p><code>linked_context</code> (logical) linked context
</p>
</li>
<li> <p><code>uri_parser</code> the uri parser, default: <code>crul::url_parse()</code>
</p>
</li></ul>




<h5>Logging</h5>


<ul>
<li> <p><code>log</code> (logical) should we log important vcr things? Default: <code>FALSE</code>
</p>
</li>
<li> <p><code>log_opts</code> (list) Additional logging options:
</p>

<ul>
<li><p> 'file' either <code>"console"</code> or a file path to log to
</p>
</li>
<li><p> 'log_prefix' default: &quot;Cassette&quot;. We insert the cassette name after
that prefix, then the rest of the message.
</p>
</li>
<li><p> More to come...
</p>
</li></ul>

</li></ul>





<h4>Cassette Options</h4>

<p>These settings can be configured globally, using <code>vcr_configure()</code>, or
locally, using either <code>use_cassette()</code> or <code>insert_cassette()</code>. Global
settings are applied to <em>all</em> cassettes but are overridden by settings
defined locally for individual cassettes.
</p>

<ul>
<li> <p><code>record</code> (character) One of 'all', 'none', 'new_episodes', or 'once'.
See <a href="#topic+recording">recording</a>
</p>
</li>
<li> <p><code>match_requests_on</code> vector of matchers. Default: (<code>method</code>, <code>uri</code>)
See <a href="#topic+request-matching">request-matching</a> for details.
</p>
</li>
<li> <p><code>serialize_with</code>: (character) &quot;yaml&quot; or &quot;json&quot;. Note that you can have
multiple cassettes with the same name as long as they use different
serializers; so if you only want one cassette for a given cassette name,
make sure to not switch serializers, or clean up files you no longer need.
</p>
</li>
<li> <p><code>json_pretty</code>: (logical) want JSON to be newline separated to be easier
to read? Or remove newlines to save disk space? default: FALSE
</p>
</li>
<li> <p><code>persist_with</code> (character) only option is &quot;FileSystem&quot;
</p>
</li>
<li> <p><code>preserve_exact_body_bytes</code> (logical) preserve exact body bytes for
</p>
</li>
<li> <p><code>re_record_interval</code> (numeric) When given, the cassette will be
re-recorded at the given interval, in seconds.
</p>
</li>
<li> <p><code>clean_outdated_http_interactions</code> (logical) Should outdated interactions
be recorded back to file. Default: <code>FALSE</code>
</p>
</li>
<li> <p><code>quiet</code> (logical) Suppress any messages from both vcr and webmockr.
Default: <code>TRUE</code>
</p>
</li>
<li> <p><code>warn_on_empty_cassette</code> (logical) Should a warning be thrown when an
empty cassette is detected? Empty cassettes are cleaned up (deleted) either
way. This option only determines whether a warning is thrown or not.
Default: <code>FALSE</code>
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>vcr_configure(dir = tempdir())
vcr_configure(dir = tempdir(), record = "all")
vcr_configuration()
vcr_config_defaults()
vcr_configure(dir = tempdir(), ignore_hosts = "google.com")
vcr_configure(dir = tempdir(), ignore_localhost = TRUE)


# logging
vcr_configure(dir = tempdir(), log = TRUE,
  log_opts = list(file = file.path(tempdir(), "vcr.log")))
vcr_configure(dir = tempdir(), log = TRUE, log_opts = list(file = "console"))
vcr_configure(dir = tempdir(), log = TRUE,
 log_opts = list(
   file = file.path(tempdir(), "vcr.log"),
   log_prefix = "foobar"
))
vcr_configure(dir = tempdir(), log = FALSE)

# filter sensitive data
vcr_configure(dir = tempdir(),
  filter_sensitive_data = list(foo = "&lt;bar&gt;")
)
vcr_configure(dir = tempdir(),
  filter_sensitive_data = list(foo = "&lt;bar&gt;", hello = "&lt;world&gt;")
)
</code></pre>

<hr>
<h2 id='vcr_logging'>vcr log file setup</h2><span id='topic+vcr_logging'></span><span id='topic+vcr_log_file'></span><span id='topic+vcr_log_info'></span>

<h3>Description</h3>

<p>vcr log file setup
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcr_log_file(file, overwrite = TRUE)

vcr_log_info(message, include_date = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcr_logging_+3A_file">file</code></td>
<td>
<p>(character) a file path, required</p>
</td></tr>
<tr><td><code id="vcr_logging_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) whether or not to overwrite the file at
'file' if it already exists. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="vcr_logging_+3A_message">message</code></td>
<td>
<p>(character) a message to log</p>
</td></tr>
<tr><td><code id="vcr_logging_+3A_include_date">include_date</code></td>
<td>
<p>(logical) include date and time in each log entry.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># user workflow
vcr_configuration()
logfile &lt;- file.path(tempdir(), "vcr.log")
vcr_configure(dir = tempdir(), log = TRUE, log_opts = list(file = logfile))

readLines(logfile) # empty

# log messages
vcr_log_info("hello world!")
readLines(logfile)
vcr_log_info("foo bar")
readLines(logfile)
## many messages
vcr_log_info(c("brown cow", "blue horse"))
readLines(logfile)
vcr_log_info(c("brown cow", "blue horse", "green goat"))
readLines(logfile)

# standalone workflow
# set a file to log to
vcr_log_file((f &lt;- tempfile()))
readLines(f) # empty

# log messages
vcr_log_info("hello world!")
readLines(logfile)
vcr_log_info("foo bar")
readLines(logfile)

# cleanup
unlink(f)
unlink(logfile)
</code></pre>

<hr>
<h2 id='vcr_test_path'>Locate file in tests directory</h2><span id='topic+vcr_test_path'></span>

<h3>Description</h3>

<p>This function, similar to <code>testthat::test_path()</code>, is designed to work both
interactively and during tests, locating files in the <code style="white-space: pre;">&#8288;tests/&#8288;</code> directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcr_test_path(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcr_test_path_+3A_...">...</code></td>
<td>
<p>Character vectors giving path component. each character string
gets added on to the path, e.g., <code>vcr_test_path("a", "b")</code> becomes
<code>tests/a/b</code> relative to the root of the package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector giving the path
</p>


<h3>Note</h3>

<p><code>vcr_test_path()</code> assumes you are using testthat for your unit tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
vcr_test_path("fixtures")
}
</code></pre>

<hr>
<h2 id='VcrResponse'>The response of an HTTPInteraction</h2><span id='topic+VcrResponse'></span>

<h3>Description</h3>

<p>Custom vcr http response object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>status</code></dt><dd><p>the status of the response</p>
</dd>
<dt><code>headers</code></dt><dd><p>the response headers</p>
</dd>
<dt><code>body</code></dt><dd><p>the response body</p>
</dd>
<dt><code>http_version</code></dt><dd><p>the HTTP version</p>
</dd>
<dt><code>opts</code></dt><dd><p>a list</p>
</dd>
<dt><code>adapter_metadata</code></dt><dd><p>Additional metadata used by a specific VCR adapter</p>
</dd>
<dt><code>hash</code></dt><dd><p>a list</p>
</dd>
<dt><code>disk</code></dt><dd><p>a boolean</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-VcrResponse-new"><code>VcrResponse$new()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-print"><code>VcrResponse$print()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-to_hash"><code>VcrResponse$to_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-from_hash"><code>VcrResponse$from_hash()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-update_content_length_header"><code>VcrResponse$update_content_length_header()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-get_header"><code>VcrResponse$get_header()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-edit_header"><code>VcrResponse$edit_header()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-delete_header"><code>VcrResponse$delete_header()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-content_encoding"><code>VcrResponse$content_encoding()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-is_compressed"><code>VcrResponse$is_compressed()</code></a>
</p>
</li>
<li> <p><a href="#method-VcrResponse-clone"><code>VcrResponse$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-VcrResponse-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new VcrResponse object
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$new(
  status,
  headers,
  body,
  http_version,
  opts,
  adapter_metadata = NULL,
  disk
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>the status of the response</p>
</dd>
<dt><code>headers</code></dt><dd><p>the response headers</p>
</dd>
<dt><code>body</code></dt><dd><p>the response body</p>
</dd>
<dt><code>http_version</code></dt><dd><p>the HTTP version</p>
</dd>
<dt><code>opts</code></dt><dd><p>a list</p>
</dd>
<dt><code>adapter_metadata</code></dt><dd><p>Additional metadata used by a specific VCR adapter</p>
</dd>
<dt><code>disk</code></dt><dd><p>boolean, is body a file on disk</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>VcrResponse</code> object
</p>


<hr>
<a id="method-VcrResponse-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>VcrResponse</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-VcrResponse-to_hash"></a>



<h4>Method <code>to_hash()</code></h4>

<p>Create a hash
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$to_hash()</pre></div>



<h5>Returns</h5>

<p>a list
</p>


<hr>
<a id="method-VcrResponse-from_hash"></a>



<h4>Method <code>from_hash()</code></h4>

<p>Get a hash back to an R list
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$from_hash(hash)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hash</code></dt><dd><p>a list</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>an <code>VcrResponse</code> object
</p>


<hr>
<a id="method-VcrResponse-update_content_length_header"></a>



<h4>Method <code>update_content_length_header()</code></h4>

<p>Updates the Content-Length response header so that
it is accurate for the response body
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$update_content_length_header()</pre></div>



<h5>Returns</h5>

<p>no return; modifies the content length header
</p>


<hr>
<a id="method-VcrResponse-get_header"></a>



<h4>Method <code>get_header()</code></h4>

<p>Get a header by name
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$get_header(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(character) header name to get</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the header value (if it exists)
</p>


<hr>
<a id="method-VcrResponse-edit_header"></a>



<h4>Method <code>edit_header()</code></h4>

<p>Edit a header
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$edit_header(key, value = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(character) header name to edit</p>
</dd>
<dt><code>value</code></dt><dd><p>(character) new value to assign</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; modifies the header in place
</p>


<hr>
<a id="method-VcrResponse-delete_header"></a>



<h4>Method <code>delete_header()</code></h4>

<p>Delete a header
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$delete_header(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>(character) header name to delete</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>no return; the header is deleted if it exists
</p>


<hr>
<a id="method-VcrResponse-content_encoding"></a>



<h4>Method <code>content_encoding()</code></h4>

<p>Get the content-encoding header value
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$content_encoding()</pre></div>



<h5>Returns</h5>

<p>(character) the content-encoding value
</p>


<hr>
<a id="method-VcrResponse-is_compressed"></a>



<h4>Method <code>is_compressed()</code></h4>

<p>Checks if the encoding is one of &quot;gzip&quot; or &quot;deflate&quot;
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$is_compressed()</pre></div>



<h5>Returns</h5>

<p>logical
</p>


<hr>
<a id="method-VcrResponse-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>VcrResponse$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vcr_configure(dir = tempdir())

# basic example of VcrResponse use
url &lt;- "https://google.com"
(cli &lt;- crul::HttpClient$new(url = url))
(res &lt;- cli$get("get", query = list(q = "stuff")))
(x &lt;- VcrResponse$new(res$status_http(), res$response_headers,
   res$parse("UTF-8"), res$response_headers$status))
x$body
x$status
x$headers
x$http_version
x$to_hash()
x$from_hash(x$to_hash())

# update content length header
## example 1
### content-length header present, but no change
url &lt;- "https://fishbase.ropensci.org"
cli &lt;- crul::HttpClient$new(url = url, headers = list(`Accept-Encoding` = '*'))
res &lt;- cli$get("species/34")
x &lt;- VcrResponse$new(res$status_http(), res$response_headers,
   res$parse("UTF-8"), res$response_headers$status)
x$headers$`content-length`
x$update_content_length_header()
x$headers$`content-length`

## example 2
### no content-length header b/c a transfer-encoding header is included
### and no content-length header allowed if transfer-encoding header
### used (via rfc7230)
url &lt;- "https://google.com"
cli &lt;- crul::HttpClient$new(url = url)
res &lt;- cli$get()
x &lt;- VcrResponse$new(res$status_http(), res$response_headers,
   rawToChar(res$content), res$response_headers$status)
x$headers$`content-length` # = NULL
x$update_content_length_header() # no change, b/c header doesn't exist
x$headers$`content-length` # = NULL

## example 3
### content-length header present, and does change
body &lt;- " Hello World "
x &lt;- VcrResponse$new(200, list('content-length'=nchar(body)),
  body, "HTTP/2")
x$headers$`content-length` # = 13
x$body &lt;- gsub("^\\s|\\s$", "", x$body)
x$headers$`content-length` # = 13
x$update_content_length_header()
x$headers$`content-length` # = 11

# check if body is compressed
url &lt;- "https://fishbase.ropensci.org"
(cli &lt;- crul::HttpClient$new(url = url))
(res &lt;- cli$get("species/3"))
res$response_headers
(x &lt;- VcrResponse$new(res$status_http(), res$response_headers,
   res$parse("UTF-8"), res$response_headers$status))
x$content_encoding()
x$is_compressed()

# with disk
url &lt;- "https://google.com"
(cli &lt;- crul::HttpClient$new(url = url))
f &lt;- tempfile()
(res &lt;- cli$get("get", query = list(q = "stuff"), disk = f))
(x &lt;- VcrResponse$new(res$status_http(), res$response_headers,
   f, res$response_headers$status, disk = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='YAML'>The YAML serializer</h2><span id='topic+YAML'></span>

<h3>Description</h3>

<p>class with methods for serializing via the <span class="pkg">yaml</span> package
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Serializer">vcr::Serializer</a></code> -&gt; <code>YAML</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-YAML-new"><code>YAML$new()</code></a>
</p>
</li>
<li> <p><a href="#method-YAML-serialize"><code>YAML$serialize()</code></a>
</p>
</li>
<li> <p><a href="#method-YAML-deserialize"><code>YAML$deserialize()</code></a>
</p>
</li>
<li> <p><a href="#method-YAML-clone"><code>YAML$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-YAML-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new YAML object
</p>


<h5>Usage</h5>

<div class="r"><pre>YAML$new(path = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>(character) path to the cassette, excluding the cassette
directory and the file extension</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>YAML</code> object
</p>


<hr>
<a id="method-YAML-serialize"></a>



<h4>Method <code>serialize()</code></h4>

<p>Serializes the given hash using internal fxn write_yaml
</p>


<h5>Usage</h5>

<div class="r"><pre>YAML$serialize(x, path, bytes)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(list) the object to serialize</p>
</dd>
<dt><code>path</code></dt><dd><p>(character) the file path</p>
</dd>
<dt><code>bytes</code></dt><dd><p>(logical) whether to preserve exact body bytes or not</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(character) the YAML string to write to disk
</p>


<hr>
<a id="method-YAML-deserialize"></a>



<h4>Method <code>deserialize()</code></h4>

<p>Deserializes the content at the path using
yaml::yaml.load_file
</p>


<h5>Usage</h5>

<div class="r"><pre>YAML$deserialize(cassette)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cassette</code></dt><dd><p>the current cassette object so it's properties can
be retrieved</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(list) the deserialized object, an R list
</p>


<hr>
<a id="method-YAML-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>YAML$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
