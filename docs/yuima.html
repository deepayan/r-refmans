<!DOCTYPE html><html lang="en"><head><title>Help for package yuima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {yuima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaBayes'><p>Adaptive Bayes estimator for the parameters in sde model</p></a></li>
<li><a href='#ae'><p>Asymptotic Expansion</p></a></li>
<li><a href='#aeCharacteristic'><p>Asymptotic Expansion - Characteristic Function</p></a></li>
<li><a href='#aeDensity'><p>Asymptotic Expansion - Density</p></a></li>
<li><a href='#aeExpectation'><p>Asymptotic Expansion - Functionals</p></a></li>
<li><a href='#aeKurtosis'><p>Asymptotic Expansion - Kurtosis</p></a></li>
<li><a href='#aeMarginal'><p>Asymptotic Expansion - Marginals</p></a></li>
<li><a href='#aeMean'><p>Asymptotic Expansion - Mean</p></a></li>
<li><a href='#aeMoment'><p>Asymptotic Expansion - Moments</p></a></li>
<li><a href='#aeSd'><p>Asymptotic Expansion - Standard Deviation</p></a></li>
<li><a href='#aeSkewness'><p>Asymptotic Expansion - Skewness</p></a></li>
<li><a href='#asymptotic_term'><p>asymptotic expansion of the expected value of the functional</p></a></li>
<li><a href='#bns.test'>
<p>Barndorff-Nielsen and Shephard's Test for the Presence of Jumps Using Bipower Variation</p></a></li>
<li><a href='#carma.info-class'><p>Class for information about CARMA(p,q) model</p></a></li>
<li><a href='#carmaHawkes.info-class'><p>Class for information on the Hawkes process with a CARMA(p,q) intensity</p></a></li>
<li><a href='#CarmaNoise'><p>Estimation for the underlying Levy in a carma model</p></a></li>
<li><a href='#cce'>
<p>Nonsynchronous Cumulative Covariance Estimator</p></a></li>
<li><a href='#cce.factor'>
<p>High-Dimensional Cumulative Covariance Estimator by Factor Modeling and Regularization</p></a></li>
<li><a href='#Class+20for+20Quasi+20Maximum+20Likelihood+20Estimation+20of+20Point+20Process+20Regression+20Models'><p>Class for Quasi Maximum Likelihood Estimation of Point Process Regression Models</p></a></li>
<li><a href='#cogarch.est.-class'><p>Class for Generalized Method of Moments Estimation for COGARCH(p,q) model</p></a></li>
<li><a href='#cogarch.est.incr-class'><p>Class for Estimation of COGARCH(p,q) model with underlying increments</p></a></li>
<li><a href='#cogarch.info-class'><p>Class for information about CoGarch(p,q)</p></a></li>
<li><a href='#cogarchNoise'><p>Estimation for the underlying Levy in a COGARCH(p,q) model</p></a></li>
<li><a href='#CPoint'><p>Volatility structural change point estimator</p></a></li>
<li><a href='#DataPPR'><p>From <code>zoo</code> data to <code>yuima.PPR</code>.</p></a></li>
<li><a href='#Diagnostic.Carma'><p>Diagnostic Carma model</p></a></li>
<li><a href='#Diagnostic.Cogarch'>
<p>Function for checking the statistical properties of the COGARCH(p,q) model</p></a></li>
<li><a href='#estimation_LRM'><p>Estimation of the t-Levy Regression Model</p></a></li>
<li><a href='#EstimCarmaHawkes'>
<p>Estimation Methods for a CARMA(p,q)-Hawkes Counting Process</p></a></li>
<li><a href='#fitCIR'><p>Calculate preliminary estimator and one-step improvements of a Cox-Ingersoll-Ross diffusion</p></a></li>
<li><a href='#FromCF2yuima_law'>
<p>From a Characteristic Function to an  <code>yuima.law-object</code>.</p></a></li>
<li><a href='#get.counting.data'>
<p>Extract arrival times from an object of class <code>yuima.PPR</code></p></a></li>
<li><a href='#gmm'>
<p>Method of Moments for COGARCH(P,Q).</p></a></li>
<li><a href='#hyavar'>
<p>Asymptotic Variance Estimator for the Hayashi-Yoshida estimator</p></a></li>
<li><a href='#IC'>
<p>Information criteria for the stochastic differential equation</p></a></li>
<li><a href='#info.Map-class'><p>Class for information about Map/Operators</p></a></li>
<li><a href='#info.PPR'><p>Class for information about Point Process</p></a></li>
<li><a href='#Integral.sde'><p>Class for the mathematical description of integral of a stochastic process</p></a></li>
<li><a href='#Integrand'><p>Class for the mathematical description of integral of a stochastic process</p></a></li>
<li><a href='#Intensity.PPR'><p>Intesity Process for the Point Process Regression Model</p></a></li>
<li><a href='#JBtest'>
<p>Remove jumps and calculate the Gaussian quasi-likelihood estimator based on the Jarque-Bera normality test</p></a></li>
<li><a href='#lambdaFromData'>
<p>Intensity of a Point Process Regression Model</p></a></li>
<li><a href='#lasso'><p>Adaptive LASSO estimation for stochastic differential equations</p></a></li>
<li><a href='#LawMethods'><p>Methods for an object of class <code>yuima.law</code></p></a></li>
<li><a href='#limiting.gamma'><p>calculate the value of limiting covariance matrices : Gamma</p></a></li>
<li><a href='#llag'><p>Lead Lag Estimator</p></a></li>
<li><a href='#llag.test'>
<p>Wild Bootstrap Test for the Absence of Lead-Lag Effects</p></a></li>
<li><a href='#lm.jumptest'>
<p>Lee and Mykland's Test for the Presence of Jumps Using Normalized Returns</p></a></li>
<li><a href='#LogSPX'>
<p>Five minutes Log SPX prices</p></a></li>
<li><a href='#lseBayes'><p>Adaptive Bayes estimator for the parameters in sde model by using LSE functions</p></a></li>
<li><a href='#mllag'>
<p>Multiple Lead-Lag Detector</p></a></li>
<li><a href='#mmfrac'>
<p>mmfrac</p></a></li>
<li><a href='#model.parameter-class'><p>Class for the parameter description of stochastic differential equations</p></a></li>
<li><a href='#mpv'>
<p>Realized Multipower Variation</p></a></li>
<li><a href='#MWK151'>
<p>Graybill - Methuselah Walk - PILO - ITRDB CA535</p></a></li>
<li><a href='#noisy.sampling'>
<p>Noisy Observation Generator</p></a></li>
<li><a href='#ntv'>
<p>Volatility Estimation and Jump Test Using Nearest Neighbor Truncation</p></a></li>
<li><a href='#param.Integral'><p>Class for the mathematical description of integral of a stochastic process</p></a></li>
<li><a href='#param.Map-class'><p>Class for information about Map/Operators</p></a></li>
<li><a href='#phi.test'><p>Phi-divergence test statistic for stochastic differential equations</p></a></li>
<li><a href='#poisson.random.sampling'><p>Poisson random sampling method</p></a></li>
<li><a href='#pz.test'>
<p>Podolskij and Ziggel's Test for the Presence of Jumps Using Power Variation with Perturbed Truncation</p></a></li>
<li><a href='#qgv'><p>qgv</p></a></li>
<li><a href='#qmle'><p>Calculate quasi-likelihood and ML estimator of least squares estimator</p></a></li>
<li><a href='#qmleLevy'>
<p>Gaussian quasi-likelihood estimation for Levy driven SDE</p></a></li>
<li><a href='#rconst'>
<p>Fictitious rng for the constant random variable used to generate and describe</p>
Poisson jumps.</a></li>
<li><a href='#rng'><p>Random numbers and densities</p></a></li>
<li><a href='#setCarma'>
<p>Continuous Autoregressive Moving Average (p, q) model</p></a></li>
<li><a href='#setCarmaHawkes'>
<p>Hawkes Process with a Continuous Autoregressive Moving Average(p, q) intensity</p></a></li>
<li><a href='#setCharacteristic'>
<p>Set characteristic information and create a &lsquo;characteristic&rsquo; object.</p></a></li>
<li><a href='#setCogarch'><p> Continuous-time GARCH (p,q) process</p></a></li>
<li><a href='#setData'>
<p>Set and access data of an object of type &quot;yuima.data&quot; or &quot;yuima&quot;.</p></a></li>
<li><a href='#setFunctional'><p>Description of a functional associated with a perturbed stochastic differential equation</p></a></li>
<li><a href='#setHawkes'><p>Constructor of Hawkes model</p></a></li>
<li><a href='#setIntegral'><p>Integral of Stochastic Differential Equation</p></a></li>
<li><a href='#setLaw'><p>Random variable constructor</p></a></li>
<li><a href='#setLaw_th'>
<p>Constructior of a t-Levy process.</p></a></li>
<li><a href='#setLRM'>
<p>A constructor of a t-Student Regression Model.</p></a></li>
<li><a href='#setMap'>
<p>Map of a Stochastic Differential Equation</p></a></li>
<li><a href='#setModel'>
<p>Basic description of stochastic differential equations (SDE)</p></a></li>
<li><a href='#setPoisson'>
<p>Basic constructor for Compound Poisson processes</p></a></li>
<li><a href='#setPPR'><p>Point Process</p></a></li>
<li><a href='#setSampling'>
<p>Set sampling information and create a &lsquo;sampling&rsquo; object.</p></a></li>
<li><a href='#setYuima'>
<p>Creates a &quot;yuima&quot; object by combining &quot;model&quot;, &quot;data&quot;, &quot;sampling&quot;, &quot;characteristic&quot;</p>
and &quot;functional&quot;slots.</a></li>
<li><a href='#simBmllag'>
<p>Simulation of increments of bivariate Brownian motions with multi-scale lead-lag relationships</p></a></li>
<li><a href='#simCIR'><p>Simulation of the Cox-Ingersoll-Ross diffusion</p></a></li>
<li><a href='#simFunctional'><p>Calculate the value of functional</p></a></li>
<li><a href='#simulate'><p>Simulator function for multi-dimensional stochastic processes</p></a></li>
<li><a href='#snr'>
<p>Calculating self-normalized residuals for SDEs.</p></a></li>
<li><a href='#spectralcov'>
<p>Spectral Method for Cumulative Covariance Estimation</p></a></li>
<li><a href='#subsampling'><p>subsampling</p></a></li>
<li><a href='#toLatex'><p>Additional Methods for LaTeX Representations for Yuima objects</p></a></li>
<li><a href='#variable.Integral'><p>Class for the mathematical description of integral of a stochastic process</p></a></li>
<li><a href='#wllag'>
<p>Scale-by-scale lead-lag estimation</p></a></li>
<li><a href='#ybook'><p>R code for the Yuima Book</p></a></li>
<li><a href='#yuima-class'><p>Class for stochastic differential equations</p></a></li>
<li><a href='#yuima.ae-class'><p>Class for the asymptotic expansion of diffusion processes</p></a></li>
<li><a href='#yuima.carma-class'><p>Class for the mathematical description of CARMA(p,q) model</p></a></li>
<li><a href='#yuima.carma.qmle-class'><p>Class for Quasi Maximum Likelihood Estimation of CARMA(p,q) model</p></a></li>
<li><a href='#yuima.carmaHawkes-class'><p>Class for the mathematical description of a Hawkes process with a CARMA(p,q) intensity</p></a></li>
<li><a href='#yuima.characteristic-class'><p>Classe for stochastic differential equations characteristic scheme</p></a></li>
<li><a href='#yuima.cogarch-class'><p>Class for the mathematical description of CoGarch(p,q) model</p></a></li>
<li><a href='#yuima.CP.qmle-class'><p>Class for Quasi Maximum Likelihood Estimation of Compound Poisson-based and SDE models</p></a></li>
<li><a href='#yuima.data-class'><p>Class &quot;yuima.data&quot; for the data slot of a &quot;yuima&quot; class object</p></a></li>
<li><a href='#yuima.functional-class'><p>Classes for stochastic differential equations data object</p></a></li>
<li><a href='#yuima.Hawkes'><p>Class for a mathematical description of a Point Process</p></a></li>
<li><a href='#yuima.Integral-class'><p>Class for the mathematical description of integral of a stochastic process</p></a></li>
<li><a href='#yuima.law-class'><p><code>yuima law-class</code>: A mathematical description for the noise.</p></a></li>
<li><a href='#yuima.LevyRM-class'><p><code>yuima.LevyRM</code>: A class for the mathematical description of the t-Student regression model.</p></a></li>
<li><a href='#yuima.Map-class'><p>Class for the mathematical description of function of a stochastic process</p></a></li>
<li><a href='#yuima.model-class'><p>Classes for the mathematical description of stochastic differential equations</p></a></li>
<li><a href='#yuima.multimodel-class'><p>Class for the mathematical description of Multi dimensional Jump Diffusion processes</p></a></li>
<li><a href='#yuima.poisson-class'><p>Class for the mathematical description of Compound Poisson processes</p></a></li>
<li><a href='#yuima.PPR'><p>Class for a mathematical description of a Point Process</p></a></li>
<li><a href='#yuima.qmleLevy.incr'><p>Class for Quasi Maximum Likelihood Estimation of Levy SDE model</p></a></li>
<li><a href='#yuima.sampling-class'><p>Classes for stochastic differential equations sampling scheme</p></a></li>
<li><a href='#yuima.snr-class'><p>Class &quot;yuima.snr&quot; for self-normalized residuals of SDE &quot;yuima&quot; class object</p></a></li>
<li><a href='#yuima.th-class'><p><code>yuima.th-class</code>: A mathematical description for the t-Levy process.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The YUIMA Project Package for SDEs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.15.27</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0), methods, zoo, stats4, utils, expm, cubature,
mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1), boot (&ge; 1.3-2), glassoFast, coda, calculus
(&ge; 0.2.0), statmod,</td>
</tr>
<tr>
<td>Author:</td>
<td>YUIMA Project Team</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano M. Iacus &lt;siacus@iq.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation and Inference for SDEs and Other Stochastic Processes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://yuimaproject.com">https://yuimaproject.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yuimaproject/yuima/issues">https://github.com/yuimaproject/yuima/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 17:48:10 UTC; jago</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 21:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaBayes'>Adaptive Bayes estimator for the parameters in sde model</h2><span id='topic+adaBayes'></span><span id='topic+adaBayes+2Cyuima-method'></span>

<h3>Description</h3>

<p>The <code>adabayes.mcmc</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code>mle-class</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaBayes(yuima, start, prior, lower, upper, method = "mcmc", iteration = NULL,mcmc,
rate =1, rcpp = TRUE, algorithm = "randomwalk",center=NULL,sd=NULL,rho=NULL,
path = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adaBayes_+3A_yuima">yuima</code></td>
<td>
<p>a 'yuima' object.</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_start">start</code></td>
<td>
<p>initial suggestion for parameter values </p>
</td></tr>
<tr><td><code id="adaBayes_+3A_prior">prior</code></td>
<td>
<p>a list of prior distributions for the parameters specified by 'code'. Currently, dunif(z, min, max), dnorm(z, mean, sd), dbeta(z, shape1, shape2), dgamma(z, shape, rate) are available. </p>
</td></tr>
<tr><td><code id="adaBayes_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_method">method</code></td>
<td>
<p><code>"nomcmc"</code> requires package <code>cubature</code> </p>
</td></tr>
<tr><td><code id="adaBayes_+3A_iteration">iteration</code></td>
<td>
<p>number of iteration of Markov chain Monte Carlo method</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_mcmc">mcmc</code></td>
<td>
<p>number of iteration of Markov chain Monte Carlo method</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_rate">rate</code></td>
<td>
<p>a thinning parameter. Only the first n^rate observation will be used for inference. </p>
</td></tr>
<tr><td><code id="adaBayes_+3A_rcpp">rcpp</code></td>
<td>
<p>Logical value. If <code>rcpp = TRUE</code> (default), Rcpp code will be performed. Otherwise, usual R code will be performed. </p>
</td></tr>
<tr><td><code id="adaBayes_+3A_algorithm">algorithm</code></td>
<td>
<p>If <code>algorithm = "randomwalk"</code> (default), the random-walk Metropolis algorithm will be performed. If <code>algorithm = "MpCN"</code>, the Mixed preconditioned Crank-Nicolson algorithm will be performed.</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_center">center</code></td>
<td>
<p>A list of parameters used to center MpCN algorithm.</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_sd">sd</code></td>
<td>
<p>A list for specifying the standard deviation of proposal distributions.</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_path">path</code></td>
<td>
<p>Logical value when <code>method = "mcmc"</code>. If <code>path=TRUE</code>, then the sample path for each variable will be included in the MCMC object in the output.</p>
</td></tr>
<tr><td><code id="adaBayes_+3A_rho">rho</code></td>
<td>
<p>A parameter used for MpCN algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the Bayes estimator for stochastic processes by using  the quasi-likelihood function. The calculation is performed by the Markov chain Monte Carlo method. Currently, the Random-walk Metropolis algorithm  and the Mixed preconditioned Crank-Nicolson algorithm is implemented.</p>


<h3>Slots</h3>


<dl>
<dt><code>mcmc</code>:</dt><dd><p>is a list of MCMC objects for all estimated parameters.</p>
</dd>
<dt><code>accept_rate</code>:</dt><dd><p>is a list acceptance rates for diffusion and drift parts.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>list</code> that contains estimated parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>is an object of class <code>vector</code> that contains estimated parameters.</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>algorithm = nomcmc</code> is unstable.
</p>


<h3>Author(s)</h3>

<p>Kengo Kamatani with YUIMA project Team</p>


<h3>References</h3>

<p>Yoshida, N. (2011). Polynomial type large deviation inequalities and quasi-likelihood analysis for stochastic differential equations. Annals of the Institute of Statistical Mathematics, 63(3), 431-479.
Uchida, M., &amp; Yoshida, N. (2014). Adaptive Bayes type estimators of ergodic diffusion processes from discrete observations. Statistical Inference for Stochastic Processes, 17(2), 181-219.
Kamatani, K. (2017). Ergodicity of Markov chain Monte Carlo with reversible proposal. Journal of Applied Probability, 54(2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
b &lt;- c("-theta1*x1+theta2*sin(x2)+50","-theta3*x2+theta4*cos(x1)+25")
a &lt;- matrix(c("4+theta5","1","1","2+theta6"),2,2)
true = list(theta1 = 0.5, theta2 = 5,theta3 = 0.3,
            theta4 = 5, theta5 = 1, theta6 = 1)
lower = list(theta1=0.1,theta2=0.1,theta3=0,
             theta4=0.1,theta5=0.1,theta6=0.1)
upper = list(theta1=1,theta2=10,theta3=0.9,
             theta4=10,theta5=10,theta6=10)
start = list(theta1=runif(1),
             theta2=rnorm(1),
             theta3=rbeta(1,1,1),
             theta4=rnorm(1),
             theta5=rgamma(1,1,1),
             theta6=rexp(1))
yuimamodel &lt;- setModel(drift=b,diffusion=a,state.variable=c("x1", "x2"),solve.variable=c("x1","x2"))
yuimasamp &lt;- setSampling(Terminal=50,n=50*10)
yuima &lt;- setYuima(model = yuimamodel, sampling = yuimasamp)
yuima &lt;- simulate(yuima, xinit = c(100,80),
                  true.parameter = true,sampling = yuimasamp)
prior &lt;-
  list(
    theta1=list(measure.type="code",df="dunif(z,0,1)"),
    theta2=list(measure.type="code",df="dnorm(z,0,1)"),
    theta3=list(measure.type="code",df="dbeta(z,1,1)"),
    theta4=list(measure.type="code",df="dgamma(z,1,1)"),
    theta5=list(measure.type="code",df="dnorm(z,0,1)"),
    theta6=list(measure.type="code",df="dnorm(z,0,1)")
  )
set.seed(123)
mle &lt;- qmle(yuima, start = start, lower = lower, upper = upper, method = "L-BFGS-B",rcpp=TRUE)
print(mle@coef)
center&lt;-list(theta1=0.5,theta2=5,theta3=0.3,theta4=4,theta5=3,theta6=3)
sd&lt;-list(theta1=0.001,theta2=0.001,theta3=0.001,theta4=0.01,theta5=0.5,theta6=0.5)
bayes &lt;- adaBayes(yuima, start=start, prior=prior,lower=lower,upper=upper,
                  method="mcmc",mcmc=1000,rate = 1, rcpp = TRUE,
                   algorithm = "randomwalk",center = center,sd=sd,
                   path=TRUE)
print(bayes@fullcoef)
print(bayes@accept_rate)
print(bayes@mcmc$theta1[1:10])

## End(Not run)
</code></pre>

<hr>
<h2 id='ae'>Asymptotic Expansion</h2><span id='topic+ae'></span>

<h3>Description</h3>

<p>Asymptotic expansion of uni-dimensional and multi-dimensional diffusion processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ae(
  model,
  xinit,
  order = 1L,
  true.parameter = list(),
  sampling = NULL,
  eps.var = "eps",
  solver = "rk4",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ae_+3A_model">model</code></td>
<td>
<p>an object of <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.</p>
</td></tr>
<tr><td><code id="ae_+3A_xinit">xinit</code></td>
<td>
<p>initial value vector of state variables.</p>
</td></tr>
<tr><td><code id="ae_+3A_order">order</code></td>
<td>
<p>integer. The asymptotic expansion order. Higher orders lead to better approximations but longer computational times.</p>
</td></tr>
<tr><td><code id="ae_+3A_true.parameter">true.parameter</code></td>
<td>
<p>named list of parameters.</p>
</td></tr>
<tr><td><code id="ae_+3A_sampling">sampling</code></td>
<td>
<p>a <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code> object.</p>
</td></tr>
<tr><td><code id="ae_+3A_eps.var">eps.var</code></td>
<td>
<p>character. The perturbation variable.</p>
</td></tr>
<tr><td><code id="ae_+3A_solver">solver</code></td>
<td>
<p>the solver for ordinary differential equations. One of <code>"rk4"</code> (more accurate) or <code>"euler"</code> (faster).</p>
</td></tr>
<tr><td><code id="ae_+3A_verbose">verbose</code></td>
<td>
<p>logical. Print on progress? Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>sampling</code> is not provided, then <code>model</code> must be an object of <code><a href="#topic+yuima-class">yuima-class</a></code> with non-empty <code>sampling</code>.
</p>
<p>if <code>eps.var</code> does not appear in the model specification, then it is internally added in front of the diffusion matrix to apply the asymptotic expansion scheme.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Emanuele Guidotti &lt;emanuele.guidotti@unine.ch&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# exact density
x &lt;- seq(50, 200, by = 0.1)
exact &lt;- dlnorm(x = x, meanlog = log(xinit)+(par$mu-0.5*par$sigma^2)*1, sdlog = par$sigma*sqrt(1))

# compare
plot(x, exact, type = 'l', ylab = "Density")
lines(x, aeDensity(x = x, ae = approx, order = 1), col = 2)
lines(x, aeDensity(x = x, ae = approx, order = 2), col = 3)
lines(x, aeDensity(x = x, ae = approx, order = 3), col = 4)
lines(x, aeDensity(x = x, ae = approx, order = 4), col = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeCharacteristic'>Asymptotic Expansion - Characteristic Function</h2><span id='topic+aeCharacteristic'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Characteristic Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeCharacteristic(..., ae, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeCharacteristic_+3A_...">...</code></td>
<td>
<p>named argument, data.frame, list, or environment specifying the grid to evaluate the characteristic function. See examples.</p>
</td></tr>
<tr><td><code id="aeCharacteristic_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeCharacteristic_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeCharacteristic_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Characteristic function evaluated on the given grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# The following are all equivalent methods to specify the grid via ....
# Notice that the character 'u1' corresponds to the 'u.var' of the ae object.
approx@u.var

# 1) named argument  
u1 &lt;- seq(0, 1, by = 0.1)
psi &lt;- aeCharacteristic(u1 = u1, ae = approx, order = 4)
# 2) data frame
df &lt;- data.frame(u1 = seq(0, 1, by = 0.1))
psi &lt;- aeCharacteristic(df, ae = approx, order = 4)
# 3) environment
env &lt;- new.env()
env$u1 &lt;- seq(0, 1, by = 0.1)
psi &lt;- aeCharacteristic(env, ae = approx, order = 4)
# 4) list
lst &lt;- list(u1 = seq(0, 1, by = 0.1))
psi &lt;- aeCharacteristic(lst, ae = approx, order = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeDensity'>Asymptotic Expansion - Density</h2><span id='topic+aeDensity'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeDensity(..., ae, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeDensity_+3A_...">...</code></td>
<td>
<p>named argument, data.frame, list, or environment specifying the grid to evaluate the density. See examples.</p>
</td></tr>
<tr><td><code id="aeDensity_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeDensity_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeDensity_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability density function evaluated on the given grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# The following are all equivalent methods to specify the grid via ....
# Notice that the character 'x' corresponds to the solve.variable of the yuima model.

# 1) named argument  
x &lt;- seq(50, 200, by = 0.1)
density &lt;- aeDensity(x = x, ae = approx, order = 4)
# 2) data frame
df &lt;- data.frame(x = seq(50, 200, by = 0.1))
density &lt;- aeDensity(df, ae = approx, order = 4)
# 3) environment
env &lt;- new.env()
env$x &lt;- seq(50, 200, by = 0.1)
density &lt;- aeDensity(env, ae = approx, order = 4)
# 4) list
lst &lt;- list(x = seq(50, 200, by = 0.1))
density &lt;- aeDensity(lst, ae = approx, order = 4)

# exact density
exact &lt;- dlnorm(x = x, meanlog = log(xinit)+(par$mu-0.5*par$sigma^2)*1, sdlog = par$sigma*sqrt(1))

# compare
plot(x = exact, y = density, xlab = "Exact", ylab = "Approximated")

## End(Not run)
</code></pre>

<hr>
<h2 id='aeExpectation'>Asymptotic Expansion - Functionals</h2><span id='topic+aeExpectation'></span>

<h3>Description</h3>

<p>Compute the expected value of functionals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeExpectation(f, bounds, ae, eps = 1, order = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeExpectation_+3A_f">f</code></td>
<td>
<p>character. The functional.</p>
</td></tr>
<tr><td><code id="aeExpectation_+3A_bounds">bounds</code></td>
<td>
<p>named list of integration bounds in the form <code>list(x = c(xmin, xmax), y = c(ymin, ymax), ...)</code></p>
</td></tr>
<tr><td><code id="aeExpectation_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeExpectation_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeExpectation_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
<tr><td><code id="aeExpectation_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="cubature.html#topic+cubintegrate">cubintegrate</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value of <code><a href="cubature.html#topic+cubintegrate">cubintegrate</a></code>. The expectation of the functional provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# compute the mean via integration
aeExpectation(f = 'x', bounds = list(x = c(0,1000)), ae = approx)

# compare with the mean computed by differentiation of the characteristic function
aeMean(approx)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeKurtosis'>Asymptotic Expansion - Kurtosis</h2><span id='topic+aeKurtosis'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Kurtosis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeKurtosis(ae, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeKurtosis_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeKurtosis_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeKurtosis_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# expansion order max
aeKurtosis(ae = approx)

# expansion order 1
aeKurtosis(ae = approx, order = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeMarginal'>Asymptotic Expansion - Marginals</h2><span id='topic+aeMarginal'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Marginals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeMarginal(ae, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeMarginal_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeMarginal_+3A_var">var</code></td>
<td>
<p>variables of the marginal distribution to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# multidimensional model
gbm &lt;- setModel(drift = c('mu*x1','mu*x2'), 
                diffusion = matrix(c('sigma1*x1',0,0,'sigma2*x2'), nrow = 2), 
                solve.variable = c('x1','x2'))

# settings
xinit &lt;- c(100, 100)
par &lt;- list(mu = 0.01, sigma1 = 0.2, sigma2 = 0.1)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 3, true.parameter = par, xinit = xinit)

# extract marginals
margin1 &lt;- aeMarginal(ae = approx, var = "x1")
margin2 &lt;- aeMarginal(ae = approx, var = "x2")

# compare with exact solution for marginal 1
x1 &lt;- seq(50, 200, by = 0.1)
exact &lt;- dlnorm(x = x1, meanlog = log(xinit[1])+(par$mu-0.5*par$sigma1^2), sdlog = par$sigma1)
plot(x1, exact, type = 'p', ylab = "Density")
lines(x1, aeDensity(x1 = x1, ae = margin1, order = 3), col = 2)

# compare with exact solution for marginal 2
x2 &lt;- seq(50, 200, by = 0.1)
exact &lt;- dlnorm(x = x2, meanlog = log(xinit[2])+(par$mu-0.5*par$sigma2^2), sdlog = par$sigma2)
plot(x2, exact, type = 'p', ylab = "Density")
lines(x2, aeDensity(x2 = x2, ae = margin2, order = 3), col = 2)


## End(Not run)
</code></pre>

<hr>
<h2 id='aeMean'>Asymptotic Expansion - Mean</h2><span id='topic+aeMean'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeMean(ae, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeMean_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeMean_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeMean_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# expansion order max
aeMean(ae = approx)

# expansion order 1
aeMean(ae = approx, order = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeMoment'>Asymptotic Expansion - Moments</h2><span id='topic+aeMoment'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeMoment(ae, m = 1, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeMoment_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeMoment_+3A_m">m</code></td>
<td>
<p>integer. The moment order. In case of multidimensional processes, it is possible to compute cross-moments by providing a vector of the same length as the state variables.</p>
</td></tr>
<tr><td><code id="aeMoment_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeMoment_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# second moment, expansion order max
aeMoment(ae = approx, m = 2)

# second moment, expansion order 3
aeMoment(ae = approx, m = 2, order = 3)

# second moment, expansion order 2
aeMoment(ae = approx, m = 2, order = 2)

# second moment, expansion order 1
aeMoment(ae = approx, m = 2, order = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeSd'>Asymptotic Expansion - Standard Deviation</h2><span id='topic+aeSd'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Standard Deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeSd(ae, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeSd_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeSd_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeSd_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# expansion order max
aeSd(ae = approx)

# expansion order 1
aeSd(ae = approx, order = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='aeSkewness'>Asymptotic Expansion - Skewness</h2><span id='topic+aeSkewness'></span>

<h3>Description</h3>

<p>Asymptotic Expansion - Skewness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aeSkewness(ae, eps = 1, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aeSkewness_+3A_ae">ae</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.ae-class">yuima.ae-class</a></code>.</p>
</td></tr>
<tr><td><code id="aeSkewness_+3A_eps">eps</code></td>
<td>
<p>numeric. The intensity of the perturbation.</p>
</td></tr>
<tr><td><code id="aeSkewness_+3A_order">order</code></td>
<td>
<p>integer. The expansion order. If <code>NULL</code> (default), it uses the maximum order used in <code>ae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# model
gbm &lt;- setModel(drift = 'mu*x', diffusion = 'sigma*x', solve.variable = 'x')

# settings
xinit &lt;- 100
par &lt;- list(mu = 0.01, sigma = 0.2)
sampling &lt;- setSampling(Initial = 0, Terminal = 1, n = 1000)

# asymptotic expansion
approx &lt;- ae(model = gbm, sampling = sampling, order = 4, true.parameter = par, xinit = xinit)

# expansion order max
aeSkewness(ae = approx)

# expansion order 1
aeSkewness(ae = approx, order = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='asymptotic_term'>asymptotic expansion of the expected value of the functional</h2><span id='topic+asymptotic_term'></span><span id='topic+asymptotic_term+2Cyuima-method'></span>

<h3>Description</h3>

<p>calculate the fisrt and second term of asymptotic expansion of the functional mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymptotic_term(yuima, block=100, rho, g, expand.var="e")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asymptotic_term_+3A_yuima">yuima</code></td>
<td>
<p>an yuima object containing model and functional.</p>
</td></tr>
<tr><td><code id="asymptotic_term_+3A_block">block</code></td>
<td>
<p>the number of trapezoids for integrals.</p>
</td></tr>
<tr><td><code id="asymptotic_term_+3A_rho">rho</code></td>
<td>
<p>specify discounting factor in mean integral.</p>
</td></tr>
<tr><td><code id="asymptotic_term_+3A_g">g</code></td>
<td>
<p>arbitrary measurable function for mean integral.</p>
</td></tr>
<tr><td><code id="asymptotic_term_+3A_expand.var">expand.var</code></td>
<td>
<p>default expand.var=&quot;e&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the first and second term of asymptotic expansion of the expected value of the functional associated with a sde. The returned value d0 + epsilon * d1 is approximation of the expected value.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>terms</code></td>
<td>
<p>list of 1st and 2nd asymptotic terms, terms$d0 and terms$d1.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>we need to fix this routine.
</p>


<h3>Author(s)</h3>

<p>YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to the Black-Scholes economy:
# dXt^e = Xt^e * dt + e * Xt^e * dWt
diff.matrix &lt;- "x*e"
model &lt;- setModel(drift = "x", diffusion = diff.matrix)
# call option is evaluated by averating
# max{ (1/T)*int_0^T Xt^e dt, 0}, the first argument is the functional of interest:
Terminal &lt;- 1
xinit &lt;- c(1)
f &lt;- list( c(expression(x/Terminal)), c(expression(0)))
F &lt;- 0
division &lt;- 1000
e &lt;- .3
yuima &lt;- setYuima(model = model, sampling = setSampling(Terminal=Terminal, n=division))
yuima &lt;- setFunctional( yuima, f=f,F=F, xinit=xinit,e=e)

# asymptotic expansion
rho &lt;- expression(0)
F0 &lt;- F0(yuima)
get_ge &lt;- function(x,epsilon,K,F0){
  tmp &lt;- (F0 - K) + (epsilon * x) 
  tmp[(epsilon * x) &lt; (K-F0)] &lt;- 0
  return( tmp )
}
g &lt;- function(x) get_ge(x,epsilon=e,K=1,F0=F0)
set.seed(123)
asymp &lt;- asymptotic_term(yuima, block=10, rho,g)
asymp
sum(asymp$d0 + e * asymp$d1)


### An example of multivariate case: Heston model
## a &lt;- 1;C &lt;- 1;d &lt;- 10;R&lt;-.1
## diff.matrix &lt;- matrix( c("x1*sqrt(x2)*e", "e*R*sqrt(x2)",0,"sqrt(x2*(1-R^2))*e"), 2,2)
## model &lt;- setModel(drift = c("a*x1","C*(10-x2)"), 
## diffusion = diff.matrix,solve.variable=c("x1","x2"),state.variable=c("x1","x2"))
## call option is evaluated by averating
## max{ (1/T)*int_0^T Xt^e dt, 0}, the first argument is the functional of interest:
##
## Terminal &lt;- 1
## xinit &lt;- c(1,1)
## 
## f &lt;- list( c(expression(0), expression(0)),   
## c(expression(0), expression(0)) , c(expression(0), expression(0))  )
## F &lt;- expression(x1,x2)
## 
## division &lt;- 1000
## e &lt;- .3
## 
## yuima &lt;- setYuima(model = model, sampling = setSampling(Terminal=Terminal, n=division))
## yuima &lt;- setFunctional( yuima, f=f,F=F, xinit=xinit,e=e)
## 
## rho &lt;- expression(x1)
## F0 &lt;- F0(yuima)
## get_ge &lt;- function(x){
##  return( max(x[1],0))
## }
## g &lt;- function(x) get_ge(x)
## set.seed(123)
## asymp &lt;- asymptotic_term(yuima, block=10, rho,g)
## sum(asymp$d0 + e * asymp$d1)


## End(Not run)
</code></pre>

<hr>
<h2 id='bns.test'>
Barndorff-Nielsen and Shephard's Test for the Presence of Jumps Using Bipower Variation
</h2><span id='topic+bns.test'></span><span id='topic+bns.test+2Cyuima-method'></span><span id='topic+bns.test+2Cyuima.data-method'></span><span id='topic+bns.test+2Clist-method'></span>

<h3>Description</h3>

<p>Tests the presence of jumps using the statistic proposed in Barndorff-Nielsen and Shephard (2004,2006) for each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bns.test(yuima, r = rep(1, 4), type = "standard", adj = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bns.test_+3A_yuima">yuima</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="bns.test_+3A_r">r</code></td>
<td>

<p>a vector of non-negative numbers or a list of vectors of non-negative numbers. Theoretically, it is necessary that <code>sum(r)=4</code> and <code>max(r)&lt;2</code>.
</p>
</td></tr>
<tr><td><code id="bns.test_+3A_type">type</code></td>
<td>

<p>type of the test statistic to use. <code>standard</code> is default.
</p>
</td></tr>
<tr><td><code id="bns.test_+3A_adj">adj</code></td>
<td>

<p>logical; if <code>TRUE</code>, the maximum adjustment suggested in Barndorff-Nielsen and Shephard (2004) is applied to the test statistic when <code>type</code> is equal to either &ldquo;<code>log</code>&rdquo; or &ldquo;<code>ratio</code>&rdquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>i</code>-th component, the test statistic is equal to the <code>i</code>-th component of <code>sqrt(n)*(mpv(yuima,2)-mpv(yuima,c(1,1)))/sqrt(vartheta*mpv(yuima,r))</code> when <code>type="standard"</code>, <code>sqrt(n)*log(mpv(yuima,2)/mpv(yuima,c(1,1)))/sqrt(vartheta*mpv(yuima,r)/mpv(yuima,c(1,1))^2)</code> when <code>type="log"</code> and <code>sqrt(n)*(1-mpv(yuima,c(1,1))/mpv(yuima,2))/sqrt(vartheta*mpv(yuima,r)/mpv(yuima,c(1,1))^2)</code> when <code>type="ratio"</code>. Here, <code>n</code> is equal to the length of the <code>i</code>-th component of the <code>zoo.data</code> of <code>yuima</code> minus 1 and <code>vartheta</code> is <code>pi^2/4+pi-5</code>. When <code>adj=TRUE</code>, <code>mpv(yuima,r)[i]/mpv(yuima,c(1,1))^2)[i]</code> is replaced with 1 if it is less than 1.
</p>


<h3>Value</h3>

<p>A list with the same length as the <code>zoo.data</code> of <code>yuima</code>. Each component of the list has class &ldquo;<code>htest</code>&rdquo; and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic of the corresponding component of the <code>zoo.data</code> of <code>yuima</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>an approximate p-value for the test of the corresponding component.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;<code>Barndorff-Nielsen and Shephard jump test</code>&rdquo;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the character string &ldquo;<code>xi</code>&rdquo;, where <code>i</code> is the number of the component.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Theoretically, this test may be invalid if sampling is irregular.
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. E. and Shephard, N. (2004)
Power and bipower variation with stochastic volatility and jumps,
<em>Journal of Financial Econometrics</em>, <b>2</b>, no. 1, 1&ndash;37.
</p>
<p>Barndorff-Nielsen, O. E. and Shephard, N. (2006)
Econometrics of testing for jumps in financial economics using bipower variation,
<em>Journal of Financial Econometrics</em>, <b>4</b>, no. 1, 1&ndash;30.
</p>
<p>Huang, X. and Tauchen, G. (2005)
The relative contribution of jumps to total price variance,
<em>Journal of Financial Econometrics</em>, <b>3</b>, no. 4, 456&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm.jumptest">lm.jumptest</a></code>, <code><a href="#topic+mpv">mpv</a></code>, <code><a href="#topic+minrv.test">minrv.test</a></code>, <code><a href="#topic+medrv.test">medrv.test</a></code>, <code><a href="#topic+pz.test">pz.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# One-dimensional case
## Model: dXt=t*dWt+t*dzt, 
## where zt is a compound Poisson process with intensity 5 and jump sizes distribution N(0,0.1).

model &lt;- setModel(drift=0,diffusion="t",jump.coeff="t",measure.type="CP",
                  measure=list(intensity=5,df=list("dnorm(z,0,sqrt(0.1))")),
                  time.variable="t")

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima) # The path seems to involve some jumps

bns.test(yuima) # standard type

bns.test(yuima,type="log") # log type

bns.test(yuima,type="ratio") # ratio type

# Multi-dimensional case
## Model: dXkt=t*dWk_t (k=1,2,3) (no jump case).

diff.matrix &lt;- diag(3)
diag(diff.matrix) &lt;- c("t","t","t")
model &lt;- setModel(drift=c(0,0,0),diffusion=diff.matrix,time.variable="t",
                  solve.variable=c("x1","x2","x3"))

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima)

bns.test(yuima)

</code></pre>

<hr>
<h2 id='carma.info-class'>Class for information about CARMA(p,q) model</h2><span id='topic+carma.info-class'></span>

<h3>Description</h3>

<p>The <code>carma.info-class</code> is a class of the  <span class="pkg">yuima</span> package.  
</p>


<h3>Details</h3>

<p>The <code>carma.info-class</code> object cannot be directly specified by the user
but it is constructed when the <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code> object is
constructed via <code><a href="#topic+setCarma">setCarma</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>p</code>:</dt><dd><p>Number of autoregressive coefficients.</p>
</dd>
<dt><code>q</code>:</dt><dd><p>Number of moving average coefficients.</p>
</dd>
<dt><code>loc.par</code>:</dt><dd><p>Label of location coefficient.</p>
</dd>
<dt><code>scale.par</code>:</dt><dd><p>Label of scale coefficient.</p>
</dd>
<dt><code>ar.par</code>:</dt><dd><p>Label of autoregressive coefficients.</p>
</dd>
<dt><code>ma.par</code>:</dt><dd><p>Label of moving average coefficients.</p>
</dd>
<dt><code>lin.par</code>:</dt><dd><p>Label of linear coefficients.</p>
</dd>
<dt><code>Carma.var</code>:</dt><dd><p>Label of the observed process.</p>
</dd>
<dt><code>Latent.var</code>:</dt><dd><p>Label of the unobserved process.</p>
</dd>
<dt><code>XinExpr</code>:</dt><dd><p>Logical variable. If <code>XinExpr=FALSE</code>, the starting condition of <code>Latent.var</code> is zero otherwise each component of Latent.var has a parameter as a starting point. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='carmaHawkes.info-class'>Class for information on the Hawkes process with a CARMA(p,q) intensity</h2><span id='topic+carmaHawkes.info-class'></span>

<h3>Description</h3>

<p>The <code>carmaHawkes.info-class</code> is a class of the  <span class="pkg">yuima</span> package.  
</p>


<h3>Details</h3>

<p>The <code>carmaHawkes.info-class</code> object cannot be directly specified by the user
but it is constructed when the <code><a href="#topic+yuima.carmaHawkes-class">yuima.carmaHawkes-class</a></code> object is
constructed via <code><a href="#topic+setCarmaHawkes">setCarmaHawkes</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>p</code>:</dt><dd><p>Number of autoregressive coefficients.</p>
</dd>
<dt><code>q</code>:</dt><dd><p>Number of moving average coefficients.</p>
</dd>
<dt><code>Counting.Process</code>:</dt><dd><p>Label of Counting process.</p>
</dd>
<dt><code>base.Int</code>:</dt><dd><p>Label of baseline Intensity parameter.</p>
</dd>
<dt><code>ar.par</code>:</dt><dd><p>Label of autoregressive coefficients.</p>
</dd>
<dt><code>ma.par</code>:</dt><dd><p>Label of moving average coefficients.</p>
</dd>
<dt><code>Intensity.var</code>:</dt><dd><p>Label of the Intensity process.</p>
</dd>
<dt><code>Latent.var</code>:</dt><dd><p>Label of the unobserved process.</p>
</dd>
<dt><code>XinExpr</code>:</dt><dd><p>Logical variable. If <code>XinExpr=FALSE</code>, the starting condition of <code>Latent.var</code> is zero otherwise each component of Latent.var has a parameter as a starting point. </p>
</dd>
<dt><code>Type.Jump</code>:</dt><dd><p>Logical variable. If <code>XinExpr=TRUE</code>, the jump size is deterministic</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='CarmaNoise'>Estimation for the underlying Levy in a carma model</h2><span id='topic+Recovering.Noise'></span><span id='topic+Carma.Recovering'></span><span id='topic+CarmaRecovNoise'></span><span id='topic+CarmaNoise'></span><span id='topic+Levy.Carma'></span>

<h3>Description</h3>

<p>Retrieve the increment of the underlying Levy for the carma(p,q) process using the approach developed in Brockwell et al.(2011)</p>


<h3>Usage</h3>

<pre><code class='language-R'>CarmaNoise(yuima, param, data=NULL, NoNeg.Noise=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CarmaNoise_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object or an object of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>.</p>
</td></tr>
<tr><td><code id="CarmaNoise_+3A_param">param</code></td>
<td>
<p><code>list</code> of parameters for the carma.</p>
</td></tr>
<tr><td><code id="CarmaNoise_+3A_data">data</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> contains the observations available at uniformly spaced time. If <code>data=NULL</code>, the default, the 'CarmaNoise' uses the data in an object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.</p>
</td></tr>
<tr><td><code id="CarmaNoise_+3A_noneg.noise">NoNeg.Noise</code></td>
<td>
<p>Estimate a non-negative Levy-Driven Carma process. By default <code>NoNeg.Noise=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<table role = "presentation">
<tr><td><code>incr.Levy</code></td>
<td>
<p>a numeric object contains the estimated increments.</p>
</td></tr>
</table>


<h3>Note</h3>


<p>The function <code>qmle</code> uses the function <code>CarmaNoise</code> for estimation of underlying Levy in the carma model.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Brockwell, P., Davis, A. R. and Yang. Y. (2011)
Estimation for Non-Negative Levy-Driven CARMA Process, <em>Journal of Business And Economic Statistics</em>, <b>29</b> - 2, 250-259.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Ex.1: Carma(p=3, q=0) process driven by a brownian motion.

mod0&lt;-setCarma(p=3,q=0)

# We fix the autoregressive and moving average parameters
# to ensure the existence of a second order stationary solution for the process.

true.parm0 &lt;-list(a1=4,a2=4.75,a3=1.5,b0=1)

# We simulate a trajectory of the Carma model.

numb.sim&lt;-1000
samp0&lt;-setSampling(Terminal=100,n=numb.sim)
set.seed(100)
incr.W&lt;-matrix(rnorm(n=numb.sim,mean=0,sd=sqrt(100/numb.sim)),1,numb.sim)

sim0&lt;-simulate(mod0,
               true.parameter=true.parm0,
               sampling=samp0, increment.W=incr.W)

#Applying the CarmaNoise

system.time(
  inc.Levy0&lt;-CarmaNoise(sim0,true.parm0)
)

# We compare the orginal with the estimated noise increments 

par(mfrow=c(1,2))
plot(t(incr.W)[1:998],type="l", ylab="",xlab="time")
title(main="True Brownian Motion",font.main="1")
plot(inc.Levy0,type="l", main="Filtered Brownian Motion",font.main="1",ylab="",xlab="time")

# Ex.2: carma(2,1) driven  by a compound poisson
# where jump size is normally distributed and
# the lambda is equal to 1.

mod1&lt;-setCarma(p=2,               
               q=1,
               measure=list(intensity="Lamb",df=list("dnorm(z, 0, 1)")),
               measure.type="CP") 

true.parm1 &lt;-list(a1=1.39631, a2=0.05029,
                  b0=1,b1=2,
                  Lamb=1)

# We generate a sample path.

samp1&lt;-setSampling(Terminal=100,n=200)
set.seed(123)
sim1&lt;-simulate(mod1,
               true.parameter=true.parm1,
               sampling=samp1)

# We estimate the parameter using qmle.
carmaopt1 &lt;- qmle(sim1, start=true.parm1)
summary(carmaopt1)
# Internally qmle uses CarmaNoise. The result is in 
plot(carmaopt1)

# Ex.3: Carma(p=2,q=1) with scale and location parameters 
# driven by a Compound Poisson
# with jump size normally distributed.
mod2&lt;-setCarma(p=2,                
               q=1,
               loc.par="mu",
               scale.par="sig",
               measure=list(intensity="Lamb",df=list("dnorm(z, 0, 1)")),
               measure.type="CP") 

true.parm2 &lt;-list(a1=1.39631,
                  a2=0.05029,
                  b0=1,
                  b1=2,
                  Lamb=1,
                  mu=0.5,
                  sig=0.23)
# We simulate the sample path 
set.seed(123)
sim2&lt;-simulate(mod2,
               true.parameter=true.parm2,
               sampling=samp1)

# We estimate the Carma and we plot the underlying noise.

carmaopt2 &lt;- qmle(sim2, start=true.parm2)
summary(carmaopt2)

# Increments estimated by CarmaNoise
plot(carmaopt2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cce'>
Nonsynchronous Cumulative Covariance Estimator
</h2><span id='topic+cce'></span>

<h3>Description</h3>

<p>This function estimates the covariance between two Ito processes when they are observed at discrete times possibly nonsynchronously. It can apply to 
irregularly sampled one-dimensional data as a special case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cce(x, method="HY", theta, kn, g=function(x)min(x,1-x), refreshing = TRUE,
    cwise = TRUE, delta = 0, adj = TRUE, K, c.two, J = 1, c.multi, kernel, H,
    c.RK, eta = 3/5, m = 2, ftregion = 0, vol.init = NA,
    covol.init = NA, nvar.init = NA, ncov.init = NA, mn, alpha = 0.4,
    frequency = 300, avg = TRUE, threshold, utime, psd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cce_+3A_x">x</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="cce_+3A_method">method</code></td>
<td>

<p>the method to be used. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cce_+3A_theta">theta</code></td>
<td>

<p>a numeric vector or matrix. If it is a matrix, each of its components   indicates the tuning parameter which determines the pre-averaging window lengths <code>kn</code> to be used for estimating the corresponding component. If it is a numeric vector, it is converted to a matrix as <code>(C+t(C))/2</code>, where <code>C=matrix(theta,d,d)</code> and <code>d=dim(x)</code>. The default value is <code>0.15</code> for the method <code>"PHY"</code> or <code>"PTHY"</code> following Christensen et al. (2013), while it is <code>1</code> for the method <code>"MRC"</code> following Christensen et al. (2010). 
</p>
</td></tr>
<tr><td><code id="cce_+3A_kn">kn</code></td>
<td>

<p>an integer-valued vector or matrix indicating the pre-averaging window length(s). For the methods <code>"PHY"</code> or <code>"PTHY"</code>, see &lsquo;Details&rsquo; for the default value. For the method <code>"MRC"</code>, the default value is <code>ceiling(theta*n^(1+delta))</code>, where <code>n</code> is the number of the refresh times associated with the data minus 1.  
</p>
</td></tr>
<tr><td><code id="cce_+3A_g">g</code></td>
<td>

<p>a function indicating the weight function to be used. The default value is the Bartlett window: <code>function(x)min(x,1-x)</code>.
</p>
</td></tr>
<tr><td><code id="cce_+3A_refreshing">refreshing</code></td>
<td>

<p>logical. If <code>TRUE</code>, the data is pre-synchronized by the next-tick interpolation in the refresh times.
</p>
</td></tr>
<tr><td><code id="cce_+3A_cwise">cwise</code></td>
<td>

<p>logical. If <code>TRUE</code>, the estimator is calculated componentwise.
</p>
</td></tr>
<tr><td><code id="cce_+3A_delta">delta</code></td>
<td>

<p>a non-negative number indicating the order of the pre-averaging window length(s) <code>kn</code>.
</p>
</td></tr>
<tr><td><code id="cce_+3A_adj">adj</code></td>
<td>

<p>logical. If <code>TRUE</code>, a finite-sample adjustment is performed. For the method <code>"MRC"</code>, see Christensen et al. (2010) for details. For the method <code>"TSCV"</code>, see Zhang (2011) and Zhang et al. (2005) for details.
</p>
</td></tr>
<tr><td><code id="cce_+3A_k">K</code></td>
<td>

<p>a positive integer indicating the large time-scale parameter. The default value is <code>ceiling(c.two*n^(2/3))</code>, where <code>n</code> is the number of the refresh times associated with the data minus 1.
</p>
</td></tr>
<tr><td><code id="cce_+3A_c.two">c.two</code></td>
<td>

<p>a positive number indicating the tuning parameter which determines the scale of the large time-scale parameter <code>K</code>. The default value is the average of the  numeric vector each of whose components is the roughly estimated optimal value in the sense of the minimizer of the theoretical asymptotic variance of the estimator of the corresponding diagonal component. The theoretical asymptotic variance is considered in the standard case and given by Eq.(63) of Zhang et al. (2005).
</p>
</td></tr>
<tr><td><code id="cce_+3A_j">J</code></td>
<td>

<p>a positive integer indicating the small time-scale parameter.
</p>
</td></tr>
<tr><td><code id="cce_+3A_c.multi">c.multi</code></td>
<td>

<p>a numeric vector or matrix. If it is a matrix, each of its components   indicates the tuning parameter which determines (the scale of) the number of the time scales to be used for estimating the corresponding component. If it is a numeric vector, it is converted to a matrix as <code>(C+t(C))/2</code>, where <code>C=matrix(c.multi,d,d)</code> and <code>d=dim(x)</code>. The default value is the numeric vector each of whose components is the roughly estimated optimal value in the sense of minimizing the theoretical asymptotic variance of the estimator of the corresponding diagonal component. The theoretical asymptotic variance is considered in the standard case and given by Eq.(37) of Zhang (2006).
</p>
</td></tr>
<tr><td><code id="cce_+3A_kernel">kernel</code></td>
<td>

<p>a function indicating the kernel function to be used. The default value is the Parzan kernel, which is recommended in Barndorff-Nielsen et al. (2009, 2011).
</p>
</td></tr>
<tr><td><code id="cce_+3A_h">H</code></td>
<td>

<p>a positive number indicating the bandwidth parameter. The default value is <code>c.RK*n^eta</code>, where <code>n</code> is the number of the refresh times associated with the data minus 1.
</p>
</td></tr>
<tr><td><code id="cce_+3A_c.rk">c.RK</code></td>
<td>

<p>a positive number indicating the tuning parameter which determines the scale of the bandwidth parameter <code>H</code>. The default value is the average of the numeric vector each of whose components is the roughly estimated optimal value in the sense of minimizing the theoretical asymptotic variance of the estimator of the corresponding diagonal component. The theoretical asymptotic variance is considered in the standard case and given in Barndorff-Nielsen et al. (2009, 2011).
</p>
</td></tr>
<tr><td><code id="cce_+3A_eta">eta</code></td>
<td>

<p>a positive number indicating the tuning parameter which determines the order of the bandwidth parameter <code>H</code>.
</p>
</td></tr>
<tr><td><code id="cce_+3A_m">m</code></td>
<td>

<p>a positive integer indicating the number of the end points to be jittered.
</p>
</td></tr>
<tr><td><code id="cce_+3A_ftregion">ftregion</code></td>
<td>

<p>a non-negative number indicating the length of the flat-top region. <code>ftregion=0</code> (the default) means that a non-flat-top realized kernel studied in Barndorff-Nielsen et al. (2011) is used. <code>ftregion=1/H</code> means that a flat-top realized kernel studied in Barndorff-Nielsen et al. (2008) is used. See Varneskov (2015) for other values. 
</p>
</td></tr>
<tr><td><code id="cce_+3A_vol.init">vol.init</code></td>
<td>

<p>a numeric vector each of whose components indicates the initial value to be used to estimate the integrated volatility of the corresponding component, which is passed to the optimizer. 
</p>
</td></tr>
<tr><td><code id="cce_+3A_covol.init">covol.init</code></td>
<td>

<p>a numeric matrix each of whose columns indicates the initial value to be used to estimate the integrated covariance of the corresponding component, which is passed to the optimizer. 
</p>
</td></tr>
<tr><td><code id="cce_+3A_nvar.init">nvar.init</code></td>
<td>

<p>a numeric vector each of whose components indicates the initial value to be used to estimate the variance of noise of the corresponding component, which is passed to the optimizer. 
</p>
</td></tr>
<tr><td><code id="cce_+3A_ncov.init">ncov.init</code></td>
<td>

<p>a numeric matrix each of whose columns indicates the initial value to be used to estimate the covariance of noise of the corresponding component, which is passed to the optimizer. 
</p>
</td></tr>
<tr><td><code id="cce_+3A_mn">mn</code></td>
<td>

<p>a positive integer indicating the number of terms to be used for calculating the SIML estimator. The default value is <code>ceiling(n^alpha)</code>, where <code>n</code> is the number of the refresh times associated with the data minus 1.
</p>
</td></tr>
<tr><td><code id="cce_+3A_alpha">alpha</code></td>
<td>

<p>a postive number indicating the order of <code>mn</code>.
</p>
</td></tr>
<tr><td><code id="cce_+3A_frequency">frequency</code></td>
<td>

<p>a positive integer indicating the frequency (seconds) of the calendar time sampling to be used.
</p>
</td></tr>
<tr><td><code id="cce_+3A_avg">avg</code></td>
<td>

<p>logical. If <code>TRUE</code>, the averaged subsampling estimator is calculated. Otherwise the simple sparsely subsampled estimator is calculated.
</p>
</td></tr>
<tr><td><code id="cce_+3A_threshold">threshold</code></td>
<td>

<p>a numeric vector or list indicating the threshold parameter(s). Each of its components indicates the threshold parameter or process to be used for estimating the corresponding component. If it is a numeric vector, the elements in <code>threshold</code> are recycled if there are two few elements in <code>threshold</code>. The default value is determined following Koike (2014) (for the method <code>"THY"</code>) and Koike (2015) (for the method <code>"PTHY"</code>).
</p>
</td></tr>
<tr><td><code id="cce_+3A_utime">utime</code></td>
<td>

<p>a positive number indicating what seconds the interval [0,1] corresponds to. 
The default value is the difference between the maximum and the minimum of the sampling times, multiplied by 23,400. Here, 23,400 seconds correspond to 6.5 hours, hence if the data is sampled on the interval [0,1], then the sampling interval is regarded as 6.5 hours. 
</p>
</td></tr>
<tr><td><code id="cce_+3A_psd">psd</code></td>
<td>

<p>logical. If <code>TRUE</code>, the estimated covariance matrix <code>C</code> is converted to <code>(C%*%C)^(1/2)</code> for ensuring the positive semi-definiteness. In this case the absolute values of the estimated correlations are always ensured to be less than or equal to 1. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for objects of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> and <code><a href="#topic+yuima-class">yuima-class</a></code>.
It extracts the <code>data</code> slot when applied to a an object of <code><a href="#topic+yuima-class">yuima-class</a></code>.
</p>
<p>Typical usages are
</p>
<pre>
cce(x,psd=FALSE)
cce(x,method="PHY",theta,kn,g,refreshing=TRUE,cwise=TRUE,psd=FALSE)
cce(x,method="MRC",theta,kn,g,delta=0,avg=TRUE,psd=FALSE)
cce(x,method="TSCV",K,c.two,J=1,adj=TRUE,utime,psd=FALSE)
cce(x,method="GME",c.multi,utime,psd=FALSE)
cce(x,method="RK",kernel,H,c.RK,eta=3/5,m=2,ftregion=0,utime,psd=FALSE)
cce(x,method="QMLE",vol.init=NULL,covol.init=NULL,
    nvar.init=NULL,ncov.init=NULL,psd=FALSE)
cce(x,method="SIML",mn,alpha=0.4,psd=FALSE)
cce(x,method="THY",threshold,psd=FALSE)
cce(x,method="PTHY",theta,kn,g,threshold,refreshing=TRUE,cwise=TRUE,psd=FALSE)
cce(x,method="SRC",frequency=300,avg=TRUE,utime,psd=FALSE)
cce(x,method="SBPC",frequency=300,avg=TRUE,utime,psd=FALSE)
</pre>
<p>The default method is method <code>"HY"</code>, which is an implementation of the Hayashi-Yoshida estimator proposed in Hayashi and Yoshida (2005).
<br />
<br />
Method <code>"PHY"</code> is an implementation of the Pre-averaged Hayashi-Yoshida estimator proposed in Christensen et al. (2010).
<br />
<br />
Method <code>"MRC"</code> is an implementation of the Modulated Realized Covariance based on refresh time sampling proposed in Christensen et al. (2010).
<br />
<br />
Method <code>"TSCV"</code> is an implementation of the previous tick Two Scales realized CoVariance based on refresh time sampling proposed in Zhang (2011).
<br />
<br />
Method <code>"GME"</code> is an implementation of the Generalized Multiscale Estimator proposed in Bibinger (2011).
<br />
<br />
Method <code>"RK"</code> is an implementation of the multivariate Realized Kernel based on refresh time sampling proposed in Barndorff-Nielsen et al. (2011).
<br />
<br />
Method <code>"QMLE"</code> is an implementation of the nonparametric Quasi Maximum Likelihood Estimator proposed in Ait-Sahalia et al. (2010).
<br />
<br />
Method <code>"SIML"</code> is an implementation of the Separating Information Maximum Likelihood estimator proposed in Kunitomo and Sato (2013) with the basis of refresh time sampling.
<br />
<br />
Method <code>"THY"</code> is an implementation of the Truncated Hayashi-Yoshida estimator proposed in Mancini and Gobbi (2012).
<br />
<br />
Method <code>"PTHY"</code> is an implementation of the Pre-averaged Truncated Hayashi-Yoshida estimator, which is a thresholding version of the pre-averaged Hayashi-Yoshida estimator.
<br />
<br />
Method <code>"SRC"</code> is an implementation of the calendar time Subsampled Realized Covariance.
<br />
<br />
Method <code>"SBPC"</code> is an implementation of the calendar time Subsampled realized BiPower Covariation.
<br />
<br />
The rough estimation procedures for selecting the default values of the tuning parameters are based on those in Barndorff-Nielsen et al. (2009).
<br />
<br />
For the methods <code>"PHY"</code> or <code>"PTHY"</code>, the default value of <code>kn</code> changes depending on the values of <code>refreshing</code> and <code>cwise</code>. If both <code>refreshing</code> and <code>cwise</code> are <code>TRUE</code> (the default), the default value of <code>kn</code> is given by the matrix <code>ceiling(theta*N)</code>, where <code>N</code> is a matrix whose diagonal components are identical with the vector <code>length(x)-1</code> and whose <code class="reqn">(i,j)</code>-th component is identical with the number of the refresh times associated with <code class="reqn">i</code>-th and <code class="reqn">j</code>-th components of <code>x</code> minus 1. If <code>refreshing</code> is <code>TRUE</code> while <code>cwise</code> is <code>FALSE</code>, the default value of <code>kn</code> is given by <code>ceiling(mean(theta)*sqrt(n))</code>, where <code>n</code> is the number of the refresh times associated with the data minus 1. If <code>refreshing</code> is <code>FALSE</code> while <code>cwise</code> is <code>TRUE</code>, the default value of <code>kn</code> is given by the matrix <code>ceiling(theta*N0)</code>, where <code>N0</code> is a matrix whose diagonal components are identical with the vector <code>length(x)-1</code> and whose <code class="reqn">(i,j)</code>-th component is identical with <code>(length(x)[i]-1)+(length(x)[j]-1)</code>. If both <code>refreshing</code> and <code>cwise</code> are <code>FALSE</code>, the default value of <code>kn</code> is given by <code>ceiling(mean(theta)*sqrt(sum(length(x)-1)))</code> (following Christensen et al. (2013)).
<br />
<br />
For the method <code>"QMLE"</code>, the optimization of the quasi-likelihood function is implemented via <a href="stats.html#topic+arima0">arima0</a> using the fact that it can be seen as an MA(1) model's one: See Hansen et al. (2008) for details.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>covmat</code></td>
<td>
<p>the estimated covariance matrix</p>
</td></tr>
<tr><td><code>cormat</code></td>
<td>
<p>the estimated correlation matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The example shows the central limit theorem for the nonsynchronous 
covariance estimator.  
Estimation of the asymptotic variance can be implemented by <code><a href="#topic+hyavar">hyavar</a></code>. 
The second-order correction will be provided in a future version of the package.
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Ait-Sahalia, Y., Fan, J. and Xiu, D. (2010)
High-frequency covariance estimates with noisy and asynchronous financial data,
<em>Journal of the American Statistical Association</em>, <b>105</b>, no. 492, 1504&ndash;1517.
</p>
<p>Barndorff-Nielsen, O. E., Hansen, P. R., Lunde, A. and Shephard, N. (2008)
Designing realised kernels to measure the ex-post variation of equity prices in the presence of noise,
<em>Econometrica</em>, <b>76</b>, no. 6, 1481&ndash;1536.
</p>
<p>Barndorff-Nielsen, O. E., Hansen, P. R., Lunde, A. and Shephard, N. (2009)
Realized kernels in practice: trades and quotes,
<em>Econometrics Journal</em>, <b>12</b>, C1&ndash;C32.
</p>
<p>Barndorff-Nielsen, O. E., Hansen, P. R., Lunde, A. and Shephard, N. (2011)
Multivariate realised kernels: Consistent positive semi-definite estimators of the covariation of equity prices with noise and non-synchronous trading,
<em>Journal of Econometrics</em>, <b>162</b>, 149&ndash;169.
</p>
<p>Bibinger, M. (2011)
Efficient covariance estimation for asynchronous noisy high-frequency data,
<em>Scandinavian Journal of Statistics</em>, <b>38</b>, 23&ndash;45.
</p>
<p>Bibinger, M. (2012)
An estimator for the quadratic covariation of asynchronously observed Ito processes with noise: asymptotic distribution theory,
<em>Stochastic processes and their applications</em>, <b>122</b>, 2411&ndash;2453.
</p>
<p>Christensen, K., Kinnebrock, S. and Podolskij, M. (2010)
Pre-averaging estimators of the ex-post covariance matrix in noisy diffusion models with non-synchronous data,
<em>Journal of Econometrics</em>, <b>159</b>, 116&ndash;133.
</p>
<p>Christensen, K., Podolskij, M. and Vetter, M. (2013)
On covariation estimation for multivariate continuous Ito semimartingales with noise in non-synchronous observation schemes,
<em>Journal of Multivariate Analysis</em> <b>120</b> 59&ndash;84.
</p>
<p>Hansen, P. R., Large, J. and Lunde, A. (2008)
Moving average-based estimators of integrated variance,
<em>Econometric Reviews</em>, <b>27</b>, 79&ndash;111.
</p>
<p>Hayashi, T. and Yoshida, N. (2005)
On covariance estimation of non-synchronously observed diffusion processes,
<em>Bernoulli</em>, <b>11</b>, no. 2, 359&ndash;379.
</p>
<p>Hayashi, T. and Yoshida, N. (2008)
Asymptotic normality of a covariance estimator for nonsynchronously observed diffusion processes, 
<em>Annals of the Institute of Statistical Mathematics</em>, <b>60</b>, no. 2, 367&ndash;406.
</p>
<p>Koike, Y. (2016)
Estimation of integrated covariances in the simultaneous presence of nonsynchronicity, microstructure noise and jumps,
<em>Econometric Theory</em>, <b>32</b>, 533&ndash;611.
</p>
<p>Koike, Y. (2014)
An estimator for the cumulative co-volatility of asynchronously observed semimartingales with jumps,
<em>Scandinavian Journal of Statistics</em>, <b>41</b>, 460&ndash;481.
</p>
<p>Kunitomo, N. and Sato, S. (2013)
Separating information maximum likelihood estimation of realized volatility and covariance with micro-market noise,
<em>North American Journal of Economics and Finance</em>, <b>26</b>, 282&ndash;309.
</p>
<p>Mancini, C. and Gobbi, F. (2012)
Identifying the Brownian covariation from the co-jumps given discrete observations,
<em>Econometric Theory</em>, <b>28</b>, 249&ndash;273.
</p>
<p>Varneskov, R. T. (2016)
Flat-top realized kernel estimation of quadratic covariation with non-synchronous and noisy asset prices,
<em>Journal of Business &amp; Economic Statistics</em>, <b>34</b>, no.1, 1&ndash;22.
</p>
<p>Zhang, L. (2006)
Efficient estimation of stochastic volatility using noisy observations: a multi-scale approach,
<em>Bernoulli</em>, <b>12</b>, no.6, 1019&ndash;1043.
</p>
<p>Zhang, L. (2011)
Estimating covariation: Epps effect, microstructure noise,
<em>Journal of Econometrics</em>, <b>160</b>, 33&ndash;47.
</p>
<p>Zhang, L., Mykland, P. A. and Ait-Sahalia, Y. (2005)
A tale of two time scales: Determining integrated volatility with noisy high-frequency data,
<em>Journal of the American Statistical Association</em>, <b>100</b>, no. 472, 1394&ndash;1411.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setModel">setModel</a></code>, <code><a href="#topic+setData">setData</a></code>, <code><a href="#topic+hyavar">hyavar</a></code>, <code><a href="#topic+lmm">lmm</a></code>, <code><a href="#topic+cce.factor">cce.factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Set a model
diff.coef.1 &lt;- function(t, x1 = 0, x2 = 0) sqrt(1+t)
diff.coef.2 &lt;- function(t, x1 = 0, x2 = 0) sqrt(1+t^2)
cor.rho &lt;- function(t, x1 = 0, x2 = 0) sqrt(1/2)
diff.coef.matrix &lt;- matrix(c("diff.coef.1(t,x1,x2)", 
"diff.coef.2(t,x1,x2) * cor.rho(t,x1,x2)", 
"", "diff.coef.2(t,x1,x2) * sqrt(1-cor.rho(t,x1,x2)^2)"), 2, 2) 
cor.mod &lt;- setModel(drift = c("", ""), 
diffusion = diff.coef.matrix,solve.variable = c("x1", "x2")) 

set.seed(111) 

## We use a function poisson.random.sampling to get observation by Poisson sampling.
yuima.samp &lt;- setSampling(Terminal = 1, n = 1200) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima) 
psample&lt;- poisson.random.sampling(yuima, rate = c(0.2,0.3), n = 1000) 

## cce takes the psample and returns an estimate of the quadratic covariation. 
cce(psample)$covmat[1, 2]
##cce(psample)[1, 2]

## True value of the quadratic covariation.
cc.theta &lt;- function(T, sigma1, sigma2, rho) { 
  tmp &lt;- function(t) return(sigma1(t) * sigma2(t) * rho(t)) 
	integrate(tmp, 0, T) 
}

theta &lt;- cc.theta(T = 1, diff.coef.1, diff.coef.2, cor.rho)$value 
cat(sprintf("theta =%.5f\n", theta))

names(psample@zoo.data)






# Example. A stochastic differential equation with nonlinear feedback. 

## Set a model
drift.coef.1 &lt;- function(x1,x2) x2
drift.coef.2 &lt;- function(x1,x2) -x1
drift.coef.vector &lt;- c("drift.coef.1","drift.coef.2")
diff.coef.1 &lt;- function(t,x1,x2) sqrt(abs(x1))*sqrt(1+t)
diff.coef.2 &lt;- function(t,x1,x2) sqrt(abs(x2))
cor.rho &lt;- function(t,x1,x2) 1/(1+x1^2)
diff.coef.matrix &lt;- matrix(c("diff.coef.1(t,x1,x2)", 
"diff.coef.2(t,x1,x2) * cor.rho(t,x1,x2)","", 
"diff.coef.2(t,x1,x2) * sqrt(1-cor.rho(t,x1,x2)^2)"), 2, 2) 
cor.mod &lt;- setModel(drift = drift.coef.vector,
 diffusion = diff.coef.matrix,solve.variable = c("x1", "x2"))

## Generate a path of the process
set.seed(111) 
yuima.samp &lt;- setSampling(Terminal = 1, n = 10000) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima, xinit=c(2,3)) 
plot(yuima)


## The "true" value of the quadratic covariation.
cce(yuima)

## We use the function poisson.random.sampling to generate nonsynchronous 
## observations by Poisson sampling.
psample&lt;- poisson.random.sampling(yuima, rate = c(0.2,0.3), n = 3000) 

## cce takes the psample to return an estimated value  of the quadratic covariation. 
## The off-diagonal elements are the value of the Hayashi-Yoshida estimator. 
cce(psample)




# Example. Epps effect for the realized covariance estimator

## Set a model
drift &lt;- c(0,0)

sigma1 &lt;- 1
sigma2 &lt;- 1
rho &lt;- 0.5

diffusion &lt;- matrix(c(sigma1,sigma2*rho,0,sigma2*sqrt(1-rho^2)),2,2)

model &lt;- setModel(drift=drift,diffusion=diffusion,
                  state.variable=c("x1","x2"),solve.variable=c("x1","x2"))
                  
## Generate a path of the latent process
set.seed(116)

## We regard the unit interval as 6.5 hours and generate the path on it 
## with the step size equal to 2 seconds

yuima.samp &lt;- setSampling(Terminal = 1, n = 11700) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)

## We extract nonsynchronous observations from the path generated above 
## by Poisson random sampling with the average duration equal to 10 seconds

psample &lt;- poisson.random.sampling(yuima, rate = c(1/5,1/5), n = 11700)

## Hayashi-Yoshida estimator consistetly estimates the true correlation
cce(psample)$cormat[1,2]

## If we synchronize the observation data on some regular grid 
## by previous-tick interpolations and compute the correlation 
## by therealized covariance based on such synchronized observations, 
## we underestimate the true correlation (known as the Epps effect). 
## This is illustrated by the following examples.

## Synchronization on the grid with 5 seconds steps
suppressWarnings(s1 &lt;- cce(subsampling(psample, sampling = setSampling(n = 4680)))$cormat[1,2])
s1

## Synchronization on the grid with 10 seconds steps
suppressWarnings(s2 &lt;- cce(subsampling(psample, sampling = setSampling(n = 2340)))$cormat[1,2])
s2

## Synchronization on the grid with 20 seconds steps
suppressWarnings(s3 &lt;- cce(subsampling(psample, sampling = setSampling(n = 1170)))$cormat[1,2])
s3

## Synchronization on the grid with 30 seconds steps
suppressWarnings(s4 &lt;- cce(subsampling(psample, sampling = setSampling(n = 780)))$cormat[1,2])
s4

## Synchronization on the grid with 1 minute steps
suppressWarnings(s5 &lt;- cce(subsampling(psample, sampling = setSampling(n = 390)))$cormat[1,2])
s5

plot(zoo(c(s1,s2,s3,s4,s5),c(5,10,20,30,60)),type="b",xlab="seconds",ylab="correlation",
main = "Epps effect for the realized covariance")



# Example. Non-synchronous and noisy observations of a correlated bivariate Brownian motion

## Generate noisy observations from the model used in the previous example
Omega &lt;- 0.005*matrix(c(1,rho,rho,1),2,2) # covariance matrix of noise
noisy.psample &lt;- noisy.sampling(psample,var.adj=Omega)
plot(noisy.psample)

## Hayashi-Yoshida estimator: inconsistent
cce(noisy.psample)$covmat

## Pre-averaged Hayashi-Yoshida estimator: consistent
cce(noisy.psample,method="PHY")$covmat

## Generalized multiscale estimator: consistent
cce(noisy.psample,method="GME")$covmat

## Multivariate realized kernel: consistent
cce(noisy.psample,method="RK")$covmat

## Nonparametric QMLE: consistent
cce(noisy.psample,method="QMLE")$covmat

## End(Not run)
</code></pre>

<hr>
<h2 id='cce.factor'>
High-Dimensional Cumulative Covariance Estimator by Factor Modeling and Regularization
</h2><span id='topic+cce.factor'></span>

<h3>Description</h3>

<p>This function estimates the covariance and precision matrices of a high-dimesnional Ito process by factor modeling and regularization when it is observed at discrete times possibly nonsynchronously with noise. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cce.factor(yuima, method = "HY", factor = NULL, PCA = FALSE, 
           nfactor = "interactive", regularize = "glasso", taper, 
           group = 1:(dim(yuima) - length(factor)), lambda = "bic", 
           weight = TRUE, nlambda = 10, ratio, N, thr.type = "soft", 
           thr = NULL, tau = NULL, par.alasso = 1, par.scad = 3.7, 
           thr.delta = 0.01, frequency = 300, utime, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cce.factor_+3A_yuima">yuima</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_method">method</code></td>
<td>

<p>the method to be used in <code><a href="#topic+cce">cce</a></code>.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_factor">factor</code></td>
<td>

<p>an integer or character vector indicating which components of <code>yuima</code> are factors. 
If <code>NULL</code>, no factor structure is taken account of.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_pca">PCA</code></td>
<td>

<p>logical. If <code>TRUE</code>, a principal component analysis is performed to construct factors.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_nfactor">nfactor</code></td>
<td>

<p>the number of factors constructed when <code>PCA</code> is <code>TRUE</code>. 
If <code>nfactor = "interactive"</code>, the scree plot of the principal component analysis is depicted and the user can set this argument interactively. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_regularize">regularize</code></td>
<td>

<p>the regularizaton method to be used. 
Possible choices are <code>"glasso"</code> (the default), <code>"tapering"</code>, <code>"thresholding"</code> and <code>"eigen.cleaning"</code>. 
See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_taper">taper</code></td>
<td>

<p>the tapering matrix used when <code>regularize = "tapering"</code>. 
If missing, the tapering matrix is constructed according to <code>group</code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_group">group</code></td>
<td>

<p>an integer vector having the length equal to <code>dim(yuima)-length(factor)</code>. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_lambda">lambda</code></td>
<td>

<p>the penalty parameter used when <code>regularize = "glasso"</code>. If it is <code>"aic"</code> (resp. <code>"bic"</code>), it is selected by minimizing the formally defined AIC (resp. BIC). 
See &lsquo;Details&rsquo;. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_weight">weight</code></td>
<td>

<p>logical. If <code>TRUE</code>, a weighted version is used for <code>regularize = "glasso"</code> as in Koike (2020).
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_nlambda">nlambda</code></td>
<td>

<p>a positive integer indicating the number of candidate penalty parameters for which AIC or BIC is evaluated when <code>lambda</code> is <code>"aic"</code> or <code>"bic"</code>. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_ratio">ratio</code></td>
<td>

<p>a positive number indicating the ratio of the largest and smallest values in candidate penalty parameters for which AIC or BIC is evaluated when <code>lambda</code> is <code>"aic"</code> or <code>"bic"</code>. See &lsquo;Details&rsquo;. 
The default value is <code>sqrt(log(d)/N)</code>, where <code>d</code> is the dimension of <code>yuima</code>. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_n">N</code></td>
<td>

<p>a positive integer indicating the &quot;effective&quot; sampling size, which is necessary to evealuate AIC and BIC when <code>lambda</code> is <code>"aic"</code> or <code>"bic"</code>. 
In a standard situation, it is equal to the sample size <code class="reqn">-</code> 1, but it might be different when the data are observed nonsynchronously and/or with noise. 
If missing, it is automatically determined according to <code>method</code>. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_thr.type">thr.type</code></td>
<td>

<p>a character string indicating the type of the thresholding method used when <code>regularize = "thresholding"</code>. 
Possible choices are <code>"hard"</code>, <code>"soft"</code>, <code>"alasso"</code> and <code>"scad"</code>. See Section 2.3 of Dai et al. (2019) for the definition of each method. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_thr">thr</code></td>
<td>

<p>a numeric matrix indicating the threshold levels used when <code>regularize = "thresholding"</code>. Its entries indicate the threshold levels for the corresponding entries of the covariance matrix (values for <code class="reqn">\lambda</code> in the notation of Dai et al. (2019)). 
A single number is converted to the matrix with common entries equal to that number. 
If <code>NULL</code>, it is determined according to <code>tau</code>. 
See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_tau">tau</code></td>
<td>

<p>a number between 0 and 1 used to determine the threshold levels used when <code>regularize = "thresholding"</code> and <code>thr=NULL</code> (a value for <code class="reqn">\tau</code> in the notation of Dai et al. (2019)). 
If <code>NULL</code>, it is determined by a grid search procedure as suggested in Section 4.3 of Dai et al. (2019). 
See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_par.alasso">par.alasso</code></td>
<td>

<p>the tuning parameter for <code>thr.type = "alasso"</code> (a value for <code class="reqn">\eta</code> in the notation of Dai et al. (2019)). 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_par.scad">par.scad</code></td>
<td>

<p>the tuning parameter for <code>thr.type = "scad"</code> (a value for <code class="reqn">a</code> in the notation of Dai et al. (2019)). 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_thr.delta">thr.delta</code></td>
<td>

<p>a positive number indicating the step size used in the grid serach procedure to determine <code>tau</code>. 
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_frequency">frequency</code></td>
<td>

<p>passed to <code><a href="#topic+cce">cce</a></code>.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_utime">utime</code></td>
<td>

<p>passed to <code><a href="#topic+cce">cce</a></code>.
</p>
</td></tr>
<tr><td><code id="cce.factor_+3A_...">...</code></td>
<td>

<p>passed to <code><a href="#topic+cce">cce</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One basic approach to estimate the covariance matrix of high-dimensional time series is to take account of the factor structure and perform regularization for the residual covariance matrix. 
This function implements such an estimation procedure for high-frequency data modeled as a discretely observed semimartingale. 
Specifically, let <code class="reqn">Y</code> be a <code class="reqn">d</code>-dimensional semimartingale which describes the dynamics of the observation data. We consider the following continuous-time factor model:
</p>
<p style="text-align: center;"><code class="reqn">
Y_t = \beta X_t + Z_t,     0\le t\le T,
</code>
</p>

<p>where <code class="reqn">X</code> is an <code class="reqn">r</code>-dimensional semimartingale (the factor process), <code class="reqn">Z</code> is a <code class="reqn">d</code>-dimensional semimartingale (the residual process), and <code class="reqn">\beta</code> is a constant <code class="reqn">d\times r</code> matrix (the factor loading matrix). We assume that <code class="reqn">X</code> and <code class="reqn">Z</code> are orthogonal in the sense that <code class="reqn">[X,Z]_T=0</code>. Then, the quadratic covariation matrix of <code class="reqn">Y</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">
[Y,Y]_T=\beta[X,X]_T\beta^\top+[Z,Z]_T.
</code>
</p>

<p>Also, <code class="reqn">\beta</code> can be written as <code class="reqn">\beta=[Y,X]_T[X,X]_T^{-1}</code>. Thus, if we have observation data both for <code class="reqn">Y</code> and <code class="reqn">X</code>, we can construct estimators for <code class="reqn">[Y,Y]_T</code>, <code class="reqn">[X,X]_T</code> and <code class="reqn">\beta</code> by <code><a href="#topic+cce">cce</a></code>. Moreover, plugging these estimators into the above equation, we can also construct an estimator for <code class="reqn">[Z,Z]_T</code>.  Since this estimator is often poor due to the high-dimensionality, we regularize it by some method. Then, by plugging the regularized estimator for <code class="reqn">[Z,Z]_T</code> into the above equation, we obtain the final  estimator for <code class="reqn">[Y,Y]_T</code>. 
</p>
<p>Even if we do not have observation data for <code class="reqn">X</code>, we can (at least formally) construct a pseudo factor process by performing principal component analysis for the initial estimator of <code class="reqn">[Y,Y]_T</code>. See Ait-Sahalia and Xiu (2017) and Dai et al. (2019) for details. 
</p>
<p>Currently, the following four options are available for the regularization method applied to the residual covariance matrix estimate:
</p>

<ol>
<li> <p><code>regularize = "glasso"</code> (the default). 
</p>
<p>This performs the glaphical Lasso. When <code>weight=TRUE</code> (the default), a weighted version of the graphical Lasso is performed as in Koike (2020). Otherwise, the standard graphical Lasso is performed as in Brownlees et al. (2018). 
</p>
<p>If <code>lambda="aic"</code> (resp.~<code>lambda="bic"</code>), the penalty parameter for the graphical Lasso is selected by minimizing the formally defined AIC (resp.~BIC). 
The minimization is carried out by grid search, where the grid is determined as in Section 5.1 of Koike (2020).
</p>
<p>The optimization problem in the graphical Lasso is solved by the GLASSOFAST algorithm of Sustik and Calderhead (2012), which is available from the package <span class="pkg">glassoFast</span>. 
</p>
</li>
<li> <p><code>regularize = "tapering"</code>. 
</p>
<p>This performs tapering, i.e. taking the entry-wise product of the residual covariance matrix estimate and a tapering matrix specified by <code>taper</code>. 
See Section 3.5.1 of Pourahmadi (2011) for an overview of this method.
</p>
<p>If <code>taper</code> is missing, it is constructed according to <code>group</code> as follows: <code>taper</code> is a 0-1 matrix and the <code class="reqn">(i,j)</code>-th entry is equal to 1 if and only if <code>group[i]==group[j]</code>. Thus, by default it makes the residual covariance matrix diagonal.
</p>
</li>
<li> <p><code>regularize = "thresholding"</code>. 
</p>
<p>This performs thresholding, i.e. entries of the residual covariance matrix are shrunk toward 0 according to a thresholding rule (specified by <code>thr.type</code>) and a threshold level (spencified by <code>thr</code>). 
</p>
<p>If <code>thr=NULL</code>, the <code class="reqn">(i,j)</code>-th entry of <code>thr</code> is given by <code class="reqn">\tau\sqrt{\hat{[Z^i,Z^i]}_T\hat{[Z^j,Z^j]}_T}</code>, where <code class="reqn">\hat{[Z^i,Z^i]}_T</code> (resp. <code class="reqn">\hat{[Z^j,Z^j]}_T</code>) denotes the <code class="reqn">i</code>-th (resp. <code class="reqn">j</code>-th) diagonal entry of the non-regularized estimator for the residual covariance matrix <code class="reqn">[Z,Z]_T</code>, and <code class="reqn">\tau</code> is a tuning parameter specified by <code>tau</code>. 
</p>
<p>When <code>tau=NULL</code>, the value of <code class="reqn">\tau</code> is set to the smallest value in the grid with step size <code>thr.delta</code> such that the regularized estimate of the residual covariance matrix becomes positive definite.
</p>
</li>
<li> <p><code>regularize = "eigen.cleaning"</code>. 
</p>
<p>This performs the eigenvalue cleaning algorithm described in Hautsch et al. (2012). 
</p>
</li></ol>



<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>covmat.y</code></td>
<td>
<p>the estimated covariance matrix</p>
</td></tr>
<tr><td><code>premat.y</code></td>
<td>
<p>the estimated precision matrix</p>
</td></tr>
<tr><td><code>beta.hat</code></td>
<td>
<p>the estimated factor loading matrix</p>
</td></tr>
<tr><td><code>covmat.x</code></td>
<td>
<p>the estimated factor covariance matrix</p>
</td></tr>
<tr><td><code>covmat.z</code></td>
<td>
<p>the estimated residual covariance matrix</p>
</td></tr>
<tr><td><code>premat.z</code></td>
<td>
<p>the estimated residual precision matrix</p>
</td></tr>
<tr><td><code>sigma.z</code></td>
<td>
<p>the estimated residual covariance matrix before regularization</p>
</td></tr>
<tr><td><code>pc</code></td>
<td>
<p>the variances of the principal components (it is <code>NULL</code> if <code>PCA = FALSE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA project Team
</p>


<h3>References</h3>

<p>Ait-Sahalia, Y. and Xiu, D. (2017).
Using principal component analysis to estimate a high dimensional factor model with high-frequency data,
<em>Journal of Econometrics</em>, <b>201</b>, 384&ndash;399.
</p>
<p>Brownlees, C., Nualart, E. and Sun, Y. (2018). 
Realized networks,
<em>Journal of Applied Econometrics</em>, <b>33</b>, 986&ndash;1006.
</p>
<p>Dai, C., Lu, K. and Xiu, D. (2019).
Knowing factors or factor loadings, or neither? Evaluating estimators of large covariance matrices with noisy and asynchronous data,
<em>Journal of Econometrics</em>, <b>208</b>, 43&ndash;79.
</p>
<p>Hautsch, N., Kyj, L. M. and Oomen, R. C. (2012).
A blocking and regularization approach to high-dimensional realized covariance estimation,
<em>Journal of Applied Econometrics</em>, <b>27</b>, 625&ndash;645.
</p>
<p>Koike, Y. (2020). 
De-biased graphical Lasso for high-frequency data,
<em>Entropy</em>, <b>22</b>, 456. 
</p>
<p>Pourahmadi, M. (2011). 
Covariance estimation: The GLM and regularization perspectives. 
<em>Statistical Science</em>, <b>26</b>, 369&ndash;387.
</p>
<p>Sustik, M. A. and Calderhead, B. (2012).
GLASSOFAST: An efficient GLASSO implementation,
UTCSTechnical Report TR-12-29, The University of Texas at Austin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cce">cce</a></code>, <code><a href="#topic+lmm">lmm</a></code>, <code><a href="glassoFast.html#topic+glassoFast">glassoFast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)

## Simulating a factor process (Heston model)
drift &lt;- c("mu*S", "-theta*(V-v)")
diffusion &lt;- matrix(c("sqrt(max(V,0))*S", "gamma*sqrt(max(V,0))*rho",
                       0, "gamma*sqrt(max(V,0))*sqrt(1-rho^2)"),
                    2,2)
mod &lt;- setModel(drift = drift, diffusion = diffusion,
                state.variable = c("S", "V")) 
n &lt;- 2340
samp &lt;- setSampling(n = n)
heston &lt;- setYuima(model = mod, sampling = samp)
param &lt;- list(mu = 0.03, theta = 3, v = 0.09, 
              gamma = 0.3, rho = -0.6) 
result &lt;- simulate(heston, xinit = c(1, 0.1), 
                   true.parameter = param)

zdata &lt;- get.zoo.data(result) # extract the zoo data
X &lt;- log(zdata[[1]]) # log-price process
V &lt;- zdata[[2]] # squared volatility process


## Simulating a residual process (correlated BM)
d &lt;- 100 # dimension
Q &lt;- 0.1 * toeplitz(0.7^(1:d-1)) # residual covariance matrix
dZ &lt;- matrix(rnorm(n*d),n,d) %*% chol(Q)/sqrt(n)
Z &lt;- zoo(apply(dZ, 2, "diffinv"), samp@grid[[1]])


## Constructing observation data
b &lt;- runif(d, 0.25, 2.25) # factor loadings
Y &lt;- X %o% b + Z
yuima &lt;- setData(cbind(X, Y))

# We subsample yuima to construct observation data
yuima &lt;- subsampling(yuima, setSampling(n = 78))


## Estimating the covariance matrix (factor is known)
cmat &lt;- tcrossprod(b) * mean(V[-1]) + Q # true covariance matrix
pmat &lt;- solve(cmat) # true precision matrix

# (1) Regularization method is glasso (the default)
est &lt;- cce.factor(yuima, factor = 1) 
norm(est$covmat.y - cmat, type = "2") 
norm(est$premat.y - pmat, type = "2")

# (2) Regularization method is tapering
est &lt;- cce.factor(yuima, factor = 1, regularize = "tapering") 
norm(est$covmat.y - cmat, type = "2") 
norm(est$premat.y - pmat, type = "2")

# (3) Regularization method is thresholding
est &lt;- cce.factor(yuima, factor = 1, regularize = "thresholding") 
norm(est$covmat.y - cmat, type = "2") 
norm(est$premat.y - pmat, type = "2")

# (4) Regularization method is eigen.cleaning
est &lt;- cce.factor(yuima, factor = 1, regularize = "eigen.cleaning") 
norm(est$covmat.y - cmat, type = "2") 
norm(est$premat.y - pmat, type = "2")


## Estimating the covariance matrix (factor is unknown)
yuima2 &lt;- setData(Y)

# We subsample yuima to construct observation data
yuima2 &lt;- subsampling(yuima2, setSampling(n = 78))

# (A) Ignoring the factor structure (regularize = "glasso")
est &lt;- cce.factor(yuima2) 
norm(est$covmat.y - cmat, type = "2") 
norm(est$premat.y - pmat, type = "2")

# (B) Estimating the factor by PCA (regularize = "glasso")
est &lt;- cce.factor(yuima2, PCA = TRUE, nfactor = 1) # use 1 factor 
norm(est$covmat.y - cmat, type = "2") 
norm(est$premat.y - pmat, type = "2")

# One can interactively select the number of factors
# after implementing PCA (the scree plot is depicted)
# Try: est &lt;- cce.factor(yuima2, PCA = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Class+20for+20Quasi+20Maximum+20Likelihood+20Estimation+20of+20Point+20Process+20Regression+20Models'>Class for Quasi Maximum Likelihood Estimation of Point Process Regression Models</h2><span id='topic+yuima.PPR.qmle-class'></span><span id='topic+yuima.PPR.qmle+2CANY-method'></span><span id='topic+qmle.PPR'></span><span id='topic+PPR.qmle'></span>

<h3>Description</h3>

<p> The <code>yuima.PPR.qmle</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code>mle-class</code> of the <span class="pkg">stats4</span> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated parameters.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated and fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>is an object of class <code>numeric</code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>is an object of class <code>function</code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>is an object of class <code>character</code>.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.PPR-class">yuima.PPR-class</a></code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>Methods mle</dt><dd><p>All methods for <code>mle-class</code> are available.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='cogarch.est.-class'>Class for Generalized Method of Moments Estimation for COGARCH(p,q) model</h2><span id='topic+cogarch.est-class'></span><span id='topic+plot+2Ccogarch.est.+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>cogarch.est</code> class is a class of the  <span class="pkg">yuima</span> package that contains estimated parameters obtained by the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+qmle">qmle</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>yuima</code>:</dt><dd><p>is an object of of <code><a href="#topic+yuima-class">yuima-class</a></code>.</p>
</dd>
<dt><code>objFun</code>:</dt><dd><p>is an object of class <code>character</code> that indicates the objective function used in the minimization problem. See the documentation of the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+qmle">qmle</a></code> for more details.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated parameters.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated and fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>is an object of class <code>numeric</code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>is an object of class <code>function</code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>is an object of class <code>character</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>Methods mle</dt><dd><p>All methods for <code>mle-class</code> are available.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='cogarch.est.incr-class'>Class for Estimation of COGARCH(p,q) model with underlying increments</h2><span id='topic+cogarch.est.incr-class'></span><span id='topic+plot+2Ccogarch.est.incr+2CANY-method'></span><span id='topic+est.cogarch.incr-class'></span><span id='topic+simulate+2Ccogarch.est.incr-method'></span>

<h3>Description</h3>

<p>The <code>cogarch.est.incr</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+cogarch.est-class">cogarch.est-class</a></code> and is filled by the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+qmle">qmle</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Incr.Lev</code>:</dt><dd><p>is an object of class <code><a href="zoo.html#topic+zoo">zoo</a></code> that contains the estimated increments of the noise obtained using <code><a href="#topic+cogarchNoise">cogarchNoise</a></code>.</p>
</dd>
<dt><code>yuima</code>:</dt><dd><p>is an object of of <code><a href="#topic+yuima-class">yuima-class</a></code>.</p>
</dd>
<dt><code>logL.Incr</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains the value of the log-likelihood for estimated Levy increments.</p>
</dd>
<dt><code>objFun</code>:</dt><dd><p>is an object of class <code>character</code> that indicates the objective function used in the minimization problem. See the documentation of the function <code><a href="#topic+gmm">gmm</a></code> or <code><a href="#topic+qmle">qmle</a></code>  for more details.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated parameters.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated and fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>is an object of class <code>numeric</code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>is an object of class <code>function</code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>is an object of class <code>character</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see <code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
<dt>plot</dt><dd><p>Plot method for estimated increment of the noise.</p>
</dd>
<dt>Methods mle</dt><dd><p>All methods for <code>mle-class</code> are available.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='cogarch.info-class'>Class for information about CoGarch(p,q)</h2><span id='topic+cogarch.info-class'></span>

<h3>Description</h3>

<p>The <code>cogarch.info-class</code> is a class of the  <span class="pkg">yuima</span> package
</p>


<h3>Slots</h3>


<dl>
<dt><code>p</code>:</dt><dd><p>Number of autoregressive coefficients in the variance process. </p>
</dd>
<dt><code>q</code>:</dt><dd><p>Number of moving average coefficients in the variance process. </p>
</dd>
<dt><code>ar.par</code>:</dt><dd><p>Label of autoregressive coefficients. </p>
</dd>
<dt><code>ma.par</code>:</dt><dd><p>Label of moving average coefficients. </p>
</dd>
<dt><code>loc.par</code>:</dt><dd><p>Label of location coefficient in the variance process. </p>
</dd>
<dt><code>Cogarch.var</code>:</dt><dd><p>Label of the observed process. </p>
</dd>
<dt><code>V.var</code>:</dt><dd><p>Label of the variance process. </p>
</dd>
<dt><code>Latent.var</code>:</dt><dd><p>Label of the latent process in the state representation of the variance.</p>
</dd>
<dt><code>XinExpr</code>:</dt><dd><p>Logical variable. If <code>XinExpr=FALSE</code>, the starting condition of <code>Latent.var</code> is zero otherwise each component of Latent.var has a parameter as a starting point. </p>
</dd>
<dt><code>measure</code>:</dt><dd><p>Levy measure for jump and quadratic part. </p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>Type specification for Levy measure. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>cogarch.info-class</code> object cannot be directly specified by the user
but it is built when the <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code> object is
constructed via <code><a href="#topic+setCogarch">setCogarch</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='cogarchNoise'>Estimation for the underlying Levy in a COGARCH(p,q) model</h2><span id='topic+Recovering.Noise.cogarch'></span><span id='topic+cogarch.Recovering'></span><span id='topic+CogarchRecovNoise'></span><span id='topic+cogarchNoise'></span><span id='topic+Levy.cogarch'></span>

<h3>Description</h3>

<p>Retrieve the increment of the underlying Levy for the COGARCH(p,q) process</p>


<h3>Usage</h3>

<pre><code class='language-R'>cogarchNoise(yuima, data=NULL, param, mu=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cogarchNoise_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object or an object of <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code>.</p>
</td></tr>
<tr><td><code id="cogarchNoise_+3A_data">data</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> contains the observations available at uniformly spaced time. If <code>data=NULL</code>, the default, the <code>cogarchNoise</code> uses the data in an object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.</p>
</td></tr>
<tr><td><code id="cogarchNoise_+3A_param">param</code></td>
<td>
<p><code>list</code> of parameters for the COGARCH(p,q).</p>
</td></tr>
<tr><td><code id="cogarchNoise_+3A_mu">mu</code></td>
<td>
<p>a numeric object that contains the value of the second moments of the levy measure.</p>
</td></tr>
</table>


<h3>Value</h3>


<table role = "presentation">
<tr><td><code>incr.Levy</code></td>
<td>
<p>a numeric object contains the estimated increments.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>an object of class yuima containing the state, the variance and the cogarch process.</p>
</td></tr>
</table>


<h3>Note</h3>


<p>The function <code>cogarchNoise</code> assumes the underlying Levy process is centered in zero.
</p>
<p>The function <code>gmm</code> uses the function <code>cogarchNoise</code> for estimation of underlying Levy in the COGARCH(p,q) model.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Chadraa. (2009)
Statistical Modelling with COGARCH(P,Q) Processes, <em>PhD Thesis</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Insert here some examples
</code></pre>

<hr>
<h2 id='CPoint'>Volatility structural change point estimator</h2><span id='topic+CPoint'></span><span id='topic+qmleL'></span><span id='topic+qmleR'></span>

<h3>Description</h3>

<p>Volatility structural change point estimator</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPoint(yuima, param1, param2, print=FALSE, symmetrized=FALSE, plot=FALSE)
qmleL(yuima, t,  ...)
qmleR(yuima, t,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPoint_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="CPoint_+3A_param1">param1</code></td>
<td>
<p>parameter values before the change point t</p>
</td></tr>
<tr><td><code id="CPoint_+3A_param2">param2</code></td>
<td>
<p>parameter values after the change point t</p>
</td></tr>
<tr><td><code id="CPoint_+3A_plot">plot</code></td>
<td>
<p>plot test statistics? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CPoint_+3A_print">print</code></td>
<td>
<p>print some debug output. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CPoint_+3A_t">t</code></td>
<td>
<p>time value. See Details.</p>
</td></tr>
<tr><td><code id="CPoint_+3A_symmetrized">symmetrized</code></td>
<td>
<p>if <code>TRUE</code> uses the symmetrized version of the quasi maximum-likelihood approximation.</p>
</td></tr>
<tr><td><code id="CPoint_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+qmle">qmle</a></code> method. See Examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CPoint</code>  estimates the change point using quasi-maximum likelihood approach.
</p>
<p>Function <code>qmleL</code> estimates the parameters in the diffusion matrix using
observations up to time <code>t</code>.
</p>
<p>Function <code>qmleR</code> estimates the parameters in the diffusion matrix using
observations from time <code>t</code> to the end.
</p>
<p>Arguments in both <code>qmleL</code> and <code>qmleR</code> follow the same rules
as in <code><a href="#topic+qmle">qmle</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ans</code></td>
<td>
<p>a list with change point instant, and paramters before and after
the change point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
diff.matrix &lt;- matrix(c("theta1.1*x1","0*x2","0*x1","theta1.2*x2"), 2, 2)

drift.c &lt;- c("1-x1", "3-x2")
drift.matrix &lt;- matrix(drift.c, 2, 1)

ymodel &lt;- setModel(drift=drift.matrix, diffusion=diff.matrix, time.variable="t",
state.variable=c("x1", "x2"), solve.variable=c("x1", "x2"))
n &lt;- 1000

set.seed(123)

t1 &lt;- list(theta1.1=.1, theta1.2=0.2)
t2 &lt;- list(theta1.1=.6, theta1.2=.6)

tau &lt;- 0.4
ysamp1 &lt;- setSampling(n=tau*n, Initial=0, delta=0.01)
yuima1 &lt;- setYuima(model=ymodel, sampling=ysamp1)
yuima1 &lt;- simulate(yuima1, xinit=c(1, 1), true.parameter=t1)

x1 &lt;- yuima1@data@zoo.data[[1]]
x1 &lt;- as.numeric(x1[length(x1)])
x2 &lt;- yuima1@data@zoo.data[[2]]
x2 &lt;- as.numeric(x2[length(x2)])

ysamp2 &lt;- setSampling(Initial=n*tau*0.01, n=n*(1-tau), delta=0.01)
yuima2 &lt;- setYuima(model=ymodel, sampling=ysamp2)

yuima2 &lt;- simulate(yuima2, xinit=c(x1, x2), true.parameter=t2)


yuima &lt;- yuima1
yuima@data@zoo.data[[1]] &lt;- c(yuima1@data@zoo.data[[1]], yuima2@data@zoo.data[[1]][-1])
yuima@data@zoo.data[[2]] &lt;- c(yuima1@data@zoo.data[[2]], yuima2@data@zoo.data[[2]][-1])

plot(yuima)

# estimation of change point for given parameter values
t.est &lt;- CPoint(yuima,param1=t1,param2=t2, plot=TRUE)


low &lt;- list(theta1.1=0, theta1.2=0)

# first state estimate of parameters using small 
# portion of data in the tails
tmp1 &lt;- qmleL(yuima,start=list(theta1.1=0.3,theta1.2=0.5),t=1.5,
        lower=low, method="L-BFGS-B")
tmp1
tmp2 &lt;- qmleR(yuima,start=list(theta1.1=0.3,theta1.2=0.5), t=8.5,
        lower=low, method="L-BFGS-B")
tmp2


# first stage changepoint estimator
t.est2 &lt;- CPoint(yuima,param1=coef(tmp1),param2=coef(tmp2))
t.est2$tau


# second stage estimation of parameters given first stage
# change point estimator
tmp11 &lt;- qmleL(yuima,start=as.list(coef(tmp1)), t=t.est2$tau-0.1,
 lower=low, method="L-BFGS-B")
tmp11

tmp21 &lt;- qmleR(yuima,start=as.list(coef(tmp2)), t=t.est2$tau+0.1,
 lower=low, method="L-BFGS-B")
tmp21

# second stage estimator of the change point
CPoint(yuima,param1=coef(tmp11),param2=coef(tmp21))


## One dimensional example: non linear case
diff.matrix &lt;- matrix("(1+x1^2)^theta1", 1, 1)
drift.c &lt;- c("x1")

ymodel &lt;- setModel(drift=drift.c, diffusion=diff.matrix, time.variable="t",
state.variable=c("x1"), solve.variable=c("x1"))
n &lt;- 500

set.seed(123)

y0 &lt;- 5 # initial value
theta00 &lt;- 1/5
gamma &lt;- 1/4


theta01 &lt;- theta00+n^(-gamma)


t1 &lt;- list(theta1= theta00)
t2 &lt;- list(theta1= theta01)

tau &lt;- 0.4
ysamp1 &lt;- setSampling(n=tau*n, Initial=0, delta=1/n)
yuima1 &lt;- setYuima(model=ymodel, sampling=ysamp1)
yuima1 &lt;- simulate(yuima1, xinit=c(5), true.parameter=t1)
x1 &lt;- yuima1@data@zoo.data[[1]]
x1 &lt;- as.numeric(x1[length(x1)])

ysamp2 &lt;- setSampling(Initial=tau, n=n*(1-tau), delta=1/n)
yuima2 &lt;- setYuima(model=ymodel, sampling=ysamp2)

yuima2 &lt;- simulate(yuima2, xinit=c(x1), true.parameter=t2)


yuima &lt;- yuima1
yuima@data@zoo.data[[1]] &lt;- c(yuima1@data@zoo.data[[1]], yuima2@data@zoo.data[[1]][-1])


plot(yuima)


t.est &lt;- CPoint(yuima,param1=t1,param2=t2)
t.est$tau

low &lt;- list(theta1=0)
upp &lt;- list(theta1=1)

# first state estimate of parameters using small 
# portion of data in the tails
tmp1 &lt;- qmleL(yuima,start=list(theta1=0.5),t=.15,lower=low, upper=upp,method="L-BFGS-B")
tmp1
tmp2 &lt;- qmleR(yuima,start=list(theta1=0.5), t=.85,lower=low, upper=upp,method="L-BFGS-B")
tmp2



# first stage changepoint estimator
t.est2 &lt;- CPoint(yuima,param1=coef(tmp1),param2=coef(tmp2))
t.est2$tau


# second stage estimation of parameters given first stage
# change point estimator
tmp11 &lt;- qmleL(yuima,start=as.list(coef(tmp1)), t=t.est2$tau-0.1,
   lower=low, upper=upp,method="L-BFGS-B")
tmp11

tmp21 &lt;- qmleR(yuima,start=as.list(coef(tmp2)), t=t.est2$tau+0.1,
  lower=low, upper=upp,method="L-BFGS-B")
tmp21


# second stage estimator of the change point
CPoint(yuima,param1=coef(tmp11),param2=coef(tmp21),plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='DataPPR'>From <code>zoo</code> data to <code>yuima.PPR</code>.</h2><span id='topic+DataPPR'></span>

<h3>Description</h3>

<p>The function converts an object of class <code>zoo</code> to an object of class <code><a href="#topic+yuima.PPR">yuima.PPR</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataPPR(CountVar, yuimaPPR, samp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataPPR_+3A_countvar">CountVar</code></td>
<td>
<p>An object of class <code>zoo</code> that contains counting variables and covariates. <code>index(CountVar)</code> returns the arrival times.</p>
</td></tr>
<tr><td><code id="DataPPR_+3A_yuimappr">yuimaPPR</code></td>
<td>
<p>An object of class <code><a href="#topic+yuima.PPR">yuima.PPR</a></code> that contains a mathematical description of the point process regression model assumed to be the generator of the observed data.</p>
</td></tr>
<tr><td><code id="DataPPR_+3A_samp">samp</code></td>
<td>
<p>An object of class <code>yuima.sampling</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code><a href="#topic+yuima.PPR">yuima.PPR</a></code> where the slot <code>model</code> contains the Point process described in <code>yuimaPPR@model</code>, the slot <code>data</code> contains the counting variables and the covariates observed on the grid in <code>samp</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In this example we generate a dataset contains the Counting Variable N
# and the Covariate X.
# The covariate X is an OU driven by a Gamma process.

# Values of parameters.
mu &lt;- 2
alpha &lt;- 4
beta &lt;-5

# Law definition
my.rKern &lt;- function(n,t){
  res0 &lt;- t(t(rgamma(n, 0.1*t)))
  res1 &lt;- t(t(rep(1,n)))
  res &lt;- cbind(res0,res1)
  return(res)
}

Law.PPRKern &lt;- setLaw(rng = my.rKern)

# Point Process definition
modKern &lt;- setModel(drift = c("0.4*(0.1-X)","0"),
                    diffusion = c("0","0"),
                    jump.coeff = matrix(c("1","0","0","1"),2,2),
                    measure = list(df = Law.PPRKern),
                    measure.type = c("code","code"),
                    solve.variable = c("X","N"),
                    xinit=c("0.25","0"))

gFun &lt;- "exp(mu*log(1+X))"
#
Kernel &lt;- "alpha*exp(-beta*(t-s))"

prvKern &lt;- setPPR(yuima = modKern,
                  counting.var="N", gFun=gFun,
                  Kernel = as.matrix(Kernel),
                  lambda.var = "lambda", var.dx = "N",
                  lower.var="0", upper.var = "t")

# Simulation

Term&lt;-200
seed&lt;-1
n&lt;-20000

true.parKern &lt;- list(mu=mu, alpha=alpha, beta=beta)


set.seed(seed)
# set.seed(1)

time.simKern &lt;-system.time(
  simprvKern &lt;- simulate(object = prvKern, true.parameter = true.parKern,
                         sampling = setSampling(Terminal =Term, n=n))
)


plot(simprvKern,main ="Counting Process with covariates" ,cex.main=0.9)

# Using the function get.counting.data we extract from an object of class
# yuima.PPR the counting process N and the covariate X at the arrival times.

CountVar &lt;- get.counting.data(simprvKern)

plot(CountVar)

# We convert the zoo object in the yuima.PPR object.

sim2 &lt;- DataPPR(CountVar, yuimaPPR=simprvKern, samp=simprvKern@sampling)


## End(Not run)
</code></pre>

<hr>
<h2 id='Diagnostic.Carma'>Diagnostic Carma model</h2><span id='topic+Diagnostic.Carma'></span>

<h3>Description</h3>

<p>This function verifies if the condition of stationarity is satisfied.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diagnostic.Carma(carma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Diagnostic.Carma_+3A_carma">carma</code></td>
<td>
<p> An object of class <code>yuima.qmle-class</code> where the slot <code>model</code> is a carma process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical variable. If <code>TRUE</code>, Carma is stationary.</p>


<h3>Author(s)</h3>

<p>YUIMA TEAM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod1 &lt;- setCarma(p = 2, q = 1, scale.par = "sig",
          Carma.var = "y")

param1 &lt;- list(a1 = 1.39631, a2 = 0.05029, b0 = 1,
            b1 = 1, sig = 1)
samp1 &lt;- setSampling(Terminal = 100, n = 200)

set.seed(123)

sim1 &lt;- simulate(mod1, true.parameter = param1,
          sampling = samp1)

est1 &lt;- qmle(sim1, start = param1)

Diagnostic.Carma(est1)

</code></pre>

<hr>
<h2 id='Diagnostic.Cogarch'>
Function for checking the statistical properties of the COGARCH(p,q) model
</h2><span id='topic+Diagnostic.Cogarch'></span>

<h3>Description</h3>

<p>The function check the statistical properties of the COGARCH(p,q) model. We verify if the process has a strict positive stationary variance model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diagnostic.Cogarch(yuima.cogarch, param = list(), matrixS = NULL, mu = 1, display = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Diagnostic.Cogarch_+3A_yuima.cogarch">yuima.cogarch</code></td>
<td>
<p> an object of class <code>yuima.cogarch</code>, <code>yuima</code> or a class <code>cogarch.gmm-class</code>
</p>
</td></tr>
<tr><td><code id="Diagnostic.Cogarch_+3A_param">param</code></td>
<td>
<p> a list containing the values of the parameters</p>
</td></tr>
<tr><td><code id="Diagnostic.Cogarch_+3A_matrixs">matrixS</code></td>
<td>
<p> a Square matrix.</p>
</td></tr>
<tr><td><code id="Diagnostic.Cogarch_+3A_mu">mu</code></td>
<td>
<p> first moment of the Levy measure.</p>
</td></tr>
<tr><td><code id="Diagnostic.Cogarch_+3A_display">display</code></td>
<td>
<p> a logical variable, if <code>TRUE</code> the function displays the result in the <code>console</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functon returns a List with entries:
</p>
<table role = "presentation">
<tr><td><code>meanVarianceProc</code></td>
<td>
<p> Unconditional Stationary mean of the variance process. </p>
</td></tr>
<tr><td><code>meanStateVariable</code></td>
<td>
<p> Unconditional Stationary mean of the state process.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p> If <code>TRUE</code>, the COGARCH(p,q) has stationary variance.</p>
</td></tr>
<tr><td><code>positivity</code></td>
<td>
<p> If <code>TRUE</code>, the variance process is strictly positive.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Definition of the COGARCH(1,1) process driven by a Variance Gamma nois:
param.VG &lt;- list(a1 = 0.038,  b1 =  0.053,
                  a0 = 0.04/0.053,lambda = 1, alpha = sqrt(2), beta = 0, mu = 0, 
                  x01 = 50.33)

cog.VG &lt;- setCogarch(p = 1, q = 1, work = FALSE,
                      measure=list(df="rvgamma(z, lambda, alpha, beta, mu)"),
                      measure.type = "code", 
                      Cogarch.var = "y",
                      V.var = "v", Latent.var="x",
                      XinExpr=TRUE)

# Verify the stationarity and the positivity of th variance process

test &lt;- Diagnostic.Cogarch(cog.VG,param=param.VG)
show(test)

# Simulate a sample path

set.seed(210)

Term=800
num=24000

samp.VG &lt;- setSampling(Terminal=Term, n=num)

sim.VG &lt;- simulate(cog.VG,
                    true.parameter=param.VG,
                    sampling=samp.VG,
                    method="euler")
plot(sim.VG)

# Estimate the model

res.VG &lt;- gmm(sim.VG, start = param.VG, Est.Incr = "IncrPar")

summary(res.VG)

#  Check if the estimated COGARCH(1,1) has a positive and stationary variance

test1&lt;-Diagnostic.Cogarch(res.VG)
show(test1)

# Simulate a COGARCH sample path using the estimated COGARCH(1,1) 
# and the recovered increments of underlying Variance Gamma Noise

esttraj&lt;-simulate(res.VG)
plot(esttraj)



## End(Not run)  
</code></pre>

<hr>
<h2 id='estimation_LRM'>Estimation of the t-Levy Regression Model</h2><span id='topic+estimation_LRM'></span><span id='topic+Estimation+20of+20t-Levy+20Regression+20Model'></span>

<h3>Description</h3>

<p>The function estimates a t-Levy Regression Model</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimation_LRM(start, model, data, upper, lower, PT = 500, n_obs1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimation_LRM_+3A_start">start</code></td>
<td>

<p>Initial values to be passed to the optimizer.
</p>
</td></tr>
<tr><td><code id="estimation_LRM_+3A_model">model</code></td>
<td>

<p>A <code><a href="#topic+yuima.LevyRM-class">yuima.LevyRM-class</a></code> that contains the mathematical representation of the t-Levy Regression Model. Its slot <code>@data</code> can contain either real or simulated data.
</p>
</td></tr>
<tr><td><code id="estimation_LRM_+3A_data">data</code></td>
<td>
	
<p>An object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> contains the observations available at uniformly spaced time. If <code>data=NULL</code>, the default, the function uses the data in the object <code>model</code>.
</p>
</td></tr>
<tr><td><code id="estimation_LRM_+3A_upper">upper</code></td>
<td>
<p>A named list for specifying upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="estimation_LRM_+3A_lower">lower</code></td>
<td>
<p>A named list for specifying lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="estimation_LRM_+3A_pt">PT</code></td>
<td>

<p>The number of the data for the estimation of the regressor coefficients and the scale parameter. 
</p>
</td></tr>
<tr><td><code id="estimation_LRM_+3A_n_obs1">n_obs1</code></td>
<td>

<p>The number of data used in the estimation of the degree of freedom. As default the number of the whole data is used in this part
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two-step estimation procedure. Regressor coefficients and scale parameters are obtained by maximizing the quasi-likelihood function based on the Cauchy density. The degree of freedom is estimated used the unitary increment of the t-noise.</p>


<h3>Value</h3>

<p>Estimated parameters</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='EstimCarmaHawkes'>
Estimation Methods for a CARMA(p,q)-Hawkes Counting Process
</h2><span id='topic+qmle.CarmaHawkes'></span><span id='topic+MethodOfMoments.CarmaHawkes'></span><span id='topic+EstimCarmaHawkes'></span>

<h3>Description</h3>

<p>The function provides two estimation procedures: Maximum Likelihood Estimation and Matching Empirical Correlation</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimCarmaHawkes(yuima, start, est.method = "qmle", method = "BFGS", 
lower = NULL, upper = NULL, lags = NULL, display = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimCarmaHawkes_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_start">start</code></td>
<td>
<p>initial values to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_est.method">est.method</code></td>
<td>
<p> The method used to estimate the parameters. The default <code>est.method = "qmle"</code> indicates the MLE while the alternative approach is based on the minimization of the empirical and theoretical autocorrelation.
</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_method">method</code></td>
<td>
<p>The optimization method to be used. See <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_lower">lower</code></td>
<td>
<p>Lower Bounds.
</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_upper">upper</code></td>
<td>

<p>Upper Bounds.
</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_lags">lags</code></td>
<td>

<p>Number of lags used in the autocorrelation.
</p>
</td></tr>
<tr><td><code id="EstimCarmaHawkes_+3A_display">display</code></td>
<td>

<p>you can see a progress of the estimation when <code>display=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output contains the estimated parameters.</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>


<h3>References</h3>

<p>Mercuri, L., Perchiazzo, A., &amp; Rroji, E. (2022). A Hawkes model with CARMA (p, q) intensity. <a href="https://doi.org/10.48550/arXiv.2208.02659">doi:10.48550/arXiv.2208.02659</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## MLE For A CARMA(2,1)-Hawkes ##

# Inputs:
a &lt;- c(3,2)
b &lt;- c(1,0.3)
mu&lt;-0.30

true.par&lt;-c(mu,a,b)

# step 1) Model Definition =&gt; Constructor 'setCarmaHawkes'
p &lt;- 2
q &lt;- 1
mod1 &lt;- setCarmaHawkes(p = p,q = q)

# step 2) Grid Construction =&gt; Constructor 'setSampling'
FinalTime &lt;- 5000
t0 &lt;- 0
samp &lt;- setSampling(t0, FinalTime, n = FinalTime)

# step 3) Simulation =&gt; method 'simulate'
# We use method 'simulate' to generate our dataset. 
# For the estimation from real data, 
# we use the constructors 'setData' and 
#'setYuima' (input 'model' is an object of 
#           'yuima.CarmaHawkes-class'). 

names(true.par) &lt;- c(mod1@info@base.Int, mod1@info@ar.par, mod1@info@ma.par) 

set.seed(1)
system.time(
sim1 &lt;- simulate(object = mod1, true.parameter = true.par, 
    sampling = samp)
)

plot(sim1)

# step 4) Estimation using the likelihood function.
system.time(
  res &lt;- EstimCarmaHawkes(yuima = sim1, 
    start = true.par)
)


## End(Not run)
</code></pre>

<hr>
<h2 id='fitCIR'>Calculate preliminary estimator and one-step improvements of a Cox-Ingersoll-Ross diffusion</h2><span id='topic+fitCIR'></span>

<h3>Description</h3>

<p>This is a function to simulate the preliminary estimator and the corresponding one step estimators based on the Newton-Raphson and the scoring method of the Cox-Ingersoll-Ross process given via the SDE 
</p>
<p><code class="reqn">\mathrm{d} X_t = (\alpha-\beta X_t)\mathrm{d} t + \sqrt{\gamma X_t}\mathrm{d} W_t</code>
</p>
<p>with parameters <code class="reqn">\beta&gt;0,</code> <code class="reqn">2\alpha&gt;5\gamma&gt;0</code> and a Brownian motion <code class="reqn">(W_t)_{t\geq 0}</code>. This function uses the Gaussian quasi-likelihood, hence requires that data is sampled at high-frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCIR(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitCIR_+3A_data">data</code></td>
<td>

<p>a numeric matrix 
containing the realization of <code class="reqn">(t_0,X_{t_0}), \dots,(t_n,X_{t_n})</code> with <code class="reqn">t_j</code> denoting the <code class="reqn">j</code>-th sampling times. <code>data[1,]</code> contains the sampling times <code class="reqn">t_0,\dots, t_n</code> and <code>data[2,]</code> the corresponding value of the process <code class="reqn">X_{t_0},\dots,X_{t_n}.</code> In other words <code>data[,j]=</code><code class="reqn">(t_j,X_{t_j})</code>. The observations should be equidistant. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimators calculated by this function can be found in the reference below.
</p>


<h3>Value</h3>

<p>A list with three entries each contain a vector in the following order: The result of the preliminary estimator, Newton-Raphson method and the method of scoring.

</p>
<p>If the sampling points are not equidistant the function will return <code>'Please use equidistant sampling points'.</code>
</p>


<h3>Author(s)</h3>

<p>Nicole Hufnagel 
</p>
<p>Contacts: <a href="mailto:nicole.hufnagel@math.tu-dortmund.de">nicole.hufnagel@math.tu-dortmund.de</a>
</p>


<h3>References</h3>

<p>Y. Cheng, N. Hufnagel, H. Masuda. Estimation of ergodic square-root diffusion under high-frequency sampling. Econometrics and Statistics, Article Number: 346 (2022).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#You can make use of the function simCIR to generate the data 
data &lt;- simCIR(alpha=3,beta=1,gamma=1, n=5000, h=0.05, equi.dist=TRUE)
results &lt;- fitCIR(data)
</code></pre>

<hr>
<h2 id='FromCF2yuima_law'>
From a Characteristic Function to an  <code>yuima.law-object</code>.
</h2><span id='topic+FromCF2yuima_law'></span>

<h3>Description</h3>

<p>This function returns an object of <code><a href="#topic+yuima.law-class">yuima.law-class</a></code> and requires the characteristic function as the only input. Density, Random Number Generator, Cumulative Distribution Function and quantile function are internally constructed</p>


<h3>Usage</h3>

<pre><code class='language-R'>FromCF2yuima_law(myfun, time.names = "t", var_char = "u", up = 45, 
low = -45, N_grid = 50001, N_Fourier = 2^10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FromCF2yuima_law_+3A_myfun">myfun</code></td>
<td>
<p> A <code>string</code> that is the name of the characteristic function defined by Users.</p>
</td></tr>
<tr><td><code id="FromCF2yuima_law_+3A_time.names">time.names</code></td>
<td>
<p> Label of time.</p>
</td></tr>
<tr><td><code id="FromCF2yuima_law_+3A_var_char">var_char</code></td>
<td>
<p> Argument of the characteristic function.</p>
</td></tr>
<tr><td><code id="FromCF2yuima_law_+3A_up">up</code></td>
<td>
<p> Upper bound for the internal integration.</p>
</td></tr>
<tr><td><code id="FromCF2yuima_law_+3A_low">low</code></td>
<td>
<p> Lower bound for the internal integration.</p>
</td></tr>
<tr><td><code id="FromCF2yuima_law_+3A_n_grid">N_grid</code></td>
<td>
<p> Observation grid. </p>
</td></tr>
<tr><td><code id="FromCF2yuima_law_+3A_n_fourier">N_Fourier</code></td>
<td>
<p> Number of points for the Fourier Inversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The density function is obtained by means of the Fourier Transform.</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+yuima.law-class">yuima.law-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='get.counting.data'>
Extract arrival times from an object of class <code>yuima.PPR</code>
</h2><span id='topic+get.counting.data'></span><span id='topic+NoisePPR'></span>

<h3>Description</h3>

<p>This function extracts arrival times from an object of class <code><a href="#topic+yuima.PPR">yuima.PPR</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.counting.data(yuimaPPR,type="zoo")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.counting.data_+3A_yuimappr">yuimaPPR</code></td>
<td>
<p>An object of class <code><a href="#topic+yuima.PPR">yuima.PPR</a></code>.</p>
</td></tr>
<tr><td><code id="get.counting.data_+3A_type">type</code></td>
<td>
<p>By default <code>type="zoo"</code> the function returns an object of class <code>zoo</code>. Other values are <code>yuima.PPR</code> and <code>matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default the function returns an object of class zoo. The arrival times can be extracted by applying the method <code>index</code> to the output</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##################
# Hawkes Process #
##################

# Values of parameters.
mu &lt;- 2
alpha &lt;- 4
beta &lt;-5

# Law definition

my.rHawkes &lt;- function(n){
  res &lt;- t(t(rep(1,n)))
  return(res)
}

Law.Hawkes &lt;- setLaw(rng = my.rHawkes)

# Point Process Definition

gFun &lt;- "mu"
Kernel &lt;- "alpha*exp(-beta*(t-s))"

modHawkes &lt;- setModel(drift = c("0"), diffusion = matrix("0",1,1),
  jump.coeff = matrix(c("1"),1,1), measure = list(df = Law.Hawkes),
  measure.type = "code", solve.variable = c("N"),
  xinit=c("0"))

prvHawkes &lt;- setPPR(yuima = modHawkes, counting.var="N", gFun=gFun,
  Kernel = as.matrix(Kernel), lambda.var = "lambda", 
  var.dx = "N", lower.var="0", upper.var = "t")

true.par &lt;- list(mu=mu, alpha=alpha,  beta=beta)

set.seed(1)

Term&lt;-70
n&lt;-7000

# Simulation trajectory

time.Hawkes &lt;-system.time(
  simHawkes &lt;- simulate(object = prvHawkes, true.parameter = true.par,
     sampling = setSampling(Terminal =Term, n=n))
)

# Arrival times of the Counting process.

DataHawkes &lt;- get.counting.data(simHawkes)
TimeArr &lt;- index(DataHawkes)

##################################
# Point Process Regression Model #
##################################

# Values of parameters.
mu &lt;- 2
alpha &lt;- 4
beta &lt;-5

# Law definition
my.rKern &lt;- function(n,t){
  res0 &lt;- t(t(rgamma(n, 0.1*t)))
  res1 &lt;- t(t(rep(1,n)))
  res &lt;- cbind(res0,res1)
  return(res)
}

Law.PPRKern &lt;- setLaw(rng = my.rKern)

# Point Process definition
modKern &lt;- setModel(drift = c("0.4*(0.1-X)","0"),
                    diffusion = c("0","0"),
                    jump.coeff = matrix(c("1","0","0","1"),2,2),
                    measure = list(df = Law.PPRKern),
                    measure.type = c("code","code"),
                    solve.variable = c("X","N"),
                    xinit=c("0.25","0"))

gFun &lt;- "exp(mu*log(1+X))"
#
Kernel &lt;- "alpha*exp(-beta*(t-s))"

prvKern &lt;- setPPR(yuima = modKern,
                  counting.var="N", gFun=gFun,
                  Kernel = as.matrix(Kernel),
                  lambda.var = "lambda", var.dx = "N",
                  lower.var="0", upper.var = "t")

# Simulation

Term&lt;-100
seed&lt;-1
n&lt;-10000

true.parKern &lt;- list(mu=mu, alpha=alpha, beta=beta)


set.seed(seed)
# set.seed(1)

time.simKern &lt;-system.time(
  simprvKern &lt;- simulate(object = prvKern, true.parameter = true.parKern,
                         sampling = setSampling(Terminal =Term, n=n))
)


plot(simprvKern,main ="Counting Process with covariates" ,cex.main=0.9)

# Arrival Times
CountVar &lt;- get.counting.data(simprvKern)
TimeArr &lt;- index(CountVar)



## End(Not run)
</code></pre>

<hr>
<h2 id='gmm'>
Method of Moments for COGARCH(P,Q).
</h2><span id='topic+gmm'></span><span id='topic+gmm.COGARCH'></span><span id='topic+Method+20of+20Moment+20COGARCH'></span>

<h3>Description</h3>

<p>The function returns the estimated parameters of a COGARCH(P,Q) model. The parameters are abtained by matching theoretical vs empirical autocorrelation function. The theoretical autocorrelation function is computed according the methodology developed in Chadraa (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm(yuima, data = NULL, start,
 method="BFGS", fixed = list(), lower, upper, lag.max = NULL,
 equally.spaced = FALSE, aggregation=TRUE, Est.Incr = "NoIncr", objFun = "L2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmm_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object or an object of <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code>.</p>
</td></tr>
<tr><td><code id="gmm_+3A_data">data</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> contains the observations available at uniformly spaced time. If <code>data=NULL</code>, the default, the function uses the data in an object of <code><a href="#topic+yuima-class">yuima-class</a></code>.</p>
</td></tr>
<tr><td><code id="gmm_+3A_start">start</code></td>
<td>
<p>a <code>list</code> containing the starting values for the optimization routine.</p>
</td></tr>
<tr><td><code id="gmm_+3A_method">method</code></td>
<td>
<p>a string indicating one of the methods available in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="gmm_+3A_fixed">fixed</code></td>
<td>
<p>a list of fixed parameters in optimization routine.</p>
</td></tr>
<tr><td><code id="gmm_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="gmm_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="gmm_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the theoretical and empirical acf. Default is <code>sqrt{N}</code> where <code>N</code> is the number of observation.</p>
</td></tr>
<tr><td><code id="gmm_+3A_equally.spaced">equally.spaced</code></td>
<td>
<p>Logical variable. If <code>equally.spaced = TRUE.</code>, the function use the returns of COGARCH(P,Q) evaluated at unitary length for the computation of the empirical autocorrelations. If <code>equally.spaced = FALSE</code>, the increments are evaluated on the interval with frequency specified in an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> that contains the observed time series.</p>
</td></tr>
<tr><td><code id="gmm_+3A_aggregation">aggregation</code></td>
<td>
<p>If <code>aggregation=TRUE</code>, before the estimation of the levy parameters we aggregate the estimated increments</p>
</td></tr>
<tr><td><code id="gmm_+3A_est.incr">Est.Incr</code></td>
<td>
<p> a string variable, If <code>Est.Incr = "NoIncr"</code>, default value, <code>gmm</code> returns an object of class  <code><a href="#topic+cogarch.est-class">cogarch.est-class</a></code> that contains the COGARCH parameters.
If <code>Est.Incr = "Incr"</code> or <code>Est.Incr = "IncrPar"</code> the output is an object of class <code><a href="#topic+cogarch.est.incr-class">cogarch.est.incr-class</a></code>. In the first case the object contains the increments of underlying noise while in the second case also the estimated parameter of levy measure.</p>
</td></tr>
<tr><td><code id="gmm_+3A_objfun">objFun</code></td>
<td>
<p>a string variable that indentifies the objective function in the optimization step. <code>objFun = "L2"</code>, default value, the objective function is  a quadratic form where the weighting Matrix is the identity one. <code>objFun = "L2CUE"</code> the weighting matrix is estimated using Continuously Updating GMM (L2CUE).
<code>objFun = "L1"</code>, the objective function is the mean absolute error. In the last case the standard error for estimators are not available.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine is based on three steps: estimation of the COGARCH parameters, recovering the increments of the underlying Levy process and estimation of the levy measure parameters. The last two steps are available on request by the user.
</p>


<h3>Value</h3>

<p> The function returns a list with the same components of the object obtained when the function  <code><a href="stats.html#topic+optim">optim</a></code> is used.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team.
</p>


<h3>References</h3>

<p>Chadraa, E. (2009) Statistical Modeling with COGARCH(P,Q) Processes. Phd Thesis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example COGARCH(1,1): the parameters are the same used in Haugh et al. 2005. In this case
# we assume the underlying noise is a symmetric variance gamma.
# As first step we define the COGARCH(1,1) in yuima:

mod1 &lt;- setCogarch(p = 1, q = 1, work = FALSE,
                   measure=list(df="rbgamma(z,1,sqrt(2),1,sqrt(2))"),
                    measure.type = "code", Cogarch.var = "y",
                    V.var = "v", Latent.var="x",XinExpr=TRUE)

param &lt;- list(a1 = 0.038,  b1 =  0.053,
              a0 = 0.04/0.053, x01 = 20)

# We generate a trajectory
samp &lt;- setSampling(Terminal=10000, n=100000)
set.seed(210)
sim1 &lt;- simulate(mod1, sampling = samp, true.parameter = param)

# We estimate the model

res1 &lt;- gmm(yuima = sim1, start = param)

summary(res1)


## End(Not run)
</code></pre>

<hr>
<h2 id='hyavar'>
Asymptotic Variance Estimator for the Hayashi-Yoshida estimator
</h2><span id='topic+hyavar'></span>

<h3>Description</h3>

<p>This function estimates the asymptotic variances of covariance and correlation estimates by the Hayashi-Yoshida estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyavar(yuima, bw, nonneg = TRUE, psd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hyavar_+3A_yuima">yuima</code></td>
<td>

<p>an object of yuima-class or yuima.data-class.
</p>
</td></tr>
<tr><td><code id="hyavar_+3A_bw">bw</code></td>
<td>

<p>a positive number or a numeric matrix. If it is a matrix, each component indicate the bandwidth parameter for the kernel estimators used to estimate the asymptotic variance of the corresponding component (necessary only for off-diagonal components). If it is a number, it is converted to a matrix as <code>matrix(bw,d,d)</code>, where <code>d=dim(x)</code>. The default value is the matrix whose <code class="reqn">(i,j)</code>-th component is given by <code class="reqn">min(n_i,n_j)^{0.45}</code>, where <code class="reqn">n_i</code> denotes the number of the observations for the <code class="reqn">i</code>-th component of the data.
</p>
</td></tr>
<tr><td><code id="hyavar_+3A_nonneg">nonneg</code></td>
<td>

<p>logical. If <code>TRUE</code>, the asymptotic variance estimates for correlations are always ensured to be non-negative. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="hyavar_+3A_psd">psd</code></td>
<td>

<p>passed to <code><a href="#topic+cce">cce</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The precise description of the method used to estimate the asymptotic variances is as follows. 
For diagonal components, they are estimated by the realized quarticity multiplied by <code>2/3</code>. Its theoretical validity is ensured by Hayashi et al. (2011), for example. 
For off-diagonal components, they are estimated by the naive kernel approach descrived in Section 8.2 of Hayashi and Yoshida (2011). Note that the asymptotic covariance between a diagonal component and another component, which is necessary to evaluate the asymptotic variances of correlation estimates, is not provided in Hayashi and Yoshida (2011), but it can be derived in a similar manner to that paper.
<br />
<br />
If <code>nonneg</code> is <code>TRUE</code>, negative values of the asymptotic variances of correlations are avoided in the following way. The computed asymptotic varaince-covariance matrix of the vector <code class="reqn">(HY_{ii},HY_{ij},HY_{jj})</code> is converted to its spectral absolute value. Here, <code class="reqn">HY_{ij}</code> denotes the Hayashi-Yohida estimator for the <code class="reqn">(i,j)</code>-th component.
<br />
<br />
The function also returns the covariance and correlation matrices calculated by the Hayashi-Yoshida estimator (using <code><a href="#topic+cce">cce</a></code>).
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>covmat</code></td>
<td>
<p>the estimated covariance matrix</p>
</td></tr>
<tr><td><code>cormat</code></td>
<td>
<p>the estimated correlation matrix</p>
</td></tr>
<tr><td><code>avar.cov</code></td>
<td>
<p>the estimated asymptotic variances for covariances</p>
</td></tr>
<tr><td><code>avar.cor</code></td>
<td>
<p>the estimated asymptotic variances for correlations</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Construction of kernel-type estimators for off-diagonal components is implemented after pseudo-aggregation described in Bibinger (2011).
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Barndorff-Nilesen, O. E. and Shephard, N. (2004)
Econometric analysis of realized covariation: High frequency based covariance, regression, and correlation in financial economics, 
<em>Econometrica</em>, <b>72</b>, no. 3, 885&ndash;925.
</p>
<p>Bibinger, M. (2011)
Asymptotics of Asynchronicity, 
technical report, Available at <a href="https://doi.org/10.48550/arXiv.1106.4222">doi:10.48550/arXiv.1106.4222</a>.
</p>
<p>Hayashi, T., Jacod, J. and Yoshida, N. (2011)
Irregular sampling and central limit theorems for power variations: The continuous case,
<em>Annales de l'Institut Henri Poincare - Probabilites et Statistiques</em>, <b>47</b>, no. 4, 1197&ndash;1218.
</p>
<p>Hayashi, T. and Yoshida, N. (2011)
Nonsynchronous covariation process and limit theorems,
<em>Stochastic processes and their applications</em>, <b>121</b>, 2416&ndash;2454.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setData">setData</a></code>, <code><a href="#topic+cce">cce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Set a model
diff.coef.1 &lt;- function(t, x1 = 0, x2 = 0) sqrt(1+t)
diff.coef.2 &lt;- function(t, x1 = 0, x2 = 0) sqrt(1+t^2)
cor.rho &lt;- function(t, x1 = 0, x2 = 0) sqrt(1/2)
diff.coef.matrix &lt;- matrix(c("diff.coef.1(t,x1,x2)", 
"diff.coef.2(t,x1,x2) * cor.rho(t,x1,x2)", 
"", "diff.coef.2(t,x1,x2) * sqrt(1-cor.rho(t,x1,x2)^2)"), 2, 2) 
cor.mod &lt;- setModel(drift = c("", ""), 
diffusion = diff.coef.matrix,solve.variable = c("x1", "x2")) 

set.seed(111) 

## We use a function poisson.random.sampling to get observation by Poisson sampling.
yuima.samp &lt;- setSampling(Terminal = 1, n = 1200) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima) 
psample&lt;- poisson.random.sampling(yuima, rate = c(0.2,0.3), n = 1000) 

## Constructing a 95% confidence interval for the quadratic covariation from psample
result &lt;- hyavar(psample)
thetahat &lt;- result$covmat[1,2] # estimate of the quadratic covariation
se &lt;- sqrt(result$avar.cov[1,2]) # estimated standard error
c(lower = thetahat + qnorm(0.025) * se, upper = thetahat + qnorm(0.975) * se)

## True value of the quadratic covariation.
cc.theta &lt;- function(T, sigma1, sigma2, rho) { 
  tmp &lt;- function(t) return(sigma1(t) * sigma2(t) * rho(t)) 
  integrate(tmp, 0, T) 
}

# contained in the constructed confidence interval
cc.theta(T = 1, diff.coef.1, diff.coef.2, cor.rho)$value

# Example. A stochastic differential equation with nonlinear feedback. 

## Set a model
drift.coef.1 &lt;- function(x1,x2) x2
drift.coef.2 &lt;- function(x1,x2) -x1
drift.coef.vector &lt;- c("drift.coef.1","drift.coef.2")
diff.coef.1 &lt;- function(t,x1,x2) sqrt(abs(x1))*sqrt(1+t)
diff.coef.2 &lt;- function(t,x1,x2) sqrt(abs(x2))
cor.rho &lt;- function(t,x1,x2) 1/(1+x1^2)
diff.coef.matrix &lt;- matrix(c("diff.coef.1(t,x1,x2)", 
"diff.coef.2(t,x1,x2) * cor.rho(t,x1,x2)","", 
"diff.coef.2(t,x1,x2) * sqrt(1-cor.rho(t,x1,x2)^2)"), 2, 2) 
cor.mod &lt;- setModel(drift = drift.coef.vector,
 diffusion = diff.coef.matrix,solve.variable = c("x1", "x2"))

## Generate a path of the process
set.seed(111) 
yuima.samp &lt;- setSampling(Terminal = 1, n = 10000) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima, xinit=c(2,3)) 
plot(yuima)


## The "true" values of the covariance and correlation.
result.full &lt;- cce(yuima)
(cov.true &lt;- result.full$covmat[1,2]) # covariance
(cor.true &lt;- result.full$cormat[1,2]) # correlation

## We use the function poisson.random.sampling to generate nonsynchronous 
## observations by Poisson sampling.
psample&lt;- poisson.random.sampling(yuima, rate = c(0.2,0.3), n = 3000) 

## Constructing 95% confidence intervals for the covariation from psample
result &lt;- hyavar(psample)
cov.est &lt;- result$covmat[1,2] # estimate of covariance
cor.est &lt;- result$cormat[1,2] # estimate of correlation
se.cov &lt;- sqrt(result$avar.cov[1,2]) # estimated standard error of covariance
se.cor &lt;- sqrt(result$avar.cor[1,2]) # estimated standard error of correlation

## 95% confidence interval for covariance
c(lower = cov.est + qnorm(0.025) * se.cov,
 upper = cov.est + qnorm(0.975) * se.cov) # contains cov.true

## 95% confidence interval for correlation
c(lower = cor.est + qnorm(0.025) * se.cor,
 upper = cor.est + qnorm(0.975) * se.cor) # contains cor.true

## We can also use the Fisher z transformation to construct a
## 95% confidence interval for correlation
## It often improves the finite sample behavior of the asymptotic
## theory (cf. Section 4.2.3 of Barndorff-Nielsen and Shephard (2004))
z &lt;- atanh(cor.est) # the Fisher z transformation of the estimated correlation
se.z &lt;- se.cor/(1 - cor.est^2) # standard error for z (calculated by the delta method)
## 95% confidence interval for correlation via the Fisher z transformation
c(lower = tanh(z + qnorm(0.025) * se.z), upper = tanh(z + qnorm(0.975) * se.z)) 

## End(Not run)
</code></pre>

<hr>
<h2 id='IC'>
Information criteria for the stochastic differential equation
</h2><span id='topic+IC'></span>

<h3>Description</h3>

<p>Information criteria BIC, Quasi-BIC (QBIC) and CIC for the stochastic differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC(drif = NULL, diff = NULL, jump.coeff = NULL, data = NULL, Terminal = 1, 
   add.settings = list(), start, lower, upper, ergodic = TRUE,
   stepwise = FALSE, weight = FALSE, rcpp = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IC_+3A_drif">drif</code></td>
<td>

<p>a character vector that each element presents the candidate drift coefficient.
</p>
</td></tr>
<tr><td><code id="IC_+3A_diff">diff</code></td>
<td>

<p>a character vector that each element presents the candidate diffusion coefficient.
</p>
</td></tr>
<tr><td><code id="IC_+3A_jump.coeff">jump.coeff</code></td>
<td>

<p>a character vector that each element presents the candidate scale coefficient.
</p>
</td></tr>
<tr><td><code id="IC_+3A_data">data</code></td>
<td>

<p>the data to be used.
</p>
</td></tr>
<tr><td><code id="IC_+3A_terminal">Terminal</code></td>
<td>

<p>terminal time of the grid.
</p>
</td></tr>
<tr><td><code id="IC_+3A_add.settings">add.settings</code></td>
<td>

<p>details of model settings(see <code><a href="#topic+setModel">setModel</a></code>).
</p>
</td></tr>
<tr><td><code id="IC_+3A_start">start</code></td>
<td>

<p>a named list of the initial values of the parameters for optimization.
</p>
</td></tr>
<tr><td><code id="IC_+3A_lower">lower</code></td>
<td>

<p>a named list for specifying lower bounds of the parameters.
</p>
</td></tr>
<tr><td><code id="IC_+3A_upper">upper</code></td>
<td>

<p>a named list for specifying upper bounds of the parameters.
</p>
</td></tr>
<tr><td><code id="IC_+3A_ergodic">ergodic</code></td>
<td>

<p>whether the candidate models are ergodic SDEs or not(default <code>ergodic=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="IC_+3A_stepwise">stepwise</code></td>
<td>

<p>specifies joint procedure or stepwise procedure(default <code>stepwise=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="IC_+3A_weight">weight</code></td>
<td>

<p>calculate model weight? (default <code>weight=FALSE</code>)
</p>
</td></tr>
<tr><td><code id="IC_+3A_rcpp">rcpp</code></td>
<td>

<p>use C++ code? (default <code>rcpp=FALSE</code>)
</p>
</td></tr>
<tr><td><code id="IC_+3A_...">...</code></td>
<td>
<p>passed to <code>qmle</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the information criteria BIC, QBIC, and CIC for stochastic processes.
The calculation and model selection are performed by joint procedure or stepwise procedure.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>BIC</code></td>
<td>

<p>values of BIC for all candidates.
</p>
</td></tr>
<tr><td><code>QBIC</code></td>
<td>

<p>values of QBIC for all candidates.
</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>

<p>values of AIC-type information criterion for all candidates.
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>information of all candidate models.
</p>
</td></tr>
<tr><td><code>par</code></td>
<td>

<p>quasi-maximum likelihood estimator for each candidate.
</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>

<p>model weights for all candidates.
</p>
</td></tr>
<tr><td><code>selected</code></td>
<td>

<p>selected model number and selected drift and diffusion coefficients
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code>IC</code> uses the function <code><a href="#topic+qmle">qmle</a></code> with <code>method="L-BFGS-B"</code> internally.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Shoichi Eguchi <a href="mailto:shoichi.eguchi@oit.ac.jp">shoichi.eguchi@oit.ac.jp</a>
</p>


<h3>References</h3>

<p>## AIC, BIC
</p>
<p>Akaike, H. (1973). Information theory and an extension of the maximum likelihood principle. In Second International Symposium on Information Theory (Tsahkadsor, 1971), 267-281. <a href="https://doi.org/10.1007/978-1-4612-1694-0_15">doi:10.1007/978-1-4612-1694-0_15</a>
</p>
<p>Schwarz, G. (1978). Estimating the dimension of a model. The Annals of Statistics, 6(2), 461-464. <a href="https://doi.org/10.1214/aos/1176344136">doi:10.1214/aos/1176344136</a>
</p>
<p>## BIC, Quasi-BIC
</p>
<p>Eguchi, S. and Masuda, H. (2018). Schwarz type model comparison for LAQ models. Bernoulli, 24(3), 2278-2327. <a href="https://doi.org/10.3150/17-BEJ928">doi:10.3150/17-BEJ928</a>.
</p>
<p>## CIC
</p>
<p>Uchida, M. (2010). Contrast-based information criterion for ergodic diffusion processes from discrete observations. Annals of the Institute of Statistical Mathematics, 62(1), 161-187. <a href="https://doi.org/10.1007/s10463-009-0245-1">doi:10.1007/s10463-009-0245-1</a>
</p>
<p>## Model weight
</p>
<p>Burnham, K. P. and Anderson, D. R. (2002). Model Selection and Multimodel Inference. Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Ex.1 
set.seed(123)

N &lt;- 1000   # number of data
h &lt;- N^(-2/3)  # sampling stepsize
Ter &lt;- N*h  # terminal sampling time

## Data generate (dXt = -Xt*dt + exp((-2*cos(Xt) + 1)/2)*dWt)
mod &lt;- setModel(drift="theta21*x", diffusion="exp((theta11*cos(x)+theta12)/2)")
samp &lt;- setSampling(Terminal=Ter, n = N)
yuima &lt;- setYuima(model=mod, sampling=setSampling(Terminal=Ter, n=50*N))
simu.yuima &lt;- simulate(yuima, xinit=1, true.parameter=list(theta11=-2, theta12=1, 
                       theta21=-1), subsampling=samp)
Xt &lt;- NULL
for(i in 1:(N+1)){
  Xt &lt;- c(Xt, simu.yuima@data@original.data[50*(i-1)+1])
}

## Candidate coefficients
diffusion &lt;- c("exp((theta11*cos(x)+theta12*sin(x)+theta13)/2)", 
               "exp((theta11*cos(x)+theta12*sin(x))/2)", 
               "exp((theta11*cos(x)+theta13)/2)", "exp((theta12*sin(x)+theta13)/2)")
drift &lt;- c("theta21*x + theta22", "theta21*x")

## Parameter settings
para.init &lt;- list(theta11=runif(1,max=5,min=-5), theta12=runif(1,max=5,min=-5), 
                  theta13=runif(1,max=5,min=-5), theta21=runif(1,max=-0.5,min=-1.5),
                  theta22=runif(1,max=-0.5,min=-1.5))
para.low &lt;- list(theta11=-10, theta12=-10, theta13=-10, theta21=-5, theta22=-5)
para.upp &lt;- list(theta11=10, theta12=10, theta13=10, theta21=-0.001, theta22=-0.001)

## Ex.1.1 Joint
ic1 &lt;- IC(drif=drift, diff=diffusion, data=Xt, Terminal=Ter, start=para.init, lower=para.low, 
          upper=para.upp, stepwise = FALSE, weight = FALSE, rcpp = TRUE)
ic1

## Ex.1.2 Stepwise
ic2 &lt;- IC(drif=drift, diff=diffusion, data=Xt, Terminal=Ter, 
          start=para.init, lower=para.low, upper=para.upp,
          stepwise = TRUE, weight = FALSE, rcpp = TRUE)
ic2


### Ex.2 (multidimansion case) 
set.seed(123)

N &lt;- 3000   # number of data
h &lt;- N^(-2/3)  # sampling stepsize
Ter &lt;- N*h  # terminal sampling time

## Data generate
diff.coef.matrix &lt;- matrix(c("beta1*x1+beta3", "1", "-1", "beta1*x1+beta3"), 2, 2)
drif.coef.vec &lt;- c("alpha1*x1", "alpha2*x2")
mod &lt;- setModel(drift = drif.coef.vec, diffusion = diff.coef.matrix, 
                state.variable = c("x1", "x2"), solve.variable = c("x1", "x2"))
samp &lt;- setSampling(Terminal = Ter, n = N)
yuima &lt;- setYuima(model = mod, sampling = setSampling(Terminal = N^(1/3), n = 50*N))
simu.yuima &lt;- simulate(yuima, xinit = c(1,1), true.parameter = list(alpha1=-2, alpha2=-1, 
                       beta1=-1, beta3=2), subsampling = samp)
Xt &lt;- matrix(0,(N+1),2)
for(i in 1:(N+1)){
  Xt[i,] &lt;- simu.yuima@data@original.data[50*(i-1)+1,]
}

## Candidate coefficients
diffusion &lt;- list(matrix(c("beta1*x1+beta2*x2+beta3", "1", "-1", "beta1*x1+beta2*x2+beta3"), 2, 2),
                  matrix(c("beta1*x1+beta2*x2", "1", "-1", "beta1*x1+beta2*x2"), 2, 2),
                  matrix(c("beta1*x1+beta3", "1", "-1", "beta1*x1+beta3"), 2, 2),
                  matrix(c("beta2*x2+beta3", "1", "-1", "beta2*x2+beta3"), 2, 2),
                  matrix(c("beta1*x1", "1", "-1", "beta1*x1"), 2, 2),
                  matrix(c("beta2*x2", "1", "-1", "beta2*x2"), 2, 2),
                  matrix(c("beta3", "1", "-1", "beta3"), 2, 2))
drift &lt;- list(c("alpha1*x1", "alpha2*x2"), c("alpha1*x2", "alpha2*x1"))
modsettings &lt;- list(state.variable = c("x1", "x2"), solve.variable = c("x1", "x2"))

## Parameter settings
para.init &lt;- list(alpha1 = runif(1,min=-3,max=-1), alpha2 = runif(1,min=-2,max=0),
                  beta1 = runif(1,min=-2,max=0), beta2 = runif(1,min=0,max=2), 
                  beta3 = runif(1,min=1,max=3))
para.low &lt;- list(alpha1 = -5, alpha2 = -5, beta1 = -5, beta2 = -5, beta3 = 1)
para.upp &lt;- list(alpha1 = 0.01, alpha2 = -0.01, beta1 = 5, beta2 = 5, beta3 = 10)

## Ex.2.1 Joint
ic3 &lt;- IC(drif=drift, diff=diffusion, data=Xt, Terminal=Ter, add.settings=modsettings, 
          start=para.init, lower=para.low, upper=para.upp, 
          weight=FALSE, rcpp=FALSE)
ic3

## Ex.2.2 Stepwise
ic4 &lt;- IC(drif=drift, diff=diffusion, data=Xt, Terminal=Ter, add.settings=modsettings, 
             start=para.init, lower=para.low, upper=para.upp,
             stepwise = TRUE, weight=FALSE, rcpp=FALSE)
ic4


## End(Not run)
</code></pre>

<hr>
<h2 id='info.Map-class'>Class for information about Map/Operators</h2><span id='topic+info.Map'></span><span id='topic+info.Map-class'></span><span id='topic+initialize+2Cinfo.Map-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.Map">yuima.Map</a></code>. see the documentation of <code><a href="#topic+yuima.Map">yuima.Map</a></code> for more details.
</p>

<hr>
<h2 id='info.PPR'>Class for information about Point Process</h2><span id='topic+info.PPR'></span><span id='topic+info.PPR-class'></span><span id='topic+initialize+2Cinfo.PPR-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.PPR">yuima.PPR</a></code> and <code><a href="#topic+yuima.Hawkes">yuima.Hawkes</a></code>. see the documentation for more details.
</p>

<hr>
<h2 id='Integral.sde'>Class for the mathematical description of integral of a stochastic process</h2><span id='topic+Integral.sde'></span><span id='topic+Integral.sde-class'></span><span id='topic+initialize+2CIntegral.sde-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.Integral">yuima.Integral</a></code>. see the documentation of <code><a href="#topic+yuima.Integral">yuima.Integral</a></code> for more details.
</p>

<hr>
<h2 id='Integrand'>Class for the mathematical description of integral of a stochastic process</h2><span id='topic+Integrand'></span><span id='topic+Integrand-class'></span><span id='topic+initialize+2CIntegrand-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.Integral">yuima.Integral</a></code>. see the documentation of <code><a href="#topic+yuima.Integral">yuima.Integral</a></code> for more details.
</p>

<hr>
<h2 id='Intensity.PPR'>Intesity Process for the Point Process Regression Model</h2><span id='topic+Intensity.PPR'></span>

<h3>Description</h3>

<p>This function returns the intensity process of a Point Process Regression Model</p>


<h3>Usage</h3>

<pre><code class='language-R'>Intensity.PPR(yuimaPPR, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Intensity.PPR_+3A_yuimappr">yuimaPPR</code></td>
<td>
<p>An object of class <code>yuima.PPR</code></p>
</td></tr>
<tr><td><code id="Intensity.PPR_+3A_param">param</code></td>
<td>
<p>Model parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>On obejct of class <code>yuima.data</code></p>


<h3>Author(s)</h3>

<p>YUIMA TEAM</p>


<h3>Examples</h3>

<pre><code class='language-R'>#INSERT HERE AN EXAMPLE
</code></pre>

<hr>
<h2 id='JBtest'>
Remove jumps and calculate the Gaussian quasi-likelihood estimator based on the Jarque-Bera normality test 
</h2><span id='topic+JBtest'></span>

<h3>Description</h3>

<p>Remove jumps and calculate the Gaussian quasi-likelihood estimator based on the Jarque-Bera normality test 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JBtest(yuima,start,lower,upper,alpha,skewness=TRUE,kurtosis=TRUE,withdrift=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JBtest_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object (diffusion with compound Poisson jumps).</p>
</td></tr>
<tr><td><code id="JBtest_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="JBtest_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="JBtest_+3A_alpha">alpha</code></td>
<td>
<p>Insert Description Here.</p>
</td></tr>
<tr><td><code id="JBtest_+3A_start">start</code></td>
<td>
<p>initial values to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="JBtest_+3A_skewness">skewness</code></td>
<td>
<p>use third moment information ? by default, skewness=TRUE</p>
</td></tr>
<tr><td><code id="JBtest_+3A_kurtosis">kurtosis</code></td>
<td>
<p>use fourth moment information ? by default, kurtosis=TRUE</p>
</td></tr>
<tr><td><code id="JBtest_+3A_withdrift">withdrift</code></td>
<td>
<p>use drift information for constructing self-normalized residuals or not? by default, withdrift = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function removes large increments which are regarded as jumps based on the iterative Jarque-Bera normality test, and after that, calculates the Gaussian quasi maximum likelihood estimator.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Removed</code></td>
<td>
<p>Removed jumps and jump times</p>
</td></tr>
<tr><td><code>OGQMLE</code></td>
<td>
<p>Gaussian quasi maximum likelihood estimator before jump removal</p>
</td></tr>
<tr><td><code>JRGQMLE</code></td>
<td>
<p>Gaussian quasi maximum likelihood estimator after jump removal</p>
</td></tr>
<tr><td><code>Figures</code></td>
<td>
<p>For visualization, the jump points are presented. In addition, the histgram of the jump removed self-normalized residuals, transition of the estimators and the logarithm of Jarque-Bera statistics are given as figures</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Yuma Uehara <a href="mailto:y-uehara@ism.ac.jp">y-uehara@ism.ac.jp</a>
</p>


<h3>References</h3>

<p>Masuda, H. (2013). Asymptotics for functionals of self-normalized residuals of discretely observed stochastic processes. 
Stochastic Processes and their Applications 123 (2013), 2752&ndash;2778
</p>
<p>Masuda, H and Uehara, Y. (2018) Estimating Diffusion With Compound Poisson Jumps Based On Self-normalized Residuals, arXiv:1802.03945
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
mod &lt;- setModel(drift="10-3*x",
                diffusion="theta*(2+x^2)/(1+x^2)",
               jump.coeff="1",
               measure=list(intensity="1",df=list("dunif(z, 3, 5)")),
               measure.type="CP")

T &lt;- 10 ## Terminal
n &lt;- 5000 ## generation size
samp &lt;- setSampling(Terminal=T, n=n) ## define sampling scheme
yuima &lt;- setYuima(model = mod, sampling = samp)

yuima &lt;- simulate(yuima, xinit=1,true.parameter=list(theta=sqrt(2)), sampling = samp)

JBtest(yuima,start=list(theta=0.5),upper=c(theta=100)
,lower=c(theta=0),alpha=0.01)

## End(Not run)
</code></pre>

<hr>
<h2 id='lambdaFromData'>
Intensity of a Point Process Regression Model
</h2><span id='topic+lambdaFromData'></span>

<h3>Description</h3>

<p>This function returns the intensity process of a PPR model when covariates and counting processes are obsered on discrete time</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaFromData(yuimaPPR, PPRData = NULL, parLambda = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambdaFromData_+3A_yuimappr">yuimaPPR</code></td>
<td>
<p> Mathematical Description of PPR model
</p>
</td></tr>
<tr><td><code id="lambdaFromData_+3A_pprdata">PPRData</code></td>
<td>
<p>Observed data</p>
</td></tr>
<tr><td><code id="lambdaFromData_+3A_parlambda">parLambda</code></td>
<td>
<p>Values of intesity parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p> ... </p>


<h3>Value</h3>

<p>...</p>


<h3>Note</h3>

<p>...</p>


<h3>Author(s)</h3>

<p>YUIMA TEAM</p>


<h3>References</h3>

<p>...</p>


<h3>See Also</h3>

<p>...</p>

<hr>
<h2 id='lasso'>Adaptive LASSO estimation for stochastic differential equations</h2><span id='topic+lasso'></span>

<h3>Description</h3>

<p>Adaptive LASSO estimation for stochastic differential equations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso(yuima, lambda0, start, delta=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="lasso_+3A_lambda0">lambda0</code></td>
<td>
<p>a named list with penalty for each parameter.</p>
</td></tr>
<tr><td><code id="lasso_+3A_start">start</code></td>
<td>
<p>initial values to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="lasso_+3A_delta">delta</code></td>
<td>
<p>controls the amount of shrinking in the adaptive sequences.</p>
</td></tr>
<tr><td><code id="lasso_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="stats.html#topic+optim">optim</a></code> method. See Examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lasso</code> behaves more likely the standard <code><a href="#topic+qmle">qmle</a></code> function in  and
argument <code>method</code> is one of the methods available in <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
<p>From initial guess of QML estimates, performs adaptive LASSO estimation using 
the Least Squares Approximation (LSA) as in Wang and Leng (2007, JASA).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ans</code></td>
<td>
<p>a list with both QMLE and LASSO estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##multidimension case
diff.matrix &lt;- matrix(c("theta1.1","theta1.2", "1", "1"), 2, 2)

drift.c &lt;- c("-theta2.1*x1", "-theta2.2*x2", "-theta2.2", "-theta2.1")
drift.matrix &lt;- matrix(drift.c, 2, 2)

ymodel &lt;- setModel(drift=drift.matrix, diffusion=diff.matrix, time.variable="t",
                   state.variable=c("x1", "x2"), solve.variable=c("x1", "x2"))
n &lt;- 100
ysamp &lt;- setSampling(Terminal=(n)^(1/3), n=n)
yuima &lt;- setYuima(model=ymodel, sampling=ysamp)
set.seed(123)

truep &lt;- list(theta1.1=0.6, theta1.2=0,theta2.1=0.5, theta2.2=0)
yuima &lt;- simulate(yuima, xinit=c(1, 1), 
 true.parameter=truep)


est &lt;- lasso(yuima, start=list(theta2.1=0.8, theta2.2=0.2, theta1.1=0.7, theta1.2=0.1),
 lower=list(theta1.1=1e-10,theta1.2=1e-10,theta2.1=.1,theta2.2=1e-10),
 upper=list(theta1.1=4,theta1.2=4,theta2.1=4,theta2.2=4), method="L-BFGS-B")

# TRUE
unlist(truep)

# QMLE
round(est$mle,3)

# LASSO
round(est$lasso,3) 

## End(Not run)
</code></pre>

<hr>
<h2 id='LawMethods'>Methods for an object of class <code>yuima.law</code></h2><span id='topic+LawMethods'></span><span id='topic+rand'></span><span id='topic+rand-method'></span><span id='topic+cdf'></span><span id='topic+quant'></span><span id='topic+char'></span><span id='topic+dens'></span>

<h3>Description</h3>

<p>Methods for yuima.law</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand(object, n, param, ...)
dens(object, x, param, log = FALSE, ...)
cdf(object, q, param, ...)
quant(object, p, param, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LawMethods_+3A_object">object</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_n">n</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_param">param</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_x">x</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_log">log</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_q">q</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="LawMethods_+3A_p">p</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Methods for an object of yuima.law-class</p>


<h3>Note</h3>

<p>Insert additional info</p>


<h3>Author(s)</h3>

<p>YUIMA TEAM</p>

<hr>
<h2 id='limiting.gamma'>calculate the value of limiting covariance matrices : Gamma</h2><span id='topic+limiting.gamma'></span>

<h3>Description</h3>

<p>To confirm assysmptotic normality of theta estimators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>limiting.gamma(obj,theta,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limiting.gamma_+3A_obj">obj</code></td>
<td>
<p>an yuima or yuima.model object.</p>
</td></tr>
<tr><td><code id="limiting.gamma_+3A_theta">theta</code></td>
<td>
<p>true theta</p>
</td></tr>
<tr><td><code id="limiting.gamma_+3A_verbose">verbose</code></td>
<td>
<p>an option for display a verbose process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the value of limiting covariance matrices Gamma.
The returned values gamma1 and gamma2 are used to confirm assysmptotic normality of theta estimators.
this program is limitted to 1-dimention-sde model for now.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>gamma1</code></td>
<td>
<p>a theoretical figure for variance of theta1 estimator</p>
</td></tr>
<tr><td><code>gamma2</code></td>
<td>
<p>a theoretical figure for variance of theta2 estimator</p>
</td></tr>
</table>


<h3>Note</h3>

<p>we need to fix this routine.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

## Yuima
diff.matrix &lt;- matrix(c("theta1"), 1, 1)
myModel &lt;- setModel(drift=c("(-1)*theta2*x"), diffusion=diff.matrix, 
time.variable="t", state.variable="x")
n &lt;- 100
mySampling &lt;- setSampling(Terminal=(n)^(1/3), n=n)
myYuima &lt;- setYuima(model=myModel, sampling=mySampling)
myYuima &lt;- simulate(myYuima, xinit=1, true.parameter=list(theta1=0.6, theta2=0.3))

## theorical figure of theta
theta1 &lt;- 3.5
theta2 &lt;- 1.3

theta &lt;- list(theta1, theta2)
lim.gamma &lt;- limiting.gamma(obj=myYuima, theta=theta, verbose=TRUE)

## return theta1 and theta2 with list
lim.gamma$list

## return theta1 and theta2 with vector
lim.gamma$vec

</code></pre>

<hr>
<h2 id='llag'>Lead Lag Estimator</h2><span id='topic+llag'></span><span id='topic+llag+2Clist-method'></span>

<h3>Description</h3>

<p>Estimate the lead-lag parameters of discretely observed processes by maximizing the shifted Hayashi-Yoshida covariation contrast functions, following Hoffmann et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llag(x, from = -Inf, to = Inf, division = FALSE, verbose = (ci || ccor), 
     grid, psd = TRUE, plot = ci, ccor = ci, ci = FALSE, alpha = 0.01, 
     fisher = TRUE, bw, tol = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llag_+3A_x">x</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.</p>
</td></tr>
<tr><td><code id="llag_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>FALSE</code>, <code>llag</code> returns lead-lag time estimates only. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="llag_+3A_from">from</code></td>
<td>
<p>a numeric vector each of whose component(s) indicates the lower end of a finite grid on which the contrast function is evaluated, if <code>grid</code> is missing.</p>
</td></tr>
<tr><td><code id="llag_+3A_to">to</code></td>
<td>
<p>a numeric vector each of whose component(s) indicates the upper end of a finite grid on which the contrast function is evaluated, if <code>grid</code> is missing.</p>
</td></tr>
<tr><td><code id="llag_+3A_division">division</code></td>
<td>
<p>a numeric vector each of whose component(s) indicates the number of the points of a finite grid on which the contrast function is evaluated, if <code>grid</code> is missing.</p>
</td></tr>
<tr><td><code id="llag_+3A_grid">grid</code></td>
<td>
<p>a numeric vector or a list of numeric vectors. See 'Details'.</p>
</td></tr>
<tr><td><code id="llag_+3A_psd">psd</code></td>
<td>
<p>logical. If <code>TRUE</code>, the estimated cross-correlation functions are converted to the interval [-1,1]. See 'Details'.</p>
</td></tr>
<tr><td><code id="llag_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, the estimated cross-correlation functions are plotted. If <code>ci</code> is also <code>TRUE</code>, the pointwise confidence intervals (under the null hypothesis that the corresponding correlation is zero) are also plotted. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="llag_+3A_ccor">ccor</code></td>
<td>
<p>logical. If <code>TRUE</code>, the estimated cross-correlation functions are returned. This argument is ignored if <code>verbose</code> is <code>FALSE</code>. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="llag_+3A_ci">ci</code></td>
<td>
<p>logical. If <code>TRUE</code>, (pointwise) confidence intervals of the estimated cross-correlation functions and p-values for the significance of the correlations at the estimated lead-lag parameters are calculated. Note that the confidence intervals are only plotted when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="llag_+3A_alpha">alpha</code></td>
<td>
<p>a posive number indicating the significance level of the confidence intervals for the cross-correlation functions.</p>
</td></tr>
<tr><td><code id="llag_+3A_fisher">fisher</code></td>
<td>
<p>logical. If <code>TRUE</code>, the p-values and the confidence intervals for the cross-correlation functions is evaluated after applying the Fisher z transformation. This argument is only meaningful if <code>pval = "corr"</code>.</p>
</td></tr>
<tr><td><code id="llag_+3A_bw">bw</code></td>
<td>
<p>bandwidth parameter to compute the asymptotic variances. See 'Details' and <code><a href="#topic+hyavar">hyavar</a></code> for details.</p>
</td></tr>
<tr><td><code id="llag_+3A_tol">tol</code></td>
<td>
<p>tolelance parameter to avoid numerical errors in comparison of time stamps. All time stamps are divided by <code>tol</code> and rounded to integers. Note that the values of <code>grid</code> are also divided by <code>tol</code> and rounded to integers. A reasonable choice of <code>tol</code> is the minimum unit of time stamps. The default value <code>1e-6</code> supposes that the minimum unit of time stamps is greater or equal to 1 micro-second.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">d</code> be the number of the components of the <code>zoo.data</code> of the object <code>x</code>.
</p>
<p>Let <code class="reqn">X^i_{t^i_{0}},X^i_{t^i_{1}},\dots,X^i_{t^i_{n(i)}}</code> be the observation data of the <code class="reqn">i</code>-th component (i.e. the <code class="reqn">i</code>-th component of the <code>zoo.data</code> of the object <code>x</code>).
</p>
<p>The shifted Hayashi-Yoshida covariation contrast function <code class="reqn">U_{ij}(\theta)</code> of the observations <code class="reqn">X^i</code> and <code class="reqn">X^j</code> <code class="reqn">(i&lt;j)</code> is defined by the same way as in Hoffmann et al. (2013), which corresponds to their cross-covariance function. The lead-lag parameter <code class="reqn">\theta_{ij}</code> is defined as a maximizer of <code class="reqn">|U_{ij}(\theta)|</code>. <code class="reqn">U_{ij}(\theta)</code> is evaluated on a finite grid <code class="reqn">G_{ij}</code> defined below. Thus <code class="reqn">\theta_{ij}</code> belongs to this grid. If there exist more than two maximizers, the lowest one is selected.
</p>
<p>If <code>psd</code> is <code>TRUE</code>, for any <code class="reqn">i,j</code> the matrix <code class="reqn">C:=(U_{kl}(\theta))_{k,l\in{i,j}}</code> is converted to <code>(C%*%C)^(1/2)</code> for ensuring the positive semi-definiteness, and <code class="reqn">U_{ij}(\theta)</code> is redefined as the <code class="reqn">(1,2)</code>-component of the converted <code class="reqn">C</code>. Here, <code class="reqn">U_{kk}(\theta)</code> is set to the realized volatility of <code class="reqn">Xk</code>. In this case <code class="reqn">\theta_{ij}</code> is given as a maximizer of the cross-correlation functions.
</p>
<p>The grid <code class="reqn">G_{ij}</code> is defined as follows. First, if <code>grid</code> is missing, <code class="reqn">G_{ij}</code> is given by  
</p>
<p style="text-align: center;"><code class="reqn">a, a+(b-a)/(N-1), \dots, a+(N-2)(b-a)/(N-1), b,</code>
</p>

<p>where <code class="reqn">a,b</code> and <code class="reqn">N</code> are the <code class="reqn">(d(i-1)-(i-1)i/2+(j-i))</code>-th components of <code>from</code>, <code>to</code> and <code>division</code> respectively.  If the corresponding component of <code>from</code> (resp. <code>to</code>) is <code>-Inf</code> (resp. <code>Inf</code>), <code class="reqn">a=-(t^j_{n(j)}-t^i_{0})</code> (resp. <code class="reqn">b=t^i_{n(i)}-t^j_{0}</code>) is used, while if the corresponding component of <code>division</code> is <code>FALSE</code>, <code class="reqn">N=round(2max(n(i),n(j)))+1</code> is used. Missing components are filled with <code>-Inf</code> (resp. <code>Inf</code>, <code>FALSE</code>). The default value <code>-Inf</code> (resp. <code>Inf</code>, <code>FALSE</code>) means that all components are <code>-Inf</code> (resp. <code>Inf</code>, <code>FALSE</code>). Next, if <code>grid</code> is a numeric vector, <code class="reqn">G_{ij}</code> is given by <code>grid</code>. If <code>grid</code> is a list of numeric vectors, <code class="reqn">G_{ij}</code> is given by the <code class="reqn">(d(i-1)-(i-1)i/2+(j-i))</code>-th component of <code>grid</code>.    
</p>
<p>The estimated lead-lag parameters are returned as the skew-symmetric matrix <code class="reqn">(\theta_{ij})_{i,j=1,\dots,d}</code>. If <code>verbose</code> is <code>TRUE</code>, the covariance matrix <code class="reqn">(U_{ij}(\theta_{ij}))_{i,j=1,\dots,d}</code> corresponding to the estimated lead-lag parameters, the corresponding correlation matrix and the computed contrast functions are also returned. If further <code>ccor</code> is <code>TRUE</code>,the computed cross-correlation functions are returned as a list with the length <code class="reqn">d(d-1)/2</code>. For <code class="reqn">i&lt;j</code>, the <code class="reqn">(d(i-1)-(i-1)i/2+(j-i))</code>-th component of the list consists of an object <code class="reqn">U_{ij}(\theta)/sqrt(U_{ii}(\theta)*U_{jj}(\theta))</code> of class <a href="zoo.html#topic+zoo">zoo</a> indexed by <code class="reqn">G_{ij}</code>.
</p>
<p>If <code>plot</code> is <code>TRUE</code>, the computed cross-correlation functions are plotted sequentially.
</p>
<p>If <code>ci</code> is <code>TRUE</code>, the asymptotic variances of the cross-correlations are calculated at each point of the grid by using the naive kernel approach descrived in Section 8.2 of Hayashi and Yoshida (2011). The implementation is the same as that of <code><a href="#topic+hyavar">hyavar</a></code> and more detailed description is found there.
</p>


<h3>Value</h3>

<p>If <code>verbose</code> is <code>FALSE</code>, a skew-symmetric matrix corresponding to the estimated lead-lag parameters is returned. 
Otherwise, an object of class <code>"yuima.llag"</code>, which is a list with the following components, is returned:
</p>
<table role = "presentation">
<tr><td><code>lagcce</code></td>
<td>
<p>a skew-symmetric matrix corresponding to the estimated lead-lag parameters.</p>
</td></tr>
<tr><td><code>covmat</code></td>
<td>
<p>a covariance matrix corresponding to the estimated lead-lag parameters.</p>
</td></tr>
<tr><td><code>cormat</code></td>
<td>
<p>a correlation matrix corresponding to the estimated lead-lag parameters.</p>
</td></tr>
<tr><td><code>LLR</code></td>
<td>
<p>a matrix consisting of lead-lag ratios. See Huth and Abergel (2014) for details.</p>
</td></tr>
</table>
<p>If <code>ci</code> is <code>TRUE</code>, the following component is added to the returned list:
</p>
<table role = "presentation">
<tr><td><code>p.values</code></td>
<td>
<p>a matrix of p-values for the significance of the correlations corresponding to the estimated lead-lag parameters.</p>
</td></tr>
</table>
<p>If further <code>ccor</code> is <code>TRUE</code>, the following components are added to the returned list:
</p>
<table role = "presentation">
<tr><td><code>ccor</code></td>
<td>
<p>a list of computed cross-correlation functions.</p>
</td></tr>
<tr><td><code>avar</code></td>
<td>
<p>a list of computed asymptotic variances of the cross-correlations (if <code>ci = TRUE</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The default <code>grid</code> usually contains too many points, so it is better for users to specify this argument in order to reduce the computational time. See 'Examples' below for an example of the specification.
</p>
<p>The evaluated p-values should carefully be interpreted because they are calculated based on <em>pointwise confidence intervals</em> rather than <em>simultaneous confidence intervals</em> (so there would be a multiple testing problem). Evaluation of p-values based on the latter will be implemented in the future extension of this function: Indeed, so far no theory has been developed for this. However, it is conjectured that the error distributions of the estimated cross-correlation functions are asymptotically independent if the grid is not dense too much, so p-values evaluated by this function will still be meaningful as long as sufficiently low significance levels are used.
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team</p>


<h3>References</h3>

<p>Hayashi, T. and Yoshida, N. (2011)
Nonsynchronous covariation process and limit theorems,
<em>Stochastic processes and their applications</em>, <b>121</b>, 2416&ndash;2454.
</p>
<p>Hoffmann, M., Rosenbaum, M. and Yoshida, N. (2013)
Estimation of the lead-lag parameter from non-synchronous data, 
<em>Bernoulli</em>, <b>19</b>, no. 2, 426&ndash;461.
</p>
<p>Huth, N. and Abergel, F. (2014)
High frequency lead/lag relationships &mdash; Empirical facts,
<em>Journal of Empirical Finance</em>, <b>26</b>, 41&ndash;58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cce">cce</a></code>, <code><a href="#topic+hyavar">hyavar</a></code>, <code><a href="#topic+mllag">mllag</a></code>, <code><a href="#topic+llag.test">llag.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Set a model
diff.coef.matrix &lt;- matrix(c("sqrt(x1)", "3/5*sqrt(x2)",
 "1/3*sqrt(x3)", "", "4/5*sqrt(x2)","2/3*sqrt(x3)",
 "","","2/3*sqrt(x3)"), 3, 3) 
drift &lt;- c("1-x1","2*(10-x2)","3*(4-x3)")
cor.mod &lt;- setModel(drift = drift, 
 diffusion = diff.coef.matrix,
 solve.variable = c("x1", "x2","x3")) 

set.seed(111) 

## We use a function poisson.random.sampling 
## to get observation by Poisson sampling.
yuima.samp &lt;- setSampling(Terminal = 1, n = 1200) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima,xinit=c(1,7,5)) 

## intentionally displace the second time series

  data2 &lt;- yuima@data@zoo.data[[2]]
  time2 &lt;- time(data2)
  theta2 &lt;- 0.05   # the lag of x2 behind x1
  stime2 &lt;- time2 + theta2  
  time(yuima@data@zoo.data[[2]]) &lt;- stime2

  data3 &lt;- yuima@data@zoo.data[[3]]
  time3 &lt;- time(data3)
  theta3 &lt;- 0.12   # the lag of x3 behind x1
  stime3 &lt;- time3 + theta3 
  time(yuima@data@zoo.data[[3]]) &lt;- stime3




## sampled data by Poisson rules
psample&lt;- poisson.random.sampling(yuima, 
 rate = c(0.2,0.3,0.4), n = 1000) 


## plot
plot(psample)


## cce
cce(psample)

## lead-lag estimation (with cross-correlation plots)
par(mfcol=c(3,1))
result &lt;- llag(psample, plot=TRUE)

## estimated lead-lag parameter
result

## computing pointwise confidence intervals
llag(psample, ci = TRUE)

## In practice, it is better to specify the grid because the default grid contains too many points.
## Here we give an example for how to specify it.

## We search lead-lag parameters on the interval [-0.1, 0.1] with step size 0.01 
G &lt;- seq(-0.1,0.1,by=0.01)

## lead-lag estimation (with computing confidence intervals)
result &lt;- llag(psample, grid = G, ci = TRUE)

## Since the true lead-lag parameter 0.12 between x1 and x3 is not contained
## in the searching grid G, we see that the corresponding cross-correlation 
## does not exceed the cofidence interval

## detailed output
## the p-value for the (1,3)-th component is high
result

## Finally, we can examine confidence intervals of other significant levels
## and/or without the Fisher z-transformation via the plot-method defined 
## for yuima.llag-class objects as follows
plot(result, alpha = 0.001)
plot(result, fisher = FALSE)

par(mfcol=c(1,1))

</code></pre>

<hr>
<h2 id='llag.test'>
Wild Bootstrap Test for the Absence of Lead-Lag Effects
</h2><span id='topic+llag.test'></span>

<h3>Description</h3>

<p>Tests the absence of lead-lag effects (time-lagged correlations) by the wild bootstrap procedure proposed in Koike (2017) for each pair of components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llag.test(x, from = -Inf, to = Inf, division = FALSE, grid, R = 999,
          parallel = "no", ncpus = getOption("boot.ncpus", 1L),
          cl = NULL, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llag.test_+3A_x">x</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_from">from</code></td>
<td>

<p>a numeric vector each of whose component(s) indicates the lower end of a finite grid on which the contrast function is evaluated, if <code>grid</code> is missing.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_to">to</code></td>
<td>

<p>a numeric vector each of whose component(s) indicates the upper end of a finite grid on which the contrast function is evaluated, if <code>grid</code> is missing.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_division">division</code></td>
<td>

<p>a numeric vector each of whose component(s) indicates the number of the points of a finite grid on which the contrast function is evaluated, if <code>grid</code> is missing.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_grid">grid</code></td>
<td>

<p>a numeric vector or a list of numeric vectors. See 'Details' of <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_r">R</code></td>
<td>

<p>a single positive integer indicating the number of bootstrap replicates.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_parallel">parallel</code></td>
<td>

<p>passed to <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_ncpus">ncpus</code></td>
<td>

<p>passed to <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_cl">cl</code></td>
<td>

<p>passed to <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="llag.test_+3A_tol">tol</code></td>
<td>

<p>tolelance parameter to avoid numerical errors in comparison of time stamps. All time stamps are divided by <code>tol</code> and rounded to integers. Note that the values of <code>grid</code> are also divided by <code>tol</code> and rounded to integers. A reasonable choice of <code>tol</code> is the minimum unit of time stamps. The default value <code>1e-6</code> supposes that the minimum unit of time stamps is greater or equal to 1 micro-second.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of components, this function performs the wild bootstrap procedure proposed in Koike (2017) to test whether there is a (possibly) time-lagged correlation. The null hypothesis of the test is that there is no time-lagged correlation and the alternative is its negative. The test regects the null hypothesis if the maximum of the absolute values of cross-covariances is too large. The critical region is constructed by a wild bootstrap procedure with Rademacher variables as the multiplier variables.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p.values</code></td>
<td>
<p>a matrix whose components indicate the bootstrap p-values for the corresponding pair of components.</p>
</td></tr>
<tr><td><code>max.cov</code></td>
<td>
<p>a matrix whose componenets indicate the maxima of the absolute values of cross-covariances for the corresponding pair of components.</p>
</td></tr>
<tr><td><code>max.corr</code></td>
<td>
<p>a matrix whose componenets indicate the maxima of the absolute values of cross-correlations for the corresponding pair of components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Koike, Y. (2019). 
Gaussian approximation of maxima of Wiener functionals and its application to high-frequency data, 
<em>Annals of Statistics</em>, <b>47</b>, 1663&ndash;1687. <a href="https://doi.org/10.1214/18-AOS1731">doi:10.1214/18-AOS1731</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cce">cce</a></code>, <code><a href="#topic+hyavar">hyavar</a></code>, <code><a href="#topic+mllag">mllag</a></code>, <code><a href="#topic+llag">llag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following example is taken from mllag

## Set a model
diff.coef.matrix &lt;- matrix(c("sqrt(x1)", "3/5*sqrt(x2)",
 "1/3*sqrt(x3)", "", "4/5*sqrt(x2)","2/3*sqrt(x3)",
 "","","2/3*sqrt(x3)"), 3, 3) 
drift &lt;- c("1-x1","2*(10-x2)","3*(4-x3)")
cor.mod &lt;- setModel(drift = drift, 
 diffusion = diff.coef.matrix,
 solve.variable = c("x1", "x2","x3")) 

set.seed(111) 

## We use a function poisson.random.sampling 
## to get observation by Poisson sampling.
yuima.samp &lt;- setSampling(Terminal = 1, n = 1200) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima,xinit=c(1,7,5)) 

## intentionally displace the second time series

  data2 &lt;- yuima@data@zoo.data[[2]]
  time2 &lt;- time(data2)
  theta2 &lt;- 0.05   # the lag of x2 behind x1
  stime2 &lt;- time2 + theta2  
  time(yuima@data@zoo.data[[2]]) &lt;- stime2

  data3 &lt;- yuima@data@zoo.data[[3]]
  time3 &lt;- time(data3)
  theta3 &lt;- 0.12   # the lag of x3 behind x1
  stime3 &lt;- time3 + theta3 
  time(yuima@data@zoo.data[[3]]) &lt;- stime3

## sampled data by Poisson rules
psample&lt;- poisson.random.sampling(yuima, 
 rate = c(0.2,0.3,0.4), n = 1000) 
 
 ## We search lead-lag parameters on the interval [-0.1, 0.1] with step size 0.01 
G &lt;- seq(-0.1,0.1,by=0.01)

## perform lead-lag test
llag.test(psample, grid = G, R = 999)

## Since the lead-lag parameter for the pair(x1, x3) is not contained in G,
## the null hypothesis is not rejected for this pair

## End(Not run)
</code></pre>

<hr>
<h2 id='lm.jumptest'>
Lee and Mykland's Test for the Presence of Jumps Using Normalized Returns
</h2><span id='topic+lm.jumptest'></span>

<h3>Description</h3>

<p>Performs a test for the null hypothesis that the realized path has no jump following Lee and Mykland (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.jumptest(yuima, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm.jumptest_+3A_yuima">yuima</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="lm.jumptest_+3A_k">K</code></td>
<td>

<p>a positive integer indicating the window size to compute local variance estimates. It can be specified as a vector to use different window sizes for different components. The default value is <code>K=pmin(floor(sqrt(252*n)), n)</code> with <code>n=length(yuima)-1</code>, following Lee and Mykland (2008) as well as Dumitru and Urga (2012).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same length as <code>dim(yuima)</code>. Each component of the list has class &ldquo;<code>htest</code>&rdquo; and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic of the corresponding component of <code>yuima</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>an approximate p-value for the test of the corresponding component.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;<code>Lee and Mykland jump test</code>&rdquo;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the character string &ldquo;<code>xi</code>&rdquo;, where <code>i</code> is the number of the component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Dumitru, A.-M. and Urga, G. (2012)
Identifying jumps in financial assets: A comparison between nonparametric jump tests.
<em>Journal of Business and Economic Statistics</em>, <b>30</b>, 242&ndash;255.
</p>
<p>Lee, S. S. and Mykland, P. A. (2008)
Jumps in financial markets: A new nonparametric test and jump dynamics.
<em>Review of Financial Studies</em>, <b>21</b>, 2535&ndash;2563.
</p>
<p>Maneesoonthorn, W., Martin, G. M. and Forbes, C. S. (2020)
High-frequency jump tests: Which test should we use?
<em>Journal of Econometrics</em>, <b>219</b>, 478&ndash;487.
</p>
<p>Theodosiou, M. and Zikes, F. (2011)
A comprehensive comparison of alternative tests for jumps in asset prices. 
Central Bank of Cyprus Working Paper 2011-2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bns.test">bns.test</a></code>, <code><a href="#topic+minrv.test">minrv.test</a></code>, <code><a href="#topic+medrv.test">medrv.test</a></code>, <code><a href="#topic+pz.test">pz.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# One-dimensional case
## Model: dXt=t*dWt+t*dzt, 
## where zt is a compound Poisson process with intensity 5 and jump sizes distribution N(0,1).

model &lt;- setModel(drift=0,diffusion="t",jump.coeff="t",measure.type="CP",
                  measure=list(intensity=5,df=list("dnorm(z,0,sqrt(0.1))")),
                  time.variable="t")

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima) # The path seems to involve some jumps

lm.jumptest(yuima) # p-value is very small, so the path would have a jump
lm.jumptest(yuima, K = floor(sqrt(390))) # different value of K

# Multi-dimensional case
## Model: Bivariate standard BM + CP
## Only the first component has jumps

mod &lt;- setModel(drift = c(0, 0), diffusion = diag(2),
                jump.coeff = diag(c(1, 0)),
                measure = list(intensity = 5, 
                               df = "dmvnorm(z,c(0,0),diag(2))"),
                jump.variable = c("z"), measure.type=c("CP"),
                solve.variable=c("x1","x2"))

samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp)
yuima &lt;- simulate(object = mod, sampling = samp)
plot(yuima)

lm.jumptest(yuima) # test is performed component-wise
</code></pre>

<hr>
<h2 id='LogSPX'>
Five minutes Log SPX prices
</h2><span id='topic+LogSPX'></span><span id='topic+Data'></span>

<h3>Description</h3>

<p>Intraday five minutes Standard and Poor 500 Log-prices data ranging from 09 july 2012 to 01 april 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LogSPX)</code></pre>


<h3>Details</h3>

<p>The dataset is composed by a list where the element <code>Data$allObs</code> contains the intraday five minutes Standard and Poor cumulative Log-return data computed as <code>Log(P_t)-Log(P_0)</code> and <code>P_0</code> is the open SPX price at 09 july 2012. <code>Data$logdayprice</code> contains daily SPX log prices and. Each day we have the same number of observation and the value is reported in <code>Data$obsinday</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LogSPX)
</code></pre>

<hr>
<h2 id='lseBayes'>Adaptive Bayes estimator for the parameters in sde model by using LSE functions</h2><span id='topic+lseBayes'></span><span id='topic+lseBayes+2Cyuima-method'></span>

<h3>Description</h3>

<p>Adaptive Bayes estimator for the parameters in a specific type of sde by using LSE functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lseBayes(yuima, start, prior, lower, upper, method = "mcmc", mcmc = 1000,
rate =1, algorithm = "randomwalk")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lseBayes_+3A_yuima">yuima</code></td>
<td>
<p>a 'yuima' object.</p>
</td></tr>
<tr><td><code id="lseBayes_+3A_start">start</code></td>
<td>
<p>initial suggestion for parameter values </p>
</td></tr>
<tr><td><code id="lseBayes_+3A_prior">prior</code></td>
<td>
<p>a list of prior distributions for the parameters specified by 'code'. Currently, dunif(z, min, max), dnorm(z, mean, sd), dbeta(z, shape1, shape2), dgamma(z, shape, rate) are available. </p>
</td></tr>
<tr><td><code id="lseBayes_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters</p>
</td></tr>
<tr><td><code id="lseBayes_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters</p>
</td></tr>
<tr><td><code id="lseBayes_+3A_method">method</code></td>
<td>
<p><code>nomcmc</code> requires package <code>cubature</code> </p>
</td></tr>
<tr><td><code id="lseBayes_+3A_mcmc">mcmc</code></td>
<td>
<p>number of iteration of Markov chain Monte Carlo method</p>
</td></tr>
<tr><td><code id="lseBayes_+3A_rate">rate</code></td>
<td>
<p>a thinning parameter. Only the first n^rate observation will be used for inference. </p>
</td></tr>
<tr><td><code id="lseBayes_+3A_algorithm">algorithm</code></td>
<td>
<p>Logical value when <code>method = mcmc</code>. If <code>algorithm = "randomwalk"</code> (default), the random-walk Metropolis algorithm will be performed. If <code>algorithm = "MpCN"</code>, the Mixed preconditioned Crank-Nicolson algorithm will be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lseBayes</code> is always performed by Rcpp code.Calculate the Bayes estimator for stochastic processes by using Least Square Estimate functions. The calculation is performed by the Markov chain Monte Carlo method. Currently, the Random-walk Metropolis algorithm  and the Mixed preconditioned Crank-Nicolson algorithm is implemented.In <code>lseBayes</code>,the LSE function for estimating diffusion parameter differs from the LSE function for estimating drift parameter.<code>lseBayes</code> is similar to <code>adaBayes</code>,but <code>lseBayes</code> calculate faster than <code>adaBayes</code> because of LSE functions.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>vector</code></td>
<td>
<p>a vector of the parameter estimate</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>algorithm = "nomcmc"</code> is unstable. <code>nomcmc</code> is going to be stopped. 
</p>


<h3>Author(s)</h3>

<p>Yuto Yoshida with YUIMA project Team</p>


<h3>References</h3>

<p>Yoshida, N. (2011). Polynomial type large deviation inequalities and quasi-likelihood analysis for stochastic differential equations. Annals of the Institute of Statistical Mathematics, 63(3), 431-479.
</p>
<p>Uchida, M., &amp; Yoshida, N. (2014). Adaptive Bayes type estimators of ergodic diffusion processes from discrete observations. Statistical Inference for Stochastic Processes, 17(2), 181-219.
</p>
<p>Kamatani, K. (2017). Ergodicity of Markov chain Monte Carlo with reversible proposal. Journal of Applied Probability, 54(2). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
####2-dim model
set.seed(123)

b &lt;- c("-theta1*x1+theta2*sin(x2)+50","-theta3*x2+theta4*cos(x1)+25")
a &lt;- matrix(c("4+theta5*sin(x1)^2","1","1","2+theta6*sin(x2)^2"),2,2)

true = list(theta1 = 0.5, theta2 = 5,theta3 = 0.3, 
            theta4 = 5, theta5 = 1, theta6 = 1)
lower = list(theta1=0.1,theta2=0.1,theta3=0,
             theta4=0.1,theta5=0.1,theta6=0.1)
upper = list(theta1=1,theta2=10,theta3=0.9,
             theta4=10,theta5=10,theta6=10)
start = list(theta1=runif(1), 
             theta2=rnorm(1),
             theta3=rbeta(1,1,1), 
             theta4=rnorm(1),
             theta5=rgamma(1,1,1), 
             theta6=rexp(1))

yuimamodel &lt;- setModel(drift=b,diffusion=a,state.variable=c("x1", "x2"),solve.variable=c("x1","x2"))
yuimasamp &lt;- setSampling(Terminal=50,n=50*100)
yuima &lt;- setYuima(model = yuimamodel, sampling = yuimasamp)
yuima &lt;- simulate(yuima, xinit = c(100,80),
                  true.parameter = true,sampling = yuimasamp)

prior &lt;-
    list(
        theta1=list(measure.type="code",df="dunif(z,0,1)"),
        theta2=list(measure.type="code",df="dnorm(z,0,1)"),
        theta3=list(measure.type="code",df="dbeta(z,1,1)"),
        theta4=list(measure.type="code",df="dgamma(z,1,1)"),
        theta5=list(measure.type="code",df="dnorm(z,0,1)"),
        theta6=list(measure.type="code",df="dnorm(z,0,1)")
    )


mle &lt;- qmle(yuima, start = start, lower = lower, upper = upper, method = "L-BFGS-B",rcpp=TRUE) 
print(mle@coef)
set.seed(123)
bayes1 &lt;- lseBayes(yuima, start=start, prior=prior,
                                    method="mcmc",
                                    mcmc=1000,lower = lower, upper = upper,algorithm = "randomwalk")
bayes1@coef
set.seed(123)
bayes2 &lt;- lseBayes(yuima, start=start, prior=prior,
                                    method="mcmc",
                                    mcmc=1000,lower = lower, upper = upper,algorithm = "MpCN")
bayes2@coef


## End(Not run)
</code></pre>

<hr>
<h2 id='mllag'>
Multiple Lead-Lag Detector
</h2><span id='topic+mllag'></span>

<h3>Description</h3>

<p>Detecting the lead-lag parameters of discretely observed processes by picking time shifts at which the Hayashi-Yoshida cross-correlation functions exceed thresholds, which are constructed based on the asymptotic theory of Hayashi and Yoshida (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllag(x, from = -Inf, to = Inf, division = FALSE, grid, psd = TRUE, 
      plot = TRUE, alpha = 0.01, fisher = TRUE, bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mllag_+3A_x">x</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> or <code>yuima.llag-class</code> (output of <code><a href="#topic+llag">llag</a></code>) or <code>yuima.mllag-class</code> (output of this function).
</p>
</td></tr>
<tr><td><code id="mllag_+3A_from">from</code></td>
<td>

<p>passed to <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_to">to</code></td>
<td>

<p>passed to <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_division">division</code></td>
<td>

<p>passed to <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_grid">grid</code></td>
<td>

<p>passed to <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_psd">psd</code></td>
<td>

<p>passed to <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_plot">plot</code></td>
<td>

<p>logical. If <code>TRUE</code>, the estimated cross-correlation functions and the pointwise confidence intervals (under the null hypothesis that the corresponding correlation is zero) as well as the detected lead-lag parameters are plotted. 
</p>
</td></tr>
<tr><td><code id="mllag_+3A_alpha">alpha</code></td>
<td>

<p>a posive number indicating the significance level of the confidence intervals for the cross-correlation functions.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_fisher">fisher</code></td>
<td>

<p>logical. If <code>TRUE</code>, the p-values and the confidence intervals for the cross-correlation functions is evaluated after applying the Fisher z transformation.
</p>
</td></tr>
<tr><td><code id="mllag_+3A_bw">bw</code></td>
<td>

<p>passed to <code><a href="#topic+llag">llag</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation method of cross-correlation functions and confidence intervals is the same as the one used in <code><a href="#topic+llag">llag</a></code>. The exception between this function and <code><a href="#topic+llag">llag</a></code> is how to detect the lead-lag parameters. While <code><a href="#topic+llag">llag</a></code> only returns the maximizer of the absolute value of the cross-correlations following the theory of Hoffmann et al. (2013),  this function returns all the time shifts at which the cross-correlations exceed (so there is also the possiblity that <em>no</em> lead-lag is returned). Note that this approach is mathematically debetable because there would be a multiple testing problem (see also 'Note' of <code><a href="#topic+llag">llag</a></code>), so the interpretation of the result from this function should carefully be addressed. In particular, the significance level <code>alpha</code> probably does not give the &quot;correct&quot; level.
</p>


<h3>Value</h3>

<p>An object of class <code>"yuima.mllag"</code>, which is a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>mlagcce</code></td>
<td>
<p>a list of <code>data.frame</code>-class objects consisting of <code>lagcce</code> (lead-lag parameters), <code>p.value</code> and <code>correlation</code>.</p>
</td></tr>
<tr><td><code>LLR</code></td>
<td>
<p>a matrix consisting of lead-lag ratios. See Huth and Abergel (2014) for details.</p>
</td></tr>
<tr><td><code>ccor</code></td>
<td>
<p>a list of computed cross-correlation functions.</p>
</td></tr>
<tr><td><code>avar</code></td>
<td>
<p>a list of computed asymptotic variances of the cross-correlations (if <code>ci = TRUE</code>).</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>a list of computed confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Hayashi, T. and Yoshida, N. (2011)
Nonsynchronous covariation process and limit theorems,
<em>Stochastic processes and their applications</em>, <b>121</b>, 2416&ndash;2454.
</p>
<p>Hoffmann, M., Rosenbaum, M. and Yoshida, N. (2013)
Estimation of the lead-lag parameter from non-synchronous data, 
<em>Bernoulli</em>, <b>19</b>, no. 2, 426&ndash;461.
</p>
<p>Huth, N. and Abergel, F. (2014)
High frequency lead/lag relationships &mdash; Empirical facts,
<em>Journal of Empirical Finance</em>, <b>26</b>, 41&ndash;58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+llag">llag</a></code>, <code><a href="#topic+hyavar">hyavar</a></code>, <code><a href="#topic+llag.test">llag.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The first example is taken from llag

## Set a model
diff.coef.matrix &lt;- matrix(c("sqrt(x1)", "3/5*sqrt(x2)",
 "1/3*sqrt(x3)", "", "4/5*sqrt(x2)","2/3*sqrt(x3)",
 "","","2/3*sqrt(x3)"), 3, 3) 
drift &lt;- c("1-x1","2*(10-x2)","3*(4-x3)")
cor.mod &lt;- setModel(drift = drift, 
 diffusion = diff.coef.matrix,
 solve.variable = c("x1", "x2","x3")) 

set.seed(111) 

## We use a function poisson.random.sampling 
## to get observation by Poisson sampling.
yuima.samp &lt;- setSampling(Terminal = 1, n = 1200) 
yuima &lt;- setYuima(model = cor.mod, sampling = yuima.samp) 
yuima &lt;- simulate(yuima,xinit=c(1,7,5)) 

## intentionally displace the second time series

  data2 &lt;- yuima@data@zoo.data[[2]]
  time2 &lt;- time(data2)
  theta2 &lt;- 0.05   # the lag of x2 behind x1
  stime2 &lt;- time2 + theta2  
  time(yuima@data@zoo.data[[2]]) &lt;- stime2

  data3 &lt;- yuima@data@zoo.data[[3]]
  time3 &lt;- time(data3)
  theta3 &lt;- 0.12   # the lag of x3 behind x1
  stime3 &lt;- time3 + theta3 
  time(yuima@data@zoo.data[[3]]) &lt;- stime3

## sampled data by Poisson rules
psample&lt;- poisson.random.sampling(yuima, 
 rate = c(0.2,0.3,0.4), n = 1000) 
 
 ## We search lead-lag parameters on the interval [-0.1, 0.1] with step size 0.01 
G &lt;- seq(-0.1,0.1,by=0.01)

## lead-lag estimation by mllag
par(mfcol=c(3,1))
result &lt;- mllag(psample, grid = G)

## Since the lead-lag parameter for the pair(x1, x3) is not contained in G,
## no lead-lag parameter is detected for this pair

par(mfcol=c(1,1))

# The second example is a situation where multiple lead-lag effects exist
set.seed(222)

n &lt;- 3600
Times &lt;- seq(0, 1, by = 1/n)
R1 &lt;- 0.6
R2 &lt;- -0.3

dW1 &lt;- rnorm(n + 10)/sqrt(n)
dW2 &lt;- rnorm(n + 5)/sqrt(n)
dW3 &lt;- rnorm(n)/sqrt(n)

x &lt;- zoo(diffinv(dW1[-(1:10)] + dW2[1:n]), Times)
y &lt;- zoo(diffinv(R1 * dW1[1:n] + R2 * dW2[-(1:5)] + 
                 sqrt(1- R1^2 - R2^2) * dW3), Times)

## In this setting, both x and y have a component leading to the other, 
## but x's leading component dominates y's one

yuima &lt;- setData(list(x, y))

## Lead-lag estimation by llag
G &lt;- seq(-30/n, 30/n, by = 1/n)
est &lt;- llag(yuima, grid = G, ci = TRUE)

## The shape of the plotted cross-correlation is evidently bimodal,
## so there are likely two lead-lag parameters

## Lead-lag estimation by mllag
mllag(est) # succeeds in detecting two lead-lag parameters

## Next consider a non-synchronous sampling case
psample &lt;- poisson.random.sampling(yuima, n = n, rate = c(0.8, 0.7))

## Lead-lag estimation by mllag
est &lt;- mllag(psample, grid = G) 
est # detects too many lead-lag parameters

## Using a lower significant level
mllag(est, alpha = 0.001) # insufficient

## As the plot reveals, one reason is because the grid is too dense
## In fact, this phenomenon can be avoided by using a coarser grid
mllag(psample, grid = seq(-30/n, 30/n, by=5/n)) # succeeds!

</code></pre>

<hr>
<h2 id='mmfrac'>
mmfrac
</h2><span id='topic+mmfrac'></span>

<h3>Description</h3>

<p>Estimates the drift of a fractional Ornstein-Uhlenbeck and, if necessary, also the Hurst and diffusion parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmfrac(yuima, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmfrac_+3A_yuima">yuima</code></td>
<td>
<p>a <code>yuima</code> object.
</p>
</td></tr>
<tr><td><code id="mmfrac_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+qgv">qgv</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the drift of s fractional Ornstein-Uhlenbeck and, if necessary, also the Hurst and diffusion parameters.
</p>


<h3>Value</h3>

<p>an object of class mmfrac
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Brouste, A., Iacus, S.M. (2013) Parameter estimation for the discretely observed fractional Ornstein-Uhlenbeck process and the Yuima R package, Computational Statistics, pp. 1129&ndash;1147.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+qgv">qgv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimating all Hurst parameter, diffusion coefficient  and drift coefficient 
# in fractional Ornstein-Uhlenbeck

model&lt;-setModel(drift="-x*lambda",hurst=NA,diffusion="theta")
sampling&lt;-setSampling(T=100,n=10000)
yui1&lt;-simulate(model,true.param=list(theta=1,lambda=4),hurst=0.7,sampling=sampling)
mmfrac(yui1)

</code></pre>

<hr>
<h2 id='model.parameter-class'>Class for the parameter description of stochastic differential equations</h2><span id='topic+model.parameter-class'></span>

<h3>Description</h3>

<p>The <code>model.parameter-class</code> is a class of the  <span class="pkg">yuima</span> package.  
</p>


<h3>Details</h3>

<p>The <code>model.parameter-class</code> object cannot be directly specified by the user
but it is constructed when the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> object is
constructed via <code><a href="#topic+setModel">setModel</a></code>.
All the terms which are not in the list of <em>solution, state, time, jump</em> variables
are considered as parameters. These parameters are
identified in the different components of the model (drift, diffusion and
jump part).
This information is later used to draw inference jointly or separately for
the different parameters depending on the model in hands. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>drift</code>:</dt><dd><p>A vector of names belonging to 
the drift coefficient.</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>A vector of names of parameters belonging to 
the diffusion coefficient.</p>
</dd>
<dt><code>jump</code>:</dt><dd><p>A vector of names of parameters belonging to 
the jump coefficient.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>A vector of names of parameters belonging to 
the Levy measure.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>A vector of names of parameters belonging to
the initial condition.</p>
</dd>
<dt><code>all</code>:</dt><dd><p>A vector of names of all the parameters found in the
components of the model.</p>
</dd>
<dt><code>common</code>:</dt><dd><p>A vector of names of the parameters in common among
drift, diffusion, jump and measure term.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='mpv'>
Realized Multipower Variation
</h2><span id='topic+mpv'></span><span id='topic+mpv+2Cyuima-method'></span><span id='topic+mpv+2Cyuima.data-method'></span>

<h3>Description</h3>

<p>The function returns the realized MultiPower Variation (mpv), defined in Barndorff-Nielsen and Shephard (2004), for each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpv(yuima, r = 2, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpv_+3A_yuima">yuima</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="mpv_+3A_r">r</code></td>
<td>

<p>a vector of non-negative numbers or a list of vectors of non-negative numbers. 
</p>
</td></tr>
<tr><td><code id="mpv_+3A_normalize">normalize</code></td>
<td>
<p>logical. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>d</code> be the number of the components of the <code>zoo.data</code> of <code>yuima</code>.
</p>
<p>Let <code class="reqn">X^i_{t_0},X^i_{t_1},\dots,X^i_{t_n}</code> be the observation data of the <code class="reqn">i</code>-th component (i.e. the <code class="reqn">i</code>-th component of the <code>zoo.data</code> of <code>yuima</code>).
</p>
<p>When <code class="reqn">r</code> is a <code class="reqn">k</code>-dimensional vector of non-negative numbers, <code>mpv(yuima,r,normalize=TRUE)</code> is defined as the <code>d</code>-dimensional vector with <code>i</code>-th element equal to
</p>
<p style="text-align: center;"><code class="reqn">\mu_{r[1]}^{-1}\cdots\mu_{r[k]}^{-1}n^{\frac{r[1]+\cdots+r[k]}{2}-1}\sum_{j=1}^{n-k+1}|\Delta X^i_{t_{j}}|^{r[1]}|\Delta X^i_{t_{j+1}}|^{r[2]}\cdots|\Delta X^i_{t_{j+k-1}}|^{r[k]},</code>
</p>

<p>where <code class="reqn">\mu_p</code> is the p-th absolute moment of the standard normal distribution and <code class="reqn">\Delta X^i_{t_{j}}=X^i_{t_j}-X^i_{t_{j-1}}</code>. If <code>normalize</code> is <code>FALSE</code> the result is not multiplied by <code class="reqn">\mu_{r[1]}^{-1}\cdots\mu_{r[k]}^{-1}</code>.
</p>
<p>When <code class="reqn">r</code> is a list of vectors of non-negative numbers, <code>mpv(yuima,r,normalize=TRUE)</code> is defined as the <code>d</code>-dimensional vector with <code>i</code>-th element equal to
</p>
<p style="text-align: center;"><code class="reqn">\mu_{r^i_1}^{-1}\cdots\mu_{r^i_{k_i}}^{-1}n^{\frac{r^i_1+\cdots+r^i_{k_i}}{2}-1}\sum_{j=1}^{n-k_i+1}|\Delta X^i_{t_{j}}|^{r^i_1}|\Delta X^i_{t_{j+1}}|^{r^i_2}\cdots|\Delta X^i_{t_{j+k_i-1}}|^{r^i_{k_i}},</code>
</p>

<p>where <code class="reqn">r^i_1,\dots,r^i_{k_i}</code> is the <code>i</code>-th component of <code>r</code>. If <code>normalize</code> is <code>FALSE</code> the result is not multiplied by <code class="reqn">\mu_{r^i_1}^{-1}\cdots\mu_{r^i_{k_i}}^{-1}</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with the same length as the <code>zoo.data</code> of <code>yuima</code>
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. E. and Shephard, N. (2004)
Power and bipower variation with stochastic volatility and jumps,
<em>Journal of Financial Econometrics</em>, <b>2</b>, no. 1, 1&ndash;37.
</p>
<p>Barndorff-Nielsen, O. E. , Graversen, S. E. , Jacod, J. , Podolskij M. and Shephard, N. (2006)
A central limit theorem for realised power and bipower variations of continuous semimartingales,
in: Kabanov, Y. , Lipster, R. , Stoyanov J. (Eds.), From Stochastic Calculus to Mathematical Finance: The Shiryaev Festschrift, Springer-Verlag, Berlin, pp. 33&ndash;68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setData">setData</a></code>, <code><a href="#topic+cce">cce</a></code>, <code><a href="#topic+minrv">minrv</a></code>, <code><a href="#topic+medrv">medrv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)

# One-dimensional case
## Model: dXt=t*dWt+t*dzt, 
## where zt is a compound Poisson process with intensity 5 and jump sizes distribution N(0,0.1). 

model &lt;- setModel(drift=0,diffusion="t",jump.coeff="t",measure.type="CP",
                  measure=list(intensity=5,df=list("dnorm(z,0,sqrt(0.1))")),
                  time.variable="t")

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima)

mpv(yuima) # true value is 1/3
mpv(yuima,1) # true value is 1/2
mpv(yuima,rep(2/3,3)) # true value is 1/3

# Multi-dimensional case
## Model: dXkt=t*dWk_t (k=1,2,3).

diff.matrix &lt;- diag(3)
diag(diff.matrix) &lt;- c("t","t","t")
model &lt;- setModel(drift=c(0,0,0),diffusion=diff.matrix,time.variable="t",
                  solve.variable=c("x1","x2","x3"))

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima)

mpv(yuima,list(c(1,1),1,rep(2/3,3))) # true varue is c(1/3,1/2,1/3)


## End(Not run)
</code></pre>

<hr>
<h2 id='MWK151'>
Graybill - Methuselah Walk - PILO - ITRDB CA535
</h2><span id='topic+MWK151'></span>

<h3>Description</h3>

<p>Graybill - Methuselah Walk - PILO - ITRDB CA535, pine tree width in mm from -608 to 1957.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MWK151)</code></pre>


<h3>Details</h3>

<p>The full data records of past temperature, precipitation, and climate and environmental change derived from tree ring measurements. Parameter keywords describe what was measured in this data set. Additional summary information can be found in the abstracts of papers listed in the data set citations, however many of the data sets arise from unpublished research contributed to the International Tree Ring Data Bank. Additional information on data processing and analysis for International Tree Ring Data Bank (ITRDB) data sets can be found on the Tree Ring Page <a href="https://www.ncei.noaa.gov/products/paleoclimatology">https://www.ncei.noaa.gov/products/paleoclimatology</a>.
</p>
<p>The MWK151 is only a small part of the data relative to one tree and contains measurement of a tree's ring width in mm, from -608 to 1957.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.25921/ppqj-xv48">doi:10.25921/ppqj-xv48</a>
</p>


<h3>References</h3>

<p>Graybill, D.A., and Shiyatov, S.G., Dendroclimatic evidence from the northern Soviet Union, in Climate since A.D. 1500, edited by R.S. Bradley and P.D. Jones, Routledge, London, 393-414, 1992.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MWK151)
</code></pre>

<hr>
<h2 id='noisy.sampling'>
Noisy Observation Generator
</h2><span id='topic+noisy.sampling'></span><span id='topic+noisy.sampling+2Cyuima-method'></span><span id='topic+noisy.sampling+2Cyuima.data-method'></span>

<h3>Description</h3>

<p>Generates a new observation data contaminated by noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisy.sampling(x, var.adj = 0, rng = "rnorm", mean.adj = 0, ..., 
               end.coef = 0, n, order.adj = 0, znoise)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noisy.sampling_+3A_x">x</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_var.adj">var.adj</code></td>
<td>

<p>a matrix or list to be used for adjusting the variance matrix of the exogenous noise.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_rng">rng</code></td>
<td>

<p>a function to be used for generating the random numbers for the exogenous noise.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_mean.adj">mean.adj</code></td>
<td>

<p>a numeric vector to be used for adjusting the mean vector of the exogenous noise.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_...">...</code></td>
<td>

<p>passed to <code>rng</code>.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_end.coef">end.coef</code></td>
<td>

<p>a numeric vector or list to be used for adjusting the variance of the endogenous noise.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_n">n</code></td>
<td>

<p>a numeric vector to be used for adjusting the scale of the endogenous noise.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_order.adj">order.adj</code></td>
<td>

<p>a positive number to be used for adjusting the order of the noise.
</p>
</td></tr>
<tr><td><code id="noisy.sampling_+3A_znoise">znoise</code></td>
<td>

<p>a list indicating other sources of noise processes. The default value is <code>as.list(double(dim(x)))</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates microstructure noise and adds it to the path of <code>x</code>. Currently, this function can deal with Kalnina and Linton (2011) type microstructure noise. See 'Examples' below for more details.
</p>


<h3>Value</h3>

<p>an object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>


<h3>References</h3>

<p>Kalnina, I. and Linton, O. (2011)
Estimating quadratic variation consistently in the presence of endogenous and diurnal measurement error,
<em>Journal of Econometrics</em>, <b>147</b>, 47&ndash;59.
</p>


<h3>See Also</h3>

<p><a href="#topic+cce">cce</a>, <a href="#topic+lmm">lmm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set a model (a two-dimensional normal model sampled by a Poisson random sampling)
set.seed(123)

drift &lt;- c(0,0)
  
sigma1 &lt;- 1
sigma2 &lt;- 1
rho &lt;- 0.7

diffusion &lt;- matrix(c(sigma1,sigma2*rho,0,sigma2*sqrt(1-rho^2)),2,2)

model &lt;- setModel(drift=drift,diffusion=diffusion,
                  state.variable=c("x1","x2"),solve.variable=c("x1","x2"))

yuima.samp &lt;- setSampling(Terminal = 1, n = 2340) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)

## Poisson random sampling
psample&lt;- poisson.random.sampling(yuima, rate = c(1/3,1/6), n = 2340)

## Plot the path without noise
plot(psample)

# Set a matrix as the variance of noise
Omega &lt;- 0.01*diffusion %*% t(diffusion)

## Contaminate the observation data by centered normal distributed noise
## with the variance matrix equal to 1% of the diffusion
noisy.psample1 &lt;- noisy.sampling(psample,var.adj=Omega)
plot(noisy.psample1)

## Contaminate the observation data by centered uniformly distributed noise
## with the variance matrix equal to 1% of the diffusion
noisy.psample2 &lt;- noisy.sampling(psample,var.adj=Omega,rng="runif",min=-sqrt(3),max=sqrt(3))
plot(noisy.psample2)

## Contaminate the observation data by centered exponentially distributed noise
## with the variance matrix equal to 1% of the diffusion
noisy.psample3 &lt;- noisy.sampling(psample,var.adj=Omega,rng="rexp",rate=1,mean.adj=1)
plot(noisy.psample3)

## Contaminate the observation data by its return series
## multiplied by -0.1 times the square root of the intensity vector
## of the Poisson random sampling   
noisy.psample4 &lt;- noisy.sampling(psample,end.coef=-0.1,n=2340*c(1/3,1/6))
plot(noisy.psample4)

## An application: 
## Adding a compound Poisson jumps to the observation data

## Set a compound Poisson process
intensity &lt;- 5
j.num &lt;- rpois(1,intensity) # Set a number of jumps
j.idx &lt;- unique(ceiling(2340*runif(j.num))) # Set time indices of jumps
jump &lt;- matrix(0,2,2341)
jump[,j.idx+1] &lt;- sqrt(0.25/intensity)*diffusion %*% matrix(rnorm(length(j.idx)),2,length(j.idx))
grid &lt;- seq(0,1,by=1/2340)
CPprocess &lt;- list(zoo(cumsum(jump[1,]),grid),zoo(cumsum(jump[2,]),grid))

## Adding the jumps
yuima.jump &lt;- noisy.sampling(yuima,znoise=CPprocess)
plot(yuima.jump)

## Poisson random sampling
psample.jump &lt;- poisson.random.sampling(yuima.jump, rate = c(1/3,1/6), n = 2340)
plot(psample.jump)
</code></pre>

<hr>
<h2 id='ntv'>
Volatility Estimation and Jump Test Using Nearest Neighbor Truncation
</h2><span id='topic+ntv'></span><span id='topic+minrv'></span><span id='topic+medrv'></span><span id='topic+minrv.test'></span><span id='topic+medrv.test'></span>

<h3>Description</h3>

<p><code>minrv</code> and <code>medrv</code> respectively compute the MinRV and MedRV estimators introduced in Andersen, Dobrev and Schaumburg (2012).
</p>
<p><code>minrv.test</code> and <code>medrv.test</code> respectively perform Haussman type tests for the null hypothesis that the realized path has no jump using the MinRV and MedRV estimators. 
See Section 4.4 in Andersen, Dobrev and Schaumburg (2014) for a concise discussion. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minrv(yuima)
medrv(yuima)

minrv.test(yuima, type = "ratio", adj = TRUE)
medrv.test(yuima, type = "ratio", adj = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ntv_+3A_yuima">yuima</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="ntv_+3A_type">type</code></td>
<td>

<p>type of the test statistic to use. <code>ratio</code> is default.
</p>
</td></tr>
<tr><td><code id="ntv_+3A_adj">adj</code></td>
<td>

<p>logical; if <code>TRUE</code>, the maximum adjustment suggested in Barndorff-Nielsen and Shephard (2004) is applied to the test statistic when <code>type</code> is equal to either &ldquo;<code>log</code>&rdquo; or &ldquo;<code>ratio</code>&rdquo;. See also Section 2.5 in Dumitru and Urga (2012).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>minrv</code> and <code>medrv</code> return a numeric vector with the same length as <code>dim(yuima)</code>. Each component of the vector is a volatility estimate for the corresponding component of <code>yuima</code>.
</p>
<p><code>minrv.test</code> and <code>medrv.test</code> return a list with the same length as <code>dim(yuima)</code>. Each component of the list has class &ldquo;<code>htest</code>&rdquo; and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic of the corresponding component of <code>yuima</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>an approximate p-value for the test of the corresponding component.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;<code>Andersen-Dobrev-Schaumburg jump test based on xxx</code>&rdquo;, where xxx is either MinRV or MedRV.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the character string &ldquo;<code>xi</code>&rdquo;, where <code>i</code> is the number of the component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Andersen, T. G., Dobrev D. and Schaumburg, E. (2012)
Jump-robust volatility estimation using nearest neighbor truncation.
<em>Journal of Econometrics</em>, <b>169</b>, 75&ndash;93.
</p>
<p>Andersen, T. G., Dobrev D. and Schaumburg, E. (2014)
A robust neighborhood truncation approach to estimation of integrated quarticity.
<em>Econometric Theory</em>, <b>30</b>, 3&ndash;59.
</p>
<p>Dumitru, A.-M. and Urga, G. (2012)
Identifying jumps in financial assets: A comparison between nonparametric jump tests.
<em>Journal of Business and Economic Statistics</em>, <b>30</b>, 242&ndash;255.
</p>
<p>Maneesoonthorn, W., Martin, G. M. and Forbes, C. S. (2020)
High-frequency jump tests: Which test should we use?
<em>Journal of Econometrics</em>, <b>219</b>, 478&ndash;487.
</p>
<p>Theodosiou, M. and Zikes, F. (2011)
A comprehensive comparison of alternative tests for jumps in asset prices. 
Central Bank of Cyprus Working Paper 2011-2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpv">mpv</a></code>, <code><a href="#topic+cce">cce</a></code>, <code><a href="#topic+bns.test">bns.test</a></code>, <code><a href="#topic+lm.jumptest">lm.jumptest</a></code>, <code><a href="#topic+pz.test">pz.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)

# One-dimensional case
## Model: dXt=t*dWt+t*dzt, 
## where zt is a compound Poisson process with intensity 5
## and jump sizes distribution N(0,1).

model &lt;- setModel(drift=0,diffusion="t",jump.coeff="t",measure.type="CP",
                  measure=list(intensity=5,df=list("dnorm(z,0,1)")),
                  time.variable="t")

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima) # The path evidently has some jumps

## Volatility estimation
minrv(yuima) # minRV (true value = 1/3)
medrv(yuima) # medRV (true value = 1/3)

## Jump test
minrv.test(yuima, type = "standard")
minrv.test(yuima,type="log")
minrv.test(yuima,type="ratio")

medrv.test(yuima, type = "standard")
medrv.test(yuima,type="log")
medrv.test(yuima,type="ratio")


# Multi-dimensional case
## Model: Bivariate standard BM + CP
## Only the first component has jumps

mod &lt;- setModel(drift = c(0, 0), diffusion = diag(2),
                jump.coeff = diag(c(1, 0)),
                measure = list(intensity = 5, 
                               df = "dmvnorm(z,c(0,0),diag(2))"),
                jump.variable = c("z"), measure.type=c("CP"),
                solve.variable=c("x1","x2"))

samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp)
yuima &lt;- simulate(object = mod, sampling = samp)
plot(yuima)

## Volatility estimation
minrv(yuima) # minRV (true value = c(1, 1))
medrv(yuima) # medRV (true value = c(1, 1))

## Jump test
minrv.test(yuima) # test is performed component-wise
medrv.test(yuima) # test is performed component-wise

## End(Not run)
</code></pre>

<hr>
<h2 id='param.Integral'>Class for the mathematical description of integral of a stochastic process</h2><span id='topic+param.Integral'></span><span id='topic+param.Integral-class'></span><span id='topic+initialize+2Cparam.Integral-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.Integral">yuima.Integral</a></code>. see the documentation of <code><a href="#topic+yuima.Integral">yuima.Integral</a></code> for more details.
</p>

<hr>
<h2 id='param.Map-class'>Class for information about Map/Operators</h2><span id='topic+param.Map'></span><span id='topic+param.Map-class'></span><span id='topic+initialize+2Cparam.Map-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.Map">yuima.Map</a></code>. see the documentation of <code><a href="#topic+yuima.Map">yuima.Map</a></code> for more details.
</p>

<hr>
<h2 id='phi.test'>Phi-divergence test statistic for stochastic differential equations</h2><span id='topic+phi.test'></span>

<h3>Description</h3>

<p>Phi-divergence test statistic for stochastic differential equations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi.test(yuima, H0, H1, phi, print=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phi.test_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="phi.test_+3A_h0">H0</code></td>
<td>
<p>a named list of parameter under H0.</p>
</td></tr>
<tr><td><code id="phi.test_+3A_h1">H1</code></td>
<td>
<p>a named list of parameter under H1.</p>
</td></tr>
<tr><td><code id="phi.test_+3A_phi">phi</code></td>
<td>
<p>the phi function to be used in the test. See Details.</p>
</td></tr>
<tr><td><code id="phi.test_+3A_print">print</code></td>
<td>
<p>you can see a progress of the estimation when print is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="phi.test_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+qmle">qmle</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phi.test</code> executes a Phi-divergence test. If <code>H1</code> is not specified
this hypothesis is filled with the QMLE estimates.
</p>
<p>If <code>phi</code> is missing, then <code>phi(x)=1-x+x*log(x)</code> and the
Phi-divergence statistic corresponds to the likelihood ratio test statistic.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ans</code></td>
<td>
<p>an obkect of class <code>phitest</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model&lt;- setModel(drift="t1*(t2-x)",diffusion="t3")
T&lt;-10
n&lt;-1000
sampling &lt;- setSampling(Terminal=T,n=n)
yuima&lt;-setYuima(model=model, sampling=sampling)

h0 &lt;- list(t1=0.3, t2=1, t3=0.25)
X &lt;- simulate(yuima, xinit=1, true=h0)
h1 &lt;- list(t1=0.3, t2=0.2, t3=0.1)

phi1 &lt;- function(x) 1-x+x*log(x)

phi.test(X, H0=h0, H1=h1,phi=phi1)
phi.test(X, H0=h0, phi=phi1, start=h0, lower=list(t1=0.1, t2=0.1, t3=0.1), 
   upper=list(t1=2,t2=2,t3=2),method="L-BFGS-B")
phi.test(X, H0=h1, phi=phi1, start=h0, lower=list(t1=0.1, t2=0.1, t3=0.1), 
  upper=list(t1=2,t2=2,t3=2),method="L-BFGS-B")

## End(Not run)
</code></pre>

<hr>
<h2 id='poisson.random.sampling'>Poisson random sampling method</h2><span id='topic+poisson.random.sampling'></span>

<h3>Description</h3>

<p>Poisson random sampling method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson.random.sampling(x, rate, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisson.random.sampling_+3A_x">x</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> or <code><a href="#topic+yuima-class">yuima-class</a></code>.</p>
</td></tr>
<tr><td><code id="poisson.random.sampling_+3A_rate">rate</code></td>
<td>
<p>a Poisson intensity or a vector of Poisson intensities.</p>
</td></tr>
<tr><td><code id="poisson.random.sampling_+3A_n">n</code></td>
<td>
<p>a common multiplier to the Poisson intensities. The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns an object
of type <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> which is a copy of the original input 
data where observations are sampled according to
the Poisson process. The unsampled data are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>an object of  <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>See Also</h3>

<p><a href="#topic+cce">cce</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set a model
diff.coef.1 &lt;- function(t, x1=0, x2) x2*(1+t)
diff.coef.2 &lt;- function(t, x1, x2=0) x1*sqrt(1+t^2)
cor.rho &lt;- function(t, x1=0, x2=0) sqrt((1+cos(x1*x2))/2)
diff.coef.matrix &lt;- matrix(c("diff.coef.1(t,x1,x2)",
"diff.coef.2(t,x1,x2)*cor.rho(t,x1,x2)", "",
"diff.coef.2(t,x1,x2)*sqrt(1-cor.rho(t,x1,x2)^2)"),2,2)
cor.mod &lt;- setModel(drift=c("",""), diffusion=diff.coef.matrix, 
solve.variable=c("x1", "x2"), xinit=c(3,2))
set.seed(111)

## We first simulate the two dimensional diffusion model
yuima.samp &lt;- setSampling(Terminal=1, n=1200)
yuima &lt;- setYuima(model=cor.mod, sampling=yuima.samp)
yuima.sim &lt;- simulate(yuima)

## Then we use function poisson.random.sampling to get observations
## by Poisson sampling.
psample &lt;- poisson.random.sampling(yuima.sim,  rate = c(0.2, 0.3), n=1000)
str(psample)
</code></pre>

<hr>
<h2 id='pz.test'>
Podolskij and Ziggel's Test for the Presence of Jumps Using Power Variation with Perturbed Truncation
</h2><span id='topic+pz.test'></span>

<h3>Description</h3>

<p>Performs a test for the null hypothesis that the realized path has no jump following Podolskij and Ziggel (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pz.test(yuima, p = 4, threshold = "local", tau = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pz.test_+3A_yuima">yuima</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="pz.test_+3A_p">p</code></td>
<td>

<p>a positive number indicating the exponent of the (truncated) power variation to compute test statistic(s). Theoretically, it must be greater than or equal to 2.
</p>
</td></tr>
<tr><td><code id="pz.test_+3A_threshold">threshold</code></td>
<td>

<p>a numeric vector or list indicating the threshold parameter(s). Each of its components indicates the threshold parameter or process to be used for estimating the corresponding component. If it is a numeric vector, the elements in <code>threshold</code> are recycled if there are two few elements in <code>threshold</code>. 
</p>
<p>Alternatively, you can specify either <code>"PZ"</code> or <code>"local"</code> to automatically select a (hopefully) appropriate threshold. When <code>threshold="PZ"</code>, selection is performed following Section 5.1 in Podolskij and Ziggel (2010). When <code>threshold="local"</code>, selection is performed following Section 5.1 in Koike (2014). The default is <code>threshold="local"</code>.
</p>
</td></tr>
<tr><td><code id="pz.test_+3A_tau">tau</code></td>
<td>

<p>a probability controlling the strength of perturbation. See Section 2.3 in Podolskij and Ziggel (2010) for details. Podolskij and Ziggel (2010) suggests using a relatively small value for <code>tau</code>, e.g. <code>tau=0.1</code> or <code>tau=0.05</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same length as <code>dim(yuima)</code>. Each component of the list has class &ldquo;<code>htest</code>&rdquo; and contains the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic of the corresponding component of <code>yuima</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>an approximate p-value for the test of the corresponding component.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &ldquo;<code>Podolskij and Ziggel jump test</code>&rdquo;.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the character string &ldquo;<code>xi</code>&rdquo;, where <code>i</code> is the number of the component.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Podolskij and Ziggel (2010) also introduce a pre-averaged version of the test to deal with noisy observations. Such a test will be implemented in the future version of the package.
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Dumitru, A.-M. and Urga, G. (2012)
Identifying jumps in financial assets: A comparison between nonparametric jump tests.
<em>Journal of Business and Economic Statistics</em>, <b>30</b>, 242&ndash;255.
</p>
<p>Koike, Y. (2014)
An estimator for the cumulative co-volatility of asynchronously observed semimartingales with jumps,
<em>Scandinavian Journal of Statistics</em>, <b>41</b>, 460&ndash;481.
</p>
<p>Maneesoonthorn, W., Martin, G. M. and Forbes, C. S. (2020)
High-frequency jump tests: Which test should we use?
<em>Journal of Econometrics</em>, <b>219</b>, 478&ndash;487.
</p>
<p>Podolskij, M. and Ziggel, D. (2010)
New tests for jumps in semimartingale models,
<em>Statistical Inference for Stochastic Processes</em>, <b>13</b>, 15&ndash;41.
</p>
<p>Theodosiou, M. and Zikes, F. (2011)
A comprehensive comparison of alternative tests for jumps in asset prices. 
Central Bank of Cyprus Working Paper 2011-2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bns.test">bns.test</a></code>, <code><a href="#topic+lm.jumptest">lm.jumptest</a></code>, <code><a href="#topic+minrv.test">minrv.test</a></code>, <code><a href="#topic+medrv.test">medrv.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)

# One-dimensional case
## Model: dXt=t*dWt+t*dzt, 
## where zt is a compound Poisson process with intensity 5 and jump sizes distribution N(0,1).

model &lt;- setModel(drift=0,diffusion="t",jump.coeff="t",measure.type="CP",
                  measure=list(intensity=5,df=list("dnorm(z,0,sqrt(0.1))")),
                  time.variable="t")

yuima.samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)
plot(yuima) # The path seems to involve some jumps

#lm.jumptest(yuima) # p-value is very small, so the path would have a jump
#lm.jumptest(yuima, K = floor(sqrt(390))) # different value of K
pz.test(yuima) # p-value is very small, so the path would have a jump
pz.test(yuima, p = 2) # different value of p
pz.test(yuima, tau = 0.1) # different value of tau

# Multi-dimensional case
## Model: Bivariate standard BM + CP
## Only the first component has jumps

mod &lt;- setModel(drift = c(0, 0), diffusion = diag(2),
                jump.coeff = diag(c(1, 0)),
                measure = list(intensity = 5, 
                               df = "dmvnorm(z,c(0,0),diag(2))"),
                jump.variable = c("z"), measure.type=c("CP"),
                solve.variable=c("x1","x2"))

samp &lt;- setSampling(Terminal = 1, n = 390) 
yuima &lt;- setYuima(model = model, sampling = yuima.samp)
yuima &lt;- simulate(object = mod, sampling = samp)
plot(yuima)

pz.test(yuima) # test is performed component-wise

## End(Not run)
</code></pre>

<hr>
<h2 id='qgv'>qgv</h2><span id='topic+qgv'></span>

<h3>Description</h3>

<p>Estimate the local Holder exponent with quadratic generalized variations method</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgv(yuima, filter.type = "Daubechies", order = 2, a = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgv_+3A_yuima">yuima</code></td>
<td>
<p>A <code>yuima</code> object.</p>
</td></tr>
<tr><td><code id="qgv_+3A_filter.type">filter.type</code></td>
<td>
<p> The <code>filter.type</code> can be set to <code>"Daubechies"</code> or 
<code>"Classical"</code>.</p>
</td></tr>
<tr><td><code id="qgv_+3A_order">order</code></td>
<td>
<p>The order of the filter <code>a</code> to be chosen</p>
</td></tr>
<tr><td><code id="qgv_+3A_a">a</code></td>
<td>
<p>Any other filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the Hurst index and the constant of the fractional Ornstein-Uhlenbeck process.
</p>


<h3>Value</h3>

<p>an object of class qgv
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Brouste, A., Iacus, S.M. (2013) Parameter estimation for the discretely observed fractional Ornstein-Uhlenbeck process and the Yuima R package, Computational Statistics, pp. 1129&ndash;1147.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+mmfrac">mmfrac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimating both Hurst parameter and diffusion coefficient in fractional Ornstein-Uhlenbeck

model&lt;-setModel(drift="-x*lambda",hurst=NA,diffusion="theta")
sampling&lt;-setSampling(T=100,n=10000)
yui1&lt;-simulate(model,true.param=list(theta=1,lambda=4),hurst=0.7,sampling=sampling)
qgv(yui1)


# Estimating Hurst parameter only in diffusion processes

model2&lt;-setModel(drift="-x*lambda",hurst=NA,diffusion="theta*sqrt(x)")
sampling&lt;-setSampling(T=1,n=10000)
yui2&lt;-simulate(model2,true.param=list(theta=1,lambda=4),hurst=0.7,sampling=sampling,xinit=10)
qgv(yui2)
</code></pre>

<hr>
<h2 id='qmle'>Calculate quasi-likelihood and ML estimator of least squares estimator</h2><span id='topic+qmle'></span><span id='topic+quasilogl'></span><span id='topic+rql'></span><span id='topic+lse'></span><span id='topic+pseudologlikelihood'></span><span id='topic+pseudologlikelihood.COGARCH'></span>

<h3>Description</h3>

<p>Calculate the quasi-likelihood and estimate of the parameters of the
stochastic differential equation by the maximum likelihood method or least squares estimator
of the drift parameter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmle(yuima, start, method = "L-BFGS-B", fixed = list(),
print = FALSE, envir = globalenv(), lower, upper, joint = FALSE, Est.Incr ="NoIncr",
aggregation = TRUE, threshold = NULL, rcpp =FALSE, ...)

quasilogl(yuima, param, print = FALSE, rcpp = FALSE)
lse(yuima, start, lower, upper, method = "BFGS", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qmle_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="qmle_+3A_print">print</code></td>
<td>
<p>you can see a progress of the estimation when print is TRUE.</p>
</td></tr>
<tr><td><code id="qmle_+3A_envir">envir</code></td>
<td>
<p>an environment where the model coefficients are evaluated.</p>
</td></tr>
<tr><td><code id="qmle_+3A_method">method</code></td>
<td>
<p>see Details.</p>
</td></tr>
<tr><td><code id="qmle_+3A_param">param</code></td>
<td>
<p><code>list</code> of parameters for the  quasi loglikelihood.</p>
</td></tr>
<tr><td><code id="qmle_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters</p>
</td></tr>
<tr><td><code id="qmle_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters</p>
</td></tr>
<tr><td><code id="qmle_+3A_start">start</code></td>
<td>
<p>initial values to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="qmle_+3A_fixed">fixed</code></td>
<td>
<p>for conditional (quasi)maximum likelihood estimation.</p>
</td></tr>
<tr><td><code id="qmle_+3A_joint">joint</code></td>
<td>
<p>perform joint estimation or two stage estimation? by default <code>joint=FALSE</code>.</p>
</td></tr>
<tr><td><code id="qmle_+3A_est.incr">Est.Incr</code></td>
<td>
<p>If the yuima model is an object of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code> or <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code>  the <code>qmle</code> returns an object of <code><a href="#topic+yuima.carma.qmle-class">yuima.carma.qmle-class</a></code>, <code><a href="#topic+cogarch.est.incr-class">cogarch.est.incr-class</a></code>,<code><a href="#topic+cogarch.est-class">cogarch.est-class</a></code>  or object of class <code>mle-class</code>. By default <code>Est.Incr="NoIncr"</code>, alternative values are <code>IncrPar</code> and <code>Incr</code>. </p>
</td></tr>
<tr><td><code id="qmle_+3A_aggregation">aggregation</code></td>
<td>
<p>If <code>aggregation=TRUE</code>, before the estimation of the levy parameters we aggregate the increments.</p>
</td></tr>
<tr><td><code id="qmle_+3A_threshold">threshold</code></td>
<td>
<p>If the model has Compund Poisson type jumps, the threshold is
used to perform thresholding of the increments.</p>
</td></tr>
<tr><td><code id="qmle_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="stats.html#topic+optim">optim</a></code> method. See Examples.</p>
</td></tr>
<tr><td><code id="qmle_+3A_rcpp">rcpp</code></td>
<td>
<p>use C++ code?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qmle</code> behaves more likely the standard <code>mle</code> function in <span class="pkg">stats4</span> and
argument <code>method</code> is one of the methods available in <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
<p><code>lse</code> calculates least squares estimators of the drift parameters. This is
useful for initial guess of <code>qmle</code> estimation.
<code>quasilogl</code> returns the value of the  quasi loglikelihood for a given
<code>yuima</code> object and list of parameters <code>coef</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>QL</code></td>
<td>
<p>a real value.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>a list with components the same as 'optim' function.</p>
</td></tr>
<tr><td><code>carmaopt</code></td>
<td>
<p>if the model is an object of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>, <code>qmle</code> returns an object <code><a href="#topic+yuima.carma.qmle-class">yuima.carma.qmle-class</a></code></p>
</td></tr>
<tr><td><code>cogarchopt</code></td>
<td>
<p>if the model is an object of <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code>, <code>qmle</code> returns an object of class <code><a href="#topic+cogarch.est-class">cogarch.est-class</a></code>. The estimates are obtained by  maximizing the pseudo-loglikelihood function as shown in Iacus et al. (2015)</p>
</td></tr>
</table>


<h3>Note</h3>


<p>The function qmle uses the function optim internally.
</p>
<p>The function qmle uses the function <code><a href="#topic+CarmaNoise">CarmaNoise</a></code> internally for estimation of underlying Levy if the model is an object of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>## Non-ergodic diffucion
</p>
<p>Genon-Catalot, V., &amp; Jacod, J. (1993). On the estimation of the diffusion coefficient for multi-dimensional diffusion processes. In Annales de l'IHP Probabilits et statistiques, 29(1), 119-151.
</p>
<p>Uchida, M., &amp; Yoshida, N. (2013). Quasi likelihood analysis of volatility and nondegeneracy of statistical random field. Stochastic Processes and their Applications, 123(7), 2851-2876.
</p>
<p>## Ergodic diffusion
</p>
<p>Kessler, M. (1997). Estimation of an ergodic diffusion from discrete observations. Scandinavian Journal of Statistics, 24(2), 211-229.
</p>
<p>## Jump diffusion
</p>
<p>Shimizu, Y., &amp; Yoshida, N. (2006). Estimation of parameters for diffusion processes with jumps from discrete observations. Statistical Inference for Stochastic Processes, 9(3), 227-277.
</p>
<p>Ogihara, T., &amp; Yoshida, N. (2011). Quasi-likelihood analysis for the stochastic differential equation with jumps. Statistical Inference for Stochastic Processes, 14(3), 189-229.
</p>
<p>## COGARCH
</p>
<p>Iacus S. M., Mercuri L. and Rroji E.(2015) Discrete time approximation of a COGARCH (p, q) model and its estimation. <a href="https://doi.org/10.48550/arXiv.1511.00253">doi:10.48550/arXiv.1511.00253</a>
</p>
<p>## CARMA
</p>
<p>Iacus S. M., Mercuri L. (2015) Implementation of Levy CARMA model in Yuima package. Comp. Stat. (30) 1111-1141. <a href="https://doi.org/10.1007/s00180-015-0569-7">doi:10.1007/s00180-015-0569-7</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#dXt^e = -theta2 * Xt^e * dt + theta1 * dWt
diff.matrix &lt;- matrix(c("theta1"), 1, 1)
ymodel &lt;- setModel(drift=c("(-1)*theta2*x"), diffusion=diff.matrix,
  time.variable="t", state.variable="x", solve.variable="x")
n &lt;- 100

ysamp &lt;- setSampling(Terminal=(n)^(1/3), n=n)
yuima &lt;- setYuima(model=ymodel, sampling=ysamp)
set.seed(123)
yuima &lt;- simulate(yuima, xinit=1, true.parameter=list(theta1=0.3,
theta2=0.1))
QL &lt;- quasilogl(yuima, param=list(theta2=0.8, theta1=0.7))
##QL &lt;- ql(yuima, 0.8, 0.7, h=1/((n)^(2/3)))
QL

## another way of parameter specification
##param &lt;- list(theta2=0.8, theta1=0.7)
##QL &lt;- ql(yuima, h=1/((n)^(2/3)), param=param)
##QL


## old code
##system.time(
##opt &lt;- ml.ql(yuima, 0.8, 0.7, h=1/((n)^(2/3)), c(0, 1), c(0, 1))
##)
##cat(sprintf("\nTrue param. theta2 = .3, theta1 = .1\n"))
##print(coef(opt))


system.time(
opt2 &lt;- qmle(yuima, start=list(theta1=0.8, theta2=0.7), lower=list(theta1=0,theta2=0),
 upper=list(theta1=1,theta2=1), method="L-BFGS-B")
)
cat(sprintf("\nTrue param. theta1 = .3, theta2 = .1\n"))
print(coef(opt2))

## initial guess for theta2 by least squares estimator
tmp &lt;- lse(yuima, start=list(theta2=0.7), lower=list(theta2=0), upper=list(theta2=1))
tmp

system.time(
opt3 &lt;- qmle(yuima, start=list(theta1=0.8, theta2=tmp), lower=list(theta1=0,theta2=0),
 upper=list(theta1=1,theta2=1), method="L-BFGS-B")
)
cat(sprintf("\nTrue param. theta1 = .3, theta2 = .1\n"))
print(coef(opt3))


## perform joint estimation? Non-optimal, just for didactic purposes
system.time(
opt4 &lt;- qmle(yuima, start=list(theta1=0.8, theta2=0.7), lower=list(theta1=0,theta2=0),
 upper=list(theta1=1,theta2=1), method="L-BFGS-B", joint=TRUE)
)
cat(sprintf("\nTrue param. theta1 = .3, theta2 = .1\n"))
print(coef(opt4))

## fix theta1 to the true value
system.time(
opt5 &lt;- qmle(yuima, start=list(theta2=0.7), lower=list(theta2=0),
upper=list(theta2=1),fixed=list(theta1=0.3), method="L-BFGS-B")
)
cat(sprintf("\nTrue param. theta1 = .3, theta2 = .1\n"))
print(coef(opt5))

## old code
##system.time(
##opt &lt;- ml.ql(yuima, 0.8, 0.7, h=1/((n)^(2/3)), c(0, 1), c(0, 1), method="Newton")
##)
##cat(sprintf("\nTrue param. theta1 = .3, theta2 = .1\n"))
##print(coef(opt))


## Not run: 
###multidimension case
##dXt^e = - drift.matrix * Xt^e * dt + diff.matrix * dWt
diff.matrix &lt;- matrix(c("theta1.1","theta1.2", "1", "1"), 2, 2)

drift.c &lt;- c("-theta2.1*x1", "-theta2.2*x2", "-theta2.2", "-theta2.1")
drift.matrix &lt;- matrix(drift.c, 2, 2)

ymodel &lt;- setModel(drift=drift.matrix, diffusion=diff.matrix, time.variable="t",
                   state.variable=c("x1", "x2"), solve.variable=c("x1", "x2"))
n &lt;- 100
ysamp &lt;- setSampling(Terminal=(n)^(1/3), n=n)
yuima &lt;- setYuima(model=ymodel, sampling=ysamp)
set.seed(123)

##xinit=c(x1, x2) #true.parameter=c(theta2.1, theta2.2, theta1.1, theta1.2)
yuima &lt;- simulate(yuima, xinit=c(1, 1),
true.parameter=list(theta2.1=0.5, theta2.2=0.3, theta1.1=0.6, theta1.2=0.2))

## theta2 &lt;- c(0.8, 0.2) #c(theta2.1, theta2.2)
##theta1 &lt;- c(0.7, 0.1) #c(theta1.1, theta1.2)
## QL &lt;- ql(yuima, theta2, theta1, h=1/((n)^(2/3)))
## QL

## ## another way of parameter specification
## #param &lt;- list(theta2=theta2, theta1=theta1)
## #QL &lt;- ql(yuima, h=1/((n)^(2/3)), param=param)
## #QL

## theta2.1.lim &lt;- c(0, 1)
## theta2.2.lim &lt;- c(0, 1)
## theta1.1.lim &lt;- c(0, 1)
## theta1.2.lim &lt;- c(0, 1)
## theta2.lim &lt;- t( matrix( c(theta2.1.lim, theta2.2.lim), 2, 2) )
## theta1.lim &lt;- t( matrix( c(theta1.1.lim, theta1.2.lim), 2, 2) )

## system.time(
## opt &lt;- ml.ql(yuima, theta2, theta1, h=1/((n)^(2/3)), theta2.lim, theta1.lim)
## )
## opt@coef

system.time(
opt2 &lt;- qmle(yuima, start=list(theta2.1=0.8, theta2.2=0.2, theta1.1=0.7, theta1.2=0.1),
 lower=list(theta1.1=.1,theta1.2=.1,theta2.1=.1,theta2.2=.1),
 upper=list(theta1.1=4,theta1.2=4,theta2.1=4,theta2.2=4), method="L-BFGS-B")
)
opt2@coef
summary(opt2)

## unconstrained optimization
system.time(
opt3 &lt;- qmle(yuima, start=list(theta2.1=0.8, theta2.2=0.2, theta1.1=0.7, theta1.2=0.1))
)
opt3@coef
summary(opt3)

quasilogl(yuima, param=list(theta2.1=0.8, theta2.2=0.2, theta1.1=0.7, theta1.2=0.1))

##system.time(
##opt &lt;- ml.ql(yuima, theta2, theta1, h=1/((n)^(2/3)), theta2.lim, theta1.lim, method="Newton")
##)
##opt@coef
##

# carma(p=2,q=0) driven by a brownian motion without location parameter

mod0&lt;-setCarma(p=2,
               q=0,
               scale.par="sigma")

true.parm0 &lt;-list(a1=1.39631,
                 a2=0.05029,
                 b0=1,
                 sigma=0.23)

samp0&lt;-setSampling(Terminal=100,n=250)
set.seed(123)
sim0&lt;-simulate(mod0,
               true.parameter=true.parm0,
               sampling=samp0)

system.time(
carmaopt0 &lt;- qmle(sim0, start=list(a1=1.39631,a2=0.05029,
                              b0=1,
                               sigma=0.23))
)

summary(carmaopt0)

# carma(p=2,q=1) driven by a brownian motion without location parameter

mod1&lt;-setCarma(p=2,
               q=1)

true.parm1 &lt;-list(a1=1.39631,
                  a2=0.05029,
                  b0=1,
                  b1=2)

samp1&lt;-setSampling(Terminal=100,n=250)
set.seed(123)
sim1&lt;-simulate(mod1,
               true.parameter=true.parm1,
               sampling=samp1)

system.time(
  carmaopt1 &lt;- qmle(sim1, start=list(a1=1.39631,a2=0.05029,
                                     b0=1,b1=2),joint=TRUE)
)

summary(carmaopt1)

# carma(p=2,q=1) driven by a compound poisson process where the jump size is normally distributed.

mod2&lt;-setCarma(p=2,
               q=1,
               measure=list(intensity="1",df=list("dnorm(z, 0, 1)")),
               measure.type="CP")

true.parm2 &lt;-list(a1=1.39631,
                  a2=0.05029,
                  b0=1,
                  b1=2)

samp2&lt;-setSampling(Terminal=100,n=250)
set.seed(123)
sim2&lt;-simulate(mod2,
               true.parameter=true.parm2,
               sampling=samp2)

system.time(
  carmaopt2 &lt;- qmle(sim2, start=list(a1=1.39631,a2=0.05029,
                                     b0=1,b1=2),joint=TRUE)
)

summary(carmaopt2)

# carma(p=2,q=1) driven by a normal inverse gaussian process
mod3&lt;-setCarma(p=2,q=1,
               measure=list(df=list("rNIG(z, alpha, beta, delta1, mu)")),
               measure.type="code")
#

# True param
true.param3&lt;-list(a1=1.39631,
                 a2=0.05029,
                 b0=1,
                 b1=2,
                 alpha=1,
                 beta=0,
                 delta1=1,
                 mu=0)

samp3&lt;-setSampling(Terminal=100,n=200)
set.seed(123)

sim3&lt;-simulate(mod3,
               true.parameter=true.param3,
               sampling=samp3)


carmaopt3&lt;-qmle(sim3,start=true.param3)

summary(carmaopt3)

# Simulation and Estimation of COGARCH(1,1) with CP driven noise

# Model parameters
eta&lt;-0.053
b1 &lt;- eta
beta &lt;- 0.04
a0 &lt;- beta/b1
phi&lt;- 0.038
a1 &lt;- phi


# Definition

cog11&lt;-setCogarch(p = 1,q = 1,
  measure = list(intensity = "1",
                 df = list("dnorm(z, 0, 1)")),
  measure.type = "CP",
  XinExpr=TRUE)

# Parameter
paramCP11 &lt;- list(a1 = a1, b1 =  b1,
                  a0 = a0, y01 = 50.31)
# Sampling scheme
samp11 &lt;- setSampling(0, 3200, n=64000)

# Simulation
set.seed(125)

SimTime11 &lt;- system.time(
  sim11 &lt;- simulate(object = cog11,
    true.parameter = paramCP11,
    sampling = samp11,
    method="mixed")
)

plot(sim11)

# Estimation

timeComp11&lt;-system.time(
  res11 &lt;- qmle(yuima = sim11,
    start = paramCP11,
    grideq = TRUE,
    method = "Nelder-Mead")
)

timeComp11

unlist(paramCP11)

coef(res11)

# COGARCH(2,2) model driven by CP

cog22 &lt;- setCogarch(p = 2,q = 2,
  measure = list(intensity = "1",
                 df = list("dnorm(z, 0, 1)")),
  measure.type = "CP",
  XinExpr=TRUE)

# Parameter

paramCP22 &lt;- list(a1 = 0.04, a2 = 0.001,
  b1 =  0.705, b2 = 0.1, a0 = 0.1, y01 = (1 + 2 / 3),
  y02=0)

# Use diagnostic.cog for checking the stat and positivity

check22 &lt;- Diagnostic.Cogarch(cog22, param = paramCP22)

# Sampling scheme

samp22 &lt;- setSampling(0, 3600, n = 64000)

# Simulation

set.seed(125)
SimTime22 &lt;- system.time(
  sim22 &lt;- simulate(object = cog22,
    true.parameter = paramCP22,
    sampling = samp22,
    method = "Mixed")
)

plot(sim22)

timeComp22 &lt;- system.time(
  res22 &lt;- qmle(yuima = sim22,
    start = paramCP22,
    grideq=TRUE,
    method = "Nelder-Mead")
)

timeComp22

unlist(paramCP22)

coef(res22)


## End(Not run)
</code></pre>

<hr>
<h2 id='qmleLevy'>
Gaussian quasi-likelihood estimation for Levy driven SDE
</h2><span id='topic+qmleLevy'></span><span id='topic+Estimation.LevyIncr'></span><span id='topic+LevySDE'></span>

<h3>Description</h3>

<p>Calculate the Gaussian quasi-likelihood and Gaussian quasi-likelihood estimators of Levy driven SDE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmleLevy(yuima, start, lower, upper, joint = FALSE, 
third = FALSE, Est.Incr = "NoIncr", 
aggregation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qmleLevy_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="qmleLevy_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="qmleLevy_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="qmleLevy_+3A_start">start</code></td>
<td>
<p>initial values to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="qmleLevy_+3A_joint">joint</code></td>
<td>
<p>perform joint estimation or two stage estimation, by default <code>joint=FALSE</code>. If there exists an overlapping parameter, <code>joint=TRUE</code> does not work for the theoretical reason</p>
</td></tr>
<tr><td><code id="qmleLevy_+3A_third">third</code></td>
<td>
<p>perform third estimation by default <code>third=FALSE</code>. If there exists an overlapping parameter, <code>third=TRUE</code> does not work for the         
theoretical reason.</p>
</td></tr>
<tr><td><code id="qmleLevy_+3A_est.incr">Est.Incr</code></td>
<td>
<p>the qmleLevy returns an object of <code>mle-clas</code>, by default <code>Est.Incr="NoIncr"</code>, other options as <code>"Inc"</code> or <code>"IncrPar"</code>.</p>
</td></tr>         
<tr><td><code id="qmleLevy_+3A_aggregation">aggregation</code></td>
<td>
<p>If <code>aggregation=TRUE</code>, the function returns the unit-time Levy increments. If <code>Est.Incr="IncrPar"</code>, the function estimates Levy parameters using the unit-time Levy increments.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>This function performs Gaussian quasi-likelihood estimation for Levy driven SDE.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>first</code></td>
<td>
<p>estimated values of first estimation (scale parameters)</p>
</td></tr>
<tr><td><code>second</code></td>
<td>
<p>estimated values of second estimation (drift parameters)</p>
</td></tr>
<tr><td><code>third</code></td>
<td>
<p>estimated values of third estimation (scale parameters)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code>qmleLevy</code> uses the function <code>qmle</code> internally.
It can be applied only for the standardized Levy noise whose moments of any order exist.
In present <code>yuima</code> package, birateral gamma (bgamma) process, normal inverse Gaussian (NIG) process, variance gamma (VG) process, and normal tempered stable process are such candidates.
In the current version, the standardization condition on the driving noise is internally checked only for the one-dimensional noise.
The standardization condition for the multivariate noise is given in
</p>
<p><a href="https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnx5dW1hdWVoYXJhMTkyOHxneDo1OGIxNGQ2YjBlYWIxNzA3">https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnx5dW1hdWVoYXJhMTkyOHxneDo3ZTdlMTA1OTMyZTBkYjQ2</a>
</p>
<p>or
</p>
<p><a href="https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnx5dW1hdWVoYXJhMTkyOHxneDo3ZTdlMTA1OTMyZTBkYjQ2">https://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=ZGVmYXVsdGRvbWFpbnx5dW1hdWVoYXJhMTkyOHxneDo3ZTdlMTA1OTMyZTBkYjQ2</a>.
</p>
<p>They also contain more presice explanation of this function.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Yuma Uehara <a href="mailto:y-uehara@ism.ac.jp">y-uehara@ism.ac.jp</a>
</p>


<h3>References</h3>

<p>Masuda, H. (2013). Convergence of Gaussian quasi-likelihood random fields for ergodic Levy driven SDE observed at high frequency. The Annals of Statistics, 41(3), 1593-1641.
</p>
<p>Masuda, H. and Uehara, Y. (2017). On stepwise estimation of Levy driven 
stochastic differential equation (Japanese) ., Proc. Inst. Statist. Math., accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## One-dimensional case 
dri&lt;-"-theta0*x" ## set drift
jum&lt;-"theta1/(1+x^2)^(-1/2)" ## set jump
yuima&lt;-setModel(drift = dri
                ,jump.coeff = jum
                ,solve.variable = "x",state.variable = "x"
                ,measure.type = "code"
                ,measure = list(df="rbgamma(z,1,sqrt(2),1,sqrt(2))")) ## set true model
n&lt;-3000
T&lt;-30 ## terminal
hn&lt;-T/n ## stepsize

sam&lt;-setSampling(Terminal = T, n=n) ## set sampling scheme
yuima&lt;-setYuima(model = yuima, sampling = sam) ## model

true&lt;-list(theta0 = 1,theta1 = 2) ## true values
upper&lt;-list(theta0 = 4, theta1 = 4) ## set upper bound
lower&lt;-list(theta0 = 0.5, theta1 = 1) ## set lower bound
set.seed(123)
yuima&lt;-simulate(yuima, xinit = 0, true.parameter = true,sampling = sam) ## generate a path
start&lt;-list(theta0 = runif(1,0.5,4), theta1 = runif(1,1,4)) ## set initial values
qmleLevy(yuima,start=start,lower=lower,upper=upper, joint = TRUE) 

## Multi-dimensional case

lambda&lt;-1/2
alpha&lt;-1
beta&lt;-c(0,0)
mu&lt;-c(0,0)
Lambda&lt;-matrix(c(1,0,0,1),2,2) ## set parameters in noise

dri&lt;-c("1-theta0*x1-x2","-theta1*x2")
jum&lt;-matrix(c("x1*theta2+1","0","0","1"),2,2) ## set coefficients

yuima &lt;- setModel(drift=dri, 
                 solve.variable=c("x1","x2"),state.variable = c("x1","x2"), 
                 jump.coeff=jum, measure.type="code",
                 measure=list(df="rvgamma(z, lambda, alpha, beta, mu, Lambda
                 )"))

n&lt;-3000 ## the number of total samples
T&lt;-30 ## terminal
hn&lt;-T/n ## stepsize

sam&lt;-setSampling(Terminal = T, n=n) ## set sampling scheme
yuima&lt;-setYuima(model = yuima, sampling = sam) ## model

true&lt;-list(theta0 = 1,theta1 = 2,theta2 = 3,lambda=lambda, alpha=alpha, 
beta=beta,mu=mu, Lambda=Lambda) ## true values
upper&lt;-list(theta0 = 4, theta1 = 4, theta2 = 5, lambda=lambda, alpha=alpha, 
beta=beta,mu=mu, Lambda=Lambda) ## set upper bound
lower&lt;-list(theta0 = 0.5, theta1 = 1, theta2 = 1, lambda=lambda, alpha=alpha, 
beta=beta,mu=mu, Lambda=Lambda) ## set lower bound
set.seed(123)
yuima&lt;-simulate(yuima, xinit = c(0,0), true.parameter = true,sampling = sam) ## generate a path
plot(yuima)
start&lt;-list(theta0 = runif(1,0.5,4), theta1 = runif(1,1,4), 
theta2 = runif(1,1,5),lambda=lambda, alpha=alpha, 
beta=beta,mu=mu, Lambda=Lambda) ## set initial values
qmleLevy(yuima,start=start,lower=lower,upper=upper,joint = FALSE,third=TRUE) 

## End(Not run)
</code></pre>

<hr>
<h2 id='rconst'>
Fictitious rng for the constant random variable used to generate and describe
Poisson jumps.
</h2><span id='topic+rconst'></span><span id='topic+dconst'></span>

<h3>Description</h3>

<p>Fictitious rng for the constant random variable used to generate and describe
Poisson jumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rconst(n, k = 1)
dconst(x, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rconst_+3A_n">n</code></td>
<td>
<p>number of replications</p>
</td></tr>
<tr><td><code id="rconst_+3A_k">k</code></td>
<td>
<p>the size of the jump</p>
</td></tr>
<tr><td><code id="rconst_+3A_x">x</code></td>
<td>
<p>the fictitious argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a numeric vector
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>dconst(1,1)
dconst(2,1)
dconst(2,2)

rconst(10,3)
</code></pre>

<hr>
<h2 id='rng'>Random numbers and densities</h2><span id='topic+rng'></span><span id='topic+rIG'></span><span id='topic+dIG'></span><span id='topic+rNIG'></span><span id='topic+dNIG'></span><span id='topic+rbgamma'></span><span id='topic+dbgamma'></span><span id='topic+rvgamma'></span><span id='topic+dvgamma'></span><span id='topic+rGIG'></span><span id='topic+dGIG'></span><span id='topic+rGH'></span><span id='topic+dGH'></span><span id='topic+rstable'></span><span id='topic+rpts'></span><span id='topic+rnts'></span>

<h3>Description</h3>

<p><code>simulate</code> function can use the specific random number generators to generate Levy paths.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rGIG(x,lambda,delta,gamma)
dGIG(x,lambda,delta,gamma)
rGH(x,lambda,alpha,beta,delta,mu,Lambda)
dGH(x,lambda,alpha,beta,delta,mu,Lambda)
rIG(x,delta,gamma)
dIG(x,delta,gamma)
rNIG(x,alpha,beta,delta,mu,Lambda)
dNIG(x,alpha,beta,delta,mu,Lambda)
rvgamma(x,lambda,alpha,beta,mu,Lambda)
dvgamma(x,lambda,alpha,beta,mu,Lambda)
rbgamma(x,delta.plus,gamma.plus,delta.minus,gamma.minus)
dbgamma(x,delta.plus,gamma.plus,delta.minus,gamma.minus)
rstable(x,alpha,beta,sigma,gamma)
rpts(x,alpha,a,b)
rnts(x,alpha,a,b,beta,mu,Lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rng_+3A_x">x</code></td>
<td>
<p>Number of R.Ns to be geneated.</p>
</td></tr>
<tr><td><code id="rng_+3A_a">a</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="rng_+3A_b">b</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="rng_+3A_delta">delta</code></td>
<td>
<p>parameter written as <code class="reqn">\delta</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_gamma">gamma</code></td>
<td>
<p>parameter written as <code class="reqn">\gamma</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_mu">mu</code></td>
<td>
<p>parameter written as <code class="reqn">\mu</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_lambda">Lambda</code></td>
<td>
<p>parameter written as <code class="reqn">\Lambda</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_alpha">alpha</code></td>
<td>
<p>parameter written as <code class="reqn">\alpha</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_lambda">lambda</code></td>
<td>
<p>parameter written as <code class="reqn">\lambda</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_sigma">sigma</code></td>
<td>
<p>parameter written as <code class="reqn">\sigma</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_beta">beta</code></td>
<td>
<p>parameter written as <code class="reqn">\beta</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_delta.plus">delta.plus</code></td>
<td>
<p>parameter written as <code class="reqn">\delta_+</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_gamma.plus">gamma.plus</code></td>
<td>
<p>parameter written as <code class="reqn">\gamma_+</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_delta.minus">delta.minus</code></td>
<td>
<p>parameter written as <code class="reqn">\delta_-</code> below</p>
</td></tr>
<tr><td><code id="rng_+3A_gamma.minus">gamma.minus</code></td>
<td>
<p>parameter written as <code class="reqn">\gamma_-</code> below</p>
</td></tr>





</table>


<h3>Details</h3>

<p><code>GIG</code> (generalized inverse Gaussian): 
The density function of GIG distribution is expressed as:
</p>
<p><code class="reqn">f(x)= 1/2*(\gamma/\delta)^\lambda*1/bK_\lambda(\gamma*\delta)*x^(\lambda-1)*exp(-1/2*(\delta^2/x+\gamma^2*x))</code>
</p>
<p>where <code class="reqn">bK_\lambda()</code> is the modified Bessel function of the third kind with order lambda.
The parameters <code class="reqn">\lambda, \delta</code> and <code class="reqn">\gamma</code> vary within the following regions:
</p>
<p><code class="reqn">\delta&gt;=0, \gamma&gt;0</code> if <code class="reqn">\lambda&gt;0</code>,
</p>
<p><code class="reqn">\delta&gt;0, \gamma&gt;0</code> if <code class="reqn">\lambda=0</code>,
</p>
<p><code class="reqn">\delta&gt;0, \gamma&gt;=0</code> if <code class="reqn">\lambda&lt;0</code>.
</p>
<p>The corresponding Levy measure is given in Eberlein, E., &amp; Hammerstein, E. A. V. (2004) (it contains IG).
</p>
<p><code>GH</code> (generalized hyperbolic): Generalized hyperbolic distribution is defined by the normal mean-variance mixture of generalized inverse Gaussian distribution. The parameters <code class="reqn">\alpha, \beta, \delta, \mu</code> express heaviness of tails, degree of asymmetry, scale and location, respectively. Here the parameter <code class="reqn">\Lambda</code> is supposed to be symmetric and positive definite with <code class="reqn">det(\Lambda)=1</code> and the parameters vary within the following region:
</p>
<p><code class="reqn">\delta&gt;=0, \alpha&gt;0, \alpha^2&gt;\beta^T \Lambda \beta</code> if <code class="reqn">\lambda&gt;0</code>,
</p>
<p><code class="reqn">\delta&gt;0, \alpha&gt;0, \alpha^2&gt;\beta^T \Lambda \beta</code> if <code class="reqn">\lambda=0</code>,
</p>
<p><code class="reqn">\delta&gt;0, \alpha&gt;=0, \alpha^2&gt;=\beta^T \Lambda \beta</code> if <code class="reqn">\lambda&lt;0</code>.
</p>
<p>The corresponding Levy measure is given in Eberlein, E., &amp; Hammerstein, E. A. V. (2004) (it contains NIG and vgamma).
</p>
<p><code>IG</code> (inverse Gaussian (the element of GIG)): <code class="reqn">\Delta</code> and <code class="reqn">\gamma</code> are positive (the case of <code class="reqn">\gamma=0</code> corresponds to the positive half stable, provided by the &quot;rstable&quot;).
</p>
<p><code>NIG</code> (normal inverse Gaussian (the element of GH)): Normal inverse Gaussian distribution is defined by the normal mean-variance mixuture of inverse Gaussian distribution. The parameters <code class="reqn">\alpha, \beta, \delta</code> and <code class="reqn">\mu</code> express the heaviness of tails, degree of asymmetry, scale and location, respectively. They satisfy the following conditions:
<code class="reqn">\Lambda</code> is symmetric and positive definite with <code class="reqn">det(\Lambda)=1; \delta&gt;0; \alpha&gt;0</code> with <code class="reqn">\alpha^2-\beta^T \Lambda \beta &gt;0</code>.
</p>
<p><code>vgamma</code> (variance gamma (the element of GH)): Variance gamma distribution is defined by the normal mean-variance mixture of gamma distribution. The parameters satisfy the following conditions:
Lambda is symmetric and positive definite with <code class="reqn">det(\Lambda)=1; \lambda&gt;0; \alpha&gt;0</code> with <code class="reqn">\alpha^2-\beta^T \Lambda \beta &gt;0</code>. Especially in the case of <code class="reqn">\beta=0</code> it is variance gamma distribution.
</p>
<p><code>bgamma</code> (bilateral gamma): Bilateral gamma distribution is defined by the difference of independent gamma distributions <code class="reqn">Gamma(\delta_+,\gamma_+) and Gamma(\delta_-,\gamma_-)</code>. Its Levy density <code class="reqn">f(z)</code> is given by: 
<code class="reqn">f(z)=\delta_+/z*exp(-\gamma_+*z)*ind(z&gt;0)+\delta_-/|z|*exp(-\gamma_-*|z|)*ind(z&lt;0)</code>, where the function <code class="reqn">ind()</code> denotes an indicator function.
</p>
<p><code>stable</code> (stable): Parameters <code class="reqn">\alpha, \beta, \sigma</code> and <code class="reqn">\gamma</code> express stability, degree of skewness, scale and location, respectively. They satisfy the following condition: <code class="reqn">0&lt;\alpha&lt;=2; -1&lt;=\beta&lt;=1; \sigma&gt;0; \gamma</code> is a real number.
</p>
<p><code>pts</code> (positive tempered stable): Positive tempered stable distribution is defined by the tilting of positive stable distribution. The parameters <code class="reqn">\alpha, a</code> and <code class="reqn">b</code> express stability, scale and degree of tilting, respectively. They satisfy the following condition: <code class="reqn">0&lt;\alpha&lt;1; a&gt;0; b&gt;0</code>. Its Levy density <code class="reqn">f(z)</code> is given by: <code class="reqn">f(z)=az^(-1-\alpha)exp(-bz)</code>.
</p>
<p><code>nts</code> (normal tempered stable): Normal tempered stable distribution is defined by the normal mean-variance mixture of positive tempered stable distribution. The parameters <code class="reqn">\alpha, a, b, \beta, \mu</code> and <code class="reqn">\Lambda</code> express stability, scale, degree of tilting, degree of asymmemtry, location and degree of mixture, respectively. They satisfy the following condition: Lambda is symmetric and positive definite with <code class="reqn">det(\Lambda)=1; 0&lt;\alpha&lt;1; a&gt;0; b&gt;0</code>. 
In one-dimensional case, its Levy density <code class="reqn">f(z)</code> is given by: 
<code class="reqn">f(z)=2a/(2\pi)^(1/2)*\exp(\beta*z)*(z^2/(2b+\beta^2))^(-\alpha/2-1/4)*bK_(\alpha+1/2)(z^2(2b+\beta^2)^(1/2))</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rXXX</code></td>
<td>
<p>Collection of of random numbers or vectors</p>
</td></tr>
<tr><td><code>dXXX</code></td>
<td>
<p>Density function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Some density-plot functions are still missing: as for the non-Gaussian stable densities, one can use, e.g., stabledist package.
The rejection-acceptance method is used for generating pts and nts. It should be noted that its acceptance rate decreases at exponential order as <code class="reqn">a</code> and <code class="reqn">b</code> become larger: specifically, the rate is given by <code class="reqn">exp(a*\Gamma(-\alpha)*b^(\alpha))</code>
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Hiroki Masuda <a href="mailto:hmasuda@ms.u-tokyo.ac.jp">hmasuda@ms.u-tokyo.ac.jp</a> and Yuma Uehara <a href="mailto:y-uehara@kansai-u.ac.jp">y-uehara@kansai-u.ac.jp</a>
</p>


<h3>References</h3>

<p>## rGIG, dGIG, rIG, dIG
</p>
<p>Chhikara, R. (1988). The Inverse Gaussian Distribution: Theory: Methodology, and Applications (Vol. 95). CRC Press.
</p>
<p>Hormann, W., &amp; Leydold, J. (2014). Generating generalized inverse Gaussian random variates. Statistics and Computing, 24(4), 547-557.
<a href="https://doi.org/10.1111/1467-9469.00045">doi:10.1111/1467-9469.00045</a>
</p>
<p>Jorgensen, B. (2012). Statistical properties of the generalized inverse Gaussian distribution (Vol. 9). Springer Science &amp; Business Media.
<a href="https://link.springer.com/book/10.1007/978-1-4612-5698-4">https://link.springer.com/book/10.1007/978-1-4612-5698-4</a>
</p>
<p>Michael, J. R., Schucany, W. R., &amp; Haas, R. W. (1976). Generating random variates using transformations with multiple roots. The American Statistician, 30(2), 88-90.
<a href="https://doi.org/10.1080/00031305.1976.10479147">doi:10.1080/00031305.1976.10479147</a>
</p>
<p>## rGH, dGH, rNIG, dNIG, rvgamma, dvgamma
</p>
<p>Barndorff-Nielsen, O. (1977). Exponentially decreasing distributions for the logarithm of particle size. In Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences (Vol. 353, No. 1674, pp. 401-419). The Royal Society.
<a href="https://doi.org/10.1098/rspa.1977.0041">doi:10.1098/rspa.1977.0041</a>
</p>
<p>Barndorff-Nielsen, O. E. (1997). Processes of normal inverse Gaussian type. Finance and stochastics, 2(1), 41-68.
<a href="https://doi.org/10.1007/s007800050032">doi:10.1007/s007800050032</a>
</p>
<p>Eberlein, E. (2001). Application of generalized hyperbolic Levy motions to finance. In Levy processes (pp. 319-336). Birkhauser Boston.
<a href="https://doi.org/10.1007/978-1-4612-0197-7_14">doi:10.1007/978-1-4612-0197-7_14</a>
</p>
<p>Eberlein, E., &amp; Hammerstein, E. A. V. (2004). Generalized hyperbolic and inverse Gaussian distributions: limiting cases and approximation of processes. In Seminar on stochastic analysis, random fields and applications IV (pp. 221-264). Birkh??user Basel.
<a href="https://doi.org/10.1007/978-1-4612-0197-7_14">doi:10.1007/978-1-4612-0197-7_14</a>
</p>
<p>Madan, D. B., Carr, P. P., &amp; Chang, E. C. (1998). The variance gamma process and option pricing. European finance review, 2(1), 79-105.
<a href="https://doi.org/10.1111/1467-9469.00045">doi:10.1111/1467-9469.00045</a>
</p>
<p>## rbgamma, dbgamma
</p>
<p>Kuchler, U., &amp; Tappe, S. (2008). Bilateral Gamma distributions and processes in financial mathematics. Stochastic Processes and their Applications, 118(2), 261-283.
<a href="https://doi.org/10.1016/j.spa.2007.04.006">doi:10.1016/j.spa.2007.04.006</a>
</p>
<p>Kuchler, U., &amp; Tappe, S. (2008). On the shapes of bilateral Gamma densities. Statistics &amp; Probability Letters, 78(15), 2478-2484.
<a href="https://doi.org/10.1016/j.spa.2007.04.006">doi:10.1016/j.spa.2007.04.006</a>
</p>
<p>## rstable
</p>
<p>Chambers, John M., Colin L. Mallows, and B. W. Stuck.  (1976) A method for simulating stable random variables, Journal of the american statistical association, 71(354), 340-344.
<a href="https://doi.org/10.1080/01621459.1976.10480344">doi:10.1080/01621459.1976.10480344</a>
</p>
<p>Weron, Rafal. (1996) On the Chambers-Mallows-Stuck method for simulating skewed stable random variables, Statistics &amp; probability letters, 28.2, 165-171.
<a href="https://doi.org/10.1016/0167-7152%2895%2900113-1">doi:10.1016/0167-7152(95)00113-1</a>
</p>
<p>Weron, Rafal. (2010) Correction to:&quot; On the Chambers-Mallows-Stuck Method for Simulating Skewed Stable Random Variables&quot;, No. 20761, University Library of Munich, Germany.
<a href="https://ideas.repec.org/p/pra/mprapa/20761.html">https://ideas.repec.org/p/pra/mprapa/20761.html</a>
</p>
<p>## rpts
</p>
<p>Kawai, R., &amp; Masuda, H. (2011). On simulation of tempered stable random variates. Journal of Computational and Applied Mathematics, 235(8), 2873-2887.
<a href="https://doi.org/10.1016/j.cam.2010.12.014">doi:10.1016/j.cam.2010.12.014</a>
</p>
<p>## rnts
</p>
<p>Barndorff-Nielsen, O. E., &amp; Shephard, N. (2001). Normal modified stable processes. Aarhus: MaPhySto, Department of Mathematical Sciences, University of Aarhus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)

# Ex 1. (One-dimensional standard Cauchy distribution)
# The value of parameters is alpha=1,beta=0,sigma=1,gamma=0.
# Choose the values of x.
x&lt;-10 # the number of r.n
rstable(x,1,0,1,0)

# Ex 2. (One-dimensional Levy distribution)
# Choose the values of sigma, gamma, x.
# alpha = 0.5, beta=1
x&lt;-10 # the number of r.n
beta &lt;- 1
sigma &lt;- 0.1
gamma &lt;- 0.1
rstable(x,0.5,beta,sigma,gamma)

# Ex 3. (Symmetric bilateral gamma)
# delta=delta.plus=delta.minus, gamma=gamma.plus=gamma.minus.
# Choose the values of delta and gamma and x.
x&lt;-10 # the number of r.n
rbgamma(x,1,1,1,1)

# Ex 4. ((Possibly skewed) variance gamma)
# lambda, alpha, beta, mu
# Choose the values of lambda, alpha, beta, mu and x.
x&lt;-10 # the number of r.n
rvgamma(x,2,1,-0.5,0)

# Ex 5. (One-dimensional normal inverse Gaussian distribution)
# Lambda=1.
# Choose the parameter values and x.
x&lt;-10 # the number of r.n
rNIG(x,1,1,1,1)

# Ex 6. (Multi-dimensional normal inverse Gaussian distribution)
# Choose the parameter values and x.
beta&lt;-c(.5,.5)
mu&lt;-c(0,0)
Lambda&lt;-matrix(c(1,0,0,1),2,2)
x&lt;-10 # the number of r.n
rNIG(x,1,beta,1,mu,Lambda)

# Ex 7. (Positive tempered stable)
# Choose the parameter values and x.
alpha&lt;-0.7
a&lt;-0.2
b&lt;-1
x&lt;-10 # the number of r.n
rpts(x,alpha,a,b)

# Ex 8. (Generarized inverse Gaussian)
# Choose the parameter values and x.
lambda&lt;-0.3
delta&lt;-1
gamma&lt;-0.5
x&lt;-10 # the number of r.n
rGIG(x,lambda,delta,gamma)

# Ex 9. (Multi-variate generalized hyperbolic)
# Choose the parameter values and x.
lambda&lt;-0.4
alpha&lt;-1
beta&lt;-c(0,0.5)
delta&lt;-1
mu&lt;-c(0,0)
Lambda&lt;-matrix(c(1,0,0,1),2,2)
x&lt;-10 # the number of r.n
rGH(x,lambda,alpha,beta,delta,mu,Lambda)

## End(Not run)
</code></pre>

<hr>
<h2 id='setCarma'>
Continuous Autoregressive Moving Average (p, q) model 
</h2><span id='topic+Carma'></span><span id='topic+CARMA'></span><span id='topic+setCarma'></span>

<h3>Description</h3>

<p>'setCarma' describes the following model: 
</p>
<p><code>Vt = c0 + sigma (b0 Xt(0) + ... + b(q) Xt(q))</code> 
</p>
<p><code>dXt(0) = Xt(1) dt</code>  
</p>
<p><code>...</code>
</p>
<p><code>dXt(p-2) = Xt(p-1) dt</code>
</p>
<p><code>dXt(p-1) = (-a(p) Xt(0) - ... - a(1) Xt(p-1))dt + (gamma(0) + gamma(1) Xt(0) + ... + gamma(p) Xt(p-1))dZt</code>
</p>
<p>The continuous ARMA process using the state-space representation as in Brockwell (2000) is obtained by choosing: 
</p>
<p><code> gamma(0) = 1, gamma(1) = gamma(2) = ... = gamma(p) = 0.</code> 
</p>
<p>Please refer to the vignettes and the examples or the <b>yuima</b> documentation for details.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCarma(p,q,loc.par=NULL,scale.par=NULL,ar.par="a",ma.par="b",
lin.par=NULL,Carma.var="v",Latent.var="x",XinExpr=FALSE, Cogarch=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCarma_+3A_p">p</code></td>
<td>
<p>a non-negative integer that indicates the number of the autoregressive coefficients.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_q">q</code></td>
<td>
<p>a non-negative integer that indicates the number of the moving average coefficients.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_loc.par">loc.par</code></td>
<td>
<p>location coefficient. The default value <code>loc.par=NULL</code> implies that <code>c0=0</code>.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_scale.par">scale.par</code></td>
<td>
<p>scale coefficient. The default value <code>scale.par=NULL</code> implies that <code>sigma=1</code>.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_ar.par">ar.par</code></td>
<td>
<p>a character-string that is the label of the autoregressive coefficients. The default Value is <code>ar.par="a"</code>.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_ma.par">ma.par</code></td>
<td>
<p>a character-string that is the label of the moving average coefficients. The default Value is <code>ma.par="b"</code>.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_carma.var">Carma.var</code></td>
<td>
<p>a character-string that is the label of the observed process. Defaults to <code>"v"</code>.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_latent.var">Latent.var</code></td>
<td>
<p>a character-string that is the label of the unobserved process. Defaults to <code>"x"</code>.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_lin.par">lin.par</code></td>
<td>
<p>a character-string that is the label of the linear coefficients. If <code>lin.par=NULL</code>, the default, the 'setCarma' builds the CARMA(p, q) model defined as in Brockwell (2000). </p>
</td></tr>
<tr><td><code id="setCarma_+3A_xinexpr">XinExpr</code></td>
<td>
<p>a logical variable. The default value <code>XinExpr=FALSE</code> implies that the starting condition for <code>Latent.var</code> is zero. If <code>XinExpr=TRUE</code>, each component of <code>Latent.var</code> has a parameter as a initial value.</p>
</td></tr>
<tr><td><code id="setCarma_+3A_cogarch">Cogarch</code></td>
<td>
<p>a logical variable. The default value <code>Cogarch=FALSE</code> implies that the parameters are specified according to Brockwell (2000).  </p>
</td></tr>
<tr><td><code id="setCarma_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'setCarma', such as the slots of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>
</p>

<dl>
<dt><code>measure</code></dt><dd><p>Levy measure of jump variables.</p>
</dd>
<dt><code>measure.type</code></dt><dd><p>type specification for Levy measure.</p>
</dd>
<dt><code>xinit</code></dt><dd><p>a vector of <code>expression</code>s identyfying the starting conditions for CARMA model.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to the vignettes and the examples or to the <span class="pkg">yuimadocs</span> package.
</p>
<p>An object of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code> contains:
</p>
  	
<dl>
<dt><code>info</code>:</dt><dd><p>It  is an object 
of  <code><a href="#topic+carma.info-class">carma.info-class</a></code> which is a list of arguments that identifies the carma(p,q) model</p>
</dd>
</dl>

<p>and the same slots in an object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> .
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There may be missing information in the model description. 
Please contribute with suggestions and fixings.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Brockwell, P. (2000)
Continuous-time ARMA processes, <em>Stochastic Processes: Theory and Methods. Handbook of Statistics</em>, <b>19</b>, (C. R. Rao and D. N. Shandhag, eds.) 249-276. North-Holland, Amsterdam.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex 1. (Continuous ARMA process driven by a Brownian Motion)
# To describe the state-space representation of a CARMA(p=3,q=1) model:
# Vt=c0+alpha0*X0t+alpha1*X1t
# dX0t = X1t*dt 
# dX1t = X2t*dt
# dX2t = (-beta3*X0t-beta2*X1t-beta1*X2t)dt+dWt
# we set
mod1&lt;-setCarma(p=3, 
               q=1, 
               loc.par="c0")
# Look at the model structure by
str(mod1)

# Ex 2. (General setCarma model driven by a Brownian Motion)
# To describe the model defined as:
# Vt=c0+alpha0*X0t+alpha1*X1t
# dX0t = X1t*dt 
# dX1t = X2t*dt
# dX2t = (-beta3*X0t-beta2*X1t-beta1*X2t)dt+(c0+alpha0*X0t)dWt
# we set 
mod2 &lt;- setCarma(p=3,
                 q=1,
                 loc.par="c0",
                 ma.par="alpha",
                 ar.par="beta",
                 lin.par="alpha")
# Look at the model structure by
str(mod2)

# Ex 3. (Continuous Arma model driven by a Levy process)
# To specify the CARMA(p=3,q=1) model driven by a Compound Poisson process defined as:
# Vt=c0+alpha0*X0t+alpha1*X1t
# dX0t = X1t*dt 
# dX1t = X2t*dt
# dX2t = (-beta3*X0t-beta2*X1t-beta1*X2t)dt+dzt
# we set the Levy measure as in setModel
mod3 &lt;- setCarma(p=3,
                 q=1,
                 loc.par="c0",
                 measure=list(intensity="1",df=list("dnorm(z, 0, 1)")),
                 measure.type="CP")
# Look at the model structure by
str(mod3)

# Ex 4. (General setCarma  model driven by a Levy process)
# Vt=c0+alpha0*X0t+alpha1*X1t
# dX0t = X1t*dt 
# dX1t = X2t*dt
# dX2t = (-beta3*X1t-beta2*X2t-beta1*X3t)dt+(c0+alpha0*X0t)dzt
mod4 &lt;- setCarma(p=3,
                 q=1,
                 loc.par="c0",
                 ma.par="alpha",
                 ar.par="beta",
                 lin.par="alpha",
                 measure=list(intensity="1",df=list("dnorm(z, 0, 1)")),
                 measure.type="CP")
# Look at the model structure by
str(mod4)
</code></pre>

<hr>
<h2 id='setCarmaHawkes'>
Hawkes Process with a Continuous Autoregressive Moving Average(p, q) intensity
</h2><span id='topic+CarmaHawkes'></span><span id='topic+Hawkes.Carma.Intensity'></span><span id='topic+setCarmaHawkes'></span>

<h3>Description</h3>

<p>'setCarmaHawkes' describes a self-exciting Hawkes process where the intensity is a CARMA(p,q) process. The model admits the Hawkes process with exponential kernel as a special case but it is able to reproduce a more complex time-dependence structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCarmaHawkes(p, q, law = NULL, base.Int = "mu0", 
ar.par = "a", ma.par = "b", Counting.Process = "N", 
Intensity.var = "lambda", Latent.var = "x", time.var = "t", 
Type.Jump = FALSE, XinExpr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCarmaHawkes_+3A_p">p</code></td>
<td>
<p>a non-negative integer that indicates the number of the autoregressive coefficients.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_q">q</code></td>
<td>
<p>a non-negative integer that indicates the number of the moving average coefficients.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_law">law</code></td>
<td>
<p> An object of <code><a href="#topic+yuima.law-class">yuima.law-class</a></code> that describes the jump size. If it is <code>NULL</code>, the jump size is unitary.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_base.int">base.Int</code></td>
<td>
<p>a character-string that is the label of the baseline Intensity parameter. Defaults to <code>"mu0"</code>.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_ar.par">ar.par</code></td>
<td>
<p>a character-string that is the label of the autoregressive coefficients. The default Value is <code>ar.par="a"</code>.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_ma.par">ma.par</code></td>
<td>
<p>a character-string that is the label of the moving average coefficients. The default Value is <code>ma.par="b"</code>.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_counting.process">Counting.Process</code></td>
<td>
<p>a character-string that is the label of the Counting process. Defaults to <code>"N"</code>.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_intensity.var">Intensity.var</code></td>
<td>
<p>a character-string that is the label of the Intensity process. Defaults to <code>"lambda"</code>
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_latent.var">Latent.var</code></td>
<td>

<p>a character-string that is the label of the unobserved process. Defaults to <code>"x"</code>.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_time.var">time.var</code></td>
<td>

<p>the name of the time variable.
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_type.jump">Type.Jump</code></td>
<td>

<p>a logical value. If it is <code>TRUE</code>, the jump size is deterministic. 
</p>
</td></tr>
<tr><td><code id="setCarmaHawkes_+3A_xinexpr">XinExpr</code></td>
<td>
 
<p>a logical variable. The default value <code>XinExpr=FALSE</code> implies that the starting condition for <code>Latent.var</code> is zero. If <code>XinExpr=TRUE</code>, each component of <code>Latent.var</code> has a parameter as a initial value.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model an object of <code><a href="#topic+yuima.carmaHawkes-class">yuima.carmaHawkes-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>


<h3>References</h3>

<p>Mercuri, L., Perchiazzo, A., &amp; Rroji, E. (2022). A Hawkes model with CARMA (p, q) intensity. <a href="https://doi.org/10.48550/arXiv.2208.02659">doi:10.48550/arXiv.2208.02659</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Definition of an Hawkes with exponential Kernel
mod1 &lt;- setCarmaHawkes(p = 1, q = 0)

# Definition of an Hawkes with a CARMA(2,1) Intensity process
mod2 &lt;- setCarmaHawkes(p = 2, q = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='setCharacteristic'>
Set characteristic information and create a &lsquo;characteristic&rsquo; object.
</h2><span id='topic+setCharacteristic'></span>

<h3>Description</h3>

<p><code>setCharacteristic</code> is a constructor for <code>characteristic</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setCharacteristic(equation.number,time.scale)
</code></pre>


<h3>Arguments</h3>

  
<table role = "presentation">
<tr><td><code id="setCharacteristic_+3A_equation.number">equation.number</code></td>
<td>
<p>The number of equations modeled in <code>yuima</code> object.</p>
</td></tr>
<tr><td><code id="setCharacteristic_+3A_time.scale">time.scale</code></td>
<td>
<p>time.scale assumed in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>class <code>characteristic</code> has two slots,
<code>equation.number</code> is the number of equations handled in the yuima object, and 
<code>time.scale</code> is a hoge of  <code>characteristic</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>characteristic</code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='setCogarch'> Continuous-time GARCH (p,q) process
</h2><span id='topic+setCogarch'></span><span id='topic+Cogarch'></span><span id='topic+cogarch'></span><span id='topic+COGARCH'></span><span id='topic+CoGarch'></span>

<h3>Description</h3>

<p><code>setCogarch</code> describes the Cogarch(p,q) model introduced in Brockwell et al. (2006):
</p>
<p><code>dGt = sqrt(Vt)dZt</code>
</p>
<p><code>Vt = a0 + (a1 Yt(1) + ... + a(p) Yt(p))</code>
</p>
<p><code>dYt(1) = Yt(2) dt</code>  
</p>
<p><code>...</code>
</p>
<p><code>dYt(q-1) = Yt(q) dt</code>
</p>
<p><code>dYt(q) = (-b(q) Yt(1) - ... - b(1) Yt(q))dt + (a0 + (a1 Yt(1) + ... + a(p) Yt(p))d[ZtZt]^{q}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCogarch(p, q, ar.par = "b", ma.par = "a", loc.par = "a0", Cogarch.var = "g",
   V.var = "v", Latent.var = "y", jump.variable = "z",  time.variable = "t",
   measure = NULL, measure.type = NULL, XinExpr = FALSE, startCogarch = 0,
   work = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCogarch_+3A_p">p</code></td>
<td>
<p>a non negative integer that is the number of the moving average coefficients of the Variance process.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_q">q</code></td>
<td>
<p>a non-negative integer that indicates the number of the autoregressive  coefficients of the Variance process.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_ar.par">ar.par</code></td>
<td>
<p>a character-string that is the label of the autoregressive coefficients.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_ma.par">ma.par</code></td>
<td>
<p>a character-string that is the label of the autoregressive coefficients.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_loc.par">loc.par</code></td>
<td>
<p>the location coefficient.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_cogarch.var">Cogarch.var</code></td>
<td>
<p>a character-string that is the label of the observed cogarch process.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_v.var">V.var</code></td>
<td>
<p>a character-string that is the label of the latent variance process.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_latent.var">Latent.var</code></td>
<td>
<p>a character-string that is the label of the latent process in the state space representation for the variance process.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_jump.variable">jump.variable</code></td>
<td>
<p>the jump variable.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_time.variable">time.variable</code></td>
<td>
<p>the time variable.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_measure">measure</code></td>
<td>
<p>Levy measure of jump variables.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_measure.type">measure.type</code></td>
<td>
<p>type specification for Levy measure.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_xinexpr">XinExpr</code></td>
<td>
<p>a vector of <code>expressions</code> identyfying the starting conditions for Cogarch model.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_startcogarch">startCogarch</code></td>
<td>
<p>Start condition for the Cogarch process </p>
</td></tr>
<tr><td><code id="setCogarch_+3A_work">work</code></td>
<td>
<p> Internal Variable. In the final release this input will be removed.</p>
</td></tr>
<tr><td><code id="setCogarch_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>setCogarch</code> such as the slots of the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>We remark that <code>yuima</code> describes a Cogarch(p,q) model using the formulation proposed in Brockwell et al. (2006). This representation has the Cogarch(1,1) model introduced in Kluppelberg et al. (2004) as a special case. Indeed, by choosing <code>beta = a0 b1, eta = b1</code> and <code>phi = a1</code>, we obtain the Cogarch(1,1) model proposed in Kluppelberg et al. (2004) defined as the solution of the SDEs:
</p>
<p><code>dGt = sqrt(Vt)dZt</code>
</p>
<p><code>dVt = (beta - eta Vt) dt + phi Vt d[ZtZt]^{q}</code>
</p>
<p>Please refer to the vignettes and the examples.
</p>
<p>An object of <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code> contains:
</p>
    
<dl>
<dt><code>info</code>:</dt><dd><p>It  is an object 
of  <code><a href="#topic+cogarch.info-class">cogarch.info-class</a></code> which is a list of arguments that identifies the Cogarch(p,q) model</p>
</dd>
</dl>

<p>and the same slots in an object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> .
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There may be missing information in the model description. 
Please contribute with suggestions and fixings.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Brockwell, P., Chadraa, E. and Lindner, A. (2006)
Continuous-time GARCH processes, <em>The Annals of Applied Probability</em>, <b>16</b>, 790-826.
</p>
<p>Kluppelberg, C., Lindner, A., and Maller, R. (2004) A continuous-time GARCH process driven by a Levy process: Stationarity and second-order behaviour, <em>Journal of Applied Probability</em>, <b>41</b>, 601-622.
</p>
<p>Stefano M. Iacus, Lorenzo Mercuri, Edit Rroji (2017) COGARCH(p,q): Simulation and Inference with the yuima Package, <em>Journal of Statistical Software</em>, <b>80</b>(4), 1-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex 1. (Continuous time GARCH process driven by a compound poisson process)
prova&lt;-setCogarch(p=1,q=3,work=FALSE,
                  measure=list(intensity="1", df=list("dnorm(z, 0, 1)")),
                  measure.type="CP",
                  Cogarch.var="y",
                  V.var="v",
                  Latent.var="x")

</code></pre>

<hr>
<h2 id='setData'>
Set and access data of an object of type &quot;yuima.data&quot; or &quot;yuima&quot;.
</h2><span id='topic+setData'></span><span id='topic+get.zoo.data'></span><span id='topic+dim'></span><span id='topic+length'></span><span id='topic+cbind.yuima'></span>

<h3>Description</h3>

<p><code>setData</code> constructs an object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
<p><code>get.zoo.data</code> returns the content of the <code>zoo.data</code> slot of a
<code><a href="#topic+yuima.data-class">yuima.data-class</a></code> object. (Note: value is a <code>list</code> of 
<code><a href="zoo.html#topic+zoo">zoo</a></code> objects).
</p>
<p><code>plot</code> plot method for object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> or 
<code><a href="#topic+yuima-class">yuima-class</a></code>.
</p>
<p><code>dim</code> returns the <code><a href="#topic+dim">dim</a></code> of the <code>zoo.data</code> slot of a
<code><a href="#topic+yuima.data-class">yuima.data-class</a></code> object.
</p>
<p><code>length</code> returns the <code><a href="#topic+length">length</a></code> of the time series in 
<code>zoo.data</code> slot of a <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> object.
<code>cbind.yuima</code> bind yuima.data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setData(original.data, delta=NULL, t0=0)
  get.zoo.data(x)
</code></pre>


<h3>Arguments</h3>

  
<table role = "presentation">
<tr><td><code id="setData_+3A_original.data">original.data</code></td>
<td>
<p>some type of data, usually some sort of time series. 
The function always tries to convert to the input data into an object of
<code><a href="zoo.html#topic+zoo">zoo</a></code>-type. See Details.</p>
</td></tr>
<tr><td><code id="setData_+3A_x">x</code></td>
<td>
<p>an object of type <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> or 
<code><a href="#topic+yuima-class">yuima-class</a></code>.</p>
</td></tr>
<tr><td><code id="setData_+3A_delta">delta</code></td>
<td>
<p>If there is the need to redefine on the fly the <code>delta</code> increment of the data to make it consistent to statistical theory. See Details.</p>
</td></tr>
<tr><td><code id="setData_+3A_t0">t0</code></td>
<td>
<p>the time origin for the internal <code>zoo.data</code> slot, defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects in the  <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> contain two slots:
</p>

<dl>
<dt><code>original.data</code>:</dt><dd><p>The slot <code>original.data</code> contains, as the 
name suggests, a copy of the original data passed to the function 
<code>setData</code>. It is intended for backup purposes.</p>
</dd>
<dt><code>zoo.data</code>:</dt><dd><p>the function <code>setData</code> tries to convert 
<code>original.data</code> into an object of class <code><a href="zoo.html#topic+zoo">zoo</a></code>. The 
coerced <code><a href="zoo.html#topic+zoo">zoo</a></code> data are stored in the slot <code>zoo.data</code>.
If the conversion fails the function exits with an error.
Internally, the <span class="pkg">yuima</span> package stores and operates on  
<code><a href="zoo.html#topic+zoo">zoo</a></code>-type objects.</p>
</dd>
</dl>

<p>The function <code>get.zoo.data</code>
returns the content of the slot <code>zoo.data</code> of <code>x</code> if <code>x</code>
is of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> or the content of 
<code>x@data@zoo.data</code> if <code>x</code> is of <code><a href="#topic+yuima-class">yuima-class</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>a list of object(s) of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> for 
<code>setData</code>. 
The content of the <code>zoo.data</code>  slot for <code>get.zoo.data</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- ts(matrix(rnorm(200),100,2))
mydata &lt;- setData(X)
str(get.zoo.data(mydata))
dim(mydata)
length(mydata)
plot(mydata)

# exactly the same output
mysde &lt;- setYuima(data=setData(X))
str(get.zoo.data(mysde))
plot(mysde)
dim(mysde)
length(mysde)

# changing delta on the fly to 1/252
mysde2 &lt;- setYuima(data=setData(X, delta=1/252))
str(get.zoo.data(mysde2))
plot(mysde2)
dim(mysde2)
length(mysde2)

# changing delta on the fly to 1/252 and shifting time to t0=1
mysde2 &lt;- setYuima(data=setData(X, delta=1/252, t0=1))
str(get.zoo.data(mysde2))
plot(mysde2)
dim(mysde2)
length(mysde2)


</code></pre>

<hr>
<h2 id='setFunctional'>Description of a functional associated with a perturbed stochastic differential equation</h2><span id='topic+setFunctional'></span><span id='topic+setFunctional+2Cyuima.model-method'></span><span id='topic+setFunctional+2Cyuima-method'></span><span id='topic+getF'></span><span id='topic+getf'></span><span id='topic+getxinit'></span><span id='topic+gete'></span>

<h3>Description</h3>

<p>This function is used to give a description
of the stochastic differential equation. The functional represent the price of the option in financial economics, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFunctional(model, F, f, xinit,e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setFunctional_+3A_model">model</code></td>
<td>
<p>yuima or yuima.model object.</p>
</td></tr>
<tr><td><code id="setFunctional_+3A_f">F</code></td>
<td>
<p>function of $X_t$ and $epsilon$</p>
</td></tr>
<tr><td><code id="setFunctional_+3A_f">f</code></td>
<td>
<p>list of functions of $X_t$ and $epsilon$</p>
</td></tr>
<tr><td><code id="setFunctional_+3A_xinit">xinit</code></td>
<td>
<p>initial values of state variable.</p>
</td></tr>
<tr><td><code id="setFunctional_+3A_e">e</code></td>
<td>
<p>epsilon parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You should look at the vignette and examples. 
</p>
<p>The object foi contains several &ldquo;slots&rdquo;. To see inside its 
structure we use the <span class="rlang"><b>R</b></span> command str.
f and Fare <span class="rlang"><b>R</b></span> (list of) expressions which contains the functional of interest specification. 
e is a small parameter on which we conduct asymptotic expansion of the functional.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yuima</code></td>
<td>
<p>an object of class 'yuima' containing object of class 'functional'. If yuima object was given as 'model' argument, the result is just added and the other slots of the object are maintained.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There may be missing information in the model description.
Please contribute with suggestions and fixings.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# to the Black-Scholes economy:
# dXt^e = Xt^e * dt + e * Xt^e * dWt
diff.matrix &lt;- matrix( c("x*e"), 1,1)
model &lt;- setModel(drift = c("x"), diffusion = diff.matrix)
# call option is evaluated by averating
# max{ (1/T)*int_0^T Xt^e dt, 0}, the first argument is the functional of interest:
Terminal &lt;- 1
xinit &lt;- c(1)
f &lt;- list( c(expression(x/Terminal)), c(expression(0)))
F &lt;- 0
division &lt;- 1000
e &lt;- .3
yuima &lt;- setYuima(model = model,sampling = setSampling(Terminal = Terminal, n = division))
yuima &lt;- setFunctional( model = yuima, xinit=xinit, f=f,F=F,e=e)
# look at the model structure
str(yuima@functional)
</code></pre>

<hr>
<h2 id='setHawkes'>Constructor of Hawkes model</h2><span id='topic+setHawkes'></span>

<h3>Description</h3>

<p>'<code>setHawkes</code>' constructs an object of class <code><a href="#topic+yuima.Hawkes">yuima.Hawkes</a></code> that is a mathematical description of a multivariate Hawkes model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setHawkes(lower.var = "0", upper.var = "t", var.dt = "s",
  process = "N", dimension = 1, intensity = "lambda",
  ExpKernParm1 = "c", ExpKernParm2 = "a", const = "nu",
  measure = NULL, measure.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setHawkes_+3A_lower.var">lower.var</code></td>
<td>
<p>Lower bound in the integral</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_upper.var">upper.var</code></td>
<td>
<p>Upper bound in the integral</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_var.dt">var.dt</code></td>
<td>
<p>Time variable</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_process">process</code></td>
<td>
<p>Counting process</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_dimension">dimension</code></td>
<td>
<p>An integer that indicates the components of the counting process</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_intensity">intensity</code></td>
<td>
<p>Intensity Process</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_expkernparm1">ExpKernParm1</code></td>
<td>
<p>Kernel parameters</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_expkernparm2">ExpKernParm2</code></td>
<td>
<p>Kernel parameters</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_const">const</code></td>
<td>
<p>Constant term in the intensity process</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_measure">measure</code></td>
<td>
<p>Jump size. By default 1</p>
</td></tr>
<tr><td><code id="setHawkes_+3A_measure.type">measure.type</code></td>
<td>
<p>Type. By default <code>code</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the object is an univariate Hawkes process</p>


<h3>Value</h3>

<p>The function returns an object of class <code><a href="#topic+yuima.Hawkes">yuima.Hawkes</a></code>.</p>


<h3>Author(s)</h3>

<p>YUIMA Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Definition of an univariate hawkes model

provaHawkes2&lt;-setHawkes()
str(provaHawkes2)

# Simulation

true.par &lt;- list(nu1=0.5, c11=3.5,  a11=4.5)

simprv1 &lt;- simulate(object = provaHawkes2, true.parameter = true.par,
  sampling = setSampling(Terminal =70, n=7000))

plot(simprv1)

# Computation of intensity

lambda1 &lt;- Intensity.PPR(simprv1, param = true.par)

plot(lambda1)

# qmle

res1 &lt;- qmle(simprv1, method="Nelder-Mead", start = true.par)

summary(res1)

## End(Not run)
</code></pre>

<hr>
<h2 id='setIntegral'>Integral of Stochastic Differential Equation</h2><span id='topic+setIntegral'></span>

<h3>Description</h3>

<p>'<code>setIntegral</code>' is the constructor of an object of class <a href="#topic+yuima.Integral">yuima.Integral</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setIntegral(yuima, integrand, var.dx, lower.var, upper.var,
 out.var = "", nrow = 1, ncol = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setIntegral_+3A_yuima">yuima</code></td>
<td>

<p>an object of class <code><a href="#topic+yuima.model">yuima.model</a></code> that is the SDE.
</p>
</td></tr>
<tr><td><code id="setIntegral_+3A_integrand">integrand</code></td>
<td>

<p>A matrix or a vector of strings that describe each component of the integrand.
</p>
</td></tr>
<tr><td><code id="setIntegral_+3A_var.dx">var.dx</code></td>
<td>
<p> A label that indicates the variable of integration </p>
</td></tr>
<tr><td><code id="setIntegral_+3A_lower.var">lower.var</code></td>
<td>

<p>A label that indicates the lower variable in the support of integration, by default <code>lower.var = 0</code>.</p>
</td></tr>
<tr><td><code id="setIntegral_+3A_upper.var">upper.var</code></td>
<td>

<p>A label that indicates the upper variable in the support of integration, by default <code>upper.var = t</code>.</p>
</td></tr>
<tr><td><code id="setIntegral_+3A_out.var">out.var</code></td>
<td>

<p>Label for the output
</p>
</td></tr>
<tr><td><code id="setIntegral_+3A_nrow">nrow</code></td>
<td>

<p>Dimension of output if <code>integrand</code> is a vector of string.
</p>
</td></tr>
<tr><td><code id="setIntegral_+3A_ncol">ncol</code></td>
<td>
<p>Dimension of output if <code>integrand</code> is a vector of string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The constructor returns an object of class <code><a href="#topic+yuima.Integral">yuima.Integral</a></code>.</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Yuima Documentation</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Definition Model

Mod1&lt;-setModel(drift=c("a1"), diffusion = matrix(c("s1"),1,1),
  solve.variable = c("X"), time.variable = "s")

# In this example we define an integral of SDE such as
# \[
# I=\int^{t}_{0} b*exp(-a*(t-s))*(X_s-a1*s)dX_s
# \]

integ &lt;- matrix("b*exp(-a*(t-s))*(X-a1*s)",1,1)

Integral &lt;- setIntegral(yuima = Mod1,integrand = integ,
  var.dx = "X", lower.var = "0", upper.var = "t",
  out.var = "", nrow =1 ,ncol=1)

# Structure of slots

is(Integral)
# Function h in the above definition
Integral@Integral@Integrand@IntegrandList
# Dimension of Intgrand
Integral@Integral@Integrand@dimIntegrand

# all parameters are $\left(b,a,a1,s1\right)$
Integral@Integral@param.Integral@allparam

# the parameters in the integrand are $\left(b,a,a1\right)$ \newline
Integral@Integral@param.Integral@Integrandparam

# common parameters are $a1$
Integral@Integral@param.Integral@common

# integral variable dX_s
Integral@Integral@variable.Integral@var.dx
Integral@Integral@variable.Integral@var.time

# lower and upper vars
Integral@Integral@variable.Integral@lower.var
Integral@Integral@variable.Integral@upper.var


## End(Not run)
</code></pre>

<hr>
<h2 id='setLaw'>Random variable constructor </h2><span id='topic+setLaw'></span>

<h3>Description</h3>

<p>Constructor of a random variable</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLaw(rng = function(n, ...) {
    NULL
}, density = function(x, ...) {
    NULL
}, cdf = function(q, ...) {
    NULL
}, quant = function(p, ...) {
    NULL
}, characteristic = function(u, ...) {
    NULL
}, time.var = "t", dim = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLaw_+3A_rng">rng</code></td>
<td>

<p>function</p>
</td></tr>
<tr><td><code id="setLaw_+3A_density">density</code></td>
<td>

<p>function</p>
</td></tr>
<tr><td><code id="setLaw_+3A_cdf">cdf</code></td>
<td>

<p>function</p>
</td></tr>
<tr><td><code id="setLaw_+3A_characteristic">characteristic</code></td>
<td>

<p>function</p>
</td></tr>
<tr><td><code id="setLaw_+3A_quant">quant</code></td>
<td>

<p>function</p>
</td></tr>
<tr><td><code id="setLaw_+3A_time.var">time.var</code></td>
<td>

<p>label</p>
</td></tr>
<tr><td><code id="setLaw_+3A_dim">dim</code></td>
<td>

<p>label</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Insert additional info</p>


<h3>Value</h3>

<p>object of class yuima.law</p>


<h3>Note</h3>

<p>Insert additional info</p>


<h3>Author(s)</h3>

<p>YUIMA TEAM</p>

<hr>
<h2 id='setLaw_th'>
Constructior of a t-Levy process.
</h2><span id='topic+setLaw_th'></span>

<h3>Description</h3>

<p><code>setLaw_th</code> constructs an object of class <code><a href="#topic+yuima.th-class">yuima.th-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLaw_th(h = 1, method = "LAG", up = 7, low = -7, N = 180, 
N_grid = 1000, regular_par = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLaw_th_+3A_h">h</code></td>
<td>

<p>a numeric object that is the time of the intervals
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_method">method</code></td>
<td>

<p>Method for the inversion of the characteristic function. Three methods are available: <code>cos</code>, <code>LAG</code>, and <code>FFT</code>. 
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_up">up</code></td>
<td>

<p>Upper bound for the integration support.
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_low">low</code></td>
<td>

<p>Lower bound for the integration support.
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_n">N</code></td>
<td>

<p>Integration grid.
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_n_grid">N_grid</code></td>
<td>

<p>Number of points in the support.
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_regular_par">regular_par</code></td>
<td>

<p>A scalar for controlling the Gibbs effect for the inversion of the characteristic function
</p>
</td></tr>
<tr><td><code id="setLaw_th_+3A_...">...</code></td>
<td>

<p>Additional arguments. See <code><a href="#topic+setLaw">setLaw</a></code> for more details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code><a href="#topic+yuima.th-class">yuima.th-class</a></code>.</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='setLRM'>
A constructor of a t-Student Regression Model.
</h2><span id='topic+setLRM'></span>

<h3>Description</h3>

<p>This function returns an object of <code><a href="#topic+yuima.LevyRM-class">yuima.LevyRM-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLRM(unit_Levy, yuima_regressors, LevyRM = "Y", coeff = c("mu", "sigma0"), 
data = NULL, sampling = NULL, characteristic = NULL, functional = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setLRM_+3A_unit_levy">unit_Levy</code></td>
<td>
<p>An object of <code><a href="#topic+yuima.th-class">yuima.th-class</a></code> that describes the t - noise in the regression model.
</p>
</td></tr>
<tr><td><code id="setLRM_+3A_yuima_regressors">yuima_regressors</code></td>
<td>
<p>An object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> that represents the regressors.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_levyrm">LevyRM</code></td>
<td>
<p>The label of the output variable. Default <code>'Y'</code>.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_coeff">coeff</code></td>
<td>
<p>Labels for the regressor coefficients and the scale parameter.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_data">data</code></td>
<td>
<p>An object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> that contains simulated or real data.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_sampling">sampling</code></td>
<td>
<p>An object of <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code>.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_characteristic">characteristic</code></td>
<td>
<p>An object of <code><a href="#topic+yuima.characteristic-class">yuima.characteristic-class</a></code>.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_functional">functional</code></td>
<td>
<p>An object of class <code><a href="#topic+yuima.functional-class">yuima.functional-class</a></code>.</p>
</td></tr>
<tr><td><code id="setLRM_+3A_...">...</code></td>
<td>
<p>Additional arguments. See <code><a href="#topic+setYuima">setYuima</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="#topic+yuima.LevyRM-class">yuima.LevyRM-class</a>.</code>
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='setMap'>
Map of a Stochastic Differential Equation
</h2><span id='topic+setMap'></span><span id='topic+Map+20of+20SDE'></span><span id='topic+Map+20of+20yuima'></span>

<h3>Description</h3>

<p>'<code>setMap</code>' is the constructor of an object of class <code><a href="#topic+yuima.Map">yuima.Map</a></code> that describes a map of a SDE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMap(func, yuima, out.var = "", nrow = 1, ncol = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setMap_+3A_func">func</code></td>
<td>
<p>a matrix or a vector of strings that describe each component of the map.</p>
</td></tr>
<tr><td><code id="setMap_+3A_yuima">yuima</code></td>
<td>
<p> an object of class <code><a href="#topic+yuima.model">yuima.model</a></code> that is the SDE.</p>
</td></tr>
<tr><td><code id="setMap_+3A_out.var">out.var</code></td>
<td>
<p> label for the output</p>
</td></tr>
<tr><td><code id="setMap_+3A_nrow">nrow</code></td>
<td>
<p> dimension of Map if <code>func</code> is a vector of string. </p>
</td></tr>
<tr><td><code id="setMap_+3A_ncol">ncol</code></td>
<td>
<p> dimension of output if <code>func</code> is a vector of string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The constructor returns an object of class <code><a href="#topic+yuima.Map">yuima.Map</a></code>.</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>References</h3>

<p>Yuima Documentation</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Definition of a yuima model
mod &lt;- setModel(drift=c("a1", "a2"),
  diffusion = matrix(c("s1","0","0","s2"),2,2),
  solve.variable = c("X","Y"))

# Definition of a map
my.Map &lt;- matrix(c("(X+Y)","-X-Y",
  "a*exp(X-a1*t)","b*exp(Y-a2*t)"),
  nrow=2,ncol=2)

# Construction of yuima.Map

yuimaMap &lt;- setMap(func = my.Map, yuima = mod,
  out.var = c("f11","f21","f12","f22"))

# Simulation of a Map

set.seed(123)
samp &lt;- setSampling(0, 100,n = 1000)
mypar &lt;- list(a=1, b=1, s1=0.1, s2=0.2, a1=0.1, a2=0.1)
sim1 &lt;- simulate(object = yuimaMap, true.parameter = mypar,
  sampling = samp)

# plot

plot(sim1, ylab = yuimaMap@Output@param@out.var,
  main = "simulation Map", cex.main = 0.8)


## End(Not run)

</code></pre>

<hr>
<h2 id='setModel'>
Basic description of stochastic differential equations (SDE)
</h2><span id='topic+setModel'></span>

<h3>Description</h3>

<p>'setModel' gives a description of 
stochastic differential equation with or without jumps of the following
form:
</p>
<p><code>dXt = a(t,Xt, alpha)dt + b(t,Xt,beta)dWt + c(t,Xt,gamma)dZt,  X0=x0</code>  
</p>
<p>All functions relying on the <span class="pkg">yuima</span> 
package will get as much information as possible 
from the different slots of the <code><a href="#topic+yuima-class">yuima-class</a></code> structure
without replicating the same code twice. 
If there are missing pieces of information, some default values 
can be assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setModel(drift = NULL, diffusion = NULL, hurst = 0.5, jump.coeff = NULL,
measure = list(), measure.type = character(), state.variable = "x",
jump.variable = "z", time.variable = "t", solve.variable, xinit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setModel_+3A_drift">drift</code></td>
<td>
<p>a vector of <code>expression</code>s (the default value is 0 when 
<code>drift=NULL</code>).</p>
</td></tr>
<tr><td><code id="setModel_+3A_diffusion">diffusion</code></td>
<td>
<p>a matrix of <code>expression</code>s (the default value is 0 when
<code>diffusion=NULL</code>).</p>
</td></tr>
<tr><td><code id="setModel_+3A_hurst">hurst</code></td>
<td>
<p>the Hurst parameter of the gaussian noise. If <code>h=0.5</code>, the default,
the process is Wiener otherwise it is fractional Brownian motion with that precise value
of the Hurst index. Can be set to <code>NA</code> for further specification.</p>
</td></tr>
<tr><td><code id="setModel_+3A_jump.coeff">jump.coeff</code></td>
<td>
<p>a matrix of <code>expression</code>s for the jump component.</p>
</td></tr>
<tr><td><code id="setModel_+3A_measure">measure</code></td>
<td>
<p>Levy measure for jump variables.</p>
</td></tr>
<tr><td><code id="setModel_+3A_measure.type">measure.type</code></td>
<td>
<p>type specification for Levy measures.</p>
</td></tr>
<tr><td><code id="setModel_+3A_state.variable">state.variable</code></td>
<td>
<p>a vector of names of the state variables in the drift 
and diffusion coefficients.</p>
</td></tr>
<tr><td><code id="setModel_+3A_jump.variable">jump.variable</code></td>
<td>
<p>a vector of names of the jump variables in the jump 
coefficient.</p>
</td></tr>
<tr><td><code id="setModel_+3A_time.variable">time.variable</code></td>
<td>
<p>the name of the time variable.</p>
</td></tr>  
<tr><td><code id="setModel_+3A_solve.variable">solve.variable</code></td>
<td>
<p>a vector of names of the variables in the left-hand-side 
of the equations in the model; <code>solve.variable</code> equals 
<code>state.variable</code> as long as we have no exogenous variable other than 
statistical parameters in the coefficients (<code>drift</code> and
<code>diffusion</code>).</p>
</td></tr>  
<tr><td><code id="setModel_+3A_xinit">xinit</code></td>
<td>
<p>a vector of numbers identifying the initial value of the 
<code>solve.variable</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to the vignettes and the examples or to the <span class="pkg">yuimadocs</span>
package.
</p>
<p>An object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> contains several slots:
</p>
		
<dl>
<dt><code>drift</code>:</dt><dd><p>an <span class="rlang"><b>R</b></span> expression which specifies the drift coefficient 
(a vector).</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>an <span class="rlang"><b>R</b></span> expression which specifies the diffusion 
coefficient (a matrix).</p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>coefficient of the jump term.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>the Levy measure of the driving Levy process.</p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>specifies the type of the measure, such as 
<code>CP</code>, <code>code</code> or <code>density</code>. See below.</p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>a short name for &ldquo;parameters&rdquo;. It  is an object 
of  <code><a href="#topic+model.parameter-class">model.parameter-class</a></code> which is a list of vectors of 
names of parameters belonging to the single components of the model (drift, 
diffusion, jump and measure), the names of common parameters and the names 
of all parameters. For more details see <code><a href="#topic+model.parameter-class">model.parameter-class</a></code> 
documentation page.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>a vector of variable names, each element 
corresponds to the name of the solution variable (left-hand-side) of each 
equation in the model, in the corresponding order.</p>
</dd>	  
<dt><code>state.variable</code>:</dt><dd><p>identifies the state variables in the <span class="rlang"><b>R</b></span> 
expression. By default, it is assumed to be <code>x</code>.</p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>the variable for the jump coefficient. By default,
it is assumed to be <code>z</code>.</p>
</dd>
<dt><code>time</code>:</dt><dd><p>the time variable. By default, it is assumed to be <code>t</code>.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>used to identify the solution variables in the
<span class="rlang"><b>R</b></span> expression, i.e. the variable with respect to which the stochastic 
differential equation has to be solved. By default, it is assumed to be 
<code>x</code>, otherwise the user can choose any other model specification.</p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>denotes the number of sources of noise. Currently 
only for the Gaussian part.</p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>denotes the dimension of the stochastic 
differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the dimensions of the parameters in the 
<code>parameter</code> slot.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>denotes the initial value of the stochastic differential 
equation.</p>
</dd>
</dl>

<p>The <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> structure assumes that the user either uses the default
names for <code>state.variable</code>, <code>jump.variable</code>, <code>solution.variable</code> and 
<code>time.variable</code> or specifies his/her own names. 
All the rest of the terms in the <span class="rlang"><b>R</b></span> expressions are considered as parameters 
and identified accordingly in the <code>parameter</code> slot.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There may be missing information in the model description. 
Please contribute with suggestions and fixings.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ex 1. (One-dimensional diffusion process)
# To describe
# dXt = -3*Xt*dt + (1/(1+Xt^2+t))dWt,
# we set
mod1 &lt;- setModel(drift = "-3*x", diffusion = "1/(1+x^2+t)", solve.variable = c("x"))
# We may omit the solve.variable; then the default variable x is used
mod1 &lt;- setModel(drift = "-3*x", diffusion = "1/(1+x^2+t)")
# Look at the model structure by
str(mod1)

# Ex 2. (Two-dimensional diffusion process with three factors)
# To describe
# dX1t = -3*X1t*dt + dW1t +X2t*dW3t,
# dX2t = -(X1t + 2*X2t)*dt + X1t*dW1t + 3*dW2t,
# we set the drift coefficient
a &lt;- c("-3*x1","-x1-2*x2")
# and also the diffusion coefficient
b &lt;- matrix(c("1","x1","0","3","x2","0"),2,3)
# Then set
mod2 &lt;- setModel(drift = a, diffusion = b, solve.variable = c("x1","x2"))
# Look at the model structure by
str(mod2)
# The noise.number is automatically determined by inputting the diffusion matrix expression.
# If the dimensions of the drift differs from the number of the rows of the diffusion, 
# the error message is returned.

# Ex 3. (Process with jumps (compound Poisson process))
# To describe
# dXt = -theta*Xt*dt+sigma*dZt
mod3 &lt;- setModel(drift=c("-theta*x"), diffusion="sigma",
jump.coeff="1", measure=list(intensity="1", df=list("dnorm(z, 0, 1)")),
measure.type="CP", solve.variable="x")
# Look at the model structure by
str(mod3)

# Ex 4. (Process with jumps (stable process))
# To describe
# dXt = -theta*Xt*dt+sigma*dZt
mod4 &lt;- setModel(drift=c("-theta*x"), diffusion="sigma",
jump.coeff="1", measure.type="code",measure=list(df="rstable(z,1,0,1,0)"), solve.variable="x")
# Look at the model structure by
str(mod4)
# See rng about other candidate of Levy noises.

# Ex 5. (Two-dimensional stochastic differenatial equation with Levy noise)
# To describe
# dX1t = (1 - X1t - X2t)*dt+dZ1t 
# dX2t = (0.5 - X1t - X2t)*dt+dZ2t
beta&lt;-c(.5,.5)
mu&lt;-c(0,0)
Lambda&lt;-matrix(c(1,0,0,1),2,2)
mod5 &lt;- setModel(drift=c("1 - x1-x2",".5 - x1-x2"), 
solve.variable=c("x1","x2"), jump.coeff=Lambda, measure.type="code",
measure=list(df="rNIG(z, alpha, beta, delta0, mu, Lambda)"))
# Look at the model structure by
str(mod5)

# Ex 6. (Process with fractional Gaussian noise)
# dYt = 3*Yt*dt + dWt^h
mod6 &lt;- setModel(drift="3*y", diffusion=1, hurst=0.3, solve.variable=c("y"))
# Look at the model structure by
str(mod6)
</code></pre>

<hr>
<h2 id='setPoisson'>
Basic constructor for Compound Poisson processes
</h2><span id='topic+setPoisson'></span>

<h3>Description</h3>

<p>'setPoisson' construct a Compound Poisson model specification for a process of the form:
</p>
<p><code>Mt = m0+sum_{i=0}^Nt c*Y_{tau_i},  M0=m0</code>
</p>
<p>where Nt is a homogeneous or time-inhomogeneous Poisson process, tau_i is the
sequence of random times of Nt and Y is a sequence of i.i.d. random jumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPoisson(intensity = 1, df = NULL, scale = 1, dimension=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPoisson_+3A_intensity">intensity</code></td>
<td>
<p>either and expression or a numerical value representing the intensity function of the Poisson process Nt.</p>
</td></tr>
<tr><td><code id="setPoisson_+3A_df">df</code></td>
<td>
<p>is the density of jump random variables Y.</p>
</td></tr>
<tr><td><code id="setPoisson_+3A_scale">scale</code></td>
<td>
<p>this is the scaling factor <code>c</code>.</p>
</td></tr>
<tr><td><code id="setPoisson_+3A_dimension">dimension</code></td>
<td>
<p>this is the dimension of the jump component.</p>
</td></tr>
<tr><td><code id="setPoisson_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+setModel">setModel</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> where the <code>model</code> slot is of class <code>yuima.poisson-class</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Terminal &lt;- 10
samp &lt;- setSampling(T=Terminal,n=1000)

# Ex 1. (Simple homogeneous Poisson process)
mod1 &lt;- setPoisson(intensity="lambda", df=list("dconst(z,1)"))
set.seed(123)
y1 &lt;- simulate(mod1, true.par=list(lambda=1),sampling=samp)
plot(y1)

# scaling the jumps
mod2 &lt;- setPoisson(intensity="lambda", df=list("dconst(z,1)"),scale=5)
set.seed(123)
y2 &lt;- simulate(mod2, true.par=list(lambda=1),sampling=samp)
plot(y2)

# scaling the jumps through the constant distribution
mod3 &lt;- setPoisson(intensity="lambda", df=list("dconst(z,5)"))
set.seed(123)
y3 &lt;- simulate(mod3, true.par=list(lambda=1),sampling=samp)
plot(y3)

# Ex 2. (Time inhomogeneous Poisson process)
mod4 &lt;- setPoisson(intensity="beta*(1+sin(lambda*t))", df=list("dconst(z,1)"))
set.seed(123)
lambda &lt;- 3
beta &lt;- 5
y4 &lt;- simulate(mod4, true.par=list(lambda=lambda,beta=beta),sampling=samp)
par(mfrow=c(2,1))
par(mar=c(3,3,1,1))
plot(y4)
f &lt;- function(t) beta*(1+sin(lambda*t))
curve(f, 0, Terminal, col="red")

# Ex 2. (Time inhomogeneous Compound Poisson process with Gaussian Jumps)
mod5 &lt;- setPoisson(intensity="beta*(1+sin(lambda*t))", df=list("dnorm(z,mu,sigma)"))
set.seed(123)
y5 &lt;- simulate(mod5, true.par=list(lambda=lambda,beta=beta,mu=0, sigma=2),sampling=samp)
plot(y5)
f &lt;- function(t)  beta*(1+sin(lambda*t))
curve(f, 0, Terminal, col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='setPPR'>Point Process</h2><span id='topic+setPPR'></span>

<h3>Description</h3>

<p>Constructor of a Point Process Regression Model</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPPR(yuima, counting.var = "N", gFun, Kernel,
  var.dx = "s", var.dt = "s", lambda.var = "lambda",
  lower.var = "0", upper.var = "t", nrow = 1, ncol = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPPR_+3A_yuima">yuima</code></td>
<td>
<p>an object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> that describes the mathematical features of counting and covariates processes <code>Y[t]=(X[t],N[t])</code>.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_counting.var">counting.var</code></td>
<td>
<p>a label denoting the name of the counting process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_gfun">gFun</code></td>
<td>
<p>a vector string that is the mathematical expression of the vector function <code>g(t,Y[t-],theta)</code> in the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_kernel">Kernel</code></td>
<td>
<p>a matrix string that is the kernel <code>kappa(t-s,Y[s],theta)</code> in the definition of the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_var.dx">var.dx</code></td>
<td>
<p>a string denoting the integration variable in the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_var.dt">var.dt</code></td>
<td>
<p>a string denoting the integration time variable in the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_lambda.var">lambda.var</code></td>
<td>
<p>name of the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_lower.var">lower.var</code></td>
<td>
<p>Lower bound of the support for the integral in the definition of the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_upper.var">upper.var</code></td>
<td>
<p>Upper bound of the support for the integral in the definition of the intensity process.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in the kernel.</p>
</td></tr>
<tr><td><code id="setPPR_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in the kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="#topic+yuima.PPR">yuima.PPR</a></code></p>


<h3>Note</h3>

<p>There may be missing information in the model description. Please contribute with suggestions and fixings.</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a></p>


<h3>References</h3>

<p>Insert Here References</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Hawkes process with power law kernel

# I. Law Definition:
my.rHwk2 &lt;- function(n){
  as.matrix(rep(1,n))
  }
Law.Hwk2 &lt;- setLaw(rng = my.rHwk2, dim = 1)

# II. Definition of the counting process N_t
mod.Hwk2 &lt;- setModel(drift = c("0"), diffusion = matrix("0",1,1),
  jump.coeff = matrix(c("1"),1,1), measure = list(df = Law.Hwk2),
  measure.type = "code", solve.variable = c("N"),
  xinit=c("0"))

# III. Definition of g() and kappa()
g.Hwk2 &lt;- "mu"
Kern.Hwk2 &lt;- "alpha/(1+(t-s))^beta"

# IV. Construction of an yuima.PPR object
PPR.Hwk2 &lt;- setPPR(yuima = mod.Hwk2, gFun=g.Hwk2,
  Kernel = as.matrix(Kern.Hwk2),var.dx = "N")

## End(Not run)
</code></pre>

<hr>
<h2 id='setSampling'>
Set sampling information and create a &lsquo;sampling&rsquo; object.
</h2><span id='topic+setSampling'></span>

<h3>Description</h3>

<p><code>setSampling</code> is a constructor for <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  setSampling(Initial = 0, Terminal = 1, n = 100, delta, 
   grid, random = FALSE, sdelta=as.numeric(NULL), 
   sgrid=as.numeric(NULL), interpolation="pt" )
</code></pre>


<h3>Arguments</h3>

  
<table role = "presentation">
<tr><td><code id="setSampling_+3A_initial">Initial</code></td>
<td>
<p>Initial time of the grid.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_terminal">Terminal</code></td>
<td>
<p>Terminal time of the grid.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_n">n</code></td>
<td>
<p>number of time intervals.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_delta">delta</code></td>
<td>
<p>mesh size in case of regular time grid.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_grid">grid</code></td>
<td>
<p>a grid of times for the simulation, possibly empty.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_random">random</code></td>
<td>
<p>specify if it is random sampling. See Details.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_sdelta">sdelta</code></td>
<td>
<p>mesh size in case of regular space grid.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_sgrid">sgrid</code></td>
<td>
<p>a grid in space for the simulation, possibly empty.</p>
</td></tr>
<tr><td><code id="setSampling_+3A_interpolation">interpolation</code></td>
<td>
<p>a rule of interpolation in case of subsampling. 
By default, the previous tick interpolation. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates an object of type 
<code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code> with several slots.
</p>

<dl>
<dt><code>Initial</code>:</dt><dd><p>initial time of the grid.</p>
</dd>
<dt><code>Terminal</code>:</dt><dd><p>terminal time fo the grid.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>the number of observations - 1.</p>
</dd>
<dt><code>delta</code>:</dt><dd><p>in case of a regular time grid it is the mesh.</p>
</dd>
<dt><code>grid</code>:</dt><dd><p>the grid of times.</p>
</dd>
<dt><code>random</code>:</dt><dd><p>either <code>FALSE</code> or the distribution 
of the random times.</p>
</dd>
<dt><code>regular</code>:</dt><dd><p>indicator of whether the grid is regular or not.
For internal use only.</p>
</dd>
<dt><code>sdelta</code>:</dt><dd><p>in case of a regular space grid it is the mesh.</p>
</dd>
<dt><code>sgrid</code>:</dt><dd><p>the grid in space.</p>
</dd>
<dt><code>oindex</code>:</dt><dd><p>in case of interpolation, a vector of indexes 
corresponding to the original observations used for the approximation.</p>
</dd>
<dt><code>interpolation</code>:</dt><dd><p>the name of the interpolation method used.</p>
</dd>
</dl>

<p>In case of subsampling, the observations are subsampled on some given 
<code>grid</code>/<code>sgrid</code> or according to some <code>random</code> times. When 
the original observations do not exist at a give point of the grid they are
obtained by some approximation method. Available methods are <code>"pt"</code> or
<code>"previous tick"</code> observation method, <code>"nt"</code> or <code>"next tick"</code> 
observation method, or by l<code>"linear"</code> interpolation.
In case of interpolation, the slot <code>oindex</code> contains the vector of indexes 
corresponding to the original observations used for the approximation. For the
linear method the index corresponds to the left-most observation.
</p>
<p>The slot <code>random</code> is used as information in case a <code>grid</code> is
already determined (e.g. <code>n</code> or <code>delta</code>, etc. ot the <code>grid</code>
itself are given) or if some subsampling has occurred or if some particular
method which causes a random grid is used in simulation (for example the
space discretized Euler scheme). The slot <code>random</code> contains a list
of two elements <code>distr</code> and <code>scale</code>, where <code>distr</code> is a
the distribution of independent random times and <code>scale</code> is either a 
scaling constant or a scaling function.
If the <code>grid</code> of times is deterministic, then <code>random</code> is <code>FALSE</code>.
</p>
<p>If not specified and <code>random=FALSE</code>, the slot <code>grid</code> is filled 
automatically by the function. It is eventually modified or created
after the call to the function <code><a href="#topic+simulate">simulate</a></code>.
</p>
<p>If <code>delta</code> is not specified, it is calculated as <code>(Terminal-Initial)/n)</code>.
If <code>delta</code> is specified, the <code>Terminal</code> is adjusted to be equal to
<code>Initial+n*delta</code>.
</p>
<p>The vectors <code>delta</code>, <code>n</code>, <code>Initial</code> and <code>Terminal</code> may
have different lengths, but then they are extended to the maximal length to
keep consistency. See examples.
</p>
<p>If <code>grid</code> is specified, it takes precedence over all other arguments.
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>samp &lt;- setSampling(Terminal=1, n=1000)
str(samp)

samp &lt;- setSampling(Terminal=1, n=1000, delta=0.3)
str(samp)


samp &lt;- setSampling(Terminal=1, n=1000, delta=c(0.1,0.3))
str(samp)

samp &lt;- setSampling(Terminal=1:3, n=1000)
str(samp)
</code></pre>

<hr>
<h2 id='setYuima'>
Creates a &quot;yuima&quot; object by combining &quot;model&quot;, &quot;data&quot;, &quot;sampling&quot;, &quot;characteristic&quot; 
and &quot;functional&quot;slots.
</h2><span id='topic+setYuima'></span>

<h3>Description</h3>

<p><code>setYuima</code> constructs an object of  <code><a href="#topic+yuima-class">yuima-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setYuima(data, model, sampling, characteristic, functional)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setYuima_+3A_data">data</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.</p>
</td></tr>
<tr><td><code id="setYuima_+3A_model">model</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.</p>
</td></tr>
<tr><td><code id="setYuima_+3A_sampling">sampling</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code>.</p>
</td></tr>
<tr><td><code id="setYuima_+3A_characteristic">characteristic</code></td>
<td>
<p>an object of  <code><a href="#topic+yuima.characteristic-class">yuima.characteristic-class</a></code>.</p>
</td></tr>
<tr><td><code id="setYuima_+3A_functional">functional</code></td>
<td>
<p>an object of class <code><a href="#topic+yuima.functional-class">yuima.functional-class</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>yuima-class</code> object is the main object of the <span class="pkg">yuima</span> package.
Some of the slots can be missing. 
</p>
<p>The slot <code>data</code>  contains the data, either empirical or simulated. 
</p>
<p>The slot <code>model</code>  contains the description of the 
(statistical) model which is used to generate the <code>data</code> via different 
simulation schemes, to draw inference from the <code>data</code> or both.
</p>
<p>The <code>sampling</code> slot contains information on how the <code>data</code> have been
collected or how they should be simulated.
</p>
<p>The slot <code>characteristic</code> contains information on <code>PLEASE FINISH THIS</code>.
The slot <code>functional</code> contains information on <code>PLEASE FINISH THIS</code>.
</p>
<p>Please refer to the vignettes and the examples in the <span class="pkg">yuimadocs</span>
package for more informations.
</p>


<h3>Value</h3>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code>.
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of a yuima object with all slots for a 
# stochastic differential equation
# dXt^e = -theta2 * Xt^e * dt + theta1 * dWt 
diffusion &lt;- matrix(c("theta1"), 1, 1)
drift &lt;- c("-1*theta2*x")
ymodel &lt;- setModel(drift=drift, diffusion=diffusion)
n &lt;- 100
ysamp &lt;- setSampling(Terminal=1, n=n)

yuima &lt;- setYuima(model=ymodel, sampling=ysamp)

str(yuima)
</code></pre>

<hr>
<h2 id='simBmllag'>
Simulation of increments of bivariate Brownian motions with multi-scale lead-lag relationships 
</h2><span id='topic+simBmllag'></span><span id='topic+simBmllag.coef'></span>

<h3>Description</h3>

<p>This function simulates increments of bivariate Brownian motions with multi-scale lead-lag relationships introduced in Hayashi and Koike (2018a) by the multi-dimensional circulant embedding method of Chan and Wood (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simBmllag(n, J, rho, theta, delta = 1/2^(J + 1), imaginary = FALSE)
simBmllag.coef(n, J, rho, theta, delta = 1/2^(J + 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simBmllag_+3A_n">n</code></td>
<td>

<p>the number of increments to be simulated.
</p>
</td></tr>
<tr><td><code id="simBmllag_+3A_j">J</code></td>
<td>

<p>a positive integer to determine the finest time resolution: <code>2^(-J-1)</code> is regarded as the finest time resolution.
</p>
</td></tr>
<tr><td><code id="simBmllag_+3A_rho">rho</code></td>
<td>

<p>a vector of scale-by-scale correlation coefficients. If <code>length(rho) &lt; J</code>, zeros are appended to make the length equal to <code>J</code>.
</p>
</td></tr>
<tr><td><code id="simBmllag_+3A_theta">theta</code></td>
<td>

<p>a vector of scale-by-scale lead-lag parameters. If <code>length(theta) &lt; J</code>, zeros are appended to make the length equal to <code>J</code>.
</p>
</td></tr>
<tr><td><code id="simBmllag_+3A_delta">delta</code></td>
<td>

<p>the step size of time increments. This must be smaller than or equal to <code>2^(-J-1)</code>. 
</p>
</td></tr>
<tr><td><code id="simBmllag_+3A_imaginary">imaginary</code></td>
<td>

<p>logical. 
See &lsquo;Details&rsquo;. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">B(t)</code> be a bivariate Gaussian process with stationary increments such that its marginal processes are standard Brownian motions and its cross-spectral density is given by Eq.(14) of Hayashi and Koike (2018a). The function <code>simBmllag</code> simulates the increments <code class="reqn">B(i\delta)-B((i-1)\delta)</code>, <code class="reqn">i=1,\dots,n</code>. The parameters <code class="reqn">R_j</code> and <code class="reqn">theta_j</code> in Eq.(14) of Hayashi and Koike (2018a) are specified by <code>rho</code> and <code>theta</code>, while <code class="reqn">\delta</code> and <code class="reqn">n</code> are specified by <code>delta</code> and <code>n</code>, respecitively. 
</p>
<p>Simulation is implemented by the multi-dimensional circulant embedding algorithm of Chan and Wood (1999). The last step of this algorithm returns a bivariate complex-valued sequence whose real and imaginary parts are independent and has the same law as <code class="reqn">B(k\delta)-B((k-1)\delta)</code>, <code class="reqn">k=1,\dots,n</code>; see Step 3 of Chan and Wood (1999, Section 3.2). 
If <code>imaginary = TRUE</code>, the function <code>simBmllag</code> directly returns this bivariate complex-valued sequence, so we obtain two sets of simulated increments of <code class="reqn">B(t)</code> by taking its real and complex parts. If <code>imaginary = FALSE</code> (default), the function returns only the real part of this sequence, so we directly obtain simulated increments of <code class="reqn">B(t)</code>. 
</p>
<p>The function <code>simBmllag.coef</code> is internally used to compute the sequence of coefficient matrices <code class="reqn">R(k)\Lambda(k)^{1/2}</code> in Step 2 of Chan and Wood (1999, Section 3.2). This procedure can be implemented before generating random numbers. 
Since this step typically takes the most computational cost, this function is useful to reduce computational time when we conduct a Monte Carlo simulation for <code class="reqn">(B(k\delta)-B((k-1)\delta))_{k=1}^n</code> with a fixed set of parameters. See &lsquo;Examples&rsquo; for how to use this function to simulate <code class="reqn">(B(k\delta)-B((k-1)\delta))_{k=1}^n</code>.
</p>


<h3>Value</h3>

<p><code>simBmllag</code> returns a <code>n</code> x 2 matrix if <code>imaginary = FALSE</code> (default). Otherwise, <code>simBmllag</code> returns a complex-valued <code>n</code> x 2 matrix. 
</p>
<p><code>simBmllag.coef</code> returns a complex-valued <code class="reqn">m</code> x 2 x 2 array, where <code class="reqn">m</code> is an integer determined by the rule described at the end of Chan and Wood (1999, Section 2.3). 
</p>


<h3>Note</h3>

<p>There are typos in the first and second displayed equations in page 1221 of Hayashi and Koike (2018a): The <code class="reqn">j</code>-th summands on their right hand sides should be multiplied by <code class="reqn">2^j</code>.
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA project Team
</p>


<h3>References</h3>

<p>Chan, G. and Wood, A. T. A. (1999).
Simulation of stationary Gaussian vector fields,
<em>Statistics and Computing</em>, <b>9</b>, 265&ndash;268.
</p>
<p>Hayashi, T. and Koike, Y. (2018a).
Wavelet-based methods for high-frequency lead-lag analysis,
<em>SIAM Journal of Financial Mathematics</em>, <b>9</b>, 1208&ndash;1248.
</p>
<p>Hayashi, T. and Koike, Y. (2018b). 
Multi-scale analysis of lead-lag relationships in high-frequency financial markets. 
<a href="https://doi.org/10.48550/arXiv.1708.03992">doi:10.48550/arXiv.1708.03992</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wllag">wllag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1 
## Simulation setting of Hayashi and Koike (2018a, Section 4).

n &lt;- 15000
J &lt;- 13

rho &lt;- c(0.3,0.5,0.7,0.5,0.5,0.5,0.5,0.5)
theta &lt;- c(-1,-1, -2, -2, -3, -5, -7, -10)/2^(J + 1)

set.seed(123)

dB &lt;- simBmllag(n, J, rho, theta)
str(dB)
n/2^(J + 1) # about 0.9155
sum(dB[ ,1]^2) # should be close to n/2^(J + 1)
sum(dB[ ,2]^2) # should be close to n/2^(J + 1)

# Plot the sample path of the process
B &lt;- apply(dB, 2, "diffinv") # construct the sample path
Time &lt;- seq(0, by = 1/2^(J+1), length.out = n) # Time index
plot(zoo(B, Time), main = "Sample path of B(t)")

# Using simBmllag.coef to implement the same simulation
a &lt;- simBmllag.coef(n, J, rho, theta)
m &lt;- dim(a)[1]

set.seed(123)

z1 &lt;- rnorm(m) + 1i * rnorm(m)
z2 &lt;- rnorm(m) + 1i * rnorm(m)
y1 &lt;- a[ ,1,1] * z1 + a[ ,1,2] * z2
y2 &lt;- a[ ,2,1] * z1 + a[ ,2,2] * z2
dW &lt;- mvfft(cbind(y1, y2))[1:n, ]/sqrt(m)
dB2 &lt;- Re(dW)

plot(diff(dB - dB2)) # identically equal to zero


## Example 2
## Simulation Scenario 2 of Hayashi and Koike (2018b, Section 5).

# Simulation of Bm driving the log-price processes
n &lt;- 30000
J &lt;- 14

rho &lt;- c(0.3,0.5,0.7,0.5,0.5,0.5,0.5,0.5)
theta &lt;- c(-1,-1, -2, -2, -3, -5, -7, -10)/2^(J + 1)

dB &lt;- simBmllag(n, J, rho, theta)

# Simulation of Bm driving the volatility processes
R &lt;- -0.5 # leverage parameter
delta &lt;- 1/2^(J+1) # step size of time increments 
dW1 &lt;- R * dB[ ,1] + sqrt(1 - R^2) * rnorm(n, sd = sqrt(delta))
dW2 &lt;- R * dB[ ,2] + sqrt(1 - R^2) * rnorm(n, sd = sqrt(delta))

# Simulation of the model by the simulate function
dW &lt;- rbind(dB[,1], dB[,2], dW1, dW2) # increments of the driving Bm

# defining the yuima object
drift &lt;- c(0, 0, "kappa*(eta - x3)", "kappa*(eta - x4)")
diffusion &lt;- diag(4)
diag(diffusion) &lt;- c("sqrt(max(x3,0))", "sqrt(max(x4,0))", 
                     "xi*sqrt(max(x3,0))", "xi*sqrt(max(x4,0))")
xinit &lt;- c(0,0,"rgamma(1, 2*kappa*eta/xi^2,2*kappa/xi^2)",
           "rgamma(1, 2*kappa*eta/xi^2,2*kappa/xi^2)")
mod &lt;- setModel(drift = drift, diffusion = diffusion, 
                xinit = xinit, state.variable = c("x1","x2","x3","x4"))
samp &lt;- setSampling(Terminal = n * delta, n = n)
yuima &lt;- setYuima(model = mod, sampling = samp)

# simulation
result &lt;- simulate(yuima, increment.W = dW,
                   true.parameter = list(kappa = 5, eta = 0.04, xi = 0.5))

plot(result)

## End(Not run)</code></pre>

<hr>
<h2 id='simCIR'>Simulation of the Cox-Ingersoll-Ross diffusion</h2><span id='topic+simCIR'></span>

<h3>Description</h3>

<p>This is a function to simulate a Cox-Ingersoll-Ross process given via the SDE 
</p>
<p><code class="reqn">\mathrm{d} X_t = (\alpha-\beta X_t)\mathrm{d} t + \sqrt{\gamma X_t}\mathrm{d} W_t</code>
</p>
<p>with a Brownian motion <code class="reqn">(W_t)_{t\geq 0}</code> and parameters <code class="reqn">\alpha,\beta,\gamma&gt;0.</code> We use an exact CIR simulator for <code class="reqn">(X_{t_j} )_{j=1,\dots,n}</code> through the non-central chi-squares distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCIR(time.points, n, h, alpha, beta, gamma, equi.dist=FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simCIR_+3A_alpha">alpha</code>, <code id="simCIR_+3A_beta">beta</code>, <code id="simCIR_+3A_gamma">gamma</code></td>
<td>

<p>numbers given as in the SDE above. 
</p>
</td></tr>
<tr><td><code id="simCIR_+3A_equi.dist">equi.dist</code></td>
<td>
<p>a logical value indicating whether the sampling points are equidistant (default <code>equi.dist=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="simCIR_+3A_n">n</code></td>
<td>

<p>a number indicating the quantity of sampling points in the case <code>equi.dist=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="simCIR_+3A_h">h</code></td>
<td>

<p>a number indicating the step size in the case <code>equi.dist=TRUE</code>.  
</p>
</td></tr>
<tr><td><code id="simCIR_+3A_time.points">time.points</code></td>
<td>

<p>a numeric vector of sampling times (necessary if <code>equi.dist=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the realization of <code class="reqn">(t_0,X_{t_0}),\dots, (t_n,X_{t_n})</code> with <code class="reqn">t_j</code> denoting the <code class="reqn">j</code>-th sampling times.
</p>


<h3>Author(s)</h3>

<p>Nicole Hufnagel 
</p>
<p>Contacts: <a href="mailto:nicole.hufnagel@math.tu-dortmund.de">nicole.hufnagel@math.tu-dortmund.de</a>
</p>


<h3>References</h3>

<p>S. J. A. Malham and A. Wiese. Chi-square simulation of the CIR process
and the Heston model. Int. J. Theor. Appl. Finance, 16(3):1350014, 38,
2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## You always need the parameters alpha, beta and gamma
## Additionally e.g. time.points
data &lt;- simCIR(alpha=3,beta=1,gamma=1,
               time.points = c(0,0.1,0.2,0.25,0.3))
## or n, number of observations, h, distance between observations,
## and equi.dist=TRUE
data &lt;- simCIR(alpha=3,beta=1,gamma=1,n=1000,h=0.1,equi.dist=TRUE)
plot(data[1,],data[2,], type="l",col=4)

## If you input every value and equi.dist=TRUE, time.points are not
## used for the simulations.

data &lt;- simCIR(alpha=3,beta=1,gamma=1,n=1000,h=0.1,
               time.points = c(0,0.1,0.2,0.25,0.3),
               equi.dist=TRUE)

## If you leave equi.dist=FALSE, the parameters n and h are not
## used for the simulation.
data &lt;- simCIR(alpha=3,beta=1,gamma=1,n=1000,h=0.1,
               time.points = c(0,0.1,0.2,0.25,0.3))
</code></pre>

<hr>
<h2 id='simFunctional'>Calculate the value of functional</h2><span id='topic+simFunctional'></span><span id='topic+simFunctional+2Cyuima-method'></span><span id='topic+Fnorm'></span><span id='topic+Fnorm+2Cyuima-method'></span><span id='topic+F0'></span><span id='topic+F0+2Cyuima-method'></span>

<h3>Description</h3>

<p>Calculate the value of functional associated with sde by Euler scheme.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simFunctional(yuima, expand.var="e")
Fnorm(yuima, expand.var="e")
F0(yuima, expand.var="e")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simFunctional_+3A_yuima">yuima</code></td>
<td>
<p>a <code>yuima</code> object containing model, functional and data.</p>
</td></tr>
<tr><td><code id="simFunctional_+3A_expand.var">expand.var</code></td>
<td>
<p>default expand.var=&quot;e&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the value of functional of interest. Fnorm returns normalized one, and F0 returns the value for the case small parameter epsilon = 0. In simFunctional and Fnorm, yuima MUST contains the 'data' slot (X in legacy version)
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Fe</code></td>
<td>
<p>a real value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>we need to fix this routine.
</p>


<h3>Author(s)</h3>

<p>YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# to the Black-Scholes economy:
# dXt^e = Xt^e * dt + e * Xt^e * dWt
diff.matrix &lt;- matrix( c("x*e"), 1,1)
model &lt;- setModel(drift = c("x"), diffusion = diff.matrix)
# call option is evaluated by averating
# max{ (1/T)*int_0^T Xt^e dt, 0}, the first argument is the functional of interest:
Terminal &lt;- 1
xinit &lt;- c(1)
f &lt;- list( c(expression(x/Terminal)), c(expression(0)))
F &lt;- 0
division &lt;- 1000
e &lt;- .3
samp &lt;- setSampling(Terminal = Terminal, n = division)
yuima &lt;- setYuima(model = model,sampling = samp) 
yuima &lt;- setFunctional( yuima, xinit=xinit, f=f,F=F,e=e)
# evaluate the functional value

yuima &lt;- simulate(yuima,xinit=xinit,true.par=e)
Fe &lt;- simFunctional(yuima)
Fe
Fenorm &lt;- Fnorm(yuima)
Fenorm
</code></pre>

<hr>
<h2 id='simulate'>Simulator function for multi-dimensional stochastic processes</h2><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Simulate multi-dimensional stochastic processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(object, nsim=1, seed=NULL, xinit, true.parameter, space.discretized = FALSE, 
 increment.W = NULL, increment.L = NULL, method = "euler", hurst, methodfGn = "WoodChan",
 	sampling=sampling, subsampling=subsampling, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+yuima-class">yuima-class</a></code>, 
<code><a href="#topic+yuima.model-class">yuima.model-class</a></code> or <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>  object.</p>
</td></tr>
<tr><td><code id="simulate_+3A_xinit">xinit</code></td>
<td>
<p>initial value vector of state variables.</p>
</td></tr>
<tr><td><code id="simulate_+3A_true.parameter">true.parameter</code></td>
<td>
<p>named list of parameters.</p>
</td></tr>
<tr><td><code id="simulate_+3A_space.discretized">space.discretized</code></td>
<td>
<p>flag to switch to space-discretized Euler
Maruyama method.</p>
</td></tr>
<tr><td><code id="simulate_+3A_increment.w">increment.W</code></td>
<td>
<p>to specify Wiener increment for each time tics in advance.</p>
</td></tr>
<tr><td><code id="simulate_+3A_increment.l">increment.L</code></td>
<td>
<p>to specify Levy increment for each time tics in advance.</p>
</td></tr>
<tr><td><code id="simulate_+3A_method">method</code></td>
<td>
<p>string Variable for simulation scheme. The default value <code>method=euler</code> uses the euler discretization  for the simulation of a sample path.</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>Not used yet. Included only to match the standard genenirc in 
package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>Not used yet. Included only to match the standard genenirc in 
package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_hurst">hurst</code></td>
<td>
<p>value of Hurst parameter for simulation of the fGn. Overrides the specified hurst slot.</p>
</td></tr>
<tr><td><code id="simulate_+3A_methodfgn">methodfGn</code></td>
<td>
<p>simulation methods for fractional Gaussian noise.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+setSampling">setSampling</a></code> to create a sampling</p>
</td></tr>
<tr><td><code id="simulate_+3A_sampling">sampling</code></td>
<td>
<p>a <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code> object.</p>
</td></tr>
<tr><td><code id="simulate_+3A_subsampling">subsampling</code></td>
<td>
<p>a <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simulate</code> is a function to solve SDE using the Euler-Maruyama
method. This function supports usual Euler-Maruyama method for
multidimensional SDE, and space
discretized Euler-Maruyama method for one dimensional SDE.
</p>
<p>It simulates solutions of stochastic differential equations with Gaussian noise,
fractional Gaussian noise awith/without jumps.
</p>
<p>If a <code><a href="#topic+yuima-class">yuima-class</a></code> object is passed as input, then the sampling
information is taken from the slot <code>sampling</code> of the object.
If a <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code> object, a <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> object or a 
<code><a href="#topic+yuima-class">yuima-class</a></code> object with missing <code>sampling</code> slot is passed
as input the <code>sampling</code> argument is used. If this argument is missing
then the sampling structure is constructed from <code>Initial</code>, <code>Terminal</code>,
etc. arguments (see <code><a href="#topic+setSampling">setSampling</a></code> for details on how to use these 
arguments).
</p>
<p>For a COGARCH(p,q) process setting <code>method=mixed</code> implies that the simulation scheme is based on the solution of the state space process. For the case in which the underlying noise is a compound poisson Levy process, the trajectory is build firstly by simulation of the jump time, then the quadratic variation and the increments noise are simulated exactly at jump time. For the others Levy process, the simulation scheme is based on the discretization of the state space process solution.       
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yuima</code></td>
<td>
<p>a <code>yuima-class</code> object.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the simulation of multi-variate Levy processes, the values of parameters have to be defined outside of <code>simulate</code> function in advance (see examples below).
</p>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# Path-simulation for 1-dim diffusion process. 
# dXt = -0.3*Xt*dt + dWt
mod &lt;- setModel(drift="-0.3*y", diffusion=1, solve.variable=c("y"))
str(mod)

# Set the model in an `yuima' object with a sampling scheme. 
T &lt;- 1
n &lt;- 1000
samp &lt;- setSampling(Terminal=T, n=n)
ou &lt;- setYuima(model=mod, sampling=samp)

# Solve SDEs using Euler-Maruyama method. 
par(mfrow=c(3,1))
ou &lt;- simulate(ou, xinit=1)
plot(ou)


set.seed(123)
ouB &lt;- simulate(mod, xinit=1,sampling=samp)
plot(ouB)


set.seed(123)
ouC &lt;- simulate(mod, xinit=1, Terminal=1, n=1000)
plot(ouC)

par(mfrow=c(1,1))


# Path-simulation for 1-dim diffusion process. 
# dXt = theta*Xt*dt + dWt
mod1 &lt;- setModel(drift="theta*y", diffusion=1, solve.variable=c("y"))
str(mod1)
ou1 &lt;- setYuima(model=mod1, sampling=samp)

# Solve SDEs using Euler-Maruyama method. 
ou1 &lt;- simulate(ou1, xinit=1, true.p = list(theta=-0.3))
plot(ou1)

## Not run: 

# A multi-dimensional (correlated) diffusion process. 
# To describe the following model: 
# X=(X1,X2,X3); dXt = U(t,Xt)dt + V(t)dWt
# For drift coeffcient
U &lt;- c("-x1","-2*x2","-t*x3")
# For diffusion coefficient of X1 
v1 &lt;- function(t) 0.5*sqrt(t)
# For diffusion coefficient of X2
v2 &lt;- function(t) sqrt(t)
# For diffusion coefficient of X3
v3 &lt;- function(t) 2*sqrt(t)
# correlation
rho &lt;- function(t) sqrt(1/2)
# coefficient matrix for diffusion term
V &lt;- matrix( c( "v1(t)",
                "v2(t) * rho(t)",
                "v3(t) * rho(t)",
                "",
                "v2(t) * sqrt(1-rho(t)^2)",
                "",
                "",
                "",
                "v3(t) * sqrt(1-rho(t)^2)" 
               ), 3, 3)
# Model sde using "setModel" function
cor.mod &lt;- setModel(drift = U, diffusion = V,
state.variable=c("x1","x2","x3"), 
solve.variable=c("x1","x2","x3") )
str(cor.mod)

# Set the `yuima' object. 
cor.samp &lt;- setSampling(Terminal=T, n=n)
cor &lt;- setYuima(model=cor.mod, sampling=cor.samp)

# Solve SDEs using Euler-Maruyama method. 
set.seed(123)
cor &lt;- simulate(cor)
plot(cor)

# A non-negative process (CIR process)
# dXt= a*(c-y)*dt + b*sqrt(Xt)*dWt
 sq &lt;- function(x){y = 0;if(x&gt;0){y = sqrt(x);};return(y);}
 model&lt;- setModel(drift="0.8*(0.2-x)",
  diffusion="0.5*sq(x)",solve.variable=c("x"))
 T&lt;-10
 n&lt;-1000
 sampling &lt;- setSampling(Terminal=T,n=n)
 yuima&lt;-setYuima(model=model, sampling=sampling)
 cir&lt;-simulate(yuima,xinit=0.1)
 plot(cir)

# solve SDEs using Space-discretized Euler-Maruyama method
v4 &lt;- function(t,x){
  return(0.5*(1-x)*sqrt(t))
}
mod_sd &lt;- setModel(drift = c("0.1*x1", "0.2*x2"),
                     diffusion = c("v1(t)","v4(t,x2)"),
                     solve.var=c("x1","x2")
                     )
samp_sd &lt;- setSampling(Terminal=T, n=n)
sd &lt;- setYuima(model=mod_sd, sampling=samp_sd)
sd &lt;- simulate(sd, xinit=c(1,1), space.discretized=TRUE)
plot(sd)


## example of simulation by specifying increments
## Path-simulation for 1-dim diffusion process
## dXt = -0.3*Xt*dt + dWt

mod &lt;- setModel(drift="-0.3*y", diffusion=1,solve.variable=c("y"))
str(mod)

## Set the model in an `yuima' object with a sampling scheme. 
Terminal &lt;- 1
n &lt;- 500
mod.sampling &lt;- setSampling(Terminal=Terminal, n=n)
yuima.mod &lt;- setYuima(model=mod, sampling=mod.sampling)

##use original increment
delta &lt;- Terminal/n
my.dW &lt;- rnorm(n * yuima.mod@model@noise.number, 0, sqrt(delta))
my.dW &lt;- t(matrix(my.dW, nrow=n, ncol=yuima.mod@model@noise.number))

## Solve SDEs using Euler-Maruyama method.
yuima.mod &lt;- simulate(yuima.mod,
                      xinit=1,
                      space.discretized=FALSE,
                      increment.W=my.dW)
if( !is.null(yuima.mod) ){
 dev.new()
 # x11()
  plot(yuima.mod)
}

## A multi-dimensional (correlated) diffusion process. 
## To describe the following model: 
## X=(X1,X2,X3); dXt = U(t,Xt)dt + V(t)dWt
## For drift coeffcient
U &lt;- c("-x1","-2*x2","-t*x3")
## For process 1
diff.coef.1 &lt;- function(t) 0.5*sqrt(t)
## For process 2
diff.coef.2 &lt;- function(t) sqrt(t)
## For process 3
diff.coef.3 &lt;- function(t) 2*sqrt(t)
## correlation
cor.rho &lt;- function(t) sqrt(1/2)
## coefficient matrix for diffusion term
V &lt;- matrix( c( "diff.coef.1(t)",
               "diff.coef.2(t) * cor.rho(t)",
               "diff.coef.3(t) * cor.rho(t)",
               "",
               "diff.coef.2(t)",
               "diff.coef.3(t) * sqrt(1-cor.rho(t)^2)",
               "diff.coef.1(t) * cor.rho(t)",
               "",
               "diff.coef.3(t)" 
               ), 3, 3)
## Model sde using "setModel" function
cor.mod &lt;- setModel(drift = U, diffusion = V,
                    solve.variable=c("x1","x2","x3") )
str(cor.mod)
## Set the `yuima' object.
set.seed(123)
obj.sampling &lt;- setSampling(Terminal=Terminal, n=n)
yuima.obj &lt;- setYuima(model=cor.mod, sampling=obj.sampling)

##use original dW
my.dW &lt;- rnorm(n * yuima.obj@model@noise.number, 0, sqrt(delta))
my.dW &lt;- t(matrix(my.dW, nrow=n, ncol=yuima.obj@model@noise.number))

## Solve SDEs using Euler-Maruyama method.
yuima.obj.path &lt;- simulate(yuima.obj, space.discretized=FALSE, 
 increment.W=my.dW)
if( !is.null(yuima.obj.path) ){
  dev.new()
#  x11()
  plot(yuima.obj.path)
}


##:: sample for Levy process ("CP" type)
## specify the jump term as c(x,t)dz
obj.model &lt;- setModel(drift=c("-theta*x"), diffusion="sigma",
jump.coeff="1", measure=list(intensity="1", df=list("dnorm(z, 0, 1)")),
measure.type="CP", solve.variable="x")

##:: Parameters
lambda &lt;- 3
theta &lt;- 6
sigma &lt;- 1
xinit &lt;- runif(1)
N &lt;- 500
h &lt;- N^(-0.7)
eps &lt;- h/50
n &lt;- 50*N
T &lt;- N*h

set.seed(123)
obj.sampling &lt;- setSampling(Terminal=T, n=n)
obj.yuima &lt;- setYuima(model=obj.model, sampling=obj.sampling)
X &lt;- simulate(obj.yuima, xinit=xinit, true.parameter=list(theta=theta, sigma=sigma))
dev.new()
plot(X)


##:: sample for Levy process ("CP" type)
## specify the jump term as c(x,t,z)
## same plot as above example
obj.model &lt;- setModel(drift=c("-theta*x"), diffusion="sigma",
jump.coeff="z", measure=list(intensity="1", df=list("dnorm(z, 0, 1)")),
measure.type="CP", solve.variable="x")

set.seed(123)
obj.sampling &lt;- setSampling(Terminal=T, n=n)
obj.yuima &lt;- setYuima(model=obj.model, sampling=obj.sampling)
X &lt;- simulate(obj.yuima, xinit=xinit, true.parameter=list(theta=theta, sigma=sigma))
dev.new()
plot(X)




##:: sample for Levy process ("code" type)
## dX_{t} = -x dt + dZ_t
obj.model &lt;- setModel(drift="-x", xinit=1, jump.coeff="1", measure.type="code", 
measure=list(df="rIG(z, 1, 0.1)"))
obj.sampling &lt;- setSampling(Terminal=10, n=10000)
obj.yuima &lt;- setYuima(model=obj.model, sampling=obj.sampling)
result &lt;- simulate(obj.yuima)
dev.new()
plot(result)

##:: sample for multidimensional Levy process ("code" type)
## dX = (theta - A X)dt + dZ,
##    theta=(theta_1, theta_2) = c(1,.5)
##    A=[a_ij], a_11 = 2, a_12 = 1, a_21 = 1, a_22=2
require(yuima)
x0 &lt;- c(1,1)
beta &lt;- c(.1,.1)
mu &lt;- c(0,0)
delta0 &lt;- 1
alpha &lt;- 1
Lambda &lt;- matrix(c(1,0,0,1),2,2)
cc &lt;- matrix(c(1,0,0,1),2,2)
obj.model &lt;- setModel(drift=c("1 - 2*x1-x2",".5-x1-2*x2"), xinit=x0,
solve.variable=c("x1","x2"), jump.coeff=cc, measure.type="code",
 measure=list(df="rNIG(z, alpha, beta, delta0, mu, Lambda)"))
obj.sampling &lt;- setSampling(Terminal=10, n=10000)
obj.yuima &lt;- setYuima(model=obj.model, sampling=obj.sampling)
result &lt;- simulate(obj.yuima,true.par=list( alpha=alpha, 
 beta=beta, delta0=delta0, mu=mu, Lambda=Lambda))
plot(result)


# Path-simulation for a Carma(p=2,q=1) model driven by a Brownian motion:
carma1&lt;-setCarma(p=2,q=1)
str(carma1)

# Set the sampling scheme
samp&lt;-setSampling(Terminal=100,n=10000)

# Set the values of the model parameters
par.carma1&lt;-list(b0=1,b1=2.8,a1=2.66,a2=0.3)

set.seed(123)
sim.carma1&lt;-simulate(carma1,
                     true.parameter=par.carma1,
                     sampling=samp)

plot(sim.carma1)



# Path-simulation for a Carma(p=2,q=1) model driven by a Compound Poisson process.
carma1&lt;-setCarma(p=2,
                 q=1,
                 measure=list(intensity="1",df=list("dnorm(z, 0, 1)")),
                 measure.type="CP")

# Set Sampling scheme
samp&lt;-setSampling(Terminal=100,n=10000)

# Fix carma parameters
par.carma1&lt;-list(b0=1,
                 b1=2.8,
                 a1=2.66,
                 a2=0.3)

set.seed(123)
sim.carma1&lt;-simulate(carma1,
                     true.parameter=par.carma1,
                     sampling=samp)

plot(sim.carma1)

## End(Not run)
</code></pre>

<hr>
<h2 id='snr'>
Calculating self-normalized residuals for SDEs.
</h2><span id='topic+snr'></span>

<h3>Description</h3>

<p>Calculate self-normalized residuals based on the Gaussian quasi-likelihood estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snr(yuima, start, lower, upper, withdrift)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snr_+3A_yuima">yuima</code></td>
<td>
<p>a yuima object.</p>
</td></tr>
<tr><td><code id="snr_+3A_lower">lower</code></td>
<td>
<p>a named list for specifying lower bounds of parameters.</p>
</td></tr>
<tr><td><code id="snr_+3A_upper">upper</code></td>
<td>
<p>a named list for specifying upper bounds of parameters.</p>
</td></tr>
<tr><td><code id="snr_+3A_start">start</code></td>
<td>
<p>initial values to be passed to the optimizer.</p>
</td></tr>
<tr><td><code id="snr_+3A_withdrift">withdrift</code></td>
<td>
<p>use drift information for constructing self-normalized residuals. by default, withdrift = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the Gaussian quasi maximum likelihood estimator and associated self-normalized residuals.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>estimator</code></td>
<td>
<p>Gaussian quasi maximum likelihood estimator</p>
</td></tr>
<tr><td><code>snr</code></td>
<td>
<p>self-normalized residuals based on the Gaussian quasi maximum likelihood estimator</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Yuma Uehara <a href="mailto:y-uehara@ism.ac.jp">y-uehara@ism.ac.jp</a>
</p>


<h3>References</h3>

<p>Masuda, H. (2013). Asymptotics for functionals of self-normalized residuals of discretely observed stochastic processes. 
Stochastic Processes and their Applications 123 (2013), 2752&ndash;2778
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Test code (1. diffusion case)
yuima.mod &lt;- setModel(drift="-theta*x",diffusion="theta1/sqrt(1+x^2)")
n &lt;- 10000
ysamp &lt;- setSampling(Terminal=n^(1/3),n=n)
yuima &lt;- setYuima(model=yuima.mod, sampling=ysamp)
set.seed(123)
yuima &lt;- simulate(yuima, xinit=0, true.parameter = list(theta=2,theta1=3))
start=list(theta=3,theta1=0.5)
lower=list(theta=1,theta1=0.3)
upper=list(theta=5,theta1=3)
res &lt;- snr(yuima,start,lower,upper)
str(res)

# Test code (2.jump diffusion case)
a&lt;-3
b&lt;-5
mod &lt;- setModel(drift="10-theta*x", #drift="10-3*x/(1+x^2)",
                diffusion="theta1*(2+x^2)/(1+x^2)",
                jump.coeff="1",
                # measure=list(intensity="10",df=list("dgamma(z, a, b)")),
                measure=list(intensity="10",df=list("dunif(z, a, b)")),
                measure.type="CP")

T &lt;- 100 ## Terminal
n &lt;- 10000 ## generation size
samp &lt;- setSampling(Terminal=T, n=n) ## define sampling scheme
yuima &lt;- setYuima(model = mod, sampling = samp)

yuima &lt;- simulate(yuima, xinit=1,
                  true.parameter=list(theta=2,theta1=sqrt(2),a=a,b=b), 
                  sampling = samp)
start=list(theta=3,theta1=0.5)
lower=list(theta=1,theta1=0.3)
upper=list(theta=5,theta1=3)
res &lt;- snr(yuima,start,lower,upper)
str(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='spectralcov'>
Spectral Method for Cumulative Covariance Estimation
</h2><span id='topic+spectralcov'></span><span id='topic+lmm'></span>

<h3>Description</h3>

<p>This function implements the local method of moments proposed in Bibinger et al. (2014) to estimate the cummulative covariance matrix of a non-synchronously observed multi-dimensional Ito process with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmm(x, block = 20, freq = 50, freq.p = 10, K = 4, interval = c(0, 1), 
    Sigma.p = NULL, noise.var = "AMZ", samp.adj = "direct", psd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectralcov_+3A_x">x</code></td>
<td>

<p>an object of  <code><a href="#topic+yuima-class">yuima-class</a></code> or <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>.
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_block">block</code></td>
<td>

<p>a positive integer indicating the number of the blocks which the observation interval is split into.
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_freq">freq</code></td>
<td>

<p>a positive integer indicating the number of the frequencies used to compute the final estimator.
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_freq.p">freq.p</code></td>
<td>

<p>a positive integer indicating the number of the frequencies used to compute the pilot estimator for the spot covariance matrix (corresponding to the number <code class="reqn">J_n</code> in Eq.(29) from Altmeyer and Bibinger (2015)).
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_k">K</code></td>
<td>

<p>a positive integer indicating the number of the blocks used to compute the pilot estimator for the spot covariance matrix (corresponding to the number <code class="reqn">K_n</code> in Eq.(29) from Altmeyer and Bibinger (2015)).
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_interval">interval</code></td>
<td>

<p>a vector indicating the observation interval. The first component represents the initial value and the second component represents the terminal value.
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_sigma.p">Sigma.p</code></td>
<td>

<p>a <code>block</code> by <code>dim(x)</code> matrix giving the pilot estimates of the spot covariance matrix plugged into the optimal weight matrices. If <code>NULL</code> (the default), it is computed by using formula (29) from Altmeyer and Bibinger (2015). 
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_noise.var">noise.var</code></td>
<td>

<p>character string giving the method to estimate the noise variances. There are several options: <code>"AMZ"</code> (the default) uses equation (3.7) from Gatheral and Oomen (2010), i.e. the quasi-maximum likelihood estimator proposed by Ait-Sahalia et al. (2005) (see also Xiu (2010)). <code>"BR"</code> uses equation (3.9) from Gatheral and Oomen (2010), i.e. the sample average of the squared returns divided by 2, the estimator proposed by Bandi and Russel (2006). <code>"O"</code> uses equation (3.8) from Gatheral and Oomen (2010), i.e. another method-of-moments estimator proposed by Oomen (2006). It is also possible to directly specify the noise variances by setting this argument to a numeric vector. In this case the <code>i</code>-th component of <code>noise.var</code> must indicates the variance of the noise for the <code>i</code>-th component of the observation process. 
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_samp.adj">samp.adj</code></td>
<td>

<p>character string giving the method to adjust the effect of the sampling times on the variances of the spectral statistics for the noise part. The default method <code>"direct"</code> uses the local sums of the squares of the one-skip differences of the sampling times divided by 2, which directly appears in the representation of the variances of the spectral statistics for the noise part. Another choice is <code>"QVT"</code>, which uses the local quadratic variations of time as in Altmeyer and Bibinger (2015) and Bibinger et al. (2014).
</p>
</td></tr>
<tr><td><code id="spectralcov_+3A_psd">psd</code></td>
<td>

<p>logical. If <code>TRUE</code> (the default), the estimated covariance matrix and variance-covariance matrix are converted to their spectral absolute values to ensure their positive semi-definiteness. This procedure does not matter in terms of the asymptotic theory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default implementation is the adaptive version of the local method of moments estimator, which is only based on observation data. It is possible to implement oracle versions of the estimator by setting user-specified <code>Sigma.p</code> and/or <code>noise.var</code>. An example is given below.
</p>


<h3>Value</h3>

<p>An object of class <code>"yuima.specv"</code>, which is a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>covmat</code></td>
<td>
<p>the estimated covariance matrix</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the estimated variance-covariance matrix of <code>as.vector(covmat)</code></p>
</td></tr>
<tr><td><code>Sigma.p</code></td>
<td>
<p>the pilot estimates of the spot covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Ait-Sahalia, Y., Mykland, P. A. and Zhang, L. (2005)
How often to sample a continuous-time process in the presence of market microstructure noise,
<em>The Review of Financial Studies</em>, <b>18</b>, 351&ndash;416.
</p>
<p>Altmeyer, R. and Bibinger, M. (2015)
Functional stable limit theorems for quasi-efficient spectral covolatility estimators,
to appear in <em>Stochastic processes and their applications</em>, doi:10.1016/j.spa.2015.07.009.
</p>
<p>Bandi, F. M. and Russell, J. R. (2006)
Separating microstructure noise from volatility,
<em>Journal of Financial Economics</em>, <b>79</b>, 655&ndash;692.
</p>
<p>Bibinger, M., Hautsch, N., Malec, P. and Reiss, M. (2014)
Estimating the quadratic covariation matrix from noisy observations: local method of moments and efficiency,
<em>Annals of Statistics</em>, <b>42</b>, 80&ndash;114.
</p>
<p>Gatheral J. and Oomen, R. C. A. (2010)
Zero-intelligence realized variance estimation,
<em>Finance Stochastics</em>, <b>14</b>, 249&ndash;283.
</p>
<p>Oomen, R. C. A. (2006)
Properties of realized variance under alternative sampling schemes,
<em>Journal of Business and Economic Statistics</em>, <b>24</b>, 219&ndash;237.
</p>
<p>Reiss, M. (2011)
Asymptotic equivalence for inference on the volatility from noisy observations,
<em>Annals of Statistics</em>, <b>39</b>, 772&ndash;802.
</p>
<p>Xiu, D. (2010)
Quasi-maximum likelihood estimation of volatility with high frequency data,
<em>Journal of Econometrics</em>, <b>159</b>, 235&ndash;250.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cce">cce</a></code>, <code><a href="#topic+setData">setData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example. One-dimensional and regular sampling case
# Here the simulated model is taken from Reiss (2011)

## Set a model
sigma &lt;- function(t) sqrt(0.02 + 0.2 * (t - 0.5)^4)
modI &lt;- setModel(drift = 0, diffusion = "sigma(t)")

## Generate a path of the process
set.seed(117)
n &lt;- 12000
yuima.samp &lt;- setSampling(Terminal = 1, n = n) 
yuima &lt;- setYuima(model = modI, sampling = yuima.samp) 
yuima &lt;- simulate(yuima, xinit = 0)

delta &lt;- 0.01 # standard deviation of microstructure noise
yuima &lt;- noisy.sampling(yuima, var.adj = delta^2) # generate noisy observations
plot(yuima)

## Estimation of the integrated volatility
est &lt;- lmm(yuima)
est

## True integrated volatility and theoretical standard error
disc &lt;- seq(0, 1, by = 1/n)
cat("true integrated volatility\n")
print(mean(sigma(disc[-1])^2))
cat("theoretical standard error\n")
print(sqrt(8*delta*mean(sigma(disc[-1])^3))/n^(1/4))

# Plotting the pilot estimate of the spot variance path
block &lt;- 20
G &lt;- seq(0,1,by=1/block)[1:block]
Sigma.p &lt;- sigma(G)^2 # true spot variance
plot(zoo(Sigma.p, G), col = "blue",, xlab = "time", 
     ylab = expression(sigma(t)^2))
lines(zoo(est$Sigma.p, G))

## "Oracle" implementation
lmm(yuima, block = block, Sigma.p = Sigma.p, noise.var = delta^2)

# Example. Multi-dimensional case
# We simulate noisy observations of a correlated bivariate Brownian motion
# First we examine the regular sampling case since in this situsation the theoretical standard 
# error can easily be computed via the formulae given in p.88 of Bibinger et al. (2014)

## Set a model
drift &lt;- c(0,0)

rho &lt;- 0.5 # correlation

diffusion &lt;- matrix(c(1,rho,0,sqrt(1-rho^2)),2,2)

modII &lt;- setModel(drift=drift,diffusion=diffusion,
                  state.variable=c("x1","x2"),solve.variable=c("x1","x2"))
                  
## Generate a path of the latent process
set.seed(123)

## We regard the unit interval as 6.5 hours and generate the path on it 
## with the step size equal to 1 seconds

n &lt;- 8000
yuima.samp &lt;- setSampling(Terminal = 1, n = n) 
yuima &lt;- setYuima(model = modII, sampling = yuima.samp) 
yuima &lt;- simulate(yuima)

## Generate noisy observations
eta &lt;- 0.05
yuima &lt;- noisy.sampling(yuima, var.adj = diag(eta^2, 2))
plot(yuima)

## Estimation of the integrated covariance matrix
est &lt;- lmm(yuima)
est

## Theoretical standard error
a &lt;- sqrt(4 * eta * (sqrt(1 + rho) + sqrt(1 - rho)))
b &lt;- sqrt(2 * eta * ((1 + rho)^(3/2) + (1 - rho)^(3/2)))
cat("theoretical standard error\n")
print(matrix(c(a,b,b,a),2,2)/n^(1/4))

## "Oracle" implementation
block &lt;- 20
Sigma.p &lt;- matrix(c(1,rho,rho,1),block,4,byrow=TRUE) # true spot covariance matrix
lmm(yuima, block = block, Sigma.p = Sigma.p, noise.var = rep(eta^2,2))

# Next we extract nonsynchronous observations from 
# the path generated above by Poisson random sampling
psample &lt;- poisson.random.sampling(yuima, rate = c(1/2,1/2), n = n)

## Estimation of the integrated covariance matrix
lmm(psample)

## "Oracle" implementation
lmm(psample, block = block, Sigma.p = Sigma.p, noise.var = rep(eta^2,2))

## Other choices of tuning parameters (estimated values are not varied so much)
lmm(psample, block = 25)
lmm(psample, freq = 100)
lmm(psample, freq.p = 15)
lmm(psample, K = 8)

</code></pre>

<hr>
<h2 id='subsampling'>subsampling </h2><span id='topic+subsampling'></span>

<h3>Description</h3>

<p>subsampling</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsampling(x, sampling, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsampling_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+yuima-class">yuima-class</a></code> or 
<code><a href="#topic+yuima.model-class">yuima.model-class</a></code> object.</p>
</td></tr>
<tr><td><code id="subsampling_+3A_sampling">sampling</code></td>
<td>
<p>a <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code> object.</p>
</td></tr>
<tr><td><code id="subsampling_+3A_...">...</code></td>
<td>
<p>used to create a sampling structure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When subsampling on some grid of times, it may happen that no data is available
at the given grid point. In this case it is possible to use several techniques.
Different options are avaiable specifying the argument, or the slot, 
<code>interpolation</code>:
</p>

<dl>
<dt><code>"none"</code> or <code>"exact"</code></dt><dd><p>no interpolation. If no data point exists
at a given grid point, <code>NA</code> is returned in the subsampled data</p>
</dd>
<dt><code>"pt"</code> or <code>"previous"</code></dt><dd><p>the first data on the left of 
the grid point instant is used.</p>
</dd>
<dt><code>"nt"</code> or <code>"next"</code></dt><dd><p>the first data on the right of 
the grid point instant is used.</p>
</dd>
<dt><code>"lin"</code> or <code>"linear"</code></dt><dd><p>the average of the values of the first 
data on the left and the first data to the right of 
the grid point instant is used.</p>
</dd>
</dl>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yuima</code></td>
<td>
<p>a <code>yuima.data-class</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set a model
diff.coef.1 &lt;- function(t, x1=0, x2) x2*(1+t)
diff.coef.2 &lt;- function(t, x1, x2=0) x1*sqrt(1+t^2)
cor.rho &lt;- function(t, x1=0, x2=0) sqrt((1+cos(x1*x2))/2)
diff.coef.matrix &lt;- matrix(c("diff.coef.1(t,x1,x2)",
"diff.coef.2(t,x1,x2)*cor.rho(t,x1,x2)", "",
"diff.coef.2(t,x1,x2)*sqrt(1-cor.rho(t,x1,x2)^2)"),2,2)
cor.mod &lt;- setModel(drift=c("",""), diffusion=diff.coef.matrix, 
solve.variable=c("x1", "x2"), xinit=c(3,2))
set.seed(111)

## We first simulate the two dimensional diffusion model
yuima.samp &lt;- setSampling(Terminal=1, n=1200)
yuima &lt;- setYuima(model=cor.mod, sampling=yuima.samp)
yuima.sim &lt;- simulate(yuima)

plot(yuima.sim, plot.type="single")

## random sampling with exponential times
## one random sequence per time series
newsamp &lt;- setSampling(
 random=list(rdist=c( function(x) rexp(x, rate=10), 
  function(x) rexp(x, rate=20))) )
newdata &lt;- subsampling(yuima.sim, sampling=newsamp)
points(get.zoo.data(newdata)[[1]],col="red")
points(get.zoo.data(newdata)[[2]],col="green")


plot(yuima.sim, plot.type="single")

## deterministic subsampling with different
## frequence for each time series
newsamp &lt;- setSampling(delta=c(0.1,0.2))
newdata &lt;- subsampling(yuima.sim, sampling=newsamp)
points(get.zoo.data(newdata)[[1]],col="red")
points(get.zoo.data(newdata)[[2]],col="green")
</code></pre>

<hr>
<h2 id='toLatex'>Additional Methods for LaTeX Representations for Yuima objects</h2><span id='topic+toLatex'></span><span id='topic+toLatex.yuima'></span><span id='topic+toLatex.yuima.model'></span><span id='topic+toLatex.yuima.carma'></span><span id='topic+toLatex.yuima.cogarch'></span>

<h3>Description</h3>

<p>These methods convert <code><a href="#topic+yuima-class">yuima-class</a></code>,
<code><a href="#topic+yuima.model-class">yuima.model-class</a></code>, <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code> or <code><a href="#topic+yuima.cogarch-class">yuima.cogarch-class</a></code> objects to character vectors with
LaTeX markup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'yuima'
toLatex(object,...)
## S3 method for class 'yuima.model'
toLatex(object,...)
## S3 method for class 'yuima.carma'
toLatex(object,...)
## S3 method for class 'yuima.cogarch'
toLatex(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toLatex_+3A_object">object</code></td>
<td>
<p>object of a class yuima, yuima.model or yuima.carma.</p>
</td></tr>
<tr><td><code id="toLatex_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method tries to convert a formal description of the model slot
of the yuima object into a LaTeX formula.
This is just a simple proof of concept and probably further LaTex 
manipulations for use in papers.
Copy and paste of the output of <code>toLatex</code> into a real LaTeX file
should do the job.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dXt = theta*Xt*dt + dWt
mod1 &lt;- setModel(drift="theta*y", diffusion=1, solve.variable=c("y"))
str(mod1)
toLatex(mod1)

# A multi-dimensional (correlated) diffusion process. 
# To describe the following model: 
# X=(X1,X2,X3); dXt = U(t,Xt)dt + V(t)dWt
# For drift coeffcient
U &lt;- c("-x1","-2*x2","-t*x3")
# For diffusion coefficient of X1 
v1 &lt;- function(t) 0.5*sqrt(t)
# For diffusion coefficient of X2
v2 &lt;- function(t) sqrt(t)
# For diffusion coefficient of X3
v3 &lt;- function(t) 2*sqrt(t)
# correlation
rho &lt;- function(t) sqrt(1/2)
# coefficient matrix for diffusion term
V &lt;- matrix( c( "v1(t)",
                "v2(t) * rho(t)",
                "v3(t) * rho(t)",
                "",
                "v2(t) * sqrt(1-rho(t)^2)",
                "",
                "",
                "",
                "v3(t) * sqrt(1-rho(t)^2)" 
               ), 3, 3)
# Model sde using "setModel" function
cor.mod &lt;- setModel(drift = U, diffusion = V,
state.variable=c("x1","x2","x3"), 
solve.variable=c("x1","x2","x3") )
str(cor.mod)
toLatex(cor.mod)

# A CARMA(p=3,q=1) process.
carma1&lt;-setCarma(p=3,q=1,loc.par="c",scale.par="s")
str(carma1)
toLatex(carma1)

# A COGARCH(p=3,q=5) process.
cogarch1&lt;-setCogarch(p=3,q=5,
                       measure=list(df=list("rNIG(z, mu00, bu00, 1, 0)")),
                       measure.type="code")
str(cogarch1)
toLatex(cogarch1)


</code></pre>

<hr>
<h2 id='variable.Integral'>Class for the mathematical description of integral of a stochastic process</h2><span id='topic+variable.Integral'></span><span id='topic+variable.Integral-class'></span><span id='topic+initialize+2Cvariable.Integral-method'></span>

<h3>Description</h3>

<p>Auxiliar class for definition of an object of class <code><a href="#topic+yuima.Integral">yuima.Integral</a></code>. see the documentation of <code><a href="#topic+yuima.Integral">yuima.Integral</a></code> for more details.
</p>

<hr>
<h2 id='wllag'>
Scale-by-scale lead-lag estimation
</h2><span id='topic+wllag'></span>

<h3>Description</h3>

<p>This function estimates lead-lag parameters on a scale-by-scale basis from non-synchronously observed bivariate processes, using the estimatiors proposed in Hayashi and Koike (2018b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wllag(x, y, J = 8, N = 10, tau = 1e-3, from = -to, to = 100, 
      verbose = FALSE, in.tau = FALSE, tol = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wllag_+3A_x">x</code></td>
<td>

<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object for observation data of the first process. 
</p>
</td></tr>
<tr><td><code id="wllag_+3A_y">y</code></td>
<td>

<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object for observation data of the second process.
</p>
</td></tr>
<tr><td><code id="wllag_+3A_j">J</code></td>
<td>

<p>a positive integer. Scale-by scale lead-lag parameters are estimated up to the level <code>J</code>.
</p>
</td></tr>
<tr><td><code id="wllag_+3A_n">N</code></td>
<td>

<p>The number of vanishing moments of Daubechies' compactly supported wavelets. This should be an integer between 1 and 10. 
</p>
</td></tr>
<tr><td><code id="wllag_+3A_tau">tau</code></td>
<td>

<p>the step size of a finite grid on which objective functions are evaluated. Note that this value is identified with the finest time resolution of the underlying model. 
The default value <code>1e-3</code> corresponds to 1 mili-second if the unit time corresponds to 1 second. 
</p>
</td></tr>
<tr><td><code id="wllag_+3A_from">from</code></td>
<td>

<p>a negative integer. <code>from*tau</code> gives the lower end of a finite grid on which objective functions are evaluated.
</p>
</td></tr>
<tr><td><code id="wllag_+3A_to">to</code></td>
<td>

<p>a positive integer. <code>to*tau</code> gives the upper end of a finite grid on which objective functions are evaluated.
</p>
</td></tr>
<tr><td><code id="wllag_+3A_verbose">verbose</code></td>
<td>

<p>a logical. If <code>FALSE</code> (default), the function returns only the estimated scale-by-scale lead-lag parameters. Otherwise, the function also returns some other statistics such as values of the signed objective functions. See &lsquo;Value&rsquo;.
</p>
</td></tr>
<tr><td><code id="wllag_+3A_in.tau">in.tau</code></td>
<td>

<p>a logical. If <code>TRUE</code>, the estimated lead-lag parameters are returned in increments of <code>tau</code>. That is, the estimated lead-lag parameters are divided by <code>tau</code>. 
</p>
</td></tr>
<tr><td><code id="wllag_+3A_tol">tol</code></td>
<td>

<p>tolelance parameter to avoid numerical errors in comparison of time stamps. All time stamps are divided by <code>tol</code> and rounded to integers. A reasonable choice of <code>tol</code> is the minimum unit of time stamps. The default value <code>1e-6</code> supposes that the minimum unit of time stamps is greater or equal to 1 micro-second.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hayashi and Koike (2018a) introduced a bivariate continuous-time model having different lead-lag relationships at different time scales. The wavelet cross-covariance functions of this model, computed based on the Littlewood-Paley wavelets, have unique maximizers in absolute values at each time scale. These maximizer can be considered as lead-lag parameters at each time scale. To estimate these parameters from discrete observation data, Hayashi and Koike (2018b) constructed objective functions mimicking behavior of the wavelet cross-covariance functions of the underlying model. Then, estimates of the scale-by-scale lead-lag parameters can be obtained by maximizing these objective functions in absolute values. 
</p>


<h3>Value</h3>

<p>If <code>verbose</code> is <code>FALSE</code>, a numeric vector with length <code>J</code>, corresponding to the estimated scale-by-scale lead-lag parameters, is returned. Note that their positive values indicate that the first process leads the second process. 
</p>
<p>Otherwise, an object of class <code>"yuima.wllag"</code>, which is a list with the following components, is returned:
</p>
<table role = "presentation">
<tr><td><code>lagtheta</code></td>
<td>
<p>the estimated scale-by-scale lead-lag parameters. The <code class="reqn">j</code> th component corresponds to the estimate at the level <code class="reqn">j</code>. A positive value indicates that the first process leads the second process.</p>
</td></tr>
<tr><td><code>obj.values</code></td>
<td>
<p>the values of the objective functions evaluated at the estimated lead-lag parameters.</p>
</td></tr>
<tr><td><code>obj.fun</code></td>
<td>
<p>a list of values of the objective functions. The <code class="reqn">j</code> th component of the list corresponds to a <code><a href="zoo.html#topic+zoo">zoo</a></code> object for values of the signed objective function at the level <code class="reqn">j</code> indexed by the search grid.</p>
</td></tr>
<tr><td><code>theta.hry</code></td>
<td>
<p>the lead-lag parameter estimate in the sense of Hoffmann, Rosenbaum and Yoshida (2013).</p>
</td></tr>
<tr><td><code>cor.hry</code></td>
<td>
<p>the correltion coefficient in the sense of Hoffmann, Rosenbaum and Yoshida (2013), evaluated at the estimated lead-lag parameter.</p>
</td></tr>
<tr><td><code>ccor.hry</code></td>
<td>
<p>a <code><a href="zoo.html#topic+zoo">zoo</a></code> object for values of the cross correltion function in the sense of Hoffmann, Rosenbaum and Yoshida (2013) indexed by the search grid.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Smaller levels correspond to finer time scales. In particular, the first level corresponds to the finest time resolution, which is defined by the argument <code>tau</code>.
</p>
<p>If there are multiple maximizers in an objective function, <code>wllag</code> takes a maximizer farthest from zero (if there are two such values, the function takes the negative one). This behavior is different from <code><a href="#topic+llag">llag</a></code>. 
</p>
<p>The objective functions themselves do NOT consitently estimate the corresponding wavelet covariance functions. This means that values in <code>obj.values</code> and <code>obj.fun</code> cannot be interpreted as covaraince estimates (their scales depend on the degree of non-synchronicity of observation times).  
</p>


<h3>Author(s)</h3>

<p>Yuta Koike with YUIMA Project Team
</p>


<h3>References</h3>

<p>Hayashi, T. and Koike, Y. (2018a).
Wavelet-based methods for high-frequency lead-lag analysis,
<em>SIAM Journal of Financial Mathematics</em>, <b>9</b>, 1208&ndash;1248.
</p>
<p>Hayashi, T. and Koike, Y. (2018b). 
Multi-scale analysis of lead-lag relationships in high-frequency financial markets. 
<a href="https://doi.org/10.48550/arXiv.1708.03992">doi:10.48550/arXiv.1708.03992</a>.
</p>
<p>Hoffmann, M., Rosenbaum, M. and Yoshida, N. (2013)
Estimation of the lead-lag parameter from non-synchronous data, 
<em>Bernoulli</em>, <b>19</b>, no. 2, 426&ndash;461.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simBmllag">simBmllag</a></code>, <code><a href="#topic+llag">llag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## An example from a simulation setting of Hayashi and Koike (2018b)
set.seed(123)

# Simulation of Bm driving the log-price processes
n &lt;- 15000
J &lt;- 13
tau &lt;- 1/2^(J+1)

rho &lt;- c(0.3,0.5,0.7,0.5,0.5,0.5,0.5,0.5)
theta &lt;- c(-1,-1, -2, -2, -3, -5, -7, -10) * tau

dB &lt;- simBmllag(n, J, rho, theta)

Time &lt;- seq(0, by = tau, length.out = n) # Time index
x &lt;- zoo(diffinv(dB[ ,1]), Time) # simulated path of the first process
y &lt;- zoo(diffinv(dB[ ,2]), Time) # simulated path of the second process

# Generate non-synchronously observed data
x &lt;- x[as.logical(rbinom(n + 1, size = 1, prob = 0.5))]
y &lt;- y[as.logical(rbinom(n + 1, size = 1, prob = 0.5))]

# Estimation of scale-by-scale lead-lag parameters (compare with theta/tau)
wllag(x, y, J = 8, tau = tau, tol = tau, in.tau = TRUE)
# Estimation with other information
out &lt;- wllag(x, y, tau = tau, tol = tau, in.tau = TRUE, verbose = TRUE)
out

# Plot of the HRY cross-correlation function
plot(out$ccor.hry, xlab = expression(theta), ylab = expression(U(theta))) 
dev.off()

# Plot of the objective functions
op &lt;- par(mfrow = c(4,2))
plot(out)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='ybook'>R code for the Yuima Book</h2><span id='topic+ybook'></span>

<h3>Description</h3>

<p>Shows the R code corresponding to each chapter in the Yuima Book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ybook(chapter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ybook_+3A_chapter">chapter</code></td>
<td>
<p>a number in 1:7</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an accessory function which open the R code corresponding to
Chapter &quot;chapter&quot; in the Yuima Book so that the reader can replicate
the code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ybook(1)
</code></pre>

<hr>
<h2 id='yuima-class'>Class for stochastic differential equations</h2><span id='topic+yuima-class'></span><span id='topic+get.zoo.data+2Cyuima-method'></span><span id='topic+plot+2Cyuima+2CANY-method'></span><span id='topic+dim+2Cyuima-method'></span><span id='topic+length+2Cyuima-method'></span><span id='topic+cce+2Cyuima-method'></span><span id='topic+llag+2Cyuima-method'></span><span id='topic+initialize+2Cyuima-method'></span><span id='topic+simulate+2Cyuima-method'></span><span id='topic+poisson.random.sampling+2Cyuima-method'></span><span id='topic+subsampling+2Cyuima-method'></span><span id='topic+ql+2Cyuima-method'></span><span id='topic+rql+2Cyuima-method'></span><span id='topic+ml.ql+2Cyuima-method'></span><span id='topic+limiting.gamma+2Cyuima-method'></span><span id='topic+LSE+2Cyuima-method'></span><span id='topic+cbind+2Cyuima+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>yuima</code> S4 class is a class of the <span class="pkg">yuima</span> package.
</p>


<h3>Details</h3>

<p>The <code>yuima-class</code> object is the main object of the <span class="pkg">yuima</span> package.
Some of the slots may be missing.
</p>
<p>The <code>data</code> slot contains the data, either empirical or simulated.
</p>
<p>The <code>model</code> contains the description of the
(statistical) model which is used to generate the <code>data</code> via different
simulation schemes, to draw inference from the <code>data</code> or both.
</p>
<p>The <code>sampling</code> slot contains information on how the <code>data</code> have been
collected or how they should be generated.
</p>
<p>The slot <code>characteristic</code> contains information on
<code>PLEASE FINISH THIS</code>.
The slot <code>functional</code> contains information on
<code>PLEASE FINISH THIS</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code></p>
</dd>
<dt><code>model</code>:</dt><dd><p>an object of class <code><a href="#topic+yuima.model-class">yuima.model-class</a></code></p>
</dd>
<dt><code>sampling</code>:</dt><dd><p>an object of class
<code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code></p>
</dd>
<dt><code>characteristic</code>:</dt><dd><p>an object of class
<code><a href="#topic+yuima.characteristic-class">yuima.characteristic-class</a></code></p>
</dd>
<dt><code>functional</code>:</dt><dd><p>an object of class
<code><a href="#topic+yuima.functional-class">yuima.functional-class</a></code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>new</dt><dd><p><code>signature(x = "yuima", data = "yuima.data",
	  model = "yuima.model", sampling = "yuima.sampling",
	  characteristic = "yuima.characteristic"</code>: the function makes a copy of
the prototype object from the class definition of
<code><a href="#topic+yuima-class">yuima-class</a></code>, then calls the <code>initialize</code> method
passing as arguments the newly created object and the remaining
arguments.</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(x = "yuima", data = "yuima.data",
	  model = "yuima.model", sampling = "yuima.sampling",
	  characteristic = "yuima.characteristic"</code>:  makes a copy of each argument
in the corresponding slots of the object <code>x</code>.</p>
</dd>
<dt>get.data</dt><dd><p><code>signature(x = "yuima")</code>: returns the content of the
slot <code>data</code>.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "yuima", ...)</code>: calls
<code><a href="base.html#topic+plot">plot</a></code> from the <code><a href="zoo.html#topic+zoo">zoo</a></code> package with argument
<code>x@data@zoo.data</code>. Additional arguments <code>...</code> are passed
as is to the <code><a href="base.html#topic+plot">plot</a></code> function.</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "yuima")</code>: the number of SDEs in the
<code>yuima</code> object.</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "yuima")</code>: a vector of length of
each SDE described in the <code>yuima</code> object.</p>
</dd>
<dt>cce</dt><dd><p><code>signature(x = "yuima")</code>: calculates the asyncronous
covariance estimator on the data contained in <code>x@data@zoo.data</code>.
For more details see <code><a href="#topic+cce">cce</a></code>.</p>
</dd>
<dt>llag</dt><dd><p><code>signature(x = "yuima")</code>: calculates the lead lag estimate
r on the data contained in <code>x@data@zoo.data</code>.
For more details see <code><a href="#topic+llag">llag</a></code>.</p>
</dd>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
<dt>cbind</dt><dd><p><code>signature(x = "yuima")</code>: bind yuima.data object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.ae-class'>Class for the asymptotic expansion of diffusion processes</h2><span id='topic+yuima.ae-class'></span><span id='topic+initialize+2Cyuima.ae-method'></span><span id='topic+plot+2Cyuima.ae+2CANY-method'></span>

<h3>Description</h3>

<p>The <code>yuima.ae</code> class is used to describe the output of the functions <code><a href="#topic+ae">ae</a></code> and <code><a href="#topic+aeMarginal">aeMarginal</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>order</code></dt><dd><p>integer. The order of the expansion.</p>
</dd>
<dt><code>var</code></dt><dd><p>character. The state variables.</p>
</dd>
<dt><code>u.var</code></dt><dd><p>character. The variables of the characteristic function.</p>
</dd>
<dt><code>eps.var</code></dt><dd><p>character. The perturbation variable.</p>
</dd>
<dt><code>characteristic</code></dt><dd><p>expression. The characteristic function.</p>
</dd>
<dt><code>density</code></dt><dd><p>expression. The probability density function.</p>
</dd>
<dt><code>Z0</code></dt><dd><p>numeric. The solution to the deterministic process obtained by setting the perturbation to zero.</p>
</dd>
<dt><code>Mu</code></dt><dd><p>numeric. The drift vector for the representation of Z1.</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>matrix. The diffusion matrix for the representation of Z1.</p>
</dd>
<dt><code>c.gamma</code></dt><dd><p>list. The coefficients of the Hermite polynomials.</p>
</dd>
<dt><code>h.gamma</code></dt><dd><p>list. Hermite polynomials.</p>
</dd>
</dl>

<hr>
<h2 id='yuima.carma-class'>Class for the mathematical description of CARMA(p,q) model</h2><span id='topic+yuima.carma-class'></span><span id='topic+initialize+2Cyuima.carma-method'></span><span id='topic+initialize+2Ccarma.info-method'></span><span id='topic+limiting.gamma+2Cyuima.carma-method'></span><span id='topic+simulate+2Cyuima.carma-method'></span>

<h3>Description</h3>

<p>The <code>yuima.carma</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>info</code>:</dt><dd><p>is an <code><a href="#topic+carma.info-class">carma.info-class</a></code> object that describes the structure of the CARMA(p,q) model.</p>
</dd>
<dt><code>drift</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the drift 
coefficient (a vector).</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the diffusion 
coefficient (a matrix).</p>
</dd>
<dt><code>hurst</code>:</dt><dd><p>the Hurst parameter of the gaussian noise. If 
<code>h=0.5</code>, the process is Wiener otherwise it is fractional Brownian 
motion with that precise value of the Hurst index. Can be set to <code>NA</code> for further specification.</p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>a vector of <code>expression</code>s for the jump 
component.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>Levy measure for jump variables.</p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>Type specification for Levy measures.</p>
</dd>
<dt>state.variable</dt><dd><p>a vector of names identifying the names used to 
denote the state variable in the drift and diffusion specifications.</p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>which is a short name for &ldquo;parameters&rdquo;, is an 
object of class <code><a href="#topic+model.parameter-class">model.parameter-class</a></code>. For more details see 
<code><a href="#topic+model.parameter-class">model.parameter-class</a></code> documentation page.</p>
</dd>
<dt><code>state.variable</code>:</dt><dd><p>identifies the state variables in the <span class="rlang"><b>R</b></span> 
expression.</p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>identifies the variable for the jump 
coefficient.</p>
</dd>
<dt><code>time.variable</code>:</dt><dd><p>the time variable.</p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>denotes the number of sources of noise. 
Currently only for the Gaussian part.</p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>denotes the dimension of the stochastic 
differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the dimensions of the parameter given in the 
<code>parameter</code> slot.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>identifies the variable with respect to which 
the stochastic differential equation has to be solved.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>contains the initial value of the stochastic 
differential equation.</p>
</dd>
<dt><code>J.flag</code>:</dt><dd><p>wheather jump.coeff include jump.variable.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
<dt>toLatex</dt><dd><p>This method converts an object of <code>yuima.carma-class</code> to character vectors with LaTeX markup.</p>
</dd>
<dt>CarmaNoise</dt><dd><p>Recovering underlying Levy. For more information see <code><a href="#topic+CarmaNoise">CarmaNoise</a></code>. </p>
</dd>
<dt>qmle</dt><dd><p>Quasi maximum likelihood estimation procedure. For more information see <code><a href="#topic+qmle">qmle</a></code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.carma.qmle-class'>Class for Quasi Maximum Likelihood Estimation of CARMA(p,q) model</h2><span id='topic+yuima.carma.qmle-class'></span><span id='topic+plot+2Cyuima.carma.qmle+2CANY-method'></span><span id='topic+qmle.carma'></span><span id='topic+carma.qmle'></span>

<h3>Description</h3>

<p>The <code>yuima.carma.qmle</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code>mle-class</code> of the <span class="pkg">stats4</span> package.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>Incr.Lev</code>:</dt><dd><p>is an object of class <code><a href="zoo.html#topic+zoo">zoo</a></code> that contains the estimated increments of the noise obtained using <code><a href="#topic+CarmaNoise">CarmaNoise</a></code>.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>.</p>
</dd>
<dt><code>logL.Incr</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains the value of the log-likelihood for estimated Levy increments.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated parameters.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated and fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>is an object of class <code>numeric</code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>is an object of class <code>function</code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>is an object of class <code>character</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p>Plot method for estimated increment of the noise.</p>
</dd>
<dt>Methods mle</dt><dd><p>All methods for <code>mle-class</code> are available.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.carmaHawkes-class'>Class for the mathematical description of a Hawkes process with a CARMA(p,q) intensity</h2><span id='topic+yuima.carmaHawkes-class'></span><span id='topic+initialize+2Cyuima.carmaHawkes-method'></span><span id='topic+initialize+2CcarmaHawkes.info-method'></span>

<h3>Description</h3>

<p>The <code>yuima.carmaHawkes</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>info</code>:</dt><dd><p>is an <code><a href="#topic+carmaHawkes.info-class">carmaHawkes.info-class</a></code> object that describes the structure of the CARMA(p,q) model.</p>
</dd>
<dt><code>drift</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the drift 
coefficient (a vector).</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the diffusion 
coefficient (a matrix).</p>
</dd>
<dt><code>hurst</code>:</dt><dd><p>the Hurst parameter of the gaussian noise. If 
<code>h=0.5</code>, the process is Wiener otherwise it is fractional Brownian 
motion with that precise value of the Hurst index. Can be set to <code>NA</code> for further specification.</p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>a vector of <code>expression</code>s for the jump 
component.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>Levy measure for jump variables.</p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>Type specification for Levy measures.</p>
</dd>
<dt>state.variable</dt><dd><p>a vector of names identifying the names used to 
denote the state variable in the drift and diffusion specifications.</p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>which is a short name for &ldquo;parameters&rdquo;, is an 
object of class <code><a href="#topic+model.parameter-class">model.parameter-class</a></code>. For more details see 
<code><a href="#topic+model.parameter-class">model.parameter-class</a></code> documentation page.</p>
</dd>
<dt><code>state.variable</code>:</dt><dd><p>identifies the state variables in the <span class="rlang"><b>R</b></span> 
expression.</p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>identifies the variable for the jump 
coefficient.</p>
</dd>
<dt><code>time.variable</code>:</dt><dd><p>the time variable.</p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>denotes the number of sources of noise. 
Currently only for the Gaussian part.</p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>denotes the dimension of the stochastic 
differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the dimensions of the parameter given in the 
<code>parameter</code> slot.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>identifies the variable with respect to which 
the stochastic differential equation has to be solved.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>contains the initial value of the stochastic 
differential equation.</p>
</dd>
<dt><code>J.flag</code>:</dt><dd><p>wheather jump.coeff include jump.variable.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='yuima.characteristic-class'>Classe for stochastic differential equations characteristic scheme</h2><span id='topic+yuima.characteristic-class'></span><span id='topic+initialize+2Cyuima.characteristic-method'></span>

<h3>Description</h3>

<p>The <code>yuima.characteristic</code> class is a class of the <span class="pkg">yuima</span> package.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>equation.number</code>:</dt><dd><p>The number of equations modeled in
the <code>yuima</code> object.</p>
</dd>
<dt><code>time.scale</code>:</dt><dd><p>The time scale assumed in the <code>yuima</code>
object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.cogarch-class'>Class for the mathematical description of CoGarch(p,q) model</h2><span id='topic+yuima.cogarch-class'></span><span id='topic+initialize+2Cyuima.cogarch-method'></span><span id='topic+initialize+2Ccogarch.info-method'></span><span id='topic+limiting.gamma+2Cyuima.cogarch-method'></span><span id='topic+simulate+2Cyuima.cogarch-method'></span>

<h3>Description</h3>

<p>The <code>yuima.cogarch</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the function <code><a href="#topic+setCogarch">setCogarch</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>info</code>:</dt><dd><p>is an <code><a href="#topic+cogarch.info-class">cogarch.info-class</a></code> object that describes the structure of the Cogarch(p,q) model.</p>
</dd>
<dt><code>drift</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the drift 
coefficient (a vector).</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the diffusion 
coefficient (a matrix).</p>
</dd>
<dt><code>hurst</code>:</dt><dd><p>the Hurst parameter of the gaussian noise. </p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>a vector of <code>"expressions"</code> for the jump component. </p>
</dd>
<dt><code>measure</code>:</dt><dd><p>Levy measure for the jump component. </p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>Type of specification for Levy measure </p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>is an object of class <code><a href="#topic+model.parameter-class">model.parameter-class</a></code>. </p>
</dd>
<dt><code>state.variable</code>:</dt><dd><p>the state variable. </p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>the jump variable. </p>
</dd>
<dt><code>time.variable</code>:</dt><dd><p>the time variable. </p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>dimension of the stochastic differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>number of parameters. </p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>the solve variable</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>Object of class <code>"expression"</code> that contains the starting function for the SDE. </p>
</dd>
<dt><code>J.flag</code>:</dt><dd><p>wheather jump.coeff include jump.variable.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+yuima.model-class">yuima.model</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see <code><a href="#topic+simulate">simulate</a></code> </p>
</dd>
<dt>toLatex</dt><dd><p>This method converts an object of <code>yuima.cogarch-class</code> to character vectors with LaTeX markup.
</p>
</dd>
<dt>qmle</dt><dd><p>Quasi maximum likelihood estimation procedure. For more information see <code><a href="#topic+qmle">qmle</a></code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.CP.qmle-class'>Class for Quasi Maximum Likelihood Estimation of Compound Poisson-based and SDE models</h2><span id='topic+yuima.CP.qmle-class'></span><span id='topic+yuima.qmle-class'></span><span id='topic+plot+2Cyuima.CP.qmle+2CANY-method'></span><span id='topic+qmle.CP'></span><span id='topic+CP.qmle'></span>

<h3>Description</h3>

<p>The <code>yuima.CP.qmle</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code>mle-class</code> of the <span class="pkg">stats4</span> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Jump.times</code>:</dt><dd><p>a vector which contains the estimated time of jumps.</p>
</dd>
<dt><code>Jump.values</code>:</dt><dd><p>a vector which contains the jumps.</p>
</dd>
<dt><code>X.values</code>:</dt><dd><p>the value of the process at the jump times.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated parameters.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated and fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>is an object of class <code>numeric</code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>is an object of class <code>function</code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>is an object of class <code>character</code>.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of class <code>yuima.model-class</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p>Plot method for plotting the jump times.</p>
</dd>
<dt>Methods mle</dt><dd><p>All methods for <code>mle-class</code> are available.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.data-class'>Class &quot;yuima.data&quot; for the data slot of a &quot;yuima&quot; class object</h2><span id='topic+yuima.data-class'></span><span id='topic+get.zoo.data+2Cyuima.data-method'></span><span id='topic+plot+2Cyuima.data+2CANY-method'></span><span id='topic+dim+2Cyuima.data-method'></span><span id='topic+length+2Cyuima.data-method'></span><span id='topic+cce+2Cyuima.data-method'></span><span id='topic+llag+2Cyuima.data-method'></span><span id='topic+initialize+2Cyuima.data-method'></span><span id='topic+poisson.random.sampling+2Cyuima.data-method'></span><span id='topic+subsampling+2Cyuima.data-method'></span><span id='topic+cbind.yuima+2Cyuima.data-method'></span>

<h3>Description</h3>

<p>The <code>yuima.data-class</code> is a class of the <span class="pkg">yuima</span> package used to store 
the data which are hold in the slot <code>data</code> of an object of
the <code>yuima-class</code>.   
</p>
<p>Objects from this class contain either true data or simulated data.
</p>


<h3>Details</h3>

<p>Objects in this class are created or initialized using the 
methods <code>new</code> or <code>initialize</code> or via the function <code><a href="#topic+setData">setData</a></code>. 
The preferred way to construct an object in this class is to use the function
<code><a href="#topic+setData">setData</a></code>.
</p>
<p>Objects in this class are used to store 
the data which are hold in the slot <code>data</code> of an object of
the <code>yuima-class</code>.   
</p>
<p>Objects in this class contain two slots described here. 
</p>

<dl>
<dt><code>original.data</code>:</dt><dd><p>The slot <code>original.data</code> contains, as the 
name suggests, a copy of the original data passed by the user to methods 
<code>new</code> or <code>initialize</code> or to the function <code><a href="#topic+setData">setData</a></code>. 
It is intended for backup purposes.</p>
</dd>
<dt><code>zoo.data</code>:</dt><dd><p>When a new object of this class is created or 
initialized using the <code>original.data</code>, the package tries to convert 
<code>original.data</code> into an object of class <code><a href="zoo.html#topic+zoo">zoo</a></code>. Once 
coerced to <code><a href="zoo.html#topic+zoo">zoo</a></code>, the data are stored in the slot <code>zoo.data</code>.
</p>
<p>If the conversion fails, the initialization or creation of the object fails.
</p>
<p>Internally, the <span class="pkg">yuima</span> package stores and operates on  
<code><a href="zoo.html#topic+zoo">zoo</a></code>-type objects.</p>
</dd>
</dl>

<p>If data are obtained by simulation, the <code>original.data</code> slot 
is usually empty.
</p>


<h3>Slots</h3>


<dl>
<dt><code>original.data</code>:</dt><dd><p>The original data.</p>
</dd>
<dt><code>zoo.data</code>:</dt><dd><p>A list of <code>zoo</code> format data.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>new</dt><dd><p><code>signature(x = "yuima.data", original.data)</code>: the function 
makes a copy of the prototype object from the class definition of
<code><a href="#topic+yuima.data-class">yuima.data-class</a></code>, then
calls the <code>initialize</code> method passing as arguments the newly created 
object and the <code>original.data</code>.</p>
</dd> 
<dt>initialize</dt><dd><p><code>signature(x = "yuima.data", original.data)</code>: makes
a copy of <code>original.data</code> into the slot <code>original.data</code> of 
<code>x</code> and tries to coerce <code>original.data</code> into an object of class
<code><a href="zoo.html#topic+zoo">zoo</a></code>. The result is put in the slot  <code>zoo.data</code> of 
<code>x</code>. If coercion fails, the <code>intialize</code> method fails as well.</p>
</dd>
<dt>get.zoo.data</dt><dd><p><code>signature(x = "yuima.data")</code>: returns the content
of the slot <code>zoo.data</code> of <code>x</code>.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "yuima.data",  ...)</code>: calls  
<code><a href="base.html#topic+plot">plot</a></code> from the <code><a href="zoo.html#topic+zoo">zoo</a></code> package with argument
<code>x@zoo.data</code>. Additional arguments <code>...</code> are passed
as is to the <code><a href="base.html#topic+plot">plot</a></code> function.</p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "yuima.data")</code>: calls  
<code><a href="#topic+dim">dim</a></code> from the <code><a href="zoo.html#topic+zoo">zoo</a></code> package with argument
<code>x@zoo.data</code>.</p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "yuima.data")</code>: calls  
<code><a href="#topic+length">length</a></code> from the <code><a href="zoo.html#topic+zoo">zoo</a></code> package with argument
<code>x@zoo.data</code>.</p>
</dd>
<dt>cce</dt><dd><p><code>signature(x = "yuima.data")</code>: calculates asyncronous
covariance estimator on the data contained in <code>x@zoo.data</code>. 
For more details see <code><a href="#topic+cce">cce</a></code>.</p>
</dd>
<dt>llag</dt><dd><p><code>signature(x = "yuima.data")</code>: calculates lead lag estimate
on the data contained in <code>x@zoo.data</code>. 
For more details see <code><a href="#topic+llag">llag</a></code>.</p>
</dd>   
<dt>cbind.yuima</dt><dd><p><code>signature(x = "yuima.data")</code>: bind yuima.data object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.functional-class'>Classes for stochastic differential equations data object</h2><span id='topic+yuima.functional-class'></span><span id='topic+getF+2Cyuima.functional-method'></span><span id='topic+getf+2Cyuima.functional-method'></span><span id='topic+getxinit+2Cyuima.functional-method'></span><span id='topic+gete+2Cyuima.functional-method'></span><span id='topic+initialize+2Cyuima.functional-method'></span>

<h3>Description</h3>

<p>The <code>yuima.functional</code> class is a class of the  <span class="pkg">yuima</span> package.  
</p>


<h3>Author(s)</h3>

<p>YUIMA Project</p>

<hr>
<h2 id='yuima.Hawkes'>Class for a mathematical description of a Point Process</h2><span id='topic+yuima.Hawkes'></span><span id='topic+yuima.Hawkes-class'></span><span id='topic+initialize+2Cyuima.Hawkes-method'></span><span id='topic+simulate+2Cyuima.Hawkes-method'></span>

<h3>Description</h3>

<p>The <code>yuima.Hawkes-class</code> is a class of the <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima.PPR-class">yuima.PPR-class</a></code>. The object of this class contains all the information about the Hawkes process with exponential kernel. 
</p>
<p>An object of this class can be created by calls of the function <code><a href="#topic+setHawkes">setHawkes</a></code>.
</p>

<hr>
<h2 id='yuima.Integral-class'>Class for the mathematical description of integral of a stochastic process</h2><span id='topic+yuima.Integral-class'></span><span id='topic+yuima.Integral'></span><span id='topic+initialize+2Cyuima.Integral-method'></span><span id='topic+simulate+2Cyuima.Integral-method'></span>

<h3>Description</h3>

<p>The <code>yuima.Integral</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima-class">yuima-class</a></code> it represents a integral of a stochastic process
</p>
<p><code> zt = int^{t}_0 h(theta, Xs, s) dXs</code>
</p>


<h3>Slots</h3>

<p>In the following we report the the additional slots of an object of class <code>yuima.Integral</code> with respect to the <code><a href="#topic+yuima-class">yuima-class</a></code>:
</p>

<dl>
<dt><code>Integral</code>:</dt><dd><p>It is an object of class <code>Integral.sde</code> and it is composed by the following slots:
</p>

<dl>
<dt><code>param.Integral</code>:</dt><dd><p>it is an object of class <code>param.Integral</code> and it is composed by the following slots:
</p>

<dl>
<dt><code>allparam</code>:</dt><dd><p>labels of all parameters (model and  integral).</p>
</dd>
<dt><code>common</code>:</dt><dd><p>common parameters.</p>
</dd>
<dt><code>Integrandparam</code>:</dt><dd><p>labels of all parameters only in the integral.</p>
</dd>
</dl>

</dd>
<dt><code>variable.Integral</code>:</dt><dd><p>it is an object of class <code>variable.Integral</code> and it is composed by the following slots:
</p>

<dl>
<dt><code>var.dx</code>:</dt><dd><p>integral variable.</p>
</dd>
<dt><code>lower.var</code>:</dt><dd><p>lower bound of support.</p>
</dd>
<dt><code>upper.var</code>:</dt><dd><p>upper bound of support.</p>
</dd>
<dt><code>out.var</code>:</dt><dd><p>labels of output.</p>
</dd>
<dt><code>var.time</code>:</dt><dd><p>label of time.</p>
</dd>
</dl>

</dd>
<dt><code>Integrand</code>:</dt><dd><p>it is an object of class <code>variable.Integral</code> and it is composed by the following slots:
</p>

<dl>
<dt><code>IntegrandList</code>:</dt><dd><p>It is a <code>list</code> that contains the components of integrand <code>h(theta, Xs, s)</code>.</p>
</dd>
<dt><code>dimIntegrand</code>:</dt><dd><p>a <code>numeric</code> object that is the dimensions of the output.</p>
</dd>
</dl>

</dd>
</dl>

</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
</dl>


<hr>
<h2 id='yuima.law-class'><code>yuima law-class</code>: A mathematical description for the noise.</h2><span id='topic+yuima.law-class'></span><span id='topic+yuima.law'></span><span id='topic+initialize+2Cyuima.law-method'></span><span id='topic+rand+2Cyuima.law-method'></span><span id='topic+dens+2Cyuima.law-method'></span><span id='topic+cdf+2Cyuima.law-method'></span><span id='topic+quant+2Cyuima.law-method'></span><span id='topic+char+2Cyuima.law-method'></span>

<h3>Description</h3>

<p>A yuima class that contains all information on the noise. This class is a  bridge between a <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> and a noise constructed by users.</p>


<h3>Slots</h3>


<dl>
<dt>rng</dt><dd>
<p>A user defined function that generates the noise sample.</p>
</dd>
<dt>density</dt><dd>
<p>A user defined function that is the density of the noise at time <code>t</code>.</p>
</dd>
<dt>cdf</dt><dd>
<p>A user defined function that is the cumulative distribution function of the noise at time <code>t</code>.</p>
</dd>
<dt>quantile</dt><dd><p>A user defined function that is the quantile of the noise at time <code>t</code>.</p>
</dd>
<dt>characteristic</dt><dd>
<p>A user defined function that is the characteristic function of the noise at time <code>t</code>.
</p>
</dd>
<dt>param.measure</dt><dd><p>A <code>character</code> object that contains the parameters of the noise.</p>
</dd>
<dt>time.var</dt><dd>
<p>the label of the time variable.</p>
</dd>
<dt>dim</dt><dd>
<p>Dimension of the noise</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>rand</dt><dd><p><code>signature(object = "yuima.law", n = "numeric",
	  param = "list", ...)</code>: This method returns a sample of the noise, <code>n</code> is the sample size.</p>
</dd>
<dt>dens</dt><dd><p><code>signature(object = "yuima.law", x = "numeric",
	  param = "list", log = FALSE, ...)</code>: This method returns the density of the noise, <code>x</code> is the vector of the support.</p>
</dd>
<dt>cdf</dt><dd><p><code>signature(object = "yuima.law", q = "numeric",
	  param = "list", ...)</code>: This method returns the cdf of the noise, <code>q</code> is the vector of the support.</p>
</dd>
<dt>quant</dt><dd><p><code>signature(object = "yuima.law", p = "numeric",
	  param = "list", ...)</code>: This method returns the quantile of the noise, <code>p</code> is the vector of the support.</p>
</dd>
<dt>char</dt><dd><p><code>signature(object = "yuima.law", u = "numeric",
	  param = "list", ...)</code>: This method returns the characteristic function of the noise, <code>u</code> is the vector of the support.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='yuima.LevyRM-class'><code>yuima.LevyRM</code>: A class for the mathematical description of the t-Student regression model.</h2><span id='topic+yuima.LevyRM-class'></span><span id='topic+yuima.LevyRM'></span><span id='topic+initialize+2Cyuima.LevyRM-method'></span><span id='topic+simulate+2Cyuima.LevyRM-method'></span><span id='topic+estimation_RLM+2Cyuima.LevyRM-function'></span>

<h3>Description</h3>

<p>A yuima class that contains all information on the regression model with t-student Levy process noise. This class extends <code><a href="#topic+yuima-class">yuima-class</a></code> and contains information on the regressors used in the definition of the model. The regressors are represented by an object of <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.
</p>
<p>An object of this class can be created by calls of the function <code><a href="#topic+setLRM">setLRM</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p>Initialize method. It makes a copy of each argument.</p>
</dd>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

<hr>
<h2 id='yuima.Map-class'>Class for the mathematical description of function of a stochastic process</h2><span id='topic+yuima.Map-class'></span><span id='topic+yuima.Map'></span><span id='topic+initialize+2Cyuima.Map-method'></span><span id='topic+simulate+2Cyuima.Map-method'></span>

<h3>Description</h3>

<p>The <code>yuima.Map</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima-class">yuima-class</a></code> it represents a map of a stochastic process
</p>
<p><code> zt = g(theta, Xt, t) : R^{q x d x 1} -&gt; R^{l1 x l2 x ...}</code>
</p>
<p>or an operator between two independent stochasic process:
</p>
<p><code> zt = h(theta, Xt, Yt, t)</code>
</p>
<p>where <code>Xt</code> and <code>Yt</code>  are object of class <code><a href="#topic+yuima.model-class">yuima.model-class</a></code> or <code><a href="#topic+yuima-class">yuima-class</a></code> with the same dimension.
</p>


<h3>Slots</h3>

<p>Here we report the additional slots of an object of class <code>yuima.Map</code> with respect to the <code><a href="#topic+yuima-class">yuima-class</a></code>:
</p>

<dl>
<dt><code>Output</code>:</dt><dd><p>It is an object of class <code>info.Map</code> and it is composed by the following slots:
</p>

<dl>
<dt><code>formula</code>:</dt><dd><p>It is a <code>vector</code> that contains the components of map <code>g(theta, Xt, t)</code> or the operator <code>h(theta, Xt, Yt, t)</code> </p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>a <code>numeric</code> object that is the dimensions of the Map.</p>
</dd>
<dt><code>type</code>:</dt><dd><p>If <code>type = "Maps"</code>, the Map is a map of stochastic process, If <code>type = "Operator"</code>, the result is an operator between two independent stochastic process</p>
</dd>
<dt><code>param</code></dt><dd><p>it is an object of class <code>param.Map</code> and it is composed by the following slots:
</p>

<dl>
<dt><code>out.var</code>:</dt><dd><p>labels for Map.</p>
</dd>
<dt><code>allparam</code>:</dt><dd><p>labels of all parameters (model and  map/operators).</p>
</dd>
<dt><code>allparamMap</code>:</dt><dd><p>labels of map/operator parameters.</p>
</dd>
<dt><code>common</code>:</dt><dd><p>common parameters.</p>
</dd>
<dt><code>Input.var</code>:</dt><dd><p>labels for inputs.</p>
</dd>
<dt><code>time.var</code>:</dt><dd><p>label for time variable.</p>
</dd>
</dl>

</dd>
</dl>

</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.model-class'>Classes for the mathematical description of stochastic differential equations</h2><span id='topic+yuima.model-class'></span><span id='topic+yuima.model'></span><span id='topic+initialize+2Cyuima.model-method'></span><span id='topic+initialize+2Cmodel.parameter-method'></span><span id='topic+limiting.gamma+2Cyuima.model-method'></span><span id='topic+simulate+2Cyuima.model-method'></span>

<h3>Description</h3>

<p>The <code>yuima.model</code> class is a class of the  <span class="pkg">yuima</span> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>drift</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the drift
coefficient (a vector).</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>is an <span class="rlang"><b>R</b></span> expression which specifies the diffusion
coefficient (a matrix).</p>
</dd>
<dt><code>hurst</code>:</dt><dd><p>the Hurst parameter of the gaussian noise. If
<code>h=0.5</code>, the process is Wiener otherwise it is fractional Brownian
motion with that precise value of the Hurst index. Can be set to <code>NA</code> for further specification.</p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>a matrix of <code>expression</code>s for the jump
component.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>Levy measure for jump variables.</p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>Type specification for Levy measures.</p>
</dd>
<dt>state.variable</dt><dd><p>a vector of names identifying the names used to
denote the state variable in the drift and diffusion specifications.</p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>which is a short name for &ldquo;parameters&rdquo;, is an
object of class <code><a href="#topic+model.parameter-class">model.parameter-class</a></code>. For more details see
<code><a href="#topic+model.parameter-class">model.parameter-class</a></code> documentation page.</p>
</dd>
<dt><code>state.variable</code>:</dt><dd><p>identifies the state variables in the <span class="rlang"><b>R</b></span>
expression.</p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>identifies the variable for the jump
coefficient.</p>
</dd>
<dt><code>time.variable</code>:</dt><dd><p>the time variable.</p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>denotes the number of sources of noise.
Currently only for the Gaussian part.</p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>denotes the dimension of the stochastic
differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the dimensions of the parameter given in the
<code>parameter</code> slot.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>identifies the variable with respect to which
the stochastic differential equation has to be solved.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>contains the initial value of the stochastic
differential equation.</p>
</dd>
<dt><code>J.flag</code>:</dt><dd><p>wheather jump.coeff include jump.variable.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.multimodel-class'>Class for the mathematical description of Multi dimensional Jump Diffusion processes</h2><span id='topic+yuima.multimodel-class'></span><span id='topic+yuima.multimodel'></span><span id='topic+initialize+2Cyuima.multimodel-method'></span><span id='topic+simulate+2Cyuima.multimodel-method'></span>

<h3>Description</h3>

<p>The <code>yuima.multimodel</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>drift</code>:</dt><dd><p>always <code>expression((0))</code>.</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>a list of <code>expression((0))</code>.</p>
</dd>
<dt><code>hurst</code>:</dt><dd><p>always <code>h=0.5</code>, but ignored for this model.</p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>set according to <code>scale</code> in <code><a href="#topic+setPoisson">setPoisson</a></code>.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>a list containting the intensity measure and the jump distribution.</p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>always <code>"CP"</code>.</p>
</dd>
<dt>state.variable</dt><dd><p>a vector of names identifying the names used to
denote the state variable in the drift and diffusion specifications.</p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>which is a short name for &ldquo;parameters&rdquo;, is an
object of class <code><a href="#topic+model.parameter-class">model.parameter-class</a></code>. For more details see
<code><a href="#topic+model.parameter-class">model.parameter-class</a></code> documentation page.</p>
</dd>
<dt><code>state.variable</code>:</dt><dd><p>identifies the state variables in the <span class="rlang"><b>R</b></span>
expression.</p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>identifies the variable for the jump
coefficient.</p>
</dd>
<dt><code>time.variable</code>:</dt><dd><p>the time variable.</p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>denotes the number of sources of noise.</p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>denotes the dimension of the stochastic
differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the dimensions of the parameter given in the
<code>parameter</code> slot.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>identifies the variable with respect to which
the stochastic differential equation has to be solved.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>contains the initial value of the stochastic
differential equation.</p>
</dd>
<dt><code>J.flag</code>:</dt><dd><p>wheather jump.coeff include jump.variable.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
<dt>qmle</dt><dd><p>Quasi maximum likelihood estimation procedure. For more information see <code><a href="#topic+qmle">qmle</a></code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# We define the density function of the underlying Levy

dmyexp &lt;- function(z, sig1, sig2, sig3){
  rep(0,3)
}

# We define the random number generator

rmyexp &lt;- function(z, sig1, sig2, sig3){
  cbind(rnorm(z,0,sig1), rgamma(z,1,sig2), rnorm(z,0,sig3))
}

# Model Definition: in this case we consider only a multi
# compound poisson process with a common intensity as underlying
# noise

mod &lt;- setModel(drift = matrix(c("0","0","0"),3,1), diffusion = NULL,
  jump.coeff = matrix(c("1","0","0","0","1","-1","1","0","0"),3,3),
  measure = list( intensity = "lambda1", df = "dmyexp(z,sig1,sig2,sig3)"),
  jump.variable = c("z"), measure.type=c("CP"),
  solve.variable=c("X1","X2","X3"))

# Sample scheme

samp&lt;-setSampling(0,100,n=1000)
param &lt;- list(lambda1 = 1, sig1 = 0.1, sig2 = 0.1, sig3 = 0.1)

# Simulation

traj &lt;- simulate(object = mod, sampling = samp,
  true.parameter = param)

# Plot

plot(traj, main = " driven noise. Multidimensional CP",
  cex.main = 0.8)

# We construct a multidimensional SDE driven by a multivariate
# levy process without CP components.

# Definition multivariate density

dmyexp1 &lt;- function(z, sig1, sig2, sig3){
  rep(0,3)
}

# Definition of random number generator
# In this case user must define the delta parameter in order to
# control the effect of time interval in the simulation.

rmyexp1 &lt;- function(z, sig1, sig2, sig3, delta){
  cbind(rexp(z,sig1*delta), rgamma(z,1*delta,sig2), rexp(z,sig3*delta))
}

# Model defintion

mod1 &lt;- setModel(drift=matrix(c("0.1*(0.01-X1)",
  "0.05*(1-X2)","0.1*(0.1-X3)"),3,1), diffusion=NULL,
   jump.coeff = matrix(c("0.01","0","0","0","0.01",
                          "0","0","0","0.01"),3,3),
   measure = list(df="dmyexp1(z,sig1,sig2,sig3)"),
   jump.variable = c("z"), measure.type=c("code"),
   solve.variable=c("X1","X2","X3"),xinit=c("10","1.2","10"))

# Simulation sample paths

samp&lt;-setSampling(0,100,n=1000)
param &lt;- list(sig1 = 1, sig2 = 1, sig3 = 1)

# Simulation

set.seed(1)
traj1 &lt;- simulate(object = mod1, sampling = samp,
  true.parameter = param)

# Plot

plot(traj1, main = "driven noise: multi Levy without CP",
  cex.main = 0.8)

# We construct a multidimensional SDE driven by a multivariate
# levy process.

# We consider a mixed situation where some
# noise are driven by a multivariate Compuond Poisson that
# shares a common intensity parameters.

### Multi Levy model

rmyexample2&lt;-function(z,sig1,sig2,sig3, delta){
    if(missing(delta)){
      delta&lt;-1
    }
    cbind(rexp(z,sig1*delta), rgamma(z,1*delta,sig2),
        rexp(z,sig3*delta), rep(1,z),
        rep(1,z))
}

dmyexample2&lt;-function(z,sig1,sig2,sig3){
  rep(0,5)
}

# Definition Model

mod2 &lt;- setModel(drift=matrix(c("0.1*(0.01-X1)",
  "0.05*(1-X2)","0.1*(0.1-X3)", "0", "0"),5,1), diffusion=NULL,
  jump.coeff = matrix(c("0.01","0","0","0","0",
                        "0","0.01","0","0","0",
                        "0","0","0.01","0","0",
                        "0","0","0","0.01","0",
                        "0","0","0","0","0.01"),5,5),
  measure = list(df = "dmyexample2(z,sig1,sig2,sig3)",
            intensity = "lambda1"),
  jump.variable = c("z"),
  measure.type=c("code","code","code","CP","CP"),
  solve.variable=c("X1","X2","X3","X4","X5"),
  xinit=c("10","1.2","10","0","0"))

# Simulation scheme
samp &lt;- setSampling(0, 100, n = 1000)
param &lt;- list(sig1 = 1, sig2 = 1, sig3 = 1, lambda1 = 1)

# Simulation

set.seed(1)
traj2 &lt;- simulate(object = mod2, sampling = samp,
  true.parameter = param)

plot(traj2, main = "driven noise: general multi Levy", cex.main = 0.8)


## End(Not run)
</code></pre>

<hr>
<h2 id='yuima.poisson-class'>Class for the mathematical description of Compound Poisson processes</h2><span id='topic+yuima.poisson-class'></span><span id='topic+initialize+2Cyuima.poisson-method'></span>

<h3>Description</h3>

<p>The <code>yuima.poisson</code> class is a class of the  <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>drift</code>:</dt><dd><p>always <code>expression((0))</code>.</p>
</dd>
<dt><code>diffusion</code>:</dt><dd><p>a list of <code>expression((0))</code>.</p>
</dd>
<dt><code>hurst</code>:</dt><dd><p>always <code>h=0.5</code>, but ignored for this model.</p>
</dd>
<dt><code>jump.coeff</code>:</dt><dd><p>set according to <code>scale</code> in <code><a href="#topic+setPoisson">setPoisson</a></code>.</p>
</dd>
<dt><code>measure</code>:</dt><dd><p>a list containting the intensity measure and the jump distribution.</p>
</dd>
<dt><code>measure.type</code>:</dt><dd><p>always <code>"CP"</code>.</p>
</dd>
<dt>state.variable</dt><dd><p>a vector of names identifying the names used to 
denote the state variable in the drift and diffusion specifications.</p>
</dd>
<dt><code>parameter</code>:</dt><dd><p>which is a short name for &ldquo;parameters&rdquo;, is an 
object of class <code><a href="#topic+model.parameter-class">model.parameter-class</a></code>. For more details see 
<code><a href="#topic+model.parameter-class">model.parameter-class</a></code> documentation page.</p>
</dd>
<dt><code>state.variable</code>:</dt><dd><p>identifies the state variables in the <span class="rlang"><b>R</b></span> 
expression.</p>
</dd>
<dt><code>jump.variable</code>:</dt><dd><p>identifies the variable for the jump 
coefficient.</p>
</dd>
<dt><code>time.variable</code>:</dt><dd><p>the time variable.</p>
</dd>
<dt><code>noise.number</code>:</dt><dd><p>denotes the number of sources of noise.</p>
</dd>
<dt><code>equation.number</code>:</dt><dd><p>denotes the dimension of the stochastic 
differential equation.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>the dimensions of the parameter given in the 
<code>parameter</code> slot.</p>
</dd>
<dt><code>solve.variable</code>:</dt><dd><p>identifies the variable with respect to which 
the stochastic differential equation has to be solved.</p>
</dd>
<dt><code>xinit</code>:</dt><dd><p>contains the initial value of the stochastic 
differential equation.</p>
</dd>
<dt><code>J.flag</code>:</dt><dd><p>wheather jump.coeff include jump.variable.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>simulate</dt><dd><p>simulation method. For more information see
<code><a href="#topic+simulate">simulate</a></code>.</p>
</dd>
<dt>qmle</dt><dd><p>Quasi maximum likelihood estimation procedure. For more information see <code><a href="#topic+qmle">qmle</a></code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.PPR'>Class for a mathematical description of a Point Process</h2><span id='topic+yuima.PPR'></span><span id='topic+yuima.PPR-class'></span><span id='topic+initialize+2Cyuima.PPR-method'></span><span id='topic+simulate+2Cyuima.PPR-method'></span>

<h3>Description</h3>

<p>The <code>yuima.PPR</code> class is a class of the <span class="pkg">yuima</span> package that extends the <code><a href="#topic+yuima-class">yuima-class</a></code>. The object of this class contains all the information about the Point Process Regression Model.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the function <code><a href="#topic+setPPR">setPPR</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>PPR</code>:</dt><dd><p>is an object of class <code><a href="#topic+info.PPR">info.PPR</a></code>.</p>
</dd>
<dt><code>gFun</code>:</dt><dd><p>is an object of class <code><a href="#topic+info.Map">info.Map</a></code>.</p>
</dd>
<dt><code>Kernel</code>:</dt><dd><p>is an object of class <code><a href="#topic+Integral.sde">Integral.sde</a></code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code>. The slot contain either true data or simulated data</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.model-class">yuima.model-class</a></code>. The slot contains all the information about the covariates</p>
</dd>
<dt><code>sampling</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.sampling-class">yuima.sampling-class</a></code>.</p>
</dd>
<dt><code>characteristic</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.characteristic-class">yuima.characteristic-class</a></code>.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.functional-class">yuima.functional-class</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.qmleLevy.incr'>Class for Quasi Maximum Likelihood Estimation of Levy SDE model</h2><span id='topic+yuima.qmleLevy.incr-class'></span><span id='topic+yuima.qmleLevy.incr+2CANY-method'></span><span id='topic+initialize+2Cyuima.qmleLevy.incr-method'></span><span id='topic+qmleLevy.incr'></span><span id='topic+incr.qmleLevy'></span>

<h3>Description</h3>

<p>The <code>yuima.qmleLevy.incr-class</code> is a class of the  <span class="pkg">yuima</span> package that extends the <code>mle-class</code> of the <span class="pkg">stats4</span> package.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>Incr.Lev</code>:</dt><dd><p>is an object of class <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> that contains the estimated increments of the noise.</p>
</dd>
<dt><code>logL.Incr</code>:</dt><dd><p>an numeric object that represents the value of the loglikelihood for the estimated Levy increments.</p>
</dd>
<dt><code>minusloglLevy</code>:</dt><dd><p>an R function that evaluates the loglikelihood of the estimated Levy increments. The function is used internally in <code><a href="#topic+qmleLevy">qmleLevy</a></code> for the estimation of the Levy measure parameters.</p>
</dd>
<dt><code>Levydetails</code>:</dt><dd><p>a <code>list</code> containing additional information about the optimization procedure in the estimation of the Levy measure parameters. See <code><a href="stats.html#topic+optim">optim</a></code> help for the meaning of the components of this <code>list</code>.</p>
</dd>
<dt><code>Data</code>:</dt><dd><p>is an object of <code><a href="#topic+yuima.data-class">yuima.data-class</a></code> containing observation data.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>is an object of of <code><a href="#topic+yuima.carma-class">yuima.carma-class</a></code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>is an object of class <code>language</code>. </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated parameters.</p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>is an object of class <code>numeric</code> that contains estimated and fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>is an object of class <code>matrix</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>is an object of class <code>numeric</code>.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>is an object of class <code>function</code>.</p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>an object of class <code>numeric</code>.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>is an object of class <code>character</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>Methods mle</dt><dd><p>All methods for <code>mle-class</code> are available.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.sampling-class'>Classes for stochastic differential equations sampling scheme</h2><span id='topic+yuima.sampling-class'></span><span id='topic+initialize+2Cyuima.sampling-method'></span>

<h3>Description</h3>

<p>The <code>yuima.sampling</code> class is a class of the <span class="pkg">yuima</span> package.  
</p>


<h3>Details</h3>

<p>This object is created by <code><a href="#topic+setSampling">setSampling</a></code> or as a result of a 
simulation scheme by the <code><a href="#topic+simulate">simulate</a></code> function or after
subsampling via the function <code><a href="#topic+subsampling">subsampling</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Initial</code>:</dt><dd><p>initial time of the grid.</p>
</dd>
<dt><code>Terminal</code>:</dt><dd><p>terminal time fo the grid.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>the number of observations - 1.</p>
</dd>
<dt><code>delta</code>:</dt><dd><p>in case of a regular grid is the mesh.</p>
</dd>
<dt><code>grid</code>:</dt><dd><p>the grid of times.</p>
</dd>
<dt><code>random</code>:</dt><dd><p>either <code>FALSE</code> or the distribution 
of the random times.</p>
</dd>
<dt><code>regular</code>:</dt><dd><p>indicator of whether the grid is regular or not.
For internal use only.</p>
</dd>
<dt><code>sdelta</code>:</dt><dd><p>in case of a regular space grid it is the mesh.</p>
</dd>
<dt><code>sgrid</code>:</dt><dd><p>the grid in space.</p>
</dd>
<dt><code>oindex</code>:</dt><dd><p>in case of interpolation, a vector of indexes 
corresponding to the original observations used for the approximation.</p>
</dd>
<dt><code>interpolation</code>:</dt><dd><p>the name of the interpolation method used.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.snr-class'>Class &quot;yuima.snr&quot; for self-normalized residuals of SDE &quot;yuima&quot; class object</h2><span id='topic+yuima.snr-class'></span><span id='topic+show+2Cyuima.snr-method'></span>

<h3>Description</h3>

<p>The <code>yuima.snr-class</code> is a class of the <span class="pkg">yuima</span> package used to store 
the calculatied self-normalized residuals of an SDEs.   
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>The original call.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>A <code>numeric</code> vector.</p>
</dd>
<dt><code>snr</code>:</dt><dd><p>A  <code>numeric</code> vector of residuals.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>A <code>yuima.model</code>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>print method</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team</p>

<hr>
<h2 id='yuima.th-class'><code>yuima.th-class</code>: A mathematical description for the t-Levy process.</h2><span id='topic+yuima.th-class'></span><span id='topic+yuima.th'></span><span id='topic+t-Levy+20process'></span><span id='topic+initialize+2Cyuima.th-method'></span><span id='topic+rand+2Cyuima.th-method'></span><span id='topic+dens+2Cyuima.th-method'></span><span id='topic+cdf+2Cyuima.th-method'></span><span id='topic+quant+2Cyuima.th-method'></span><span id='topic+char+2Cyuima.th-method'></span>

<h3>Description</h3>

<p>A yuima class that contains all information on the noise for t-Levy process. This class extends <code><a href="#topic+yuima.law-class">yuima.law-class</a></code> and contains info on the numerical method used for the inversion of the characteristic function. Three inversion methods are available: <code>cos</code>, <code>Laguerre</code> and <code>FFT</code>.
</p>
<p>An object of this class can be created by calls of the function <code><a href="#topic+setLaw_th">setLaw_th</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>rand</dt><dd><p><code>signature(object = "yuima.th", n = "numeric",
	  param = "list", ...)</code>: This method returns a sample of the noise, <code>n</code> is the sample size.</p>
</dd>
<dt>dens</dt><dd><p><code>signature(object = "yuima.th", x = "numeric",
	  param = "list", log = FALSE, ...)</code>: This method returns the density of the noise, <code>x</code> is the vector of the support.</p>
</dd>
<dt>cdf</dt><dd><p><code>signature(object = "yuima.th", q = "numeric",
	  param = "list", ...)</code>: This method returns the cdf of the noise, <code>q</code> is the vector of the support.</p>
</dd>
<dt>quant</dt><dd><p><code>signature(object = "yuima.th", p = "numeric",
	  param = "list", ...)</code>: This method returns the quantile of the noise, <code>p</code> is the vector of the support.</p>
</dd>
<dt>char</dt><dd><p><code>signature(object = "yuima.th", u = "numeric",
	  param = "list", ...)</code>: This method returns the characteristic function of the noise, <code>u</code> is the vector of the support.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>The YUIMA Project Team
</p>
<p>Contacts: Lorenzo Mercuri <a href="mailto:lorenzo.mercuri@unimi.it">lorenzo.mercuri@unimi.it</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
