<!DOCTYPE html><html><head><title>Help for package adaptiveGPCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adaptiveGPCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptiveGPCA-package'><p>adaptiveGPCA: A package for structured dimensionality reduction</p></a></li>
<li><a href='#adaptivegpca'><p>Adaptive gPCA</p></a></li>
<li><a href='#AntibioticPhyloseq'><p>Antibiotic time course experiment.</p></a></li>
<li><a href='#AntibioticSmall'><p>A subset of the antibiotic data</p></a></li>
<li><a href='#check_axes'><p>Check that the axes specified are valid</p></a></li>
<li><a href='#check_phyloseq'><p>Check compatibility of agpca and phyloseq objects</p></a></li>
<li><a href='#estimateComponents'><p>Estimate parameters in hierarchical model</p></a></li>
<li><a href='#estimateComponents2'><p>Estimate variance components</p></a></li>
<li><a href='#findReflection'><p>Find reflection</p></a></li>
<li><a href='#gpca'><p>gPCA</p></a></li>
<li><a href='#gpcaEvecs'><p>gPCA using pre-computed eidendecomposition</p></a></li>
<li><a href='#gpcaFullFamily'><p>Make a sequence of ordinations</p></a></li>
<li><a href='#gradLik'><p>Derivative of the likelihood</p></a></li>
<li><a href='#gradSigma2OfR'><p>Derivative of <code class="reqn">\sigma^2</code></p></a></li>
<li><a href='#inspectTaxonomy'><p>Shiny gadget for tree/taxonomy inspection</p></a></li>
<li><a href='#likelihood'><p>The likelihood at a given value of <code class="reqn">r</code> and <code class="reqn">\sigma</code></p></a></li>
<li><a href='#likelihood_two_params'><p>Likelihood of data in two-parameter model</p></a></li>
<li><a href='#likelihoodR'><p>The likelihood at a given value of <code class="reqn">r</code> and the maximizing <code class="reqn">\sigma</code> for</p>
that value of <code class="reqn">r</code>.</a></li>
<li><a href='#normalizeMatrix'><p>Normalizes a matrix.</p></a></li>
<li><a href='#plot.adaptivegpca'><p>Plot an adaptivegpca object</p></a></li>
<li><a href='#print.adaptivegpca'><p>Print an adaptivegpca object</p></a></li>
<li><a href='#processPhyloseq'><p>Make the input matrices for adaptive gPCA</p></a></li>
<li><a href='#sigma2OfR'><p>Value of <code class="reqn">\sigma^2</code> that maximizes the likelihood for a given value of</p>
<code class="reqn">r</code></a></li>
<li><a href='#varianceOnEvecs'><p>Variance along eigenvectors of Q</p></a></li>
<li><a href='#visualizeFullFamily'><p>Shiny gadget for adaptive gPCA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Adaptive Generalized PCA</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements adaptive gPCA, as described in: Fukuyama, J. (2017)
    &lt;<a href="https://doi.org/10.48550/arXiv.1702.00501">doi:10.48550/arXiv.1702.00501</a>&gt;. The package also includes functionality for applying
    the method to 'phyloseq' objects so that the method can be easily applied
    to microbiome data and a 'shiny' app for interactive visualization. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 3.1.4), ggplot2 (&ge; 1.0.0), shiny (&ge; 1.0.0), phyloseq
(&ge; 1.14.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-07 20:37:35 UTC; jfukuyam</td>
</tr>
<tr>
<td>Author:</td>
<td>Julia Fukuyama [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julia Fukuyama &lt;julia.fukuyama@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-08 11:42:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptiveGPCA-package'>adaptiveGPCA: A package for structured dimensionality reduction</h2><span id='topic+adaptiveGPCA-package'></span>

<h3>Description</h3>

<p>This package implements the methods for structured dimensionality
reduction described in
<a href="https://arxiv.org/abs/1702.00501">Fukuyama, J. (2017)</a>. The
general idea is to obtain a low-dimensional representation of the
data, similar to that given by PCA, which incorporates side
information about the relationships between the variables. The
output is similar to a PCA biplot, but the variable loadings are
regularized so that similar variables are encouraged to have
similar loadings on the principal axes.
</p>


<h3>Details</h3>

<p>There are two main ways of using this package. The function
<code><a href="#topic+adaptivegpca">adaptivegpca</a></code> will choose how much to regularize the
variables according to the similarities between them, while the
function <code><a href="#topic+gpcaFullFamily">gpcaFullFamily</a></code> produces analogous output for
a range of regularization parameters. With this function, the
results for the different regularization parameters are inspected
with the <code><a href="#topic+visualizeFullFamily">visualizeFullFamily</a></code> function, and the
desired parameter is chosen manually.
</p>
<p>The package also contains functionality to integrate with phyloseq:
the function <code><a href="#topic+processPhyloseq">processPhyloseq</a></code> takes a
<code><a href="phyloseq.html#topic+phyloseq">phyloseq</a></code> object and creates the inputs
necessary to perform adaptive gPCA on a microbiome dataset
including information about the phylogenetic relationships between
the bacteria.
</p>

<hr>
<h2 id='adaptivegpca'>Adaptive gPCA</h2><span id='topic+adaptivegpca'></span>

<h3>Description</h3>

<p>Performs adaptive generalized PCA, a dimensionality-reduction
method which takes into account similarities between the
variables. See <a href="https://arxiv.org/abs/1702.00501">Fukuyama,
J. (2017)</a> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptivegpca(X, Q, k = 2, weights = rep(1, nrow(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptivegpca_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">n \times p</code> data matrix.</p>
</td></tr>
<tr><td><code id="adaptivegpca_+3A_q">Q</code></td>
<td>
<p>A <code class="reqn">p \times p</code> similarity matrix on the variables defining
an inner product on the rows of <code>X</code>, can also be given as an
eigendecomposition (formatted as the output from <code>eigen</code>).</p>
</td></tr>
<tr><td><code id="adaptivegpca_+3A_k">k</code></td>
<td>
<p>The number of components to return.</p>
</td></tr>
<tr><td><code id="adaptivegpca_+3A_weights">weights</code></td>
<td>
<p>A vector of length <code class="reqn">n</code> containing weights for
the rows of <code>X</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the row/sample scores (<code>U</code>), the
variable loadings (<code>QV</code>), the proportion of variance explained
by each of the principal components (<code>vars</code>), the value of
<code class="reqn">r</code> that was used (<code>r</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticSmall)
out.agpca = adaptivegpca(AntibioticSmall$X, AntibioticSmall$Q, k = 2)
</code></pre>

<hr>
<h2 id='AntibioticPhyloseq'>Antibiotic time course experiment.</h2><span id='topic+AntibioticPhyloseq'></span>

<h3>Description</h3>

<p>A phyloseq object describing a time course experiment in which
three people two courses of cipro and had their gut microbiomes
sampled. See Dethlefsen and Relman, PNAS (2010), at
https://www.ncbi.nlm.nih.gov/pubmed/20847294 for more details.
</p>


<h3>Format</h3>

<p>A phyloseq object.</p>

<hr>
<h2 id='AntibioticSmall'>A subset of the antibiotic data</h2><span id='topic+AntibioticSmall'></span>

<h3>Description</h3>

<p>This is a smaller version of the <code>AntibioticPhyloseq</code> dataset,
for use in the examples so that the running time isn't so long. It
has the same samples and a randomly selected set of 200 of the
taxa. It is stored as a list with three components: the normalized
OTU abundances (<code>X</code>), the similarity matrix for the taxa
(<code>Q</code>), and the diagonal weight matrix (<code>D</code>, the identity
matrix).
</p>


<h3>Format</h3>

<p>A list with three components.</p>

<hr>
<h2 id='check_axes'>Check that the axes specified are valid</h2><span id='topic+check_axes'></span>

<h3>Description</h3>

<p>Check that the axes specified are valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_axes(axes, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_axes_+3A_axes">axes</code></td>
<td>
<p>A set of user-specified axes.</p>
</td></tr>
<tr><td><code id="check_axes_+3A_x">x</code></td>
<td>
<p>Object of class <code>adaptivegpca</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='check_phyloseq'>Check compatibility of agpca and phyloseq objects</h2><span id='topic+check_phyloseq'></span>

<h3>Description</h3>

<p>Check that the dimensions of the agpca object match the phyloseq
object and that the phyloseq object has a taxonomy table and a
phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_phyloseq(agpcafit, physeq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_phyloseq_+3A_agpcafit">agpcafit</code></td>
<td>
<p>An adaptivegpca object.</p>
</td></tr>
<tr><td><code id="check_phyloseq_+3A_physeq">physeq</code></td>
<td>
<p>A phyloseq object.</p>
</td></tr>
</table>

<hr>
<h2 id='estimateComponents'>Estimate parameters in hierarchical model</h2><span id='topic+estimateComponents'></span>

<h3>Description</h3>

<p>Estimates the values of <code class="reqn">r</code> and <code class="reqn">\sigma</code> in a model <code class="reqn">X \sim N(0, \sigma^2
(r Q + (1 - r)I))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateComponents(X, Q, Qeig = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateComponents_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix.</p>
</td></tr>
<tr><td><code id="estimateComponents_+3A_q">Q</code></td>
<td>
<p>A <code class="reqn">p \times p</code> matrix giving the prior variance on the
rows of <code>X</code>.</p>
</td></tr>
<tr><td><code id="estimateComponents_+3A_qeig">Qeig</code></td>
<td>
<p>If the eigendecomposition of <code>Q</code> is already computed, it
can be included here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code class="reqn">r</code> and <code class="reqn">\sigma</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticSmall)
estimateComponents(AntibioticSmall$X, AntibioticSmall$Q)
</code></pre>

<hr>
<h2 id='estimateComponents2'>Estimate variance components</h2><span id='topic+estimateComponents2'></span>

<h3>Description</h3>

<p>Estimate variance components in a two-parameter model where <code class="reqn">X \sim
N(0, \sigma^2 (r_1 Q + (1 - r_1) (r_2 Q^(-1) + (1 - r_2) I)))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateComponents2(X, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateComponents2_+3A_x">X</code></td>
<td>
<p>An n x p data matrix.</p>
</td></tr>
<tr><td><code id="estimateComponents2_+3A_q">Q</code></td>
<td>
<p>A p x p psd matrix giving the similarity between the
variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with r1 and r2
</p>

<hr>
<h2 id='findReflection'>Find reflection</h2><span id='topic+findReflection'></span>

<h3>Description</h3>

<p>Find a reflection of one data frame so that it most closely matches
another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findReflection(df1, df2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findReflection_+3A_df1">df1</code></td>
<td>
<p>The base data frame.</p>
</td></tr>
<tr><td><code id="findReflection_+3A_df2">df2</code></td>
<td>
<p>The data frame that will be reflected across either the
x-axis or the y-axis (or both or neither) so that the points in it
most closely match df1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>ncol(df1)</code>: Multiplying the first
column of df2 by the first element and multiplying the second
column of df2 by the second element and so on gives the optimal
reflection.
</p>

<hr>
<h2 id='gpca'>gPCA</h2><span id='topic+gpca'></span>

<h3>Description</h3>

<p>Performs standard gPCA with <code>k</code> components on a data matrix <code>X</code> with
row inner product <code>Q</code> and weights <code>D</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpca(X, Q, D = rep(1, nrow(X)), k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpca_+3A_x">X</code></td>
<td>
<p>A data matrix of size <code class="reqn">n \times p</code>.</p>
</td></tr>
<tr><td><code id="gpca_+3A_q">Q</code></td>
<td>
<p>An inner product matrix for the rows, either as a <code class="reqn">p
\times p</code> matrix or an eigendecomposition of such a matrix.</p>
</td></tr>
<tr><td><code id="gpca_+3A_d">D</code></td>
<td>
<p>Sample weights, a vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="gpca_+3A_k">k</code></td>
<td>
<p>The number of components to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with variable loadings on the principal axes
(<code>QV</code>), sample/row scores (<code>U</code>), the fraction of the
variance explained by each of the axes (<code>vars</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticSmall)
out.gpca = gpca(AntibioticSmall$X, AntibioticSmall$Q, k = 2)
</code></pre>

<hr>
<h2 id='gpcaEvecs'>gPCA using pre-computed eidendecomposition</h2><span id='topic+gpcaEvecs'></span>

<h3>Description</h3>

<p>Performs gPCA with pre-computed eigenvectors and eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpcaEvecs(X, evecs, evals, D = rep(1, nrow(X)), k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpcaEvecs_+3A_x">X</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="gpcaEvecs_+3A_evecs">evecs</code></td>
<td>
<p>Eigenvectors of <code>Q</code>, the inner product/similarity
matrix.</p>
</td></tr>
<tr><td><code id="gpcaEvecs_+3A_evals">evals</code></td>
<td>
<p>Eigenvalues of <code>Q</code>.</p>
</td></tr>
<tr><td><code id="gpcaEvecs_+3A_d">D</code></td>
<td>
<p>Sample weights</p>
</td></tr>
<tr><td><code id="gpcaEvecs_+3A_k">k</code></td>
<td>
<p>The number of components to return.</p>
</td></tr>
</table>

<hr>
<h2 id='gpcaFullFamily'>Make a sequence of ordinations</h2><span id='topic+gpcaFullFamily'></span>

<h3>Description</h3>

<p>Creates a sequence of gPCA data representations. One end of the
sequence (<code class="reqn">r = 0</code>) doesn't do any regularization according to
the variable structure (and so is just standard PCA), and the other
(<code class="reqn">r = 1</code>) does a maximal amount of regularization according to
the variable structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpcaFullFamily(X, Q, weights = rep(1, nrow(X)), k = 2, rvec = (0:100)/100,
  findReflections = TRUE, returnLong = FALSE, sampledata = NULL,
  variabledata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpcaFullFamily_+3A_x">X</code></td>
<td>
<p>A data matrix of size <code class="reqn">n \times p</code>.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_q">Q</code></td>
<td>
<p>A <code class="reqn">p \times p</code> similarity matrix defining an inner
product on the rows of <code>X</code>.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_weights">weights</code></td>
<td>
<p>A vector of weights for the rows of <code>X</code>.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_k">k</code></td>
<td>
<p>The number of components to compute for each ordination.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_rvec">rvec</code></td>
<td>
<p>The values of <code class="reqn">r</code> for which to make the ordinations.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_findreflections">findReflections</code></td>
<td>
<p>Whether or not flip the axes so as to make
neighboring ordinations as close as possible. If <code>k</code> is very
large this should be false since all possible axis combinations are
searched over.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_returnlong">returnLong</code></td>
<td>
<p>Return a long data frame with the
samples/variables instead of a list of data frames.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_sampledata">sampledata</code></td>
<td>
<p>Extra sample data to be included along with the
sample scores.</p>
</td></tr>
<tr><td><code id="gpcaFullFamily_+3A_variabledata">variabledata</code></td>
<td>
<p>Extra variable data to be included along with
the variable loadings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing elements for the sample points
(<code>locationList</code>), the species points (<code>speciesList</code>), and
the variance fractions (<code>varsList</code>). Each element is itself a
list of data frames (location/species points) or of vectors (for
the variances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticSmall)
out.ff = gpcaFullFamily(AntibioticSmall$X, AntibioticSmall$Q, k = 2)
</code></pre>

<hr>
<h2 id='gradLik'>Derivative of the likelihood</h2><span id='topic+gradLik'></span>

<h3>Description</h3>

<p>Derivative of the likelihood in the hierarchical model as a
function of <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradLik(Xtilde, r, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradLik_+3A_xtilde">Xtilde</code></td>
<td>
<p>The transformed data</p>
</td></tr>
<tr><td><code id="gradLik_+3A_r">r</code></td>
<td>
<p>r</p>
</td></tr>
<tr><td><code id="gradLik_+3A_d">D</code></td>
<td>
<p>The eigenvalues of Q</p>
</td></tr>
</table>

<hr>
<h2 id='gradSigma2OfR'>Derivative of <code class="reqn">\sigma^2</code></h2><span id='topic+gradSigma2OfR'></span>

<h3>Description</h3>

<p>Derivative of <code class="reqn">\sigma^2(r)</code> in the hierarchical model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradSigma2OfR(Xtilde, r, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradSigma2OfR_+3A_xtilde">Xtilde</code></td>
<td>
<p>The transformed data</p>
</td></tr>
<tr><td><code id="gradSigma2OfR_+3A_r">r</code></td>
<td>
<p>r</p>
</td></tr>
<tr><td><code id="gradSigma2OfR_+3A_d">D</code></td>
<td>
<p>The eigenvalues of Q</p>
</td></tr>
</table>

<hr>
<h2 id='inspectTaxonomy'>Shiny gadget for tree/taxonomy inspection</h2><span id='topic+inspectTaxonomy'></span>

<h3>Description</h3>

<p>Shiny gadget that allows users to visualize the scores of the taxa
on the agpca axes, their positions on the phylogenetic tree, and
their taxonomic assignments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspectTaxonomy(agpcafit, physeq, axes = c(1, 2), br.length = FALSE,
  height = 600)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspectTaxonomy_+3A_agpcafit">agpcafit</code></td>
<td>
<p>An agpca object, created either by the function
<code><a href="#topic+adaptivegpca">adaptivegpca</a></code> or by
<code><a href="#topic+visualizeFullFamily">visualizeFullFamily</a></code>.</p>
</td></tr>
<tr><td><code id="inspectTaxonomy_+3A_physeq">physeq</code></td>
<td>
<p>A phyloseq object with a tree and a taxonomy table.</p>
</td></tr>
<tr><td><code id="inspectTaxonomy_+3A_axes">axes</code></td>
<td>
<p>The axes to plot, must be a vector of two whole
numbers.</p>
</td></tr>
<tr><td><code id="inspectTaxonomy_+3A_br.length">br.length</code></td>
<td>
<p>Plot the tree with the branch lengths?</p>
</td></tr>
<tr><td><code id="inspectTaxonomy_+3A_height">height</code></td>
<td>
<p>The height, in pixels, of the plotting region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will open a browser window showing the tree
and the locations of the taxa on the selected agpca
axes. &quot;Brushing&quot; over the plot will highlight the positions of
the selected taxa on the tree and list their taxonomic
assignments. Clicking the &quot;done&quot; button will exit the app and
return a data frame containing the positions of the selected
taxa on the agpca axes, the taxonomic assignments of the
selected taxa, and their names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(AntibioticPhyloseq)
pp = processPhyloseq(AntibioticPhyloseq)
out.agpca = adaptivegpca(pp$X, pp$Q, k = 2)
treeInspect(out.agpca, AntibioticPhyloseq)

## End(Not run)
</code></pre>

<hr>
<h2 id='likelihood'>The likelihood at a given value of <code class="reqn">r</code> and <code class="reqn">\sigma</code></h2><span id='topic+likelihood'></span>

<h3>Description</h3>

<p>The likelihood at a given value of <code class="reqn">r</code> and <code class="reqn">\sigma</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood(Xtilde, sigma, r, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_+3A_xtilde">Xtilde</code></td>
<td>
<p>The transformed data</p>
</td></tr>
<tr><td><code id="likelihood_+3A_sigma">sigma</code></td>
<td>
<p>Overall scaling factor.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_r">r</code></td>
<td>
<p>r</p>
</td></tr>
<tr><td><code id="likelihood_+3A_d">D</code></td>
<td>
<p>The eigenvalues of Q</p>
</td></tr>
</table>

<hr>
<h2 id='likelihood_two_params'>Likelihood of data in two-parameter model</h2><span id='topic+likelihood_two_params'></span>

<h3>Description</h3>

<p>Likelihood of data in two-parameter model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood_two_params(r1, r2, Xtilde, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_two_params_+3A_r1">r1</code></td>
<td>
<p>Coefficient of Q</p>
</td></tr>
<tr><td><code id="likelihood_two_params_+3A_r2">r2</code></td>
<td>
<p>Coefficient of Q^(-1) in the noise part.</p>
</td></tr>
<tr><td><code id="likelihood_two_params_+3A_xtilde">Xtilde</code></td>
<td>
<p>The data projected onto the eigenvectors of Q.</p>
</td></tr>
<tr><td><code id="likelihood_two_params_+3A_d">D</code></td>
<td>
<p>The eigenvalues of Q</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The marginal likelihood of the data given r1 and r2.
</p>

<hr>
<h2 id='likelihoodR'>The likelihood at a given value of <code class="reqn">r</code> and the maximizing <code class="reqn">\sigma</code> for
that value of <code class="reqn">r</code>.</h2><span id='topic+likelihoodR'></span>

<h3>Description</h3>

<p>The likelihood at a given value of <code class="reqn">r</code> and the maximizing <code class="reqn">\sigma</code> for
that value of <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihoodR(Xtilde, r, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihoodR_+3A_xtilde">Xtilde</code></td>
<td>
<p>The transformed data</p>
</td></tr>
<tr><td><code id="likelihoodR_+3A_r">r</code></td>
<td>
<p>r</p>
</td></tr>
<tr><td><code id="likelihoodR_+3A_d">D</code></td>
<td>
<p>The eigenvalues of Q</p>
</td></tr>
</table>

<hr>
<h2 id='normalizeMatrix'>Normalizes a matrix.</h2><span id='topic+normalizeMatrix'></span>

<h3>Description</h3>

<p>Normalizes a count matrix X for correspondence analysis and returns
the corresponding metric. The normalization for X is as follows:
First the row sums of X are computed, giving the weights for each
sample. These weights are stored in a matrix D, which defines an
inner product on the columns of X. Then the vectors of counts
stored in the rows of X are replaced with proportions, and the
resulting matrix is centered according to the inner product defined
by D. Both the centered data matrix and D are returned to the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeMatrix(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeMatrix_+3A_x">X</code></td>
<td>
<p>The matrix to be normalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the normalized matrix (<code>Xtilde</code>) and the
row weights (<code>D</code>).
</p>

<hr>
<h2 id='plot.adaptivegpca'>Plot an adaptivegpca object</h2><span id='topic+plot.adaptivegpca'></span>

<h3>Description</h3>

<p>Plots the output from <code><a href="#topic+adaptivegpca">adaptivegpca</a></code>, either a scree
plot, the samples, or the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adaptivegpca'
plot(x, type = c("scree", "samples", "variables"),
  axes = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.adaptivegpca_+3A_x">x</code></td>
<td>
<p>An object of class <code>adaptivegpca</code></p>
</td></tr>
<tr><td><code id="plot.adaptivegpca_+3A_type">type</code></td>
<td>
<p>What type of plot to make. <code>scree</code> will make a
scree plot showing the eigenvalues, <code>samples</code> will plot
the samples, and <code>variables</code> will plot the variables.</p>
</td></tr>
<tr><td><code id="plot.adaptivegpca_+3A_axes">axes</code></td>
<td>
<p>Which axes to plot.</p>
</td></tr>
<tr><td><code id="plot.adaptivegpca_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticSmall)
out.agpca = adaptivegpca(AntibioticSmall$X, AntibioticSmall$Q, k = 2)
plot(out.agpca)
plot(out.agpca, type = "samples")
plot(out.agpca, type = "variables")
</code></pre>

<hr>
<h2 id='print.adaptivegpca'>Print an adaptivegpca object</h2><span id='topic+print.adaptivegpca'></span>

<h3>Description</h3>

<p>Print an adaptivegpca object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adaptivegpca'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.adaptivegpca_+3A_x">x</code></td>
<td>
<p><code>adaptivegpca</code> object.</p>
</td></tr>
<tr><td><code id="print.adaptivegpca_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='processPhyloseq'>Make the input matrices for adaptive gPCA</h2><span id='topic+processPhyloseq'></span>

<h3>Description</h3>

<p>Takes a phyloseq object and creates the matrices necessary to do
adaptive gPCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processPhyloseq(physeq, ca = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processPhyloseq_+3A_physeq">physeq</code></td>
<td>
<p>A <code><a href="phyloseq.html#topic+phyloseq">phyloseq</a></code> object, from the
phyloseq package.</p>
</td></tr>
<tr><td><code id="processPhyloseq_+3A_ca">ca</code></td>
<td>
<p>If TRUE, do the normalization as for correspondence
analysis (transform counts to relative abundances, compute sample
weights, center the relative abundances according to the sample
weights). Otherwise, simply center the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the matrix to perform adaptive gPCA on
(<code>X</code>), the species similarity matrix (<code>Q</code>), and the
sample weights (<code>weights</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticPhyloseq)
pp = processPhyloseq(AntibioticPhyloseq)
</code></pre>

<hr>
<h2 id='sigma2OfR'>Value of <code class="reqn">\sigma^2</code> that maximizes the likelihood for a given value of
<code class="reqn">r</code></h2><span id='topic+sigma2OfR'></span>

<h3>Description</h3>

<p>Value of <code class="reqn">\sigma^2</code> that maximizes the likelihood for a given value of
<code class="reqn">r</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma2OfR(Xtilde, r, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma2OfR_+3A_xtilde">Xtilde</code></td>
<td>
<p>The transformed data</p>
</td></tr>
<tr><td><code id="sigma2OfR_+3A_r">r</code></td>
<td>
<p>r</p>
</td></tr>
<tr><td><code id="sigma2OfR_+3A_d">D</code></td>
<td>
<p>The eigenvalues of Q</p>
</td></tr>
</table>

<hr>
<h2 id='varianceOnEvecs'>Variance along eigenvectors of Q</h2><span id='topic+varianceOnEvecs'></span>

<h3>Description</h3>

<p>Project the sample points stored in the rows of <code>X</code> along the
eigenvectors of <code>Q</code> and find the variance along each of the
projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varianceOnEvecs(X, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varianceOnEvecs_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix, each row corresponding to a sample.</p>
</td></tr>
<tr><td><code id="varianceOnEvecs_+3A_q">Q</code></td>
<td>
<p>A <code class="reqn">p \times p</code> similarity matrix, either as a matrix
or as its eigendecomposition (the output from <code>eigen</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the variance of the samples along each
of the eigenvectors of <code>Q</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AntibioticSmall)
voe = varianceOnEvecs(AntibioticSmall$X, AntibioticSmall$Q)
</code></pre>

<hr>
<h2 id='visualizeFullFamily'>Shiny gadget for adaptive gPCA</h2><span id='topic+visualizeFullFamily'></span>

<h3>Description</h3>

<p>Shiny gadget that shows the ordinations from an entire family of
gPCAs and returns a gPCA object with the one selected by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualizeFullFamily(fullFamily, sample_data = NULL,
  sample_mapping = aes_string(x = "Axis1", y = "Axis2"),
  sample_facet = NULL, var_data = NULL, var_mapping = aes_string(x =
  "Axis1", y = "Axis2"), layout = c(2, 6))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualizeFullFamily_+3A_fullfamily">fullFamily</code></td>
<td>
<p>The output from <code><a href="#topic+gpcaFullFamily">gpcaFullFamily</a></code></p>
</td></tr>
<tr><td><code id="visualizeFullFamily_+3A_sample_data">sample_data</code></td>
<td>
<p>Optional data used for plotting the samples</p>
</td></tr>
<tr><td><code id="visualizeFullFamily_+3A_sample_mapping">sample_mapping</code></td>
<td>
<p>An aesthetic mapping to be passed to
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> for plotting the samples</p>
</td></tr>
<tr><td><code id="visualizeFullFamily_+3A_sample_facet">sample_facet</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> faceting
command used for faceting the samples.</p>
</td></tr>
<tr><td><code id="visualizeFullFamily_+3A_var_data">var_data</code></td>
<td>
<p>Optional data used for plotting the variables</p>
</td></tr>
<tr><td><code id="visualizeFullFamily_+3A_var_mapping">var_mapping</code></td>
<td>
<p>An aesthetic mapping to be passed to
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> for plotting the variables</p>
</td></tr>
<tr><td><code id="visualizeFullFamily_+3A_layout">layout</code></td>
<td>
<p>A vector of length 2. The first number gives the
number of columns (out of 12) for the sidebar, the second number
gives the number of columns (out of 12) for the sample plot in the
main panel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will open a 'shiny' app in a browser
window. You can investigate the results for different values of
<code class="reqn">r</code> with this app. Once you press the 'done' button, the app
will close and the function will return an R object containing the
results for the value of <code class="reqn">r</code> (the regularization parameter)
that was chosen in the app. The returned object is a list
containing the variable loadings on the principal axes (<code>QV</code>),
the sample/row scores (<code>U</code>), and the fraction of the variance
explained by each of the axes (<code>vars</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(AntibioticPhyloseq)
pp = processPhyloseq(AntibioticPhyloseq)
out.ff = gpcaFullFamily(pp$X, Q = pp$Q, D = pp$D, k = 2)
out.agpca = visualizeFullFamily(out.ff,
    sample_data = sample_data(AntibioticPhyloseq),
    sample_mapping = aes(x = Axis1, y = Axis2, color = condition),
    var_data = tax_table(AntibioticPhyloseq),
    var_mapping = aes(x = Axis1, y = Axis2, color = Phylum))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
