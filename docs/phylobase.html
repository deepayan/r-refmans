<!DOCTYPE html><html><head><title>Help for package phylobase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phylobase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addData'><p>Adding data to a phylo4 or a phylo4d object</p></a></li>
<li><a href='#ancestor'><p>Tree traversal and utility functions</p></a></li>
<li><a href='#checkPhylo4'><p>Validity checking for phylo4 objects</p></a></li>
<li><a href='#edges'><p>Edges accessors</p></a></li>
<li><a href='#extractTree'><p>Get tree from tree+data object</p></a></li>
<li><a href='#formatData'><p>Format data for use in phylo4d objects</p></a></li>
<li><a href='#geospiza'><p>Data from Darwin's finches</p></a></li>
<li><a href='#getNode'><p>Node and Edge look-up functions</p></a></li>
<li><a href='#hasEdgeLength'><p>edgeLength methods</p></a></li>
<li><a href='#hasSingle'><p>Test trees for polytomies, inline nodes (singletons), or reticulation</p></a></li>
<li><a href='#hasTipData'><p>Tests for presence of data associated with trees stored as phylo4d objects</p></a></li>
<li><a href='#Import Nexus and Newick files'><p>Create a <code>phylo4</code>, <code>phylo4d</code> or <code>data.frame</code> object</p>
from a NEXUS or a Newick file</a></li>
<li><a href='#isRooted'><p>Methods to test, access (and modify) the root of a phylo4 object.</p></a></li>
<li><a href='#MRCA'><p>MRCA</p></a></li>
<li><a href='#multiPhylo-class'><p>multiPhylo4 and extended classes</p></a></li>
<li><a href='#nodeId'><p>nodeId methods</p></a></li>
<li><a href='#nTips'><p>nTips, nNodes, nEdges</p></a></li>
<li><a href='#owls4'><p>'Owls' data from ape</p></a></li>
<li><a href='#pdata'><p>Constructor for pdata (phylogenetic data) class</p></a></li>
<li><a href='#pdata-class'><p>Class &quot;pdata&quot;</p></a></li>
<li><a href='#phylo4-class'><p>The phylo4 class</p></a></li>
<li><a href='#phylo4-labels'><p>Labels for phylo4/phylo4d objects</p></a></li>
<li><a href='#phylo4-methods'><p>Create a phylogenetic tree</p></a></li>
<li><a href='#phylo4d-class'><p>phylo4d class</p></a></li>
<li><a href='#phylo4d-methods'><p>Combine a phylogenetic tree with data</p></a></li>
<li><a href='#phylobase-package'><p>Utilities and Tools for Phylogenetics</p></a></li>
<li><a href='#phylobase.options'><p>Set or return options of phylobase</p></a></li>
<li><a href='#phylobubbles'><p>Bubble plots for phylo4d objects</p></a></li>
<li><a href='#phylomat-class'><p>matrix classes for phylobase</p></a></li>
<li><a href='#phyloXXYY'><p>Calculate node x and y coordinates</p></a></li>
<li><a href='#plotOneTree'><p>Plot a phylo4 object</p></a></li>
<li><a href='#print'><p>print a phylogeny</p></a></li>
<li><a href='#reorder-methods'><p>reordering trees within phylobase objects</p></a></li>
<li><a href='#setAs'><p>Converting between phylo4/phylo4d and other phylogenetic tree</p>
formats</a></li>
<li><a href='#shortestPath'><p>shortestPath-methods</p></a></li>
<li><a href='#subset-methods'><p>Methods for creating subsets of phylogenies</p></a></li>
<li><a href='#summary-methods'><p>Summary for phylo4/phylo4d objects</p></a></li>
<li><a href='#tdata'><p>Retrieving or updating tip and node data in phylo4d objects</p></a></li>
<li><a href='#tip.data.plot'><p>Plotting trees and associated data</p></a></li>
<li><a href='#treePlot-methods'><p>Phylogeny plotting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Base Package for Phylogenetic Structures and Comparative Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.12</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, ape (&ge; 3.0), Rcpp (&ge; 0.11.0), rncl (&ge; 0.6.0), grid,
methods, stats, RNeXML</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, testthat (&ge; 0.8.1), knitr, rmarkdown</td>
</tr>
<tr>
<td>Author:</td>
<td>R Hackathon et al. (alphabetically: Ben Bolker, Marguerite Butler,
    Peter Cowan, Damien de Vienne, Dirk Eddelbuettel, Mark Holder, Thibaut
    Jombart, Steve Kembel, Francois Michonneau, David Orme, Brian O'Meara,
    Emmanuel Paradis, Jim Regetz, Derrick Zwickl)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francois Michonneau &lt;francois.michonneau@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a base S4 class for comparative methods, incorporating
    one or more trees and trait data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fmichonneau/phylobase">https://github.com/fmichonneau/phylobase</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fmichonneau/phylobase/issues">https://github.com/fmichonneau/phylobase/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'oldclasses-class.R' 'internal-constructors.R'
'phylo4-methods.R' 'RcppExports.R' 'checkdata.R'
'phylo4-class.R' 'getNode-methods.R' 'formatData.R'
'phylo4d-class.R' 'phylo4d-methods.R' 'MRCA-methods.R'
'addData-methods.R' 'ancestors.R' 'phylo4-accessors.R'
'root-methods.R' 'nodeId-methods.R' 'edgeLength-methods.R'
'setAs-methods.R' 'extractTree.R' 'labels-methods.R'
'multiphylo4-class.R' 'pdata.R' 'phylo4d-accessors.R'
'phylobase-package.R' 'phylobase.options.R' 'phylomats-class.R'
'print-methods.R' 'readNCL.R' 'reorder-methods.R'
'shortestPath-methods.R' 'subset-methods.R' 'summary-methods.R'
'tbind.R' 'tdata-methods.R' 'treePlot.R' 'treestruc.R' 'zzz.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 16:12:26 UTC; francois</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 00:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='addData'>Adding data to a phylo4 or a phylo4d object</h2><span id='topic+addData'></span><span id='topic+addData+2Cphylo4d-method'></span><span id='topic+addData-methods'></span><span id='topic+addData+2Cphylo4-method'></span>

<h3>Description</h3>

<p><code>addData</code> adds data to a <code>phylo4</code> (converting it in a
<code>phylo4d</code> object) or to a <code>phylo4d</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addData(x, ...)

## S4 method for signature 'phylo4d'
addData(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  merge.data = TRUE,
  pos = c("after", "before"),
  ...
)

## S4 method for signature 'phylo4'
addData(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  merge.data = TRUE,
  pos = c("after", "before"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addData_+3A_x">x</code></td>
<td>
<p>a phylo4 or a phylo4d object</p>
</td></tr>
<tr><td><code id="addData_+3A_...">...</code></td>
<td>
<p>additional arguments to control how matching between
data and tree (see Details section of
<code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> for more details).</p>
</td></tr>
<tr><td><code id="addData_+3A_tip.data">tip.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing only tip data</p>
</td></tr>
<tr><td><code id="addData_+3A_node.data">node.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing only node data</p>
</td></tr>
<tr><td><code id="addData_+3A_all.data">all.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing both tip and node data</p>
</td></tr>
<tr><td><code id="addData_+3A_merge.data">merge.data</code></td>
<td>
<p>if both <code>tip.data</code> and <code>node.data</code> are
provided, it determines whether columns with common names will be
merged together (default TRUE). If FALSE, columns with common
names will be preserved separately, with &quot;.tip&quot; and &quot;.node&quot;
appended to the names. This argument has no effect if
<code>tip.data</code> and <code>node.data</code> have no column names in
common.</p>
</td></tr>
<tr><td><code id="addData_+3A_pos">pos</code></td>
<td>
<p>should the new data provided be bound <code>before</code> or
<code>after</code> the pre-existing data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rules for matching data to tree nodes are identical to those used
by the <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor.
</p>
<p>If any column names in the original data are the same as columns
in the new data, &quot;.old&quot; is appended to the former column names and
&quot;.new&quot; is appended to the new column names.
</p>
<p>The option <code>pos</code> is ignored (silently) if <code>x</code> is a
<code>phylo4</code> object. It is provided for compatibility reasons.
</p>


<h3>Value</h3>

<p><code>addData</code> returns a <code>phylo4d</code> object.
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tdata">tdata</a></code> for extracting or updating data and
<code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(geospiza)
  nDt &lt;- data.frame(a=rnorm(nNodes(geospiza)), b=1:nNodes(geospiza),
                    row.names=nodeId(geospiza, "internal"))
  t1 &lt;- addData(geospiza, node.data=nDt)
</code></pre>

<hr>
<h2 id='ancestor'>Tree traversal and utility functions</h2><span id='topic+ancestor'></span><span id='topic+children'></span><span id='topic+descendants'></span><span id='topic+siblings'></span><span id='topic+ancestors'></span>

<h3>Description</h3>

<p>Functions for describing relationships among phylogenetic nodes (i.e.
internal nodes or tips).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestor(phy, node)

children(phy, node)

descendants(phy, node, type = c("tips", "children", "all", "ALL"))

siblings(phy, node, include.self = FALSE)

ancestors(phy, node, type = c("all", "parent", "ALL"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestor_+3A_phy">phy</code></td>
<td>
<p>a <a href="#topic+phylo4-class">phylo4</a> object (or one inheriting from
<a href="#topic+phylo4-class">phylo4</a>, e.g. a <a href="#topic+phylo4d-class">phylo4d</a> object)</p>
</td></tr>
<tr><td><code id="ancestor_+3A_node">node</code></td>
<td>
<p>either an integer corresponding to a node ID number, or a
character corresponding to a node label; for <code>ancestors</code> and
<code>descendants</code>, this may be a vector of multiple node numbers or names</p>
</td></tr>
<tr><td><code id="ancestor_+3A_type">type</code></td>
<td>
<p>(<code>ancestors</code>) specify whether to return just direct
ancestor (&quot;parent&quot;), all ancestor nodes (&quot;all&quot;), or all ancestor nodes
including self (&quot;ALL&quot;); (<code>descendants</code>) specify whether to return just
direct descendants (&quot;children&quot;), all extant descendants (&quot;tips&quot;), or all
descendant nodes (&quot;all&quot;) or all descendant nodes including self (&quot;ALL&quot;).</p>
</td></tr>
<tr><td><code id="ancestor_+3A_include.self">include.self</code></td>
<td>
<p>whether to include self in list of siblings</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ancestors</code> and <code>descendants</code> can take <code>node</code> vectors of
arbitrary length, returning a list of output vectors if the number of valid
input nodes is greater than one. List element names are taken directly from
the input node vector.
</p>
<p>If any supplied nodes are not found in the tree, the behavior currently
varies across functions.
</p>

<ul>
<li><p> Invalid nodes are automatically omitted by <code>ancestors</code>
and <code>descendants</code>, with a warning.
</p>
</li>
<li> <p><code>ancestor</code>
will return <code>NA</code> for any invalid nodes, with a warning.
</p>
</li>
<li><p> Both <code>children</code> and <code>siblings</code> will return an empty
vector, again with a warning.
</p>
</li></ul>



<h3>Value</h3>


<dl>
<dt><code>ancestors</code></dt><dd><p> return a named vector (or a list
of such vectors in the case of multiple input nodes) of the
ancestors and descendants of a node</p>
</dd>
<dt><code>descendants</code></dt><dd><p> return a named vector (or a list of
such vectors in the case of multiple input nodes) of the ancestors
and descendants of a node</p>
</dd>
<dt><code>ancestor</code></dt><dd> <p><code>ancestor</code> is analogous to
<code>ancestors(...{}, type="parent")</code> (i.e. direct ancestor
only), but returns a single concatenated vector in the case of
multiple input nodes</p>
</dd>
<dt><code>children</code></dt><dd><p>is analogous to <code>descendants(...{},
type="children")</code> (i.e. direct descendants only), but is not
currently intended to be used with multiple input nodes </p>
</dd>
<dt><code>siblings</code></dt><dd><p> returns sibling nodes (children of the same
parent)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="ape.html#topic+mrca">mrca</a></code>, in the ape package, gives a list of all
subtrees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(geospiza)
  nodeLabels(geospiza) &lt;- LETTERS[1:nNodes(geospiza)]
  plot(as(geospiza, "phylo4"), show.node.label=TRUE)
  ancestor(geospiza, "E")
  children(geospiza, "C")
  descendants(geospiza, "D", type="tips")
  descendants(geospiza, "D", type="all")
  ancestors(geospiza, "D")
  MRCA(geospiza, "conirostris", "difficilis", "fuliginosa")
  MRCA(geospiza, "olivacea", "conirostris")

  ## shortest path between 2 nodes
  shortestPath(geospiza, "fortis", "fuliginosa")
  shortestPath(geospiza, "F", "L")

  ## branch length from a tip to the root
  sumEdgeLength(geospiza, ancestors(geospiza, "fortis", type="ALL"))
</code></pre>

<hr>
<h2 id='checkPhylo4'>Validity checking for phylo4 objects</h2><span id='topic+checkPhylo4'></span><span id='topic+checkTree'></span><span id='topic+checkPhylo4Data'></span>

<h3>Description</h3>

<p>Basic checks on the validity of S4 phylogenetic objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPhylo4(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPhylo4_+3A_object">object</code></td>
<td>
<p>A prospective phylo4 or phylo4d object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As required by <code><a href="methods.html#topic+validObject">validObject</a></code>, returns an error
string (describing problems) or TRUE if everything is OK.
</p>


<h3>Note</h3>

<p>These functions are only intended to be called by other phylobase functions.
</p>
<p><code>checkPhylo4</code> is an (inflexible) wrapper for
<code>checkTree</code>.  The rules for <code>phylo4</code> objects essentially
follow those for <code>phylo</code> objects from the <code>ape</code> package,
which are in turn defined in
<a href="https://emmanuelparadis.github.io/misc/FormatTreeR.pdf">https://emmanuelparadis.github.io/misc/FormatTreeR.pdf</a>.
These are essentially that: </p>
 <ul>
<li><p> if the tree has edge
lengths defined, the number of edge lengths must match the number
of edges; </p>
</li>
<li><p> the number of tip labels must match the number of
tips; </p>
</li>
<li><p> in a tree with <code>ntips</code> tips and <code>nnodes</code>
(total) nodes, nodes 1 to <code>ntips</code> must be tips </p>
</li>
<li><p> if the
tree is rooted, the root must be node number <code>ntips+1</code> and
the root node must be the first row of the edge matrix </p>
</li>
<li><p> tip
labels, node labels, edge labels, edge lengths must have proper
internal names (i.e.  internal names that match the node numbers
they document) </p>
</li>
<li><p> tip and node labels must be unique </p>
</li></ul>

<p>You can alter some of the default options by using the function
<code>phylobase.options</code>.
</p>
<p>For <code>phylo4d</code> objects, <code>checkTree</code> also calls
<code>checkPhylo4Data</code> to check the validity of the data associated with the
tree. It ensures that (1) the data associated with the tree have the correct
dimensions, (2) that the row names for the data are correct.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker, Steven Kembel, Francois Michonneau
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+phylo4">phylo4</a></code> constructor and
<a href="#topic+phylo4-class">phylo4</a> class; the <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor
and the <a href="#topic+phylo4d-class">phylo4d</a> class do checks for the data
associated with trees.  See <code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code> for
translation functions and <code><a href="#topic+phylobase.options">phylobase.options</a> to change
some of the default options of the validator.</code>
</p>

<hr>
<h2 id='edges'>Edges accessors</h2><span id='topic+edges'></span><span id='topic+edges+2Cphylo4-method'></span><span id='topic+edgeOrder'></span><span id='topic+edgeOrder+2Cphylo4-method'></span><span id='topic+internalEdges'></span><span id='topic+internalEdges+2Cphylo4-method'></span><span id='topic+terminalEdges'></span><span id='topic+terminalEdges+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Access or modify information about the edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(x, ...)

## S4 method for signature 'phylo4'
edges(x, drop.root = FALSE)

edgeOrder(x, ...)

## S4 method for signature 'phylo4'
edgeOrder(x)

internalEdges(x)

## S4 method for signature 'phylo4'
internalEdges(x)

terminalEdges(x)

## S4 method for signature 'phylo4'
terminalEdges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object.</p>
</td></tr>
<tr><td><code id="edges_+3A_...">...</code></td>
<td>
<p>Optional arguments used by specific methods. (None
used at present).</p>
</td></tr>
<tr><td><code id="edges_+3A_drop.root">drop.root</code></td>
<td>
<p>logical (default FALSE), should the edge
connecting the root be included in the edge matrix?</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>edges</code></dt><dd><p>returns the edge matrix that represent the
ancestor-descendant relationships among the nodes of the tree.</p>
</dd>
<dt><code>edgeOrder</code></dt><dd><p>returns the order in which the edge matrix
is in.</p>
</dd>
<dt><code>internalEdges</code></dt><dd><p>returns a logical vector indicating
internal edges (edges that connect an internal node to
another). This vector is named with the <code>edgeId</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>terminalEdges</code></dt><dd><p>returns a logical vector indicating
terminal edges (edges that connect an internal node to a
tip). This vector is named with the <code>edgeId</code> </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Ben Bolker, Francois Michonneau, Thibaut Jombart
</p>


<h3>See Also</h3>

<p>reorder, edgeId
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(geospiza)
   edges(geospiza)
   edgeOrder(geospiza)
   geoPost &lt;- reorder(geospiza, "postorder")
   edgeOrder(geoPost)
   ## with a binary tree this should always be true
   identical(!terminalEdges(geospiza), internalEdges(geospiza))
</code></pre>

<hr>
<h2 id='extractTree'>Get tree from tree+data object</h2><span id='topic+extractTree'></span>

<h3>Description</h3>

<p>Extracts a <code>phylo4</code> tree object from a <code>phylo4d</code>
tree+data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTree(from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractTree_+3A_from">from</code></td>
<td>
<p>a <code>phylo4d</code> object, containing a phylogenetic
tree plus associated phenotypic data. Created by the
<code>phylo4d()</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extractTree</code> extracts just the phylogeny from a tree+data
object. The phylogeny contains the topology (how the nodes are
linked together), the branch lengths (if any), and any tip and/or
node labels. This may be useful for extracting a tree from a
<code>phylo4d</code> object, and associating with another phenotypic
dataset, or to convert the tree to another format.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo4-methods">phylo4-methods</a></code>,
<code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code>, <code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code> for
translation functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree.phylo &lt;- ape::read.tree(text = "((a,b),c);")
tree &lt;- as(tree.phylo, "phylo4")
plot(tree)
tip.data &lt;- data.frame(size = c(1, 2, 3), row.names = c("a", "b", "c"))
(treedata &lt;- phylo4d(tree, tip.data))
plot(treedata)
(tree1 &lt;- extractTree(treedata))
plot(tree1)

</code></pre>

<hr>
<h2 id='formatData'>Format data for use in phylo4d objects</h2><span id='topic+formatData'></span>

<h3>Description</h3>

<p>Associates data with tree nodes and applies consistent formatting
rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatData(
  phy,
  dt,
  type = c("tip", "internal", "all"),
  match.data = TRUE,
  rownamesAsLabels = FALSE,
  label.type = c("rownames", "column"),
  label.column = 1,
  missing.data = c("fail", "warn", "OK"),
  extra.data = c("warn", "OK", "fail"),
  keep.all = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatData_+3A_phy">phy</code></td>
<td>
<p>a valid <code>phylo4</code> object</p>
</td></tr>
<tr><td><code id="formatData_+3A_dt">dt</code></td>
<td>
<p>a data frame, matrix, vector, or factor</p>
</td></tr>
<tr><td><code id="formatData_+3A_type">type</code></td>
<td>
<p>type of data to attach</p>
</td></tr>
<tr><td><code id="formatData_+3A_match.data">match.data</code></td>
<td>
<p>(logical) should the rownames of the data frame
be used to be matched against tip and internal node identifiers?
See details.</p>
</td></tr>
<tr><td><code id="formatData_+3A_rownamesaslabels">rownamesAsLabels</code></td>
<td>
<p>(logical), should the row names of the
data provided be matched only to labels (TRUE), or should any
number-like row names be matched to node numbers (FALSE and
default)</p>
</td></tr>
<tr><td><code id="formatData_+3A_label.type">label.type</code></td>
<td>
<p>character, <code>rownames</code> or <code>column</code>:
should the labels be taken from the row names of <code>dt</code> or from
the <code>label.column</code> column of <code>dt</code>?</p>
</td></tr>
<tr><td><code id="formatData_+3A_label.column">label.column</code></td>
<td>
<p>if <code>label.type=="column"</code>, column
specifier (number or name) of the column containing tip labels</p>
</td></tr>
<tr><td><code id="formatData_+3A_missing.data">missing.data</code></td>
<td>
<p>action to take if there are missing data or if
there are data labels that don't match</p>
</td></tr>
<tr><td><code id="formatData_+3A_extra.data">extra.data</code></td>
<td>
<p>action to take if there are extra data or if
there are labels that don't match</p>
</td></tr>
<tr><td><code id="formatData_+3A_keep.all">keep.all</code></td>
<td>
<p>(logical), should the returned data have rows for
all nodes (with NA values for internal rows when type='tip', and
vice versa) (TRUE and default) or only rows corresponding to the
type argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>formatData</code> is an internal function that should not be
called directly by the user. It is used to format data provided by
the user before associating it with a tree, and is called
internally by the <code>phylo4d</code>, <code>tdata</code>, and <code>addData</code>
methods. However, users may pass additional arguments to these
methods in order to control how the data are matched to nodes.
</p>
<p>Rules for matching rows of data to tree nodes are determined
jointly by the <code>match.data</code> and <code>rownamesAsLabels</code>
arguments. If <code>match.data</code> is TRUE, data frame rows will be
matched exclusively against tip and node labels if
<code>rownamesAsLabels</code> is also TRUE, whereas any all-digit row
names will be matched against tip and node numbers if
<code>rownamesAsLabels</code> is FALSE (the default). If
<code>match.data</code> is FALSE, <code>rownamesAsLabels</code> has no effect,
and row matching is purely positional with respect to the order
returned by <code>nodeId(phy, type)</code>.
</p>
<p><code>formatData</code> (1) converts labels provided in the data into
node numbers, (2) makes sure that the data are appropriately
matched against tip and/or internal nodes, (3) checks for
differences between data and tree, (4) creates a data frame with
the correct dimensions given a tree.
</p>


<h3>Value</h3>

<p><code>formatData</code> returns a data frame having node numbers
as row names. The data frame is also formatted to have the correct
dimension given the <code>phylo4</code> object provided.
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor, the
<a href="#topic+phylo4d-class">phylo4d</a> class. See <code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code> for
translation functions.
</p>

<hr>
<h2 id='geospiza'>Data from Darwin's finches</h2><span id='topic+geospiza'></span><span id='topic+geospiza_raw'></span>

<h3>Description</h3>

<p>Phylogenetic tree and morphological data for Darwin's finches, in different
formats
</p>


<h3>Format</h3>

<p><code>geospiza</code> is a <code>phylo4d</code> object; <code>geospiza_raw</code> is a
list containing <code>tree</code>, a <code>phylo</code> object (the tree), <code>data</code>,
and a data frame with the data (for showing examples of how to merge tree
and data)
</p>


<h3>Note</h3>

<p>Stolen from Luke Harmon's Geiger package, to avoid unnecessary
dependencies
</p>


<h3>Source</h3>

<p>Dolph Schluter via Luke Harmon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(geospiza)
plot(geospiza)

</code></pre>

<hr>
<h2 id='getNode'>Node and Edge look-up functions</h2><span id='topic+getNode'></span><span id='topic+getNode+2Cphylo4-method'></span><span id='topic+getEdge'></span><span id='topic+getEdge-methods'></span><span id='topic+getEdge+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Functions for retrieving node and edge IDs (possibly with corresponding
labels) from a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNode(
  x,
  node,
  type = c("all", "tip", "internal"),
  missing = c("warn", "OK", "fail")
)

## S4 method for signature 'phylo4'
getNode(
  x,
  node,
  type = c("all", "tip", "internal"),
  missing = c("warn", "OK", "fail")
)

getEdge(
  x,
  node,
  type = c("descendant", "ancestor"),
  missing = c("warn", "OK", "fail")
)

## S4 method for signature 'phylo4'
getEdge(
  x,
  node,
  type = c("descendant", "ancestor"),
  missing = c("warn", "OK", "fail")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNode_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+phylo4-class">phylo4</a> object (or one inheriting from
<a href="#topic+phylo4-class">phylo4</a>, e.g. a <a href="#topic+phylo4d-class">phylo4d</a> object)</p>
</td></tr>
<tr><td><code id="getNode_+3A_node">node</code></td>
<td>
<p>either an integer vector corresponding to node ID numbers, or a
character vector corresponding to node labels; if missing, all nodes
appropriate to the specified type will be returned by <code>getNode</code>, and
all edges appropriate to the specified type will be returned by
<code>getEdge</code>.</p>
</td></tr>
<tr><td><code id="getNode_+3A_type">type</code></td>
<td>
<p>(<code>getNode</code>) specify whether to return nodes matching &quot;all&quot;
tree nodes (default), only &quot;tip&quot; nodes, or only &quot;internal&quot; nodes;
(<code>nodeId, edgeId</code>) specify whether to return &quot;all&quot; tree nodes, or only
those corresponding to &quot;tip&quot;, &quot;internal&quot;, or &quot;root&quot; nodes; (<code>getEdge</code>)
specify whether to look up edges based on their descendant node
(&quot;descendant&quot;) or ancestral node (&quot;ancestor&quot;)</p>
</td></tr>
<tr><td><code id="getNode_+3A_missing">missing</code></td>
<td>
<p>what to do if some requested node IDs or names are not in the
tree: warn, do nothing, or stop with an error</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getNode</code> and <code>getEdge</code> are primarily intended for looking up the
IDs either of nodes themselves or of edges associated with those nodes. Note
that they behave quite differently. With <code>getNode</code>, any input nodes are
looked up against tree nodes of the specified type, and those that match are
returned as numeric node IDs with node labels (if they exist) as element
names. With <code>getEdge</code>, any input nodes are looked up against edge ends
of the specified type, and those that match are returned as character edge
IDs with the corresponding node ID as element names.
</p>
<p>If <code>missing</code> is &ldquo;warn&rdquo; or &ldquo;OK&rdquo;, <code>NA</code> is returned for
any nodes that are unmatched for the specified type. This can provide a
mechanism for filtering a set of nodes or edges.
</p>
<p><code>nodeId</code> provides similar output to <code>getNode</code> in the case when no
node is supplied, but it is faster and returns an unnamed vector of the
numeric IDs of all nodes of the specified node type.  Similarly,
<code>edgeId</code> simply returns an unnamed vector of the character IDs of all
edges for which the descendant node is of the specified node type.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list("getNode")</code></td>
<td>
<p>returns a named integer vector of node IDs,
in the order of input nodes if provided, otherwise in nodeId order</p>
</td></tr>
<tr><td><code>list("getEdge")</code></td>
<td>
<p>returns a named character vector of edge IDs, in the
order of input nodes if provide, otherwise in nodeId order</p>
</td></tr>
<tr><td><code>list("nodeId")</code></td>
<td>
<p>returns an unnamed integer vector of node IDs, in
ascending order</p>
</td></tr> <tr><td><code>list("getEdge")</code></td>
<td>
<p>returns an unnamed character vector
of edge IDs, in edge matrix order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(geospiza)
  nodeLabels(geospiza) &lt;- LETTERS[1:nNodes(geospiza)]
  plot(as(geospiza, "phylo4"), show.node.label=TRUE)
  getNode(geospiza, 18)
  getNode(geospiza, "D")
  getEdge(geospiza, "D")
  getEdge(geospiza, "D", type="ancestor")

  ## match nodes only to tip nodes, flagging invalid cases as NA
  getNode(geospiza, c(1, 18, 999), type="tip", missing="OK")

  ## get all edges that descend from internal nodes
  getEdge(geospiza, type="ancestor")

  ## identify an edge from its terminal node
  getEdge(geospiza, c("olivacea", "B", "fortis"))
  getNode(geospiza, c("olivacea", "B", "fortis"))
  edges(geospiza)[c(26, 1, 11),]

  ## quickly get all tip node IDs and tip edge IDs
  nodeId(geospiza, "tip")
  edgeId(geospiza, "tip")

</code></pre>

<hr>
<h2 id='hasEdgeLength'>edgeLength methods</h2><span id='topic+hasEdgeLength'></span><span id='topic+hasEdgeLength+2Cphylo4-method'></span><span id='topic+edgeLength'></span><span id='topic+edgeLength+2Cphylo4-method'></span><span id='topic+edgeLength+3C-'></span><span id='topic+edgeLength+3C-+2Cphylo4-method'></span><span id='topic+edgeLength+3C-+2Cphylo4+2CANY-method'></span><span id='topic+depthTips'></span><span id='topic+depthTips+2Cphylo4-method'></span><span id='topic+depthTips+2Cphylo4-methods'></span><span id='topic+nodeDepth'></span><span id='topic+nodeDepth+2Cphylo4-method'></span><span id='topic+nodeHeight'></span><span id='topic+nodeHeight+2Cphylo4-method'></span><span id='topic+sumEdgeLength'></span><span id='topic+sumEdgeLength+2Cphylo4-method'></span><span id='topic+isUltrametric'></span><span id='topic+isUltrametric+2Cphylo4-method'></span>

<h3>Description</h3>

<p>These functions give information about and allow replacement of edge lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasEdgeLength(x)

## S4 method for signature 'phylo4'
hasEdgeLength(x)

edgeLength(x, ...)

## S4 method for signature 'phylo4'
edgeLength(x, node)

edgeLength(x, use.names = TRUE, ...) &lt;- value

## S4 replacement method for signature 'phylo4'
edgeLength(x, use.names = TRUE, ...) &lt;- value

depthTips(x)

## S4 method for signature 'phylo4'
depthTips(x)

nodeDepth(x, node)

## S4 method for signature 'phylo4'
nodeDepth(x, node)

nodeHeight(x, node, from)

## S4 method for signature 'phylo4'
nodeHeight(x, node, from = c("root", "all_tip", "min_tip", "max_tip"))

sumEdgeLength(x, node)

## S4 method for signature 'phylo4'
sumEdgeLength(x, node)

isUltrametric(x, tol = .Machine$double.eps^0.5)

## S4 method for signature 'phylo4'
isUltrametric(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasEdgeLength_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object.</p>
</td></tr>
<tr><td><code id="hasEdgeLength_+3A_...">...</code></td>
<td>
<p>optional arguments (none used at present).</p>
</td></tr>
<tr><td><code id="hasEdgeLength_+3A_node">node</code></td>
<td>
<p>optional numeric or character vector indicating the
nodes for which edge</p>
</td></tr>
<tr><td><code id="hasEdgeLength_+3A_use.names">use.names</code></td>
<td>
<p>should the the name attributes of <code>value</code> be
used to match the length to a given edge.</p>
</td></tr>
<tr><td><code id="hasEdgeLength_+3A_value">value</code></td>
<td>
<p>a numeric vector indicating the new values for the edge lengths</p>
</td></tr>
<tr><td><code id="hasEdgeLength_+3A_from">from</code></td>
<td>
<p>The point of reference for calculating the height of
the node. <code>root</code> calculates the distance between the root of
the tree and the node. <code>all_tip</code> return the distance between
the node and all the tips descending from it. <code>min_tip</code> the
distance between the node and its closest tip. <code>max_tip</code> the
distance between the node and its farther tip. <code>min_tip</code> and
<code>max_tip</code> will be identical if the tree is ultrametric. If
more than one tip is equidistant from the node, the tip with the
lowest node id will be returned.</p>
</td></tr>
<tr><td><code id="hasEdgeLength_+3A_tol">tol</code></td>
<td>
<p>the tolerance to decide whether all the tips have the
same depth to test if the tree is ultrametric. Default is
<code>.Machine$double.eps^0.5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>edgeLength</code> function returns the edge length in the same
order as the edges in the matrix.
</p>


<h3>Value</h3>


<dl>
<dt>hasEdgeLength</dt><dd><p>whether or not the object has edge lengths
(logical)</p>
</dd>
<dt>edgeLength</dt><dd><p>a named vector of the edge length for the
object</p>
</dd>
<dt>isUltrametric</dt><dd><p>whether or not the tree is ultrametric (all
the tips are have the same depth (distance from the root) (logical)</p>
</dd>
<dt>sumEdgeLength</dt><dd><p>the sum of the edge lengths for a set of
nodes (intended to be used with <code>ancestors</code> or <code>descendants</code>)</p>
</dd>
<dt>nodeHeight</dt><dd><p>the distance between a node and the root or the
tips. The format of the result will depend on the options and the
number of nodes provided, either a vector or a list.</p>
</dd>
<dt>nodeDepth</dt><dd><p>Deprecated, now replaced by <code>nodeHeight</code>. A
named vector indicating the &ldquo;depth&rdquo; (the distance between
the root and a given node).</p>
</dd>
<dt>depthTip</dt><dd><p>Deprecated, now  replaced by <code>nodeHeight</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code>ancestors</code>, <code>descendants</code>, <code>.Machine</code> for
more information about tolerance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(geospiza)
  hasEdgeLength(geospiza) # TRUE
  topoGeo &lt;- geospiza
  edgeLength(topoGeo) &lt;- NULL
  hasEdgeLength(topoGeo)  # FALSE

  edgeLength(geospiza)[2]       # use the position in vector
  edgeLength(geospiza)["16-17"] # or the name of the edge
  edgeLength(geospiza, 17)      # or the descendant node of the edge

  ## The same methods can be used to update an edge length
  edgeLength(geospiza)[2] &lt;- 0.33
  edgeLength(geospiza)["16-17"] &lt;- 0.34
  edgeLength(geospiza, 17) &lt;- 0.35

  ## Test if tree is ultrametric
  isUltrametric(geospiza)   # TRUE
  ## indeed all tips are at the same distance from the root
  nodeHeight(geospiza, nodeId(geospiza, "tip"), from="root")
  ## compare distances from tips of two MRCA
  nodeHeight(geospiza, MRCA(geospiza, c("pallida", "psittacula")), from="min_tip")
  nodeHeight(geospiza, MRCA(geospiza, c("fortis", "difficilis")), from="min_tip")
  ## or the same but from the root
  nodeHeight(geospiza, MRCA(geospiza, c("pallida", "psittacula")), from="root")
  nodeHeight(geospiza, MRCA(geospiza, c("fortis", "difficilis")), from="root")
</code></pre>

<hr>
<h2 id='hasSingle'>Test trees for polytomies, inline nodes (singletons), or reticulation</h2><span id='topic+hasSingle'></span><span id='topic+hasSingle+2Cphylo4-method'></span><span id='topic+hasRetic'></span><span id='topic+hasRetic+2Cphylo4-method'></span><span id='topic+hasPoly'></span><span id='topic+hasPoly+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Methods to test whether trees have (structural) polytomies, inline
nodes (i.e., nodes with a single descendant), or reticulation
(i.e., nodes with more than one ancestor). <code>hasPoly</code> only
check for structural polytomies (1 node has more than 2
descendants) and not polytomies that result from having edges with
a length of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasSingle(object)

## S4 method for signature 'phylo4'
hasSingle(object)

hasRetic(object)

## S4 method for signature 'phylo4'
hasRetic(object)

hasPoly(object)

## S4 method for signature 'phylo4'
hasPoly(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasSingle_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>phylo4</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value
</p>


<h3>Note</h3>

<p>Some algorithms are unhappy with structural polytomies (i.e., &gt;2
descendants from a node), with single-descendant nodes, or with
reticulation; these functions check those properties.  We haven't bothered
to check for zero branch lengths: the consensus is that it doesn't come up
much, and that it's simple enough to test <code>any(edgeLength(x) == 0)</code> in
these cases.  (Single-descendant nodes are used e.g. in OUCH, or in other
cases to represent events occurring along a branch.)
</p>


<h3>Author(s)</h3>

<p>Ben Bolker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree.owls.bis &lt;- ape::read.tree(text="((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3);")
owls4 &lt;- as(tree.owls.bis, "phylo4")
hasPoly(owls4)
hasSingle(owls4)

</code></pre>

<hr>
<h2 id='hasTipData'>Tests for presence of data associated with trees stored as phylo4d objects</h2><span id='topic+hasTipData'></span><span id='topic+hasTipData+2Cphylo4d-method'></span><span id='topic+hasTipData-method+2Cphylo4d-method'></span><span id='topic+hasNodeData'></span><span id='topic+hasNodeData-methods'></span><span id='topic+hasNodeData+2Cphylo4d-method'></span><span id='topic+nData'></span><span id='topic+nData+2Cphylo4d-method'></span>

<h3>Description</h3>

<p>Methods that test for the presence of data associated with trees stored as
<code>phylo4d</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasTipData(x)

## S4 method for signature 'phylo4d'
hasTipData(x)

hasNodeData(x)

## S4 method for signature 'phylo4d'
hasNodeData(x)

nData(x)

## S4 method for signature 'phylo4d'
nData(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasTipData_+3A_x">x</code></td>
<td>
<p>a <code>phylo4d</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nData</code> tests for the presence of data associated with the object.
</p>
<p><code>hasTipData</code> and <code>hasNodeData</code> tests for the presence of
data associated with the tips and the internal nodes
respectively. The outcome of the test is based on row names of the
data frame stored in the <code>data</code> slot. If no rows have names
from the set <code>nodeId(x, "tip")</code>, then <code>hasTipData</code>
returns FALSE.  Likewise, if no rows have names from the set
<code>nodeId(x, "internal")</code>, then <code>hasNodeData</code> returns
FALSE.
</p>


<h3>Value</h3>


<dl>
<dt><code>nData</code></dt><dd><p>returns the number of datasets (i.e.,
columns) associated with the object.</p>
</dd>
<dt><code>hasTipData</code>, <code>hasNodeData</code></dt><dd><p>return <code>TRUE</code>
or <code>FALSE</code> depending whether data associated with the
tree are associated with either tips or internal nodes respectively.</p>
</dd></dl>



<h3>Methods</h3>

 <dl>
<dt>hasNodeData</dt><dd><p><code>signature(object =
"phylo4d")</code>: whether tree has internal node data</p>
</dd>
<dt>hasTipData</dt><dd><p><code>signature(object = "phylo4d")</code>: whether tree has
data associated with its tips</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Ben Bolker, Thibault Jombart, Francois Michonneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor and
<code><a href="#topic+phylo4d-class">phylo4d</a></code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(geospiza)
  nData(geospiza)       ## 5
  hasTipData(geospiza)  ## TRUE
  hasNodeData(geospiza) ## FALSE

</code></pre>

<hr>
<h2 id='Import+20Nexus+20and+20Newick+20files'>Create a <code>phylo4</code>, <code>phylo4d</code> or <code>data.frame</code> object
from a NEXUS or a Newick file</h2><span id='topic+Import+20Nexus+20and+20Newick+20files'></span><span id='topic+readNCL'></span><span id='topic+readNexus'></span><span id='topic+readNewick'></span>

<h3>Description</h3>

<p><code>readNexus</code> reads a NEXUS file and outputs a <code>phylo4</code>,
<code>phylo4d</code> or <code>data.frame</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readNCL(
  file,
  simplify = FALSE,
  type = c("all", "tree", "data"),
  spacesAsUnderscores = TRUE,
  char.all = FALSE,
  polymorphic.convert = TRUE,
  levels.uniform = FALSE,
  quiet = TRUE,
  check.node.labels = c("keep", "drop", "asdata"),
  return.labels = TRUE,
  file.format = c("nexus", "newick"),
  check.names = TRUE,
  convert.edge.length = FALSE,
  ...
)

readNexus(
  file,
  simplify = FALSE,
  type = c("all", "tree", "data"),
  char.all = FALSE,
  polymorphic.convert = TRUE,
  levels.uniform = FALSE,
  quiet = TRUE,
  check.node.labels = c("keep", "drop", "asdata"),
  return.labels = TRUE,
  check.names = TRUE,
  convert.edge.length = FALSE,
  ...
)

readNewick(
  file,
  simplify = FALSE,
  quiet = TRUE,
  check.node.labels = c("keep", "drop", "asdata"),
  convert.edge.length = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_file">file</code></td>
<td>
<p>a NEXUS file for <code>readNexus</code> or a file that
contains Newick formatted trees for <code>readNewick</code>.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE, if there are multiple trees in the file,
only the first one is returned; otherwise a list of
<code>phylo4(d)</code> objects is returned if the file contains multiple
trees.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_type">type</code></td>
<td>
<p>Determines which type of objects to return, if present
in the file (see Details).</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_spacesasunderscores">spacesAsUnderscores</code></td>
<td>
<p>In the NEXUS file format white spaces
are not allowed in taxa labels and are represented by
underscores. Therefore, NCL converts underscores found in taxa
labels in the NEXUS file into white spaces
(e.g. <code>species_1</code> will become <code>"species 1"</code>. If you
want to preserve the underscores, set as TRUE, the default).</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_char.all">char.all</code></td>
<td>
<p>If <code>TRUE</code>, returns all characters, even those
excluded in the NEXUS file</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_polymorphic.convert">polymorphic.convert</code></td>
<td>
<p>If <code>TRUE</code>, converts polymorphic
characters to missing data</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_levels.uniform">levels.uniform</code></td>
<td>
<p>If <code>TRUE</code>, uses the same levels for all
characters</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code> the output of the NCL interface is
printed. This is mainly for debugging purposes. This option
can considerably slow down the process if the tree is big or
there are many trees in the file.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_check.node.labels">check.node.labels</code></td>
<td>
<p>Determines how the node labels in the
NEXUS or Newick files should be treated in the phylo4 object,
see Details for more information.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_return.labels">return.labels</code></td>
<td>
<p>Determines whether state names (if
<code>TRUE</code>) or state codes should be returned.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_file.format">file.format</code></td>
<td>
<p>character indicating the format of the
specified file (either &ldquo;<code>newick</code>&rdquo; or
&ldquo;<code>nexus</code>&rdquo;). It's more convenient to just use
<code>readNexus</code>  or <code>readNewick</code>.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_check.names">check.names</code></td>
<td>
<p>logical. If &lsquo;TRUE&rsquo; then the names of the
characters from the NEXUS file are checked to ensure that they
are syntactically valid variable names and are not duplicated.
If necessary they are adjusted using &lsquo;make.names&rsquo;.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_convert.edge.length">convert.edge.length</code></td>
<td>
<p>logical. If <code>TRUE</code> negative edge
lengths are replaced with 0. At this time <code>phylobase</code>
does not accept objects with negative branch lengths, this
workaround allows to import trees with negative branch
lengths.</p>
</td></tr>
<tr><td><code id="Import+2B20Nexus+2B20and+2B20Newick+2B20files_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to phylo4 or
phylo4d constructor (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readNewick</code> reads a Newick file and outputs a <code>phylo4</code>
or <code>phylo4d</code> object.
</p>
<p><code>readNexus</code> is used internally by both <code>readNexus</code> and
<code>readNewick</code> to extract data held in a tree files,
specifically in NEXUS files from DATA, CHARACTER or TREES
blocks.
</p>
<p>The <code>type</code> argument specifies which of these is returned:
</p>

<dl>
<dt>data</dt><dd><p>will only return a <code>data.frame</code> of the contents
of all DATA and CHARACTER blocks.</p>
</dd>
<dt>tree</dt><dd><p>will only return a <code>phylo4</code> object of the
contents of the TREES block.</p>
</dd>
<dt>all</dt><dd><p>if only data or a tree are present in the file, this
option will act as the options above, returning either a
<code>data.frame</code> or a <code>phylo4</code> object respectively. If both
are present then a <code>phylo4d</code> object is returned containing
both.</p>
</dd>
</dl>

<p>The function returns <code>NULL</code> if the <code>type</code> of
data requested is not present in the file, or if neither data nor
tree blocks are present.
</p>
<p>Depending on the context <code>readNexus</code> will call either the
<code>phylo4</code> or <code>phylo4d</code> constructor. The <code>phylo4d</code>
constructor will be used with <code>type="all"</code>, or if the option
<code>check.node.labels="asdata"</code> is invoked.
</p>
<p><code>readNewick</code> imports Newick formatted tree files and will
return a <code>phylo4</code> or a <code>phylo4d</code> object if the option
<code>check.node.labels="asdata"</code> is invoked.
</p>
<p>For both <code>readNexus</code> and <code>readNewick</code>, the options for
<code>check.node.labels</code> can take the values:
</p>

<dl>
<dt>keep</dt><dd><p>the node labels of the trees will be passed as node
labels in the <code>phylo4</code> object</p>
</dd>
<dt>drop</dt><dd><p>the node labels of the trees will be ignored in the
<code>phylo4</code> object</p>
</dd>
<dt>asdata</dt><dd><p>the node labels will be passed as data and a
<code>phylo4d</code> object will be returned.</p>
</dd>
</dl>

<p>If you use the option <code>asdata</code> on a file with no node labels,
a warning message is issued, and is thus equivalent to the value
<code>drop</code>.
</p>
<p>For both <code>readNexus</code> and <code>readNewick</code>, additional
arguments can be passed to the constructors such as <code>annote</code>,
<code>missing.data</code> or <code>extra.data</code>. See the &lsquo;Details&rsquo;
section of <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> for the complete list of
options.
</p>


<h3>Value</h3>

<p>Depending on the value of <code>type</code> and the contents of
the file, one of: a <code>data.frame</code>, a <a href="#topic+phylo4-class">phylo4</a>
object, a <a href="#topic+phylo4d-class">phylo4d</a> object or <code>NULL</code>.  If
several trees are included in the NEXUS file and the option
<code>simplify=FALSE</code> a list of <a href="#topic+phylo4-class">phylo4</a> or
<a href="#topic+phylo4d-class">phylo4d</a> objects is returned.
</p>


<h3>Note</h3>

<p>Underscores in state labels (i.e. trait or taxon names) will
be translated to spaces. Unless <code>check.names=FALSE</code>, trait
names will be converted to valid R names (see
<code><a href="base.html#topic+make.names">make.names</a></code>) on input to R, so spaces will be
translated to periods.
</p>


<h3>Author(s)</h3>

<p>Brian O'Meara, Francois Michonneau, Derrick Zwickl
</p>


<h3>See Also</h3>

<p>the <a href="#topic+phylo4d-class">phylo4d</a> class, the <a href="#topic+phylo4-class">phylo4</a>
class
</p>

<hr>
<h2 id='isRooted'>Methods to test, access (and modify) the root of a phylo4 object.</h2><span id='topic+isRooted'></span><span id='topic+isRooted+2Cphylo4-method'></span><span id='topic+rootNode'></span><span id='topic+rootNode+2Cphylo4-method'></span><span id='topic+rootNode+3C-'></span><span id='topic+rootNode+3C-+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Methods to test, access (and modify) the root of a phylo4 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isRooted(x)

## S4 method for signature 'phylo4'
isRooted(x)

rootNode(x)

## S4 method for signature 'phylo4'
rootNode(x)

rootNode(x) &lt;- value

## S4 replacement method for signature 'phylo4'
rootNode(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isRooted_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object.</p>
</td></tr>
<tr><td><code id="isRooted_+3A_value">value</code></td>
<td>
<p>a character string or a numeric giving the new root.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>isRooted</dt><dd><p>logical whether the tree is rooted</p>
</dd>
<dt>rootNode</dt><dd><p>the node corresponding to the root</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ben Bolker, Francois Michonneau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geospiza)
isRooted(geospiza)
rootNode(geospiza)
</code></pre>

<hr>
<h2 id='MRCA'>MRCA</h2><span id='topic+MRCA'></span><span id='topic+MRCA+2Cphylo4-method'></span><span id='topic+MRCA+2Cphylo-method'></span>

<h3>Description</h3>

<p>Most Recent Common Ancestor (MRCA) of 2 or more nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRCA(phy, ...)

## S4 method for signature 'phylo4'
MRCA(phy, ...)

## S4 method for signature 'phylo'
MRCA(phy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRCA_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree in phylo4, phylo4d or phylo format.</p>
</td></tr>
<tr><td><code id="MRCA_+3A_...">...</code></td>
<td>
<p>a vector of nodes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given some nodes (i.e., tips and/or internal), this function
returns the node corresponding to the most recent common ancestor.
</p>
<p>If <code>phy</code> is a <code>phylo4</code> or <code>phylo4d</code> object, the
nodes can contain both numeric or character values that will be
used by <code>getNode</code> to retrieve the correct node. However, if
<code>phy</code> is a <code>phylo</code> object, the nodes must be a numeric
vector.
</p>
<p>With <code>phylo4</code> and <code>phylo4d</code> objects, if a single node is
provided, it will be returned.
</p>


<h3>Value</h3>

<p>the node corresponding to the most recent common ancestor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(geospiza)
  MRCA(geospiza, 1, 5)
  MRCA(geospiza, "fortis", 11)
  MRCA(geospiza, 2, 4, "fusca", 3)
  geo &lt;- as(geospiza, "phylo")
  MRCA(geo, c(1,5))
</code></pre>

<hr>
<h2 id='multiPhylo-class'>multiPhylo4 and extended classes</h2><span id='topic+multiPhylo-class'></span><span id='topic+multiPhylo4-class'></span><span id='topic+multiPhylo4d-class'></span><span id='topic+tbind'></span>

<h3>Description</h3>

<p>Classes for lists of phylogenetic trees.  These classes and methods are
planned for a future version of <code>phylobase</code>.
</p>
<p>Classes for lists of phylogenetic trees.  These classes and methods are
planned for a future version of <code>phylobase</code>.
</p>

<hr>
<h2 id='nodeId'>nodeId methods</h2><span id='topic+nodeId'></span><span id='topic+nodeId+2Cphylo4-method'></span><span id='topic+edgeId'></span><span id='topic+edgeId+2Cphylo4-method'></span>

<h3>Description</h3>

<p>These functions gives the node (<code>nodeId</code>) or edge
(<code>edgeId</code>) identity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeId(x, type = c("all", "tip", "internal", "root"))

## S4 method for signature 'phylo4'
nodeId(x, type = c("all", "tip", "internal", "root"))

edgeId(x, type = c("all", "tip", "internal", "root"))

## S4 method for signature 'phylo4'
edgeId(x, type = c("all", "tip", "internal", "root"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeId_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object.</p>
</td></tr>
<tr><td><code id="nodeId_+3A_type">type</code></td>
<td>
<p>a character vector indicating which subset of the
nodes or edges you are interested in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nodeId</code> returns the node in ascending order, and
<code>edgeId</code> in the same order as the edges are stored in the
edge matrix.
</p>


<h3>Value</h3>


<dl>
<dt>nodeId</dt><dd><p>an integer vector  indicating node numbers</p>
</dd>
<dt>edgeId</dt><dd><p>a character vector indicating the edge identity</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(geospiza)
  identical(nodeId(geospiza, "tip"), 1:nTips(geospiza))
  nodeId(geospiza, "internal")
  edgeId(geospiza, "internal")
  nodeId(geospiza, "root")
</code></pre>

<hr>
<h2 id='nTips'>nTips, nNodes, nEdges</h2><span id='topic+nTips'></span><span id='topic+nTips+2Cphylo4-method'></span><span id='topic+nTips+2Cphylo-method'></span><span id='topic+nNodes'></span><span id='topic+nNodes+2Cphylo4-method'></span><span id='topic+nEdges'></span><span id='topic+nEdges+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Number of tips, nodes and edges found in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nTips(x)

## S4 method for signature 'phylo4'
nTips(x)

## S4 method for signature 'phylo'
nTips(x)

nNodes(x)

## S4 method for signature 'phylo4'
nNodes(x)

nEdges(x)

## S4 method for signature 'phylo4'
nEdges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nTips_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to return the number of tips, nodes and edges found in a
tree in the <code>phylo4</code> or <code>phylo4d</code> format.
</p>


<h3>Value</h3>

<p>a numeric vector indicating the number of tips, nodes or
edge respectively.
</p>

<hr>
<h2 id='owls4'>'Owls' data from ape</h2><span id='topic+owls4'></span>

<h3>Description</h3>

<p>A tiny tree, for testing/example purposes, using one of the examples from
the <code>ape</code> package
</p>


<h3>Format</h3>

<p>This is the standard 'owls' tree from the <code>ape</code> package, in
<code>phylo4</code> format.
</p>


<h3>Source</h3>

<p>From various examples in the <code>ape</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(owls4)
plot(owls4)

</code></pre>

<hr>
<h2 id='pdata'>Constructor for pdata (phylogenetic data) class</h2><span id='topic+pdata'></span><span id='topic+check_pdata'></span>

<h3>Description</h3>

<p>Combine data, type, comments, and metadata information to create a new pdata
object, or check such an object for consistency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdata(data, type, comment, metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdata_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="pdata_+3A_type">type</code></td>
<td>
<p>a factor with levels as specified by <a href="#topic+pdata-class">pdata</a>, the
same length as <code>ncol(data)</code></p>
</td></tr>
<tr><td><code id="pdata_+3A_comment">comment</code></td>
<td>
<p>a character vector, the same length as <code>ncol(data)</code></p>
</td></tr>
<tr><td><code id="pdata_+3A_metadata">metadata</code></td>
<td>
<p>an arbitrary list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>pdata</code>
</p>


<h3>Author(s)</h3>

<p>Ben Bolker
</p>


<h3>See Also</h3>

<p><a href="#topic+pdata-class">pdata</a>
</p>

<hr>
<h2 id='pdata-class'>Class &quot;pdata&quot;</h2><span id='topic+pdata-class'></span><span id='topic+ptypes'></span><span id='topic++5B+3C-+2Cpdata-method'></span><span id='topic++5B+2Cpdata-method'></span><span id='topic++5B+2Cpdata+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2Cpdata-method'></span><span id='topic++5B+5B+3C-+2Cpdata-method'></span><span id='topic++5B+5B+2Cpdata+2CANY+2CANY-method'></span><span id='topic++5B+5B+2Cpdata+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Data class for phylo4d objects
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("pdata", ...)</code>.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker
</p>

<hr>
<h2 id='phylo4-class'>The phylo4 class</h2><span id='topic+phylo4-class'></span>

<h3>Description</h3>

<p>Classes for phylogenetic trees
</p>


<h3>Objects from the Class</h3>

<p>Phylogenetic tree objects can be created by
calls to the <code><a href="#topic+phylo4">phylo4</a></code> constructor function.  Translation
functions from other phylogenetic packages are also available. See
<code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+phylo4-methods">phylo4-methods</a></code> constructor, the
<code><a href="#topic+checkPhylo4">checkPhylo4</a></code> function to check the validity of
<code>phylo4</code> objects. See also the <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code>
constructor and the <a href="#topic+phylo4d-class">phylo4d</a> class.
</p>

<hr>
<h2 id='phylo4-labels'>Labels for phylo4/phylo4d objects</h2><span id='topic+phylo4-labels'></span><span id='topic+labels'></span><span id='topic+labels+2Cphylo4-method'></span><span id='topic+labels+3C-'></span><span id='topic+labels+3C-+2Cphylo4-method'></span><span id='topic+hasDuplicatedLabels'></span><span id='topic+hasDuplicatedLabels+2Cphylo4-method'></span><span id='topic+hasDuplicatedLabels+2Cphylo4+2CANY-method'></span><span id='topic+hasNodeLabels'></span><span id='topic+hasNodeLabels+2Cphylo4-method'></span><span id='topic+nodeLabels'></span><span id='topic+nodeLabels+2Cphylo4-method'></span><span id='topic+nodeLabels+3C-'></span><span id='topic+nodeLabels+3C-+2Cphylo4-method'></span><span id='topic+tipLabels'></span><span id='topic+tipLabels+2Cphylo4-method'></span><span id='topic+tipLabels+3C-'></span><span id='topic+tipLabels+3C-+2Cphylo4-method'></span><span id='topic+hasEdgeLabels'></span><span id='topic+hasEdgeLabels+2Cphylo4-method'></span><span id='topic+edgeLabels'></span><span id='topic+edgeLabels+2Cphylo4-method'></span><span id='topic+edgeLabels+3C-'></span><span id='topic+edgeLabels+3C-+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Methods for creating, accessing and updating labels in
phylo4/phylo4d objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels(object, ...)

## S4 method for signature 'phylo4'
labels(object, type = c("all", "tip", "internal"))

labels(x, type, use.names, ...) &lt;- value

## S4 replacement method for signature 'phylo4'
labels(x, type = c("all", "tip", "internal"), use.names, ...) &lt;- value

hasDuplicatedLabels(x, type)

## S4 method for signature 'phylo4'
hasDuplicatedLabels(x, type = c("all", "tip", "internal"))

hasNodeLabels(x)

## S4 method for signature 'phylo4'
hasNodeLabels(x)

nodeLabels(x)

## S4 method for signature 'phylo4'
nodeLabels(x)

nodeLabels(x, ...) &lt;- value

## S4 replacement method for signature 'phylo4'
nodeLabels(x, ...) &lt;- value

tipLabels(x)

## S4 method for signature 'phylo4'
tipLabels(x)

tipLabels(x, ...) &lt;- value

## S4 replacement method for signature 'phylo4'
tipLabels(x, ...) &lt;- value

hasEdgeLabels(x)

## S4 method for signature 'phylo4'
hasEdgeLabels(x)

edgeLabels(x)

## S4 method for signature 'phylo4'
edgeLabels(x)

edgeLabels(x, ...) &lt;- value

## S4 replacement method for signature 'phylo4'
edgeLabels(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo4-labels_+3A_object">object</code></td>
<td>
<p>a phylo4 or phylo4d object.</p>
</td></tr>
<tr><td><code id="phylo4-labels_+3A_...">...</code></td>
<td>
<p>additional optional arguments (not in use)</p>
</td></tr>
<tr><td><code id="phylo4-labels_+3A_type">type</code></td>
<td>
<p>which type of labels: <code>all</code> (tips and internal nodes),
<code>tip</code> (tips only), <code>internal</code> (internal nodes only).</p>
</td></tr>
<tr><td><code id="phylo4-labels_+3A_x">x</code></td>
<td>
<p>a phylo4 or phylo4d object.</p>
</td></tr>
<tr><td><code id="phylo4-labels_+3A_use.names">use.names</code></td>
<td>
<p>should the names of the vector used to create/update labels
be used to match the labels? See Details for more information.</p>
</td></tr>
<tr><td><code id="phylo4-labels_+3A_value">value</code></td>
<td>
<p>a vector of class <code>character</code>, see Details for more
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In phylo4/phylo4d objects, tips must have labels (that's why there
is no method for hasTipLabels), internal nodes and edges can have
labels.
</p>
<p>Labels must be provided as a vector of class <code>character</code>. The
length of the vector must match the number of elements they label.
</p>
<p>The option <code>use.names</code> allows the user to match a label to a
particular node. In this case, the vector must have names that
match the node numbers.
</p>
<p>The function <code>labels</code> is mostly intended to be used
internally.
</p>


<h3>Value</h3>

<p>labels in ascending order.
</p>


<h3>Methods</h3>

 <dl>
<dt>labels</dt><dd><p><code>signature(object =
"phylo4")</code>: tip and/or internal node labels, ordered by node ID</p>
</dd>
<dt>hasDuplicatedLabels</dt><dd><p><code>signature(object = "phylo4")</code>: are any
labels duplicated?</p>
</dd>
<dt>tipLabels</dt><dd><p><code>signature(object = "phylo4")</code>: tip labels, ordered by
node ID</p>
</dd>
<dt>hasNodeLabels</dt><dd><p><code>signature(object = "phylo4")</code>: whether tree has
(internal) node labels</p>
</dd> <dt>nodeLabels</dt><dd><p><code>signature(object =
"phylo4")</code>: internal node labels, ordered by node ID</p>
</dd>
<dt>hasEdgeLabels</dt><dd><p><code>signature(object = "phylo4")</code>: whether tree has
(internal) edge labels</p>
</dd> <dt>edgeLabels</dt><dd><p><code>signature(object =
"phylo4")</code>: internal edge labels, ordered according to the edge matrix</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Ben Bolker, Peter Cowan, Steve Kembel, Francois Michonneau
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(geospiza)

## Return labels from geospiza
tipLabels(geospiza)

## Internal node labels in geospiza are empty
nodeLabels(geospiza)

## Creating internal node labels
ndLbl &lt;- paste("n", 1:nNodes(geospiza), sep="")
nodeLabels(geospiza) &lt;- ndLbl
nodeLabels(geospiza)

## naming the labels
names(ndLbl) &lt;- nodeId(geospiza, "internal")

## shuffling the labels
(ndLbl &lt;- sample(ndLbl))

## by default, the labels are attributed in the order
## they are given:
nodeLabels(geospiza) &lt;- ndLbl
nodeLabels(geospiza)

## but use.names puts them in the correct order
labels(geospiza, "internal", use.names=TRUE) &lt;- ndLbl
nodeLabels(geospiza)
</code></pre>

<hr>
<h2 id='phylo4-methods'>Create a phylogenetic tree</h2><span id='topic+phylo4-methods'></span><span id='topic+phylo4'></span><span id='topic+phylo4_orderings'></span><span id='topic+phylo4+2Cmatrix-method'></span><span id='topic+phylo4+2Cphylo-method'></span><span id='topic+phylo4+2Cnexml-method'></span><span id='topic+nexml+2Cphylo4-method'></span>

<h3>Description</h3>

<p><code>phylo4</code> is a generic constructor that creates a phylogenetic tree
object for use in phylobase methods. Phylobase contains functions for input
of phylogenetic trees and data, manipulation of these objects including
pruning and subsetting, and plotting. The phylobase package also contains
translation functions to forms used in other comparative phylogenetic method
packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo4(x, ...)

phylo4_orderings

## S4 method for signature 'matrix'
phylo4(
  x,
  edge.length = NULL,
  tip.label = NULL,
  node.label = NULL,
  edge.label = NULL,
  order = "unknown",
  annote = list()
)

## S4 method for signature 'phylo'
phylo4(x, check.node.labels = c("keep", "drop"), annote = list())

## S4 method for signature 'nexml'
phylo4(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo4-methods_+3A_x">x</code></td>
<td>
<p>a matrix of edges or an object of class <code>phylo</code> (see above)</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_...">...</code></td>
<td>
<p>optional arguments (none used at present).</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_edge.length">edge.length</code></td>
<td>
<p>Edge (branch) length. (Optional)</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_tip.label">tip.label</code></td>
<td>
<p>A character vector of species names (names of &quot;tip&quot; nodes).
(Optional)</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_node.label">node.label</code></td>
<td>
<p>A character vector of internal node names. (Optional)</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_edge.label">edge.label</code></td>
<td>
<p>A character vector of edge (branch) names. (Optional)</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_order">order</code></td>
<td>
<p>character: tree ordering (allowable values are listed in
<code>phylo4_orderings</code>, currently &quot;unknown&quot;, &quot;preorder&quot; (=&quot;cladewise&quot; in
<code>ape</code>), and &quot;postorder&quot;, with &quot;cladewise&quot; and &quot;pruningwise&quot; also
allowed for compatibility with <code>ape</code>)</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_annote">annote</code></td>
<td>
<p>any additional annotation data to be passed to the new object</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_check.node.labels">check.node.labels</code></td>
<td>
<p>if <code>x</code> is of class <code>phylo</code>, either &quot;keep&quot;
(the default) or &quot;drop&quot; node labels. This argument is useful if the
<code>phylo</code> object has non-unique node labels.</p>
</td></tr>
<tr><td><code id="phylo4-methods_+3A_edge">edge</code></td>
<td>
<p>A numeric, two-column matrix with as many rows as branches in
the phylogeny.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 5.
</p>


<h3>Details</h3>

<p>The minimum information necessary to create a phylobase tree object is a
valid edge matrix. The edge matrix describes the topology of the phylogeny.
Each row describes a branch of the phylogeny, with the (descendant) node
number in column 2 and its ancestor's node number in column 1. These numbers
are used internally and must be unique for each node.
</p>
<p>The labels designate either nodes or edges. The vector <code>node.label</code>
names internal nodes, and together with <code>tip.label</code>, name all nodes in
the tree. The vector <code>edge.label</code> names all branches in the tree. All
label vectors are optional, and if they are not given, internally-generated
labels will be assigned. The labels, whether user-specified or internally
generated, must be unique as they are used to join species data with
phylogenetic trees.
</p>
<p><code>phylobase</code> also allows to create <code>phylo4</code> objects using
the function <code>phylo4()</code> from objects of the classes:
<code>phylo</code> (from <code>ape</code>), and <code>nexml</code> (from <code>RNeXML</code>).
</p>


<h3>Note</h3>

<p>Translation functions are available from many valid tree formats. See
<a href="methods.html#topic+coerce-methods">coerce-methods</a>.
</p>


<h3>Author(s)</h3>

<p>phylobase team
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code> for translation
functions. The <a href="#topic+phylo4-class">phylo4</a> class. See also the
<code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor, and
<a href="#topic+phylo4d-class">phylo4d</a> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a three species tree:
mytree &lt;- phylo4(x=matrix(data=c(4,1, 4,5, 5,2, 5,3, 0,4), ncol=2,
byrow=TRUE), tip.label=c("speciesA", "speciesB", "speciesC")) 
mytree
plot(mytree)

# another way to specify the same tree:
mytree &lt;- phylo4(x=cbind(c(4, 4, 5, 5, 0), c(1, 5, 2, 3, 4)),
tip.label=c("speciesA", "speciesB", "speciesC")) 

# another way:
mytree &lt;- phylo4(x=rbind(c(4, 1), c(4, 5), c(5, 2), c(5, 3), c(0, 4)),
tip.label=c("speciesA", "speciesB", "speciesC")) 

# with branch lengths:
mytree &lt;- phylo4(x=rbind(c(4, 1), c(4, 5), c(5, 2), c(5, 3), c(0, 4)),
tip.label=c("speciesA", "speciesB", "speciesC"), edge.length=c(1, .2,
.8, .8, NA))
plot(mytree)

</code></pre>

<hr>
<h2 id='phylo4d-class'>phylo4d class</h2><span id='topic+phylo4d-class'></span>

<h3>Description</h3>

<p>S4 class for phylogenetic tree and data.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created from various trees
and a data.frame using the constructor <code>phylo4d</code>, or using
<code>new("phylo4d", ...{})</code> for empty objects.
</p>


<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code> for translation
functions. The <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor. See also
the <code><a href="#topic+phylo4-methods">phylo4-methods</a></code> constructor, the
<a href="#topic+phylo4-class">phylo4</a> class, and the <code><a href="#topic+checkPhylo4">checkPhylo4</a></code>
function to check the validity of <code>phylo4</code> trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  example(read.tree, "ape")
  obj &lt;- phylo4d(as(tree.owls.bis,"phylo4"), data.frame(wing=1:3))
  obj
  names(obj)
  summary(obj)
</code></pre>

<hr>
<h2 id='phylo4d-methods'>Combine a phylogenetic tree with data</h2><span id='topic+phylo4d-methods'></span><span id='topic+phylo4d'></span><span id='topic+phylo4d+2Cphylo4-method'></span><span id='topic+phylo4d+2Cphylo4+2Cphylo4-method'></span><span id='topic+phylo4d+2Cmatrix-method'></span><span id='topic+phylo4d+2Cmatrix+2Cmatrix-method'></span><span id='topic+phylo4d+2Cphylo-method'></span><span id='topic+phylo4d+2Cphylo+2Cphylo-method'></span><span id='topic+phylo4d+2Cphylo4d-method'></span><span id='topic+phylo4d+2Cphylo4d+2Cphylo4d-method'></span><span id='topic+phylo4d+2Cnexml-method'></span><span id='topic+nexml+2Cphylo4d-method'></span>

<h3>Description</h3>

<p><code>phylo4d</code> is a generic constructor which merges a
phylogenetic tree with data frames to create a combined object of
class <code>phylo4d</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo4d(x, ...)

## S4 method for signature 'phylo4'
phylo4d(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  merge.data = TRUE,
  metadata = list(),
  ...
)

## S4 method for signature 'matrix'
phylo4d(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  merge.data = TRUE,
  metadata = list(),
  edge.length = NULL,
  tip.label = NULL,
  node.label = NULL,
  edge.label = NULL,
  order = "unknown",
  annote = list(),
  ...
)

## S4 method for signature 'phylo'
phylo4d(
  x,
  tip.data = NULL,
  node.data = NULL,
  all.data = NULL,
  check.node.labels = c("keep", "drop", "asdata"),
  annote = list(),
  metadata = list(),
  ...
)

## S4 method for signature 'phylo4d'
phylo4d(x, ...)

## S4 method for signature 'nexml'
phylo4d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo4d-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>phylo4</code>, <code>phylo</code>,
<code>nexml</code> or a matrix of edges (see above)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_...">...</code></td>
<td>
<p>further arguments to control the behavior of the
constructor in the case of missing/extra data and where to look
for labels in the case of non-unique labels that cannot be stored
as row names in a data frame (see Details).</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_tip.data">tip.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing only tip data (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_node.data">node.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing only node data (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_all.data">all.data</code></td>
<td>
<p>a data frame (or object to be coerced to one)
containing both tip and node data (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_merge.data">merge.data</code></td>
<td>
<p>if both <code>tip.data</code> and <code>node.data</code> are
provided, should columns with common names will be merged together
(default TRUE) or not (FALSE)? See details.</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_metadata">metadata</code></td>
<td>
<p>any additional metadata to be passed to the new object</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_edge.length">edge.length</code></td>
<td>
<p>Edge (branch) length. (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_tip.label">tip.label</code></td>
<td>
<p>A character vector of species names (names of
&quot;tip&quot; nodes).  (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_node.label">node.label</code></td>
<td>
<p>A character vector of internal node
names. (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_edge.label">edge.label</code></td>
<td>
<p>A character vector of edge (branch)
names. (Optional)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_order">order</code></td>
<td>
<p>character: tree ordering (allowable values are listed
in <code>phylo4_orderings</code>, currently &quot;unknown&quot;, &quot;preorder&quot;
(=&quot;cladewise&quot; in <code>ape</code>), and &quot;postorder&quot;, with &quot;cladewise&quot;
and &quot;pruningwise&quot; also allowed for compatibility with <code>ape</code>)</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_annote">annote</code></td>
<td>
<p>any additional annotation data to be passed to the
new object</p>
</td></tr>
<tr><td><code id="phylo4d-methods_+3A_check.node.labels">check.node.labels</code></td>
<td>
<p>if <code>x</code> is of class <code>phylo</code>, use
either &ldquo;keep&rdquo; (the default) to retain internal node labels,
&ldquo;drop&rdquo; to drop them, or &ldquo;asdata&rdquo; to convert them to
numeric tree data. This argument is useful if the <code>phylo</code>
object has non-unique node labels or node labels with informative
data (e.g., posterior probabilities).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can provide several data frames to define traits associated
with tip and/or internal nodes. By default, data row names are
used to link data to nodes in the tree, with any number-like names
(e.g., &ldquo;10&rdquo;) matched against node ID numbers, and any
non-number-like names (e.g., &ldquo;n10&rdquo;) matched against node
labels. Alternative matching rules can be specified by passing
additional arguments (listed in the Details section); these
include positional matching, matching exclusively on node labels,
and matching based on a column of data rather than on row
names.
</p>
<p>Matching rules will apply the same way to all supplied data
frames.  This means that you need to be consistent with the row
names of your data frames.  It is good practice to use tip and
node labels (or node numbers if you use duplicated labels) when
you combine data with a tree.
</p>
<p>If you provide both <code>tip.data</code> and <code>node.data</code>, the
treatment of columns with common names will depend on the
<code>merge.data</code> argument. If TRUE, columns with the same name in
both data frames will be merged; when merging columns of different
data types, coercion to a common type will follow standard R
rules. If <code>merge.data</code> is FALSE, columns with common names
will be preserved independently, with &ldquo;.tip&rdquo; and
&ldquo;.node&rdquo; appended to the names. This argument has no effect
if <code>tip.data</code> and <code>node.data</code> have no column names in
common.
</p>
<p>If you provide <code>all.data</code> along with either of
<code>tip.data</code> and <code>node.data</code>, it must have distinct column
names, otherwise an error will result. Additionally, although
supplying columns with the same names <em>within</em> data frames is
not illegal, automatic renaming for uniqeness may lead to
surprising results, so this practice should be avoided.
</p>
<p>This is the list of additional arguments that can be used
to control matching between the tree and the data:
</p>

<dl>
<dt>match.data</dt><dd><p>(logical) should the rownames of the data frame
be used to be matched against tip and internal node identifiers?</p>
</dd>
<dt>rownamesAsLabels</dt><dd><p>(logical), should the row names of the
data provided be matched only to labels (TRUE), or should any
number-like row names be matched to node numbers (FALSE and
default)</p>
</dd>
<dt>label.type</dt><dd><p>character, <code>rownames</code> or <code>column</code>:
should the labels be taken from the row names of <code>dt</code> or from
the <code>label.column</code> column of <code>dt</code>?</p>
</dd>
<dt>label.column</dt><dd><p>iff <code>label.type=="column"</code>, column
specifier (number or name) of the column containing tip labels</p>
</dd>
<dt>missing.data</dt><dd><p>action to take if there are missing data or if
there are data labels that don't match</p>
</dd>
<dt>extra.data</dt><dd><p>action to take if there are extra data or if
there are labels that don't match</p>
</dd>
<dt>keep.all</dt><dd><p>(logical), should the returned data have rows for
all nodes (with NA values for internal rows when type='tip', and
vice versa) (TRUE and default) or only rows corresponding to the
type argument</p>
</dd>
</dl>

<p>Rules for matching rows of data to tree nodes are determined
jointly by the <code>match.data</code> and <code>rownamesAsLabels</code>
arguments. If <code>match.data</code> is TRUE, data frame rows will be
matched exclusively against tip and node labels if
<code>rownamesAsLabels</code> is also TRUE, whereas any all-digit row
names will be matched against tip and node numbers if
<code>rownamesAsLabels</code> is FALSE (the default). If
<code>match.data</code> is FALSE, <code>rownamesAsLabels</code> has no effect,
and row matching is purely positional with respect to the order
returned by <code>nodeId(phy, type)</code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+phylo4d-class">phylo4d</a>.
</p>


<h3>Methods</h3>

 <dl>
<dt>x = &quot;phylo4&quot;</dt><dd><p>merges a tree of
class <code>phylo4</code> with a data.frame into a <code>phylo4d</code>
object</p>
</dd> <dt>x = &quot;matrix&quot;</dt><dd><p>merges a matrix of tree edges similar
to the edge slot of a <code>phylo4</code> object (or to <code>$edge</code> of a
<code>phylo</code> object) with a data.frame into a <code>phylo4d</code>
object</p>
</dd> <dt>x = &quot;phylo&quot;</dt><dd><p>merges a tree of class <code>phylo</code>
with a data.frame into a <code>phylo4d</code> object </p>
</dd> </dl>



<h3>Note</h3>

<p>Checking on matches between the tree and the data will be
done by the validity checker (label matches between data and tree
tips, number of rows of data vs. number of nodes/tips/etc.)
</p>


<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart, Steve Kembel, Francois
Michonneau, Jim Regetz
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+coerce-methods">coerce-methods</a></code> for translation
functions. The <a href="#topic+phylo4d-class">phylo4d</a> class; <a href="#topic+phylo4-class">phylo4</a>
class and <a href="#topic+phylo4">phylo4</a> constructor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
treeOwls &lt;- "((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3);"
tree.owls.bis &lt;- ape::read.tree(text=treeOwls)
try(phylo4d(as(tree.owls.bis,"phylo4"),data.frame(wing=1:3)), silent=TRUE)
obj &lt;- phylo4d(as(tree.owls.bis,"phylo4"),data.frame(wing=1:3), match.data=FALSE)
obj
print(obj)

####

data(geospiza_raw)
geoTree &lt;- geospiza_raw$tree
geoData &lt;- geospiza_raw$data

## fix differences in tip names between the tree and the data
geoData &lt;- rbind(geoData, array(, dim = c(1,ncol(geoData)),
                  dimnames = list("olivacea", colnames(geoData))))

### Example using a tree of class 'phylo'
exGeo1 &lt;- phylo4d(geoTree, tip.data = geoData)

### Example using a tree of class 'phylo4'
geoTree &lt;- as(geoTree, "phylo4")

## some random node data
rNodeData &lt;- data.frame(randomTrait = rnorm(nNodes(geoTree)),
                        row.names = nodeId(geoTree, "internal"))

exGeo2 &lt;- phylo4d(geoTree, tip.data = geoData, node.data = rNodeData)

### Example using 'merge.data'
data(geospiza)
trGeo &lt;- extractTree(geospiza)
tDt &lt;- data.frame(a=rnorm(nTips(trGeo)), row.names=nodeId(trGeo, "tip"))
nDt &lt;- data.frame(a=rnorm(nNodes(trGeo)), row.names=nodeId(trGeo, "internal"))

(matchData1 &lt;- phylo4d(trGeo, tip.data=tDt, node.data=nDt, merge.data=FALSE))
(matchData2 &lt;- phylo4d(trGeo, tip.data=tDt, node.data=nDt, merge.data=TRUE))

## Example with 'all.data'
nodeLabels(geoTree) &lt;- as.character(nodeId(geoTree, "internal"))
rAllData &lt;- data.frame(randomTrait = rnorm(nTips(geoTree) + nNodes(geoTree)),
row.names = labels(geoTree, 'all'))

exGeo5 &lt;- phylo4d(geoTree, all.data = rAllData)

## Examples using 'rownamesAsLabels' and comparing with match.data=FALSE
tDt &lt;- data.frame(x=letters[1:nTips(trGeo)],
                  row.names=sample(nodeId(trGeo, "tip")))
tipLabels(trGeo) &lt;- as.character(sample(1:nTips(trGeo)))
(exGeo6 &lt;- phylo4d(trGeo, tip.data=tDt, rownamesAsLabels=TRUE))
(exGeo7 &lt;- phylo4d(trGeo, tip.data=tDt, rownamesAsLabels=FALSE))
(exGeo8 &lt;- phylo4d(trGeo, tip.data=tDt, match.data=FALSE))

## generate a tree and some data
set.seed(1)
p3 &lt;- ape::rcoal(5)
dat &lt;- data.frame(a = rnorm(5), b = rnorm(5), row.names = p3$tip.label)
dat.defaultnames &lt;- dat
row.names(dat.defaultnames) &lt;- NULL
dat.superset &lt;- rbind(dat, rnorm(2))
dat.subset &lt;- dat[-1, ]

## create a phylo4 object from a phylo object
p4 &lt;- as(p3, "phylo4")

## create phylo4d objects with tip data
p4d &lt;- phylo4d(p4, dat)
###checkData(p4d)
p4d.sorted &lt;- phylo4d(p4, dat[5:1, ])
try(p4d.nonames &lt;- phylo4d(p4, dat.defaultnames))
p4d.nonames &lt;- phylo4d(p4, dat.defaultnames, match.data=FALSE)

## Not run: 
p4d.subset &lt;- phylo4d(p4, dat.subset)
p4d.subset &lt;- phylo4d(p4, dat.subset)
try(p4d.superset &lt;- phylo4d(p4, dat.superset))
p4d.superset &lt;- phylo4d(p4, dat.superset)

## End(Not run)

## create phylo4d objects with node data
nod.dat &lt;- data.frame(a = rnorm(4), b = rnorm(4))
p4d.nod &lt;- phylo4d(p4, node.data = nod.dat, match.data=FALSE)


## create phylo4 objects with node and tip data
p4d.all1 &lt;- phylo4d(p4, node.data = nod.dat, tip.data = dat, match.data=FALSE)
nodeLabels(p4) &lt;- as.character(nodeId(p4, "internal"))
p4d.all2 &lt;- phylo4d(p4, all.data = rbind(dat, nod.dat), match.data=FALSE)
</code></pre>

<hr>
<h2 id='phylobase-package'>Utilities and Tools for Phylogenetics</h2><span id='topic+phylobase-package'></span><span id='topic+phylobase'></span>

<h3>Description</h3>

<p>Base package for phylogenetic structures and comparative data.
</p>


<h3>Details</h3>

<p><code>phylobase</code> provides a set of functions to associate and
manipulate phylogenetic information and data about the
species/individuals that are in the tree.
</p>
<p><code>phylobase</code> intends to be robust, fast and efficient. We hope
other people use the data structure it provides to develop new
comparative methods in R.
</p>
<p>With <code>phylobase</code> it is easy to ensure that all your data are
represented and associated with the tips or the internal nodes of
your tree. <code>phylobase</code> provides functions to:
</p>

<ul>
<li><p> prune (subset) your trees, find ancestor(s) a
descendant(s)
</p>
</li>
<li><p> find the most common recent ancestor of 2 nodes (MRCA)
</p>
</li>
<li><p> calculate the distance of a given node from the tip or
between two nodes in your tree
</p>
</li>
<li><p> robust functions to import data from NEXUS and Newick files
using the NEXUS Class Library (<a href="https://github.com/mtholder/ncl/">https://github.com/mtholder/ncl/</a>)
</p>
</li></ul>



<h3>History</h3>

<p><code>phylobase</code> was started during a Hackathlon at NESCent on
December 10-14 2007.
</p>
<p>Peter Cowan was a Google Summer of Code fellow in 2008 and
developed all the code for plotting.
</p>
<p>In December 2008, a mini-virtual Hackathlon was organized to clean
up and make the code more robust.
</p>
<p>In the spring and summer of 2009, Jim Regetz made several
contributions that made the code faster (in particular with the
re-ordering parts), found many bugs, and wrote most of the testing
code.
</p>
<p><code>phylobase</code> was first released on CRAN on November 1st, 2009
with version 0.5.
</p>
<p>Since then, several releases have followed adding new
functionalities: better support of NEXUS files, creation of
<code>phylobase.options()</code> function that controls the <code>phylo4</code>
validator, rewrite of the validator in C++.
</p>
<p>Starting with 0.6.8, Francois Michonneau succeeds to Ben Bolker as
the maintainer of the package.
</p>


<h3>More Info</h3>

<p>See the help index <code>help(package="phylobase")</code> and run
<code>vignette("phylobase", "phylobase")</code> for further details and
examples about how to use <code>phylobase</code>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/fmichonneau/phylobase">https://github.com/fmichonneau/phylobase</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fmichonneau/phylobase/issues">https://github.com/fmichonneau/phylobase/issues</a>
</p>
</li></ul>


<hr>
<h2 id='phylobase.options'>Set or return options of phylobase</h2><span id='topic+phylobase.options'></span>

<h3>Description</h3>

<p>Provides a mean to control the validity of <code>phylobase</code>
objects such as singletons, reticulated trees, polytomies, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylobase.options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylobase.options_+3A_...">...</code></td>
<td>
<p>a list may be given as the only argument, or any
number of arguments may be in the <code>name=value</code> form, or no
argument at all may be given.  See the Value and Details sections
for explanation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter values set via a call to this function will remain
in effect for the rest of the session, affecting the subsequent
behavior of phylobase.
</p>


<h3>Value</h3>

<p>A list with the updated values of the parameters. If
arguments are provided, the returned list is invisible.
</p>


<h3>Author(s)</h3>

<p>Francois Michonneau (adapted from the package <code>sm</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
phylobase.options(poly="fail")
# subsequent trees with polytomies will fail the validity check

## End(Not run)

</code></pre>

<hr>
<h2 id='phylobubbles'>Bubble plots for phylo4d objects</h2><span id='topic+phylobubbles'></span>

<h3>Description</h3>

<p>Plots either circles or squares corresponding to the magnitude of each cell
of a <code>phylo4d</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylobubbles(
  type = type,
  place.tip.label = "right",
  show.node.label = show.node.label,
  rot = 0,
  edge.color = edge.color,
  node.color = node.color,
  tip.color = tip.color,
  edge.width = edge.width,
  newpage = TRUE,
  ...,
  XXYY,
  square = FALSE,
  grid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylobubbles_+3A_type">type</code></td>
<td>
<p>the type of plot</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_place.tip.label">place.tip.label</code></td>
<td>
<p>A string indicating whether labels should be plotted
to the right or to the left of the bubble plot</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_show.node.label">show.node.label</code></td>
<td>
<p>A logical indicating whether internal node labels
should be plotted</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_rot">rot</code></td>
<td>
<p>The number of degrees that the plot should be rotated</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_edge.color">edge.color</code></td>
<td>
<p>A vector of colors for the tree edge segments</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_node.color">node.color</code></td>
<td>
<p>A vector of colors for the coloring the nodes</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_tip.color">tip.color</code></td>
<td>
<p>A vector of colors for the coloring the tip labels</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_edge.width">edge.width</code></td>
<td>
<p>A vector of line widths for the tree edges</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_newpage">newpage</code></td>
<td>
<p>Logical to control whether the device is cleared before
plotting, useful for adding plot inside other plots</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the bubble plotting functions</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_xxyy">XXYY</code></td>
<td>
<p>The out put from the phyloXXYY function</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_square">square</code></td>
<td>
<p>Logical indicating whether the plot 'bubbles' should be
squares</p>
</td></tr>
<tr><td><code id="phylobubbles_+3A_grid">grid</code></td>
<td>
<p>A logical indicating whether a grey grid should be plotted
behind the bubbles</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Cowan <a href="mailto:pdc@berkeley.edu">pdc@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyloXXYY">phyloXXYY</a></code>, <code>treePlot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

</code></pre>

<hr>
<h2 id='phylomat-class'>matrix classes for phylobase</h2><span id='topic+phylomat-class'></span><span id='topic+phylo4vcov-class'></span><span id='topic+as_phylo4vcov'></span><span id='topic+phylomat-setAs'></span><span id='topic+setAs+2Cphylo+2Cphylo4vcov-method'></span><span id='topic+setAs+2Cphylo4vcov+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Classes representing phylogenies as matrices
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylomat-class_+3A_from">from</code></td>
<td>
<p>a <code>phylo4</code> object</p>
</td></tr>
<tr><td><code id="phylomat-class_+3A_...">...</code></td>
<td>
<p>optional arguments, to be passed to <code>vcov.phylo</code> in
<code>ape</code> (the main useful option is <code>cor</code>, which can be set to
<code>TRUE</code> to compute a correlation rather than a variance-covariance
matrix)</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>These are square matrices (with rows and
columns corresponding to tips, and internal nodes implicit) with different
meanings depending on the type (variance-covariance matrix, distance matrix,
etc.).
</p>


<h3>Author(s)</h3>

<p>Ben Bolker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  tree_string &lt;- "(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
  tree.owls &lt;- ape::read.tree(text=tree_string)
  o2 &lt;- as(tree.owls,"phylo4")
  ov &lt;- as(o2,"phylo4vcov")
  o3 &lt;- as(ov,"phylo4")
  ## these are not completely identical, but are
  ## topologically identical ...

  ## edge matrices are in a different order:
  ## cf. edges(o2) and edges(o3)
  ## BUT the edge matrices are otherwise identical
  o2edges &lt;- edges(o2)
  o3edges &lt;- edges(o3)
  identical(o2edges[order(o2edges[,2]),],
            o3edges[order(o3edges[,2]),])

  ## There is left/right ambiguity here in the tree orders:
  ## in o2 the 5-&gt;6-&gt;7-&gt;1 lineage
  ## (terminating in Strix aluco)
  ## is first, in o3 the 5-&gt;6-&gt;3 lineage
  ## (terminating in Athene noctua) is first.


</code></pre>

<hr>
<h2 id='phyloXXYY'>Calculate node x and y coordinates</h2><span id='topic+phyloXXYY'></span>

<h3>Description</h3>

<p>Calculates the node x and y locations for plotting a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloXXYY(phy, tip.order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloXXYY_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo4</code> or <code>phylo4d</code> object.</p>
</td></tr>
<tr><td><code id="phyloXXYY_+3A_tip.order">tip.order</code></td>
<td>
<p>A character vector of tip labels, indicating their order
along the y axis (from top to bottom). Or, a numeric vector of tip node IDs
indicating the order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The y coordinates of the tips are evenly spaced from 0 to 1 in pruningwise
order.  Ancestor y nodes are given the mean value of immediate descendants.
The root is given the x coordinate 0 and descendant nodes are placed
according to the cumulative branch length from the root, with a maximum x
value of 1.
</p>


<h3>Value</h3>

<table>
<tr><td><code>yy</code></td>
<td>
<p>Internal node and tip y coordinates</p>
</td></tr> <tr><td><code>xx</code></td>
<td>
<p>Internal
node and tip x coordinates</p>
</td></tr> <tr><td><code>phy</code></td>
<td>
<p>A <code>phylo4</code> or <code>phylo4d</code>
object</p>
</td></tr> <tr><td><code>segs</code></td>
<td>
<p>A list of <code>h0x, h1x, v0x, v1x</code> and <code>h0y, h1y,
v0y, v1y</code> describing the start and end points for the plot line segments</p>
</td></tr>
<tr><td><code>torder</code></td>
<td>
<p>The tip order provided as <code>tip.order</code> or if NULL the
preoder tip order</p>
</td></tr> <tr><td><code>eorder</code></td>
<td>
<p>The an index of the reordered edges
compared to the result of <code>edges(phy)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Cowan <a href="mailto:pdc@berkeley.edu">pdc@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code>treePlot</code>, <code><a href="#topic+plotOneTree">plotOneTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(geospiza)
coor &lt;- phyloXXYY(geospiza)
plot(coor$xx, coor$yy, pch = 20)


</code></pre>

<hr>
<h2 id='plotOneTree'>Plot a phylo4 object</h2><span id='topic+plotOneTree'></span>

<h3>Description</h3>

<p>Plots the phylogenetic tree contained in a <code>phylo4</code> or <code>phylo4d</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOneTree(
  xxyy,
  type,
  show.tip.label,
  show.node.label,
  edge.color,
  node.color,
  tip.color,
  edge.width,
  rot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotOneTree_+3A_xxyy">xxyy</code></td>
<td>
<p>A list created by the <code><a href="#topic+phyloXXYY">phyloXXYY</a></code> function</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_type">type</code></td>
<td>
<p>A character string indicating the shape of plotted tree</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>Logical, indicating whether tip labels should be shown</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_show.node.label">show.node.label</code></td>
<td>
<p>Logical, indicating whether node labels should be
shown</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_edge.color">edge.color</code></td>
<td>
<p>A vector of colors in the order of <code>edges(phy)</code></p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_node.color">node.color</code></td>
<td>
<p>A vector of colors indicating the colors of the node
labels</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_tip.color">tip.color</code></td>
<td>
<p>A vector of colors indicating the colors of the tip labels</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_edge.width">edge.width</code></td>
<td>
<p>A vector in the order of <code>edges(phy)</code> indicating the
widths of edge lines</p>
</td></tr>
<tr><td><code id="plotOneTree_+3A_rot">rot</code></td>
<td>
<p>Numeric indicating the rotation of the plot in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns no values, function invoked for the plotting side effect.
</p>


<h3>Author(s)</h3>

<p>Peter Cowan <a href="mailto:pdc@berkeley.edu">pdc@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p><code>treePlot</code>, <code><a href="#topic+phyloXXYY">phyloXXYY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid)
data(geospiza)
grid.newpage()
xxyy &lt;- phyloXXYY(geospiza)
plotOneTree(xxyy, type = 'phylogram',
  show.tip.label = TRUE, show.node.label = TRUE,
  edge.color = 'black', node.color = 'orange', tip.color = 'blue',
  edge.width = 1, rot = 0
)

grid.newpage()
pushViewport(viewport(w = 0.8, h = 0.8))
plotOneTree(xxyy, type = 'phylogram',
  show.tip.label = TRUE, show.node.label = TRUE,
  edge.color = 'black', node.color = 'orange', tip.color = 'blue',
  edge.width = 1, rot = 0
)
popViewport()

</code></pre>

<hr>
<h2 id='print'>print a phylogeny</h2><span id='topic+print'></span><span id='topic+print+2Cphylo4-method'></span><span id='topic+show'></span><span id='topic+show+2Cphylo4-method'></span><span id='topic+names'></span><span id='topic+names+2Cphylo4-method'></span><span id='topic+head'></span><span id='topic+head+2Cphylo4-method'></span><span id='topic+tail'></span><span id='topic+tail+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Prints a phylo4 or phylo4d object in data.frame format with user-friendly
column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...)

## S4 method for signature 'phylo4'
print(x, edgeOrder = c("pretty", "real"), printall = TRUE)

show(object)

## S4 method for signature 'phylo4'
show(object)

names(x)

## S4 method for signature 'phylo4'
names(x)

head(x, ...)

## S4 method for signature 'phylo4'
head(x, n = 20)

tail(x, ...)

## S4 method for signature 'phylo4'
tail(x, n = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> tree or <code>phylo4d</code> tree+data object</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>optional additional arguments (not in use)</p>
</td></tr>
<tr><td><code id="print_+3A_edgeorder">edgeOrder</code></td>
<td>
<p>in the data frame returned, the option 'pretty' returns the
internal nodes followed by the tips, the option 'real' returns the nodes in
the order they are stored in the edge matrix.</p>
</td></tr>
<tr><td><code id="print_+3A_printall">printall</code></td>
<td>
<p>default prints entire tree. printall=FALSE returns the first
6 rows</p>
</td></tr>
<tr><td><code id="print_+3A_object">object</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object</p>
</td></tr>
<tr><td><code id="print_+3A_n">n</code></td>
<td>
<p>for head() and tail(), the number of lines to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a user-friendly version of the tree representation, useful for
checking that objects were read in completely and translated correctly. The
phylogenetic tree is represented as a list of numbered nodes, linked in a
particular way through time (or rates of evolutionary change).  The topology
is given by the pattern of links from each node to its ancestor. Also given
are the taxon names, node type (root/internal/tip) and phenotypic data (if
any) associated with the node, and the branch length from the node to its
ancestor. A list of nodes (descendants) and ancestors is minimally required
for a phylo4 object.
</p>


<h3>Value</h3>

<p>A data.frame with a row for each node (descendant), sorted as
follows: root first, then other internal nodes, and finally tips.<br /> The
returned data.frame has the following columns:<br /> </p>
<table>
<tr><td><code>label</code></td>
<td>
<p>Label for the
taxon at the node (usually species name).</p>
</td></tr> <tr><td><code>node</code></td>
<td>
<p>Node number, i.e. the
number identifying the node in edge matrix.</p>
</td></tr> <tr><td><code>ancestor</code></td>
<td>
<p>Node number
of the node's ancestor.</p>
</td></tr> <tr><td><code>branch.length</code></td>
<td>
<p>The branch length connecting
the node to its ancestor (NAs if missing).</p>
</td></tr> <tr><td><code>node.type</code></td>
<td>
<p>&quot;root&quot;,
&quot;internal&quot;, or &quot;tip&quot;. (internally generated)</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>phenotypic data
associated with the nodes, with separate columns for each variable.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is the default show() method for phylo4, phylo4d. It prints the
user-supplied information for building a phylo4 object. For a full
description of the phylo4 S4 object and slots, see <code><a href="#topic+phylo4">phylo4</a></code>.
</p>


<h3>Author(s)</h3>

<p>Marguerite Butler, Thibaut Jombart <a href="mailto:jombart@biomserv.univ-lyon1.fr">jombart@biomserv.univ-lyon1.fr</a>, Steve Kembel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

tree.phylo &lt;- ape::read.tree(text="((a,b),c);")
tree &lt;- as(tree.phylo, "phylo4")
##plot(tree,show.node=TRUE) ## plotting broken with empty node labels: FIXME
tip.data &lt;- data.frame(size=c(1,2,3), row.names=c("a", "b", "c"))
treedata &lt;- phylo4d(tree, tip.data)
plot(treedata)
print(treedata)


</code></pre>

<hr>
<h2 id='reorder-methods'>reordering trees within phylobase objects</h2><span id='topic+reorder-methods'></span><span id='topic+reorder'></span><span id='topic+reorder+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Methods for reordering trees into various traversal orders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder(x, ...)

## S4 method for signature 'phylo4'
reorder(x, order = c("preorder", "postorder"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder-methods_+3A_x">x</code></td>
<td>
<p>a <code>phylo4</code> or <code>phylo4d</code> object</p>
</td></tr>
<tr><td><code id="reorder-methods_+3A_...">...</code></td>
<td>
<p>additional optional elements (not in use)</p>
</td></tr>
<tr><td><code id="reorder-methods_+3A_order">order</code></td>
<td>
<p>The desired traversal order; currently only
&ldquo;preorder&rdquo; and &ldquo;postorder&rdquo; are allowed for
<code>phylo4</code> and <code>phylo4d</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>reorder</code> method takes a <code>phylo4</code> or <code>phylo4d</code>
tree and orders the edge matrix (i.e. <code>edges(x)</code>) in the
requested traversal order. Currently only two orderings are
permitted, and both require rooted trees. In <code>postorder</code>, a
node's descendants come before that node, thus the root, which is
ancestral to all nodes, comes last.  In <code>preorder</code>, a node is
visited before its descendants, thus the root comes first.
</p>


<h3>Value</h3>

<p>A <code>phylo4</code> or <code>phylo4d</code> object with the edge,
label, length and data slots ordered as <code>order</code>, which is
itself recorded in the order slot.
</p>


<h3>Note</h3>

<p>The <code>preorder</code> parameter corresponds to
<code>cladewise</code> in the <code>ape</code> package, and <code>postorder</code>
corresponds (almost) to <code>pruningwise</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Cowan, Jim Regetz
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+reorder.phylo">reorder.phylo</a></code> in the <code>ape</code> package.
<code><a href="#topic+ancestors">ancestors</a></code> <code><a href="#topic+ancestor">ancestor</a></code> <code><a href="#topic+siblings">siblings</a></code>
<code><a href="#topic+children">children</a></code> <code><a href="#topic+descendants">descendants</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phy &lt;- phylo4(ape::rtree(5))
edges(reorder(phy, "preorder"))
edges(reorder(phy, "postorder"))
</code></pre>

<hr>
<h2 id='setAs'>Converting between phylo4/phylo4d and other phylogenetic tree
formats</h2><span id='topic+setAs'></span><span id='topic+as'></span><span id='topic+as-method'></span><span id='topic+as+2Cphylo+2Cphylo4-method'></span><span id='topic+as+2Cphylo+2Cphylo4d-method'></span><span id='topic+as+2Cnexml+2Cphylo4-method'></span><span id='topic+as+2Cnexml+2Cphylo4d-method'></span><span id='topic+as+2Cphylo4+2Cphylo-method'></span><span id='topic+setAs+2Cphylo4+2Cphylog-method'></span><span id='topic+setAs+2Cphylo4+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Translation functions to convert between phylobase objects
(<code>phylo4</code> or <code>phylo4d</code>), and objects used by other
comparative methods packages in R: <code>ape</code> objects
(<code>phylo</code>, <code>multiPhylo</code>), <code>RNeXML</code> object
(<code>nexml</code>), <code>ade4</code> objects (<code>phylog</code>, <em>now
deprecated</em>), and to <code>data.frame</code> representation.
</p>


<h3>Usage</h3>

<p><code>as(object, class)</code>
</p>


<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart, Marguerite Butler, Steve
Kembel, Francois Michonneau
</p>


<h3>See Also</h3>

<p>generic <code><a href="methods.html#topic+as">as</a></code>,
<code><a href="#topic+phylo4-methods">phylo4-methods</a></code>, <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code>,
<code><a href="#topic+extractTree">extractTree</a></code>, <code>nexml</code> class from the
<code>RNeXML</code> package, <code><a href="ade4.html#topic+phylog">phylog</a></code> from the
<code>ade4</code> package and <code><a href="ape.html#topic+as.phylo">as.phylo</a></code> from the
<code>ape</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree_string &lt;- "(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
tree.owls &lt;- ape::read.tree(text=tree_string)
## round trip conversion
tree_in_phylo &lt;- tree.owls                  # tree is a phylo object
(tree_in_phylo4 &lt;- as(tree.owls,"phylo4"))  # phylo converted to phylo4
identical(tree_in_phylo,as(tree_in_phylo4,"phylo"))
## test if phylo, and phylo4 converted to phylo are identical
## (no, because of dimnames)

## Conversion to phylog (ade4)
as(tree_in_phylo4, "phylog")

## Conversion to data.frame
as(tree_in_phylo4, "data.frame")

## Conversion to phylo (ape)
as(tree_in_phylo4, "phylo")

## Conversion to phylo4d, (data slots empty)
as(tree_in_phylo4, "phylo4d")
</code></pre>

<hr>
<h2 id='shortestPath'>shortestPath-methods</h2><span id='topic+shortestPath'></span><span id='topic+shortestPath-phylo4'></span><span id='topic+shortestPath+2Cphylo4-method'></span><span id='topic+shortestPath-phylo'></span><span id='topic+shortestPath+2Cphylo-method'></span>

<h3>Description</h3>

<p>Finds the shortest path between two nodes in a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortestPath(x, node1, node2)

## S4 method for signature 'phylo4'
shortestPath(x, node1, node2)

## S4 method for signature 'phylo'
shortestPath(x, node1, node2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortestPath_+3A_x">x</code></td>
<td>
<p>a tree in the phylo4, phylo4d or phylo format</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_node1">node1</code></td>
<td>
<p>a numeric or character (passed to <code>getNode</code>)
indicating the beginning from which the path should be calculated.</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_node2">node2</code></td>
<td>
<p>a numeric or character (passed to <code>getNode</code>)
indicating the end of the path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two nodes (i.e, tips or internal nodes), this function
returns the shortest path between them (excluding <code>node1</code> and
<code>node2</code> as a vector of nodes.
</p>


<h3>Value</h3>

<p>a vector of nodes indcating the shortest path between 2 nodes
</p>


<h3>See Also</h3>

<p>getNode
</p>

<hr>
<h2 id='subset-methods'>Methods for creating subsets of phylogenies</h2><span id='topic+subset-methods'></span><span id='topic+subset'></span><span id='topic+subset+2Cphylo4-method'></span><span id='topic++5B'></span><span id='topic++5B+2Cphylo4+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cphylo4+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cphylo4+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cphylo4+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cphylo4d+2CANY+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2Cphylo4d+2CANY+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2Cphylo4d+2CANY+2Clogical+2Cmissing-method'></span><span id='topic++5B+2Cphylo4+2CANY+2CANY+2CANY-method'></span><span id='topic+prune'></span><span id='topic+prune+2Cphylo4-method'></span><span id='topic+prune+2Cphylo4d-method'></span>

<h3>Description</h3>

<p>Methods for creating subsets of phylogenies, based on pruning a
tree to include or exclude a set of terminal taxa, to include all
descendants of the MRCA of multiple taxa, or to return a subtree
rooted at a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset(x, ...)

## S4 method for signature 'phylo4'
subset(
  x,
  tips.include = NULL,
  tips.exclude = NULL,
  mrca = NULL,
  node.subtree = NULL,
  ...
)

x[i, ...]

## S4 method for signature 'phylo4,character,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4,numeric,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4,logical,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4,missing,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4d,ANY,character,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4d,ANY,numeric,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4d,ANY,logical,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'phylo4,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]

prune(x, ...)

## S4 method for signature 'phylo4'
prune(x, tips.exclude, trim.internal = TRUE)

## S4 method for signature 'phylo4d'
prune(x, tips.exclude, trim.internal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"phylo4"</code> or <code>"phylo4d"</code></p>
</td></tr>
<tr><td><code id="subset-methods_+3A_...">...</code></td>
<td>
<p>optional additional parameters (not in use)</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_tips.include">tips.include</code></td>
<td>
<p>A vector of tips to include in the subset tree</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_tips.exclude">tips.exclude</code></td>
<td>
<p>A vector of tips to exclude from the subset
tree</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_mrca">mrca</code></td>
<td>
<p>A vector of nodes for determining the most recent
common ancestor, which is then used as the root of the subset tree</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_node.subtree">node.subtree</code></td>
<td>
<p>A single internal node specifying the root of
the subset tree</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_i">i</code></td>
<td>
<p>(<code>[</code> method) An index vector indicating tips to
include</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_j">j</code></td>
<td>
<p>(<code>[</code> method, phylo4d only) An index vector
indicating columns of node/tip data to include</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_drop">drop</code></td>
<td>
<p>(not in use: for compatibility with the generic method)</p>
</td></tr>
<tr><td><code id="subset-methods_+3A_trim.internal">trim.internal</code></td>
<td>
<p>A logical specifying whether to remove
internal nodes that no longer have tip descendants in the subset
tree</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>subset</code> methods must be called using no more than one of
the four main subsetting criteria arguments (<code>tips.include</code>,
<code>tips.exclude</code>, <code>mrca</code>, or <code>node.subtree</code>).  Each
of these arguments can be either character or numeric.  In the
first case, they are treated as node labels; in the second case,
they are treated as node numbers.  For the first two arguments,
any supplied tips not found in the tree (<code>tipLabels(x)</code>) will
be ignored, with a warning.  Similarly, for the <code>mrca</code>
argument, any supplied tips or internal nodes not found in the
tree will be ignored, with a warning.  For the <code>node.subtree</code>
argument, failure to provide a single, valid internal node will
result in an error.
</p>
<p>Although <code>prune</code> is mainly intended as the workhorse function
called by <code>subset</code>, it may also be called directly.  In
general it should be equivalent to the <code>tips.exclude</code> form of
<code>subset</code> (although perhaps with less up-front error
checking).
</p>
<p>The &quot;[&quot; operator, when used as <code>x[i]</code>, is similar to the
<code>tips.include</code> form of <code>subset</code>.  However, the indices
used with this operator can also be logical, in which case the
corresponding tips are assumed to be ordered as in <code>nodeId(x,
"tip")</code>, and recycling rules will apply (just like with a vector
or a matrix).  With a <a href="#topic+phylo4d-class">phylo4d</a> object 'x',
<code>x[i,j]</code> creates a subset of <code>x</code> taking <code>i</code> for a
tip index and <code>j</code> for the index of data variables in
<code>tdata(geospiza, "all")</code>.  Note that the second index is
optional: <code>x[i, TRUE]</code>, <code>x[i,]</code>, and <code>x[i]</code> are all
equivalent.
</p>
<p>Regardless of which approach to subsetting is used, the argument
values must be such that at least two tips are retained.
</p>
<p>If the most recent common ancestor of the retained tips is not the
original root node, then the root node of the subset tree will be
a descendant of the original root.  For rooted trees with non-NA
root edge length, this has implications for the new root edge
length.  In particular, the new length will be the summed edge
length from the new root node back to the original root (including
the original root edge).  As an alternative, see the examples for
a way to determine the length of the edge that was immediately
ancestral to the new root node in the original tree.
</p>
<p>Note that the correspondance between nodes and labels (and data in
the case of <a href="#topic+phylo4d-class">phylo4d</a>) will be retained after all
forms of subsetting.  Beware, however, that the node numbers (IDs)
will likely be altered to reflect the new tree topology, and
therefore cannot be compared directly between the original tree
and the subset tree.
</p>


<h3>Value</h3>

<p>an object of class <code>"phylo4"</code> or <code>"phylo4d"</code>
</p>


<h3>Methods</h3>

 <dl>
<dt>x = &quot;phylo4&quot;</dt><dd><p>subset tree</p>
</dd>
<dt>x = &quot;phylo4d&quot;</dt><dd><p>subset tree and corresponding node and tip
data</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Jim Regetz <a href="mailto:regetz@nceas.ucsb.edu">regetz@nceas.ucsb.edu</a><br /> Steven Kembel
<a href="mailto:skembel@berkeley.edu">skembel@berkeley.edu</a><br /> Damien de Vienne
<a href="mailto:damien.de-vienne@u-psud.fr">damien.de-vienne@u-psud.fr</a><br /> Thibaut Jombart
<a href="mailto:jombart@biomserv.univ-lyon1.fr">jombart@biomserv.univ-lyon1.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geospiza)
nodeLabels(geospiza) &lt;- paste("N", nodeId(geospiza, "internal"), sep="")
geotree &lt;- extractTree(geospiza)

## "subset" examples
tips &lt;- c("difficilis", "fortis", "fuliginosa", "fusca", "olivacea",
    "pallida", "parvulus", "scandens")
plot(subset(geotree, tips.include=tips))
plot(subset(geotree, tips.include=tips, trim.internal=FALSE))
plot(subset(geotree, tips.exclude="scandens"))
plot(subset(geotree, mrca=c("scandens","fortis","pauper")))
plot(subset(geotree, node.subtree=18))

## "prune" examples (equivalent to subset using tips.exclude)
plot(prune(geotree, tips))

## "[" examples (equivalent to subset using tips.include)
plot(geotree[c(1:6,14)])
plot(geospiza[c(1:6,14)])

## for phylo4d, subset both tips and data columns
geospiza[c(1:6,14), c("wingL", "beakD")]

## note handling of root edge length:
edgeLength(geotree)['0-15'] &lt;- 0.1
geotree2 &lt;- geotree[1:2]
## in subset tree, edge of new root extends back to the original root
edgeLength(geotree2)['0-3']
## edge length immediately ancestral to this node in the original tree
edgeLength(geotree, MRCA(geotree, tipLabels(geotree2)))
</code></pre>

<hr>
<h2 id='summary-methods'>Summary for phylo4/phylo4d objects</h2><span id='topic+summary-methods'></span><span id='topic+summary'></span><span id='topic+summary+2Cphylo4-method'></span><span id='topic+summary+2Cphylo4d-method'></span><span id='topic+nodeType'></span><span id='topic+nodeType+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Summary of information for the tree (<code>phylo4</code> only) and/or the
associated data (<code>phylo4d</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)

## S4 method for signature 'phylo4'
summary(object, quiet = FALSE)

## S4 method for signature 'phylo4d'
summary(object, quiet = FALSE)

nodeType(object)

## S4 method for signature 'phylo4'
nodeType(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>a phylo4d object</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>optional additional elements (not in use)</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_quiet">quiet</code></td>
<td>
<p>Should the summary be displayed on screen?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>nodeType</code> method returns named vector which has
the type of node (internal, tip, root) for value, and the node number
for name
</p>
<p>The <code>summary</code> method invisibly returns a list with the
following components: </p>
<table>
<tr><td><code>list("name")</code></td>
<td>
<p>the name of the object</p>
</td></tr>
<tr><td><code>list("nb.tips")</code></td>
<td>
<p>the number of tips</p>
</td></tr>
<tr><td><code>list("nb.nodes")</code></td>
<td>
<p>the number of nodes</p>
</td></tr>
<tr><td><code>list("mean.el")</code></td>
<td>
<p>mean of edge lengths</p>
</td></tr>
<tr><td><code>list("var.el")</code></td>
<td>
<p>variance of edge lengths (estimate for population) </p>
</td></tr>
<tr><td><code>list("sumry.el")</code></td>
<td>
<p>summary (i.e. range and quartiles) of the
edge lengths</p>
</td></tr>
<tr><td><code>list("degree")</code></td>
<td>
<p>(optional) type of polytomy for each node:
&lsquo;node&rsquo;, &lsquo;terminal&rsquo; (all descendants are tips) or
&lsquo;internal&rsquo; (at least one descendant is an internal node);
displayed only when there are polytomies</p>
</td></tr>
<tr><td><code>list("sumry.tips")</code></td>
<td>
<p>(optional) summary for the data
associated with the tips</p>
</td></tr>
<tr><td><code>list("sumry.nodes")</code></td>
<td>
<p>(optional) summary for the data
associated with the internal nodes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart, Francois Michonneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code> constructor and
<code><a href="#topic+phylo4d-class">phylo4d</a></code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  tOwls &lt;- "(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);"
  tree.owls &lt;- ape::read.tree(text=tOwls)
  P1 &lt;- as(tree.owls, "phylo4")
  P1
  summary(P1)
  nodeType(P1)

  ## summary of a polytomous tree
  E &lt;- matrix(c(
      8,  9,
      9, 10,
     10,  1,
     10,  2,
      9,  3,
      9,  4,
      8, 11,
     11,  5,
     11,  6,
     11,  7,
      0,  8), ncol=2, byrow=TRUE)

  P2 &lt;- phylo4(E)
  nodeLabels(P2) &lt;- as.character(nodeId(P2, "internal"))
  plot(P2, show.node.label=TRUE)
  sumryP2 &lt;- summary(P2)
  sumryP2

</code></pre>

<hr>
<h2 id='tdata'>Retrieving or updating tip and node data in phylo4d objects</h2><span id='topic+tdata'></span><span id='topic+tdata+2Cphylo4d-method'></span><span id='topic+tdata+3C-'></span><span id='topic+tdata+3C-+2Cphylo4d-method'></span><span id='topic+tdata+3C-+2Cphylo4d+2CANY-method'></span><span id='topic+tipData'></span><span id='topic+tipData-method'></span><span id='topic+tipData+2Cphylo4d-method'></span><span id='topic+tipData+3C-'></span><span id='topic+tipData+3C-+2Cphylo4d-method'></span><span id='topic+tipData+3C-+2Cphylo4d+2CANY-method'></span><span id='topic+nodeData'></span><span id='topic+nodeData-method'></span><span id='topic+nodeData+2Cphylo4d-method'></span><span id='topic+nodeData+3C-'></span><span id='topic+nodeData+3C-+2Cphylo4d-method'></span><span id='topic+nodeData+3C-+2Cphylo4d+2CANY-method'></span>

<h3>Description</h3>

<p>Methods to retrieve or update tip, node or all data associated with a
phylogenetic tree stored as a phylo4d object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdata(x, ...)

## S4 method for signature 'phylo4d'
tdata(
  x,
  type = c("all", "tip", "internal"),
  label.type = c("row.names", "column"),
  empty.columns = TRUE
)

tdata(x, ...) &lt;- value

## S4 replacement method for signature 'phylo4d'
tdata(
  x,
  type = c("all", "tip", "internal"),
  merge.data = TRUE,
  clear.all = FALSE,
  ...
) &lt;- value

tipData(x, ...)

## S4 method for signature 'phylo4d'
tipData(x, ...)

tipData(x, ...) &lt;- value

## S4 replacement method for signature 'phylo4d'
tipData(x, ...) &lt;- value

nodeData(x, ...)

## S4 method for signature 'phylo4d'
nodeData(x, ...)

nodeData(x, ...) &lt;- value

## S4 replacement method for signature 'phylo4d'
nodeData(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdata_+3A_x">x</code></td>
<td>
<p>A <code>phylo4d</code> object</p>
</td></tr>
<tr><td><code id="tdata_+3A_...">...</code></td>
<td>
<p>For the <code>tipData</code> and <code>nodeData</code> accessors,
further arguments to be used by <code>tdata</code>. For the replacement
forms, further arguments to be used to control matching between
tree and data (see Details section of <code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code>).</p>
</td></tr>
<tr><td><code id="tdata_+3A_type">type</code></td>
<td>
<p>The type of data to retrieve or update: &ldquo;<code>all</code>&rdquo;
(default) for data associated with both tip and internal nodes,
&ldquo;<code>tip</code>&rdquo; for data associated with tips only,
&ldquo;<code>internal</code>&rdquo; for data associated with internal nodes only.</p>
</td></tr>
<tr><td><code id="tdata_+3A_label.type">label.type</code></td>
<td>
<p>How should the tip/node labels from the tree be returned?
&ldquo;<code>row.names</code>&rdquo; returns them as row names of the data frame,
&ldquo;<code>column</code>&rdquo; returns them in the first column of the data frame.
This options is useful in the case of missing (<code>NA</code>) or non-unique
labels.</p>
</td></tr>
<tr><td><code id="tdata_+3A_empty.columns">empty.columns</code></td>
<td>
<p>Should columns filled with <code>NA</code> be returned?</p>
</td></tr>
<tr><td><code id="tdata_+3A_value">value</code></td>
<td>
<p>a data frame (or object to be coerced to one) to replace the
values associated with the nodes specified by the argument <code>type</code></p>
</td></tr>
<tr><td><code id="tdata_+3A_merge.data">merge.data</code></td>
<td>
<p>if tip or internal node data are provided and data already
exists for the other type, this determines whether columns with common names
will be merged together (default TRUE). If FALSE, columns with common names
will be preserved separately, with &ldquo;.tip&rdquo; and &ldquo;.node&rdquo; appended
to the names. This argument has no effect if tip and node data have no
column names in common, or if type=&ldquo;all&rdquo;.</p>
</td></tr>
<tr><td><code id="tdata_+3A_clear.all">clear.all</code></td>
<td>
<p>If only tip or internal node data are to be replaced,
should data of the other type be dropped?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tdata</code> returns a data frame
</p>


<h3>Methods</h3>


<dl>
<dt>tdata</dt><dd><p><code>signature(object="phylo4d")</code>: retrieve or update data
associated with a tree in a <code>phylo4d</code> object</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Ben Bolker, Thibaut Jombart, Francois Michonneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo4d-methods">phylo4d-methods</a></code>, <code><a href="#topic+phylo4d-class">phylo4d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(geospiza)
   tdata(geospiza)
   tipData(geospiza) &lt;- 1:nTips(geospiza)
   tdata(geospiza)
</code></pre>

<hr>
<h2 id='tip.data.plot'>Plotting trees and associated data</h2><span id='topic+tip.data.plot'></span>

<h3>Description</h3>

<p>Plotting phylogenetic trees and associated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tip.data.plot(
  xxyy,
  type = c("phylogram", "cladogram", "fan"),
  show.tip.label = TRUE,
  show.node.label = FALSE,
  rot = 0,
  tip.plot.fun = grid.points,
  edge.color = "black",
  node.color = "black",
  tip.color = "black",
  edge.width = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tip.data.plot_+3A_xxyy">xxyy</code></td>
<td>
<p>A list created by the <code><a href="#topic+phyloXXYY">phyloXXYY</a></code> function</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_type">type</code></td>
<td>
<p>A character string indicating the shape of plotted tree</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>Logical, indicating whether tip labels should be shown</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_show.node.label">show.node.label</code></td>
<td>
<p>Logical, indicating whether node labels should be
shown</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_rot">rot</code></td>
<td>
<p>Numeric indicating the rotation of the plot in degrees</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_tip.plot.fun">tip.plot.fun</code></td>
<td>
<p>A function used to plot the data elements of a
<code>phylo4d</code> object</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_edge.color">edge.color</code></td>
<td>
<p>A vector of colors in the order of <code>edges(phy)</code></p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_node.color">node.color</code></td>
<td>
<p>A vector of colors indicating the colors of the node
labels</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_tip.color">tip.color</code></td>
<td>
<p>A vector of colors indicating the colors of the tip labels</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_edge.width">edge.width</code></td>
<td>
<p>A vector in the order of <code>edges(phy)</code> indicating the
widths of edge lines</p>
</td></tr>
<tr><td><code id="tip.data.plot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>tip.plot.fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates a plot on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Peter Cowan
</p>

<hr>
<h2 id='treePlot-methods'>Phylogeny plotting</h2><span id='topic+treePlot-methods'></span><span id='topic+treePlot'></span><span id='topic+plot+2CANY+2CANY-method'></span><span id='topic+plot+2Cpdata+2Cmissing-method'></span><span id='topic+plot+2Cphylo4+2Cmissing-method'></span><span id='topic+treePlot-method'></span><span id='topic+treePlot+2Cphylo4+2Cphylo4d-method'></span><span id='topic+plot'></span><span id='topic+plot+2Cphylo4-method'></span>

<h3>Description</h3>

<p>Plot <code>phylo4</code> or <code>phylo4d</code> objects, including associated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treePlot(
  phy,
  type = c("phylogram", "cladogram", "fan"),
  show.tip.label = TRUE,
  show.node.label = FALSE,
  tip.order = NULL,
  plot.data = is(phy, "phylo4d"),
  rot = 0,
  tip.plot.fun = "bubbles",
  plot.at.tip = TRUE,
  edge.color = "black",
  node.color = "black",
  tip.color = "black",
  edge.width = 1,
  newpage = TRUE,
  margins = c(1.1, 1.1, 1.1, 1.1),
  ...
)

plot(x, y, ...)

## S4 method for signature 'phylo4,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treePlot-methods_+3A_phy">phy</code></td>
<td>
<p>A <code>phylo4</code> or <code>phylo4d</code> object</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_type">type</code></td>
<td>
<p>A character string indicating the shape of plotted tree</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>Logical, indicating whether tip labels should be shown</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_show.node.label">show.node.label</code></td>
<td>
<p>Logical, indicating whether node labels should be
shown</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_tip.order">tip.order</code></td>
<td>
<p>If NULL the tree is plotted with tips in preorder, if &quot;rev&quot;
this is reversed. Otherwise, it is a character vector of tip labels,
indicating their order along the y axis (from top to bottom). Or, a numeric
vector of tip node IDs indicating the order.</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_plot.data">plot.data</code></td>
<td>
<p>Logical indicating whether <code>phylo4d</code> data should be
plotted</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_rot">rot</code></td>
<td>
<p>Numeric indicating the rotation of the plot in degrees</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_tip.plot.fun">tip.plot.fun</code></td>
<td>
<p>A function used to generate plot at the each tip of the
phylogenetic trees</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_plot.at.tip">plot.at.tip</code></td>
<td>
<p>should the data plots be at the tip? (logical)</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_edge.color">edge.color</code></td>
<td>
<p>A vector of colors in the order of <code>edges(phy)</code></p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_node.color">node.color</code></td>
<td>
<p>A vector of colors indicating the colors of the node
labels</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_tip.color">tip.color</code></td>
<td>
<p>A vector of colors indicating the colors of the tip labels</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_edge.width">edge.width</code></td>
<td>
<p>A vector in the order of <code>edges(phy)</code> indicating the
widths of edge lines</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_newpage">newpage</code></td>
<td>
<p>Logical indicating whether the page should be cleared before
plotting</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_margins">margins</code></td>
<td>
<p>number of lines around the plot (similar to <code>par(mar)</code>).</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_x">x</code></td>
<td>
<p>A <code>phylo4</code> or <code>phylo4d</code> object</p>
</td></tr>
<tr><td><code id="treePlot-methods_+3A_y">y</code></td>
<td>
<p>(only here for compatibility)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>treePlot</code> can only plot numeric values
for tree-associated data. The dataset will be subset to only
include columns of class <code>numeric</code>, <code>integer</code> or
<code>double</code>. If a <code>phylo4d</code> object is passed to the
function and it contains no data, or if the data is in a format
that cannot be plotted, the function will produce a warning. You
can avoid this by using the argument <code>plot.data=FALSE</code>.
</p>


<h3>Value</h3>

<p>No return value, function invoked for plotting side effect
</p>


<h3>Methods</h3>

 <dl>
<dt>phy = &quot;phylo4&quot;</dt><dd><p>plots a tree of class
<a href="#topic+phylo4-class">phylo4</a></p>
</dd> <dt>phy = &quot;phylo4d&quot;</dt><dd><p>plots a tree with one or more
quantitative traits contained in a <a href="#topic+phylo4d-class">phylo4d</a> object.</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Peter Cowan <a href="mailto:pdc@berkeley.edu">pdc@berkeley.edu</a>, Francois Michonneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylobubbles">phylobubbles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example of plotting two grid plots on the same page
library(grid)
data(geospiza)
geotree &lt;- extractTree(geospiza)
grid.newpage()
pushViewport(viewport(layout=grid.layout(nrow=1, ncol=2), name="base"))
  pushViewport(viewport(layout.pos.col=1, name="plot1"))
    treePlot(geotree, newpage=FALSE)
  popViewport()

  pushViewport(viewport(layout.pos.col=2, name="plot2"))
    treePlot(geotree, newpage=FALSE, rot=180)
popViewport(2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
