<!DOCTYPE html><html><head><title>Help for package multitool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multitool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_correlations'><p>Add correlations from the <code>correlation</code> package in <code>easystats</code></p></a></li>
<li><a href='#add_filters'><p>Add filtering/exclusion criteria to a multiverse pipeline</p></a></li>
<li><a href='#add_model'><p>Add a model and formula to a multiverse pipeline</p></a></li>
<li><a href='#add_parameter_keys'><p>Add parameter keys names for later use in summarizing model effects</p></a></li>
<li><a href='#add_postprocess'><p>Add arbitrary postprocessing code to a multiverse pipeline</p></a></li>
<li><a href='#add_preprocess'><p>Add arbitrary preprocessing code to a multiverse analysis pipeline</p></a></li>
<li><a href='#add_reliabilities'><p>Add item reliabilities to a multiverse pipeline</p></a></li>
<li><a href='#add_summary_stats'><p>Add a set of descriptive statistics to compute over a set of variables</p></a></li>
<li><a href='#add_variables'><p>Add a set of variable alternatives to a multiverse pipeline</p></a></li>
<li><a href='#condense'><p>Summarize multiverse parameters</p></a></li>
<li><a href='#create_blueprint_graph'><p>Create a Analysis Pipeline diagram</p></a></li>
<li><a href='#detect_multiverse_n'><p>Detect total number of analysis pipelines</p></a></li>
<li><a href='#detect_n_filters'><p>Detect total number of filtering expressions your pipelines</p></a></li>
<li><a href='#detect_n_models'><p>Detect total number of models in your pipelines</p></a></li>
<li><a href='#detect_n_variables'><p>Detect total number of variable sets in your pipelines</p></a></li>
<li><a href='#expand_decisions'><p>Expand a set of multiverse decisions into all possible combinations</p></a></li>
<li><a href='#multitool-package'><p>multitool: Run Multiverse Style Analyses</p></a></li>
<li><a href='#reveal'><p>Reveal the contents of a multiverse analysis</p></a></li>
<li><a href='#reveal_corrs'><p>Reveal a set of multiverse correlations</p></a></li>
<li><a href='#reveal_model_messages'><p>Reveal any messages about your models during a multiverse analysis</p></a></li>
<li><a href='#reveal_model_parameters'><p>Reveal the model parameters of a multiverse analysis</p></a></li>
<li><a href='#reveal_model_performance'><p>Reveal the model performance/fit indices from a multiverse analysis</p></a></li>
<li><a href='#reveal_model_warnings'><p>Reveal any warnings about your models during a multiverse analysis</p></a></li>
<li><a href='#reveal_reliabilities'><p>Reveal a set of multiverse cronbach's alpha statistics</p></a></li>
<li><a href='#reveal_summary_stats'><p>Reveal a set of summary statistics from a multiverse analysis</p></a></li>
<li><a href='#run_descriptives'><p>Run a multiverse-style descriptive analysis based on a complete decision grid</p></a></li>
<li><a href='#run_multiverse'><p>Run a multiverse based on a complete decision grid</p></a></li>
<li><a href='#show_code_filter'><p>Show multiverse data code pipelines</p></a></li>
<li><a href='#summarize_filter_ns'><p>Summarize samples sizes for each unique filtering expression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Run Multiverse Style Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Run the same analysis over a range of arbitrary data processing 
    decisions. 'multitool' provides an interface for creating alternative 
    analysis pipelines and turning them into a grid of all possible pipelines. 
    Using this grid as a blueprint, you can model your data across all possible 
    pipelines and summarize the results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>clipr, correlation, DiagrammeR, dplyr, flextable, furrr,
future, ggdist, glue, ggplot2, moments, purrr, rlang, stringr,
tibble, tidyr, lme4, parameters, performance</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), tidyverse</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ethan-young.github.io/multitool/">https://ethan-young.github.io/multitool/</a>,
<a href="https://github.com/ethan-young/multitool">https://github.com/ethan-young/multitool</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ethan-young/multitool/issues">https://github.com/ethan-young/multitool/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 03:08:53 UTC; ethanyoung</td>
</tr>
<tr>
<td>Author:</td>
<td>Ethan Young <a href="https://orcid.org/0000-0002-8232-0184"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Stefan Vermeent <a href="https://orcid.org/0000-0002-9595-5373"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ethan Young &lt;young.ethan.scott@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_correlations'>Add correlations from the <code>correlation</code> package in <code>easystats</code></h2><span id='topic+add_correlations'></span>

<h3>Description</h3>

<p>Add correlations from the <code>correlation</code> package in <code>easystats</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_correlations(
  .df,
  var_set,
  variables,
  focus_set = NULL,
  method = "auto",
  redundant = TRUE,
  add_matrix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_correlations_+3A_.df">.df</code></td>
<td>
<p>the original <code>data.frame</code>(e.g., base data set). If part of
set of
add_* decision functions in a pipeline, the base data will be passed along
as an attribute.</p>
</td></tr>
<tr><td><code id="add_correlations_+3A_var_set">var_set</code></td>
<td>
<p>character string. Should be a descriptive name of the
correlation matrix.</p>
</td></tr>
<tr><td><code id="add_correlations_+3A_variables">variables</code></td>
<td>
<p>the variables for which you would like to correlations.
These variables will be passed to <code>link[correlation]{correlation}</code>.
You can also use tidyselect to select variables.</p>
</td></tr>
<tr><td><code id="add_correlations_+3A_focus_set">focus_set</code></td>
<td>
<p>variables to focus one in a table. This produces a table
where rows are each focused variables and columns are all other variables</p>
</td></tr>
<tr><td><code id="add_correlations_+3A_method">method</code></td>
<td>
<p>a valid method of correlation supplied to
<code>link[correlation]{correlation}</code> (e.g., 'pearson' or 'kendall').
Defaults to <code>'auto'</code>. See <code>link[correlation]{correlation}</code> for
more details.</p>
</td></tr>
<tr><td><code id="add_correlations_+3A_redundant">redundant</code></td>
<td>
<p>logical, should the result include repeated correlations?
Defaults to <code>TRUE</code> See <code>link[correlation]{correlation}</code> for
details.</p>
</td></tr>
<tr><td><code id="add_correlations_+3A_add_matrix">add_matrix</code></td>
<td>
<p>logical, add a traditional correlation matrix to the
output. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_correlations("predictors", matches("iv|mod|cov"), focus_set = c(cov1,cov2))
</code></pre>

<hr>
<h2 id='add_filters'>Add filtering/exclusion criteria to a multiverse pipeline</h2><span id='topic+add_filters'></span>

<h3>Description</h3>

<p>Add filtering/exclusion criteria to a multiverse pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_filters(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_filters_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_filters_+3A_...">...</code></td>
<td>
<p>logical expressions to be used with <code><a href="dplyr.html#topic+filter">filter</a></code>
separated by commas. Expressions should not be quoted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5)
</code></pre>

<hr>
<h2 id='add_model'>Add a model and formula to a multiverse pipeline</h2><span id='topic+add_model'></span>

<h3>Description</h3>

<p>Add a model and formula to a multiverse pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_model(.df, model_desc, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_model_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_model_+3A_model_desc">model_desc</code></td>
<td>
<p>a human readable name you would like to give the model.</p>
</td></tr>
<tr><td><code id="add_model_+3A_code">code</code></td>
<td>
<p>literal model syntax you would like to run. You can use
<code>glue</code> inside formulas to dynamically generate variable names based on
a variable grid. For example, if you make variable grid with two versions
of your IVs (e.g., <code>iv1</code> and <code>iv2</code>), you can write your formula
like so: <code>lm(happiness ~ {iv} + control_var)</code>. The only requirement is
that the variables written in the formula actually exist in the underlying
data. You are also responsible for loading any packages that run a
particular model (e.g., <code>lme4</code> for mixed-models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess("scale_iv", 'mutate({ivs} = scale({ivs}))') |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * {mods}))
</code></pre>

<hr>
<h2 id='add_parameter_keys'>Add parameter keys names for later use in summarizing model effects</h2><span id='topic+add_parameter_keys'></span>

<h3>Description</h3>

<p>Add parameter keys names for later use in summarizing model effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_parameter_keys(.df, parameter_group, parameter_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_parameter_keys_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_parameter_keys_+3A_parameter_group">parameter_group</code></td>
<td>
<p>character, a name for the parameter of interest</p>
</td></tr>
<tr><td><code id="add_parameter_keys_+3A_parameter_name">parameter_name</code></td>
<td>
<p>quoted or unquoted names of variables involved in a
particular parameter of interest. Usually this is just a variable in your
model (e.g., a main effect of your iv). However, it could also be an
interaction term or some other term. You can use <code>glue</code> syntax to
specify an effect that might use alternative versions of the same variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * {mods})) |&gt;
  add_parameter_keys("my_interaction", "{ivs}:{mods}") |&gt;
  add_parameter_keys("my_main_effect", {ivs})
</code></pre>

<hr>
<h2 id='add_postprocess'>Add arbitrary postprocessing code to a multiverse pipeline</h2><span id='topic+add_postprocess'></span>

<h3>Description</h3>

<p>Add arbitrary postprocessing code to a multiverse pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_postprocess(.df, postprocess_name, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_postprocess_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_postprocess_+3A_postprocess_name">postprocess_name</code></td>
<td>
<p>a character string. A descriptive name for what the
postprocessing step accomplishes.</p>
</td></tr>
<tr><td><code id="add_postprocess_+3A_code">code</code></td>
<td>
<p>the literal code you would like to execute after each analysis.
</p>
<p>The code should be written to work with pipes (i.e., <code>|&gt;</code> or
<code>%&gt;%</code>). Because the post-processing code comes last in each
multiverse analysis step, the chosen model object will be passed to the
post-processing code.
</p>
<p>For example, if you fit a simple linear model like: <code>lm(y ~ x1 + x2)</code>,
and your post-processing code executes a call to <code>anova</code>, you would
simply pass <code>anova()</code> to <code>add_postprocess()</code>. The underlying code
would be:
</p>
<p><code>data |&gt; filters |&gt; lm(y ~ x1 + x2, data = _) |&gt; anova()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess("scale_iv", 'mutate({ivs} = scale({ivs}))') |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * {mods})) |&gt;
  add_postprocess("analysis of variance", aov())
</code></pre>

<hr>
<h2 id='add_preprocess'>Add arbitrary preprocessing code to a multiverse analysis pipeline</h2><span id='topic+add_preprocess'></span>

<h3>Description</h3>

<p>Add arbitrary preprocessing code to a multiverse analysis pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_preprocess(.df, process_name, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_preprocess_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_preprocess_+3A_process_name">process_name</code></td>
<td>
<p>a character string. A descriptive name for what the
preprocessing step accomplishes.</p>
</td></tr>
<tr><td><code id="add_preprocess_+3A_code">code</code></td>
<td>
<p>the literal code you would like to execute after data are
filtered. <code><a href="glue.html#topic+glue">glue</a></code> syntax is allowed. An example might be
centering or scaling a predictor after the appropriate filters are applied
to the data.
</p>
<p>The code should be written to work with pipes (i.e., <code>|&gt;</code> or
<code>%&gt;%</code>). Pre-processing code will eventually take the base data along
with any filters applied to the data. This means
<code><a href="dplyr.html#topic+mutate">mutate</a></code> calls are the most natural but other functions
that take a <code>data.frame</code> as the first argument should work as well (as
long as they also return a <code>data.frame</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess("scale_iv", 'mutate({ivs} = scale({ivs}))')
</code></pre>

<hr>
<h2 id='add_reliabilities'>Add item reliabilities to a multiverse pipeline</h2><span id='topic+add_reliabilities'></span>

<h3>Description</h3>

<p>Add item reliabilities to a multiverse pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_reliabilities(.df, scale_name, items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_reliabilities_+3A_.df">.df</code></td>
<td>
<p>the original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_reliabilities_+3A_scale_name">scale_name</code></td>
<td>
<p>a character string. Indicates the name of the scale or
measure measured by the items or indicators in <code>items</code>.</p>
</td></tr>
<tr><td><code id="add_reliabilities_+3A_items">items</code></td>
<td>
<p>the items (variables) that comprise a scale or measure. These
variables will be passed to <code>link[performance]{cronbachs_alpha}</code>,
<code>link[performance]{item_intercor}</code>, and
<code>link[performance]{item_reliability}</code>. You can also use tidyselect to
select variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_reliabilities("unp_scale", c(iv1,iv2,iv3))
</code></pre>

<hr>
<h2 id='add_summary_stats'>Add a set of descriptive statistics to compute over a set of variables</h2><span id='topic+add_summary_stats'></span>

<h3>Description</h3>

<p>Add a set of descriptive statistics to compute over a set of variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_summary_stats(.df, var_set, variables, stats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_summary_stats_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_summary_stats_+3A_var_set">var_set</code></td>
<td>
<p>a character string. A name for the set of summary statistics</p>
</td></tr>
<tr><td><code id="add_summary_stats_+3A_variables">variables</code></td>
<td>
<p>the variables for which you would like to compute summary
statistics. You can also use tidyselect to select variables.</p>
</td></tr>
<tr><td><code id="add_summary_stats_+3A_stats">stats</code></td>
<td>
<p>a character vector of stat names (e.g., <code>c("mean","sd")</code>).
You are responsible for loading any packages that compute your preferred
summary statistics. Summary statistic functions must work inside
<code><a href="dplyr.html#topic+summarize">summarize</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess(process_name = "scale_iv", 'mutate({ivs} = scale({ivs}))') |&gt;
  add_preprocess(process_name = "scale_mod", mutate({mods} := scale({mods}))) |&gt;
  add_summary_stats("iv_stats", starts_with("iv"), c("mean", "sd")) |&gt;
  add_summary_stats("dv_stats", starts_with("dv"), c("skewness", "kurtosis"))
</code></pre>

<hr>
<h2 id='add_variables'>Add a set of variable alternatives to a multiverse pipeline</h2><span id='topic+add_variables'></span>

<h3>Description</h3>

<p>Add a set of variable alternatives to a multiverse pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_variables(.df, var_group, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_variables_+3A_.df">.df</code></td>
<td>
<p>The original <code>data.frame</code>(e.g., base data set). If part of
set of add_* decision functions in a pipeline, the base data will be passed
along as an attribute.</p>
</td></tr>
<tr><td><code id="add_variables_+3A_var_group">var_group</code></td>
<td>
<p>a character string. Indicates the name of the current set.
For example, &quot;primary_iv&quot; could indicate this set are alternatives of the
main predictor in an analysis.</p>
</td></tr>
<tr><td><code id="add_variables_+3A_...">...</code></td>
<td>
<p>the bare unquoted names of the variables to include as alternative
options for this variable set. You can also use tidyselect to select
variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with three columns: type, group, and code. Type
indicates the decision type, group is a decision, and the code is the
actual code that will be executed. If part of a pipe, the current set of
decisions will be appended as new rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

the_data |&gt;
 add_variables("ivs", iv1, iv2, iv3) |&gt;
 add_variables("dvs", dv1, dv2) |&gt;
 add_variables("mods", starts_with("mod"))
</code></pre>

<hr>
<h2 id='condense'>Summarize multiverse parameters</h2><span id='topic+condense'></span>

<h3>Description</h3>

<p>Summarize multiverse parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense(.unpacked, .what, .how, .group = NULL, list_cols = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense_+3A_.unpacked">.unpacked</code></td>
<td>
<p>an unpacked (with <code><a href="#topic+reveal">reveal</a></code> or
<code><a href="tidyr.html#topic+unnest">unnest</a></code>) multiverse dataset.</p>
</td></tr>
<tr><td><code id="condense_+3A_.what">.what</code></td>
<td>
<p>a specific column to summarize. This could be a model estimate,
a summary statistic, correlation, or any other estimate computed over the
multiverse.</p>
</td></tr>
<tr><td><code id="condense_+3A_.how">.how</code></td>
<td>
<p>a named list. The list should contain summary functions (e.g.,
mean or median) the user would like to compute over the individual
estimates from the multiverse</p>
</td></tr>
<tr><td><code id="condense_+3A_.group">.group</code></td>
<td>
<p>an optional variable to group the results. This argument is
passed directly to the <code>.by</code> argument used in <code>dplyr::across</code></p>
</td></tr>
<tr><td><code id="condense_+3A_list_cols">list_cols</code></td>
<td>
<p>logical, whether to create list columns for the raw values
of any summarized columns. Useful for creating visualizations and tables.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summarized <code>tibble</code> containing a column for each summary
method from <code>.how</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear_model", lm({dvs} ~ {ivs} * {mods} + cov1))

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])

# Reveal and condense
the_multiverse |&gt;
  reveal_model_parameters() |&gt;
  filter(str_detect(parameter, "iv")) |&gt;
  condense(coefficient, list(mean = mean, median = median))
</code></pre>

<hr>
<h2 id='create_blueprint_graph'>Create a Analysis Pipeline diagram</h2><span id='topic+create_blueprint_graph'></span>

<h3>Description</h3>

<p>Create a Analysis Pipeline diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_blueprint_graph(
  .pipeline,
  splines = "line",
  render = TRUE,
  show_code = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_blueprint_graph_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
<tr><td><code id="create_blueprint_graph_+3A_splines">splines</code></td>
<td>
<p>options for how to draw edges (lines) for a grViz diagram</p>
</td></tr>
<tr><td><code id="create_blueprint_graph_+3A_render">render</code></td>
<td>
<p>whether to render the graph or just output grViz code</p>
</td></tr>
<tr><td><code id="create_blueprint_graph_+3A_show_code">show_code</code></td>
<td>
<p>whether to show the code that generated the diagram</p>
</td></tr>
<tr><td><code id="create_blueprint_graph_+3A_...">...</code></td>
<td>
<p>additional options passed to <code>DiagrammeR::grViz()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>grViz graph of your pipeline
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0, include2 != 3, include3 &gt; -2.5) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

create_blueprint_graph(full_pipeline)
</code></pre>

<hr>
<h2 id='detect_multiverse_n'>Detect total number of analysis pipelines</h2><span id='topic+detect_multiverse_n'></span>

<h3>Description</h3>

<p>Detect total number of analysis pipelines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_multiverse_n(.pipeline, include_models = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_multiverse_n_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
<tr><td><code id="detect_multiverse_n_+3A_include_models">include_models</code></td>
<td>
<p>Whether to count alternative models if you have more
than one <code>add_model()</code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, the total number of unique analysis pipelines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0, include2 != 3, include3 &gt; -2.5) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

detect_multiverse_n(full_pipeline)
</code></pre>

<hr>
<h2 id='detect_n_filters'>Detect total number of filtering expressions your pipelines</h2><span id='topic+detect_n_filters'></span>

<h3>Description</h3>

<p>Detect total number of filtering expressions your pipelines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_n_filters(.pipeline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_n_filters_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, the total number of filtering expressions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0, include2 != 3, include3 &gt; -2.5) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

detect_n_filters(full_pipeline)
</code></pre>

<hr>
<h2 id='detect_n_models'>Detect total number of models in your pipelines</h2><span id='topic+detect_n_models'></span>

<h3>Description</h3>

<p>Detect total number of models in your pipelines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_n_models(.pipeline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_n_models_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, the total number of unique models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0, include2 != 3, include3 &gt; -2.5) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

detect_n_models(full_pipeline)
</code></pre>

<hr>
<h2 id='detect_n_variables'>Detect total number of variable sets in your pipelines</h2><span id='topic+detect_n_variables'></span>

<h3>Description</h3>

<p>Detect total number of variable sets in your pipelines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_n_variables(.pipeline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_n_variables_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, the total number of unique variable sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0, include2 != 3, include3 &gt; -2.5) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

detect_n_variables(full_pipeline)
</code></pre>

<hr>
<h2 id='expand_decisions'>Expand a set of multiverse decisions into all possible combinations</h2><span id='topic+expand_decisions'></span>

<h3>Description</h3>

<p>Expand a set of multiverse decisions into all possible combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_decisions(.pipeline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_decisions_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nested <code>data.frame</code> containing all combinations of arbitrary
decisions for a multiverse analysis. Decision types will become list
columns matching the type of decisions called along the pipeline (e.g.,
filters, variables, etc.). Any decisions containing
<code><a href="glue.html#topic+glue">glue</a></code> syntax will be populated with the relevant
information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2, include3 &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess(process_name = "scale_iv", 'mutate({ivs} = scale({ivs}))') |&gt;
  add_preprocess(process_name = "scale_mod", mutate({mods} := scale({mods}))) |&gt;
  add_summary_stats("iv_stats", starts_with("iv"), c("mean", "sd")) |&gt;
  add_summary_stats("dv_stats", starts_with("dv"), c("skewness", "kurtosis")) |&gt;
  add_correlations("predictors", matches("iv|mod|cov"), focus_set = c(cov1,cov2)) |&gt;
  add_correlations("outcomes", matches("dv|mod"), focus_set = matches("dv")) |&gt;
  add_reliabilities("unp_scale", c(iv1,iv2,iv3)) |&gt;
  add_model("no covariates", lm({dvs} ~ {ivs} * {mods})) |&gt;
  add_model("with covariates", lm({dvs} ~ {ivs} * {mods} + cov1)) |&gt;
  add_postprocess("aov", aov())

pipeline_expanded &lt;- expand_decisions(full_pipeline)
</code></pre>

<hr>
<h2 id='multitool-package'>multitool: Run Multiverse Style Analyses</h2><span id='topic+multitool'></span><span id='topic+multitool-package'></span>

<h3>Description</h3>

<p>Run the same analysis over a range of arbitrary data processing decisions. 'multitool' provides an interface for creating alternative analysis pipelines and turning them into a grid of all possible pipelines. Using this grid as a blueprint, you can model your data across all possible pipelines and summarize the results.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ethan Young <a href="mailto:young.ethan.scott@gmail.com">young.ethan.scott@gmail.com</a> (<a href="https://orcid.org/0000-0002-8232-0184">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Stefan Vermeent <a href="mailto:p.c.s.vermeent@gmail.com">p.c.s.vermeent@gmail.com</a> (<a href="https://orcid.org/0000-0002-9595-5373">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ethan-young.github.io/multitool/">https://ethan-young.github.io/multitool/</a>
</p>
</li>
<li> <p><a href="https://github.com/ethan-young/multitool">https://github.com/ethan-young/multitool</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ethan-young/multitool/issues">https://github.com/ethan-young/multitool/issues</a>
</p>
</li></ul>


<hr>
<h2 id='reveal'>Reveal the contents of a multiverse analysis</h2><span id='topic+reveal'></span>

<h3>Description</h3>

<p>Reveal the contents of a multiverse analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal(.multi, .what, .which = NULL, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_+3A_.multi">.multi</code></td>
<td>
<p>a multiverse list-column <code>tibble</code> produced by
<code><a href="#topic+run_multiverse">run_multiverse</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_+3A_.what">.what</code></td>
<td>
<p>the name of a list-column you would like to unpack</p>
</td></tr>
<tr><td><code id="reveal_+3A_.which">.which</code></td>
<td>
<p>any sub-list columns you would like to unpack</p>
</td></tr>
<tr><td><code id="reveal_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the unnested part of the multiverse requested. This usually contains
the particular estimates or statistics you would like to analyze over the
decision grid specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear_model", lm({dvs} ~ {ivs} * {mods} + cov1))

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])

# Reveal results of the linear model
the_multiverse |&gt; reveal(model_fitted, model_parameters)
</code></pre>

<hr>
<h2 id='reveal_corrs'>Reveal a set of multiverse correlations</h2><span id='topic+reveal_corrs'></span>

<h3>Description</h3>

<p>Reveal a set of multiverse correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_corrs(.descriptives, .which, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_corrs_+3A_.descriptives">.descriptives</code></td>
<td>
<p>a descriptive multiverse list-column <code>tibble</code>
produced by <code><a href="#topic+run_descriptives">run_descriptives</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_corrs_+3A_.which">.which</code></td>
<td>
<p>the specific name of the correlations requested</p>
</td></tr>
<tr><td><code id="reveal_corrs_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an unnested set of correlations per decision from the
multiverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(
    include1 == 0,
    include2 != 3,
    include2 != 2,
    include3 &gt; -2.5,
    include3 &lt; 2.5,
    between(include3, -2.5, 2.5)
  ) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_correlations("predictors", starts_with("iv")) |&gt;
  add_summary_stats("iv_stats", starts_with("iv"), c("mean", "sd")) |&gt;
  add_reliabilities("vio_scale", starts_with("iv")) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

my_descriptives &lt;- run_descriptives(full_pipeline)

my_descriptives |&gt;
  reveal_corrs(predictors_rs)
</code></pre>

<hr>
<h2 id='reveal_model_messages'>Reveal any messages about your models during a multiverse analysis</h2><span id='topic+reveal_model_messages'></span>

<h3>Description</h3>

<p>Reveal any messages about your models during a multiverse analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_model_messages(.multi, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_model_messages_+3A_.multi">.multi</code></td>
<td>
<p>a multiverse list-column <code>tibble</code> produced by
<code><a href="#topic+run_multiverse">run_multiverse</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_model_messages_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the unnested model messages captured during analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear_model", lm({dvs} ~ {ivs} * {mods} + cov1))

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])

# Reveal results of the linear model
the_multiverse |&gt;
  reveal_model_messages()
</code></pre>

<hr>
<h2 id='reveal_model_parameters'>Reveal the model parameters of a multiverse analysis</h2><span id='topic+reveal_model_parameters'></span>

<h3>Description</h3>

<p>Reveal the model parameters of a multiverse analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_model_parameters(.multi, parameter_key = NULL, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_model_parameters_+3A_.multi">.multi</code></td>
<td>
<p>a multiverse list-column <code>tibble</code> produced by
<code><a href="#topic+run_multiverse">run_multiverse</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_model_parameters_+3A_parameter_key">parameter_key</code></td>
<td>
<p>character, if you added parameter keys to your pipeline,
you can specify if you would like filter the parameters using one of your
parameter keys. This is useful when different variables are being switched
out across the multiverse but represent the same effect of interest.</p>
</td></tr>
<tr><td><code id="reveal_model_parameters_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the unnested model paramerters from the multiverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear_model", lm({dvs} ~ {ivs} * {mods} + cov1))

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])

# Reveal results of the linear model
the_multiverse |&gt;
  reveal_model_parameters()
</code></pre>

<hr>
<h2 id='reveal_model_performance'>Reveal the model performance/fit indices from a multiverse analysis</h2><span id='topic+reveal_model_performance'></span>

<h3>Description</h3>

<p>Reveal the model performance/fit indices from a multiverse analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_model_performance(.multi, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_model_performance_+3A_.multi">.multi</code></td>
<td>
<p>a multiverse list-column <code>tibble</code> produced by
<code><a href="#topic+run_multiverse">run_multiverse</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_model_performance_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the unnested model performance/fit indices from a multiverse
analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear_model", lm({dvs} ~ {ivs} * {mods} + cov1))

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])

# Reveal results of the linear model
the_multiverse |&gt;
  reveal_model_performance()
</code></pre>

<hr>
<h2 id='reveal_model_warnings'>Reveal any warnings about your models during a multiverse analysis</h2><span id='topic+reveal_model_warnings'></span>

<h3>Description</h3>

<p>Reveal any warnings about your models during a multiverse analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_model_warnings(.multi, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_model_warnings_+3A_.multi">.multi</code></td>
<td>
<p>a multiverse list-column <code>tibble</code> produced by
<code><a href="#topic+run_multiverse">run_multiverse</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_model_warnings_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the unnested model warnings captured during analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_model("linear_model", lm({dvs} ~ {ivs} * {mods} + cov1))

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])

# Reveal results of the linear model
the_multiverse |&gt;
  reveal_model_warnings()
</code></pre>

<hr>
<h2 id='reveal_reliabilities'>Reveal a set of multiverse cronbach's alpha statistics</h2><span id='topic+reveal_reliabilities'></span>

<h3>Description</h3>

<p>Reveal a set of multiverse cronbach's alpha statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_reliabilities(.descriptives, .which, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_reliabilities_+3A_.descriptives">.descriptives</code></td>
<td>
<p>a descriptive multiverse list-column <code>tibble</code>
produced by <code><a href="#topic+run_descriptives">run_descriptives</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_reliabilities_+3A_.which">.which</code></td>
<td>
<p>the specific name of the alphas</p>
</td></tr>
<tr><td><code id="reveal_reliabilities_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an unnested set of correlations per decision from the multiverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(
    include1 == 0,
    include2 != 3,
    include2 != 2,
    include3 &gt; -2.5,
    include3 &lt; 2.5,
    between(include3, -2.5, 2.5)
  ) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_correlations("predictor correlations", starts_with("iv")) |&gt;
  add_summary_stats("iv_stats", starts_with("iv"), c("mean", "sd")) |&gt;
  add_reliabilities("vio_scale", starts_with("iv")) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

my_descriptives &lt;- run_descriptives(full_pipeline)

my_descriptives |&gt;
  reveal_reliabilities(vio_scale_alpha)
</code></pre>

<hr>
<h2 id='reveal_summary_stats'>Reveal a set of summary statistics from a multiverse analysis</h2><span id='topic+reveal_summary_stats'></span>

<h3>Description</h3>

<p>Reveal a set of summary statistics from a multiverse analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reveal_summary_stats(.descriptives, .which, .unpack_specs = "no")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reveal_summary_stats_+3A_.descriptives">.descriptives</code></td>
<td>
<p>a descriptive multiverse list-column <code>tibble</code>
produced by <code><a href="#topic+run_descriptives">run_descriptives</a></code>.</p>
</td></tr>
<tr><td><code id="reveal_summary_stats_+3A_.which">.which</code></td>
<td>
<p>the specific name of the summary statistics</p>
</td></tr>
<tr><td><code id="reveal_summary_stats_+3A_.unpack_specs">.unpack_specs</code></td>
<td>
<p>character, options are <code>"no"</code>, <code>"wide"</code>, or
<code>"long"</code>. <code>"no"</code> (default) keeps specifications in a list column,
<code>wide</code> unnests specifications with each specification category as a
column. <code>"long"</code> unnests specifications and stacks them into long
format, which stacks specifications into a <code>decision_set</code> and
<code>alternatives</code> columns. This is mainly useful for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an unnested set of summary statistics per decision from the
multiverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(
    include1 == 0,
    include2 != 3,
    include2 != 2,
    include3 &gt; -2.5,
    include3 &lt; 2.5,
    between(include3, -2.5, 2.5)
  ) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_correlations("predictor correlations", starts_with("iv")) |&gt;
  add_summary_stats("iv_stats", starts_with("iv"), c("mean", "sd")) |&gt;
  add_reliabilities("vio_scale", starts_with("iv")) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

my_descriptives &lt;- run_descriptives(full_pipeline)

my_descriptives |&gt;
  reveal_summary_stats(iv_stats)
</code></pre>

<hr>
<h2 id='run_descriptives'>Run a multiverse-style descriptive analysis based on a complete decision grid</h2><span id='topic+run_descriptives'></span>

<h3>Description</h3>

<p>Run a multiverse-style descriptive analysis based on a complete decision grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_descriptives(.pipeline, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_descriptives_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>tibble</code> produced by a series of <code>add_*</code> calls.
Importantly, this needs to be a pre-expanded pipeline because descriptive
analyses only change when the underlying cases change. Thus, only filtering
decisions will be used and internally expanded before calculating various
descriptive analyses.</p>
</td></tr>
<tr><td><code id="run_descriptives_+3A_show_progress">show_progress</code></td>
<td>
<p>logical, whether to show a progress bar while running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single <code>tibble</code> containing tidied results for all descriptive
analyses specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_summary_stats("iv_stats", starts_with("iv"), c("mean", "sd")) |&gt;
  add_summary_stats("dv_stats", starts_with("dv"), c("skewness", "kurtosis")) |&gt;
  add_correlations("predictors", matches("iv|mod|cov"), focus_set = c(cov1,cov2)) |&gt;
  add_correlations("outcomes", matches("dv|mod"), focus_set = matches("dv")) |&gt;
  add_reliabilities("unp_scale", c(iv1,iv2,iv3)) |&gt;
  add_reliabilities("vio_scale", starts_with("mod"))

run_descriptives(full_pipeline)
</code></pre>

<hr>
<h2 id='run_multiverse'>Run a multiverse based on a complete decision grid</h2><span id='topic+run_multiverse'></span>

<h3>Description</h3>

<p>Run a multiverse based on a complete decision grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_multiverse(.grid, ncores = 1, save_model = FALSE, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_multiverse_+3A_.grid">.grid</code></td>
<td>
<p>a <code>tibble</code> produced by <code><a href="#topic+expand_decisions">expand_decisions</a></code></p>
</td></tr>
<tr><td><code id="run_multiverse_+3A_ncores">ncores</code></td>
<td>
<p>numeric. The number of cores you want to use for parallel
processing.</p>
</td></tr>
<tr><td><code id="run_multiverse_+3A_save_model">save_model</code></td>
<td>
<p>logical, indicates whether to save the model object in its
entirety. The default is <code>FALSE</code> because model objects are usually
large and under the hood, <code><a href="parameters.html#topic+parameters">parameters</a></code> and
<code><a href="performance.html#topic+performance">performance</a></code> is used to summarize the most useful
model information.</p>
</td></tr>
<tr><td><code id="run_multiverse_+3A_show_progress">show_progress</code></td>
<td>
<p>logical, whether to show a progress bar while running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single <code>tibble</code> containing tidied results for the model and
any post-processing tests/tasks. For each unique test (e.g., an <code>lm</code>
or <code>aov</code> called on an <code>lm</code>), a list column with the function name
is created with <code><a href="parameters.html#topic+parameters">parameters</a></code> and
<code><a href="performance.html#topic+performance">performance</a></code> and any warnings or messages printed
while fitting the models. Internally, modeling and post-processing
functions are checked to see if there are tidy or glance methods available.
If not, <code>summary</code> will be called instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# Simulate some data
the_data &lt;-
  data.frame(
    id   = 1:500,
    iv1  = rnorm(500),
    iv2  = rnorm(500),
    iv3  = rnorm(500),
    mod1 = rnorm(500),
    mod2 = rnorm(500),
    mod3 = rnorm(500),
    cov1 = rnorm(500),
    cov2 = rnorm(500),
    dv1  = rnorm(500),
    dv2  = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# Decision pipeline
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0,include2 != 3,include2 != 2,scale(include3) &gt; -2.5) |&gt;
  add_variables("ivs", iv1, iv2, iv3) |&gt;
  add_variables("dvs", dv1, dv2) |&gt;
  add_variables("mods", starts_with("mod")) |&gt;
  add_preprocess(process_name = "scale_iv", 'mutate({ivs} = scale({ivs}))') |&gt;
  add_preprocess(process_name = "scale_mod", mutate({mods} := scale({mods}))) |&gt;
  add_model("no covariates",lm({dvs} ~ {ivs} * {mods})) |&gt;
  add_model("covariate", lm({dvs} ~ {ivs} * {mods} + cov1)) |&gt;
  add_postprocess("aov", aov())

pipeline_grid &lt;- expand_decisions(full_pipeline)

# Run the whole multiverse
the_multiverse &lt;- run_multiverse(pipeline_grid[1:10,])
</code></pre>

<hr>
<h2 id='show_code_filter'>Show multiverse data code pipelines</h2><span id='topic+show_code_filter'></span><span id='topic+show_code_preprocess'></span><span id='topic+show_code_model'></span><span id='topic+show_code_postprocess'></span><span id='topic+show_code_summary_stats'></span><span id='topic+show_code_corrs'></span><span id='topic+show_code_reliabilities'></span>

<h3>Description</h3>

<p>Each <code>show_code*</code> function should be self-explanatory - they indicate
where along the multiverse pipeline to extract code. The goal of these
functions is to create a window into each multiverse decision set
context/results and allow the user to inspect specific decisions straight from
the code that produced it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_code_filter(.grid, decision_num, copy = FALSE)

show_code_preprocess(.grid, decision_num, copy = FALSE)

show_code_model(.grid, decision_num, copy = FALSE)

show_code_postprocess(.grid, decision_num, copy = FALSE)

show_code_summary_stats(.grid, decision_num, copy = FALSE)

show_code_corrs(.grid, decision_num, copy = FALSE)

show_code_reliabilities(.grid, decision_num, copy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_code_filter_+3A_.grid">.grid</code></td>
<td>
<p>a full decision grid created by <code><a href="#topic+expand_decisions">expand_decisions</a></code>.</p>
</td></tr>
<tr><td><code id="show_code_filter_+3A_decision_num">decision_num</code></td>
<td>
<p>numeric. Indicates which 'universe' in the multiverse to
show underlying code.</p>
</td></tr>
<tr><td><code id="show_code_filter_+3A_copy">copy</code></td>
<td>
<p>logical. Whether to copy the pipeline code to the clipboard using
<code><a href="clipr.html#topic+write_clip">write_clip</a></code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the code that generated results up to the specified point in an
analysis pipeline. The code is printed in the console and can be optionally
copied to the clipboard.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>show_code_preprocess()</code>: Show the code up to the preprocessing stage
</p>
</li>
<li> <p><code>show_code_model()</code>: Show the code up to the modeling stage
</p>
</li>
<li> <p><code>show_code_postprocess()</code>: Show the code up to the post-processing
stage
</p>
</li>
<li> <p><code>show_code_summary_stats()</code>: Show the code for computing summary statistics
</p>
</li>
<li> <p><code>show_code_corrs()</code>: Show the code for computing correlations
</p>
</li>
<li> <p><code>show_code_reliabilities()</code>: Show the code for computing scale reliability
</p>
</li></ul>

<hr>
<h2 id='summarize_filter_ns'>Summarize samples sizes for each unique filtering expression</h2><span id='topic+summarize_filter_ns'></span>

<h3>Description</h3>

<p>Summarize samples sizes for each unique filtering expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_filter_ns(.pipeline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_filter_ns_+3A_.pipeline">.pipeline</code></td>
<td>
<p>a <code>data.frame</code> produced by calling a series of add_*
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>tibble</code> with each row representing a filtering expression and
four columns: <code>filter_expression</code>, <code>variable</code>, <code>n_retained</code>,
and <code>n_excluded</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidyverse)
library(multitool)

# create some data
the_data &lt;-
  data.frame(
    id  = 1:500,
    iv1 = rnorm(500),
    iv2 = rnorm(500),
    iv3 = rnorm(500),
    mod = rnorm(500),
    dv1 = rnorm(500),
    dv2 = rnorm(500),
    include1 = rbinom(500, size = 1, prob = .1),
    include2 = sample(1:3, size = 500, replace = TRUE),
    include3 = rnorm(500)
  )

# create a pipeline blueprint
full_pipeline &lt;-
  the_data |&gt;
  add_filters(include1 == 0, include2 != 3, include3 &gt; -2.5) |&gt;
  add_variables(var_group = "ivs", iv1, iv2, iv3) |&gt;
  add_variables(var_group = "dvs", dv1, dv2) |&gt;
  add_model("linear model", lm({dvs} ~ {ivs} * mod))

summarize_filter_ns(full_pipeline)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
