<!DOCTYPE html><html><head><title>Help for package nos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nos-package'><p>nos: A package for calculating node overlap and segregation in ecological</p>
networks</a></li>
<li><a href='#boreal'><p>A sample food-web network from the boreal region of the Barents Sea</p></a></li>
<li><a href='#freqMat_2_edge'><p>Convert a frequency interaction matrix to an edge list</p></a></li>
<li><a href='#NOSM_bip'><p>Compute NOS using a bipartite network</p></a></li>
<li><a href='#NOSM_dir'><p>Compute NOS using a directed network without a user provided network</p>
of potential interactions</a></li>
<li><a href='#NOSM_POT_dir'><p>Compute NOS using a directed network and with a user provided network</p>
of potential interactions</a></li>
<li><a href='#NOSM_POT_undir'><p>Compute NOS using an undirected network and with a user provided</p>
network of potential interactions</a></li>
<li><a href='#NOSM_undir'><p>Compute NOS using an undirected network without a user provided</p>
network of potential interactions</a></li>
<li><a href='#summary.NOSM'><p>Summarising the results of the five main NOSM functions</p></a></li>
<li><a href='#testList'><p>Unit tests data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute Node Overlap and Segregation in Ecological Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate NOS (node overlap and segregation) and
    the associated metrics described in Strona and Veech (2015)
    &lt;<a href="https://doi.org/10.1111%2F2041-210X.12395">doi:10.1111/2041-210X.12395</a>&gt; and Strona et al. (2018) 
    &lt;<a href="https://doi.org/10.1111%2Fecog.03447">doi:10.1111/ecog.03447</a>&gt;. The functions provided in the 
    package enable assessment of structural patterns ranging from
    complete node segregation to perfect nestedness in a variety 
    of network types. In addition, they provide a measure of 
    network modularity.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/txm676/nos">https://github.com/txm676/nos</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/txm676/nos/issues">https://github.com/txm676/nos/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, gmp, stats, bipartite</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 18:15:58 UTC; Tom</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Matthews <a href="https://orcid.org/0000-0002-7624-244X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Giovanni Strona <a href="https://orcid.org/0000-0003-2294-4013"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Matthews &lt;txm676@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-22 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nos-package'>nos: A package for calculating node overlap and segregation in ecological
networks</h2><span id='topic+nos-package'></span>

<h3>Description</h3>

<p>A package to calculate NOS (node overlap and segregation) and
the associated metrics described in Strona and Veech (2015) and Strona et
al. (2017). The functions provided in the package enable assessment of
structural patterns ranging from complete node segregation to perfect
nestedness in a variety of network types. In addition, they provide a
measure of network modularity.
</p>
<p>Does not currently work on Macs (OS X El Capitan) as the dependent
gmp package is not yet available in binary form for OS X El Capitan.
</p>


<h3>Details</h3>

<p>There are five main S3 generics that the user can choose depending
on whether a directed, bipartite or undirected network is provided as
input, and whether a network of potential interactions (pot_net) is
available from the user. These five functions are: 1) NOSM_dir - for
directed unimode networks (e.g. food webs) when pot_net is not provided, 2)
NOSM_undir - for undirected networks (e.g. co-occurrence networks) when
pot_net is not provided, 3) NOSM_bip - for bipartite networks (e.g.
plant-pollinator networks), 4) NOSM_pot_dir - for directed unimode (e.g.
food webs) and bipartite networks when pot_net is provided, and 5)
NOSM_pot_undir - for undirected networks (e.g. co-occurrence networks) when
pot_net is provided.
</p>
<p>Each of these five main functions produces an output with class 'NOSM'. An
S3 method (summary.NOSM) provides the summary statistics of interest (e.g..
NOS, Mod/network modularity, effect size Z, and p-value).
</p>
<p>If a network of potential interactions is not provided, the computation will
be made according to the following criteria: in an undirected network, all
nodes will be considered as potential interacting partners; in a directed,
unimode network, all nodes having at least an in-coming link will be
considered as potential partners for nodes having at least an out-going link
and vice-versa; in a bipartite network, where nodes can be formally
categorized into two distinct categories (e.g. plant-pollinators) all nodes
in one category will be considered as potential partners for the nodes in
the other category (and vice-versa).
</p>
<p>Input data should be in the form of an edge list or frequency interaction
matrix (this can be either a bipartite graph type or a squared adjacency
matrix type). If the input data are in the format of a frequency interaction
matrix, as used in the <a href="bipartite.html#topic+bipartite">bipartite</a> R package, then
<code><a href="#topic+freqMat_2_edge">freqMat_2_edge</a></code> should be used first, to convert the
interaction matrix to an edge list prior to running any 'nos' functions.
</p>
<p>The internal function comb calculates factorials. If the user provided
n or k are too large (&gt; roughly 170) factorial(n || k) produces Inf.
In these cases gmp::factorialZ is used instead. See the help documentation
for the 'gmp' package for further information.
</p>
<p>It should be noted that due to differences in the way R and Python calculate
the standard deviation, the modularity values and z values calculated using
this R package differ very slightly (less than 0.2) from the values
calculated using the Python scrip from Strona et al. (2017).
</p>


<h3>Author(s)</h3>

<p>Thomas J. Matthews and Giovanni Strona
</p>


<h3>References</h3>

<p>Strona, G., Matthews, T.J., Kortsch, S. and Veech, J.A. (2017)
NOS: A software suite to compute node overlap and segregation in
ecological networks. Ecography. In review.
</p>

<hr>
<h2 id='boreal'>A sample food-web network from the boreal region of the Barents Sea</h2><span id='topic+boreal'></span>

<h3>Description</h3>

<p>The sample network is a marine food web from the boreal region of the Barents
Sea. The Barents Sea is a large, open sub-arctic shelf sea bordering the
Arctic Ocean. The sample food web contains 180 trophospecies, consisting of
detritus, 8 basal taxa, 32 zooplankton, 66 benthic, 56 fish, 8 sea birds and
9 marine mammal, and 1546 feeding interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(boreal)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 columns and 1546 rows. Each row is a node pair
where the first element of each node pair is 'consumed' (or pollinated
etc) by the second element.
</p>


<h3>Source</h3>

<p>Kortsch, S. et al. 2015. Climate change alters the structure of
arctic marine food webs due to poleward shifts of boreal generalists.
Proc. R. Soc. B 282: 20151546.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
</code></pre>

<hr>
<h2 id='freqMat_2_edge'>Convert a frequency interaction matrix to an edge list</h2><span id='topic+freqMat_2_edge'></span>

<h3>Description</h3>

<p>Converts frequency interaction matrices, as used with the
<a href="bipartite.html#topic+bipartite">bipartite</a> R package, into edge lists. The input matrix
can be either a matrix representing a bipartite graph or a squared
adjacency matrix. As the functions in the 'nos' R package are based on
presence-absence data, all interactions greater than or equal to 1 are set
to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqMat_2_edge(x, bip = FALSE, sp_nam = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqMat_2_edge_+3A_x">x</code></td>
<td>
<p>A frequency interaction matrix, in which rows and columns represent
species and each value should be numeric, indicating the number of
interactions between two species. The input frequency interaction matrix
can be in the form of a squared adjacency matrix (e.g. a food web, where
the rows and columns represent the same set of species) or representing a
bipartite graph where rows and columns correspond to different entities. In
regards to the latter, the rows must correspond to species that are
consumed (or pollinated etc) and columns are those species that are the
consumers (or pollinators etc). For example, for a plant-pollinator
interaction matrix, the rows would be the plant species, and the columns
the pollinator species. The input interaction matrix can be a dataframe or
a matrix. The names of the species can be set as the rownames and column
names of the interaction matrix prior to running the function; if names are
not provided, the function automatically names the species (see below). As
the functions in the 'nos' R package are based on presence-absence data,
all interactions greater than or equal to 1 are set to 1. Cannibalistic
interactions are allowed, i.e. the same species can be in a row and column.</p>
</td></tr>
<tr><td><code id="freqMat_2_edge_+3A_bip">bip</code></td>
<td>
<p>A logical value describing whether the input matrix represents a
bipartite graph (bip = TRUE), or a squared adjaceny matrix (bip = FALSE: the
default).</p>
</td></tr>
<tr><td><code id="freqMat_2_edge_+3A_sp_nam">sp_nam</code></td>
<td>
<p>A logical value describing whether the user has provided.
species names i.e. row and column names (sp_nam = TRUE) or not (sp_nam = FALSE:
the default).If species names are not provided and the input matrix is a
squared adjaceny matrix, the rows and columns are given the same identity
values (i.e. numbers). If the input matrix represent a bipartite graph,
rows and columns are assumed to correspond to different entities and are
given different unique values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge list in the form of a dataframe. Each value in a column is a
node (e.g. a food item in a trophic-web). Nodes are set as numeric values.
For each row (i.e. node pair), the value in the first column is 'consumed'
(or pollinated, parasitized etc) by the value in the second column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_dat &lt;- matrix(c(0, 2, 1, 0, 1, 2, 0, 1), ncol = 4) #simulate bipartite matrix
rownames(sim_dat) &lt;- c("A", "B") #name the consumed species
colnames(sim_dat) &lt;- c("C", "D", "A", "E") #name the consumer species
freqMat_2_edge(sim_dat, bip = TRUE, sp_nam = TRUE)
</code></pre>

<hr>
<h2 id='NOSM_bip'>Compute NOS using a bipartite network</h2><span id='topic+NOSM_bip'></span>

<h3>Description</h3>

<p>Computation of NOS using a bipartite network (e.g.
plant-pollinator network), where nodes can be formally categorized into two
distinct categories (e.g. plant-pollinators). All nodes in one category
will be considered as potential partners for the nodes in the other
category (and vice-versa).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOSM_bip(net, perc = 1, sl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOSM_bip_+3A_net">net</code></td>
<td>
<p>A network, in the form of an edge list. This should be a matrix or
dataframe with two columns. Each value in a column is a node (e.g. a food
item in a trophic-web). Nodes can be identified using numbers or
characters. For each row (i.e. node pair), the value in the first column is
'consumed' (or pollinated, parasitized etc) by the value in the second
column. Data can also be in the format of a frequency interaction matrix,
as used in the <a href="bipartite.html#topic+bipartite">bipartite</a> R package. In these cases
<code><a href="#topic+freqMat_2_edge">freqMat_2_edge</a></code> should be used first, to convert the
interaction matrix to an edge list.</p>
</td></tr>
<tr><td><code id="NOSM_bip_+3A_perc">perc</code></td>
<td>
<p>(default to 1) - the fraction of node pair comparisons to be
performed to compute NOS. We recommend performing all possible pair
comparisons (perc = 1). However, for exploratory analyses on large sets of
networks (or for very large networks), the possibility of using a lower
fraction of pair comparisons is a useful option.</p>
</td></tr>
<tr><td><code id="NOSM_bip_+3A_sl">sl</code></td>
<td>
<p>(default is 1) Specifies whether cannibalistic interactions should
be considered as possible and therefore taken into account and removed
during computation ('1') or not ('0').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (two elements) of class 'NOSM' with a 'Type' attribute 'bip'.
The first element in the list is a vector of overlap values for the &quot;in
nodes&quot; and the second element is a vector of overlap values for the &quot;out
nodes&quot;.
</p>
<p>The <code><a href="#topic+summary.NOSM">summary.NOSM</a></code> methods provides more useful summary
statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
y &lt;-  boreal[sample(rownames(boreal), 100, FALSE),] #subset 100 rows for speed
x &lt;- NOSM_bip(y, perc = 1, sl = 1)
summary(x)
</code></pre>

<hr>
<h2 id='NOSM_dir'>Compute NOS using a directed network without a user provided network
of potential interactions</h2><span id='topic+NOSM_dir'></span>

<h3>Description</h3>

<p>Computation of NOS using a directed network (e.g. food
web) and without a user provided network of potential interactions. In a
directed, unimode network, all nodes having at least an in-coming link will
be considered as potential partners for nodes having at least an out-going
link and vice-versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOSM_dir(net, perc = 1, sl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOSM_dir_+3A_net">net</code></td>
<td>
<p>A network, in the form of an edge list. This should be a matrix or
dataframe with two columns. Each value in a column is a node (e.g. a food
item in a trophic-web). Nodes can be identified using numbers or
characters. For each row (i.e. node pair), the value in the first column is
'consumed' (or pollinated, parasitized etc) by the value in the second
column. Data can also be in the format of a frequency interaction matrix,
as used in the <a href="bipartite.html#topic+bipartite">bipartite</a> R package. In these cases
<code><a href="#topic+freqMat_2_edge">freqMat_2_edge</a></code> should be used first, to convert the
interaction matrix to an edge list.</p>
</td></tr>
<tr><td><code id="NOSM_dir_+3A_perc">perc</code></td>
<td>
<p>(default to 1) - the fraction of node pair comparisons to be
performed to compute NOS. We recommend performing all possible pair
comparisons (perc = 1). However, for exploratory analyses on large sets of
networks (or for very large networks), the possibility of using a lower
fraction of pair comparisons is a useful option.</p>
</td></tr>
<tr><td><code id="NOSM_dir_+3A_sl">sl</code></td>
<td>
<p>(default is 1) Specifies whether cannibalistic interactions should
be considered as possible and therefore taken into account and removed
during computation ('1') or not ('0').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (two elements) of class 'NOSM' with a 'Type' attribute 'Dir'.
The first element in the list is a vector of overlap values for the &quot;in
nodes&quot; and the second element is a vector of overlap values for the &quot;out
nodes&quot;.
</p>
<p>The <code><a href="#topic+summary.NOSM">summary.NOSM</a></code> methods provides more useful summary
statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
y &lt;-  boreal[sample(rownames(boreal), 100, FALSE),] #subset 100 rows for speed
x &lt;- NOSM_dir(y, perc = 1, sl = 1)
summary(x)
</code></pre>

<hr>
<h2 id='NOSM_POT_dir'>Compute NOS using a directed network and with a user provided network
of potential interactions</h2><span id='topic+NOSM_POT_dir'></span>

<h3>Description</h3>

<p>Computation of NOS using an directed network (e.g. a
food web) and with a user provided network of potential interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOSM_POT_dir(net, pot_net, perc = 1, sl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOSM_POT_dir_+3A_net">net</code></td>
<td>
<p>A network, in the form of an edge list. This should be a matrix or
dataframe with two columns. Each value in a column is a node. Nodes can be
identified using numbers or characters.Data can also be in the format of a
frequency interaction matrix, as used in the <a href="bipartite.html#topic+bipartite">bipartite</a> R
package. In these cases <code><a href="#topic+freqMat_2_edge">freqMat_2_edge</a></code> should be used first,
to convert the interaction matrix to an edge list.</p>
</td></tr>
<tr><td><code id="NOSM_POT_dir_+3A_pot_net">pot_net</code></td>
<td>
<p>A network of all potential interactions. These should include,
as a minimum, all the observed interactions (i.e. all links in net),plus
any other possible interaction (such as all those permitted by a certain
trophic rule). pot_net should have the same structure as net (e.g. it
should be a data frame or matrix).</p>
</td></tr>
<tr><td><code id="NOSM_POT_dir_+3A_perc">perc</code></td>
<td>
<p>(default to 1) - the fraction of node pair comparisons to be
performed to compute NOS. We recommend performing all possible pair
comparisons (perc = 1). However, for exploratory analyses on large sets of
networks (or for very large networks), the possibility of using a lower
fraction of pair comparisons is a useful option.</p>
</td></tr>
<tr><td><code id="NOSM_POT_dir_+3A_sl">sl</code></td>
<td>
<p>(default is 1) Specifies whether cannibalistic interactions should
be considered as possible and therefore taken into account and removed
during computation ('1') or not ('0').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (two elements) of class 'NOSM' with a 'Type' attribute
'Pot_dir'. The first element in the list is a vector of overlap values for
the &quot;in nodes&quot; and the second element is a vector of overlap values for the
&quot;out nodes&quot;.
</p>
<p>The <code><a href="#topic+summary.NOSM">summary.NOSM</a></code> methods provides more useful summary
statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
y &lt;-  boreal[1:300,] #subset 300 rows for speed
d &lt;- sample(nrow(y), 200, replace = FALSE) #create a random pot_net
pot_net &lt;- y[d,] #by randomly sampling 200 rows from boreal
x &lt;- NOSM_POT_dir(y, pot_net, perc = 1, sl = 1)
summary(x)
</code></pre>

<hr>
<h2 id='NOSM_POT_undir'>Compute NOS using an undirected network and with a user provided
network of potential interactions</h2><span id='topic+NOSM_POT_undir'></span>

<h3>Description</h3>

<p>Computation of NOS using an undirected network (e.g. a
social co-occurence network) and with a user provided network of potential interactions.
In an undirected network, all nodes are considered as potential interacting
partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOSM_POT_undir(net, pot_net, perc = 1, sl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOSM_POT_undir_+3A_net">net</code></td>
<td>
<p>A network, in the form of an edge list. This should be a matrix or
dataframe with two columns. Each value in a column is a node. Nodes can be
identified using numbers or characters.Data can also be in the format of a
frequency interaction matrix, as used in the <a href="bipartite.html#topic+bipartite">bipartite</a> R
package. In these cases <code><a href="#topic+freqMat_2_edge">freqMat_2_edge</a></code> should be used first,
to convert the interaction matrix to an edge list.</p>
</td></tr>
<tr><td><code id="NOSM_POT_undir_+3A_pot_net">pot_net</code></td>
<td>
<p>A network of all potential interactions. These should include,
as a minimum, all the observed interactions (i.e. all links in net),plus
any other possible interaction (such as all those permitted by a certain
trophic rule). pot_net should have the same structure as net (e.g. it
should be a data frame or matrix).</p>
</td></tr>
<tr><td><code id="NOSM_POT_undir_+3A_perc">perc</code></td>
<td>
<p>(default to 1) - the fraction of node pair comparisons to be
performed to compute NOS. We recommend performing all possible pair
comparisons (perc = 1). However, for exploratory analyses on large sets of
networks (or for very large networks), the possibility of using a lower
fraction of pair comparisons is a useful option.</p>
</td></tr>
<tr><td><code id="NOSM_POT_undir_+3A_sl">sl</code></td>
<td>
<p>(default is 1) Specifies whether cannibalistic interactions should
be considered as possible and therefore taken into account and removed
during computation ('1') or not ('0').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'NOSM' with a 'Type' attribute 'Pot_undir',
containing a vector of overlap values. The <code><a href="#topic+summary.NOSM">summary.NOSM</a></code>
methods provides more useful summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
y &lt;-  boreal[1:300,] #subset 300 rows for speed
d &lt;- sample(nrow(y), 200, replace = FALSE) #create a random pot_net
pot_net &lt;- y[d,] #by randomly sampling 200 rows from boreal
x &lt;- NOSM_POT_undir(y, pot_net, perc = 1, sl = 1)
summary(x)
</code></pre>

<hr>
<h2 id='NOSM_undir'>Compute NOS using an undirected network without a user provided
network of potential interactions</h2><span id='topic+NOSM_undir'></span>

<h3>Description</h3>

<p>Computation of NOS using an undirected network (e.g. a
social co-occurence network) and without a user provided network of potential
interactions. In an undirected network, all nodes are considered as
potential interacting partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOSM_undir(net, perc = 1, sl = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOSM_undir_+3A_net">net</code></td>
<td>
<p>A network, in the form of an edge list. This should be a matrix or
dataframe with two columns. Each value in a column is a node. Nodes can be
identified using numbers or characters. Data can also be in the format of a
frequency interaction matrix, as used in the <a href="bipartite.html#topic+bipartite">bipartite</a> R
package. In these cases <code><a href="#topic+freqMat_2_edge">freqMat_2_edge</a></code> should be used first,
to convert the interaction matrix to an edge list.</p>
</td></tr>
<tr><td><code id="NOSM_undir_+3A_perc">perc</code></td>
<td>
<p>(default to 1) - the fraction of node pair comparisons to be
performed to compute NOS. We recommend performing all possible pair
comparisons (perc = 1). However, for exploratory analyses on large sets of
networks (or for very large networks), the possibility of using a lower
fraction of pair comparisons is a useful option.</p>
</td></tr>
<tr><td><code id="NOSM_undir_+3A_sl">sl</code></td>
<td>
<p>(default is 1) Specifies whether cannibalistic interactions should
be considered as possible and therefore taken into account and removed
during computation ('1') or not ('0').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'NOSM' with a 'Type' attribute 'Undir', containing a
vector of overlap values. The <code><a href="#topic+summary.NOSM">summary.NOSM</a></code> methods provides
more useful summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
y &lt;-  boreal[sample(rownames(boreal), 100, FALSE),] #subset 100 rows for speed
x &lt;- NOSM_undir(y, perc = 1, sl = 1)
summary(x)
</code></pre>

<hr>
<h2 id='summary.NOSM'>Summarising the results of the five main NOSM functions</h2><span id='topic+summary.NOSM'></span>

<h3>Description</h3>

<p>S3 method for class 'NOSM'. summary.NOSM creates summary
statistics for objects of class NOSM. The exact summary statistics computed
depends on the 'Type' attribute (e.g. 'bip') of the NOSM object (see
below). The summary method generates more useful information for the user
than the standard NOSM functions. Another S3 method (print.summary.NOSM;
not documented) is used to print the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NOSM'
summary(object, ..., y = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NOSM_+3A_object">object</code></td>
<td>
<p>An object of class 'NOSM'.</p>
</td></tr>
<tr><td><code id="summary.NOSM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.NOSM_+3A_y">y</code></td>
<td>
<p>(default of 3) The adjustment value for the computation of the z
value (see Strona &amp; Veech, 2015).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object of class 'summary.NOSM' with a Type attribute (e.g.
'bip') which is inherited. For NOSM objects of Type 'Pot_dir', 'bip' or
'Dir', the summary.NOSM method returns the mean of the overlap values for
the &quot;in nodes&quot; (NOS_In), the mean of the overlap values for the &quot;out nodes&quot;
(NOS_Out), the mean of Nos In and Nos Out (NOS), the standard
deviation of the overlap values for the &quot;in nodes&quot; (MOD_In), the SD of the
overlap values for the &quot;out nodes&quot; (MOD_Out), and the SD of the combined
set of overlap values (MOD; network modularity).
</p>
<p>For NOSM objects of Type 'Dir' and 'Undir', the summary.NOSM method returns
just the NOS and MOD values (network modularity).
</p>
<p>For all types of NOSM object, the z value and associated p value are also
provided (see Strona &amp; Veech, 2015).
</p>


<h3>References</h3>

<p>Strona, G. &amp; Veech, J. A. (2015). A new measure of ecological
network structure based on node overlap and segregation. Methods in Ecology
and Evolution, 6(8), 907-915.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NOSM_bip">NOSM_bip</a></code>, <code><a href="#topic+NOSM_POT_dir">NOSM_POT_dir</a></code>,
<code><a href="#topic+NOSM_POT_undir">NOSM_POT_undir</a></code>, <code><a href="#topic+NOSM_dir">NOSM_dir</a></code>,
<code><a href="#topic+NOSM_undir">NOSM_undir</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boreal)
z &lt;- boreal[sample(rownames(boreal), 200, FALSE),] #subset for speed
x &lt;- NOSM_bip(z, perc = 1, sl = 1)
summary(x, y = 3)
</code></pre>

<hr>
<h2 id='testList'>Unit tests data</h2><span id='topic+testList'></span>

<h3>Description</h3>

<p>Datasets used in the unit tests. Is a list with two elements,
each representing a different dataset. Each dataset is a list
with four elements, the first three being input data, and the
fourth the output data. All generated using the python nos
package to ensure the results match up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testList
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testList)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
