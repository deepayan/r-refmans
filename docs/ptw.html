<!DOCTYPE html><html><head><title>Help for package ptw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ptw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ptw-package'>
<p>Parametric Time Warping</p></a></li>
<li><a href='#asysm'><p>Trend estimation with asymmetric least squares</p></a></li>
<li><a href='#baseline.corr'><p>Baseline Correction using asymmetric least squares</p></a></li>
<li><a href='#bestref'><p>Identification of optimal reference</p></a></li>
<li><a href='#calc.multicoef'><p>Calculation of warping coefficients when applying more than one</p>
warping function successively</a></li>
<li><a href='#calc.zerocoef'><p>Correction for warping coefficients when using zeropadding</p></a></li>
<li><a href='#coda'><p>Chromatogram selection using the CODA algorithm</p></a></li>
<li><a href='#difsm'><p>Smoothing with a finite difference penalty</p></a></li>
<li><a href='#gaschrom'><p>16 calibration GC traces</p></a></li>
<li><a href='#lcms'><p>Parts of 3 proteomic LC-MS samples</p></a></li>
<li><a href='#mzchannel2pktab'>
<p>Conversion between peak lists from hyphenated MS (LCMS, GCMS, ...) data</p>
and input for <code>stptw</code>.</a></li>
<li><a href='#padzeros'><p>Pad matrix with zeros</p></a></li>
<li><a href='#plot.ptw'><p>Plot a ptw object</p></a></li>
<li><a href='#predict.ptw'><p>Prediction of warped signals</p></a></li>
<li><a href='#ptw'><p>Parametric Time Warping</p></a></li>
<li><a href='#ptwgrid'><p>Calculate RMS or WCC values on a grid</p></a></li>
<li><a href='#RMS'><p>Quality criteria for comparing patterns with shifts</p></a></li>
<li><a href='#select.traces'>
<p>Select traces from a data set according to several criteria</p></a></li>
<li><a href='#warp.time'><p>Transform time according to a given warping function</p></a></li>
<li><a href='#wcc'>
<p>Weighted auto- and cross-correlation measures</p></a></li>
<li><a href='#whit1'><p>Weighted Whittaker smoothing with a first order finite difference penalty</p></a></li>
<li><a href='#whit2'><p>Weighted Whittaker smoothing with a second order finite difference penalty</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parametric Time Warping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Parametric Time Warping aligns patterns, i.e. it aims to
        put corresponding features at the same locations. The algorithm
        searches for an optimal polynomial describing the warping. It
        is possible to align one sample to a reference, several samples
        to the same reference, or several samples to several
        references. One can choose between calculating individual
        warpings, or one global warping for a set of samples and one
        reference. Two optimization criteria are implemented: RMS (Root
        Mean Square error) and WCC (Weighted Cross Correlation). Both
	warping of peak profiles and of peak lists are supported. A
	vignette for the latter is contained in the inst/doc directory
	of the source package - the vignette source can be found on
	the package github site.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rwehrens/ptw">https://github.com/rwehrens/ptw</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppDE, graphics, grDevices, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-19 11:55:55 UTC; ron</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Gerretzen [ctb],
  Paul Eilers [aut],
  Hans Wouters [ctb],
  Tom Bloemberg [aut],
  Ron Wehrens [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ron Wehrens &lt;ron.wehrens@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-19 13:42:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='ptw-package'>
Parametric Time Warping
</h2><span id='topic+ptw-package'></span>

<h3>Description</h3>

<p>Parametric Time Warping aligns patterns, i.e. it aims to
        put corresponding features at the same locations. The algorithm
        searches for an optimal polynomial describing the warping. It
        is possible to align one sample to a reference, several samples
        to the same reference, or several samples to several
        references. One can choose between calculating individual
        warpings, or one global warping for a set of samples and one
        reference. Two optimization criteria are implemented: RMS (Root
        Mean Square error) and WCC (Weighted Cross Correlation). Both
	warping of peak profiles and of peak lists are supported. A
	vignette for the latter is contained in the inst/doc directory
	of the source package - the vignette source can be found on
	the package github site.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ptw</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Parametric Time Warping</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.9-16</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Jan", "Gerretzen", role = "ctb"),
             person("Paul", "Eilers", role = "aut"),
	     person("Hans", "Wouters", role = "ctb"),
	     person("Tom", "Bloemberg", role = "aut",
	            email = "t.bloemberg@science.ru.nl"),
	     person("Ron", "Wehrens", role = c("aut", "cre"),
	            email = "ron.wehrens@gmail.com"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Parametric Time Warping aligns patterns, i.e. it aims to
        put corresponding features at the same locations. The algorithm
        searches for an optimal polynomial describing the warping. It
        is possible to align one sample to a reference, several samples
        to the same reference, or several samples to several
        references. One can choose between calculating individual
        warpings, or one global warping for a set of samples and one
        reference. Two optimization criteria are implemented: RMS (Root
        Mean Square error) and WCC (Weighted Cross Correlation). Both
	warping of peak profiles and of peak lists are supported. A
	vignette for the latter is contained in the inst/doc directory
	of the source package - the vignette source can be found on
	the package github site.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/rwehrens/ptw</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> RcppDE, graphics, grDevices, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Jan Gerretzen [ctb],
  Paul Eilers [aut],
  Hans Wouters [ctb],
  Tom Bloemberg [aut],
  Ron Wehrens [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Ron Wehrens &lt;ron.wehrens@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>


<h3>References</h3>

<p>@ArticleBloemberg2010,
title = Improved Parametric Time Warping for Proteomics,
author = Tom G. Bloemberg and Jan Gerretzen and Hans J. P. Wouters and Jolein Gloerich and Maurice van Dael and Hans J. C. T. Wessels and Lambert P. van den Heuvel and Paul H. C. Eilers and Lutgarde M. C. Buydens and Ron Wehrens,
year = 2010,
journal = Chemometrics and Intelligent Laboratory Systems,
volume = 104,
number = 1,
pages = 65-74,

</p>
<p>ArticleWehrens2015,
title = Fast parametric warping of peak lists,
author = Ron Wehrens and Tom G. Bloemberg and Paul H. C. Eilers,
year = 2015,
volume = 31,
pages = 3063&ndash;3065,
journal = Bioinformatics,
doi = 10.1093/bioinformatics/btv299,

</p>

<hr>
<h2 id='asysm'>Trend estimation with asymmetric least squares</h2><span id='topic+asysm'></span>

<h3>Description</h3>

<p>Estimates a trend based on asymmetric least squares. In
this case used to estimate the baseline of a given spectrum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  asysm(y, lambda = 1e+07, p = 0.001, eps = 1e-8, maxit = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asysm_+3A_y">y</code></td>
<td>
<p>data: either a vector or a data matrix containing spectra as rows</p>
</td></tr>
<tr><td><code id="asysm_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter (generally 1e5 - 1e8)</p>
</td></tr>
<tr><td><code id="asysm_+3A_p">p</code></td>
<td>
<p>asymmetry parameter</p>
</td></tr>
<tr><td><code id="asysm_+3A_eps">eps</code></td>
<td>
<p>numerical precision for convergence</p>
</td></tr>
<tr><td><code id="asysm_+3A_maxit">maxit</code></td>
<td>
<p>max number of iterations. If no convergence is reached, a
warning is issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Asymmetric least squares (not to be confused with alternating
least squares) assigns different weights to the data points that are
above and below an iteratively estimated trendline, respectively. In
this case, the asymmetry parameter p (0 &lt;= p &lt;= 1) is the weight for
points above the trendline, whereas 1-p is the weight for points below
it. Naturally, p should be small for estimating baselines. The
parameter lambda controls the amount of smoothing: the larger it is,
the smoother the trendline will be.
</p>


<h3>Value</h3>

<p>An estimated baseline</p>


<h3>Author(s)</h3>

<p>Paul Eilers, Jan Gerretzen</p>


<h3>References</h3>

<p>Eilers, P.H.C.
Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>
<p>Boelens, H.F.M., Eilers, P.H.C., Hankemeier, T. (2005) &quot;Sign constraints improve the detection of differences between complex spectral data sets: LC-IR as an example&quot;, Analytical Chemistry, <b>77</b>, 7998 &ndash; 8007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
plot(gaschrom[1,], type = "l", ylim = c(0, 100))
lines(asysm(gaschrom[1,]), col = 2)
</code></pre>

<hr>
<h2 id='baseline.corr'>Baseline Correction using asymmetric least squares</h2><span id='topic+baseline.corr'></span>

<h3>Description</h3>

<p>This function estimates a baseline using asymmetric least
squares and subtracts it from the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline.corr(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline.corr_+3A_y">y</code></td>
<td>
<p>signal(s) to correct. This can be a vector (containing one
signal) or a matrix of signals(one signal per row)</p>
</td></tr>
<tr><td><code id="baseline.corr_+3A_...">...</code></td>
<td>
<p>other arguments to the <code>asysm</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>ycorr</code></td>
<td>
<p>baseline corrected signal(s): a vector or a matrix of the
same dimension as the input signal(s)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Eilers, Jan Gerretzen</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
plot(gaschrom[1,], type = "l", ylim = c(0, 100))
lines(baseline.corr(gaschrom[1,]), col = 2)
</code></pre>

<hr>
<h2 id='bestref'>Identification of optimal reference</h2><span id='topic+bestref'></span>

<h3>Description</h3>

<p>This function calculates a similarity matrix and returns
the sample number that is most similar to all other samples. This is
possibly preferable as a reference sample since warping then may be
kept to a minimum. Either RMS or WCC may be used as similarity
functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestref(x, optim.crit = c("WCC", "RMS"),
               trwdth=20, wghts = NULL, smooth.param = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestref_+3A_x">x</code></td>
<td>
<p>data matrix or array of signals, specified row-wise. In case of an array, the third dimension should differentiate between the different samples</p>
</td></tr>
<tr><td><code id="bestref_+3A_optim.crit">optim.crit</code></td>
<td>
<p>either <code>"WCC"</code> or <code>"RMS"</code></p>
</td></tr>
<tr><td><code id="bestref_+3A_trwdth">trwdth</code></td>
<td>
<p>the width of the triangle in the WCC criterion, given as
a number of data points. Default: 20</p>
</td></tr>
<tr><td><code id="bestref_+3A_wghts">wghts</code></td>
<td>
<p>Optional weights vector in the WCC criterion; will be
calculated from the triangle width if necessary. Sometimes it is
more efficient to pre-calculate it and give it as an argument</p>
</td></tr>
<tr><td><code id="bestref_+3A_smooth.param">smooth.param</code></td>
<td>
<p>smoothing parameter for smoothing the signal when
<code>optim.crit</code> equals <code>"RMS"</code>. If no smoothing is required,
set this to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>
<table>
<tr><td><code>best.ref</code></td>
<td>
<p>the index of the best reference(s)</p>
</td></tr>
<tr><td><code>crit.values</code></td>
<td>
<p>the qualities as measured by either RMS or WCC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Gerretzen, Ron Wehrens</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
bestref(gaschrom)
bestref(gaschrom, optim.crit = "WCC", trwdth = 50)
bestref(gaschrom, optim.crit = "RMS")
bestref(gaschrom, optim.crit = "RMS", smooth.param = 1e5)
</code></pre>

<hr>
<h2 id='calc.multicoef'>Calculation of warping coefficients when applying more than one
warping function successively</h2><span id='topic+calc.multicoef'></span>

<h3>Description</h3>

<p>Applying two (or more) warping function after each other
can be described with one warping function of a higher warping
degree. This function provides the coefficients of this higher degree
warping function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.multicoef(coef1, coef2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.multicoef_+3A_coef1">coef1</code></td>
<td>
<p>vector containing the warping coefficients of the first
applied warping function</p>
</td></tr> 
<tr><td><code id="calc.multicoef_+3A_coef2">coef2</code></td>
<td>
<p>vector containing the warping coefficients of the second
applied warping function</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function uses Pascal's simplex to calculate the new
warping coefficients. 
</p>
<p>When applying three warping functions successively (first a, then b and
finally c - here a, b and c are vectors of warping coefficients), first
calculate the new coefficients for b and c, and afterwards the
coefficients for a with these new coefficients. So the coefficients for
the total warping function can be calculated via <code>calc.multicoef(a,
  calc.multicoef(b, c))</code>. 
</p>


<h3>Value</h3>

<p>a vector containing the corrected warping coefficients</p>


<h3>Author(s)</h3>

<p>Jan Gerretzen</p>


<h3>References</h3>

<p>Bloemberg, T.G., et al. (2010) &quot;Improved parametric time warping for Proteomics&quot;, Chemometrics and Intelligent Laboratory Systems, <b>104</b> (1), 65 &ndash; 74.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc.zerocoef">calc.zerocoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[16,]
coef1 &lt;- c(100,1.1, 1e-5)
coef2 &lt;- c(25, 0.95, 3.2e-5)
gaschrom.ptw &lt;- ptw(ref, samp, init.coef = coef1, try = TRUE)
ref.w &lt;- gaschrom.ptw$reference
samp.w &lt;- gaschrom.ptw$warped.sample
samp.w[is.na(samp.w)] &lt;- 0
gaschrom.ptw2 &lt;- ptw(ref.w, samp.w, init.coef = coef2, try = TRUE)
plot(c(gaschrom.ptw2$warped.sample), type = "l")

corr.coef &lt;- calc.multicoef(coef1, coef2)
gaschrom.ptw3 &lt;- ptw(ref, samp, init.coef = corr.coef, try = TRUE)
lines(c(gaschrom.ptw3$warped.sample), col = 2, lty = 2)
</code></pre>

<hr>
<h2 id='calc.zerocoef'>Correction for warping coefficients when using zeropadding</h2><span id='topic+calc.zerocoef'></span>

<h3>Description</h3>

<p>This function calculates the warping coefficients for the
original range of the data, based on the warping of zero-filled
data. Only needed when zeros are added in the beginning of the signal.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.zerocoef(coef, zeros)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.zerocoef_+3A_coef">coef</code></td>
<td>
<p>vector of warping coefficients of a PTW-calculation on a
set of signals with zeros added to the beginning of the signal</p>
</td></tr> 
<tr><td><code id="calc.zerocoef_+3A_zeros">zeros</code></td>
<td>
<p>the number of zeros added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the corrected warping coefficients</p>


<h3>Author(s)</h3>

<p>Jan Gerretzen</p>


<h3>References</h3>

<p>Bloemberg, T.G., et al. (2010) &quot;Improved parametric time warping for Proteomics&quot;, Chemometrics and Intelligent Laboratory Systems, <b>104</b> (1), 65 &ndash; 74.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+padzeros">padzeros</a></code>
<code><a href="#topic+calc.multicoef">calc.multicoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
gaschrom.zf &lt;- padzeros(gaschrom, 250)
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[16,]
ref.zf &lt;- gaschrom.zf[1,]
samp.zf &lt;- gaschrom.zf[16,]
gaschrom.ptw &lt;- ptw(ref.zf, samp.zf)
layout(matrix(1:2,2,1, byrow=TRUE))
plot(gaschrom.ptw)
corr.coef &lt;- calc.zerocoef(gaschrom.ptw$warp.coef, 250)
gaschrom.ptw2 &lt;- ptw(ref, samp, init.coef = corr.coef, try = TRUE)
plot(gaschrom.ptw2)
</code></pre>

<hr>
<h2 id='coda'>Chromatogram selection using the CODA algorithm</h2><span id='topic+coda'></span>

<h3>Description</h3>

<p>The CODA algorithm calculates a so-called MCQ (Mass Chromatogram
Quality) value for every row of the input. High MCQ values correspond
with those chromatograms not containing spikes and/or a baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coda(x, window = 5, smoothing = c("median", "mean"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coda_+3A_x">x</code></td>
<td>
<p>data matrix containing chromatograms in the rows</p>
</td></tr>
<tr><td><code id="coda_+3A_window">window</code></td>
<td>
<p>width of the smoothing window</p>
</td></tr>
<tr><td><code id="coda_+3A_smoothing">smoothing</code></td>
<td>
<p>type of smoothing: whether to use running means or
running medians</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MCQ value of a spectrum is the inner product between the
standardized, smoothed chromatogram, and the length-scaled
chromatogram. In literature, a cut-off of 0.85 has been reported to
work well in selecting useful chromatograms, although this is strongly
data-set dependent.
</p>


<h3>References</h3>

<p>Windig, W., Phalp, J., Payna, A. (1996) &quot;A noise and background reduction method for component detection in liquid chromatography/mass spectrometry&quot;,
Analytical Chemistry, <b>68</b>, 3602 &ndash; 3606.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
coda(gaschrom)
</code></pre>

<hr>
<h2 id='difsm'>Smoothing with a finite difference penalty</h2><span id='topic+difsm'></span>

<h3>Description</h3>

<p>This function smoothes signals with a finite difference penalty of
order 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difsm(y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difsm_+3A_y">y</code></td>
<td>
<p>signal to be smoothed: a vector</p>
</td></tr>
<tr><td><code id="difsm_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter: larger values lead to smoothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed signal: a vector</p>


<h3>Author(s)</h3>

<p>Paul Eilers, Jan Gerretzen</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>
<p>Eilers, P.H.C. (2003) &quot;A perfect smoother&quot;, Analytical Chemistry, <b>75</b>, 3631 &ndash; 3636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(gaschrom)
  plot(gaschrom[1,], type = "l", ylim = c(0, 100))
  lines(difsm(gaschrom[1,], lambda = 1e5), col = 2)
  lines(difsm(gaschrom[1,], lambda = 1e6), col = 3)
  lines(difsm(gaschrom[1,], lambda = 1e7), col = 4)
  </code></pre>

<hr>
<h2 id='gaschrom'>16 calibration GC traces</h2><span id='topic+gaschrom'></span><span id='topic+gaschrom.st'></span>

<h3>Description</h3>

<p>The object <code>gaschrom</code> contains 16 calibration GC traces, measured
at 5,000 time points. A peak-picked version is available as object
<code>gaschrom.st</code> (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gaschrom)
</code></pre>


<h3>Source</h3>

<p>Claire Boucon, Unilever</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)

## the gaschrom.st object has been generated in the following way:
## Not run: 
pick.peaks &lt;- function(x, span) {
  span.width &lt;- span * 2 + 1
  loc.max &lt;- span.width + 1 -
      apply(embed(x, span.width), 1, which.max)
  loc.max[loc.max == 1 | loc.max == span.width] &lt;- NA
  
  pks &lt;- loc.max + 0:(length(loc.max)-1)
  pks &lt;- pks[!is.na(pks)]
  pks.tab &lt;- table(pks)
  
  pks.id &lt;- as.numeric(names(pks.tab)[pks.tab &gt; span])
  
  cbind(rt = pks.id, I = x[pks.id])
}

gaschrom &lt;- t(apply(gaschrom, 1, baseline.corr))
gaschrom.st &lt;- lapply(1:nrow(gaschrom), 
                      function(ii) 
                      pick.peaks(gaschrom[ii,], span = 11))
## remove peaks with an intensity below 10
gaschrom.st &lt;- lapply(gaschrom.st,
                      function(pk)
                      pk[pk[,2] &gt;= 10,])

## End(Not run)
plot(gaschrom[1,], type = "l", xlim = c(3000, 3500), ylim = c(0, 200))
abline(h = 10, lty = 2, col = 2)
abline(v = gaschrom.st[[1]], col = 4)
</code></pre>

<hr>
<h2 id='lcms'>Parts of 3 proteomic LC-MS samples</h2><span id='topic+lcms'></span><span id='topic+time'></span><span id='topic+mz'></span><span id='topic+lcms.pks'></span>

<h3>Description</h3>

<p>The <code>lcms</code> data consists of a 100 x 2000 x 3 array <code>lcms</code>, a
vector <code>time</code> of length 2000 and a vector <code>mz</code> of length 100. The
LC-MS data in the array are a subset (samples 1, 2 and 5) of a larger
set measured on a tryptic digest of E. coli proteins (see
<code>source</code> section). Separate objects <code>mz</code> and <code>rt</code> give
the values for the first two axis.
</p>
<p>Peak picking leads to the object ldms.pks (see example section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lcms)
</code></pre>


<h3>Source</h3>

<p>Nijmegen Proteomics Facility, Department of Laboratory Medicine,
Radboud University Nijmegen Medical Centre. Data available (in
different formats) at
http://www.cac.science.ru.nl/research/data/ecoli/</p>


<h3>References</h3>

<p>Bloemberg, T.G., et al. (2010)
&quot;Improved parametric time warping for Proteomics&quot;, Chemometrics and
Intelligent Laboratory Systems, <b>104</b> (1), 65 &ndash; 74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the lcms.pks object is generated in the following way:
## Not run: 
data(lcms)
pick.peaks &lt;- function(x, span) {
  span.width &lt;- span * 2 + 1
  loc.max &lt;- span.width + 1 -
      apply(embed(x, span.width), 1, which.max)
  loc.max[loc.max == 1 | loc.max == span.width] &lt;- NA
  
  pks &lt;- loc.max + 0:(length(loc.max)-1)
  pks &lt;- pks[!is.na(pks)]
  pks.tab &lt;- table(pks)
  
  pks.id &lt;- as.numeric(names(pks.tab)[pks.tab &gt; span])
  
  cbind(rt = pks.id, I = x[pks.id])
}

## bring all samples to the same scale, copied from ptw man page
lcms.scaled &lt;- aperm(apply(lcms, c(1,3), 
                           function(x) x/mean(x) ), c(2,1,3))
lcms.s.z &lt;- aperm(apply(lcms.scaled, c(1,3), 
                        function(x) padzeros(x, 250) ), c(2,1,3))
lcms.pks &lt;- lapply(1:3,
                   function(ii) {
                     lapply(1:nrow(lcms.s.z[,,ii]),
                            function(jj)
                            cbind("mz" = jj,
                                  pick.peaks(lcms.s.z[jj,,ii], 5)))
                   })

## End(Not run)</code></pre>

<hr>
<h2 id='mzchannel2pktab'>
Conversion between peak lists from hyphenated MS (LCMS, GCMS, ...) data
and input for <code>stptw</code>.
</h2><span id='topic+mzchannel2pktab'></span><span id='topic+pktab2mzchannel'></span>

<h3>Description</h3>

<p>Function pktab2mzchannel allows to split a list of peaks
into several sublists, for instance on the basis of m/z values. The
result can be aligned with <code>stptw</code>. The peak list can be obtained
from packages like <code>XCMS</code>. The reverse function,
mzchannel2pktab, simply gathers all peak positions in one matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pktab2mzchannel(pktab, Ivalue = "maxo", masses = NULL, nMasses = 0, massDigits = 2) 
mzchannel2pktab(mzchannels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mzchannel2pktab_+3A_pktab">pktab</code></td>
<td>
<p>a peak table as generated for example by XCMS. Necessary
information: m/z value (column name &quot;mz&quot;), retention time (column
name &quot;rt&quot;) and intensity.</p>
</td></tr>
<tr><td><code id="mzchannel2pktab_+3A_ivalue">Ivalue</code></td>
<td>
<p>the name of the intensity value to be used. Default is
&quot;maxo&quot;, one of the columns generated by the XCMS package.</p>
</td></tr>
<tr><td><code id="mzchannel2pktab_+3A_masses">masses</code></td>
<td>
<p>a vector of specific masses</p>
</td></tr>
<tr><td><code id="mzchannel2pktab_+3A_nmasses">nMasses</code></td>
<td>
<p>an optional number limiting the number of mass
channels. When both <code>masses</code> and <code>nMasses</code> are defined,
the former takes preference</p>
</td></tr>
<tr><td><code id="mzchannel2pktab_+3A_massdigits">massDigits</code></td>
<td>
<p>number of significant mass digits - if no
<code>masses</code> are supplied this number determines the number of
distinct categories in the output</p>
</td></tr>
<tr><td><code id="mzchannel2pktab_+3A_mzchannels">mzchannels</code></td>
<td>
<p>a list of peak matrices, e.g. the output of
<code>pktab2mzchannel</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>pktab2mzchannel</code> returns a list of peak matrices; list
elements have the name of the mz value that they represent. Function
<code>mzchannel2pktab</code> returns one peak matrix where all masses are in a
specific column.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lcms)
## first couple of peaks in the first three channels
(smallset &lt;- lapply(lcms.pks[[1]][1:3], head))
## all in one data matrix
allpeaks &lt;- mzchannel2pktab(smallset)
## and back again
pktab2mzchannel(allpeaks, Ivalue = "I")
</code></pre>

<hr>
<h2 id='padzeros'>Pad matrix with zeros</h2><span id='topic+padzeros'></span>

<h3>Description</h3>

<p>Adds zeros to the left side of a matrix or vector, to its right side, or to both sides.</p>


<h3>Usage</h3>

<pre><code class='language-R'>padzeros(data, nzeros, side="both")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padzeros_+3A_data">data</code></td>
<td>
<p>the original matrix or vector</p>
</td></tr>
<tr><td><code id="padzeros_+3A_nzeros">nzeros</code></td>
<td>
<p>number of columns to add on one side</p>
</td></tr>
<tr><td><code id="padzeros_+3A_side">side</code></td>
<td>
<p>to which side to add the zeros - choose between &quot;<code>both</code>&quot;, &quot;<code>left</code>&quot; or &quot;<code>right</code>&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>data</code> is a numeric vector, it is converted to a matrix of a single row.</p>


<h3>Value</h3>

<p>A matrix with the same number of rows as the original matrix, and extra columns containing zeros on the specified side or sides</p>


<h3>Author(s)</h3>

<p>Jan Gerretzen</p>


<h3>References</h3>

<p>Bloemberg, T.G., et al. (2010) &quot;Improved parametric time warping for Proteomics&quot;, Chemometrics and Intelligent Laboratory Systems, <b>104</b> (1), 65 &ndash; 74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lcms)
lcms.z1 &lt;- padzeros(lcms[75,,1], 250, side="left")
lcms.z2 &lt;- padzeros(lcms[75,,1], 250, side="right")
lcms.z3 &lt;- padzeros(lcms[75,,1], 250, side="both")
zeros &lt;- rep(0, 250)

layout(matrix(1:4,2,2, byrow=TRUE))
plot(lcms[75,,1], type="l", main="Original signal")

plot(as.vector(lcms.z1), type="l", main="Padzeros left side")
points(1:250, zeros, col=2, lwd=0.08)

plot(as.vector(lcms.z2), type="l", main="Padzeros right side")
points(2001:2250, zeros, col=2, lwd=0.08)

plot(as.vector(lcms.z3), type="l", main="Padzeros both sides")
points(1:250, zeros, col=2, lwd=0.08)
points(2251:2500, zeros, col=2, lwd=0.08)
</code></pre>

<hr>
<h2 id='plot.ptw'>Plot a ptw object</h2><span id='topic+plot.ptw'></span>

<h3>Description</h3>

<p>The function plots a <code>ptw</code> object. It shows either the original and
warped signals, or the warping function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptw'
plot(x, what = c("signal", "function"),
         type = c("simultaneous", "individual"), ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ptw_+3A_x">x</code></td>
<td>
<p>object of class 'ptw'</p>
</td></tr>
<tr><td><code id="plot.ptw_+3A_what">what</code></td>
<td>
<p><code>"signal"</code> plots the reference, sample and warped
sample signal(s); <code>"function"</code> plots the warping function as 
warped 'time' - 'time' for the forward warping mode and as 'time' - 
warped 'time' for the backward warping mode.</p>
</td></tr>
<tr><td><code id="plot.ptw_+3A_type">type</code></td>
<td>
<p><code>"simultaneous"</code> plots all signals or warping
functions in one plot; <code>"individual"</code> generates multiple plots</p>
</td></tr>
<tr><td><code id="plot.ptw_+3A_ask">ask</code></td>
<td>
<p>logical, whether to ask before showing a new plot</p>
</td></tr>
<tr><td><code id="plot.ptw_+3A_...">...</code></td>
<td>
<p>further arguments to the plotting functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Gerretzen, Ron Wehrens, Tom Bloemberg</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
ref &lt;- gaschrom[1:8,]
samp &lt;- gaschrom[9:16,]
gaschrom.ptw &lt;- ptw(ref, samp, warp.type = "individual",
                    optim.crit = "RMS", init.coef = c(0, 1, 0))
plot(gaschrom.ptw)
plot(gaschrom.ptw, what = "function")
</code></pre>

<hr>
<h2 id='predict.ptw'>Prediction of warped signals</h2><span id='topic+predict.ptw'></span>

<h3>Description</h3>

<p>Given a ptw object, predict either the signal at a certain
warped time, or the warped time itself.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptw'
predict(object, newdata, what = c("response", "time"),
  RTref = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ptw_+3A_object">object</code></td>
<td>
<p>An object of class &quot;ptw&quot;</p>
</td></tr>
<tr><td><code id="predict.ptw_+3A_newdata">newdata</code></td>
<td>
<p>Optional vector or matrix of new data points. If
<code>what</code> equals &quot;response&quot;, the new data should be a vector or
matrix of intensities. If <code>what</code> equals &quot;time&quot;, the new data is
a vector of time points (a matrix of time points makes no sense...).</p>
</td></tr>
<tr><td><code id="predict.ptw_+3A_what">what</code></td>
<td>
<p>Either &quot;response&quot;, in which case the function returns the
warped signal, or &quot;time&quot;, and then the function returns the warped
time axis. That is, the time point in the warped sample
corresponding to the given time point in the original sample.</p>
</td></tr>
<tr><td><code id="predict.ptw_+3A_rtref">RTref</code></td>
<td>
<p>Optional vector of retention times in the reference.</p>
</td></tr>
<tr><td><code id="predict.ptw_+3A_...">...</code></td>
<td>
<p>Further arguments, at the moment not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a matrix (possibly containing only one
row) of either warped time points or signals, warped according to the
warping function defined in <code>object</code>. When warping signals
individually, <code>predict.ptw</code> will check the dimension of  
<code>newdata</code>: if this is a vector or a matrix of one row, every
single warping function will be applied to the one row. If the
number of rows equals the number of warping functions, each row will
be warped with its corresponding function. If the number of rows does
not match the number of warping functions and is not equal to one, an
error is given.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>Eilers, P.H.C. &quot;Parametric Time Warping.&quot; Anal. Chem., 2004, 76, 404-411
</p>
<p>Bloemberg, T.G. et al. &quot;Improved parametric time warping for
proteomics.&quot; Chemom. Intell. Lab. Syst., 2010, 104, pp. 65-74
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptw">ptw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## educational example, contributed by zeehio (Sergio Oller)
x1 &lt;- c(rep(0, 5), 1,1,1, 20, 40, 20, 1, 1, 1, rep(0, 5))
x2 &lt;- c(rep(0, 6), 1,1,1, 20, 40, 20, 1, 1, 1, rep(0, 4))
time &lt;- 1:length(x1)
## get time-warped object. Default: 'forward' warping, also works
## with backward warping
w1b &lt;- ptw(ref = x1, samp = x2) 
## predict intensities of object x2 after warping at the times used in x1
x2wb &lt;- predict(w1b, newdata = x2, what = "response")
## predict times where the original elements of x2 will end up
t2wb &lt;- as.numeric(predict(w1b, newdata = time, what = "time"))

graphics.off()
par(mfrow = c(2,1))
plot(x1, type = "h", col = 2, lwd = 2, main = "Orig data")
points(x2, type = "h", col = 4)

plot(x1, type = "h", col = 2, lwd = 2, main = "Backward warping")
points(c(x2wb), type = "h", col = 4) # what = "response"
points(t2wb, x2, col = 4)            # what = "time"

## more relevant example
data(gaschrom)
## Global warping: all samples warped with the same function
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[14:16,]
gp &lt;- ptw(ref, samp, init.coef = c(0, 1), warp.type = "global")
matplot(t(samp), type = "l", xlim = c(2200, 2400), lty = 1, col = 1:3)
lines(ref, type = "l", col = "gray", lwd = 2)
## plot predicted warped signal directly
matlines(t(predict(gp)), lty = 2, col = 1:3)
## plot original signal at warped time axis
matlines(t(predict(gp, newdata = 2001:2600, what = "time")),
         t(samp[,2001:2600]), col = 1:3, lwd = 3, lty = 2) ## OK
## result: good alignment with ref, differences between three profiles persist

## Individual warping: all samples warped individually
gp &lt;- ptw(ref, samp, init.coef = c(0, 1), warp.type = "indiv")
predict(gp, what = "time", newdata = 2001:2600)
matplot(t(samp), type = "l", xlim = c(2200, 2400), lty = 1, col = 1:3)
lines(ref, type = "l", col = "gray", lwd = 2)
matlines(t(predict(gp, what = "time")),
         t(samp), col = 1:3, lty = 2)
## result: each individual profile is aligned to the ref

## How would samples 11:13 be warped using the coefficients from samples
## 14:16 (silly but just to make the point)?
samp.pred &lt;- predict(gp, what = "response", newdata = gaschrom[11:13,])
</code></pre>

<hr>
<h2 id='ptw'>Parametric Time Warping</h2><span id='topic+ptw'></span><span id='topic+print.ptw'></span><span id='topic+summary.ptw'></span><span id='topic+coef.ptw'></span><span id='topic+stptw'></span><span id='topic+print.stptw'></span><span id='topic+summary.stptw'></span>

<h3>Description</h3>

<p>The main functions of the <code>ptw</code> package, performing
parametric time warping of one or more samples. Features in the
samples are optimally aligned with features in the reference(s). One
may align a single sample to a single reference, several samples to a
single reference, and several samples to several references. In the
latter case, the number of references and samples should be equal. One
may require that all samples are warped with the same warping
function, or one may allow individual warpings for all samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptw(ref, samp, selected.traces,
    init.coef = c(0, 1, 0), try = FALSE,
    warp.type = c("individual", "global"),
    optim.crit = c("WCC", "RMS"),
    mode = c("forward", "backward"),
    smooth.param = ifelse(try, 0, 1e05),
    trwdth = 20, trwdth.res = trwdth,
    verbose = FALSE, ...)
stptw(ref, samp, init.coef = c(0, 1, 0),
      trwdth = 20, trwdth.res = trwdth, 
      nGlobal = ifelse(length(init.coef) &gt; 3, 5, 0),
      ...)
## S3 method for class 'ptw'
summary(object, ...)
## S3 method for class 'ptw'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptw_+3A_ref">ref</code></td>
<td>
<p>reference. Either a vector (containing one reference
signal) or a matrix (one reference per row). If
more than one reference is specified, the number of reference
signals must equal the number of sample signals.</p>
</td></tr> 
<tr><td><code id="ptw_+3A_samp">samp</code></td>
<td>
<p>sample. A vector (containing one sample signal) or a
matrix (one sample per row).</p>
</td></tr> 
<tr><td><code id="ptw_+3A_selected.traces">selected.traces</code></td>
<td>
<p>optional vector containing the row numbers to
use from <code>ref</code> (if more than one reference signal is specified)
and <code>samp</code>.</p>
</td></tr>   
<tr><td><code id="ptw_+3A_init.coef">init.coef</code></td>
<td>
<p>starting coefficients. The first number is the
zeroth-order coefficient (i.e., a constant shift); further numbers
indicate linear, quadratic, ... stretches. The default is to start
from the identity warping using a quadratic function
(<code>c(0, 1, 0)</code>)</p>
</td></tr>  
<tr><td><code id="ptw_+3A_try">try</code></td>
<td>
<p>if <code>try = TRUE</code>, <code>ptw</code> does not optimize the
warping but returns a <code>ptw</code> object containing the warping for
<code>init.coef</code>. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ptw_+3A_warp.type">warp.type</code></td>
<td>
<p>default is to treat samples and references as single
entities and align them individually and independently. Using the 
argument <code>warp.type = "global"</code> leads to one alignment 
function; the samples are warped simultaneously to the 
reference(s). Also see details</p>
</td></tr>
<tr><td><code id="ptw_+3A_optim.crit">optim.crit</code></td>
<td>
<p>either <code>"WCC"</code> or <code>"RMS"</code>. In both cases,
the optimal value of the alignment leads to a value of 0. For &quot;WCC&quot;,
this means that <code>1 - WCC</code> is optimized rather than <code>WCC</code>
(where the optimal value equals 1)</p>
</td></tr>
<tr><td><code id="ptw_+3A_mode">mode</code></td>
<td>
<p>either &quot;forward&quot; or &quot;backward&quot;: the latter was the
original implementation, basically for a point i in the original
signal predicting the point j in the signal that would be in
position i in the warped signal. The interpretation of the
coefficients is counterintuitive. Therefore the default is
&quot;forward&quot;, simply predicting the location (time) in the warped
signal of a particular point. Apart from possible numerical
optimisation issues, both warpings should give the same net result.</p>
</td></tr> 
<tr><td><code id="ptw_+3A_smooth.param">smooth.param</code></td>
<td>
<p>smoothing parameter for smoothing the reference
and sample when <code>optim.crit</code> equals <code>"RMS"</code>. If no
smoothing is required, set this to 0. The default is to use
smoothing in the optimization mode, and no smoothing otherwise</p>
</td></tr>
<tr><td><code id="ptw_+3A_trwdth">trwdth</code></td>
<td>
<p>the width of the triangle in the WCC criterion during
the optimization, given as a number of data points. Default: 20</p>
</td></tr>   
<tr><td><code id="ptw_+3A_trwdth.res">trwdth.res</code></td>
<td>
<p>the width of the triangle in the WCC calculation in
the calculation of the quality of the final result. Default: equal
to <code>trwdth</code></p>
</td></tr>
<tr><td><code id="ptw_+3A_verbose">verbose</code></td>
<td>
<p>logical, default is <code>FALSE</code>. Whether to give
output during the optimisation, which may be useful for large data
sets</p>
</td></tr>
<tr><td><code id="ptw_+3A_...">...</code></td>
<td>
<p>further arguments to optim</p>
</td></tr>
<tr><td><code id="ptw_+3A_nglobal">nGlobal</code></td>
<td>
<p>for stick optimisations with more than three
coefficients, a more powerful optimisation method is used
(<code>nloptr</code>: in such cases <code>nGlobal</code> indicates the number of
times this method is employed.</p>
</td></tr>
<tr><td><code id="ptw_+3A_x">x</code>, <code id="ptw_+3A_object">object</code></td>
<td>
<p>an object of class &quot;ptw&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ptw</code> and friends is meant for profile data,
where intensities have been recorded at regular time points; function
<code>stptw</code> is meant for lists of peaks, for instance obtained after
peak-picking the profile data. The latter option is less flexible
(Euclidean distance and backward warping have not been implemented,
and only global alignment is possible)
but is much faster, especially for larger data sets.
</p>
<p>In the optimization mode (<code>try = FALSE</code>), the function
optimizes the warping coefficients using the chosen criterion (either
&quot;WCC&quot; or &quot;RMS&quot;). For &quot;RMS&quot;, the data are smoothed before the
optimization, but the quality of the final warping is measured on the
unsmoothed data. For &quot;WCC&quot;, the warping is performed using 
<code>trwdth</code> as the triangle width, but the quality of the final 
solution is measured using <code>trwdth.res</code>.
</p>
<p>If <code>try = TRUE</code> is used as an argument, the function does not
start an optimization, but just calculates the warping for the given 
warp function (<code>init.coef</code>); if <code>smooth.param</code> is larger 
than zero for the RMS criterion, the RMS of the smoothed patterns is 
calculated. The WCC criterion uses <code>trwidth.res</code> as the triangle 
width in this case. 
</p>
<p>Five situations can be distinguished:
</p>

<ol>
<li><p> One sample and one reference: this obviously leads to one warping
function regardless of the setting of <code>warp.type</code>.
</p>
</li>
<li><p> Several samples, all warped to the same single reference, each with 
its own warping function: this is the default behaviour
(<code>warp.type = "individual"</code>)
</p>
</li>
<li><p> Several samples, warped to an equal number of references
(pair-wise), with their own warping functions: this is the default
behaviour (<code>warp.type = "individual"</code>)
</p>
</li>
<li><p> Several samples, warped to one reference, with one warping function 
(<code>warp.type = "global"</code>)
</p>
</li>
<li><p> Several samples, warped to an equal number of references
(pair-wise), with one warping function 
(<code>warp.type = "global"</code>)
</p>
</li></ol>



<h3>Value</h3>

<p>A list of class &quot;ptw&quot; containing:
</p>
<table>
<tr><td><code>reference</code></td>
<td>
<p>the reference(s) used as input</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>the sample(s) used as input</p>
</td></tr>
<tr><td><code>warped.sample</code></td>
<td>
<p>the warped sample</p>
</td></tr>
<tr><td><code>warp.coef</code></td>
<td>
<p>the warping coefficients</p>
</td></tr>
<tr><td><code>warp.fun</code></td>
<td>
<p>the warped indices (not for <code>stptw</code>)</p>
</td></tr>
<tr><td><code>crit.value</code></td>
<td>
<p>the value of the chosen criterion, either &quot;WCC&quot; or &quot;RMS&quot;</p>
</td></tr>
<tr><td><code>optim.crit</code></td>
<td>
<p>the chosen criterion, either &quot;WCC&quot; or &quot;RMS&quot;</p>
</td></tr>
<tr><td><code>warp.type</code></td>
<td>
<p>the chosen type of warping, either &quot;individual&quot; or
&quot;global&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Gerretzen, Ron Wehrens</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>
<p>Bloemberg, T.G., et al. (2010) &quot;Improved parametric time warping for Proteomics&quot;, Chemometrics and Intelligent Laboratory Systems, <b>104</b> (1), 65 &ndash; 74.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WCC">WCC</a></code>, <code><a href="#topic+RMS">RMS</a></code>, <code><a href="#topic+select.traces">select.traces</a></code>,
<code><a href="#topic+gaschrom">gaschrom</a></code>, <code><a href="#topic+lcms">lcms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[16,]
gaschrom.ptw &lt;- ptw(ref, samp)
summary(gaschrom.ptw)

## same with sticks (peak lists)
refst &lt;- gaschrom.st[1]
sampst &lt;- gaschrom.st[16]
gaschrom.st.ptw &lt;- stptw(refst, sampst, trwdth = 100)
summary(gaschrom.st.ptw)

## Not run: 
## comparison between backward and forward warping
gaschrom.ptw &lt;- ptw(ref, samp, init.coef = c(0, 1, 0, 0), mode = "backward")
summary(gaschrom.ptw)
gaschrom.ptw &lt;- ptw(ref, samp, init.coef = c(-10, 1, 0, 0), mode = "forward")
summary(gaschrom.ptw)

## #############################
## many samples warped on one reference
ref &lt;- gaschrom[1,]
samp &lt;- gaschrom[2:16,]
gaschrom.ptw &lt;-
  ptw(ref, samp, warp.type = "individual", verbose = TRUE,
      optim.crit = "WCC",  trwdth = 100, init.coef = c(0, 1, 0))
summary(gaschrom.ptw)

## "individual" warping not implemented for sticks; do separate warpings
## instead
refst &lt;- gaschrom.st[1]
sampst &lt;- gaschrom.st[2:16]
gaschrom.st.ptw.list &lt;-
  lapply(sampst,
         function(smpl)
           stptw(refst, list(smpl), trwdth = 100, init.coef = c(0, 1, 0)))
t(sapply(gaschrom.st.ptw.list,  "[[", "warp.coef"))
t(sapply(gaschrom.st.ptw.list,  "[[", "crit.value"))

## #############################
## several samples on several references individually
ref &lt;- gaschrom[1:8,]
samp &lt;- gaschrom[9:16,]
gaschrom.ptw &lt;-
  ptw(ref, samp, warp.type = "individual",
      optim.crit = "WCC", trwdth = 100, init.coef = c(0, 1, 0))
summary(gaschrom.ptw)

## stick version
gaschrom.st.ptw.list &lt;-
  mapply(function(x, y)
         stptw(list(x), list(y), trwdth = 100, init.coef = c(0, 1, 0)),
         gaschrom.st[1:8], gaschrom.st[9:16],
         SIMPLIFY = FALSE)
t(sapply(gaschrom.st.ptw.list, coef))

## #############################
## several samples on several references: one, global warping
gaschrom.ptw &lt;- ptw(ref, samp, warp.type = "global",
                    optim.crit = "WCC", init.coef = c(0, 1, 0))
summary(gaschrom.ptw)

refst &lt;- gaschrom.st[1:8]
sampst &lt;- gaschrom.st[9:16]
gaschrom.st.ptw &lt;- stptw(refst, sampst, trwdth=100, init.coef = c(0, 1, 0))
summary(gaschrom.st.ptw)

## #################################################################
## Example of a three-way data set#
## #################################################################

## first bring all samples to the same scale
data(lcms)
lcms.scaled &lt;- aperm(apply(lcms, c(1,3), 
                           function(x) x/mean(x) ), c(2,1,3))
## add zeros to the start and end of the chromatograms
lcms.s.z &lt;- aperm(apply(lcms.scaled, c(1,3), 
                        function(x) padzeros(x, 250) ), c(2,1,3))


## define a global 2nd degree warping
warp1 &lt;- ptw(lcms.s.z[,,2], lcms.s.z[,,3], warp.type="global")
warp.samp &lt;- warp1$warped.sample
warp.samp[is.na(warp.samp)] &lt;- 0
## refine by adding 5th degree warpings for individual chromatograms
warp2 &lt;- ptw(lcms.s.z[,,2], warp.samp, init.coef=c(0,1,0,0,0,0))
warp.samp2 &lt;- warp2$warped.sample
warp.samp2[is.na(warp.samp2)] &lt;- 0
## compare TICs
layout(matrix(1:2,2,1, byrow=TRUE))
plot(colSums(lcms.s.z[,,2]), type="l", ylab = "",
     main = "TIC: original data")
lines(colSums(lcms.s.z[,,3]), col=2, lty=2)
plot(colSums(lcms.s.z[,,2]), type="l", ylab = "",
     main = "TIC: warped data")
lines(colSums(warp.samp2), lty=2, col=2)

## ###########################
## stick version of this warping - note that the peaks have been picked
## from the scaled profiles. Note that here we need to take list
## elements: every sample is a list of mz channels.
warp1.st &lt;- stptw(lcms.pks[[2]], lcms.pks[[3]], trwdth = 100)
summary(warp1.st)

## End(Not run)
</code></pre>

<hr>
<h2 id='ptwgrid'>Calculate RMS or WCC values on a grid</h2><span id='topic+ptwgrid'></span>

<h3>Description</h3>

<p>Calculates values of the chosen optimization criterion (RMS
or WCC) on a grid defined by the coefficients of the warping
function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptwgrid(ref, samp, selected.traces,
	coef.mins, coef.maxs, coef.lengths, 
	optim.crit = c("WCC", "RMS"), 
	smooth.param = 1e05, 
	trwdth = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptwgrid_+3A_ref">ref</code></td>
<td>
<p>reference. Either a vector (containing one reference
signal) or a matrix (one reference per row). If
more than one reference is specified, the number of reference
signals must equal the number of sample signals</p>
</td></tr> 
<tr><td><code id="ptwgrid_+3A_samp">samp</code></td>
<td>
<p>sample. A vector (containing one sample signal) or a
matrix (one sample per row). If
more than one sample is specified, the number of sample
signals must equal the number of reference signals</p>
</td></tr> 
<tr><td><code id="ptwgrid_+3A_selected.traces">selected.traces</code></td>
<td>
<p>optional vector containing the row numbers to
use from <code>ref</code> (if more than one reference signal is specified)
and <code>samp</code></p>
</td></tr>
<tr><td><code id="ptwgrid_+3A_coef.mins">coef.mins</code></td>
<td>
<p>a vector containing the respective minimal values 
of coefficients for the grid. The first number is the minimal 
zeroth-order coefficient (i.e., a constant shift); further numbers 
indicate the minimal linear, quadratic, ... stretches </p>
</td></tr>  
<tr><td><code id="ptwgrid_+3A_coef.maxs">coef.maxs</code></td>
<td>
<p>a vector containing the maximal values of 
coefficients for the grid</p>
</td></tr>  
<tr><td><code id="ptwgrid_+3A_coef.lengths">coef.lengths</code></td>
<td>
<p>a vector of the same length as coef.maxs and 
coef.mins containing the number of steps in which to vary the 
respective coefficients between their minimum and maximum value</p>
</td></tr>
<tr><td><code id="ptwgrid_+3A_optim.crit">optim.crit</code></td>
<td>
<p>either <code>"WCC"</code> or <code>"RMS"</code>. In both cases,
the optimal value of the alignment leads to a value of 0. For &quot;WCC&quot;,
this means that <code>1 - WCC</code> is optimized rather than <code>WCC</code>
(where the optimal value equals 1)</p>
</td></tr>
<tr><td><code id="ptwgrid_+3A_smooth.param">smooth.param</code></td>
<td>
<p>smoothing parameter for smoothing the reference
and sample when <code>optim.crit</code> equals <code>"RMS"</code>. If no
smoothing is required, set this to 0</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="ptwgrid_+3A_trwdth">trwdth</code></td>
<td>
<p>the width of the triangle in the WCC criterion during
the optimization, given as a number of data points. Default: 20</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>In contrast to ptw, only the three situations leading to one 
warping function are distinguished here:
</p>

<ol>
<li><p> One sample and one reference;
</p>
</li>
<li><p> Several samples, warped to an equal number of references
(pair-wise);
</p>
</li>
<li><p> Several samples, warped to a single reference.
</p>
</li></ol>

<p>Which situation is applicable is determined from the dimensions of 
<code>ref</code> and <code>samp</code>.
</p>


<h3>Value</h3>

<p>An array of dimension <code>length(coef.mins)</code> and maximal indices 
per dimension specified by <code>coef.lengths</code></p>


<h3>Author(s)</h3>

<p>Tom Bloemberg, Jan Gerretzen, Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+ptw">ptw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  data(gaschrom)
  mygrid &lt;- ptwgrid(gaschrom[1,], gaschrom[16,],
                    coef.mins = c(-10, .9), coef.max = c(10, 1.1),
                    coef.lengths = c(21, 21))
  image(seq(-10, 10, length = 21),
        seq(.9, 1.1, length = 21),
        mygrid)

## End(Not run)
</code></pre>

<hr>
<h2 id='RMS'>Quality criteria for comparing patterns with shifts</h2><span id='topic+RMS'></span><span id='topic+WCC'></span>

<h3>Description</h3>

<p>Functions to compare patterns with shifted features. These
functions compare warped sample patterns to one or more reference
patterns. RMS returns the usual root-mean-squared difference measure;
WCC returns 1-wcc, where wcc indicates the weighted
cross-correlation. Perfect alignment leads to a value of 0 for both
criteria.
</p>
<p>Internal function, not meant to be called directly by the user. In
particular, note that the identity warping may lead to slightly
different estimates than a direct comparison of the reference and
sample signals - a warping even slightly outside the original range of
<code>1 : ncol(ref)</code> leads to NA values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMS(warp.coef, ref, samp, B, mode)
WCC(warp.coef, ref, samp, B, trwdth = 20, wghts, mode, ref.acors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMS_+3A_warp.coef">warp.coef</code></td>
<td>
<p>a vector of warping coefficients</p>
</td></tr>
<tr><td><code id="RMS_+3A_ref">ref</code></td>
<td>
<p>reference signal; a matrix with one or more rows. If the
number of rows is greater than one, it should equal the number of
rows in <code>samp</code></p>
</td></tr>
<tr><td><code id="RMS_+3A_samp">samp</code></td>
<td>
<p>sample signal; a matrix with one or more rows</p>
</td></tr>
<tr><td><code id="RMS_+3A_b">B</code></td>
<td>
<p>basis for warping function</p>
</td></tr>
<tr><td><code id="RMS_+3A_mode">mode</code></td>
<td>
<p>either &quot;forward&quot; (new implementation, also used for
warping peak lists) or &quot;backward&quot; (classical implementation).</p>
</td></tr>
<tr><td><code id="RMS_+3A_trwdth">trwdth</code></td>
<td>
<p>triangle width for the WCC function, expressed in the number
of data points</p>
</td></tr>
<tr><td><code id="RMS_+3A_wghts">wghts</code></td>
<td>
<p>optional weights vector, will be calculated from triangle
width if necessary. Sometimes it is more efficient to
pre-calculate it and give it as an argument</p>
</td></tr>
<tr><td><code id="RMS_+3A_ref.acors">ref.acors</code></td>
<td>
<p>autocorrelation of the reference. Since the
reference is often unchanged over multiple evaluations (e.g., during
an optimization), it is useful to pre-calculate this number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All patterns in <code>samp</code> are warped using the same warping
function, and then compared to <code>ref</code>, either pair-wise (when
<code>ref</code> and <code>samp</code> are of the same size), or with the one
pattern in <code>ref</code>.
</p>


<h3>Value</h3>

<p>One number - either the WCC or RMS value
</p>


<h3>Author(s)</h3>

<p>Jan Gerretzen, Tom Bloemberg, Ron Wehrens</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>
<p>de Gelder, R., Wehrens, R. and Hageman, J.A. (2001) &quot;A generalized expression for the similarity of spectra: Application to powder diffraction pattern classification&quot;,  Journal of Computational Chemistry, <b>22</b>, 273 &ndash; 289.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wcc">wcc</a></code></p>

<hr>
<h2 id='select.traces'>
Select traces from a data set according to several criteria
</h2><span id='topic+select.traces'></span>

<h3>Description</h3>

<p>For alignment purposes, it may be useful to select traces which show
clear features, and to throw away traces that contain mainly
noise. This function implements three ways to achieve this: CODA, a
criterion similar to varimax, and a criterion based on the highest
intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.traces(X, criterion = c("coda", "var", "int"),
              window = 5, smoothing = c("median", "mean"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.traces_+3A_x">X</code></td>
<td>
<p>a data matrix or an array. The first dimension signifies the
traces from which a selection is to be made. If X is a matrix, the
first usually corresponds to samples and the second dimension
is the spectral dimension. If X is an array, the data are
assumed to come from a hyphenated experiment, with the first
dimension the chromatographic dimension, the second the spectral
dimension and the third dimension corresponding to samples</p>
</td></tr>
<tr><td><code id="select.traces_+3A_criterion">criterion</code></td>
<td>
<p>either Windig's CODA algorithm, a criterion
calculating the variances of the length-scaled spectra, or a
criterion giving the height of the highest peak</p>
</td></tr>
<tr><td><code id="select.traces_+3A_window">window</code>, <code id="select.traces_+3A_smoothing">smoothing</code></td>
<td>
<p>arguments to the coda function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CODA criterion in essence selects traces with no baseline
and no spikes, but still containing significant intensities. The
variance criterion aims at something similar: it calculates the
variance (or standard deviation) of every trace after length scaling -
traces with a high value show few highly structured features, whereas
traces with a low value show noise or a significant baseline. The
intensity criterion simply returns the intensity of the highest
peak. The latter two criteria are simpler than CODA but implicitly
assume that the traces have been preprocessed (i.c., spikes have been
removed).
</p>


<h3>Value</h3>

<p>The function returns a list with components
</p>
<table>
<tr><td><code>crit.val</code></td>
<td>
<p>a vector containing the values of the criterion for
all traces. If X is an array, the function is recursively applied
to all samples (elements of the third dimension) - the results are
multiplied to obtain one criterion value per trace</p>
</td></tr>
<tr><td><code>trace.nrs</code></td>
<td>
<p>the order of the traces (from large to small)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+coda">coda</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lcms)
ntrace &lt;- dim(lcms)[1]
lcms.selection &lt;- select.traces(lcms[,,1:2], criterion = "var")
good &lt;- lcms.selection$trace.nrs[1]
bad &lt;- lcms.selection$trace.nrs[ntrace]

par(mfrow = c(1,2))
matplot(lcms[good,,1:2], type = 'l', lty = 1)
matplot(lcms[bad,,1:2], type = 'l', lty = 1)
</code></pre>

<hr>
<h2 id='warp.time'>Transform time according to a given warping function</h2><span id='topic+warp.time'></span>

<h3>Description</h3>

<p>Warp time points according to a warping function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>warp.time(tp, coef)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warp.time_+3A_tp">tp</code></td>
<td>
<p>A vector of time points, not necessarily equidistant.</p>
</td></tr>
<tr><td><code id="warp.time_+3A_coef">coef</code></td>
<td>
<p>The coefficients of the parametric time warping function:
the first coefficient is the constant shift, the second the linear
stretch etcetera.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of warped time points.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>Wehrens, R. et al. (2015)
&quot;Fast parametric warping of peak lists&quot;,
Bioinformatics. DOI: 10.1093/bioinformatics/btv299.</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- 1:100
## simple shift and compression
warp.time(time, c(-10, .99))
</code></pre>

<hr>
<h2 id='wcc'>
Weighted auto- and cross-correlation measures
</h2><span id='topic+wcc'></span><span id='topic+wac'></span><span id='topic+wcc.st'></span><span id='topic+wac.st'></span>

<h3>Description</h3>

<p>Functions to calculate weighted auto- and cross-correlation
measures. The wcc is a suitable measure for the similarity of two
patterns when features may be shifted. Identical patterns lead to a
wcc value of 1.
</p>
<p>Functions <code>wcc</code> and <code>wac</code> are meant for profile data
(intensities measured at equidistant time points), whereas
<code>wcc.st</code> and <code>wac.st</code> are meant for peak lists. In general,
wcc values calculated for profiles will be higher since they will also
include the large similarity in the empty spaces, i.e., parts of the
profiles where no peaks are present (and that will appear to be
perfectly aligned), whereas the peak-based version concentrates only
on the peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcc(pattern1, pattern2, trwdth, wghts = NULL, acors1 = NULL, acors2 = NULL)
wac(pattern1, trwdth, wghts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcc_+3A_pattern1">pattern1</code>, <code id="wcc_+3A_pattern2">pattern2</code></td>
<td>
<p>input patterns, typically spectra. Vectors</p>
</td></tr>
<tr><td><code id="wcc_+3A_trwdth">trwdth</code></td>
<td>
<p>triangle width, given in the number of data points for
the profile functions, and in the actual retention times for the
stick-based warpings.</p>
</td></tr>
<tr><td><code id="wcc_+3A_wghts">wghts</code></td>
<td>
<p>optional weights vector, will be calculated from triangle
width if necessary. Sometimes it is more efficient to
pre-calculate it and give it as an argument</p>
</td></tr>
<tr><td><code id="wcc_+3A_acors1">acors1</code>, <code id="wcc_+3A_acors2">acors2</code></td>
<td>
<p>autocorrelations of the input patterns. If not
provided, they are calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>wcc</code> and <code>wac</code> are defined such that the
triangle width stands for  
the number of points on one side of <strong>and including</strong> the current 
point. Thus, a <code>trwdth</code> of 0 signifies a non-existent triangle and 
results in an error; a <code>trwdth</code> equal to 1 only includes the current
point with weight 1 and no neighbouring points. For the stick-based
equivalents, the units of the time axis are used for the triangle width.
</p>


<h3>Value</h3>

<p>One number, the weighted autocorrelation or crosscorrelation</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>de Gelder, R., Wehrens, R. and Hageman, J.A. (2001)
&quot;A generalized expression for the similarity of spectra: Application to powder diffraction pattern classification&quot;,
Journal of Computational Chemistry, <b>22</b>, 273 &ndash; 289. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gaschrom)
wcc(gaschrom[1,], gaschrom[2,], 20)

wcc.st(gaschrom.st[[1]], gaschrom.st[[2]], 20)
</code></pre>

<hr>
<h2 id='whit1'>Weighted Whittaker smoothing with a first order finite difference penalty</h2><span id='topic+whit1'></span>

<h3>Description</h3>

<p>This function smoothes signals with a finite difference penalty of
order 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whit1(y, lambda, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whit1_+3A_y">y</code></td>
<td>
<p>signal to be smoothed: a vector</p>
</td></tr>
<tr><td><code id="whit1_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter: larger values lead to more smoothing</p>
</td></tr>
<tr><td><code id="whit1_+3A_w">w</code></td>
<td>
<p>weights: a vector of same length as y. Default weights are equal to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed signal: a vector</p>


<h3>Author(s)</h3>

<p>Paul Eilers, Jan Gerretzen</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>
<p>Eilers, P.H.C. (2003) &quot;A perfect smoother&quot;, Analytical Chemistry, <b>75</b>, 3631 &ndash; 3636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(gaschrom)
  plot(gaschrom[1,], type = "l", ylim = c(0, 100))
  lines(whit1(gaschrom[1,], lambda = 1e1), col = 2)
  lines(whit1(gaschrom[1,], lambda = 1e2), col = 3)
  lines(whit1(gaschrom[1,], lambda = 1e3), col = 4)
  </code></pre>

<hr>
<h2 id='whit2'>Weighted Whittaker smoothing with a second order finite difference penalty</h2><span id='topic+whit2'></span>

<h3>Description</h3>

<p>This function smoothes signals with a finite difference penalty of
order 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whit2(y, lambda, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whit2_+3A_y">y</code></td>
<td>
<p>signal to be smoothed: a vector</p>
</td></tr>
<tr><td><code id="whit2_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter: larger values lead to more smoothing</p>
</td></tr>
<tr><td><code id="whit2_+3A_w">w</code></td>
<td>
<p>weights: a vector of same length as y. Default weights are equal to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed signal: a vector</p>


<h3>Author(s)</h3>

<p>Paul Eilers, Jan Gerretzen</p>


<h3>References</h3>

<p>Eilers, P.H.C. (2004) &quot;Parametric Time Warping&quot;, Analytical Chemistry, <b>76</b> (2), 404 &ndash; 411.
</p>
<p>Eilers, P.H.C. (2003) &quot;A perfect smoother&quot;, Analytical Chemistry, <b>75</b>, 3631 &ndash; 3636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(gaschrom)
  plot(gaschrom[1,], type = "l", ylim = c(0, 100))
  lines(whit2(gaschrom[1,], lambda = 1e5), col = 2)
  lines(whit2(gaschrom[1,], lambda = 1e6), col = 3)
  lines(whit2(gaschrom[1,], lambda = 1e7), col = 4)
  </code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
