<!DOCTYPE html><html><head><title>Help for package mHMMbayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mHMMbayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mHMMbayes-package'><p>mHMMbayes: Multilevel Hidden Markov Models Using Bayesian Estimation</p></a></li>
<li><a href='#int_to_prob'><p>Transforming a set of Multinomial logit regression intercepts to probabilities</p></a></li>
<li><a href='#mHMM'><p>Multilevel hidden  Markov model using Bayesian estimation</p></a></li>
<li><a href='#nonverbal'><p>Nonverbal communication of patients and therapist</p></a></li>
<li><a href='#nonverbal_cov'><p>Predictors of nonverbal communication</p></a></li>
<li><a href='#obtain_emiss'><p>Obtain the emission distribution probabilities for a fitted multilevel HMM</p></a></li>
<li><a href='#obtain_gamma'><p>Obtain the transition probabilities gamma for a fitted multilevel HMM</p></a></li>
<li><a href='#pd_RW_emiss_cat'><p>Proposal distribution settings RW Metropolis sampler for mHMM categorical emission distribution(s)</p></a></li>
<li><a href='#pd_RW_emiss_count'><p>Proposal distribution settings RW Metropolis sampler for mHMM</p>
Poisson-lognormal emission distribution(s)</a></li>
<li><a href='#pd_RW_gamma'><p>Proposal distribution settings RW Metropolis sampler for mHMM transition probability matrix gamma</p></a></li>
<li><a href='#plot.mHMM'><p>Plotting the posterior densities for a fitted multilevel HMM</p></a></li>
<li><a href='#plot.mHMM_gamma'><p>Plotting the transition probabilities gamma for a fitted multilevel HMM</p></a></li>
<li><a href='#prior_emiss_cat'><p>Specifying informative hyper-prior on the categorical emission distribution(s)  of the multilevel hidden Markov model</p></a></li>
<li><a href='#prior_emiss_cont'><p>Specifying informative hyper-prior on the continuous emission distribution(s)  of the multilevel hidden Markov model</p></a></li>
<li><a href='#prior_emiss_count'><p>Specifying informative hyper-priors on the count emission</p>
distribution(s) of the multilevel hidden Markov model</a></li>
<li><a href='#prior_gamma'><p>Specifying informative hyper-prior on the transition probability matrix gamma of the multilevel hidden Markov model</p></a></li>
<li><a href='#prob_to_int'><p>Transforming a set of probabilities to Multinomial logit regression intercepts</p></a></li>
<li><a href='#sim_mHMM'><p>Simulate data using a multilevel hidden Markov model</p></a></li>
<li><a href='#var_to_logvar'><p>Transform the between-subject variance in the positive scale to the</p>
logvariance in the logarithmic scale</a></li>
<li><a href='#vit_mHMM'><p>Obtain hidden state sequence for each subject using the Viterbi</p>
algorithm</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multilevel Hidden Markov Models Using Bayesian Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MCMCpack, mvtnorm, stats, Rdpack, Rcpp</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmeke Aarts &lt;e.aarts@uu.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the multilevel (also known as mixed or random 
    effects) hidden Markov model using Bayesian estimation in R. The multilevel 
    hidden Markov model (HMM) is a generalization of the well-known hidden
    Markov model, for the latter see Rabiner (1989) &lt;<a href="https://doi.org/10.1109%2F5.18626">doi:10.1109/5.18626</a>&gt;. The 
    multilevel HMM is tailored to accommodate (intense) longitudinal data of 
    multiple individuals simultaneously, see e.g., de Haan-Rietdijk et al. 
    &lt;<a href="https://doi.org/10.1080%2F00273171.2017.1370364">doi:10.1080/00273171.2017.1370364</a>&gt;. Using a multilevel framework, we allow 
    for heterogeneity in the model parameters (transition probability matrix and 
    conditional distribution), while estimating one overall HMM. The model can 
    be fitted on multivariate data with either a categorical, normal, or Poisson 
    distribution, and include individual level covariates (allowing for e.g., 
    group comparisons on model parameters). Parameters are estimated using 
    Bayesian estimation utilizing the forward-backward recursion within a hybrid 
    Metropolis within Gibbs sampler. Missing data (NA) in the dependent 
    variables is accommodated assuming MAR. The package also includes various 
    visualization options, a function to simulate data, and a function to obtain 
    the most likely hidden state sequence for each individual using the Viterbi 
    algorithm. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=mHMMbayes">https://CRAN.R-project.org/package=mHMMbayes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emmekeaarts/mHMMbayes/issues">https://github.com/emmekeaarts/mHMMbayes/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, alluvial, grDevices, RColorBrewer, testthat
(&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-01 12:06:04 UTC; 0446564</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmeke Aarts [aut, cre],
  Sebastian Mildiner Moraga [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-01 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mHMMbayes-package'>mHMMbayes: Multilevel Hidden Markov Models Using Bayesian Estimation</h2><span id='topic+mHMMbayes'></span><span id='topic+mHMMbayes-package'></span>

<h3>Description</h3>

<p>An implementation of the multilevel (also known as mixed or random effects) hidden Markov model using Bayesian estimation in R. The multilevel hidden Markov model (HMM) is a generalization of the well-known hidden Markov model, for the latter see Rabiner (1989) <a href="https://doi.org/10.1109/5.18626">doi:10.1109/5.18626</a>. The multilevel HMM is tailored to accommodate (intense) longitudinal data of multiple individuals simultaneously, see e.g., de Haan-Rietdijk et al. <a href="https://doi.org/10.1080/00273171.2017.1370364">doi:10.1080/00273171.2017.1370364</a>. Using a multilevel framework, we allow for heterogeneity in the model parameters (transition probability matrix and conditional distribution), while estimating one overall HMM. The model can be fitted on multivariate data with either a categorical, normal, or Poisson distribution, and include individual level covariates (allowing for e.g., group comparisons on model parameters). Parameters are estimated using Bayesian estimation utilizing the forward-backward recursion within a hybrid Metropolis within Gibbs sampler. Missing data (NA) in the dependent variables is accommodated assuming MAR. The package also includes various visualization options, a function to simulate data, and a function to obtain the most likely hidden state sequence for each individual using the Viterbi algorithm.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emmeke Aarts <a href="mailto:e.aarts@uu.nl">e.aarts@uu.nl</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Mildiner Moraga
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://CRAN.R-project.org/package=mHMMbayes">https://CRAN.R-project.org/package=mHMMbayes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/emmekeaarts/mHMMbayes/issues">https://github.com/emmekeaarts/mHMMbayes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='int_to_prob'>Transforming a set of Multinomial logit regression intercepts to probabilities</h2><span id='topic+int_to_prob'></span>

<h3>Description</h3>

<p><code>int_to_prob</code> transforms a set of Multinomial logit regression
intercepts to the corresponding state transition or categorical emission
observation probabilities. Note that the first state or category is assumed
to be the reference category, hence no intercept is to specified for the
first state or category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_to_prob(int_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_to_prob_+3A_int_matrix">int_matrix</code></td>
<td>
<p>A matrix with (number of states OR categories - 1) columns
and number of rows to be determined by the user. For obtaining the set of
probabilities of the complete transition probability matrix gamma or
categorical emission distribution matrix, the number of rows equals the
number of states <code>m</code>. The first state / category is assumed to be the
reference category, no intercept is to be specified for this first
category.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed to ease the specification of informative hyper-prior values for the
mean intercepts of the transition probability matrix gamma and categorical
emission distribution(s) of the multilevel hidden Markov model through the
functions <code><a href="#topic+prior_gamma">prior_gamma</a></code> and <code><a href="#topic+prior_emiss_cat">prior_emiss_cat</a></code>. No
check is performed on correct specifications of the dimensions.
</p>


<h3>Value</h3>

<p><code>int_to_prob</code> returns a matrix containing probabilities with
each row summing to one, with the number of columns equal to the number of
states / categories and the number of rows equal to the number rows
specified in the input matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob_to_int">prob_to_int</a></code> for transforming a set of probabilities to
a set of Multinomial logit regression intercepts, <code><a href="#topic+prior_gamma">prior_gamma</a></code>
and <code><a href="#topic+prior_emiss_cat">prior_emiss_cat</a></code> for specifying informative hyper-priors
for the the multilevel hidden Markov model and <code><a href="#topic+mHMM">mHMM</a></code> to fit a
multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example for transition probability matrix gamma with 3 states
m &lt;- 3
gamma_int &lt;- matrix(c(-1, -1,
                       3,  0,
                       0,  2), ncol = m-1, nrow = m, byrow = TRUE)
gamma_prob &lt;- int_to_prob(gamma_int)
gamma_prob

</code></pre>

<hr>
<h2 id='mHMM'>Multilevel hidden  Markov model using Bayesian estimation</h2><span id='topic+mHMM'></span>

<h3>Description</h3>

<p><code>mHMM</code> fits a multilevel (also known as mixed or random effects) hidden
Markov model (HMM) to intense longitudinal data with categorical, continuous
(i.e., normally distributed), or count (i.e., Poisson distributed)
observations of multiple subjects using Bayesian estimation, and creates an
object of class <code>mHMM</code>. By using a multilevel framework, we allow for
heterogeneity in the model parameters between subjects, while estimating one
overall HMM. The function includes the possibility to add covariates at level
2 (i.e., at the subject level) and have varying observation lengths over
subjects. For a short description of the package see <a href="#topic+mHMMbayes">mHMMbayes</a>. See
<code>vignette("tutorial-mhmm")</code> for an introduction to multilevel hidden
Markov models and the package, and see <code>vignette("estimation-mhmm")</code> for
an overview of the used estimation algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mHMM(
  s_data,
  data_distr = "categorical",
  gen,
  xx = NULL,
  start_val,
  mcmc,
  return_path = FALSE,
  show_progress = TRUE,
  gamma_hyp_prior = NULL,
  emiss_hyp_prior = NULL,
  gamma_sampler = NULL,
  emiss_sampler = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mHMM_+3A_s_data">s_data</code></td>
<td>
<p>A matrix containing the observations to be modeled, where the
rows represent the observations over time. In <code>s_data</code>, the first
column indicates subject id number. Hence, the id number is repeated over
rows equal to the number of observations for that subject. The subsequent
columns contain the dependent variable(s). Note that in case of categorical
dependent  variable(s), input are integers (i.e., whole numbers) that range
from 1 to <code>q_emiss</code> (see below) and is numeric (i.e., not be a (set
of) factor variable(s)). The total number of rows are equal to the sum over
the number of observations of each subject, and the number of columns are
equal to the number of dependent variables (<code>n_dep</code>) + 1. The number
of observations can vary over subjects.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_data_distr">data_distr</code></td>
<td>
<p>String vector with length 1 describing the
observation type of the data. Currently supported are <code>'categorical'</code>
, <code>'continuous'</code>, and <code>'count'</code>. Note that for multivariate
data, all dependent variables are assumed to be of the same observation
type. The default equals to <code>data_distr = 'categorical'</code>.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="mHMM_+3A_xx">xx</code></td>
<td>
<p>An optional list of (level 2) covariates to predict the transition
matrix and/or the emission probabilities. Level 2 covariate(s) means that
there is one observation per subject of each covariate. The first element
in the list <code>xx</code> is used to predict the transition matrix. Subsequent
elements in the list are used to predict the emission distribution of (each
of) the dependent variable(s). Each element in the list is a matrix, with
the number of rows equal to the number of subjects. The first column of
each matrix represents the intercept, that is, a column only consisting of
ones. Subsequent columns correspond to covariates used to predict the
transition matrix / emission distribution. See <em>Details</em> for more
information on the use of covariates.
</p>
<p>If <code>xx</code> is omitted completely, <code>xx</code> defaults to <code>NULL</code>,
resembling no covariates. Specific elements in the list can also be left
empty (i.e., set to <code>NULL</code>) to signify that either the transition
probability matrix or a specific emission distribution is not predicted by
covariates.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_start_val">start_val</code></td>
<td>
<p>List containing the start values for the transition
probability matrix gamma and the emission distribution(s). The first
element of the list contains a <code>m</code> by <code>m</code> matrix with the start
values for gamma. The subsequent <code>n_dep</code> elements each contain a
matrix with the start values for the emission distribution(s). In case of
categorical observations: a <code>m</code> by <code>q_emiss[k]</code> matrix denoting
the probability of observing each categorical outcome (columns) within each
state (rows). In case of continuous observations: a <code>m</code> by 2 matrix
denoting the mean (first column) and standard deviation (second column) of
the Normal emission distribution within each state (rows). In case of
count observations: a <code>m</code> by 1 matrix denoting the mean (column) of
the Poisson emission distribution within each state on the natural
(i.e., real positive domain, not logarithmic) scale (rows). Note that
<code>start_val</code> should not contain nested lists (i.e., lists within
lists).</p>
</td></tr>
<tr><td><code id="mHMM_+3A_mcmc">mcmc</code></td>
<td>
<p>List of Markov chain Monte Carlo (MCMC) arguments, containing the
following elements:
</p>
<ul>
<li><p><code>J</code>: numeric vector with length 1 denoting the number
of iterations of the MCMC algorithm
</p>
</li>
<li><p><code>burn_in</code>: numeric vector with length 1 denoting the
burn-in period for the MCMC algorithm.</p>
</li></ul>
</td></tr>
<tr><td><code id="mHMM_+3A_return_path">return_path</code></td>
<td>
<p>A logical scalar. Should the sampled state sequence
obtained at each iteration and for each subject be returned by the function
(<code>sample_path = TRUE</code>) or not (<code>sample_path = FALSE</code>). Note that
the sampled state sequence is quite a large object, hence the default
setting is <code>sample_path = FALSE</code>. Can be used for local decoding
purposes.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_show_progress">show_progress</code></td>
<td>
<p>A logical scaler. Should the function show a text
progress bar in the <code>R</code> console to represent the progress of the
algorithm (<code>show_progress = TRUE</code>) or not (<code>show_progress =
FALSE</code>). Defaults to <code>show_progress = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_gamma_hyp_prior">gamma_hyp_prior</code></td>
<td>
<p>An optional object of class <code>mHMM_prior_gamma</code>
containing user specified parameter values for the hyper-prior distribution
on the transition probability matrix gamma, generated by the function
<code><a href="#topic+prior_gamma">prior_gamma</a></code>.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_emiss_hyp_prior">emiss_hyp_prior</code></td>
<td>
<p>An object of the class <code>mHMM_prior_emiss</code>
containing user specified parameter values for the hyper-prior distribution
on the categorical or Normal emission distribution(s), generated by the
function <code><a href="#topic+prior_emiss_cat">prior_emiss_cat</a></code>, <code><a href="#topic+prior_emiss_cont">prior_emiss_cont</a></code> or
<code><a href="#topic+prior_emiss_count">prior_emiss_count</a></code>.
Mandatory in case of continuous and count observations, optional in case of
categorical observations.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_gamma_sampler">gamma_sampler</code></td>
<td>
<p>An optional object of the class <code>mHMM_pdRW_gamma</code>
containing user specified settings for the proposal distribution of the
random walk (RW) Metropolis sampler on the subject level transition
probability matrix parameters, generated by the function
<code><a href="#topic+pd_RW_gamma">pd_RW_gamma</a></code>.</p>
</td></tr>
<tr><td><code id="mHMM_+3A_emiss_sampler">emiss_sampler</code></td>
<td>
<p>An optional object of the class <code>mHMM_pdRW_emiss</code>
containing user specified settings for the proposal distribution of the
random walk (RW) Metropolis sampler on the subject level emission
distribution(s) parameters, generated by either the function
<code><a href="#topic+pd_RW_emiss_cat">pd_RW_emiss_cat</a></code> or <code><a href="#topic+pd_RW_emiss_count">pd_RW_emiss_count</a></code>. Only
applicable in case of categorical and count observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariates specified in <code>xx</code> can either be dichotomous or continuous
variables. Dichotomous variables have to be coded as 0/1 variables.
Categorical or factor variables can as yet not be used as predictor
covariates. The user can however break up the categorical variable in
multiple dummy variables (i.e., dichotomous variables), which can be used
simultaneously in the analysis. Continuous predictors are automatically
centered. That is, the mean value of the covariate is subtracted from all
values of the covariate such that the new mean equals zero. This is done such
that the presented probabilities in the output (i.e., for the population
transition probability matrix and population emission probabilities)
correspond to the predicted probabilities at the average value of the
covariate(s).
</p>


<h3>Value</h3>

<p><code>mHMM</code> returns an object of class <code>mHMM</code>, which has
<code>print</code> and <code>summary</code> methods to see the results.
The object contains always the following components:
</p>

<dl>
<dt><code>PD_subj</code></dt><dd><p>A list containing one list per subject with the
elements <code>trans_prob</code>, <code>cat_emiss</code>, <code>cont_emiss</code>, or
<code>count_emiss</code> in case of categorical, continuous, and count
observations, respectively, and <code>log_likl</code>, providing the subject
parameter estimates over the iterations of the MCMC sampler.
<code>trans_prob</code> relates to the transition probabilities gamma,
<code>cat_emiss</code> to the categorical emission distribution (emission
probabilities), <code>cont_emiss</code> to the continuous emission distributions
(subsequently the the emission means and the (fixed
over subjects) emission standard deviation), <code>count_emiss</code> to the
count emission distribution means in the natural (real-positive) scale,
and <code>log_likl</code> to the log likelihood over the MCMC iterations.
Iterations are contained in the rows, the parameters in the columns.</p>
</dd>
<dt><code>gamma_prob_bar</code></dt><dd><p>A matrix containing the group level parameter
estimates of the transition probabilities over the iterations of the hybrid
Metropolis within Gibbs sampler. The iterations of the sampler are
contained in the rows, and the columns contain the group level parameter
estimates. If covariates were included in the analysis, the group level
probabilities represent the predicted probability given that the covariate
is at the average value for continuous covariates, or given that the
covariate equals zero for dichotomous covariates.</p>
</dd>
<dt><code>gamma_int_bar</code></dt><dd><p>A matrix containing the group level intercepts
of the Multinomial logistic regression modeling the transition
probabilities over the iterations of the hybrid Metropolis within Gibbs
sampler. The iterations of the sampler are contained in the rows, and the
columns contain the group level intercepts.</p>
</dd>
<dt><code>gamma_cov_bar</code></dt><dd><p>A matrix containing the group level regression
coefficients of the Multinomial logistic regression predicting the
transition probabilities over the iterations of the hybrid Metropolis within
Gibbs sampler. The iterations of the sampler are contained in the rows, and
the columns contain the group level regression coefficients.</p>
</dd>
<dt><code>gamma_V_int_bar</code></dt><dd><p>A matrix containing the variance
components for the subject-level intercepts (between subject variances)
of the multinomial logistic regression modeling the transition
probabilities over the iterations of the hybrid Metropolis within Gibbs
sampler. The iterations of the sampler are contained in the rows, and the
columns contain the variance components for the subject level intercepts.
Note that only the intercept variances (and not the co-variances) are
returned.</p>
</dd>
<dt><code>gamma_int_subj</code></dt><dd><p>A list containing one matrix per subject
denoting the subject level intercepts of the Multinomial logistic
regression modeling the transition probabilities over the iterations of the
hybrid Metropolis within Gibbs sampler. The iterations of the sampler are
contained in the rows, and the columns contain the subject level
intercepts.</p>
</dd>
<dt><code>gamma_naccept</code></dt><dd><p>A matrix containing the number of accepted
draws at the subject level RW Metropolis step for each set of parameters of
the transition probabilities. The subjects are contained in the rows, and
the columns contain the sets of parameters.</p>
</dd>
<dt><code>input</code></dt><dd><p>Overview of used input specifications: the distribution
type of the observations <code>data_distr</code>, the number of
states <code>m</code>, the number of used dependent variables <code>n_dep</code>, (in
case of categorical observations) the number of output categories for each
of the dependent variables <code>q_emiss</code>, the number of iterations
<code>J</code> and the specified burn in period <code>burn_in</code> of the hybrid
Metropolis within Gibbs sampler, the number of subjects <code>n_subj</code>, the
observation length for each subject <code>n_vary</code>, and the column names of
the dependent variables <code>dep_labels</code>.</p>
</dd>
<dt><code>sample_path</code></dt><dd><p>A list containing one matrix per subject with the
sampled hidden state sequence over the hybrid Metropolis within Gibbs
sampler. The time points of the dataset are contained in the rows, and the
sampled paths over the iterations are contained in the columns. Only
returned if <code>return_path = TRUE</code>. </p>
</dd>
</dl>

<p>Additionally, in case of categorical observations, the <code>mHMM</code> return object
contains:
</p>

<dl>
<dt><code>emiss_prob_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group level emission probabilities of each dependent
variable over the iterations of the hybrid Metropolis within Gibbs sampler.
The iterations of the sampler are contained in the rows of the matrix, and
the columns contain the group level emission probabilities. If covariates
were included in the analysis, the group level probabilities represent the
predicted probability given that the covariate is at the average value for
continuous covariates, or given that the covariate equals zero for
dichotomous covariates.</p>
</dd>
<dt><code>emiss_int_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group level intercepts of each dependent variable of
the Multinomial logistic regression modeling the probabilities of the
emission distribution over the iterations of the hybrid Metropolis within
Gibbs sampler. The iterations of the sampler are contained in the rows of
the matrix, and the columns contain the group level intercepts.</p>
</dd>
<dt><code>emiss_cov_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group level regression coefficients of the
Multinomial logistic regression predicting the emission probabilities within
each of the dependent variables over the iterations of the hybrid
Metropolis within Gibbs sampler. The iterations of the sampler are
contained in the rows  of the matrix, and the columns contain the group
level regression coefficients.</p>
</dd>
<dt><code>emiss_V_int_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the variance components for the subject-level intercepts
(between subject variances) of the multinomial logistic regression
modeling the categorical emission probabilities over the iterations of
the hybrid Metropolis within Gibbs sampler. The iterations of the sampler
are contained in the rows, and the columns contain the variance components
for the subject level intercepts. Note that only the intercept variances
(and not the co-variances) are returned.</p>
</dd>
<dt><code>emiss_int_subj</code></dt><dd><p>A list containing one list per subject denoting
the subject level intercepts of each dependent variable of the Multinomial
logistic regression modeling the probabilities of the emission distribution
over the iterations of the hybrid Metropolis within Gibbs sampler. Each
lower level list contains one matrix per dependent variable, in which
iterations of the sampler are contained in the rows, and the columns
contain the subject level intercepts.</p>
</dd>
<dt><code>emiss_naccept</code></dt><dd><p>A list containing one matrix per dependent
variable with the number of accepted draws at the subject level RW
Metropolis step for each set of parameters of the emission distribution.
The subjects are contained in the rows, and the columns of the matrix
contain the sets of parameters.</p>
</dd></dl>

<p>In case of continuous observations, the <code>mHMM</code> return object contains:
</p>

<dl>
<dt><code>emiss_mu_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group level means of the Normal emission
distribution of each dependent variable over the iterations of the Gibbs
sampler. The iterations of the sampler are contained in the rows of the
matrix, and the columns contain the group level emission means. If
covariates were included in the analysis, the group level means represent
the predicted mean given that the covariate is at the average value for
continuous covariates, or given that the covariate equals zero for
dichotomous covariates.</p>
</dd>
<dt><code>emiss_varmu_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the variance between the subject level means of the
Normal emission distributions. over the iterations of the Gibbs sampler. The
iterations of the sampler are contained in the rows of the matrix, and the
columns contain the group level variance in the mean.</p>
</dd>
<dt><code>emiss_sd_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the (fixed over subjects) standard deviation of the
Normal emission distributions over the iterations of the Gibbs sampler. The
iterations of the sampler are contained in the rows of the matrix, and the
columns contain the group level emission variances.</p>
</dd>
<dt><code>emiss_cov_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group level regression coefficients predicting the
emission means within each of the dependent variables over the iterations
of the Gibbs sampler. The iterations of the sampler are contained in the
rows  of the matrix, and the columns contain the group level regression
coefficients.</p>
</dd>
<dt><code>emiss_naccept</code></dt><dd><p>A list containing one matrix per dependent
variable with the number of accepted draws at the subject level RW
Metropolis step for each set of parameters of the emission distribution.
The subjects are contained in the rows, and the columns of the matrix
contain the sets of parameters.</p>
</dd>
<dt><code>input</code></dt><dd><p>Overview of used input specifications: the number of
states <code>m</code>, the number of used dependent variables <code>n_dep</code>, the
number of iterations <code>J</code> and the specified burn in period
<code>burn_in</code> of the hybrid Metropolis within Gibbs sampler, the number of
subjects <code>n_subj</code>, the observation length for each subject
<code>n_vary</code>, and the column names of the dependent variables
<code>dep_labels</code>.</p>
</dd></dl>

<p>In case of count observations, the <code>mHMM</code> return object contains:
</p>

<dl>
<dt><code>emiss_mu_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group-level means of the Poisson emission
distribution of each dependent variable over the MCMC iterations. The
iterations of the sampler are contained in the rows of the matrix, and the
columns contain the group-level Poisson emission means in the positive
scale. If covariates were included in the analysis, the group-level means
represent the predicted mean counts given that the covariate is at the
average value for continuous covariates, or given that the covariate
equals zero for dichotomous covariates.</p>
</dd>
<dt><code>emiss_varmu_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the variance between the subject-level means of the
Poisson emission distribution(s) over the iterations of the MCMC sampler.
The iterations of the sampler are contained in the rows of the matrix, and
the columns contain the group-level variance(s) between subject-specific
means (in the positive scale).</p>
</dd>
<dt><code>emiss_logmu_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group-level logmeans of the Poisson emission
distribution of each dependent variable over the MCMC iterations. The
iterations of the sampler are contained in the rows of the matrix, and the
columns contain the group-level Poisson emission logmeans in the
logarithmic scale. If covariates were included in the analysis, the
group-level means represent the predicted logmean counts given that the
covariate is at the average value for continuous covariates, or given that
the covariate equals zero for dichotomous covariates.</p>
</dd>
<dt><code>emiss_logvarmu_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the logvariance between the subject-level logmeans of
the Poisson emission distribution(s) over the iterations of the MCMC
sampler. The iterations of the sampler are contained in the rows of the
matrix, and the columns contain the group-level logvariance(s) between
subject-specific means (in the logarithmic scale).</p>
</dd>
<dt><code>emiss_cov_bar</code></dt><dd><p>A list containing one matrix per dependent
variable, denoting the group level regression coefficients predicting the
emission means in the logarithmic scale within each of the dependent
variables over the iterations of the MCMC sampler. The iterations of the
sampler are contained in the rows  of the matrix, and the columns contain
the group-level regression coefficients in the logarithmic scale.</p>
</dd>
<dt><code>input</code></dt><dd><p>Overview of used input specifications: the number of
states <code>m</code>, the number of used dependent variables <code>n_dep</code>, the
number of iterations <code>J</code> and the specified burn in period
<code>burn_in</code> of the hybrid Metropolis within Gibbs sampler, the number of
subjects <code>n_subj</code>, the observation length for each subject
<code>n_vary</code>, and the column names of the dependent variables
<code>dep_labels</code>.</p>
</dd></dl>



<h3>References</h3>

<p>Rabiner LR (1989).
&ldquo;A tutorial on hidden Markov models and selected applications in speech recognition.&rdquo;
<em>Proceedings of the IEEE</em>, <b>77</b>(2), 257&ndash;286.
</p>
<p>Scott SL (2002).
&ldquo;Bayesian methods for hidden Markov models: Recursive computing in the 21st century.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>97</b>(457), 337&ndash;351.
</p>
<p>Altman RM (2007).
&ldquo;Mixed hidden Markov models: an extension of the hidden Markov model to the longitudinal data setting.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>102</b>(477), 201&ndash;210.
</p>
<p>Rossi PE, Allenby GM, McCulloch R (2012).
<em>Bayesian statistics and marketing</em>.
John Wiley &amp; Sons.
</p>
<p>Zucchini W, MacDonald IL, Langrock R (2017).
<em>Hidden Markov models for time series: an introduction using R</em>.
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_mHMM">sim_mHMM</a></code> for simulating multilevel hidden Markov data,
<code><a href="#topic+vit_mHMM">vit_mHMM</a></code> for obtaining the most likely hidden state sequence
for each subject using the Viterbi algorithm, <code><a href="#topic+obtain_gamma">obtain_gamma</a></code>
and <code><a href="#topic+obtain_emiss">obtain_emiss</a></code> for obtaining the transition or emission
distribution probabilities of a fitted model at the group or subject level,
and <code><a href="#topic+plot.mHMM">plot.mHMM</a></code> for plotting the posterior densities of a
fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example on package (categorical) example data, see ?nonverbal

# specifying general model properties:
m &lt;- 2
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .2
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_2st &lt;- mHMM(s_data = nonverbal,
                gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 11, burn_in = 5))

out_2st
summary(out_2st)

# plot the posterior densities for the transition and emission probabilities
plot(out_2st, component = "gamma", col =c("darkslategray3", "goldenrod"))

# Run a model including a covariate (see ?nonverbal_cov) to predict the
# emission distribution for each of the 4 dependent variables:

n_subj &lt;- 10
xx_emiss &lt;- rep(list(matrix(c(rep(1, n_subj),nonverbal_cov$std_CDI_change),
                            ncol = 2, nrow = n_subj)), n_dep)
xx &lt;- c(list(matrix(1, ncol = 1, nrow = n_subj)), xx_emiss)
out_2st_c &lt;- mHMM(s_data = nonverbal, xx = xx,
                  gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  start_val = c(list(start_TM), start_EM),
                  mcmc = list(J = 11, burn_in = 5))


###### Example on categorical simulated data
# Simulate data for 10 subjects with each 100 observations:
n_t &lt;- 100
n &lt;- 10
m &lt;- 2
n_dep &lt;- 1
q_emiss &lt;- 3
gamma &lt;- matrix(c(0.8, 0.2,
                  0.3, 0.7), ncol = m, byrow = TRUE)
emiss_distr &lt;- list(matrix(c(0.5, 0.5, 0.0,
                        0.1, 0.1, 0.8), nrow = m, ncol = q_emiss, byrow = TRUE))
data1 &lt;- sim_mHMM(n_t = n_t, n = n, gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  gamma = gamma, emiss_distr = emiss_distr, var_gamma = .5, var_emiss = .5)

# Specify remaining required analysis input (for the example, we use simulation
# input as starting values):
n_dep &lt;- 1
q_emiss &lt;- 3

# Run the model on the simulated data:
out_2st_sim &lt;- mHMM(s_data = data1$obs,
                 gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                 start_val = c(list(gamma), emiss_distr),
                 mcmc = list(J = 11, burn_in = 5))

###### Example on continuous simulated data
 # simulating multivariate continuous data
n_t     &lt;- 100
n       &lt;- 10
m       &lt;- 3
n_dep   &lt;- 2

gamma   &lt;- matrix(c(0.8, 0.1, 0.1,
                    0.2, 0.7, 0.1,
                    0.2, 0.2, 0.6), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c( 50, 10,
                              100, 10,
                              150, 10), nrow = m, byrow = TRUE),
                    matrix(c(5, 2,
                             10, 5,
                             20, 3), nrow = m, byrow = TRUE))

data_cont &lt;- sim_mHMM(n_t = n_t, n = n, data_distr = 'continuous',
                      gen = list(m = m, n_dep = n_dep),
                      gamma = gamma, emiss_distr = emiss_distr,
                      var_gamma = .1, var_emiss = c(5^2, 0.2^2))

# Specify hyper-prior for the continuous emission distribution
manual_prior_emiss &lt;- prior_emiss_cont(
                        gen = list(m = m, n_dep = n_dep),
                        emiss_mu0 = list(matrix(c(30, 70, 170), nrow = 1),
                                         matrix(c(7, 8, 18), nrow = 1)),
                        emiss_K0 = list(1, 1),
                        emiss_V =  list(rep(5^2, m), rep(0.5^2, m)),
                        emiss_nu = list(1, 1),
                        emiss_a0 = list(rep(1.5, m), rep(1, m)),
                        emiss_b0 = list(rep(20, m), rep(4, m)))

# Run the model on the simulated data:
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_3st_cont_sim &lt;- mHMM(s_data = data_cont$obs,
                         data_distr = 'continuous',
                         gen = list(m = m, n_dep = n_dep),
                         start_val = c(list(gamma), emiss_distr),
                         emiss_hyp_prior = manual_prior_emiss,
                         mcmc = list(J = 11, burn_in = 5))




###### Example on multivariate count data
# Simulate data with one covariate for each count dependent variable

n_t     &lt;- 200     # Number of observations on the dependent variable
m       &lt;- 3        # Number of hidden states
n_dep   &lt;- 2        # Number of dependent variables
n_subj  &lt;- 30        # Number of subjects

gamma   &lt;- matrix(c(0.9, 0.05, 0.05,
                    0.2, 0.7, 0.1,
                    0.2,0.3, 0.5), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c(20,
                             10,
                             5), nrow = m, byrow = TRUE),
                    matrix(c(50,
                             3,
                             20), nrow = m, byrow = TRUE))

# Define between subject variance to use on the simulating function:
# here, the variance is varied over states within the dependent variable.
var_emiss &lt;- list(matrix(c(5.0, 3.0, 1.5), nrow = m),
                  matrix(c(5.0, 5.0, 5.0), nrow = m))

# Simulate count data:
data_count &lt;- sim_mHMM(n_t = n_t,
                       n = n_subj,
                       data_distr = "count",
                       gen = list(m = m, n_dep = n_dep),
                       gamma = gamma,
                       emiss_distr = emiss_distr,
                       var_gamma = 0.1,
                       var_emiss = var_emiss,
                       return_ind_par = TRUE)


# Transition probabilities
start_gamma &lt;- diag(0.8, m)
start_gamma[lower.tri(start_gamma) | upper.tri(start_gamma)] &lt;-
                                            (1 - diag(start_gamma)) / (m - 1)

# Emission distribution
start_emiss &lt;- list(matrix(c(20,10, 5), nrow = m, byrow = TRUE),
                    matrix(c(50, 3,20), nrow = m, byrow = TRUE))

# Specify hyper-prior for the count emission distribution
manual_prior_emiss &lt;- prior_emiss_count(
  gen = list(m = m, n_dep = n_dep),
  emiss_mu0 = list(matrix(c(20, 10, 5), byrow = TRUE, ncol = m),
                   matrix(c(50, 3, 20), byrow = TRUE, ncol = m)),
  emiss_K0  = rep(list(0.1),n_dep),
  emiss_nu  = rep(list(0.1),n_dep),
  emiss_V   = rep(list(rep(10, m)),n_dep)
)

# Run model
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_3st_count_sim &lt;- mHMM(s_data = data_count$obs,
                          data_distr = 'count',
                          gen = list(m = m, n_dep = n_dep),
                          start_val = c(list(start_gamma), start_emiss),
                          emiss_hyp_prior = manual_prior_emiss,
                          mcmc = list(J = 11, burn_in = 5),
                          show_progress = TRUE)

summary(out_3st_count_sim)


</code></pre>

<hr>
<h2 id='nonverbal'>Nonverbal communication of patients and therapist</h2><span id='topic+nonverbal'></span>

<h3>Description</h3>

<p>A dataset containing the nonverbal communication of 10 patient-therapist couples,
recorded for 15 minutes at a frequency of 1 observation per second (= 900 observations per couple).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonverbal
</code></pre>


<h3>Format</h3>

<p>A matrix with 10 * 900 rows and 5 variables:
</p>

<dl>
<dt>id</dt><dd><p>id variable of patient - therapist couple to distinguish which
observation belongs to which couple</p>
</dd>
<dt>p_verbalizing</dt><dd><p>verbalizing behavior of the patient, consisting of 1 =
not verbalizing, 2 = verbalizing, 3 = back channeling</p>
</dd>
<dt>p_looking</dt><dd><p>looking behavior of the patient, consisting of 1 = not
looking at therapist, 2 = looking at therapist</p>
</dd>
<dt>t_verbalizing</dt><dd><p>verbalizing behavior of the therapist, consisting of 1
= not verbalizing, 2 = verbalizing, 3 = back channeling</p>
</dd>
<dt>t_looking</dt><dd><p>looking behavior of the therapist, consisting of 1 = not
looking at patient, 2 = looking at patient</p>
</dd>
</dl>


<hr>
<h2 id='nonverbal_cov'>Predictors of nonverbal communication</h2><span id='topic+nonverbal_cov'></span>

<h3>Description</h3>

<p>A dataset containing predictors of nonverbal communication of 10 patient-therapist couples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonverbal_cov
</code></pre>


<h3>Format</h3>

<p>A matrix with 10 rows and 3 variables:
</p>

<dl>
<dt>diagnosis</dt><dd><p>Diagnosis of the patient, consisting of 0 = depression, 1 = anxiety</p>
</dd>
<dt>std_CDI_change</dt><dd><p>Change in measure for depression (CDI) before and after therapy, standardized scale</p>
</dd>
<dt>std_SCA_change</dt><dd><p>Change in measure for anxiety (SCARED) before and after therapy, standardized scale</p>
</dd>
</dl>


<hr>
<h2 id='obtain_emiss'>Obtain the emission distribution probabilities for a fitted multilevel HMM</h2><span id='topic+obtain_emiss'></span>

<h3>Description</h3>

<p><code>obtain_emiss</code> obtains the emission distribution for an object
containing a fitted multilevel hidden Markov model, either at the group
level, i.e., representing the average emission distribution over all
subjects, or at the subject level, returning the emission distribution for
each subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_emiss(object, level = "group", burn_in = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_emiss_+3A_object">object</code></td>
<td>
<p>An object of class <code>mHMM</code>, generated by the function
<code><a href="#topic+mHMM">mHMM</a></code>.</p>
</td></tr>
<tr><td><code id="obtain_emiss_+3A_level">level</code></td>
<td>
<p>String specifying if the returned transition probability matrix
gamma should be at the group level (<code>level = "group"</code>), i.e.,
representing the average transition probability matrix over all subjects,
or at the subject level (<code>level = "subject"</code>).</p>
</td></tr>
<tr><td><code id="obtain_emiss_+3A_burn_in">burn_in</code></td>
<td>
<p>An integer which specifies the number of iterations to discard
when obtaining the model parameter summary statistics. When left
unspecified (<code>burn_in = NULL</code>), the burn in period specified when
creating the <code>mHMM</code> object will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>obtain_emiss</code> creates an object of the class <code>mHMM_emiss</code>.
Depending on the specification at the input variable <code>level</code>, the
output is either a list of matrices with the emission distribution at the
group level (if <code>level = "group"</code>) for each dependent variable, or a
list of lists, where for each dependent variable a list is returned with
the number of elements equal to the number of subjects analyzed (if
<code>level = 'subject'</code>). In the latter scenario, each matrix in the lower
level list represents the subject specific emission distribution for a specific
dependent variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for fitting the
multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example on package data, see ?nonverbal

# specifying general model properties:
m &lt;- 2
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .2
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
out_2st &lt;- mHMM(s_data = nonverbal,
                gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 11, burn_in = 5))

out_2st
summary(out_2st)

# obtaining the emission probabilities at the group and subject level
obtain_emiss(out_2st, level = "group")
obtain_emiss(out_2st, level = "subject")



</code></pre>

<hr>
<h2 id='obtain_gamma'>Obtain the transition probabilities gamma for a fitted multilevel HMM</h2><span id='topic+obtain_gamma'></span>

<h3>Description</h3>

<p><code>obtain_gamma</code> obtains the transition probability matrix (TPM) for an
object containing a fitted multilevel hidden Markov model. The TPM can be
obtained either at the group level, i.e., representing the average transition
probability matrix over all subjects, or at the subject level, returning the
transition probability matrices for each subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_gamma(object, level = "group", burn_in = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_gamma_+3A_object">object</code></td>
<td>
<p>An object of class <code>mHMM</code>, generated by the function
<code><a href="#topic+mHMM">mHMM</a></code>.</p>
</td></tr>
<tr><td><code id="obtain_gamma_+3A_level">level</code></td>
<td>
<p>String specifying if the returned transition probability matrix
gamma should be at the group level (<code>level = "group"</code>), i.e.,
representing the average transition probability matrix over all subjects,
or at the subject level (<code>level = "subject"</code>).</p>
</td></tr>
<tr><td><code id="obtain_gamma_+3A_burn_in">burn_in</code></td>
<td>
<p>An integer which specifies the number of iterations to discard
when obtaining the model parameter summary statistics. When left
unspecified (<code>burn_in = NULL</code>), the burn in period specified when
creating the <code>mHMM</code> object will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>obtain_gamma</code> creates an object of the class <code>mHMM_gamma</code>.
This object can be directly plotted using the function
<code>plot.mHMM_gamma()</code>, or simply <code>plot()</code>. Depending on the
specification at the input variable <code>level</code>, the output is either a
matrix with the transition probabilities at the group level (if <code>level
  = "group"</code>), or a list of matrices (with the number of elements equal to
the number of subjects analyzed, if <code>level = 'subject'</code>), where each
matrix in the list represents a subject specific transition probability
matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for fitting the multilevel hidden Markov model,
and <code><a href="#topic+plot.mHMM_gamma">plot.mHMM_gamma</a></code> for plotting the obtained transition
probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example on package data

# specifying general model properties:
m &lt;- 2
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .2
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
out_2st &lt;- mHMM(s_data = nonverbal,
                gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 11, burn_in = 5))

out_2st
summary(out_2st)

# obtaining the transition probabilities at the group and subject level
obtain_gamma(out_2st, level = "group")
obtain_gamma(out_2st, level = "subject")



</code></pre>

<hr>
<h2 id='pd_RW_emiss_cat'>Proposal distribution settings RW Metropolis sampler for mHMM categorical emission distribution(s)</h2><span id='topic+pd_RW_emiss_cat'></span>

<h3>Description</h3>

<p><code>pd_RW_emiss_cat</code> provides a framework to manually specify the
settings of the proposal distribution of the random walk (RW) Metropolis
sampler of categorical emission distribution(s) of the multilevel hidden Markov
model, and creates on object of the class <code>mHMM_pdRW_emiss</code>. The RW
metropolis sampler is used for sampling the subject level parameter estimates
relating to the emission distributions of the dependent variables <code>k</code>,
that is, the Multinomial logistic regression intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_RW_emiss_cat(gen, emiss_int_mle0, emiss_scalar, emiss_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_RW_emiss_cat_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="pd_RW_emiss_cat_+3A_emiss_int_mle0">emiss_int_mle0</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding
to each of the dependent variables <code>k</code>, where each element is a matrix
with <code>m</code> rows and <code>q_emiss[k]</code> - 1 columns denoting the starting
values for the maximum likelihood (ML) estimates of the Multinomial logit
regression intercepts of the emission distribution(s). ML parameters to be
estimated are based on the pooled data (data over all subjects).</p>
</td></tr>
<tr><td><code id="pd_RW_emiss_cat_+3A_emiss_scalar">emiss_scalar</code></td>
<td>
<p>A list containing <code>n_dep</code> elements
corresponding to each of the dependent variables, where each element is a
numeric vector with length 1 denoting the scale factor <code>s</code>. That is,
the scale of the proposal distribution is composed of a covariance matrix
Sigma, which is then tuned by multiplying it by a scaling factor <code>s</code>^2.</p>
</td></tr>
<tr><td><code id="pd_RW_emiss_cat_+3A_emiss_w">emiss_w</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding
to each of the dependent variables, where each element is a numeric vector
with length 1 denoting the weight for the overall log likelihood (i.e., log
likelihood based on the pooled data over all subjects) in the fractional
likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no manual values for the settings of the proposal distribution of the
random walk (RW) Metropolis sampler are specified at all (that is, the
function <code>pd_RW_emiss_cat</code> is not used), all elements in
<code>emiss_int_mle0</code> set to 0, <code>emiss_scalar</code> set to 2.93 /
sqrt(<code>q_emiss[k]</code> - 1), and <code>emiss_w</code> set to 0.1. See the section
<em>Scaling the proposal distribution of the RW Metropolis sampler</em> in
<code>vignette("estimation-mhmm")</code> for details.
</p>
<p>Within the function <code>mHMM</code>, the acceptance rate of the RW metropolis
sampler relating to the emission distribution(s) can be tracked using the
output parameter <code>emiss_naccept</code>. An acceptance rate of about 23% is
considered optimal when many parameters are being updated at once (Gelman,
Carlin, Stern &amp; Rubin, 2014).
</p>


<h3>Value</h3>

<p><code>pd_RW_emiss_cat</code> returns an object of class
<code>mHMM_pdRW_emiss</code>, containing settings of the proposal distribution of
the random walk (RW) Metropolis sampler on the categorical emission
distribution(s) of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>, and
checked for correct input dimensions. The object contains the following
components:
</p>

<dl>
<dt><code>gen</code></dt><dd><p>A list containing the elements <code>m</code>, <code>n_dep</code>,
and <code>q_emiss</code>, used for checking equivalent general model properties
specified under <code>pd_RW_emiss_cat</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>emiss_int_mle0</code></dt><dd><p>A list containing <code>n_dep</code> elements, where
each element is a matrix  containing the starting values for the maximum
likelihood (ML) estimates of the Multinomial logit regression intercepts of
the emission distribution(s).</p>
</dd>
<dt><code>emiss_scalar</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting
the scale factor <code>s</code> of the proposal distribution.</p>
</dd>
<dt><code>emiss_w</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting
denoting the weight for the overall log likelihood in the fractional
likelihood.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman A, Carlin JB, Stern HS, Rubin DB (2014).
<em>Bayesian Data Analysis vol. 2</em>.
Taylor &amp; Francis.
</p>
<p>Rossi PE, Allenby GM, McCulloch R (2012).
<em>Bayesian statistics and marketing</em>.
John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using package example data, see ?nonverbal
# specifying general model properties:
m &lt;- 3
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying manual values for RW metropolis sampler on emission distributions
emiss_int_mle0 &lt;- list(matrix(c( 2,  0,
                                -2, -2,
                                 0, -1), byrow = TRUE, nrow = m, ncol = q_emiss[1] - 1),
                       matrix(c( 2,
                                 2,
                                 2), byrow = TRUE, nrow = m, ncol = q_emiss[2] - 1),
                       matrix(c(-2, -2,
                                 2,  0,
                                 0, -1), byrow = TRUE, nrow = m, ncol = q_emiss[3] - 1),
                       matrix(c( 2,
                                 2,
                                 2), byrow = TRUE, nrow = m, ncol = q_emiss[4] - 1))
emiss_scalar &lt;- list(c(2), c(3), c(2), c(3))
emiss_w &lt;- rep(list(c(0.2)), n_dep)
manual_emiss_sampler &lt;- pd_RW_emiss_cat(gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                                        emiss_int_mle0 = emiss_int_mle0,
                                        emiss_scalar = emiss_scalar,
                                        emiss_w = emiss_w)

# specifying starting values
start_TM &lt;- diag(.7, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .1
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.

out_3st_RWemiss &lt;- mHMM(s_data = nonverbal,
                         gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                         start_val = c(list(start_TM), start_EM),
                         emiss_sampler = manual_emiss_sampler,
                         mcmc = list(J = 11, burn_in = 5))

out_3st_RWemiss
summary(out_3st_RWemiss)

# checking acceptance rate (for illustrative purposes, in the example,
# J is too low for getting a fair indication)
div_J &lt;- function(x, J) x / J
J_it &lt;- 11 - 1 # accept/reject starts at iteration 2 of MCMC algorithm
RW_emiss_accept &lt;- sapply(out_3st_RWemiss$emiss_naccept, div_J, J_it, simplify = FALSE)

# average acceptance rate over all subjects per parameter
# rows represent each of the n_dep dependent variables, columns represent the m states
t(sapply(RW_emiss_accept, apply, MARGIN = 2, mean))




</code></pre>

<hr>
<h2 id='pd_RW_emiss_count'>Proposal distribution settings RW Metropolis sampler for mHMM
Poisson-lognormal emission distribution(s)</h2><span id='topic+pd_RW_emiss_count'></span>

<h3>Description</h3>

<p><code>pd_RW_emiss_count</code> provides a framework to manually specify the
settings of the proposal distribution of the random walk (RW) Metropolis
sampler of Poisson emission distribution(s) of the multilevel hidden Markov
model, and creates on object of the class <code>mHMM_pdRW_emiss</code>. The RW
metropolis sampler is used for sampling the subject level parameter estimates
relating to the emission distributions of the dependent variables <code>k</code>,
that is, the Poisson parameters lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_RW_emiss_count(gen, emiss_scalar, emiss_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_RW_emiss_count_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="pd_RW_emiss_count_+3A_emiss_scalar">emiss_scalar</code></td>
<td>
<p>A list containing <code>n_dep</code> elements
corresponding to each of the dependent variables, where each element is a
numeric vector with length 1 denoting the scale factor <code>s</code>. That is,
the scale of the proposal distribution is composed of a covariance matrix
Sigma, which is then tuned by multiplying it by a scaling factor <code>s</code>^2.</p>
</td></tr>
<tr><td><code id="pd_RW_emiss_count_+3A_emiss_w">emiss_w</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding
to each of the dependent variables, where each element is a numeric vector
with length 1 denoting the weight for the overall log likelihood (i.e., log
likelihood based on the pooled data over all subjects) in the fractional
likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no manual values for the settings of the proposal distribution of the
random walk (RW) Metropolis sampler are specified at all (that is, the
function <code>pd_RW_emiss_count</code> is not used), <code>emiss_scalar</code> set
to 2.38, and <code>emiss_w</code> set to 0.1. See the section <em>Scaling the
proposal distribution of the RW Metropolis sampler</em> in
<code>vignette("estimation-mhmm")</code> for details.
</p>
<p>Within the function <code>mHMM</code>, the acceptance rate of the RW metropolis
sampler relating to the emission distribution(s) can be tracked using the
output parameter <code>emiss_naccept</code>. An acceptance rate of about 45% is
considered optimal when a single parameter is being updated (Gelman,
Carlin, Stern &amp; Rubin, 2014).
</p>


<h3>Value</h3>

<p><code>pd_RW_emiss_count</code> returns an object of class
<code>mHMM_pdRW_emiss</code>, containing settings of the proposal distribution of
the random walk (RW) Metropolis sampler on the categorical emission
distribution(s) of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>, and
checked for correct input dimensions. The object contains the following
components:
</p>

<dl>
<dt><code>gen</code></dt><dd><p>A list containing the elements <code>m</code> and
<code>n_dep</code>, used for checking equivalent general model properties
specified under <code>pd_RW_emiss_count</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>emiss_scalar</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting
the scale factor <code>s</code> of the proposal distribution.</p>
</dd>
<dt><code>emiss_w</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting
denoting the weight for the overall log likelihood in the fractional
likelihood.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman A, Carlin JB, Stern HS, Rubin DB (2014).
<em>Bayesian Data Analysis vol. 2</em>.
Taylor &amp; Francis.
</p>
<p>Rossi PE, Allenby GM, McCulloch R (2012).
<em>Bayesian statistics and marketing</em>.
John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using simulated data
# specifying general model properties:
n_t     &lt;- 200     # Number of observations on the dependent variable
m       &lt;- 3        # Number of hidden states
n_dep   &lt;- 2        # Number of dependent variables
n_subj  &lt;- 30        # Number of subjects

gamma   &lt;- matrix(c(0.9, 0.05, 0.05,
                    0.2, 0.7, 0.1,
                    0.2,0.3, 0.5), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c(20,
                             10,
                             5), nrow = m, byrow = TRUE),
                    matrix(c(50,
                             3,
                             20), nrow = m, byrow = TRUE))

# Define between subject variance to use on the simulating function:
# here, the variance is varied over states within the dependent variable.
var_emiss &lt;- list(matrix(c(5.0, 3.0, 1.5), nrow = m),
                  matrix(c(5.0, 5.0, 5.0), nrow = m))

# Simulate count data:
data_count &lt;- sim_mHMM(n_t = n_t,
                       n = n_subj,
                       data_distr = "count",
                       gen = list(m = m, n_dep = n_dep),
                       gamma = gamma,
                       emiss_distr = emiss_distr,
                       var_gamma = 0.1,
                       var_emiss = var_emiss,
                       return_ind_par = TRUE)


# Transition probabilities
start_gamma &lt;- diag(0.8, m)
start_gamma[lower.tri(start_gamma) | upper.tri(start_gamma)] &lt;- (1 - diag(start_gamma)) / (m - 1)

# Emission distribution
start_emiss &lt;- list(matrix(c(20,10, 5), nrow = m, byrow = TRUE),
                    matrix(c(50, 3,20), nrow = m, byrow = TRUE))

# Specify hyper-prior for the count emission distribution
manual_prior_emiss &lt;- prior_emiss_count(
  gen = list(m = m, n_dep = n_dep),
  emiss_mu0 = list(matrix(c(20, 10, 5), byrow = TRUE, ncol = m),
                   matrix(c(50, 3, 20), byrow = TRUE, ncol = m)),
  emiss_K0  = rep(list(0.1),n_dep),
  emiss_nu  = rep(list(0.1),n_dep),
  emiss_V   = rep(list(rep(10, m)),n_dep)
)

# Specify the desired values for the sampler
manual_emiss_sampler &lt;- pd_RW_emiss_count(gen = list(m = m, n_dep = n_dep),
                                        emiss_scalar = rep(list(2.38),n_dep),
                                        emiss_w = rep(list(0.1), n_dep))

# Run model
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_3st_count_RWemiss &lt;- mHMM(s_data = data_count$obs,
                          data_distr = 'count',
                          gen = list(m = m, n_dep = n_dep),
                          start_val = c(list(start_gamma), start_emiss),
                          emiss_hyp_prior = manual_prior_emiss,
                          emiss_sampler = manual_emiss_sampler,
                          mcmc = list(J = 11, burn_in = 5),
                          show_progress = TRUE)

# Examine acceptance rates over dependent variable, individual, and states:
lapply(out_3st_count_RWemiss$emiss_naccept, function(e) e/out_3st_count_RWemiss$input$J)

# Finally, take the average acceptance rate by dependent variable and state:
lapply(out_3st_count_RWemiss$emiss_naccept, function(e) colMeans(e/out_3st_count_RWemiss$input$J))


</code></pre>

<hr>
<h2 id='pd_RW_gamma'>Proposal distribution settings RW Metropolis sampler for mHMM transition probability matrix gamma</h2><span id='topic+pd_RW_gamma'></span>

<h3>Description</h3>

<p><code>pd_RW_gamma</code> provides a framework to manually specify the settings of
the proposal distribution of the random walk (RW) Metropolis sampler of the
transition probability matrix gamma of the multilevel hidden Markov model,
and creates on object of the class <code>mHMM_pdRW_gamma</code>. The RW metropolis
sampler is used for sampling the subject level parameter estimates relating
to the transition probability matrix gamma, that is, the Multinomial logistic
regression intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_RW_gamma(m, gamma_int_mle0, gamma_scalar, gamma_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_RW_gamma_+3A_m">m</code></td>
<td>
<p>Numeric vector with length 1 denoting the number of hidden states.</p>
</td></tr>
<tr><td><code id="pd_RW_gamma_+3A_gamma_int_mle0">gamma_int_mle0</code></td>
<td>
<p>A matrix with <code>m</code> rows and <code>m</code> - 1 columns
denoting the starting values for the maximum likelihood (ML) estimates of
the Multinomial logit regression intercepts of the transition probability
matrix gamma. ML parameters to be estimated are based on the pooled data
(data over all subjects).</p>
</td></tr>
<tr><td><code id="pd_RW_gamma_+3A_gamma_scalar">gamma_scalar</code></td>
<td>
<p>A numeric vector with length 1 denoting the scale factor
<code>s</code>. That is, the scale of the proposal distribution is composed of a
covariance matrix Sigma, which is then tuned by multiplying it by a scaling
factor <code>s</code>^2.</p>
</td></tr>
<tr><td><code id="pd_RW_gamma_+3A_gamma_w">gamma_w</code></td>
<td>
<p>A numeric vector with length 1 denoting the weight for the
overall log likelihood (i.e., log likelihood based on the pooled data over
all subjects) in the fractional likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no manual values for the settings of the proposal distribution of the
random walk (RW) Metropolis sampler are specified at all (that is, the
function <code>pd_RW_gamma</code> is not used), all elements in
<code>gamma_int_mle0</code> set to 0, <code>gamma_scalar</code> set to 2.93 /
sqrt(<code>m</code> - 1), and <code>gamma_w</code> set to 0.1. See the section
<em>Scaling the proposal distribution of the RW Metropolis sampler</em> in
<code>vignette("estimation-mhmm")</code> for details.
</p>
<p>Within the function <code>mHMM</code>, the acceptance rate of the RW metropolis
sampler relating to the transition probability matrix gamma can be tracked
using the output parameter <code>gamma_naccept</code>. An acceptance rate of about
23% is considered optimal when many parameters are being updated at once
(Gelman, Carlin, Stern &amp; Rubin, 2014).
</p>


<h3>Value</h3>

<p><code>pd_RW_gamma</code> returns an object of class
<code>mHMM_pdRW_gamma</code>, containing settings of the proposal distribution of
the random walk (RW) Metropolis sampler on the transition probability
matrix gamma of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>, and
checked for correct input dimensions. The object contains the following
components:
</p>

<dl>
<dt><code>m</code></dt><dd><p>Numeric vector denoting the number of hidden states, used
for checking equivalent general model properties specified under
<code>pd_RW_gamma</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>gamma_int_mle0</code></dt><dd><p>A matrix containing the starting values for
the maximum likelihood (ML) estimates of the Multinomial logit regression
intercepts of the transition probability matrix gamma.</p>
</dd>
<dt><code>gamma_scalar</code></dt><dd><p>A numeric vector with length 1 denoting
the scale factor <code>s</code> of the proposal distribution.</p>
</dd>
<dt><code>gamma_w</code></dt><dd><p>A numeric vector with length 1  denoting
denoting the weight for the overall log likelihood in the fractional
likelihood.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gelman A, Carlin JB, Stern HS, Rubin DB (2014).
<em>Bayesian Data Analysis vol. 2</em>.
Taylor &amp; Francis.
</p>
<p>Rossi PE, Allenby GM, McCulloch R (2012).
<em>Bayesian statistics and marketing</em>.
John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using package example data, see ?nonverbal
# specifying general model properties:
m &lt;- 3

# specifying manual values for RW metropolis sampler on gamma
gamma_int_mle0 &lt;- matrix(c( -2, -2,
                             2,  0,
                             0,  3), byrow = TRUE, nrow = m, ncol = m - 1)
gamma_scalar &lt;- c(2)
gamma_w &lt;- c(0.2)
manual_gamma_sampler &lt;- pd_RW_gamma(m = m, gamma_int_mle0 = gamma_int_mle0,
                                    gamma_scalar = gamma_scalar,
                                    gamma_w = gamma_w)

# specifying starting values
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

start_TM &lt;- diag(.7, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .1
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.

out_3st_RWgamma &lt;- mHMM(s_data = nonverbal,
                         gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                         start_val = c(list(start_TM), start_EM),
                         gamma_sampler = manual_gamma_sampler,
                         mcmc = list(J = 11, burn_in = 5))
out_3st_RWgamma
summary(out_3st_RWgamma)

# checking acceptance rate (for illustrative purposes, in the example,
# J is too low for getting a fair indication)
J_it &lt;- 11 - 1 # accept/reject starts at iteration 2 of MCMC algorithm
out_3st_RWgamma$gamma_naccept / J_it
# average acceptance rate over all subjects per parameter
apply(out_3st_RWgamma$gamma_naccept / J_it, 2, mean)




</code></pre>

<hr>
<h2 id='plot.mHMM'>Plotting the posterior densities for a fitted multilevel HMM</h2><span id='topic+plot.mHMM'></span>

<h3>Description</h3>

<p><code>plot.mHMM</code> plots the posterior densities for a fitted multilevel hidden
Markov model for the group and subject level parameters simultaneously. The
plotted posterior densities are either for the transition probability matrix
gamma, or for the emission distribution probabilities (categorical data) or
means and standard deviation (continuous data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mHMM'
plot(
  x,
  component = "gamma",
  dep = 1,
  col,
  dep_lab,
  cat_lab,
  lwd1 = 2,
  lwd2 = 1,
  lty1 = 1,
  lty2 = 3,
  legend_cex,
  burn_in,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mHMM_+3A_x">x</code></td>
<td>
<p>Object of class <code>mHMM</code>, generated by the function
<code><a href="#topic+mHMM">mHMM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_component">component</code></td>
<td>
<p>String specifying if the displayed posterior densities
should be for the transition probability matrix gamma (<code>component =
"gamma"</code>), or for the emission distribution probabilities (<code>component
= "emiss"</code>). In case of the latter and the model is based on multiple
dependent variables, the user has to indicate for which dependent variable
the posterior densities have to be plotted, see <code>dep</code>.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_dep">dep</code></td>
<td>
<p>Integer specifying for which dependent variable the posterior
densities should be plotted. Only required if one wishes to plot the
emission distribution probabilities and the model is based on multiple
dependent variables. Defaults to <code>dep = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_col">col</code></td>
<td>
<p>Vector of colors for the posterior density lines. If one is
plotting the posterior densities for gamma, or the posterior densities of
Normally distributed emission probabilities, the vector has length <code>m</code>
(i.e., number of hidden states). If one is plotting the posterior densities
for categorical emission probabilities, the vector has length
<code>q_emiss[k]</code> (i.e., the number of outcome categories for the dependent
variable <code>k</code>).</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_dep_lab">dep_lab</code></td>
<td>
<p>Optional string when plotting the posterior
densities of the emission probabilities with length 1, denoting the label
for the dependent variable plotted. Automatically obtained from the input
object <code>x</code> when not specified.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_cat_lab">cat_lab</code></td>
<td>
<p>Optional vector of strings when plotting the posterior
densities of categorical emission probabilities, denoting the labels of the
categorical outcome values. Automatically generated when not provided.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_lwd1">lwd1</code></td>
<td>
<p>Positive number indicating the line width of the posterior
density at the group level.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_lwd2">lwd2</code></td>
<td>
<p>Positive number indicating the line width of the posterior
density at the subject level.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_lty1">lty1</code></td>
<td>
<p>Positive number indicating the line type of the posterior
density at the group level.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_lty2">lty2</code></td>
<td>
<p>Positive number indicating the line type of the posterior
density at the subject level.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_legend_cex">legend_cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text
and symbols in the legend should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_burn_in">burn_in</code></td>
<td>
<p>An integer which specifies the number of iterations to discard
when obtaining the model parameter summary statistics. When left
unspecified, the burn in period specified at creating the <code>mHMM</code>
object with the function <code><a href="#topic+mHMM">mHMM</a></code> will be used.</p>
</td></tr>
<tr><td><code id="plot.mHMM_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the standard deviation of the (variable and) state specific Normal
emission distribution in case of continuous data is fixed over subjects.
Hence, for the standard deviation, only the posterior distribution at the
group level is plotted.
</p>


<h3>Value</h3>

<p><code>plot.mHMM</code> returns a plot of the posterior densities. Depending
on whether (<code>component = "gamma"</code>) or (<code>component = "emiss"</code>),
the plotted posterior densities are either for the transition probability
matrix gamma or for the emission distribution probabilities, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for fitting the multilevel hidden Markov
model, creating the object <code>mHMM</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example on package example data, see ?nonverbal
# First run the function mHMM on example data

# specifying general model properties:
m &lt;- 2
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .2
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05, 0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9, 0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05, 0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9, 0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
out_2st &lt;- mHMM(s_data = nonverbal, gen = list(m = m, n_dep = n_dep,
                q_emiss = q_emiss), start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 11, burn_in = 5))

## plot the posterior densities for gamma
plot(out_2st, component = "gamma")


</code></pre>

<hr>
<h2 id='plot.mHMM_gamma'>Plotting the transition probabilities gamma for a fitted multilevel HMM</h2><span id='topic+plot.mHMM_gamma'></span>

<h3>Description</h3>

<p><code>plot.mHMM_gamma</code> plots the transition probability matrix for a fitted
multilevel hidden Markov model, by means of an alluvial plot (also known as
Sankey diagram or riverplot) using the R package <code>alluvial</code>. The plotted
transition probability matrix either represents the probabilities at the
group level, i.e., representing the average transition probability matrix
over all subjects, or at the subject level. In case of the latter, the user
has to specify for which subject the transition probability matrix should be
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mHMM_gamma'
plot(x, subj_nr = NULL, cex = 0.8, col, hide, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mHMM_gamma_+3A_x">x</code></td>
<td>
<p>An object of class <code>mHMM_gamma</code>, generated by the function
<code><a href="#topic+obtain_gamma">obtain_gamma</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mHMM_gamma_+3A_subj_nr">subj_nr</code></td>
<td>
<p>An integer specifying for which specific subject the
transition probability matrix should be plotted. Only required if the input
object represents the subject specific transition probability matrices.</p>
</td></tr>
<tr><td><code id="plot.mHMM_gamma_+3A_cex">cex</code></td>
<td>
<p>An integer specifying scaling of fonts of category labels. When
not specified, defaults to <code>cex = 0.8</code>.</p>
</td></tr>
<tr><td><code id="plot.mHMM_gamma_+3A_col">col</code></td>
<td>
<p>An optional vector with length <code>m</code> * <code>m</code> (i.e., where
<code>m</code> denotes the number of hidden states) specifying the used colors in
the alluvial plot.</p>
</td></tr>
<tr><td><code id="plot.mHMM_gamma_+3A_hide">hide</code></td>
<td>
<p>An optional logical vector with  length <code>m</code> * <code>m</code>
(i.e., where <code>m</code> denotes the number of hidden states) specifying
whether particular stripes should be plotted. When not specified, omits
the lines representing a value of exactly zero.</p>
</td></tr>
<tr><td><code id="plot.mHMM_gamma_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to alluvial (see
<code><a href="alluvial.html#topic+alluvial">alluvial</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot.mHMM_gamma</code> returns a plot of the transition probability
matrix. Depending on whether the input object represents the transition
probabilities at the group level or the subject specific transition
probability matrices, the returned plot represents either the group
transition probability matrix, or the transition probability matrix for a
given subject, specified by <code>subject_nr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for fitting the multilevel hidden Markov
model, creating the object <code>mHMM</code>, and <code><a href="#topic+obtain_gamma">obtain_gamma</a></code> to
obtain the transition probabilities gamma for a fitted multilevel HMM,
creating the object <code>mHMM_gamma</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#' ###### Example on package data, see ?nonverbal
# specifying general model properties:
m &lt;- 2
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .2
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
out_2st &lt;- mHMM(s_data = nonverbal,
                gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 11, burn_in = 5))

out_2st
summary(out_2st)

# obtaining the transition probabilities at the group and subject level
est_gamma_group &lt;- obtain_gamma(out_2st, level = "group")

# plot the obtained transition probabilities
plot(est_gamma_group, col = rep(c("green", "blue"), each = m))




</code></pre>

<hr>
<h2 id='prior_emiss_cat'>Specifying informative hyper-prior on the categorical emission distribution(s)  of the multilevel hidden Markov model</h2><span id='topic+prior_emiss_cat'></span>

<h3>Description</h3>

<p><code>prior_emiss_cat</code> provides a framework to manually specify an
informative hyper-prior on the categorical emission distribution(s).
<code>prior_emiss_cat</code> creates an object of class <code>mHMM_prior_emiss</code>
used by the function <code>mHMM</code>, and additionally attaches the class
<code>cat</code> to signal use for categorical observations. Note that the
hyper-prior distribution on the categorical emission probabilities are on the
intercepts (and, if subject level covariates are used, regression
coefficients) of the Multinomial logit model used to accommodate the
multilevel framework of the data, instead of on the probabilities directly.
The set of hyper-prior distributions consists of a multivariate Normal
hyper-prior distribution on the vector of means (i.e., intercepts and
regression coefficients), and an Inverse Wishart hyper-prior distribution on
the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_emiss_cat(
  gen,
  emiss_mu0,
  emiss_K0 = NULL,
  emiss_V = NULL,
  emiss_nu = NULL,
  n_xx_emiss = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_emiss_cat_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="prior_emiss_cat_+3A_emiss_mu0">emiss_mu0</code></td>
<td>
<p>A list of lists: <code>emiss_mu0</code> contains <code>n_dep</code>
lists, i.e., one list for each dependent variable <code>k</code>. Each list
<code>k</code> contains <code>m</code> matrices; one matrix for each set of emission
probabilities within a state. The matrices contain the hypothesized
hyper-prior mean values of the intercepts of the Multinomial logit model on
the categorical emission probabilities. Hence, each matrix consists of one
row (when not including covariates in the model) and <code>q_emiss[k]</code> - 1
columns. If covariates are used, the number of rows in each matrix in the
list is equal to 1 + n_xx (i.e., the first row corresponds to the
hyper-prior mean values of the intercepts, the subsequent rows correspond
to the hyper-prior mean values of the regression coefficients connected to
each of the covariates).</p>
</td></tr>
<tr><td><code id="prior_emiss_cat_+3A_emiss_k0">emiss_K0</code></td>
<td>
<p>Optional list containing <code>n_dep</code> elements corresponding
to each dependent variable <code>k</code>. Each element <code>k</code> is a
numeric vector with length 1 (when no covariates are used) denoting the
number of hypothetical prior subjects on which the set of hyper-prior mean
intercepts specified in <code>emiss_mu0</code> are based. When covariates are
used: each element is a numeric vector with length 1 + n_xx denoting the
number of hypothetical prior subjects on which the set of intercepts (first
value) and set of regression coefficients (subsequent values) are based.</p>
</td></tr>
<tr><td><code id="prior_emiss_cat_+3A_emiss_v">emiss_V</code></td>
<td>
<p>Optional list containing <code>n_dep</code> elements corresponding
to each dependent variable <code>k</code>, where each element <code>k</code> is a
matrix of <code>q_emiss[k]</code> - 1 by <code>q_emiss[k]</code> - 1 containing the
variance-covariance of the hyper-prior Inverse Wishart distribution on the
covariance of the Multinomial logit intercepts.</p>
</td></tr>
<tr><td><code id="prior_emiss_cat_+3A_emiss_nu">emiss_nu</code></td>
<td>
<p>Optional list containing <code>n_dep</code> elements corresponding
to each dependent variable <code>k</code>. Each element <code>k</code> is
a numeric vector with length 1 denoting the degrees of freedom of the
hyper-prior Inverse Wishart distribution on the covariance of the
Multinomial logit intercepts.</p>
</td></tr>
<tr><td><code id="prior_emiss_cat_+3A_n_xx_emiss">n_xx_emiss</code></td>
<td>
<p>Optional numeric vector with length <code>n_dep</code> denoting
the number of (level 2) covariates used to predict the emission
distribution of each of the dependent variables <code>k</code>. When omitted, the
model assumes no covariates are used to predict the emission
distribution(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the mHMM proceeds within a Bayesian context, hence a
hyper-prior distribution has to be defined for the group level parameters.
Default, non-informative priors are used unless specified otherwise by the
user. For each dependent variable, each row of the categorical emission
probability matrix (i.e., the probability to observe each category (columns)
within each of the states (rows)) has its own set of Multinomial logit
intercepts, which are assumed to follow a multivariate normal distribution.
Hence, the hyper-prior distributions for the intercepts consists of a
multivariate Normal hyper-prior distribution on the vector of means, and an
Inverse Wishart hyper-prior distribution on the covariance matrix. Note that
only the general model properties (number of states <code>m</code>, number of
dependent variables <code>n_dep</code>, and number of observed categories for each
dependent variable <code>q_emiss</code>) and values of the hypothesized hyper-prior
mean values of the Multinomial logit intercepts have to be specified by the
user, default values are available for all other hyper-prior distribution
parameters.
</p>
<p>Given that the hyper-priors are specified on the intercepts of the Multinomial
logit model intercepts instead of on the categorical emission
probabilities directly, specifying a hyper-prior can seem rather
daunting. However, see the function <code><a href="#topic+prob_to_int">prob_to_int</a></code> and
<code><a href="#topic+int_to_prob">int_to_prob</a></code> for translating probabilities to a set of
Multinomial logit intercepts and vice versa.
</p>
<p>Note that <code>emiss_K0</code>, <code>emiss_nu</code> and <code>emiss_V</code> are assumed
equal over the states.  When the hyper-prior values for <code>emiss_K0</code>,
<code>emiss_nu</code> and <code>emiss_V</code> are not manually specified, the default
values are as follows. <code>emiss_K0</code> set to 1, <code>emiss_nu</code> set to 3 +
<code>q_emiss[k]</code> - 1, and the diagonal of <code>gamma_V</code> (i.e., the
variance) set to 3 + <code>q_emiss[k]</code> - 1 and the off-diagonal elements
(i.e., the covariance) set to 0. In addition, when no manual values for the
hyper-prior on the categorical emission distribution are specified at all
(that is, the function <code>prior_emiss_cat</code> is not used), all elements of
the matrices contained in <code>emiss_mu0</code> are set to 0 in the function
<code>mHMM</code>.
</p>
<p>Note that in case covariates are specified, the hyper-prior parameter values
of the inverse Wishart distribution on the covariance matrix remain
unchanged, as the estimates of the regression coefficients for the covariates
are fixed over subjects.
</p>


<h3>Value</h3>

<p><code>prior_emiss_cat</code> returns an object of class <code>mHMM_prior_emiss</code>,
containing informative hyper-prior values for the categorical emission
distribution(s) of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>,
and thoroughly checked for correct input dimensions.
The object contains the following components:
</p>

<dl>
<dt><code>gen</code></dt><dd><p>A list containing the elements <code>m</code>, <code>n_dep</code>,
and <code>q_emiss</code>, used for checking equivalent general model properties
specified under <code>prior_emiss_cat</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>emiss_mu0</code></dt><dd><p>A list of lists containing the hypothesized
hyper-prior mean values of the intercepts of the Multinomial logit model on
the categorical emission probabilities.</p>
</dd>
<dt><code>emiss_K0</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting the
number of hypothetical prior subjects on which the set of hyper-prior mean
intercepts specified in <code>emiss_mu0</code> are based.</p>
</dd>
<dt><code>emiss_nu</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting the
degrees of freedom of the hyper-prior Inverse Wishart distribution on
the covariance of the Multinomial logit intercepts.</p>
</dd>
<dt><code>emiss_V</code></dt><dd><p>A list containing <code>n_dep</code> elements containing
the variance-covariance of the hyper-prior Inverse Wishart distribution on
the covariance of the Multinomial logit intercepts.</p>
</dd>
<dt><code>n_xx_emiss</code></dt><dd><p>A numeric vector denoting the number of (level 2)
covariates used to predict the emission distribution of each of the
dependent variables. When no covariates are used, <code>n_xx_emiss</code> equals
<code>NULL</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+prior_gamma">prior_gamma</a></code> for manually specifying an informative
hyper-prior on the transition probability matrix gamma,
<code><a href="#topic+prob_to_int">prob_to_int</a></code> for transforming a set of probabilities to a set
of Multinomial logit regression intercepts, and <code><a href="#topic+mHMM">mHMM</a></code> for
fitting a multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using package example data, see ?nonverbal
# specifying general model properties:
m &lt;- 3
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# hypothesized mean emission probabilities
prior_prob_emiss_cat &lt;- list(matrix(c(0.10, 0.80, 0.10,
                                      0.80, 0.10, 0.10,
                                      0.40, 0.40, 0.20), byrow = TRUE,
                                    nrow = m, ncol = q_emiss[1]), # vocalizing patient,
                                    # prior belief: state 1 - much talking, state 2 -
                                    # no talking, state 3 - mixed
                             matrix(c(0.30, 0.70,
                                      0.30, 0.70,
                                      0.30, 0.70), byrow = TRUE, nrow = m,
                                    ncol = q_emiss[2]), # looking patient
                                    # prior belief: all 3 states show frequent looking
                                    # behavior
                             matrix(c(0.80, 0.10, 0.10,
                                      0.10, 0.80, 0.10,
                                      0.40, 0.40, 0.20), byrow = TRUE,
                                    nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                                    # prior belief: state 1 - no talking, state 2 -
                                    # frequent talking, state 3 - mixed
                             matrix(c(0.30, 0.70,
                                      0.30, 0.70,
                                      0.30, 0.70), byrow = TRUE, nrow = m,
                                    ncol = q_emiss[4])) # looking therapist
                                    # prior belief: all 3 states show frequent looking
                                    # behavior

# using the function prob_to_int to obtain intercept values for the above specified
# categorical emission distributions
prior_int_emiss &lt;- sapply(prior_prob_emiss_cat, prob_to_int)
emiss_mu0 &lt;- rep(list(vector(mode = "list", length = m)), n_dep)
for(k in 1:n_dep){
  for(i in 1:m){
  emiss_mu0[[k]][[i]] &lt;- matrix(prior_int_emiss[[k]][i,], nrow = 1)
  }
}

emiss_K0 &lt;- rep(list(c(1)), n_dep)
emiss_nu &lt;- list(c(5), c(4), c(5), c(4))
emiss_V &lt;- list(diag(5, q_emiss[1] - 1),
                diag(4, q_emiss[2] - 1),
                diag(5, q_emiss[3] - 1),
                diag(4, q_emiss[4] - 1))

manual_prior_emiss &lt;- prior_emiss_cat(gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                                  emiss_mu0 = emiss_mu0, emiss_K0 = emiss_K0,
                                  emiss_nu = emiss_nu, emiss_V = emiss_V)


# using the informative hyper-prior in a model

# specifying starting values
start_TM &lt;- diag(.7, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .1
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.

out_3st_infemiss &lt;- mHMM(s_data = nonverbal,
                    gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                    start_val = c(list(start_TM), start_EM),
                    emiss_hyp_prior = manual_prior_emiss,
                    mcmc = list(J = 11, burn_in = 5))

out_3st_infemiss
summary(out_3st_infemiss)



</code></pre>

<hr>
<h2 id='prior_emiss_cont'>Specifying informative hyper-prior on the continuous emission distribution(s)  of the multilevel hidden Markov model</h2><span id='topic+prior_emiss_cont'></span>

<h3>Description</h3>

<p><code>prior_emiss_cont</code> provides a framework to manually specify an
informative hyper-prior on the Normal (i.e., Gaussian) emission
distributions. <code>prior_emiss_cont</code> creates an object of class
<code>mHMM_prior_emiss</code> used by the function <code>mHMM</code>, and additionally
attaches the class <code>cont</code> to signal use for continuous observations. The
set of hyper-prior distributions consists of a Normal-Inverse-Gamma
distribution (i.e., assuming both unknown population mean and variance
between subject level means) on the vector of means (i.e., intercepts and
regression coefficients), and an Inverse gamma distribution (i.e., assuming a
known mean) on each of the (fixed over subjects) emission variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_emiss_cont(
  gen,
  emiss_mu0,
  emiss_K0,
  emiss_V,
  emiss_nu,
  emiss_a0,
  emiss_b0,
  n_xx_emiss = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_emiss_cont_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_emiss_mu0">emiss_mu0</code></td>
<td>
<p>A list containing <code>n_dep</code> matrices, i.e., one list for
each dependent variable <code>k</code>. Each matrix contains the hypothesized
hyper-prior means of the Normal emission distributions in each of the
states. Hence, each matrix consists of one row (when not including
covariates in the model) and <code>m</code> columns. If covariates are used, the
number of rows in each matrix in the list is equal to 1 + n_xx (i.e., the
first row corresponds to the hyper-prior means, the subsequent rows
correspond to the hyper-prior values of the regression coefficients
connected to each of the covariates).</p>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_emiss_k0">emiss_K0</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding
to each dependent variable <code>k</code>. Each element <code>k</code> is a
numeric vector with length 1 (when no covariates are used) denoting the
number of hypothetical prior subjects on which the set of hyper-prior means
specified in <code>emiss_mu0</code> are based. When covariates are
used: each element is a numeric vector with length 1 + n_xx denoting the
number of hypothetical prior subjects on which the set of means (first
value) and set of regression coefficients (subsequent values) are based.</p>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_emiss_v">emiss_V</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to each
of the dependent variables <code>k</code>, where each element <code>k</code> is a
vector with length <code>m</code> containing the hypothesized variance between
the subject (emission distribution) means, which are assumed to follow a
Inverse Gamma hyper-prior distribution (note: here, the Inverse Gamma
hyper-prior distribution is parametrized as a scaled inverse chi-squared
distribution).</p>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_emiss_nu">emiss_nu</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to each
dependent variable <code>k</code>. Each element <code>k</code> is a numeric vector with
length 1 denoting the degrees of freedom of the Inverse Gamma hyper-prior
distribution on the between subject variance of the emission distribution
means (note: here, the Inverse Gamma hyper-prior distribution is
parametrized as a scaled inverse chi-squared distribution).</p>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_emiss_a0">emiss_a0</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to each
of the dependent variables <code>k</code>, where each element <code>k</code> is a
vector with length <code>m</code> containing the shape values of the Inverse
Gamma hyper-prior on each of the (fixed over subjects) emission standard
deviation^2 of the Normal emission distributions (note: here the standard
Inverse Gamma parametrization is used).</p>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_emiss_b0">emiss_b0</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to each
of the dependent variables <code>k</code>, where each element <code>k</code> is a
vector with length <code>m</code> containing the scale values of the Inverse
Gamma hyper-prior on each of the (fixed over subjects) emission standard
deviation^2 of the Normal emission distributions (note: here the standard
Inverse Gamma parametrization is used).</p>
</td></tr>
<tr><td><code id="prior_emiss_cont_+3A_n_xx_emiss">n_xx_emiss</code></td>
<td>
<p>Optional numeric vector with length <code>n_dep</code> denoting
the number of (level 2) covariates used to predict the emission
distribution of each of the dependent variables <code>k</code>. When omitted, the
model assumes no covariates are used to predict the emission
distribution(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the mHMM proceeds within a Bayesian context, hence a
hyper-prior distribution has to be defined for the group level parameters. To
avoid problems with 'label switching' when dealing with continuous emission
distribution(s) (i.e., switching of the labels of the hidden states while
sampling from the MCMC), the user is forced to specify hyper-prior parameter
values when using continuous emission distributions (i.e., default,
non-informative priors are not available for continuous emission
distributions).
</p>
<p>Note that <code>emiss_K0</code> and <code>emiss_nu</code> are assumed equal over the
states. Also note that in case covariates are specified, the hyper-prior
parameter values of the inverse Wishart distribution on the covariance matrix
remain unchanged, as the estimates of the regression coefficients for the
covariates are fixed over subjects.
</p>


<h3>Value</h3>

<p><code>prior_emiss_cont</code> returns an object of class <code>mHMM_prior_emiss</code>,
containing informative hyper-prior values for the continuous emission
distribution(s) of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>,
and thoroughly checked for correct input dimensions.
The object contains the following components:
</p>

<dl>
<dt><code>gen</code></dt><dd><p>A list containing the elements <code>m</code>, and <code>n_dep</code>,
used for checking equivalent general model properties
specified under <code>prior_emiss_cont</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>emiss_mu0</code></dt><dd><p>A lists containing the hypothesized
hyper-prior means of the Normal distribution on
the continuous emission probabilities.</p>
</dd>
<dt><code>emiss_K0</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting the
number of hypothetical prior subjects on which the set of hyper-prior means
specified in <code>emiss_mu0</code> are based.</p>
</dd>
<dt><code>emiss_V</code></dt><dd><p>A list containing <code>n_dep</code> elements containing
the variance of the Inverse Gamma hyper-prior distribution on the between
subject variance of the emission distribution means.</p>
</dd>
<dt><code>emiss_nu</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting the
degrees of freedom of the Inverse Gamma hyper-prior distribution on the
between subject variance of the emission distribution means.</p>
</dd>
<dt><code>emiss_a0</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting
the shape values of the Inverse Gamma hyper-prior on each of the (fixed
over subjects) emission standard deviation^2 of the Normal emission
distributions.</p>
</dd>
<dt><code>emiss_b0</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting
the scale values of the Inverse Gamma hyper-prior on each of the (fixed
over subjects) emission standard deviation^2 of the Normal emission
distributions.</p>
</dd>
<dt><code>n_xx_emiss</code></dt><dd><p>A numeric vector denoting the number of (level 2)
covariates used to predict the emission distribution of each of the
dependent variables. When no covariates are used, <code>n_xx_emiss</code> equals
<code>NULL</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+prior_gamma">prior_gamma</a></code> for manually specifying an informative
hyper-prior on the transition probability matrix gamma, and
<code><a href="#topic+mHMM">mHMM</a></code> for fitting a multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using simulated data
# specifying general model properties:
m &lt;- 3
n_dep &lt;- 2

# hypothesized hyper-prior values for the continuous emission distribution
manual_prior_emiss &lt;- prior_emiss_cont(
                        gen = list(m = m, n_dep = n_dep),
                        emiss_mu0 = list(matrix(c(30, 70, 170), nrow = 1),
                                         matrix(c(7, 8, 18), nrow = 1)),
                        emiss_K0 = list(1, 1),
                         emiss_V =  list(rep(5^2, m), rep(0.5^2, m)),
                        emiss_nu = list(1, 1),
                        emiss_a0 = list(rep(1.5, m), rep(1, m)),
                        emiss_b0 = list(rep(20, m), rep(4, m)))

# to use the informative priors in a model, simulate multivariate continuous data
n_t     &lt;- 100
n       &lt;- 10

gamma   &lt;- matrix(c(0.8, 0.1, 0.1,
                    0.2, 0.7, 0.1,
                    0.2, 0.2, 0.6), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c( 50, 10,
                              100, 10,
                              150, 10), nrow = m, byrow = TRUE),
                    matrix(c(5, 2,
                             10, 5,
                             20, 3), nrow = m, byrow = TRUE))

data_cont &lt;- sim_mHMM(n_t = n_t, n = n, data_distr = 'continuous',
                      gen = list(m = m, n_dep = n_dep),
                      gamma = gamma, emiss_distr = emiss_distr,
                      var_gamma = .1, var_emiss = c(5^2, 0.2^2))

# using the informative hyper-prior in a model
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_3st_cont_sim_infemiss &lt;- mHMM(s_data = data_cont$obs,
                    data_distr = "continuous",
                    gen = list(m = m, n_dep = n_dep),
                    start_val = c(list(gamma), emiss_distr),
                    emiss_hyp_prior = manual_prior_emiss,
                    mcmc = list(J = 11, burn_in = 5))

out_3st_cont_sim_infemiss
summary(out_3st_cont_sim_infemiss)

</code></pre>

<hr>
<h2 id='prior_emiss_count'>Specifying informative hyper-priors on the count emission
distribution(s) of the multilevel hidden Markov model</h2><span id='topic+prior_emiss_count'></span>

<h3>Description</h3>

<p><code>prior_emiss_count</code> provides a framework to manually specify an
informative hyper-prior on the count emission distributions.
<code>prior_emiss_count</code> creates an object of class
<code>mHMM_prior_emiss</code> used by the function <code>mHMM</code>, and additionally
attaches the class <code>count</code> to signal use for count observations. The
set of hyper-prior distributions consists of a lognormal-Inverse-Gamma
distribution (i.e., assuming both unknown population mean and variance
between subject level means) on the vector of Poisson means (i.e.,
intercepts and regression coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_emiss_count(
  gen,
  emiss_mu0,
  emiss_K0,
  emiss_V,
  emiss_nu,
  n_xx_emiss = NULL,
  log_scale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_emiss_count_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="prior_emiss_count_+3A_emiss_mu0">emiss_mu0</code></td>
<td>
<p>A list containing <code>n_dep</code> matrices, i.e., one list for
each dependent variable <code>k</code>. Each matrix contains the hypothesized
hyper-prior means of the Poisson emission distribution in each of the
states in the natural (positive real numbers) scale. Hence, each
matrix consists of one row (when not including covariates in the model)
and <code>m</code> columns. If covariates are used, the number of rows in each
matrix in the list is equal to 1 + n_xx_emiss (i.e., the first row
corresponds to the hyper-prior means, the subsequent rows correspond to
the hyper-prior values of the regression coefficients connected to each of
the covariates). If covariates are used to predict the emission
distribution, then <code>emiss_mu0</code> should be specified in the logarithmic
scale, and <code>log_scale</code> set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="prior_emiss_count_+3A_emiss_k0">emiss_K0</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding
to each dependent variable <code>k</code>. Each element <code>k</code> is a
numeric vector with length 1 (when no covariates are used) denoting the
number of hypothetical prior subjects on which the set of hyper-prior means
specified in <code>emiss_mu0</code> are based. When covariates are
used: each element is a numeric vector with length 1 + n_xx denoting the
number of hypothetical prior subjects on which the set of means (first
value) and set of regression coefficients (subsequent values) are based.</p>
</td></tr>
<tr><td><code id="prior_emiss_count_+3A_emiss_v">emiss_V</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to each
of the dependent variables <code>k</code>, where each element <code>k</code> is a
vector with length <code>m</code> containing the hypothesized variance between
the subject (emission distribution) means in the natural (positive real
numbers) scale, which are assumed to follow a Inverse Gamma hyper-prior
distribution (note: here, the Inverse Gamma hyper-prior distribution is
parametrized as a scaled inverse chi-squared distribution). If
covariates are used to predict the emission distribution, then
<code>emiss_V</code> should be specified in the logarithmic scale, and
<code>log_scale</code> set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="prior_emiss_count_+3A_emiss_nu">emiss_nu</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to each
dependent variable <code>k</code>. Each element <code>k</code> is a numeric vector with
length 1 denoting the degrees of freedom of the Inverse Gamma hyper-prior
distribution on the between subject variance of the emission distribution
means (note: here, the Inverse Gamma hyper-prior distribution is
parametrized as a scaled inverse chi-squared distribution).</p>
</td></tr>
<tr><td><code id="prior_emiss_count_+3A_n_xx_emiss">n_xx_emiss</code></td>
<td>
<p>Optional numeric vector with length <code>n_dep</code> denoting
the number of (level 2) covariates used to predict the emission
distribution of each of the dependent variables <code>k</code>. When omitted, the
model assumes no covariates are used to predict the emission
distribution(s).</p>
</td></tr>
<tr><td><code id="prior_emiss_count_+3A_log_scale">log_scale</code></td>
<td>
<p>A logical scalar. Should <code>emiss_mu0</code> and <code>emiss_V</code>
be specified in the logarithmic scale (<code>log_scale = TRUE</code>) or the
natural scale (<code>log_scale = FALSE</code>). The default equals
<code>log_scale = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the mHMM proceeds within a Bayesian context, hence a
hyper-prior distribution has to be defined for the group level parameters. To
avoid problems with 'label switching' when dealing with continuous emission
distribution(s) (i.e., switching of the labels of the hidden states while
sampling from the MCMC), the user is forced to specify hyper-prior parameter
values when using count emission distributions (i.e., default,
non-informative priors are not available for count emission
distributions).
</p>
<p>Note that <code>emiss_K0</code> and <code>emiss_nu</code> are assumed equal over the
states. Also note that in case covariates are specified, the hyper-prior
parameter values of the inverse Wishart distribution on the covariance matrix
remain unchanged, as the estimates of the regression coefficients for the
covariates are fixed over subjects.
</p>
<p>Also note that for simplicity the hyper-prior means and variances of the
lognormal distribution, <code>emiss_mu0</code> and <code>emiss_V</code>, by default
have to be specified in the natural (positive real numbers) scale and not in
the logarithmic scale. <code>prior_emiss_count</code> returns the corresponding
values of the parameters on the logarithmic scale. If the user wants to
manually specify these values on the logarithmic scale, please set the
argument <code>log_scale</code> to <code>TRUE</code> in <code>prior_emiss_count</code>. If
covariates are used to predict the emission distribution, then the
logarithmic scale should be used for the inputs <code>emiss_mu0</code> and
<code>emiss_V</code>, and set <code>log_scale = TRUE</code>. To aid the user in
transforming the variance to the logarithmic scale, the function
'var_to_logvar()' can be used.
</p>


<h3>Value</h3>

<p><code>prior_emiss_count</code> returns an object of class <code>mHMM_prior_emiss</code>,
containing informative hyper-prior values for the continuous emission
distribution(s) of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>,
and thoroughly checked for correct input dimensions.
The object contains the following components:
</p>

<dl>
<dt><code>gen</code></dt><dd><p>A list containing the elements <code>m</code>, and <code>n_dep</code>,
used for checking equivalent general model properties
specified under <code>prior_emiss_count</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>emiss_mu0</code></dt><dd><p>A lists containing the hypothesized
hyper-prior means of the the Poisson distribution used to model
the count emissions.</p>
</dd>
<dt><code>emiss_K0</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting the
number of hypothetical prior subjects on which the set of hyper-prior means
specified in <code>emiss_mu0</code> are based.</p>
</dd>
<dt><code>emiss_V</code></dt><dd><p>A list containing <code>n_dep</code> elements containing
the variance of the Inverse Gamma hyper-prior distribution on the between
subject variance of the emission distribution means.</p>
</dd>
<dt><code>emiss_nu</code></dt><dd><p>A list containing <code>n_dep</code> elements denoting the
degrees of freedom of the Inverse Gamma hyper-prior distribution on the
between subject variance of the emission distribution means.</p>
</dd>
<dt><code>n_xx_emiss</code></dt><dd><p>A numeric vector denoting the number of (level 2)
covariates used to predict the emission distribution of each of the
dependent variables. When no covariates are used, <code>n_xx_emiss</code> equals
<code>NULL</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+prior_gamma">prior_gamma</a></code> for manually specifying an informative
hyper-prior on the transition probability matrix gamma, and
<code><a href="#topic+mHMM">mHMM</a></code> for fitting a multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using simulated data
# specifying general model properties:
m &lt;- 3
n_dep &lt;- 2

# hypothesized hyper-prior values for the count emission distribution
manual_prior_emiss &lt;- prior_emiss_count(
                        gen = list(m = m, n_dep = n_dep),
                        emiss_mu0 = list(matrix(c(30, 70, 170), nrow = 1),
                                         matrix(c(7, 8, 18), nrow = 1)),
                        emiss_K0 = list(1, 1),
                        emiss_V =  list(rep(16, m), rep(4, m)),
                        emiss_nu = list(0.1, 0.1))

# to use the informative priors in a model, simulate multivariate count data
n_t     &lt;- 100
n       &lt;- 10

# Specify group-level transition and emission means
gamma   &lt;- matrix(c(0.8, 0.1, 0.1,
                    0.2, 0.7, 0.1,
                    0.2, 0.2, 0.6), ncol = m, byrow = TRUE)
emiss_distr &lt;- list(matrix(log(c( 50,
                              100,
                              150)), nrow = m, byrow = TRUE),
                    matrix(log(c(5,
                             10,
                             20)), nrow = m, byrow = TRUE))
# Simulate data
data_count &lt;- sim_mHMM(n_t = n_t, n = n, data_distr = 'count',
                       gen = list(m = m, n_dep = n_dep),
                       gamma = gamma, emiss_distr = emiss_distr,
                       var_gamma = .1, var_emiss = c(.05, 0.01), log_scale = TRUE)

# Specify starting values
start_gamma &lt;- gamma
start_emiss &lt;- list(matrix(c(50,
                             100,
                             150), nrow = m, byrow = TRUE),
                    matrix(c(5,
                             10,
                             20), nrow = m, byrow = TRUE))


# using the informative hyper-prior in a model
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_3st_count_sim_infemiss &lt;- mHMM(s_data = data_count$obs,
                    data_distr = "count",
                    gen = list(m = m, n_dep = n_dep),
                    start_val = c(list(start_gamma), start_emiss),
                    emiss_hyp_prior = manual_prior_emiss,
                    mcmc = list(J = 11, burn_in = 5))

out_3st_count_sim_infemiss
summary(out_3st_count_sim_infemiss)

</code></pre>

<hr>
<h2 id='prior_gamma'>Specifying informative hyper-prior on the transition probability matrix gamma of the multilevel hidden Markov model</h2><span id='topic+prior_gamma'></span>

<h3>Description</h3>

<p><code>prior_gamma</code> provides a framework to manually specify an informative
hyper-prior on the transition probability matrix gamma, and creates an object
of class <code>mHMM_prior_gamma</code> used by the function <code>mHMM</code>. Note that the
hyper-prior distribution on the transition probabilities are on the
intercepts (and, if subject level covariates are used, regression
coefficients) of the Multinomial logit model used to accommodate the
multilevel framework of the data, instead of on the probabilities directly.
The set of hyper-prior distributions consists of a multivariate Normal
hyper-prior distribution on the vector of means (i.e., intercepts and
regression coefficients), and an Inverse Wishart hyper-prior distribution on
the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_gamma(
  m,
  gamma_mu0,
  gamma_K0 = NULL,
  gamma_nu = NULL,
  gamma_V = NULL,
  n_xx_gamma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_gamma_+3A_m">m</code></td>
<td>
<p>Numeric vector with length 1 denoting the number of hidden states.</p>
</td></tr>
<tr><td><code id="prior_gamma_+3A_gamma_mu0">gamma_mu0</code></td>
<td>
<p>A list containing m matrices; one matrix for each row of the
transition probability matrix gamma. Each matrix contains the hypothesized
hyper-prior mean values of the intercepts of the Multinomial logit
model on the transition probabilities gamma. Hence, each matrix
consists of one row (when not including covariates in the model) and
<code>m</code> - 1 columns. If covariates are used, the number of rows in each
matrix in the list is equal to 1 + n_xx_gamma (i.e., the first row corresponds to
the hyper-prior mean values of the intercepts, the subsequent rows
correspond to the hyper-prior mean values of the regression coefficients
connected to each of the covariates).</p>
</td></tr>
<tr><td><code id="prior_gamma_+3A_gamma_k0">gamma_K0</code></td>
<td>
<p>Optional numeric vector with length 1 (when no covariates are
used) denoting the number of hypothetical prior subjects on which the set
of hyper-prior mean intercepts specified in <code>gamma_mu0</code> are based.
When covariates are used: Numeric vector with length 1 + n_xx_gamma denoting the
number of hypothetical prior subjects on which the set of intercepts (first
value) and set of regression coefficients (subsequent values) are based.</p>
</td></tr>
<tr><td><code id="prior_gamma_+3A_gamma_nu">gamma_nu</code></td>
<td>
<p>Optional numeric vector with length 1 denoting the degrees of freedom
of the hyper-prior Inverse Wishart distribution on the covariance of
the Multinomial logit intercepts.</p>
</td></tr>
<tr><td><code id="prior_gamma_+3A_gamma_v">gamma_V</code></td>
<td>
<p>Optional matrix of <code>m</code> - 1 by <code>m</code> - 1 containing the
variance-covariance matrix of the hyper-prior Inverse Wishart distribution
on the covariance of the Multinomial logit intercepts.</p>
</td></tr>
<tr><td><code id="prior_gamma_+3A_n_xx_gamma">n_xx_gamma</code></td>
<td>
<p>Optional numeric vector with length 1 denoting the number
of (level 2) covariates (excluding the intercept) used to predict the
transition probability matrix gamma. When omitted, the model assumes no
covariates are used to predict gamma.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the mHMM proceeds within a Bayesian context, hence a
hyper-prior distribution has to be defined for the group level parameters.
Default, non-informative priors are used unless specified otherwise by the
user. Each row of the transition probability matrix has its own set of
Multinomial logit intercepts, which are assumed to follow a multivariate
normal distribution. Hence, the hyper-prior distributions for the intercepts
consists of a multivariate Normal hyper-prior distribution on the vector of
means, and an Inverse Wishart hyper-prior distribution on the covariance
matrix. Note that only the number of states <code>m</code> and values of the
hypothesized hyper-prior mean values of the Multinomial logit intercepts have
to be specified by the user, default values are available for all other
hyper-prior distribution parameters.
</p>
<p>Given that the hyper-priors are specified on the intercepts of the Multinomial
logit model intercepts instead of on the probabilities of the transition
probability matrix gamma directly, specifying a hyper-prior can seem rather
daunting. However, see the function <code><a href="#topic+prob_to_int">prob_to_int</a></code> and
<code><a href="#topic+int_to_prob">int_to_prob</a></code> for translating probabilities to a set of
Multinomial logit intercepts and vice versa.
</p>
<p>Note that <code>gamma_K0</code>, <code>gamma_nu</code> and <code>gamma_V</code> are assumed
equal over the states. When the hyper-prior values for <code>gamma_K0</code>,
<code>gamma_nu</code> and <code>gamma_V</code> are not manually specified, the default
values are as follows. <code>gamma_K0</code> set to 1, <code>gamma_nu</code> set to 3 + m
- 1, and the diagonal of <code>gamma_V</code> (i.e., the variance) set to 3 + m - 1
and the off-diagonal elements (i.e., the covariance) set to 0. In addition,
when no manual values for the hyper-prior on gamma are specified at all (that
is, the function <code>prior_gamma</code> is not used), all elements of the
matrices contained in <code>gamma_mu0</code> are set to 0 in the function
<code>mHMM</code>.
</p>
<p>Note that in case covariates are specified, the hyper-prior parameter values
of the inverse Wishart distribution on the covariance matrix remain
unchanged, as the estimates of the regression coefficients for the covariates
are fixed over subjects.
</p>


<h3>Value</h3>

<p><code>prior_gamma</code> returns an object of class <code>mHMM_prior_gamma</code>,
containing informative hyper-prior values for the transition probability
matrix gamma of the multilevel hidden Markov model. The object is
specifically created and formatted for use by the function <code>mHMM</code>,
and thoroughly checked for correct input dimensions.
The object contains the following components:
</p>

<dl>
<dt><code>m</code></dt><dd><p>Numeric vector denoting the number of hidden states, used
for checking equivalent general model properties specified under
<code>prior_gamma</code> and <code>mHMM</code>.</p>
</dd>
<dt><code>gamma_mu0</code></dt><dd><p>A list containing the hypothesized hyper-prior mean
values of the intercepts of the Multinomial logit model on the transition
probability matrix gamma.</p>
</dd>
<dt><code>gamma_K0</code></dt><dd><p>A numeric vector denoting the number of hypothetical
prior subjects on which the set of hyper-prior mean intercepts specified in
<code>gamma_mu0</code> are based.</p>
</dd>
<dt><code>gamma_nu</code></dt><dd><p>A numeric vector denoting the degrees of freedom
of the hyper-prior Inverse Wishart distribution on the covariance of the
Multinomial logit intercepts.</p>
</dd>
<dt><code>gamma_V</code></dt><dd><p>A matrix containing the variance-covariance of the
hyper-prior Inverse Wishart distribution on the covariance of the
Multinomial logit intercepts.</p>
</dd>
<dt><code>n_xx_gamma</code></dt><dd><p>A numeric vector denoting the number of (level 2)
covariates used to predict the transition probability matrix gamma. When no
covariates are used, <code>n_xx_gamma</code> equals <code>NULL</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+prior_emiss_cat">prior_emiss_cat</a></code> for manually specifying an informative
hyper-prior on the categorical emission distribution(s),
<code><a href="#topic+prob_to_int">prob_to_int</a></code> for transforming a set of probabilities to a set
of Multinomial logit regression intercepts, and <code><a href="#topic+mHMM">mHMM</a></code> for
fitting a multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example using package example data, see ?nonverbal
# specifying general model properties:
m &lt;- 3
# representing a prior belief that switching to state 3 does not occur often and
# state 3 has a relative short duration
prior_prob_gamma &lt;- matrix(c(0.70, 0.25, 0.05,
                             0.25, 0.70, 0.05,
                             0.30, 0.30, 0.40), nrow = m, ncol = m, byrow = TRUE)

# using the function prob_to_int to obtain intercept values for the above specified
# transition probability matrix gamma
prior_int_gamma &lt;- prob_to_int(prior_prob_gamma)
gamma_mu0 &lt;- list(matrix(prior_int_gamma[1,], nrow = 1, ncol = m-1),
                  matrix(prior_int_gamma[2,], nrow = 1, ncol = m-1),
                  matrix(prior_int_gamma[3,], nrow = 1, ncol = m-1))

gamma_K0 &lt;- 1
gamma_nu &lt;- 5
gamma_V &lt;- diag(5, m - 1)

manual_prior_gamma &lt;- prior_gamma(m = m, gamma_mu0 = gamma_mu0,
                                  gamma_K0 = gamma_K0, gamma_nu = gamma_nu,
                                  gamma_V = gamma_V)


# using the informative hyper-prior in a model
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.7, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .1
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05,
                          0.55, 0.45, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.

out_3st_infgamma &lt;- mHMM(s_data = nonverbal,
                    gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                    start_val = c(list(start_TM), start_EM),
                    gamma_hyp_prior = manual_prior_gamma,
                    mcmc = list(J = 11, burn_in = 5))

out_3st_infgamma
summary(out_3st_infgamma)




</code></pre>

<hr>
<h2 id='prob_to_int'>Transforming a set of probabilities to Multinomial logit regression intercepts</h2><span id='topic+prob_to_int'></span>

<h3>Description</h3>

<p><code>prob_to_int</code> transforms a set of state transition or categorical
emission observation probabilities to the corresponding Multinomial logit
regression intercepts. Note that the first category is assumed to be the
reference category, hence no intercept is returned for the first state or
category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_to_int(prob_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_to_int_+3A_prob_matrix">prob_matrix</code></td>
<td>
<p>A matrix with number of states OR categories columns and
number of rows to be determined by the user, with rows summing to one. For
obtaining the set of Multinomial logit regression intercepts of the
complete transition probability matrix gamma or categorical emission
distribution matrix, the number of rows equals the number of states
<code>m</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed to ease the specification of informative hyper-prior values for the
mean intercepts of the transition probability matrix gamma and categorical
emission distribution(s) of the multilevel hidden Markov model through the
functions <code><a href="#topic+prior_gamma">prior_gamma</a></code> and <code><a href="#topic+prior_emiss_cat">prior_emiss_cat</a></code>. No
check is performed on correct specifications of the dimensions.
</p>


<h3>Value</h3>

<p><code>prob_to_int</code> returns a matrix containing Multinomial logit
regression intercepts, with the number of columns equal to (number of
states or categories - 1) and the number of rows equal to the number rows
specified in the input matrix. The first state / category is assumed to be
the reference category, hence no intercept is returned for this first
category.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int_to_prob">int_to_prob</a></code> for transforming a set of Multinomial
logit regression intercepts to a probabilities, <code><a href="#topic+prior_gamma">prior_gamma</a></code>
and <code><a href="#topic+prior_emiss_cat">prior_emiss_cat</a></code> for specifying informative hyper-priors
for the the multilevel hidden Markov model and <code><a href="#topic+mHMM">mHMM</a></code> to fit a
multilevel hidden Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example for transition probability matrix gamma with 3 states
m &lt;- 3
gamma_prob &lt;- matrix(c(0.6, 0.2, 0.2,
                       0.1, 0.8, 0.1,
                       0.1, 0.1, 0.8), ncol = m, nrow = m, byrow = TRUE)
gamma_int &lt;- prob_to_int(gamma_prob)
gamma_int

</code></pre>

<hr>
<h2 id='sim_mHMM'>Simulate data using a multilevel hidden Markov model</h2><span id='topic+sim_mHMM'></span>

<h3>Description</h3>

<p><code>sim_mHMM</code> simulates data for multiple subjects, for which the data have
either categorical or continuous (i.e., normally distributed)
observations that follow a hidden Markov model (HMM) with a
multilevel structure. The multilevel structure implies that each subject is
allowed to have its own set of parameters, and that the parameters at the
subject level (level 1) are tied together by a population distribution at
level 2 for each of the corresponding parameters. The shape of the population
distribution for each of the parameters is a normal distribution. In addition
to (natural and/or unexplained) heterogeneity between subjects, the subjects
parameters can also depend on a covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mHMM(
  n_t,
  n,
  data_distr = "categorical",
  gen,
  gamma,
  emiss_distr,
  start_state = NULL,
  xx_vec = NULL,
  beta = NULL,
  var_gamma = 0.1,
  var_emiss = NULL,
  return_ind_par = FALSE,
  m,
  n_dep,
  q_emiss,
  log_scale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_mHMM_+3A_n_t">n_t</code></td>
<td>
<p>Numeric vector with length 1 denoting the length of the observed
sequence to be simulated for each subject. To only simulate subject
specific transition probability matrices gamma and emission distributions
(and no data), set <code>t</code> to 0.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_n">n</code></td>
<td>
<p>Numeric vector with length 1 denoting the number of subjects for
which data is simulated.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_data_distr">data_distr</code></td>
<td>
<p>A character vector of length 1 denoting the distribution
adopted for the data given the hidden states. It can take the values
'categorical', 'continuous', or 'count', standing for the for categorical
observations following a Multinomial logit, continuous observations
following a normal distribution, and count observations following a
Poisson distribution, correspondingly.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables
</p>
</li>
<li><p><code>q_emiss</code>: only to be specified if the data represents
categorical data. Numeric vector with length <code>n_dep</code> denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.</p>
</li></ul>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_gamma">gamma</code></td>
<td>
<p>A matrix with <code>m</code> rows and <code>m</code> columns containing the
average population transition probability matrix used for simulating the
data. That is, the probability to switch from hidden state <em>i</em> (row
<em>i</em>) to hidden state <em>j</em> (column  <em>j</em>).</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_emiss_distr">emiss_distr</code></td>
<td>
<p>A list with <code>n_dep</code> elements containing the average
population emission distribution(s) of the observations given the hidden
states for each of the dependent variables. If <code>data_distr =
'categorical'</code>, each element is a matrix with <code>m</code> rows and
<code>q_emiss[k]</code> columns for each of the <code>k</code> in <code>n_dep</code> emission
distribution(s). That is, the probability of observing category <em>q</em>
(column <em>q</em>) in state <em>i</em> (row <em>i</em>). If <code>data_distr =
'continuous'</code>, each element is a matrix with <code>m</code> rows and 2 columns;
the first column denoting the mean of state <em>i</em> (row <em>i</em>) and the
second column denoting the standard deviation of state <em>i</em>
(row <em>i</em>) of the Normal distribution. If <code>data_distr =
'count'</code>, each element is a matrix with <code>m</code> rows and 1 column;
the only column denoting the logmean of state <em>i</em> (row <em>i</em>)
of the lognormal distribution used as prior for the Poisson emissions
(note: by default the logmeans should be specified in the natural scale;
see argument <code>log_scale</code> below, unless covariates are used to predict
a count emission distribution).</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_start_state">start_state</code></td>
<td>
<p>Optional numeric vector with length 1 denoting in which
state the simulated state sequence should start. If left unspecified, the
simulated state for time point 1 is sampled from the initial state
distribution (which is derived from the transition probability matrix
gamma).</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_xx_vec">xx_vec</code></td>
<td>
<p>List of 1 + <code>n_dep</code> vectors containing the covariate(s) to
predict the transition probability matrix <code>gamma</code> and/or (specific)
emission distribution(s) <code>emiss_distr</code> using the regression parameters
specified in <code>beta</code> (see below). The first element in the list
<code>xx_vec</code> is used to predict the transition matrix. Subsequent elements
in the list are used to predict the emission distribution of (each of) the
dependent variable(s). This means that the covariate used to predict
<code>gamma</code> and <code>emiss_distr</code> can either be the same covariate,
different covariates, or a covariate for certain elements and none for the
other. At this point, it is only possible to use one covariate for both
<code>gamma</code> and <code>emiss_distr</code>. For all elements in the list,
the number of observations in the vectors should be  equal to the number of
subjects to be simulated <code>n</code>. If <code>xx_vec</code> is omitted completely,
<code>xx_vec</code> defaults to NULL, resembling no covariates at all. Specific
elements in the list can also be left empty (i.e., set to <code>NULL</code>) to
signify that either the transition probability matrix or (one of) the
emission distribution(s) is not predicted by covariates.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_beta">beta</code></td>
<td>
<p>List of 1 + <code>n_dep</code> matrices containing the regression
parameters to predict <code>gamma</code> and/or <code>emiss_distr</code> in combination
with <code>xx_vec</code> using (Multinomial logistic) regression. The first
matrix is used to predict the transition probability matrix <code>gamma</code>.
The subsequent matrices are used to predict the emission distribution(s)
<code>emiss_distr</code> of the dependent variable(s). For <code>gamma</code> and
categorical emission distributions, one regression parameter is specified
for each element in <code>gamma</code> and <code>emiss_distr</code>, with the following
exception. The first element in each row of <code>gamma</code> and/or
<code>emiss_distr</code> is used as reference category in the Multinomial
logistic regression. As such, no regression parameters can be specified for
these parameters. Hence, the first element in the list <code>beta</code> to
predict <code>gamma</code> consist of a matrix with the number of rows equal to
<code>m</code> and the number of columns equal to <code>m</code> - 1. For categorical
emission distributions, the subsequent elements in the list <code>beta</code> to
predict <code>emiss_distr</code> consist of a matrix with the number of rows
equal to <code>m</code> and the number of columns equal to <code>q_emiss[k]</code> - 1
for each of the <code>k</code> in <code>n_dep</code> emission distribution(s). See
<em>details</em> for more information. For continuous and count emission
distributions, the subsequent elements in the list <code>beta</code> consist of
a matrix with the number of rows equal to <code>m</code> and 1 column.
</p>
<p>Note that if <code>beta</code> is specified, <code>xx_vec</code> has to be specified as
well. If <code>beta</code> is omitted completely, <code>beta</code> defaults to NULL,
resembling no prediction of <code>gamma</code> and <code>emiss_distr</code> using
covariates. One of the elements in the list can also be left empty
(i.e., set to <code>NULL</code>) to signify that either the transition
probability matrix or a specific emission distribution is not predicted by
covariates. If covariates are used to predict a count emission
distribution (<code>data_distr = 'count'</code>), then the logarithmic scale
should be used for the inputs <code>emiss_distr</code> and <code>var_emiss</code> in
addition to <code>beta</code>, and also set <code>log_scale = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_var_gamma">var_gamma</code></td>
<td>
<p>Either a numeric vector with length 1 or a matrix of
(<code>m</code> by <code>m</code> - 1) elements denoting the amount of variance
between subjects in the transition probability matrix. Note that the
value(s) correspond to the variance of the parameters of the Multinomial
distribution (i.e., the intercepts of the regression equation of the
Multinomial distribution used to sample the transition probability
matrix), see details below. Also note that if only one variance value is
provided, it will be adopted for the complete transition probability
matrix, hence the variance is assumed fixed across all components. The
default equals 0.1, which corresponds to little variation between
subjects. If one wants to simulate data from exactly the same HMM for all
subjects, var_gamma should be set to 0. Note that if data for only 1
subject is simulated (i.e., n = 1), <code>var_gamma</code> is set to 0.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_var_emiss">var_emiss</code></td>
<td>
<p>Either a numeric vector with length <code>n_dep</code> or a
list of <code>n_dep</code> matrices denoting the amount of variance between
subjects in the emission distribution(s). When opting for a list of
matrices: if <code>data_distr = 'categorical'</code>, each element of the list
is a matrix with <code>m</code> rows and <code>q_emiss[k] - 1</code> columns for each
of the <code>k</code> in <code>n_dep</code> emission distribution(s) between subject
variances; if <code>data_distr = 'continuous'</code>, each element is a matrix
with <code>m</code> rows and 1 column; the single column denoting the variance
between the subjects' means of state <em>i</em> (row <em>i</em>) of the normal
distribution used as prior for the Normal emissions. If <code>data_distr =
  'count'</code>, each element is a matrix with <code>m</code> rows and 1 column; the
single column denoting the logvariance between the subjects' logmeans of
state <em>i</em> (row <em>i</em>) of the lognormal distribution used as prior
for the Poisson emissions (note: by default the logvariances should be
specified in the natural scale; see argument <code>log_scale</code> below).
</p>
<p>For categorical data, this value corresponds to the variance of the
parameters of the Multinomial distribution (i.e., the intercepts of the
regression equation of the Multinomial distribution used to sample the
components of the emission distribution), see details below. For
continuous data, this value corresponds to the variance in the mean of the
emission distribution(s) across subjects. For count data, it corresponds
to the variance in the logmean of the emission distribution(s) across
subjects and by should be specified in the natural scale (see argument
<code>log_scale</code> below). Note that if only one variance value provided for
each emission distribution, the variance is assumed fixed across states
(and, for the categorical distribution, categories within a state) within
an emission distribution. The default equals 0.1, which corresponds to
little variation between subjects given categorical observations. If one
wants to simulate data from exactly the same HMM for all subjects,
var_emiss should be set to a vector of 0's. Note that if data for only 1
subject is simulated (i.e., n = 1), <code>var_emiss</code> is set to a vector
of 0's.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_return_ind_par">return_ind_par</code></td>
<td>
<p>A logical scalar. Should the subject specific
transition probability matrix <code>gamma</code> and emission probability matrix
<code>emiss_distr</code> be returned by the function (<code>return_ind_par =
TRUE</code>) or not (<code>return_ind_par = FALSE</code>). The default equals
<code>return_ind_par = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_m">m</code></td>
<td>
<p>The argument <code>m</code> is deprecated; please specify using the input
parameter <code>gen</code>.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_n_dep">n_dep</code></td>
<td>
<p>The argument <code>n_dep</code> is deprecated; please specify using
the input parameter <code>gen</code>.</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_q_emiss">q_emiss</code></td>
<td>
<p>The argument <code>q_emiss</code> is deprecated; please specify
using the input parameter <code>gen</code> (only to be specified when simulating
categorical data).</p>
</td></tr>
<tr><td><code id="sim_mHMM_+3A_log_scale">log_scale</code></td>
<td>
<p>A logical scalar. If <code>data_distr = 'count'</code>, should
<code>emiss_distr</code> (i.e., the sample average logmeans) and
<code>var_emiss</code> (i.e., the between subject logvariances) of the lognormal
prior adopted for the count be specified in the logarithmic scale
(<code>log_scale = TRUE</code>) or the natural (i.e., real positive numbers)
scale (<code>log_scale = FALSE</code>). The default equals
<code>log_scale = FALSE</code>. Note that if covariates <code>beta</code> are used to
predict the count emission distribution, then the logarithmic scale should
be used for the inputs <code>emiss_distr</code>, <code>beta</code>, and
<code>var_emiss</code>, and also set <code>log_scale = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simulating the data, having a multilevel structure means that the
parameters for each subject are sampled from the population level
distribution of the corresponding parameter. The user specifies the
population distribution for each parameter: the average population transition
probability matrix and its variance, and the average population emission
distribution and its variance. For now, the variance of the mean population
parameters is assumed fixed for all components of the transition probability
matrix and for all components of the emission distribution.
</p>
<p>One can simulate multivariate data. That is, the hidden states depend on more
than 1 observed variable simultaneously. The distributions of multiple
dependent variables for multivariate data are assumed to be independent, and
all distributions for one dataset have to be of the same type (either
categorical or continuous).
</p>
<p>Note that the subject specific initial state distributions (i.e., the
probability of each of the states at the first time point) needed to simulate
the data are obtained from the stationary distributions of the subject
specific transition probability matrices gamma.
</p>
<p><code>beta</code>: As the first element in each row of <code>gamma</code> is used as
reference category in the Multinomial logistic regression, the first matrix
in the list <code>beta</code> used to predict transition probability matrix
<code>gamma</code> has a number of rows equal to <code>m</code> and the number of columns
equal to <code>m</code> - 1. The first element in the first row corresponds to the
probability of switching from state one to state two. The second element in
the first row corresponds to the probability of switching from state one to
state three, and so on. The last element in the first row corresponds to the
probability of switching from state one to the last state. The same principle
holds for the second matrix in the list <code>beta</code> used to predict
categorical emission distribution(s) <code>emiss_distr</code>: the first element in
the first row corresponds to the probability of observing category two in
state one. The second element in the first row corresponds to the probability
of observing category three is state one, and so on. The last element in the
first row corresponds to the probability of observing the last category in
state one.
</p>
<p>Note that when simulating count data (<code>data_distr = 'count'</code>), by
default the emission distribution parameters <code>emiss_distr</code> and
<code>var_emiss</code> are specified in the natural (positive real numbers) scale
(as opposite to the logarithmic scale). If the user wants to manually
specify these values on the logarithmic scale, please set the argument
<code>log_scale = TRUE</code>. Also note that if covariates are used to predict a
count emission distribution, then the logarithmic scale should be used for
the inputs <code>emiss_distr</code>, <code>beta</code>, and <code>var_emiss</code>, and also
set <code>log_scale = TRUE</code>.
</p>


<h3>Value</h3>

<p>The following components are returned by the function <code>sim_mHMM</code>:
</p>

<dl>
<dt><code>states</code></dt><dd><p>A matrix containing the simulated hidden state
sequences, with one row per hidden state per subject. The first column
indicates subject id number. The second column contains the simulated
hidden state sequence, consecutively for all subjects. Hence, the id number
is repeated over the rows (with the number of repeats equal to the length
of the simulated hidden state sequence <code>T</code> for each subject).</p>
</dd>
<dt><code>obs</code></dt><dd><p>A matrix containing the simulated observed outputs, with
one row per simulated observation per subject. The first column indicates
subject id number. The second column contains the simulated observation
sequence, consecutively for all subjects. Hence, the id number is repeated
over rows (with the number of repeats equal to the length of the simulated
observation sequence <code>T</code> for each subject).</p>
</dd>
<dt><code>gamma</code></dt><dd><p>A list containing <code>n</code> elements with the simulated
subject specific transition probability matrices <code>gamma</code>. Only
returned if <code>return_ind_par</code> is set to <code>TRUE</code>.</p>
</dd>
<dt><code>emiss_distr</code></dt><dd><p>A list containing <code>n</code> elements with the
simulated subject specific emission probability matrices
<code>emiss_distr</code>. Only returned if <code>return_ind_par</code> is set to
<code>TRUE</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for analyzing multilevel hidden Markov data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Examples on univariate categorical data
# simulating data for 10 subjects with each 100 categorical observations
n_t     &lt;- 100
n       &lt;- 10
m       &lt;- 3
n_dep   &lt;- 1
q_emiss &lt;- 4
gamma   &lt;- matrix(c(0.8, 0.1, 0.1,
                    0.2, 0.7, 0.1,
                    0.2, 0.2, 0.6), ncol = m, byrow = TRUE)
emiss_distr &lt;- list(matrix(c(0.5, 0.5, 0.0, 0.0,
                             0.1, 0.1, 0.8, 0.0,
                             0.0, 0.0, 0.1, 0.9), nrow = m, ncol = q_emiss, byrow = TRUE))
data1 &lt;- sim_mHMM(n_t = n_t, n = n, gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  gamma = gamma, emiss_distr = emiss_distr, var_gamma = 1, var_emiss = 1)
head(data1$obs)
head(data1$states)

# including a covariate to predict (only) the transition probability matrix gamma
beta      &lt;- rep(list(NULL), 2)
beta[[1]] &lt;- matrix(c(0.5, 1.0,
                     -0.5, 0.5,
                      0.0, 1.0), byrow = TRUE, ncol = 2)
xx_vec      &lt;- rep(list(NULL),2)
xx_vec[[1]] &lt;-  c(rep(0,5), rep(1,5))
data2 &lt;- sim_mHMM(n_t = n_t, n = n, gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  gamma = gamma, emiss_distr = emiss_distr, beta = beta, xx_vec = xx_vec,
                  var_gamma = 1, var_emiss = 1)


# simulating subject specific transition probability matrices and emission distributions only
n_t &lt;- 0
n &lt;- 5
m &lt;- 3
n_dep   &lt;- 1
q_emiss &lt;- 4
gamma &lt;- matrix(c(0.8, 0.1, 0.1,
                  0.2, 0.7, 0.1,
                  0.2, 0.2, 0.6), ncol = m, byrow = TRUE)
emiss_distr &lt;- list(matrix(c(0.5, 0.5, 0.0, 0.0,
                             0.1, 0.1, 0.8, 0.0,
                             0.0, 0.0, 0.1, 0.9), nrow = m, ncol = q_emiss, byrow = TRUE))
data3 &lt;- sim_mHMM(n_t = n_t, n = n, gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  gamma = gamma, emiss_distr = emiss_distr, var_gamma = 1, var_emiss = 1)
data3

data4 &lt;- sim_mHMM(n_t = n_t, n = n, gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  gamma = gamma, emiss_distr = emiss_distr, var_gamma = .5, var_emiss = .5)
data4


## Example on multivariate continuous data
# simulating multivariate continuous data
n_t     &lt;- 100
n       &lt;- 10
m       &lt;- 3
n_dep   &lt;- 2

gamma   &lt;- matrix(c(0.8, 0.1, 0.1,
                    0.2, 0.7, 0.1,
                    0.2, 0.2, 0.6), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c( 50, 10,
                              100, 10,
                              150, 10), nrow = m, byrow = TRUE),
                    matrix(c(5, 2,
                             10, 5,
                             20, 3), nrow = m, byrow = TRUE))

data_cont &lt;- sim_mHMM(n_t = n_t, n = n, data_distr = 'continuous',
                      gen = list(m = m, n_dep = n_dep),
                      gamma = gamma, emiss_distr = emiss_distr,
                      var_gamma = .5, var_emiss = c(5^2, 0.2^2))

head(data_cont$states)
head(data_cont$obs)


## Example on multivariate count data without covariates
n_t     &lt;- 200     # Number of observations on the dependent variable
m       &lt;- 3        # Number of hidden states
n_dep   &lt;- 2        # Number of dependent variables
n_subj  &lt;- 30        # Number of subjects

gamma   &lt;- matrix(c(0.9, 0.05, 0.05,
                    0.2, 0.7, 0.1,
                    0.2,0.3, 0.5), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c(20,
                             10,
                             5), nrow = m, byrow = TRUE),
                    matrix(c(50,
                             3,
                             20), nrow = m, byrow = TRUE))

# Define between subject variance to use on the simulating function:
# here, the variance is varied over states within the dependent variable.
var_emiss &lt;- list(matrix(c(5.0, 3.0, 1.5), nrow = m),
                  matrix(c(5.0, 5.0, 5.0), nrow = m))

# Simulate count data:
data_count &lt;- sim_mHMM(n_t = n_t,
                       n = n_subj,
                       data_distr = "count",
                       gen = list(m = m, n_dep = n_dep),
                       gamma = gamma,
                       emiss_distr = emiss_distr,
                       var_gamma = 0.1,
                       var_emiss = var_emiss,
                       return_ind_par = TRUE)


## Example on multivariate count data with covariates
# Simulate data with one covariate for each count dependent variable

n_t     &lt;- 200     # Number of observations on the dependent variable
m       &lt;- 3        # Number of hidden states
n_dep   &lt;- 3        # Number of dependent variables
n_subj  &lt;- 30        # Number of subjects

gamma   &lt;- matrix(c(0.9, 0.05, 0.05,
                    0.2, 0.7, 0.1,
                    0.2,0.3, 0.5), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c(20,
                             10,
                             5), nrow = m, byrow = TRUE),
                    matrix(c(15,
                             2,
                             5), nrow = m, byrow = TRUE),
                    matrix(c(50,
                             3,
                             20), nrow = m, byrow = TRUE))

# Since we have covariates, we specify inputs in the log scale:
emiss_distr_log &lt;- lapply(emiss_distr, function(e) log(e))

# Define list of vectors of covariate values
set.seed(42)
xx_vec &lt;- c(list(NULL),rep(list(rnorm(n_subj,mean = 0, sd = 0.1)),3))

# Define object beta with regression coefficients for the three dependent variables
beta      &lt;- rep(list(NULL), n_dep+1)
beta[[2]] &lt;- matrix(c(1,-1,0), byrow = TRUE, ncol = 1)
beta[[3]] &lt;- matrix(c(2,0,-2), byrow = TRUE, ncol = 1)
beta[[4]] &lt;- matrix(c(-1,3,1), byrow = TRUE, ncol = 1)

# Calculate logvar to use on the simulating function:
logvar &lt;- var_to_logvar(gen = list(m = m, n_dep = n_dep),
                        emiss_mu = emiss_distr,
                        var_emiss =  list(rep(4, m),
                                          rep(2, m),
                                          rep(5, m)),
                        byrow = FALSE)

# Put logvar in the right format:
logvar &lt;- lapply(logvar, function(q) matrix(q, nrow = m))

# Simulate count data:
data_count &lt;- sim_mHMM(n_t = n_t,
                       n = n_subj,
                       data_distr = "count",
                       gen = list(m = m, n_dep = n_dep),
                       gamma = gamma,
                       emiss_distr = emiss_distr_log,
                       xx_vec = xx_vec,
                       beta = beta,
                       var_gamma = 0.1,
                       var_emiss = logvar,
                       return_ind_par = TRUE,
                       log_scale = TRUE)

head(data_count$states)
head(data_count$obs)
</code></pre>

<hr>
<h2 id='var_to_logvar'>Transform the between-subject variance in the positive scale to the
logvariance in the logarithmic scale</h2><span id='topic+var_to_logvar'></span>

<h3>Description</h3>

<p><code>var_to_logvar</code> returns the desired between-subject logvariance in the
logarithmic scale corresponding to the between-subject variance in the
(real) positive scale specified as input. The logvariance is used as the
dispersion parameter in the lognormal distribution adopted as prior for
the subject-specific Poisson means in the implementation of <code>mHMM</code>
and <code><a href="#topic+sim_mHMM">sim_mHMM</a></code> of <code><a href="#topic+mHMMbayes">mHMMbayes</a></code> for count
distributed data. It takes as inputs the group-level Poisson means
<code>emiss_mu</code> and the desired between-subject variance <code>var_emiss</code>,
both in the (real) positive scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_to_logvar(gen, emiss_mu, var_emiss, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_to_logvar_+3A_gen">gen</code></td>
<td>
<p>List containing the following elements denoting the general model
properties:
</p>

<ul>
<li><p><code>m</code>: numeric vector with length 1 denoting the number
of hidden states
</p>
</li>
<li><p><code>n_dep</code>: numeric vector with length 1 denoting the
number of dependent variables</p>
</li></ul>
</td></tr>
<tr><td><code id="var_to_logvar_+3A_emiss_mu">emiss_mu</code></td>
<td>
<p>A list containing <code>n_dep</code> matrices, i.e., one list for
each dependent variable <code>k</code>. Each matrix contains the group-level
means of the lognormal emission distributions in each of the
states in the natural (positive real numbers) scale. Hence, each
matrix consists of either 1 row (when not including covariates in the
model) and <code>m</code> columns (see <code>emiss_mu0</code> in
<code><a href="#topic+prior_emiss_count">prior_emiss_count</a></code>), or <code>m</code> rows and 1 column
(when not including covariates in the model; see <code>emiss_distr</code> in
<code><a href="#topic+sim_mHMM">sim_mHMM</a></code>), denoting the mean of state
<em>i</em> (column or row <em>i</em>) of the lognormal distribution used as
prior for the Poisson emissions. By default it is assumed that the
matrices contain 1 row and <code>m</code> columns, as specified for
<code>emiss_mu0</code> in <code><a href="#topic+prior_emiss_count">prior_emiss_count</a></code> (see argument
<code>byrow</code>). If <code>emiss_mu</code> were to be specified using <code>m</code> rows
and 1 column as for <code>emiss_distr</code> in <code><a href="#topic+sim_mHMM">sim_mHMM</a></code>, then set
the argument <code>byrow = FALSE</code>.
</p>
<p>Note: in every case the means should be specified in the natural
(real positive) scale.</p>
</td></tr>
<tr><td><code id="var_to_logvar_+3A_var_emiss">var_emiss</code></td>
<td>
<p>A list containing <code>n_dep</code> elements corresponding to
each of the dependent variables <code>k</code>, where each element <code>k</code> is a
vector with length <code>m</code> denoting the amount of variance between the
subject (emission distribution) means in the natural (positive real
numbers) scale. It follows a similar specification as <code>emiss_V</code> in
<code><a href="#topic+prior_emiss_count">prior_emiss_count</a></code>.</p>
</td></tr>
<tr><td><code id="var_to_logvar_+3A_byrow">byrow</code></td>
<td>
<p>A logical scalar indicating whether the emission means are
specified in the first row (<code>byrow = TRUE</code>) or the first column
(<code>byrow = FALSE</code>) of the <code>n_dep</code> matrices listed in
<code>emiss_mu</code>. Use <code>byrow = TRUE</code> if <code>emiss_mu</code> is entered
as <code>emiss_mu0</code> in <code><a href="#topic+prior_emiss_count">prior_emiss_count</a></code>, and
<code>byrow = FALSE</code> if <code>emiss_mu</code> is entered as <code>emiss_distr</code>
in <code><a href="#topic+sim_mHMM">sim_mHMM</a></code>. By default, <code>byrow = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>var_to_logvar</code> Returns a list of <code>n_dep</code> numeric vectors
of <code>m</code> elements denoting the state <code>i</code>-specific logvariance
(between-subject variance in the logarithmic scale) for the
<code>k</code>-dependent variable used as dispersion parameter in the lognormal
prior for the Poisson emission distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for fitting the multilevel hidden Markov model,
and <code><a href="#topic+sim_mHMM">sim_mHMM</a></code> for simulating data from a multilevel hidden
Markov model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example on package data


## Example: specifying count priors manually using both positive and log scale:

# Define general parameters:
m       &lt;- 3        # Number of hidden states
n_dep   &lt;- 2        # Number of dependent variables

# Specify priors manually on the positive scale for emuss_mu0 and emiss_V:
manual_prior_emiss_1 &lt;- prior_emiss_count(
  gen = list(m = m, n_dep = n_dep),
  emiss_mu0 = list(matrix(c(30, 70, 170), nrow = 1),
                   matrix(c(7, 8, 18), nrow = 1)),
  emiss_K0 = list(1, 1),
  emiss_V =  list(c(16,25,32),
                  rep(4, m)),
  emiss_nu = list(0.1, 0.1),
  log_scale = FALSE)

# Define logmu and logvar:
logmu &lt;-  list(matrix(log(c(30, 70, 170)), nrow = 1),
               matrix(log(c(7, 8, 18)), nrow = 1))

logvar &lt;- var_to_logvar(gen = list(m = m, n_dep = n_dep),
                        emiss_mu = list(matrix(c(30, 70, 170), nrow = 1),
                                        matrix(c(7, 8, 18), nrow = 1)),
                        var_emiss = list(c(16,25,32),
                                         rep(4, m)),
                        byrow = TRUE)

# Specify priors manually on the log scale for emiss_mu0 and emiss_V:
manual_prior_emiss_2 &lt;- prior_emiss_count(
  gen = list(m = m, n_dep = n_dep),
  emiss_mu0 = logmu,
  emiss_K0 = list(1, 1),
  emiss_V =  logvar,
  emiss_nu = list(0.1, 0.1),
  log_scale = TRUE)

# Check whether they are identical:
identical(manual_prior_emiss_1, manual_prior_emiss_2)



</code></pre>

<hr>
<h2 id='vit_mHMM'>Obtain hidden state sequence for each subject using the Viterbi
algorithm</h2><span id='topic+vit_mHMM'></span>

<h3>Description</h3>

<p><code>vit_mHMM</code> obtains the most likely state sequence (for each subject)
from an object of class <code>mHMM</code> (generated by the function
<code>mHMM()</code>), using (an extended version of) the Viterbi algorithm. This is
also known as global decoding. Optionally, the state probabilities
themselves at each point in time can also be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vit_mHMM(object, s_data, burn_in = NULL, return_state_prob = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vit_mHMM_+3A_object">object</code></td>
<td>
<p>An object of class <code>mHMM</code>, generated
by the function <code><a href="#topic+mHMM">mHMM</a></code>.</p>
</td></tr>
<tr><td><code id="vit_mHMM_+3A_s_data">s_data</code></td>
<td>
<p>A matrix containing the observations to be modeled, where the
rows represent the observations over time. In <code>s_data</code>, the first
column indicates subject id number. Hence, the id number is repeated over
rows equal to the number of observations for that subject. The subsequent
columns contain the dependent variable(s). Note that in case of categorical
dependent  variable(s), input are integers (i.e., whole numbers) that range
from 1 to <code>q_emiss</code> (see below) and is numeric (i.e., not be a (set
of) factor variable(s)). The total number of rows are equal to the sum over
the number of observations of each subject, and the number of columns are
equal to the number of dependent variables (<code>n_dep</code>) + 1. The number
of observations can vary over subjects.</p>
</td></tr>
<tr><td><code id="vit_mHMM_+3A_burn_in">burn_in</code></td>
<td>
<p>The number of iterations to be discarded from the MCMC
algorithm when inferring the transition probability matrix gamma and the
emission distribution of (each of) the dependent variable(s) for each
subject from <code>s_data</code>. If omitted, defaults to <code>NULL</code> and
<code>burn_in</code> specified at the function <code>mHMM</code> will be used.</p>
</td></tr>
<tr><td><code id="vit_mHMM_+3A_return_state_prob">return_state_prob</code></td>
<td>
<p>A logical scaler. Should the function, in addition
to the most likely state sequence for each subject, also return the state
probabilities at each point in time for each subject
(<code>return_state_prob = TRUE</code>) or not (<code>return_state_prob =
FALSE</code>). Defaults to <code>return_state_prob = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that local decoding is also possible, by inferring the most frequent
state at each point in time for each subject from the sampled state path at
each iteration of the MCMC algorithm. This information is contained in the
output object <code>return_path</code> of the function <code>mHMM()</code>.
</p>


<h3>Value</h3>

<p>The function <code>vit_mHMM</code> returns a matrix containing the most
likely state at each point in time. The first column indicates subject id
number. Hence, the id number is repeated over rows equal to the number of
observations for that subject. The second column contains the most likely
state at each point in time. If requested, the subsequent columns contain
the state probabilities at each point in time for each subject.
</p>


<h3>References</h3>

<p>Viterbi A (1967).
&ldquo;Error bounds for convolutional codes and an asymptotically optimum decoding algorithm.&rdquo;
<em>IEEE transactions on Information Theory</em>, <b>13</b>(2), 260&ndash;269.
</p>
<p>Rabiner LR (1989).
&ldquo;A tutorial on hidden Markov models and selected applications in speech recognition.&rdquo;
<em>Proceedings of the IEEE</em>, <b>77</b>(2), 257&ndash;286.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mHMM">mHMM</a></code> for analyzing multilevel hidden Markov data
and obtaining the input needed for <code>vit_mHMM</code>, and
<code><a href="#topic+sim_mHMM">sim_mHMM</a></code> for simulating multilevel hidden Markov data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Example on package example categorical data, see ?nonverbal
# First fit the multilevel HMM on the example data

# specifying general model properties:
m &lt;- 2
n_dep &lt;- 4
q_emiss &lt;- c(3, 2, 3, 2)

# specifying starting values
start_TM &lt;- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] &lt;- .2
start_EM &lt;- list(matrix(c(0.05, 0.90, 0.05, 0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9, 0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05, 0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9, 0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Fit the multilevel HMM model:
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_2st &lt;- mHMM(s_data = nonverbal, gen = list(m = m, n_dep = n_dep,
                q_emiss = q_emiss), start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 3, burn_in = 1))

###### obtain the most likely state sequence with the Viterbi algorithm
states1 &lt;- vit_mHMM(s_data = nonverbal, object = out_2st)


###### Example on simulated multivariate continuous data
# simulating multivariate continuous data
n_t     &lt;- 100
n       &lt;- 10
m       &lt;- 3
n_dep   &lt;- 2

gamma   &lt;- matrix(c(0.8, 0.1, 0.1,
                    0.2, 0.7, 0.1,
                    0.2, 0.2, 0.6), ncol = m, byrow = TRUE)

emiss_distr &lt;- list(matrix(c( 50, 10,
                              100, 10,
                              150, 10), nrow = m, byrow = TRUE),
                    matrix(c(5, 2,
                             10, 5,
                             20, 3), nrow = m, byrow = TRUE))

data_cont &lt;- sim_mHMM(n_t = n_t, n = n, data_distr = 'continuous',
                      gen = list(m = m, n_dep = n_dep), gamma = gamma,
                      emiss_distr = emiss_distr, var_gamma = .1,
                      var_emiss = c(5^2, 0.2^2))

# Specify hyper-prior for the continuous emission distribution
manual_prior_emiss &lt;- prior_emiss_cont(
                        gen = list(m = m, n_dep = n_dep),
                        emiss_mu0 = list(matrix(c(30, 70, 170), nrow = 1),
                                         matrix(c(7, 8, 18), nrow = 1)),
                        emiss_K0 = list(1, 1),
                        emiss_V =  list(rep(5^2, m), rep(0.5^2, m)),
                        emiss_nu = list(1, 1),
                        emiss_a0 = list(rep(1.5, m), rep(1, m)),
                        emiss_b0 = list(rep(20, m), rep(4, m)))

# Run the model on the simulated data:
# Note that for reasons of running time, J is set at a ridiculous low value.
# One would typically use a number of iterations J of at least 1000,
# and a burn_in of 200.
out_3st_cont_sim &lt;- mHMM(s_data = data_cont$obs,
                    data_distr = "continuous",
                    gen = list(m = m, n_dep = n_dep),
                    start_val = c(list(gamma), emiss_distr),
                    emiss_hyp_prior = manual_prior_emiss,
                    mcmc = list(J = 11, burn_in = 5))

###### obtain the most likely state sequence with the Viterbi algorithm,
# including state probabilities at each time point.
states2 &lt;- vit_mHMM(s_data = data_cont$obs, object = out_3st_cont_sim,
                    return_state_prob = TRUE)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
