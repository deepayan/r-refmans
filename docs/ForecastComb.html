<!DOCTYPE html><html lang="en"><head><title>Help for package ForecastComb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ForecastComb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auto_combine'><p>Automated Forecast Combination</p></a></li>
<li><a href='#comb_BG'><p>Bates/Granger (1969) Forecast Combination Approach</p></a></li>
<li><a href='#comb_CLS'><p>Constrained Least Squares Forecast Combination</p></a></li>
<li><a href='#comb_CSR'><p>All Possible Combinations Forecast Averaging</p></a></li>
<li><a href='#comb_EIG1'><p>Standard Eigenvector Forecast Combination</p></a></li>
<li><a href='#comb_EIG2'><p>Bias-Corrected Eigenvector Forecast Combination</p></a></li>
<li><a href='#comb_EIG3'><p>Trimmed Eigenvector Forecast Combination</p></a></li>
<li><a href='#comb_EIG4'><p>Trimmed Bias-Corrected Eigenvector Forecast Combination</p></a></li>
<li><a href='#comb_InvW'><p>Inverse Rank Forecast Combination</p></a></li>
<li><a href='#comb_LAD'><p>Least Absolute Deviation Forecast Combination</p></a></li>
<li><a href='#comb_MED'><p>Median Forecast Combination</p></a></li>
<li><a href='#comb_NG'><p>Newbold/Granger (1974) Forecast Combination</p></a></li>
<li><a href='#comb_OLS'><p>Ordinary Least Squares Forecast Combination</p></a></li>
<li><a href='#comb_SA'><p>Simple Average Forecast Combination</p></a></li>
<li><a href='#comb_TA'><p>Trimmed Mean Forecast Combination</p></a></li>
<li><a href='#comb_WA'><p>Winsorized Mean Forecast Combination</p></a></li>
<li><a href='#cs_dispersion'><p>Compute Cross-Sectional Dispersion</p></a></li>
<li><a href='#electricity'><p>UK Electricity Supply 2007 - 2017</p></a></li>
<li><a href='#foreccomb'><p>Format Raw Data for Forecast Combination</p></a></li>
<li><a href='#foreccomb_res'><p>Result Rbject for the Forecast Combination Methods</p></a></li>
<li><a href='#plot.foreccomb_res'><p>Plot results from forecast combination model</p></a></li>
<li><a href='#predict.foreccomb_res'><p>Prediction function for Forecast Combinations</p></a></li>
<li><a href='#rolling_combine'><p>Dynamic Forecast Combination</p></a></li>
<li><a href='#summary.foreccomb_res'><p>Summary of Forecast Combination</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecast Combination Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>forecast (&ge; 7.3), ggplot2 (&ge; 2.1.0), Matrix (&ge; 1.2-6),
mtsdi (&ge; 0.3.3), psych (&ge; 1.6.9), quadprog (&ge; 1.5-5),
quantreg (&ge; 5.29)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.2)</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph E. Weiss, Gernot R. Roetzer, Eran Raviv </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christoph E. Weiss &lt;info@ceweiss.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides geometric- and regression-based forecast
    combination methods under a unified user interface for the packages 'ForecastCombinations'
    and 'GeomComb'. Additionally, updated tools and convenience functions for data pre-processing are available in order to deal with 
    common problems in forecast combination (missingness, collinearity). For method details see Hsiao C, Wan SK (2014). &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2013.11.003">doi:10.1016/j.jeconom.2013.11.003</a>&gt;, Hansen BE (2007). &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2007.00785.x">doi:10.1111/j.1468-0262.2007.00785.x</a>&gt;,
    Elliott G, Gargano A, Timmermann A (2013). &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2013.04.017">doi:10.1016/j.jeconom.2013.04.017</a>&gt;, 
    and Clemen RT (1989). &lt;<a href="https://doi.org/10.1016%2F0169-2070%2889%2990012-5">doi:10.1016/0169-2070(89)90012-5</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ceweiss/ForecastComb">https://github.com/ceweiss/ForecastComb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ceweiss/ForecastComb/issues">https://github.com/ceweiss/ForecastComb/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-06 20:43:31 UTC; gernot</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-07 13:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='auto_combine'>Automated Forecast Combination</h2><span id='topic+auto_combine'></span>

<h3>Description</h3>

<p>Computes the fit for all the available forecast combination methods on the provided dataset with respect to the loss criterion.
Returns the best fit method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_combine(x, criterion = "RMSE", param_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_combine_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="auto_combine_+3A_criterion">criterion</code></td>
<td>
<p>Specifies loss criterion. Set criterion to either 'RMSE' (default), 'MAE', or 'MAPE'.</p>
</td></tr>
<tr><td><code id="auto_combine_+3A_param_list">param_list</code></td>
<td>
<p>Can contain additional parameters for the different combination methods (see example below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>auto_combine</code> allows to quickly apply all the different forecast combination methods onto the provided time series
data and selects the method with the best fit.
</p>
<p>The user can choose from 3 different loss criteria for the best-fit evaluation:
root mean square error (<code>criterion='RMSE'</code>), mean absolute error (<code>criterion='MAE'</code>), and
mean absolute percentage error (<code>criterion='MAPE'</code>).
</p>
<p>In case the user does not want to optimize over the parameters of some of the combination methods,
<code>auto_combine</code> allows to specify the parameter values for these methods explicitly (see Examples).
</p>
<p>The best-fit results are stored in an object of class 'foreccomb_res', for which separate plot and summary functions are provided.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> that represents the results for the best-fit forecast combination method:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the best-fit forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the best-fit combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)

# Evaluating all the forecast combination methods and returning the best.
# If necessary, it uses the built-in automated parameter optimisation methods
# for the different methods.
best_combination&lt;-auto_combine(data, criterion = "MAPE")

# Same as above, but now we restrict the parameter ntop_pred for the method comb_EIG3 to be 3.
param_list&lt;-list()
param_list$comb_EIG3$ntop_pred&lt;-3
best_combination_restricted&lt;-auto_combine(data, criterion = "MAPE", param_list = param_list)

</code></pre>

<hr>
<h2 id='comb_BG'>Bates/Granger (1969) Forecast Combination Approach</h2><span id='topic+comb_BG'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the approach by Bates and Granger (1969) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_BG(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_BG_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In their seminal paper, Bates and Granger (1969) introduce the idea of combining forecasts. Their approach builds on portfolio diversification theory and uses the diagonal
elements of the estimated mean squared prediction error matrix in order to compute combination weights:
</p>
<p style="text-align: center;"><code class="reqn">w_i^{BG} = \frac{\hat{\sigma}^{-2} (i)}{\Sigma_{j=1}^N  \hat{\sigma}^{-2} (j)}</code>
</p>

<p>where <code class="reqn">\hat{\sigma}^{-2} (i)</code> is the estimated mean squared prediction error of the i-th model.
</p>
<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {\mathbf{f}_{t}}'\mathbf{w}^{BG}</code>
</p>

<p>Their approach ignores correlation between forecast models due to difficulties in precisely estimating the covariance matrix.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Bates, J. M., and Granger, C. W. (1969). The Combination of Forecasts. <em>Journal of the Operational Research Society</em>, <b>20(4)</b>, 451&ndash;468.
</p>
<p>Timmermann, A. (2006). Forecast Combinations. In: Elliott, G., Granger, C. W. J., and Timmermann, A. (Eds.), <em>Handbook of Economic Forecasting</em>,
<b>1</b>, 135&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_BG(data)

</code></pre>

<hr>
<h2 id='comb_CLS'>Constrained Least Squares Forecast Combination</h2><span id='topic+comb_CLS'></span>

<h3>Description</h3>

<p>Computes forecast combination weights using constrained least squares (CLS) regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_CLS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_CLS_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function integrates the constrained least squares (CLS) forecast combination implementation of the
<em>ForecastCombinations</em> package into ForecastComb. The implementation has improved robustness regarding multicollinearity.
</p>
<p>Compared to the <code><a href="#topic+comb_OLS">ordinary least squares forecast combination</a></code> method, CLS forecast combination has the additional
requirement that the weights, <code class="reqn">\mathbf{w}^{CLS} = (w_1, \ldots, w_N)'</code>, sum up to 1 and that there is no intercept. That is,
the combinations of <code>comb_CLS</code> are affine combinations.
</p>
<p>This method was first introduced by Granger and Ramanathan (1984). The general appeal of the method is its ease of interpretation (the
weights can be interpreted as percentages) and often produces better forecasts than the OLS method when the individual forecasts are
highly correlated. A disadvantage is that if one or more individual forecasts are biased, this bias is not corrected through the
forecast combination due to the lack of an intercept.
</p>
<p>In addition to the version presented by Granger and Ramanathan (1984), this variant of the method adds the restriction that combination
weights must be non-negative, which has been found to be almost always outperform unconstrained OLS by Aksu and Gunter (1992) and
was combined with the condition of forcing the weights to sum up to one by Nowotarski et al. (2014), who conclude that even though the
method provides a suboptimal solution in-sample, it almost always produces better
forecasts than unrestricted OLS out-of-sample.
</p>
<p>The results are stored in an object of class 'foreccomb_res', for which separate plot and summary functions are provided.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the best-fit forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Aksu, C., and Gunter, S. I. (1992). An Empirical Analysis of the Accuracy of SA, OLS,
ERLS and NRLS Combination Forecasts. <em>International Journal of Forecasting</em>, <b>8(1)</b>, 27&ndash;43.
</p>
<p>Granger, C., and Ramanathan, R. (1984). Improved Methods Of Combining Forecasts. <em>Journal of Forecasting</em>, <b>3(2)</b>, 197&ndash;204.
</p>
<p>Nowotarski, J., Raviv, E., Tr\&quot;uck, S., and Weron, R. (2014). An Empirical Comparison of Alternative
Schemes for Combining Electricity Spot Price Forecasts. <em>Energy Economics</em>, <b>46</b>, 395&ndash;412.
</p>


<h3>See Also</h3>

<p><code><a href="ForecastCombinations.html#topic+Forecast_comb">Forecast_comb</a></code>,
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_CLS(data)

</code></pre>

<hr>
<h2 id='comb_CSR'>All Possible Combinations Forecast Averaging</h2><span id='topic+comb_CSR'></span>

<h3>Description</h3>

<p>Combine different forecasts using complete subset regressions. Apart from the simple averaging, weights based on information criteria (AIC, corrected AIC, Hannan Quinn and BIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_CSR(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_CSR_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OLS forecast combination is based on </p>
<p style="text-align: center;"><code class="reqn"> obs_t = const + \sum_{i = 1}^p w_{i} \widehat{obs}_{it} + e_t, </code>
</p>
<p> where <code class="reqn">obs</code> is the observed values and <code class="reqn">\widehat{obs}</code> is the forecast, one out of the <code class="reqn">p</code> forecasts available.
</p>
<p>The function computes the complete subset regressions. So a matrix of forecasts based on all possible subsets of <code>fhat</code> is returned.
</p>
<p>Those forecasts can later be cross-sectionally averaged (averaged over rows) to create a single combined forecast using weights which are based on the information criteria of the different individual regression, rather than a simple average.
</p>
<p>Additional weight-vectors which are based on different information criteria are also returned. This is in case the user would like to perform the frequensit version of forecast averaging (see references for more details).
</p>
<p>Although the function is geared towards forecast averaging, it can be used in any other application as a generic complete subset regression.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights based on the different information criteria.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values for each information criterion.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eran Raviv  and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Hansen, B. (2008). Least-squares forecast averaging <em>Journal of Econometrics</em>, <b>146(2)</b>, 342&ndash;350.
</p>
<p>Kapetanios, G., Labhard V., Price, S. (2008). Forecasting Using Bayesian and Information-Theoretic Model Averaging.
<em>Journal of Business &amp; Economic Statistics</em>, <b>26(1)</b>.
</p>
<p>Koenker R. (2005). <em>Quantile Regression. Cambridge University Press</em>.
</p>
<p>Graham, E., Garganob, A., Timmermann, A. (2013). Complete subset regressions. 
<em>Journal of Econometrics</em>, <b>177(2)</b>, 357&ndash;373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="#topic+comb_NG">comb_NG</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_CSR(data)

</code></pre>

<hr>
<h2 id='comb_EIG1'>Standard Eigenvector Forecast Combination</h2><span id='topic+comb_EIG1'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the standard eigenvector approach by Hsiao and Wan (2014) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_EIG1(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_EIG1_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard eigenvector approach retrieves combination weights from the sample estimated mean squared prediction error matrix
as follows:
Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>, <code class="reqn">\Sigma</code> is the (positive definite)
mean squared prediction error matrix of <code class="reqn">\mathbf{f}_t</code> and <code class="reqn">\mathbf{e}</code> is an <code class="reqn">N \times 1</code> vector of <code class="reqn">(1, \ldots, 1)'</code>.
The <code class="reqn">N</code> positive eigenvalues are then arranged in increasing order <code class="reqn">(\Phi_1 = \Phi_{min}, \Phi_2, \ldots, \Phi_N)</code>, and <code class="reqn">\mathbf{w^j}</code>
is defined as the eigenvector corresponding to <code class="reqn">\Phi_j</code>. The combination weights <code class="reqn">\mathbf{w}^{EIG1} = (w_1, \ldots, w_N)'</code> are then
chosen corresponding to the minimum of <code class="reqn">\left(\frac{\Phi_1}{d_1^2}, \frac{\Phi_2}{d_2^2},\ldots,\frac{\Phi_N}{d_N^2}\right)</code>, denoted as <code class="reqn">\mathbf{w}^l</code>, where <code class="reqn">d_j = \mathbf{e}'\mathbf{w}^j</code>, as:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{w}^{EIG1} = \frac{1}{d_l} \mathbf{w}^l</code>
</p>

<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {\mathbf{f}_{t}}'\mathbf{w}^{EIG1}</code>
</p>

<p>The difference to extant methods that minimize the population mean squared prediction error (e.g., Newbold and Granger, 1974) is the normalization function. While
previous approaches optimize MSPE under the constraint of <code class="reqn">\mathbf{e}'\mathbf{w} = 1</code>, Hsiao and Wan (2014) show that this is dominated by
using <code class="reqn">\mathbf{w}'\mathbf{w} = 1</code> as constraint in the optimization problem.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294&ndash;309.
</p>
<p>Newbold, P., and Granger, C. W. J. (1974). Experience with Forecasting Univariate Time Series and the Combination of Forecasts.
<em>Journal of the Royal Statistical Society, Series A</em>, <b>137(2)</b>, 131&ndash;165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="#topic+comb_NG">comb_NG</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG1(data)

</code></pre>

<hr>
<h2 id='comb_EIG2'>Bias-Corrected Eigenvector Forecast Combination</h2><span id='topic+comb_EIG2'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the bias-corrected eigenvector approach by Hsiao and Wan (2014) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_EIG2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_EIG2_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bias-corrected eigenvector approach builds on the idea that if one or more of the predictive models yield biased predictions,
the accuracy of the standard eigenvector approach can be improved by eliminating the bias. The optimization procedure to
obtain combination weights coincides with the <code><a href="#topic+comb_EIG1">standard eigenvector approach</a></code>, except
that it is applied to the centered MSPE matrix after extracting the bias (by subtracting the column means of the MSPE).
</p>
<p>The combination weights are calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{w}^{EIG2} = \frac{1}{\tilde{d}_l} \tilde{\mathbf{w}}^l</code>
</p>

<p>where <code class="reqn">\tilde{d}_j</code> and <code class="reqn">\tilde{\mathbf{w}}^j</code> are defined analogously to <code class="reqn">d_j</code> and <code class="reqn">\mathbf{w}^j</code>
in the <code><a href="#topic+comb_EIG1">standard eigenvector approach</a></code>, with the only difference that they correspond to the spectral decomposition of the
centered MSPE matrix rather than the uncentered one.
</p>
<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = a + {\mathbf{f}_t}'\mathbf{w}^{EIG2}</code>
</p>

<p>where <code class="reqn">a = E(y_t) - E(\mathbf{f}_t)' \mathbf{w}^{EIG2}</code> is the intercept for bias correction. If the actual
series and the forecasts are stationary, the expectations can be approximated by the time series means, i.e. the intercept is obtained
by subtracting the weighted sum of column means of the MSPE matrix from the mean of the actual series. Forecast combination methods
including intercepts therefore usually require stationarity.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Intercept</code></td>
<td>
<p>Returns the intercept (bias correction).</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294&ndash;309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comb_EIG1">comb_EIG1</a></code>,
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code>accuracy</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG2(data)

</code></pre>

<hr>
<h2 id='comb_EIG3'>Trimmed Eigenvector Forecast Combination</h2><span id='topic+comb_EIG3'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the trimmed eigenvector approach by Hsiao and Wan (2014) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_EIG3(x, ntop_pred = NULL, criterion = "RMSE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_EIG3_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="comb_EIG3_+3A_ntop_pred">ntop_pred</code></td>
<td>
<p>Specifies the number of retained predictors. If <code>NULL</code> (default), the inbuilt optimization algorithm selects this number.</p>
</td></tr>
<tr><td><code id="comb_EIG3_+3A_criterion">criterion</code></td>
<td>
<p>If <code>ntop_pred</code> is not specified, a selection criterion is required for the optimization algorithm: one of &quot;MAE&quot;, &quot;MAPE&quot;,
or &quot;RMSE&quot;. If <code>ntop_pred</code> is selected by the user, <code>criterion</code> should be set to <code>NULL</code> (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying methodology of the trimmed eigenvector approach by Hsiao and Wan (2014) is the same as their <code><a href="#topic+comb_EIG1">standard eigenvector approach</a></code>.
The only difference is that the trimmed eigenvector approach pre-selects the models that serve as input for the forecast combination, only a subset of the available
forecast models is retained, while the models with the worst performance are discarded.
</p>
<p>The number of retained forecast models is controlled via <code>ntop_pred</code>. The user can choose whether to select this number, or leave the selection
to the inbuilt optimization algorithm (in that case <code>ntop_pred = NULL</code>). If the optimization algorithm should select the best number of
retained models, the user must select the optimization <code>criterion</code>: MAE, MAPE, or RMSE. After this trimming step, the weights and the combined
forecast are computed in the same way as in the <code><a href="#topic+comb_EIG1">standard eigenvector approach</a></code>.
</p>
<p>The trimmed eigenvector approach takes note of the eigenvector approaches' property to treat <code class="reqn">y</code> and <code class="reqn">\mathbf{f}</code> symmetrically,
which bears the risk that the (non-trimmed) eigenvector approaches' performance could be severely impaired by one or a few models that
produce forecasts much worse than the average.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Top_Predictors</code></td>
<td>
<p>Number of retained predictors.</p>
</td></tr>
<tr><td><code>Ranking</code></td>
<td>
<p>Ranking of the predictors that determines which models are removed in the trimming step.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294&ndash;309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comb_EIG1">comb_EIG1</a></code>
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

## Number of retained models selected by the user:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG3(data, ntop_pred = 2, criterion = NULL)

## Number of retained models selected by algorithm:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG3(data, ntop_pred = NULL, criterion = "RMSE")

</code></pre>

<hr>
<h2 id='comb_EIG4'>Trimmed Bias-Corrected Eigenvector Forecast Combination</h2><span id='topic+comb_EIG4'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the trimmed bias-corrected  eigenvector approach by Hsiao and Wan (2014) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_EIG4(x, ntop_pred = NULL, criterion = "RMSE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_EIG4_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="comb_EIG4_+3A_ntop_pred">ntop_pred</code></td>
<td>
<p>Specifies the number of retained predictors. If <code>NULL</code> (default), the inbuilt optimization algorithm selects this number.</p>
</td></tr>
<tr><td><code id="comb_EIG4_+3A_criterion">criterion</code></td>
<td>
<p>If <code>ntop_pred</code> is not specified, a selection criterion is required for the optimization algorithm: one of &quot;MAE&quot;, &quot;MAPE&quot;,
or &quot;RMSE&quot;. If <code>ntop_pred</code> is selected by the user, <code>criterion</code> should be set to <code>NULL</code> (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying methodology of the trimmed bias-corrected eigenvector approach by Hsiao and Wan (2014) is the same as their
<code><a href="#topic+comb_EIG2">bias-corrected eigenvector approach</a></code>. The only difference is that the bias-corrected trimmed eigenvector approach
pre-selects the models that serve as input for the forecast combination, only a subset of the available forecast models is retained,
while the models with the worst performance are discarded.
</p>
<p>The number of retained forecast models is controlled via <code>ntop_pred</code>. The user can choose whether to select this number, or leave the selection
to the inbuilt optimization algorithm (in that case <code>ntop_pred = NULL</code>). If the optimization algorithm should select the best number of
retained models, the user must select the optimization <code>criterion</code>: MAE, MAPE, or RMSE. After this trimming step, the weights, the intercept and the
combined forecast are computed in the same way as in the <code><a href="#topic+comb_EIG2">bias-corrected eigenvector approach</a></code>.
</p>
<p>The bias-corrected trimmed eigenvector approach combines the strengths of the <br />
<code><a href="#topic+comb_EIG2">bias-corrected eigenvector approach</a></code> and the <code><a href="#topic+comb_EIG3">trimmed eigenvector approach</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Intercept</code></td>
<td>
<p>Returns the intercept (bias correction).</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Top_Predictors</code></td>
<td>
<p>Number of retained predictors.</p>
</td></tr>
<tr><td><code>Ranking</code></td>
<td>
<p>Ranking of the predictors that determines which models are removed in the trimming step.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294&ndash;309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comb_EIG2">comb_EIG2</a></code>
<code><a href="#topic+comb_EIG3">comb_EIG3</a></code>
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

## Number of retained models selected by the user:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG4(data, ntop_pred = 2, criterion = NULL)

## Number of retained models selected by algorithm:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_EIG4(data, ntop_pred = NULL, criterion = "RMSE")

</code></pre>

<hr>
<h2 id='comb_InvW'>Inverse Rank Forecast Combination</h2><span id='topic+comb_InvW'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the inverse rank approach by Aiolfi and Timmermann (2006) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_InvW(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_InvW_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the inverse rank approach by Aiolfi and Timmermann (2006), the combination weights are inversely proportional to the forecast model's rank, <code class="reqn">Rank_i</code>:
</p>
<p style="text-align: center;"><code class="reqn">w_i^{InvW} = \frac{Rank_i^{-1}}{\Sigma_{j=1}^N  Rank_j^{-1}}</code>
</p>

<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {\mathbf{f}_{t}}'\mathbf{w}^{InvW}</code>
</p>

<p>This is a robust variant of the Bates/Granger (1969) approach and also ignores correlations across forecast errors.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Aiolfi, M., amd Timmermann, A. (2006). Persistence in Forecasting Performance and Conditional Combination Strategies. <em>Journal of Econometrics</em>, <b>135(1)</b>, 31&ndash;53.
</p>
<p>Bates, J. M., and Granger, C. W. (1969). The Combination of Forecasts. <em>Journal of the Operational Research Society</em>, <b>20(4)</b>, 451&ndash;468.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="#topic+comb_BG">comb_BG</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_InvW(data)

</code></pre>

<hr>
<h2 id='comb_LAD'>Least Absolute Deviation Forecast Combination</h2><span id='topic+comb_LAD'></span>

<h3>Description</h3>

<p>Computes forecast combination weights using least absolute deviation (LAD) regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_LAD(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_LAD_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function integrates the least absolute deviation (LAD) forecast combination implementation of the
<em>ForecastCombinations</em> package into ForecastComb.
</p>
<p>The defining property of <code>comb_LAD</code> is that it does not minimize the squared error loss like <code><a href="#topic+comb_OLS">comb_OLS</a></code> and
<code><a href="#topic+comb_CLS">comb_CLS</a></code>, but the absolute values of the errors. This makes the method more robust to outliers &ndash; <code>comb_LAD</code>
tends to penalize models, which have high errors for some observations, less harshly than the least squares methods would.
</p>
<p>Optimal forecast combinations under general loss functions are discussed by Elliott and Timmermann (2004). The LAD method is
described in more detail, and used in an empirical context, by Nowotarksi et al. (2014).
</p>
<p>The results are stored in an object of class 'foreccomb_res', for which separate plot and summary functions are provided.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the best-fit forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Intercept</code></td>
<td>
<p>Returns the intercept of the linear regression.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Elliott, G., and Timmermann, A. (2004). Optimal Forecast Combinations Under General Loss Functions and Forecast Error Distributions.
<em>Journal of Econometrics</em>, <b>122(1)</b>, 47&ndash;79.
</p>
<p>Nowotarski, J., Raviv, E., Tr\&quot;uck, S., and Weron, R. (2014). An Empirical Comparison of Alternative
Schemes for Combining Electricity Spot Price Forecasts. <em>Energy Economics</em>, <b>46</b>, 395&ndash;412.
</p>


<h3>See Also</h3>

<p><code><a href="ForecastCombinations.html#topic+Forecast_comb">Forecast_comb</a></code>,
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_LAD(data)

</code></pre>

<hr>
<h2 id='comb_MED'>Median Forecast Combination</h2><span id='topic+comb_MED'></span>

<h3>Description</h3>

<p>Computes a &lsquo;combined forecast&rsquo; from a pool of individual model forecasts using their median at each point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_MED(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_MED_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>. For each point in time, the median method gives
a weight of 1 to the median forecast and a weight of 0 to all other forecasts, the combined forecast is obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {median(\mathbf{f}_{t}})</code>
</p>

<p>The median method is an appealing simple, rank-based combination method that has been proposed by authors such as Armstrong (1989),
McNees (1992), Hendry and Clements (2004), Stock and Watson (2004), and Timmermann (2006). It is more robust to outliers than the
simple average approach.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Armstrong, J. S. (1989). Combining Forecasts: The End of the Beginning or the Beginning of the End?. <em>International Journal of Forecasting</em>,
<b>5(4)</b>, 585&ndash;588.
</p>
<p>Hendry, D. F., and Clements, M. P. (2004). Pooling of Forecasts. <em>The Econometrics Journal</em>, <b>7(1)</b>, 1&ndash;31.
</p>
<p>McNees, S. K. (1992). The Uses and Abuses of 'Consensus' Forecasts. <em>Journal of Forecasting</em>, <b>11(8)</b>, 703&ndash;710.
</p>
<p>Stock, J. H., and Watson, M. W. (2004). Combination Forecasts of Output Growth in a Seven-Country Data Set. <em>Journal of Forecasting</em>, <b>23(6)</b>,
405&ndash;430.
</p>
<p>Timmermann, A. (2006). Forecast Combinations. In: Elliott, G., Granger, C. W. J., and Timmermann, A. (Eds.), <em>Handbook of Economic Forecasting</em>,
<b>1</b>, 135&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="#topic+comb_SA">comb_SA</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_MED(data)

</code></pre>

<hr>
<h2 id='comb_NG'>Newbold/Granger (1974) Forecast Combination</h2><span id='topic+comb_NG'></span>

<h3>Description</h3>

<p>Computes forecast combination weights according to the approach by Newbold and Granger (1974) and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_NG(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_NG_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Building on early research by Bates and Granger (1969), the methodology of Newbold and Granger (1974) also extracts the combination weights from the estimated
mean squared prediction error matrix.
</p>
<p>Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>, <code class="reqn">\Sigma</code> is the (positive definite)
mean squared prediction error matrix of <code class="reqn">\mathbf{f}_t</code> and <code class="reqn">\mathbf{e}</code> is an <code class="reqn">N \times 1</code> vector of <code class="reqn">(1, \ldots, 1)'</code>.
</p>
<p>Their approach is a constrained minimization of the mean squared prediction error using the normalization condition <code class="reqn">\mathbf{e}'\mathbf{w} = 1</code>.
This yields the following combination weights:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{w}^{NG} = \frac{\Sigma^{-1}\mathbf{e}}{\mathbf{e}'\Sigma^{-1}\mathbf{e}}</code>
</p>

<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {\mathbf{f}_{t}}'\mathbf{w}^{NG}</code>
</p>

<p>While the method dates back to Newbold and Granger (1974), the variant of the method used here does not impose the prior restriction that <code class="reqn">\Sigma</code>
is diagonal. This approach, called <code>VC</code> in Hsiao and Wan (2014), is a generalization of the original method.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Bates, J. M., and Granger, C. W. (1969). The Combination of Forecasts. <em>Journal of the Operational Research Society</em>, <b>20(4)</b>, 451&ndash;468.
</p>
<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294&ndash;309.
</p>
<p>Newbold, P., and Granger, C. W. J. (1974). Experience with Forecasting Univariate Time Series and the Combination of Forecasts.
<em>Journal of the Royal Statistical Society, Series A</em>, <b>137(2)</b>, 131&ndash;165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comb_BG">comb_BG</a></code>,
<code><a href="#topic+comb_EIG1">comb_EIG1</a></code>,
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_NG(data)

</code></pre>

<hr>
<h2 id='comb_OLS'>Ordinary Least Squares Forecast Combination</h2><span id='topic+comb_OLS'></span>

<h3>Description</h3>

<p>Computes forecast combination weights using ordinary least squares (OLS) regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_OLS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_OLS_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function integrates the ordinary least squares (OLS) forecast combination implementation of the
<em>ForecastCombinations</em> package into ForecastComb.
</p>
<p>The OLS combination method (Granger and Ramanathan (1984)) uses ordinary least squares to
estimate the weights, <code class="reqn">\mathbf{w}^{OLS} = (w_1, \ldots, w_N)'</code>, as well as an intercept, <code class="reqn">b</code>, for the combination of
the forecasts.
</p>
<p>Suppose that there are <code class="reqn">N</code> not perfectly collinear predictors  <code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>,
then the forecast combination for one data point can be represented as:
</p>
<p style="text-align: center;"><code class="reqn">y_t = b + \sum_{i=1}^{N} w_i f_{it}</code>
</p>

<p>An appealing feature of the method is its bias correction through the intercept &ndash; even if one or more of the individual
predictors are biased, the resulting combined forecast is unbiased. A disadvantage of the method is that it places no
restriction on the combination weights (i.e., they do not add up to 1 and can be negative), which can make interpretation
hard. Another issue, documented in Nowotarski et al. (2014), is the method's unstable behavior
when predictors are highly correlated (which is the norm in forecast combination): Minor fluctuations in the sample
can cause major shifts of the coefficient vector (&lsquo;bouncing betas&rsquo;) &ndash; often causing poor out-of-sample performance.
This issue is addressed by the <code><a href="#topic+comb_LAD">comb_LAD</a></code> method that is more robust to outliers.
</p>
<p>The results are stored in an object of class 'foreccomb_res', for which separate plot and summary functions are provided.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the best-fit forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Intercept</code></td>
<td>
<p>Returns the intercept of the linear regression.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Granger, C., and Ramanathan, R. (1984). Improved Methods Of Combining Forecasts. <em>Journal of Forecasting</em>, <b>3(2)</b>, 197&ndash;204.
</p>
<p>Nowotarski, J., Raviv, E., Tr\&quot;uck, S., and Weron, R. (2014). An Empirical Comparison of Alternative
Schemes for Combining Electricity Spot Price Forecasts. <em>Energy Economics</em>, <b>46</b>, 395&ndash;412.
</p>


<h3>See Also</h3>

<p><code><a href="ForecastCombinations.html#topic+Forecast_comb">Forecast_comb</a></code>,
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_OLS(data)

</code></pre>

<hr>
<h2 id='comb_SA'>Simple Average Forecast Combination</h2><span id='topic+comb_SA'></span>

<h3>Description</h3>

<p>Computes forecast combination weights using simple average and produces forecasts for the test set, if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_SA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_SA_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>. The simple average gives equal weights to all predictors:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{w}^{SA} = \frac{1}{N}</code>
</p>

<p>The combined forecast is then obtained by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = {\mathbf{f}_{t}}'\mathbf{w}^{SA}</code>
</p>

<p>It is well-documented that simple average is a robust combination method that is hard to beat (e.g., Stock and Watson, 2004; Timmermann, 2006).
This is often associated with the importance of parameter estimation error in sophisticated techniques &ndash; a problem that simple averaging avoids.
However, simple averaging may not be a suitable combination method when some of the predictors are biased (Palm and Zellner, 1992).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Palm, F. C., and Zellner, A. (1992). To Combine or not to Combine? Issues of Combining Forecasts. <em>Journal of Forecasting</em>, <b>11(8)</b>, 687&ndash;701.
</p>
<p>Stock, J. H., and Watson, M. W. (2004). Combination Forecasts of Output Growth in a Seven-Country Data Set. <em>Journal of Forecasting</em>, <b>23(6)</b>,
405&ndash;430.
</p>
<p>Timmermann, A. (2006). Forecast Combinations. In: Elliott, G., Granger, C. W. J., and Timmermann, A. (Eds.), <em>Handbook of Economic Forecasting</em>,
<b>1</b>, 135&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code>accuracy</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_SA(data)

</code></pre>

<hr>
<h2 id='comb_TA'>Trimmed Mean Forecast Combination</h2><span id='topic+comb_TA'></span>

<h3>Description</h3>

<p>Computes a &lsquo;combined forecast&rsquo; from a pool of individual model forecasts using trimmed mean at each point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_TA(x, trim_factor = NULL, criterion = "RMSE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_TA_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="comb_TA_+3A_trim_factor">trim_factor</code></td>
<td>
<p>numeric. Must be between 0 (simple average) and 0.5 (median).</p>
</td></tr>
<tr><td><code id="comb_TA_+3A_criterion">criterion</code></td>
<td>
<p>If <code>trim_factor</code> is not specified, an optimization criterion for automated trimming needs to be defined. One of
&quot;MAE&quot;, &quot;MAPE&quot;, or &quot;RMSE&quot; (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>. For each point in time, the order forecasts are
computed:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{f}_t^{ord} = (f_{(1)t}, \ldots, f_{(N)t})'</code>
</p>

<p>Using a trim factor <code class="reqn">\lambda</code> (i.e., the top/bottom <code class="reqn">\lambda \%</code> are trimmed) the combined forecast is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = \frac{1}{N(1-2\lambda)} \sum_{i = \lambda N +1}^{(1-\lambda)N} f_{(i)t}</code>
</p>

<p>The trimmed mean is an interpolation between the simple average and the median. It is an appealing simple, rank-based
combination method that is less sensitive to outliers than the simple average approach, and has been proposed by authors
such as Armstrong (2001), Stock and Watson (2004), and Jose and Winkler (2008).
</p>
<p>This method allows the user to select <code class="reqn">\lambda</code> (by specifying <code>trim_factor</code>), or to leave the selection to
an optimization algorithm &ndash; in which case the optimization criterion has to be selected (one of &quot;MAE&quot;, &quot;MAPE&quot;, or &quot;RMSE&quot;).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Trim Factor</code></td>
<td>
<p>Returns the trim factor, <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Armstrong, J. S. (2001). Combining Forecasts. In: <em>Armstrong, J. S. (Ed.), Principles of Forecasting. Springer, Boston, MA</em>, 417&ndash;439.
</p>
<p>Jose, V. R. R., and Winkler, R. L. (2008). Simple Robust Averages of Forecasts: Some Empirical Results. <em>International Journal of Forecasting</em>, <b>24(1)</b>, 163&ndash;169.
</p>
<p>Stock, J. H., and Watson, M. W. (2004). Combination Forecasts of Output Growth in a Seven-Country Data Set. <em>Journal of Forecasting</em>, <b>23(6)</b>,
405&ndash;430.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="#topic+comb_SA">comb_SA</a></code>,
<code><a href="#topic+comb_MED">comb_MED</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

## User-selected trim factor:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_TA(data, trim_factor=0.1)

## Algorithm-optimized trim factor:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_TA(data, criterion="RMSE")

</code></pre>

<hr>
<h2 id='comb_WA'>Winsorized Mean Forecast Combination</h2><span id='topic+comb_WA'></span>

<h3>Description</h3>

<p>Computes a &lsquo;combined forecast&rsquo; from a pool of individual model forecasts using winsorized mean at each point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_WA(x, trim_factor = NULL, criterion = "RMSE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comb_WA_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="comb_WA_+3A_trim_factor">trim_factor</code></td>
<td>
<p>numeric. Must be between 0 and 0.5.</p>
</td></tr>
<tr><td><code id="comb_WA_+3A_criterion">criterion</code></td>
<td>
<p>If <code>trim_factor</code> is not specified, an optimization criterion for automated trimming needs to be defined. One of
&quot;MAE&quot;, &quot;MAPE&quot;, or &quot;RMSE&quot; (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">y_t</code> is the variable of interest, there are <code class="reqn">N</code> not perfectly collinear predictors,
<code class="reqn">\mathbf{f}_t = (f_{1t}, \ldots, f_{Nt})'</code>. For each point in time, the order forecasts are
computed:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{f}_t^{ord} = (f_{(1)t}, \ldots, f_{(N)t})'</code>
</p>

<p>Using a trim factor <code class="reqn">\lambda</code> (i.e., the top/bottom <code class="reqn">\lambda \%</code> are winsorized), and setting <code class="reqn">K = N\lambda</code> ,
the combined forecast is calculated as (Jose and Winkler, 2008):
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_t = \frac{1}{N} \left[Kf_{(K+1)t} + \sum_{i=K+1}^{N-K} f_{(i)t} + Kf_{(N-K)t}\right]</code>
</p>

<p>Like the trimmed mean, the winsorized mean is a robust statistic that is less sensitive to outliers than the simple average.
It is less extreme about handling outliers than the trimmed mean and preferred by Jose and Winkler (2008) for this reason.
</p>
<p>This method allows the user to select <code class="reqn">\lambda</code> (by specifying <code>trim_factor</code>), or to leave the selection to
an optimization algorithm &ndash; in which case the optimization criterion has to be selected (one of &quot;MAE&quot;, &quot;MAPE&quot;, or &quot;RMSE&quot;).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the used forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the combination method to the training set.</p>
</td></tr>
<tr><td><code>Trim Factor</code></td>
<td>
<p>Returns the trim factor, <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Jose, V. R. R., and Winkler, R. L. (2008). Simple Robust Averages of Forecasts: Some Empirical Results. <em>International Journal of Forecasting</em>, <b>24(1)</b>, 163&ndash;169.
</p>


<h3>See Also</h3>

<p><code><a href="psych.html#topic+winsor.mean">winsor.mean</a></code>,
<code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
<code><a href="#topic+comb_SA">comb_SA</a></code>,
<code><a href="#topic+comb_TA">comb_TA</a></code>,
<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

## User-selected trim factor:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_TA(data, trim_factor=0.1)

## Algorithm-optimized trim factor:
data&lt;-foreccomb(train_o, train_p, test_o, test_p)
comb_TA(data, criterion="RMSE")

</code></pre>

<hr>
<h2 id='cs_dispersion'>Compute Cross-Sectional Dispersion</h2><span id='topic+cs_dispersion'></span>

<h3>Description</h3>

<p>Computes (time-varying) dispersion measures for the cross section of individual model forecasts that are the input of forecast combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs_dispersion(x, measure = "SD", plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cs_dispersion_+3A_x">x</code></td>
<td>
<p>An object of class <code>foreccomb</code>. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="cs_dispersion_+3A_measure">measure</code></td>
<td>
<p>Cross-sectional dispersion measure, one of: <code>"SD"</code> = standard deviation (default); <code>"IQR"</code> = interquartile range; or <code>"Range"</code> = range.</p>
</td></tr>
<tr><td><code id="cs_dispersion_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, evolution of cross-sectional forecast dispersion is plotted as <code>ggplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available measures of scale are defined as in Davison (2003). Let <code class="reqn">y_{(i)}</code> denote the i-th order statistic of the sample, then:
</p>
<p style="text-align: center;"><code class="reqn">Range_t = y_{(n), t} - y_{(1), t}</code>
</p>

<p style="text-align: center;"><code class="reqn">IQR_t = y_{(3n/4),t} - y_{(n/4),t}</code>
</p>

<p style="text-align: center;"><code class="reqn">SD_t = \sqrt{\frac{1}{n-1} \Sigma_{i=1}^n \left(y_{i,t} - \bar{y}_t \right)}</code>
</p>

<p>Previous research in the forecast combination literature has documented that regression-based combination methods tend to have relative advantage when one or more individual model forecasts are better than the rest, while eigenvector-based methods tend to have relative advantage when individual model forecasts are in the same ball park.
</p>


<h3>Value</h3>

<p>Returns a vector of the evolution of cross-sectional dispersion over the sample period (using the selected dispersion measure)
</p>


<h3>References</h3>

<p>Davison, A. C. (2003). Statistical Models. <em>Cambridge University Press</em>.
</p>
<p>Hsiao, C., and Wan, S. K. (2014). Is There An Optimal Forecast Combination? <em>Journal of Econometrics</em>, <b>178(2)</b>, 294&ndash;309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="stats.html#topic+sd">sd</a></code>,
<code><a href="stats.html#topic+IQR">IQR</a></code>,
<code><a href="base.html#topic+range">range</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
cs_dispersion(data, measure = "IQR")

</code></pre>

<hr>
<h2 id='electricity'>UK Electricity Supply 2007 - 2017</h2><span id='topic+electricity'></span>

<h3>Description</h3>

<p>The <code>electricity</code> dataset contains monthly data on the total UK electricity
supply in GWh from January 2007 to March 2017, as well as univariate time series
forecasts for this series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(electricity)</code></pre>


<h3>Format</h3>

<p>A multivariate time series of 123 observations; monthly, 2007-2017.
</p>
<p>This data contains the following columns:
</p>

<dl>
<dt>arima</dt><dd><p>(ARIMA 1-month forecasts)</p>
</dd>
<dt>ets</dt><dd><p>(ETS 1-month forecasts)</p>
</dd>
<dt>nnet</dt><dd><p>(Neural Network 1-month forecasts)</p>
</dd>
<dt>dampedt</dt><dd><p>(Damped Trend 1-month forecasts)</p>
</dd>
<dt>dotm</dt><dd><p>(Dynamic Optimized Theta 1-month forecasts)</p>
</dd>
<dt>Actual</dt><dd><p>(Observed values)</p>
</dd>
</dl>



<h3>Source</h3>

<p>International Energy Agency (2017). IEA Monthly Electricity Statistics.
Available at <a href="http://www.iea.org/statistics/monthlystatistics/monthlyelectricitystatistics/">http://www.iea.org/statistics/monthlystatistics/monthlyelectricitystatistics/</a>
</p>

<hr>
<h2 id='foreccomb'>Format Raw Data for Forecast Combination</h2><span id='topic+foreccomb'></span>

<h3>Description</h3>

<p>Structures cross-sectional input data (individual model forecasts) for forecast combination. Stores data as S3 class
<code>foreccomb</code> that serves as input to the forecast combination techniques. Handles missing value imputation (optional) and resolves
problems due to perfect collinearity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreccomb(observed_vector, prediction_matrix, newobs = NULL,
  newpreds = NULL, byrow = FALSE, na.impute = TRUE, criterion = "RMSE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foreccomb_+3A_observed_vector">observed_vector</code></td>
<td>
<p>A vector or univariate time series; contains &lsquo;actual values&rsquo; for training set.</p>
</td></tr>
<tr><td><code id="foreccomb_+3A_prediction_matrix">prediction_matrix</code></td>
<td>
<p>A matrix or multivariate time series; contains individual model forecasts for training set.</p>
</td></tr>
<tr><td><code id="foreccomb_+3A_newobs">newobs</code></td>
<td>
<p>A vector or univariate time series; contains &lsquo;actual values&rsquo; if a test set is used (optional).</p>
</td></tr>
<tr><td><code id="foreccomb_+3A_newpreds">newpreds</code></td>
<td>
<p>A matrix or multivariate time series; contains individual model forecasts if a test set is used (optional). Does not
require specification of <code>newobs</code> &ndash; in the case in which a forecaster only wants to train the forecast combination method
with a training set and apply it to future individual model forecasts, only <code>newpreds</code> is required, not <code>newobs</code>.</p>
</td></tr>
<tr><td><code id="foreccomb_+3A_byrow">byrow</code></td>
<td>
<p>logical. The default (<code>FALSE</code>) assumes that each column of the forecast matrices (<code>prediction_matrix</code> and &ndash; if
specified &ndash; <code>newpreds</code>) contains forecasts from one forecast model; if each row of the matrices contains forecasts from
one forecast model, set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreccomb_+3A_na.impute">na.impute</code></td>
<td>
<p>logical. The default (<code>TRUE</code>) behavior is to impute missing values via the cross-validated spline approach of
the <code>mtsdi</code> package. If set to <code>FALSE</code>, forecasts with missing values will be removed. Missing values in the observed data are never
imputed.</p>
</td></tr>
<tr><td><code id="foreccomb_+3A_criterion">criterion</code></td>
<td>
<p>One of <code>"RMSE"</code> (default), <code>"MAE"</code>, or <code>"MAPE"</code>. Is only used if <code>prediction_matrix</code> is not full rank: The algorithm
checks which models are causing perfect collinearity and the one with the worst individual accuracy (according to the chosen
criterion) is removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function imports the column names of the prediction matrix (if <code>byrow = FALSE</code>, otherwise the row names) as model names;
if no column names are specified, generic model names are created.
</p>
<p>The missing value imputation algorithm is a modified version of the EM algorithm for imputation that is applicable to time series
data - accounting for correlation between the forecasting models and time structure of the series itself. A smooth spline is
fitted to each of the time series at each iteration. The degrees of freedom of each spline are chosen by cross-validation.
</p>
<p>Forecast combination relies on the lack of perfect collinearity. The test for this condition checks if <code>prediction_matrix</code> is full
rank. In the presence of perfect collinearity, the iterative algorithm identifies the subset of forecasting models that are causing
linear dependence and removes the one among them that has the lowest accuracy (according to a selected criterion, default is RMSE).
This procedure is repeated until the revised prediction matrix is full rank.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb</code>.
</p>


<h3>Author(s)</h3>

<p>Christoph E. Weiss, Gernot R. Roetzer
</p>


<h3>References</h3>

<p>Junger, W. L., Ponce de Leon, A., and Santos, N. (2003). Missing Data Imputation in Multivariate Time Series
via EM Algorithm. <em>Cadernos do IME</em>, <b>15</b>, 8&ndash;21.
</p>
<p>Dempster, A., Laird, N., and Rubin D. (1977). Maximum Likelihood from Incomplete Data via the EM Algorithm.
<em>Journal of the Royal Statistical Society, Series B</em>, <b>39(1)</b>, 1&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="mtsdi.html#topic+mnimput">mnimput</a></code>,
<code><a href="Matrix.html#topic+rankMatrix">rankMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

## Example with a training set only:
foreccomb(train_o, train_p)

## Example with a training set and future individual forecasts:
foreccomb(train_o, train_p, newpreds=test_p)

## Example with a training set and a full test set:
foreccomb(train_o, train_p, test_o, test_p)

## Example with forecast models being stored in rows:
preds_row &lt;- matrix(rnorm(1000, 1), 10, 100)
train_p_row &lt;- preds_row[,1:80]
foreccomb(train_o, train_p_row, byrow = TRUE)

## Example with NA imputation:
train_p_na &lt;- train_p
train_p_na[2,3] &lt;- NA
foreccomb(train_o, train_p_na, na.impute = TRUE)

## Example with perfect collinearity:
train_p[,2] &lt;- 0.8*train_p[,1] + 0.4*train_p[,8]
foreccomb(train_o, train_p, criterion="RMSE")

</code></pre>

<hr>
<h2 id='foreccomb_res'>Result Rbject for the Forecast Combination Methods</h2><span id='topic+foreccomb_res'></span>

<h3>Description</h3>

<p>Stores the results and inputs for some combined forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreccomb_res(method, modelnames, fitted, accuracy_insample, input_data,
  predict = NULL, intercept = NULL, weights = NULL, pred = NULL,
  accuracy_outsample = NULL, trim_factor = NULL, top_predictors = NULL,
  ranking = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foreccomb_res_+3A_method">method</code></td>
<td>
<p>Name of the method.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_modelnames">modelnames</code></td>
<td>
<p>Names of the models provided by the user.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_fitted">fitted</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_accuracy_insample">accuracy_insample</code></td>
<td>
<p>Insample accuracy obtained by the method.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_input_data">input_data</code></td>
<td>
<p>Contains the input data provided by the user.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_predict">predict</code></td>
<td>
<p>(optional) Function used to conduct predictions for new forecasts.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_intercept">intercept</code></td>
<td>
<p>(optional) Intercept of the method, if it requires one.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_weights">weights</code></td>
<td>
<p>(optional) Weights of the method, if it requires one.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_pred">pred</code></td>
<td>
<p>= (optional) Predictions on a test set.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_accuracy_outsample">accuracy_outsample</code></td>
<td>
<p>= (optional) Accuracy on the test set.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_trim_factor">trim_factor</code></td>
<td>
<p>= (optional) Trim factor used in some of the methods.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_top_predictors">top_predictors</code></td>
<td>
<p>(optional) Number of retained predictors.</p>
</td></tr>
<tr><td><code id="foreccomb_res_+3A_ranking">ranking</code></td>
<td>
<p>(optional) Ranking of the predictors that determines which models are removed in the trimming step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code>.
</p>


<h3>Author(s)</h3>

<p>Christoph E. Weiss, Gernot R. Roetzer
</p>

<hr>
<h2 id='plot.foreccomb_res'>Plot results from forecast combination model</h2><span id='topic+plot.foreccomb_res'></span>

<h3>Description</h3>

<p>Produces plots for the results of a forecast combination method. Either
an actual vs. fitted plot (<code>which = 1</code>) or a barplot of the combination weights
(<code>which = 2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foreccomb_res'
plot(x, which = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.foreccomb_res_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb_res'.</p>
</td></tr>
<tr><td><code id="plot.foreccomb_res_+3A_which">which</code></td>
<td>
<p>Type of plot: 1 = actual vs. fitted, 2 = combination weights.</p>
</td></tr>
<tr><td><code id="plot.foreccomb_res_+3A_...">...</code></td>
<td>
<p>Other arguments passing to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot for the foreccomb_res class.
</p>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
fit &lt;- comb_EIG1(data)
plot(fit)

</code></pre>

<hr>
<h2 id='predict.foreccomb_res'>Prediction function for Forecast Combinations</h2><span id='topic+predict.foreccomb_res'></span>

<h3>Description</h3>

<p><code>prediction</code> method for class &lsquo;foreccomb_res&rsquo;. Uses the previously created forecast combination
result to predict the combination for a newly provided prediction dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foreccomb_res'
predict(object, newpreds, newobs = NULL,
  simplify = TRUE, byrow = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.foreccomb_res_+3A_object">object</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="predict.foreccomb_res_+3A_newpreds">newpreds</code></td>
<td>
<p>A matrix or multivariate time series; contains individual model forecasts if a test set is used (optional). Does not
require specification of <code>newobs</code> &ndash; in the case in which a forecaster only wants to train the forecast combination method
with a training set and apply it to future individual model forecasts, only <code>newpreds</code> is required, not <code>newobs</code>.</p>
</td></tr>
<tr><td><code id="predict.foreccomb_res_+3A_newobs">newobs</code></td>
<td>
<p>A vector or univariate time series; contains &lsquo;actual values&rsquo; if a test set is used (optional).</p>
</td></tr>
<tr><td><code id="predict.foreccomb_res_+3A_simplify">simplify</code></td>
<td>
<p>logical. The default (<code>TRUE</code>) returns the predictions separately. If set to (<code>FALSE</code>) the predictions are incorporated
into the foreccomb_res object, that is, the object is equal to the one that would have been obtained, if the new prediction set would have
been provided when the forecast combination method was trained originally.</p>
</td></tr>
<tr><td><code id="predict.foreccomb_res_+3A_byrow">byrow</code></td>
<td>
<p>logical. The default (<code>FALSE</code>) assumes that each column of the forecast matrices (<code>prediction_matrix</code> and &ndash; if
specified &ndash; <code>newpreds</code>) contains forecasts from one forecast model; if each row of the matrices contains forecasts from
one forecast model, set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.foreccomb_res_+3A_...">...</code></td>
<td>
<p>potential further arguments (require by generic)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p)
fit&lt;-comb_BG(data)
predict(fit, test_p)

</code></pre>

<hr>
<h2 id='rolling_combine'>Dynamic Forecast Combination</h2><span id='topic+rolling_combine'></span>

<h3>Description</h3>

<p>Computes the dynamic version of the combined forecast for a method included in the ForecastComb package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_combine(x, comb_method, criterion = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rolling_combine_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb'. Must contrain full training set and test set.</p>
</td></tr>
<tr><td><code id="rolling_combine_+3A_comb_method">comb_method</code></td>
<td>
<p>The combination method that should be used.</p>
</td></tr>
<tr><td><code id="rolling_combine_+3A_criterion">criterion</code></td>
<td>
<p>Specifies loss criterion. Set criterion to either 'RMSE', 'MAE', or 'MAPE' for the methods <code>comb_TA</code>, <code>comb_WA</code>,
<code>comb_EIG3</code>, and <code>comb_EIG4</code>, or to 'NULL' (default) for all other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rolling_combine</code> allows to estimate a dynamic version of the other combination methods of the package in a
standardized way, i.e., it allows for time-varying weights. The function builds on the idea of time series cross-validation:
Taking the provided training set as starting point, the models are re-estimated at each period of the test set using a
revised (increased) training set.
</p>
<p>Like univariate dynamic forecasting, the validation approach requires a full test set &ndash; including the observed values.
</p>
<p>The results are stored in an object of class 'foreccomb_res', for which separate plot and summary functions are provided.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>foreccomb_res</code> that represents the results for the best-fit forecast combination method:
</p>
<table role = "presentation">
<tr><td><code>Method</code></td>
<td>
<p>Returns the best-fit forecast combination method.</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>Returns the individual input models that were used for the forecast combinations.</p>
</td></tr>
<tr><td><code>Weights</code></td>
<td>
<p>Returns the combination weights obtained by applying the best-fit combination method to the training set.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Returns the fitted values of the combination method for the training set.</p>
</td></tr>
<tr><td><code>Accuracy_Train</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the training set.</p>
</td></tr>
<tr><td><code>Forecasts_Test</code></td>
<td>
<p>Returns forecasts produced by the combination method for the test set. Only returned if input included a forecast matrix for the test set.</p>
</td></tr>
<tr><td><code>Accuracy_Test</code></td>
<td>
<p>Returns range of summary measures of the forecast accuracy for the test set. Only returned if input included a forecast matrix and a vector of actual values for the test set.</p>
</td></tr>
<tr><td><code>Input_Data</code></td>
<td>
<p>Returns the data forwarded to the method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss
</p>


<h3>References</h3>

<p>Bergmeir, C., Hyndman, R.J., and Koo, B. (2015). A Note on the Validity of Cross-Validation
for Evaluating Time Series Prediction. <em>Monash University, Deparment of Econometrics and
Business Statistics</em>, Working Paper No. 10/15.
</p>
<p>Timmermann, A. (2006). Forecast Combinations. <em>Handbook of Economic Forecasting</em>, <b>1</b>, 135&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
<code><a href="#topic+summary.foreccomb_res">summary.foreccomb_res</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)

#Static forecast combination (for example OLS):
static_OLS &lt;- comb_OLS(data)

#Dynamic forecast combination:
dyn_OLS &lt;- rolling_combine(data, "comb_OLS")

</code></pre>

<hr>
<h2 id='summary.foreccomb_res'>Summary of Forecast Combination</h2><span id='topic+print.foreccomb_res_summary'></span><span id='topic+summary.foreccomb_res'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &lsquo;foreccomb_res&rsquo;. Includes information about combination method,
combination weights assigned to the individual forecast models, as well as an accuracy evaluation of the combined
forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'foreccomb_res'
summary(object, ...)

## S3 method for class 'foreccomb_res_summary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.foreccomb_res_+3A_object">object</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
<tr><td><code id="summary.foreccomb_res_+3A_...">...</code></td>
<td>
<p>potential further arguments (require by generic)</p>
</td></tr>
<tr><td><code id="summary.foreccomb_res_+3A_x">x</code></td>
<td>
<p>An object of class 'foreccomb'. Contains training set (actual values + matrix of model forecasts) and optionally a test set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christoph E. Weiss and Gernot R. Roetzer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+foreccomb">foreccomb</a></code>,
<code><a href="#topic+plot.foreccomb_res">plot.foreccomb_res</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- rnorm(100)
preds &lt;- matrix(rnorm(1000, 1), 100, 10)
train_o&lt;-obs[1:80]
train_p&lt;-preds[1:80,]
test_o&lt;-obs[81:100]
test_p&lt;-preds[81:100,]

data&lt;-foreccomb(train_o, train_p, test_o, test_p)
fit&lt;-comb_BG(data)
summary(fit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
