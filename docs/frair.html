<!DOCTYPE html><html><head><title>Help for package frair</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frair}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bythotrephes'><p>Bythotrephes Functional Response Data</p></a></li>
<li><a href='#drawpoly'><p>Draw polygons</p></a></li>
<li><a href='#fr_emdII'><p>EMD Type II Response</p></a></li>
<li><a href='#fr_flexp'><p>Scaling Exponent Response, assuming replacement</p></a></li>
<li><a href='#fr_flexpnr'><p>Scaling Exponent Response, not assuming replacement</p></a></li>
<li><a href='#fr_hassIII'><p>Hassell's Type III Response</p></a></li>
<li><a href='#fr_hassIIInr'><p>Hassell's Type III Response, without replacement</p></a></li>
<li><a href='#fr_hollingsII'><p>Holling's Original Type II Response</p></a></li>
<li><a href='#fr_rogersII'><p>Rogers' Type II Response</p></a></li>
<li><a href='#fr_typeI'><p>Type I Response</p></a></li>
<li><a href='#frair_boot'><p>Bootstrap a predator-prey functional response.</p></a></li>
<li><a href='#frair_boot_methods'><p>frair methods</p></a></li>
<li><a href='#frair_compare'><p>Test the difference between two functional response fits</p></a></li>
<li><a href='#frair_fit'><p>Fit predator-prey functional responses.</p></a></li>
<li><a href='#frair_fit_methods'><p>frair methods</p></a></li>
<li><a href='#frair_responses'><p>FRAIR responses</p></a></li>
<li><a href='#frair_test'><p>Test for evidence of type-II or type-III functional responses</p></a></li>
<li><a href='#frair-deprecated'><p>Deprecated Functional Response Models</p></a></li>
<li><a href='#frair-package'><p>Functional Response Analysis in R</p></a></li>
<li><a href='#gammarus'><p>Gammarus Functional Response Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Functional Response Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.100</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-03-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to support sensible statistics for functional response analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats4, bbmle</td>
</tr>
<tr>
<td>Imports:</td>
<td>lamW (&ge; 1.0), boot, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dpritchard/frair">https://github.com/dpritchard/frair</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dpritchard/frair/issues">https://github.com/dpritchard/frair/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-25 21:24:43 UTC; daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Pritchard [aut, cre],
  Daniel Barrios-O'Neill [ctb],
  Helene Bovy [ctb],
  Rachel Paterson [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Pritchard &lt;daniel@pritchard.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-26 07:31:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bythotrephes'>Bythotrephes Functional Response Data</h2><span id='topic+bythotrephes'></span>

<h3>Description</h3>

<p>Functional response dataset for <em>Bythotrephes</em> spp. (water fleas) preying on prey items of different sizes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bythotrephes)</code></pre>


<h3>Format</h3>

<p>A dataframe with the following structure:
</p>

<table>
<tr>
 <td style="text-align: right;">
		density: </td><td style="text-align: left;"> An integer. The initial density of prey</td>
</tr>
<tr>
 <td style="text-align: right;">
		eaten: </td><td style="text-align: left;"> An integer. The number of prey eaten</td>
</tr>
<tr>
 <td style="text-align: right;">
		alive:</td><td style="text-align: left;"> An integer. The number of prey left alive</td>
</tr>
<tr>
 <td style="text-align: right;">
		size: </td><td style="text-align: left;"> A factor with levels 'small', 'medium' and 'large'. The size of prey items.
	</td>
</tr>

</table>



<h3>Details</h3>

<p><em>Bythotrephes</em> spp. (water fleas) preying on prey items of different sizes. Prey were not replaced during the experiment and total experimental time was 12 hours. Provides a  example dataset for type-III and flexible exponent models. </p>


<h3>Source</h3>

<p>Daniel Barrios-O'Neill.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bythotrephes)
str(bythotrephes) 

with(bythotrephes, 
	plot(density, eaten, type='n', 
	xlab='Density', ylab='No. Prey Eaten'))
with(bythotrephes[bythotrephes$size=='large',], 
	points(density-0.2, eaten, pch=20, col=rgb(0.5,0,0,0.4)))
with(bythotrephes[bythotrephes$size=='medium',], 
	points(density, eaten, pch=20, col=rgb(0,0.5,0,0.4)))
with(bythotrephes[bythotrephes$size=='small',], 
	points(density+0.2, eaten, pch=20, col=rgb(0,0,0.5,0.4)))

legend(1,12, c('Large', 'Medium', 'Small'), pch=20, bty = 'n', 
    col=c(rgb(0.5,0,0), rgb(0,0.5,0), rgb(0,0,0.5)))
</code></pre>

<hr>
<h2 id='drawpoly'>Draw polygons</h2><span id='topic+drawpoly'></span><span id='topic+drawpoly.default'></span>

<h3>Description</h3>

<p>Draw a closed polygon delineated by an 'upper' and 'lower' y limit.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    drawpoly(x, upper, lower, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawpoly_+3A_x">x</code></td>
<td>
<p>The x values of the polygon</p>
</td></tr>
<tr><td><code id="drawpoly_+3A_upper">upper</code></td>
<td>
<p>The upper 'edge' of the polygon</p>
</td></tr>
<tr><td><code id="drawpoly_+3A_lower">lower</code></td>
<td>
<p>The lower 'edge' of the polygon</p>
</td></tr>
<tr><td><code id="drawpoly_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>polygon</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drawpoly</code> is a generic method for drawing polygons where the polygon is drawn as:
</p>
<p><code>polygon(x=c(x, rev(x), x[1]), y=c(upper, rev(lower), upper[1])</code>
</p>
<p><em>i.e.</em> a line following along the top edge (left-to-right along <code>x</code>) and back along the bottom edge (right-to-left along <code>x</code>). 
</p>
<p>The specific method implemented here for FRAIR is <code><a href="#topic+drawpoly.frboot">drawpoly.frboot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawpoly.frboot">drawpoly.frboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datx &lt;- 1:6
upper &lt;- datx*1.2
lower &lt;- datx*0.8
plot(datx, datx, type='n', ylim=c(0,10), xlab='X', ylab='Y')
drawpoly(datx, upper, lower, col=2)
points(datx, datx, pch=20)
</code></pre>

<hr>
<h2 id='fr_emdII'>EMD Type II Response</h2><span id='topic+fr_emdII'></span><span id='topic+emdII'></span><span id='topic+emdII_fit'></span><span id='topic+emdII_nll'></span>

<h3>Description</h3>

<p>The 'Ecological Models and Data in R' type-II decreasing prey function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    emdII_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    emdII_nll(a, h, P, T, X, Y)
    emdII(X, a, h, P, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_emdII_+3A_data">data</code></td>
<td>
<p>A dataframe containing X and Y.</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually 'a' and 'h'.</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually 'P' and 'T'.</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_a">a</code>, <code id="fr_emdII_+3A_h">h</code></td>
<td>
<p>Capture rate and handling time. Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_p">P</code>, <code id="fr_emdII_+3A_t">T</code></td>
<td>
<p>P: Number of predators. T: Total time available</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_emdII_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the type-II functional response model described in detail in Bolker (2008). With the exception of <em>P</em> these functions are identical to those used in <code><a href="#topic+rogersII">rogersII</a></code>. 
</p>
<p>The <code>emdII</code> function solves the random predator equation using the LambertW equation (using the <code><a href="lamW.html#topic+lambertW0">lambertW0</a></code> function from the <em>lamW</em> package), giving:
</p>
<p><code>X - lambertW0(a * h * X * exp(-a * (P * T - h * X)))/(a * h)</code>
</p>
<p>Note that generally speaking <em>P</em> is determined by the experimental design and is therefore usually provided as a 'fixed' variable. When <code class="reqn">P = 1</code> the results should be identical to those provided by <code><a href="#topic+rogersII">rogersII</a></code>.  
</p>
<p>This is exactly the function in Chapter 8 of Bolker (2008), which in turn presents examples from  Vonesh and Bolker (2005). Users are directed there for more information. 
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can call them directly if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>emdII_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package).  The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>emdII_nll</code> function to optimise <code>emdII</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Vonesh JR, Bolker BM (2005) Compensatory larval responses shift trade-offs associated with predator-induced hatching plasticity.  <em>Ecology</em> 86: 1580&ndash;1591. doi:10.1890/04-0535.
</p>
<p>Bolker, BM (2008) <em>Ecological Models and Data in R</em>. Princeton University Press, Princeton, NJ.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)
fitP1 &lt;- frair_fit(eaten~density, data=gammarus, 
                response='emdII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24, P=1))
fitP2 &lt;- frair_fit(eaten~density, data=gammarus, 
                response='emdII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24, P=2))
# Note that the coefficients are scaled to per prey item
coef(fitP1)
coef(fitP2)

# Should give identical answers to rogersII when P=1
rogII &lt;- frair_fit(eaten~density, data=gammarus, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24))
coef(fitP1)
coef(rogII)

stopifnot(coef(fitP1)[1]==coef(rogII)[1])
stopifnot(coef(fitP1)[2]==coef(rogII)[2])

</code></pre>

<hr>
<h2 id='fr_flexp'>Scaling Exponent Response, assuming replacement</h2><span id='topic+fr_flexp'></span><span id='topic+flexp'></span><span id='topic+flexp_fit'></span><span id='topic+flexp_nll'></span>

<h3>Description</h3>

<p>Scaling exponent response (assuming replacement) based on ideas dating back to Real (1977, at least)</p>


<h3>Usage</h3>

<pre><code class='language-R'>    flexp_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    flexp_nll(b, q, h, T, X, Y)
    flexp(X, b, q, h, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_flexp_+3A_data">data</code></td>
<td>
<p>A dataframe containing X and Y.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually 'a' and 'h'.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually 'T'.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_b">b</code>, <code id="fr_flexp_+3A_q">q</code>, <code id="fr_flexp_+3A_h">h</code></td>
<td>
<p>The search coefficient (<em>b</em>), scaling exponent (<em>q</em>) and the handling time (<em>h</em>). Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_t">T</code></td>
<td>
<p><em>T</em>, the total time available.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_flexp_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements a type-II response with a scaling exponent on the capture rate (<em>a</em>), based on the use of Hill's exponents described by Real (1977). When <code class="reqn">q \ge 0</code> the response becomes progressively more 'type-III-ish'. Integer values of <em>q</em> have useful interpretations based in enzymatic biochemistry but have been extended to many other fields (e.g. Flynn et al. 1997), including functional response analysis (Vucic-Pestic et al. 2010). Importantly, this function assumes that prey are replaced throughout the experiment (c.f. <code><a href="#topic+flexpnr">flexpnr</a></code> which does not). 
</p>
<p>The capture rate (<em>a</em>) follows the following relationship:
</p>
<p style="text-align: center;"><code class="reqn">a = b X^q</code>
</p>

<p>and then (<em>a</em>) is used to calculate the number of prey eaten (<em>Ne</em>) following the same relationship as <code><a href="#topic+hollingsII">hollingsII</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">N_e=\frac{a N_0 T}{1+a N_0 h}</code>
</p>

<p>where <em>b</em> is a search coefficient and other coefficients are as defined in <code><a href="#topic+hollingsII">hollingsII</a></code>. Indeed when <code class="reqn">q = 0</code>, then <code class="reqn">a = b</code> and the relationship collapses to traditional type-II <a href="#topic+hollingsII">Holling's Disc Equation</a>. There is, therefore, a useful test on <code class="reqn">q = 0</code> in the summary of the fit.  
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can call them directly if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>flexp_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package). The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>flexp_nll</code> function to optimise <code>flexp</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Real LA (1977) The Kinetics of Functional Response. <em>The American Naturalist</em> 111: 289&ndash;300.
</p>
<p>Vucic-Pestic O, Rall BC, Kalinkat G, Brose U (2010) Allometric functional response model: body masses constrain interaction strengths. <em>Journal of Animal Ecology</em> 79: 249&ndash;256. doi:10.1111/j.1365-2656.2009.01622.x.
</p>
<p>Flynn KJ, Fasham MJR, Hipkin CR (1997) Modelling the interactions between ammonium and nitrate uptake in marine phytoplankton. <em>Philosophical Transactions of the Royal Society B: Biological Sciences</em> 352: 1625&ndash;1645.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>, <code><a href="#topic+flexpnr">flexpnr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bythotrephes)
# NB: The flexpnr model is not correct for the experimental design of the bythotrephes data

expofit &lt;- frair_fit(eaten~density, data=bythotrephes, 
                response='flexpnr', start=list(b = 0.5, q = 1, h = 0.15), 
                fixed=list(T=12/24))
## Plot
plot(expofit)
lines(expofit, col=2)

## Inspect
summary(expofit$fit) 
</code></pre>

<hr>
<h2 id='fr_flexpnr'>Scaling Exponent Response, not assuming replacement</h2><span id='topic+fr_flexpnr'></span><span id='topic+flexpnr'></span><span id='topic+flexpnr_fit'></span><span id='topic+flexpnr_nll'></span>

<h3>Description</h3>

<p>Scaling exponent response (not assuming replacement) based on ideas dating back to Real (1977, at least)</p>


<h3>Usage</h3>

<pre><code class='language-R'>    flexpnr_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    flexpnr_nll(b, q, h, T, X, Y)
    flexpnr(X, b, q, h, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_flexpnr_+3A_data">data</code></td>
<td>
<p>A dataframe containing X and Y.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually 'a' and 'h'.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually 'T'.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_b">b</code>, <code id="fr_flexpnr_+3A_q">q</code>, <code id="fr_flexpnr_+3A_h">h</code></td>
<td>
<p>The search coefficient (<em>b</em>), scaling exponent (<em>q</em>) and the handling time (<em>h</em>). Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_t">T</code></td>
<td>
<p><em>T</em>, the total time available.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_flexpnr_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This combines a type-II non-replacement functional response (<em>i.e.</em> a <a href="#topic+rogersII">Roger's random predator equation</a>) with a scaling exponent on the capture rate (<em>a</em>). This function is generalised from that described in <code><a href="#topic+flexp">flexp</a></code> relaxing the assumption that prey are replaced throughout the experiment. 
</p>
<p>The capture rate (<em>a</em>) follows the following relationship:
</p>
<p style="text-align: center;"><code class="reqn">a = b X^q</code>
</p>

<p>and then (<em>a</em>) is used to calculate the number of prey eaten (<em>Ne</em>) following the same relationship as <code><a href="#topic+rogersII">rogersII</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">N_e=N_0(1-e^{(a(N_eh-T))})</code>
</p>

<p>where <em>b</em> is a search coefficient and other coefficients are as defined in <code><a href="#topic+rogersII">rogersII</a></code>. Because <em>Ne</em> appears on both side of the equation, the solution is found using Lambert's transcendental equation. FRAIR uses the <code><a href="lamW.html#topic+lambertW0">lambertW0</a></code> function from the <em>lamW</em> package and the internal function is:
</p>
<p><code>Ne &lt;- X - lambertW0(a * h * X * exp(-a * (T - h * X)))/(a * h)</code>
</p>
<p>where <code class="reqn">X = N0</code>. When <code class="reqn">q = 0</code>, then <code class="reqn">a = b</code> and the relationship collapses to traditional type-II Rogers' random predator equation. There is, therefore, a useful test on <code class="reqn">q = 0</code> in the summary of the fit. 
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can call them directly if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>flexpnr_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package). The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>flexpnr_nll</code> function to optimise <code>flexpnr</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Real LA (1977) The Kinetics of Functional Response. <em>The American Naturalist</em> 111: 289&ndash;300.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>, <code><a href="#topic+flexp">flexp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A 'type-II' example
data(gammarus)

rogfit &lt;- frair_fit(eaten~density, data=gammarus, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24))
expofit &lt;- frair_fit(eaten~density, data=gammarus, 
                response='flexpnr', start=list(b = 1.2, q = 0, h = 0.015), 
                fixed=list(T=40/24))
## Plot
plot(rogfit)
lines(rogfit)
lines(expofit, col=2)

## Inspect
summary(rogfit$fit)
summary(expofit$fit) # No evidence that q is different from zero...
AIC(rogfit$fit)
AIC(expofit$fit) # The exponent model is *not* preferred

# A 'type-III' example
data(bythotrephes)

rogfit &lt;- frair_fit(eaten~density, data=bythotrephes, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=12/24))
expofit &lt;- frair_fit(eaten~density, data=bythotrephes, 
                response='flexpnr', start=list(b = 1.2, q = 0, h = 0.015), 
                fixed=list(T=12/24))
## Plot
plot(rogfit)
lines(rogfit)
lines(expofit, col=2)

## Inspect
summary(rogfit$fit)
summary(expofit$fit) # Some evidence that q is different from zero...
AIC(rogfit$fit)
AIC(expofit$fit) # The exponent model is preferred
</code></pre>

<hr>
<h2 id='fr_hassIII'>Hassell's Type III Response</h2><span id='topic+fr_hassIII'></span><span id='topic+hassIII'></span><span id='topic+hassIII_fit'></span><span id='topic+hassIII_nll'></span>

<h3>Description</h3>

<p>Hassell's original type-III response (assuming replacement)</p>


<h3>Usage</h3>

<pre><code class='language-R'>    hassIII_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    hassIII_nll(b, c, h, T, X, Y)
    hassIII(X, b, c, h, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_hassIII_+3A_data">data</code></td>
<td>
<p>A data frame containing X and Y (at least).</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually <em>b</em>, <em>c</em> and <em>h</em>.</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually <em>T</em>.</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_b">b</code>, <code id="fr_hassIII_+3A_c">c</code>, <code id="fr_hassIII_+3A_h">h</code></td>
<td>
<p>Hassel's <em>b</em> and <em>c</em>, plus <em>h</em>, the handling time. Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_t">T</code></td>
<td>
<p><em>T</em>, the total time available.</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_hassIII_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the original Hassel's type-III functional response, assuming prey density is kept constant (i.e. a 'replacement' experimental design). In practice, constant prey density might be an unrealistic assumption, in which case users should consider the <code><a href="#topic+hassIIIr">hassIIIr</a></code> function instead. 
</p>
<p>In Hassel et al.'s original formulation, the capture rate <em>a</em> is assumed to vary with the prey density in the following hyperbolic relationship:
</p>
<p><code>a &lt;- (b*X)/(1+c*X)</code>
</p>
<p>where <code>b</code> and <code>c</code> are coefficients to be fitted and <em>X</em> is the initial prey density. This is the initial formulation of Hassell et al. (1977) and uses their naming conventions. The value for <em>a</em> is then used within a traditional Holling's disc equation (see <code><a href="#topic+hollingsII">hollingsII</a></code>). 
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can do so if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>hassIII_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package). The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>hassIII_nll</code> function to optimise <code>hassIII</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Hassell M, Lawton J, Beddington J (1977) Sigmoid functional responses by invertebrate predators and parasitoids. <em>Journal of Animal Ecology</em> 46: 249&ndash;262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datx &lt;- rep(c(1,2,3,4,6,12,24,50,100), times=10)
daty1 &lt;- round(hassIII(X=datx, 
            b=0.08*rnorm(length(datx), mean=1, sd=0.1), 
            c=0.1*rnorm(length(datx), mean=1, sd=0.1), 
            h=0.1*rnorm(length(datx), mean=1, sd=0.1), 
            T=1),0)
daty2 &lt;- round(hassIII(X=datx, 
            b=0.05*rnorm(length(datx), mean=1, sd=0.1), 
            c=0.1*rnorm(length(datx), mean=1, sd=0.1), 
            h=0.2*rnorm(length(datx), mean=1, sd=0.1), 
            T=1),0)
dat &lt;- data.frame(datx,daty1,daty2)

hassIII_1 &lt;- frair_fit(daty1~datx, data=dat, response='hassIII', 
        start=list(b=0.05, c=0.1, h=0.1), fixed=list(T=1))
hassIII_2 &lt;- frair_fit(daty2~datx, data=dat, response='hassIII', 
        start=list(b=0.05, c=0.1, h=0.1), fixed=list(T=1))

plot(c(0,100), c(0,15), type='n', xlab='Density', ylab='No. Eaten')
points(hassIII_1)
points(hassIII_2, col=4)
lines(hassIII_1)
lines(hassIII_2, col=4)

frair_compare(hassIII_1, hassIII_2)

</code></pre>

<hr>
<h2 id='fr_hassIIInr'>Hassell's Type III Response, without replacement</h2><span id='topic+fr_hassIIInr'></span><span id='topic+hassIIInr'></span><span id='topic+hassIIInr_fit'></span><span id='topic+hassIIInr_nll'></span>

<h3>Description</h3>

<p>Hassell's type-III response (not assuming replacement)</p>


<h3>Usage</h3>

<pre><code class='language-R'>    hassIIInr_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    hassIIInr_nll(b, c, h, T, X, Y)
    hassIIInr(X, b, c, h, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_hassIIInr_+3A_data">data</code></td>
<td>
<p>A data frame containing X and Y (at least).</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually <em>b</em>, <em>c</em> and <em>h</em>.</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually <em>T</em>.</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_b">b</code>, <code id="fr_hassIIInr_+3A_c">c</code>, <code id="fr_hassIIInr_+3A_h">h</code></td>
<td>
<p>Hassel's <em>b</em> and <em>c</em>, plus <em>h</em>, the handling time. Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_t">T</code></td>
<td>
<p><em>T</em>, the total time available.</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_hassIIInr_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements Hassel's Type-III extension to the 'random predator' functional response. This does not assume prey are replaced throughout the experiment (c.f. <code><a href="#topic+hassIII">hassIII</a></code>). The number of prey eaten (<em>Ne</em>) follow the same relationship defined for <a href="#topic+rogersII">the Roger's Type-II response</a>, however the capture rate (<em>a</em>) is assumed to vary with prey density in the following hyperbolic relationship:
</p>
<p><code>a &lt;- (b*X)/(1+c*X)</code>
</p>
<p>where <code>b</code> and <code>c</code> are coefficients to be fitted and <em>X</em> is the initial prey density. This is the initial formulation of Hassell et al. (1977) and uses their naming conventions. The value for <em>a</em> is then used within the Roger's Type-II 'random predator' equation (see <code><a href="#topic+rogersII">rogersII</a></code>). 
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can do so if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>hassIIInr_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package). The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>hassIIInr_nll</code> function to optimise <code>hassIIInr</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Hassell M, Lawton J, Beddington J (1977) Sigmoid functional responses by invertebrate predators and parasitoids. <em>Journal of Animal Ecology</em> 46: 249&ndash;262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datx &lt;- rep(c(1,2,3,4,6,12,24,50,100), times=10)
daty1 &lt;- round(hassIIInr(X=datx, 
            b=0.08*rnorm(length(datx), mean=1, sd=0.1), 
            c=0.1*rnorm(length(datx), mean=1, sd=0.1), 
            h=0.08*rnorm(length(datx), mean=1, sd=0.1), 
            T=1),0)
daty2 &lt;- round(hassIIInr(X=datx, 
            b=0.05*rnorm(length(datx), mean=1, sd=0.1), 
            c=0.08*rnorm(length(datx), mean=1, sd=0.1), 
            h=0.1*rnorm(length(datx), mean=1, sd=0.1), 
            T=1),0)
dat &lt;- data.frame(datx,daty1,daty2)

hassIIInr_1 &lt;- frair_fit(daty1~datx, data=dat, response='hassIIInr', 
        start=list(b=0.05, c=0.1, h=0.1), fixed=list(T=1))
hassIIInr_2 &lt;- frair_fit(daty2~datx, data=dat, response='hassIIInr', 
        start=list(b=0.05, c=0.1, h=0.1), fixed=list(T=1))

plot(c(0,100), c(0,15), type='n', xlab='Density', ylab='No. Eaten')
points(hassIIInr_1)
points(hassIIInr_2, col=4)
lines(hassIIInr_1)
lines(hassIIInr_2, col=4)

frair_compare(hassIIInr_1, hassIIInr_2)
</code></pre>

<hr>
<h2 id='fr_hollingsII'>Holling's Original Type II Response</h2><span id='topic+fr_hollingsII'></span><span id='topic+hollingsII'></span><span id='topic+hollingsII_fit'></span><span id='topic+hollingsII_nll'></span>

<h3>Description</h3>

<p>Holling's Type II predator-prey function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    hollingsII_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    hollingsII_nll(a, h, T, X, Y)
    hollingsII(X, a, h, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_hollingsII_+3A_data">data</code></td>
<td>
<p>A dataframe containing X and Y.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually 'a' and 'h'.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually 'T'.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_a">a</code>, <code id="fr_hollingsII_+3A_h">h</code></td>
<td>
<p>Capture rate and handling time. Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_t">T</code></td>
<td>
<p><em>T</em>, the total time available.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_hollingsII_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the Hollings original type-II functional response, otherwise known as the 'disc equation'. An important assumption of this equation is that prey density remains constant (<em>i.e.</em> a 'replacement' experimental design). In practice this is often not the case and often the Roger's 'random predator' equation may be more appropriate (see <code><a href="#topic+rogersII">rogersII</a></code>).
</p>
<p>In Holling's original formulation the number of prey eaten (<em>Ne</em>) follows the relationship:
</p>
<p style="text-align: center;"><code class="reqn">N_e=\frac{a N_0 T}{1+a N_0 h}</code>
</p>

<p>Where <code class="reqn">N_0</code> is the initial number of prey and <em>a</em>, <em>h</em> and <em>T</em> are the capture rate, handling time and the total time available, receptively. It is implemented internally in FRAIR as: 
</p>
<p><code>Ne &lt;- (a*X*T)/(1+a*X*h)</code>
</p>
<p>where <code class="reqn">X = N_0</code>. 
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can call them directly if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>rogersII_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package).  The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>rogersII_nll</code> function to optimise <code>rogersII</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Bolker BM (2008) <em>Ecological Models and Data in R</em>. Princeton University Press, Princeton, NJ.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datx &lt;- rep(c(1,2,3,4,6,12,24,50,100), times=10)
daty1 &lt;- round(hollingsII(X=datx, 
            a=0.75*rnorm(length(datx), mean=1, sd=0.1), 
            h=0.1*rnorm(length(datx), mean=1, sd=0.1), 
            T=1),0)
daty2 &lt;- round(hollingsII(X=datx, 
            a=0.75*rnorm(length(datx), mean=1, sd=0.1), 
            h=0.01*rnorm(length(datx), mean=1, sd=0.1), 
            T=1),0)
dat &lt;- data.frame(datx,daty1,daty2)

hollII_1 &lt;- frair_fit(daty1~datx, data=dat, response='hollingsII', 
        start=list(a=1, h=0.1), fixed=list(T=1))
hollII_2 &lt;- frair_fit(daty2~datx, data=dat, response='hollingsII', 
        start=list(a=1, h=0.01), fixed=list(T=1))

plot(c(0,100), c(0,40), type='n', xlab='Density', ylab='No. Eaten')
points(hollII_1)
points(hollII_2, col=4)
lines(hollII_1)
lines(hollII_2, col=4)

frair_compare(hollII_1, hollII_2)
</code></pre>

<hr>
<h2 id='fr_rogersII'>Rogers' Type II Response</h2><span id='topic+fr_rogersII'></span><span id='topic+rogersII'></span><span id='topic+rogersII_fit'></span><span id='topic+rogersII_nll'></span>

<h3>Description</h3>

<p>Rogers' Type II decreasing prey function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    rogersII_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    rogersII_nll(a, h, T, X, Y)
    rogersII(X, a, h, T)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_rogersII_+3A_data">data</code></td>
<td>
<p>A dataframe containing X and Y.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually 'a' and 'h'.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually 'T'.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_a">a</code>, <code id="fr_rogersII_+3A_h">h</code></td>
<td>
<p>Capture rate and handling time. Usually items to be optimised.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_t">T</code></td>
<td>
<p><em>T</em>, the total time available.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_rogersII_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the Rogers' 'random predator' type-II functional response. This does not assume prey are replaced throughout the experiment (c.f. <code><a href="#topic+hollingsII">hollingsII</a></code>). The number of prey eaten (<code class="reqn">N_e</code>) follows the relationship:
</p>
<p style="text-align: center;"><code class="reqn">N_e=N_0(1-e^{(a(N_eh-T))})</code>
</p>

<p>Where <code class="reqn">N_0</code> is the initial number of prey and <em>a</em>, <em>h</em> and <em>T</em> are the capture rate, handling time and the total time available, respectively. The fact that <code class="reqn">N_e</code> appears on both side of the equation, poses some problems, but can be efficiently dealt with using Lambert's transcendental equation (Bolker, 2008). FRAIR uses the <code><a href="lamW.html#topic+lambertW0">lambertW0</a></code> function from the <em>lamW</em> package and uses this function internally as:
</p>
<p><code>Ne &lt;- X - lambertW0(a * h * X * exp(-a * (T - h * X)))/(a * h)</code>
</p>
<p>where <code class="reqn">X = N_0</code>. For further information users are directed to Chapter 8 (and preceding chapters, if needed) of Bolker (2008) where this approach is discussed in depth. Note that Bolker (2008) uses an implementation that 'partitions' the <em>a</em> and <em>h</em> coefficients between multiple prey items. This code is implemented in FRAIR as <code><a href="#topic+emdII">emdII</a></code>.
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can call them directly if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>hollingsII_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package). The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>rogersII_nll</code> function to optimise <code>rogersII</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Note</h3>

<p>Note that although Rogers (1972) is the most commonly cited reference for this equation, Royama (1971) described it one year earlier than Rogers and thus should also be given credit. 
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Bolker BM (2008) <em>Ecological Models and Data in R</em>. Princeton University Press, Princeton, NJ.
Rogers, D. (1972). Random search and insect population models. The Journal of Animal Ecology, 369-383.
Royama, T. (1971). A comparative study of models for predation and parasitism. Researches on Population Ecology, 13, 1-91.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)

pulex &lt;- gammarus[gammarus$spp=='G.pulex',]
celt &lt;- gammarus[gammarus$spp=='G.d.celticus',]

pulexfit &lt;- frair_fit(eaten~density, data=pulex, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24))
celtfit &lt;- frair_fit(eaten~density, data=celt, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24))

plot(c(0,30), c(0,30), type='n', xlab='Density', ylab='No. Eaten')
points(pulexfit)
points(celtfit, col=4)
lines(pulexfit)
lines(celtfit, col=4)

frair_compare(pulexfit, celtfit)

## Not run: 
pulexfit_b &lt;- frair_boot(pulexfit)
celtfit_b &lt;- frair_boot(celtfit)
confint(pulexfit_b)
confint(celtfit_b)

## End(Not run)
</code></pre>

<hr>
<h2 id='fr_typeI'>Type I Response</h2><span id='topic+fr_typeI'></span><span id='topic+typeI'></span><span id='topic+typeI_fit'></span><span id='topic+typeI_nll'></span>

<h3>Description</h3>

<p>A generic type-I (linear) response.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    typeI_fit(data, samp, start, fixed, boot=FALSE, windows=FALSE)
    typeI_nll(a, T, X, Y)
    typeI(X, a, T)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr_typeI_+3A_data">data</code></td>
<td>
<p>A dataframe containing X and Y.</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_samp">samp</code></td>
<td>
<p>A vector specifying the rows of data to use in the fit. Provided by <code>boot()</code> or manually, as required.</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for items to be optimised.  Usually 'a'.</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_fixed">fixed</code></td>
<td>
<p>A names list. 'Fixed data' (not optimised). Usually 'T'.</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_boot">boot</code></td>
<td>
<p>A logical. Is the function being called for use by <code>boot()</code>?</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_windows">windows</code></td>
<td>
<p>A logical. Is the operating system Microsoft Windows?</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_a">a</code></td>
<td>
<p>The capture rate</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_t">T</code></td>
<td>
<p>T: Total time available</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_x">X</code></td>
<td>
<p>The X variable. Usually prey density.</p>
</td></tr>
<tr><td><code id="fr_typeI_+3A_y">Y</code></td>
<td>
<p>The Y variable.  Usually the number of prey consumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements a simple type-I, or linear functional response. This is helpful when the response is known (or suspected) to be handling time independent. It is implemented as: 
</p>
<p style="text-align: center;"><code class="reqn">N_e = a N_0 T</code>
</p>

<p>where <em>a</em> is the capture rate, <em>T</em> is the total time available and <code class="reqn">N_0</code> (== X) is the initial prey density. 
</p>
<p>None of these functions are designed to be called directly, though they are all exported so that the user can call them directly if desired. The intention is that they are called via <code><a href="#topic+frair_fit">frair_fit</a></code>, which calls them in the order they are specified above.
</p>
<p><code>typeI_fit</code> does the heavy lifting and also pulls double duty as the <code>statistic</code> function for bootstrapping (<em>via</em> <code>boot()</code> in the boot package).  The <code>windows</code> argument if required to prevent needless calls to <code>require(frair)</code> on platforms that can manage sane parallel processing.
</p>
<p>The core fitting is done by <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package and users are directed there for more information. <code>mle2</code> uses the <code>typeI_nll</code> function to optimise <code>typeI</code>.
</p>
<p>Further references and recommended reading can be found on the help page for <a href="#topic+frair_fit">frair_fit</a>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>datx &lt;- rep(1:60, times=5)
r1 &lt;- rnorm(60*5, mean = 0.25, sd = 0.1)
r2 &lt;- rnorm(60*5, mean = 0.75, sd = 0.1)
r1[r1&gt;1] &lt;- 1
r2[r2&gt;1] &lt;- 1
daty1 &lt;- abs(round(r1*datx, 0))
daty2 &lt;- abs(round(r2*datx, 0))
dat &lt;- data.frame(datx,daty1,daty2)

TI1 &lt;- frair_fit(daty1~datx, data=dat, response='typeI', 
        start=list(a=0.5), fixed=list(T=1))
TI2 &lt;- frair_fit(daty2~datx, data=dat, response='typeI', 
        start=list(a=0.5), fixed=list(T=1))

plot(c(0,60), c(0,60), type='n', xlab='Density', ylab='No. Eaten')
points(TI1)
points(TI2, col=4)
lines(TI1)
lines(TI2, col=4)

# Test with frair_compare
frair_compare(TI1, TI2)

## Not run: 
# Test with a big stick
TI1b &lt;- frair_boot(TI1)
TI2b &lt;- frair_boot(TI2)
confint(TI1b)
confint(TI2b)

plot(c(0,60), c(0,60), type='n', xlab='Density', ylab='No. Eaten')
drawpoly(TI1b, col=1)
drawpoly(TI2b, col=4)
points(TI1b, pch=20)
points(TI2b, pch=20, col=4)

## End(Not run)

</code></pre>

<hr>
<h2 id='frair_boot'>Bootstrap a predator-prey functional response.</h2><span id='topic+frair_boot'></span>

<h3>Description</h3>

<p>Bootstraps a previously fitted predator-prey functional response and returns data in a consistent, predictable way, exposing some useful methods.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frair_boot(frfit, start=NULL, strata=NULL, nboot=999, 
            para=TRUE, ncores=NaN, WARN.ONLY=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_boot_+3A_frfit">frfit</code></td>
<td>
<p>An object returned by <code><a href="#topic+frair_fit">frair_fit</a></code></p>
</td></tr>
<tr><td><code id="frair_boot_+3A_start">start</code></td>
<td>
<p>An optional named list. See Details.</p>
</td></tr>
<tr><td><code id="frair_boot_+3A_strata">strata</code></td>
<td>
<p>A character string. Specifies a column in the original data.</p>
</td></tr>
<tr><td><code id="frair_boot_+3A_nboot">nboot</code></td>
<td>
<p>An integer. How many bootstraps to perform?</p>
</td></tr>
<tr><td><code id="frair_boot_+3A_para">para</code></td>
<td>
<p>A logical. Should the bootstrapping be performed in parallel?</p>
</td></tr>
<tr><td><code id="frair_boot_+3A_ncores">ncores</code></td>
<td>
<p>An integer. The number of cores to use for parallelisation. See Details.</p>
</td></tr>
<tr><td><code id="frair_boot_+3A_warn.only">WARN.ONLY</code></td>
<td>
<p>A logical. If true some errors are suppressed. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a simple, consistent way to generate bootstrapped estimates from a functional response fit. 
</p>
<p>If <code>start</code> is not provided, starting values for the bootstrapping are drawn from the original fit.  This interface is provided so that a single set of starting parameters (e.g. a 'global' estimate) can be used when bootstrapping different functional response fits (e.g. different treatments).
</p>
<p>Non-parametric bootstrapping and parallelisation is handled by <code><a href="boot.html#topic+boot">boot</a></code> from the boot package.  Currently, if you request bootstrapped fits and <code>para=TRUE</code> (the default), then the function will attempt to use all except one available core. Note this may affect performance of other tasks while the bootstrap is underway!
</p>
<p>If more than 10% of the bootstrapped fits fail, a warning is generated, and if more than 50% of the fits fail, an error is thrown and nothing is returned.  These are sensible defaults, but if you are very sure that you know what you are doing, you can suppress this with <code>WARN.ONLY=TRUE</code> (a warning is thrown instead).  
</p>


<h3>Value</h3>

<p>This function returns a named list of class <code>frboot</code> with the following named items:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original x data supplied to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The original y data supplied to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>A string. The fitted response.</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>A string. The right hand side of <code>formula</code>.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>A string. The left hand side of <code>formula</code>.</p>
</td></tr>
<tr><td><code>optimvars</code></td>
<td>
<p>A character vector. The optimised values (passed to <code>start</code>).</p>
</td></tr>
<tr><td><code>fixedvars</code></td>
<td>
<p>A character vector. The fixed values (passed to <code>fixed</code>).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A named numeric. All coefficients needed to draw the optimised curve.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A nboot-by-n numeric matrix. Where each row represents one bootstrap sample.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The raw object returned by the fitting procedure (response specific).</p>
</td></tr>
<tr><td><code>bootcoefs</code></td>
<td>
<p>A named numeric matrix. The bootstrapped coefficients.</p>
</td></tr>
<tr><td><code>n_failed</code></td>
<td>
<p>The number of failed fits.</p>
</td></tr>
<tr><td><code>n_duplicated</code></td>
<td>
<p>The number of fits that were duplicates.</p>
</td></tr>
<tr><td><code>n_boot</code></td>
<td>
<p>The number of (requested) bootstrapped fits.</p>
</td></tr>
<tr><td><code>stratified</code></td>
<td>
<p>Was a stratified bootstrap performed?</p>
</td></tr>
</table>
<p>Objects of class <code>frboot</code> have print, confint, plot, lines and drawpoly methods defined. See the help <a href="#topic+frair_boot_methods">for those methods</a> for more information.  
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_boot_methods">frair_boot_methods</a></code>, <code><a href="#topic+frair_fit">frair_fit</a></code>, <code><a href="#topic+fr_rogersII">fr_rogersII</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)
frair_responses() # See what is available
# A typeII fit
outII &lt;- frair_fit(eaten~density, data=gammarus, response='rogersII', 
        start=list(a = 1.2, h = 0.015), fixed=list(T=40/24))
        
## Not run: 
outIIb &lt;- frair_boot(outII) # Slow
confint(outIIb)

# Illustrate bootlines
plot(outIIb, xlim=c(0,30), type='n', main='All bootstrapped lines')
lines(outIIb, all_lines=TRUE)
points(outIIb, pch=20, col=rgb(0,0,0,0.2))

# Illustrate bootpolys
plot(outIIb, xlim=c(0,30), type='n', main='Empirical 95 percent CI')
drawpoly(outIIb, col=rgb(0,0.5,0))
points(outIIb, pch=20, col=rgb(0,0,0,0.2))

## End(Not run)
</code></pre>

<hr>
<h2 id='frair_boot_methods'>frair methods</h2><span id='topic+frair_boot_methods'></span><span id='topic+print.frboot'></span><span id='topic+confint.frboot'></span><span id='topic+plot.frboot'></span><span id='topic+lines.frboot'></span><span id='topic+drawpoly.frboot'></span><span id='topic+print.frconf'></span>

<h3>Description</h3>

<p>Documentation for methods for class frboot</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frboot'
print(x, ...)
## S3 method for class 'frboot'
confint(object, parm='all', level=0.95, ..., citypes='all')
## S3 method for class 'frboot'
plot(x, xlab=x$xvar, ylab=x$yvar, ...)
## S3 method for class 'frboot'
lines(x, all_lines=FALSE, tozero=FALSE, bootcol=1, bootalpha=1/sqrt(x$n_boot), ...)
## S3 method for class 'frboot'
drawpoly(x, ..., probs=c(0.025, 0.975), tozero=FALSE)

## S3 method for class 'frconf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_boot_methods_+3A_x">x</code>, <code id="frair_boot_methods_+3A_object">object</code></td>
<td>
<p>Output from a call to <code>frair_boot</code> (or <code>confint.frboot</code>).</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_parm">parm</code></td>
<td>
<p>A character vector. Which parameter to get CIs for? See Details.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_level">level</code></td>
<td>
<p>A numeric. The confidence limit for CIs.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_citypes">citypes</code></td>
<td>
<p>A character vector. What kind of CI? See Details.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_all_lines">all_lines</code></td>
<td>
<p>A logical. Should the bootstrapped results be plotted? See Details.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_tozero">tozero</code></td>
<td>
<p>A logical. Should the line be drawn to the origin? See Details.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_bootcol">bootcol</code></td>
<td>
<p>A valid colour for the bootstrapped lines.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_bootalpha">bootalpha</code></td>
<td>
<p>A numeric (0-1). A transparency for the (inevitably overlapping) lines.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_probs">probs</code></td>
<td>
<p>Lower and upper tails for confidence interval polygons. See <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="frair_boot_methods_+3A_...">...</code></td>
<td>
<p>Other items passed to underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This documents standard methods for FRAIR objects of class <code>frboot</code>. However, because standard naming conventions have been used, some undocumented utility functions might also work (e.g. <code><a href="stats.html#topic+coefficients">coefficients</a></code>)
</p>
<p>The code underlying <code>confint.frboot</code> is quite complex and relies heavily on the excellent work done by Brian Ripley in <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. Some of the complexity of <code>boot.ci</code> is hidden, but, like all FRAIR objects you can access the original method by passing the output directly (e.g. <code>boot.ci(object$fit)</code>). 
</p>
<p>Like <code><a href="boot.html#topic+print.bootci">print.bootci</a></code> the <code>print()</code> method for objects produced by <code>print.frboot</code> will report potentially unstable intervals. However, these are calculated and returned by <code>confint.frboot</code>, not when <code>print()</code> is called (see Value, below). When calling <code>confint.frboot</code> you can request (a combination of) different intervals. The default <code>'all'</code> is equivalent to <code>c('norm', 'basic', 'stud', 'perc', 'bca')</code> which are the Normal approximation, Basic, Studentised, Percentile and BCa intervals, respectively. Each has strengths and weaknesses which the user should be aware of.  
</p>
<p><code>lines</code> and <code>drawpoly</code> only add lines or polygons to an existing plot, so an active graphics device needs to be present. By default <code>all</code> is FALSE. The simple reason for this is because the code is a little slow (on some devices), so currently it is an 'opt-in' option.
</p>
<p><code>drawpoly</code> draws empirical confidence intervals. The intervals are constructed by evaluating every set of bootstrapped coefficients at:
</p>
<p><code>seq(from=min(x$x), to=max(x$x), length.out = 50)</code>.  
</p>
<p>and then calculating the empirical confidence limits at each value of <em>x</em> by:
</p>
<p><code>apply(val, 2, quantile, na.rm=T, probs=probs)</code>
</p>
<p>Note that this is a rough approximation of a bootstrapped confidence interval and does not account for some of the intricacies (e.g. bootstrap bias) described in <a href="boot.html#topic+boot.ci">boot.ci</a>.
</p>
<p>Note also, that if <code>tozero</code> is TRUE, then both <code>lines</code> and <code>drawpoly</code> attempt to draw to zero by evaluating every set of bootstrapped coefficients at:
</p>
<p><code>seq(from=0, to=max(x$x), length.out = 50)</code> 
</p>
<p>If the coefficients provided by a fit to the orginal data produce a value that is undefined at zero, then these functions will plot lines to a small, non-zero number (1e-04) instead (with a warning). However, this does not guarantee that all of the values produced by the bootstrapped coefficients will produce sensible values. Clearly the intention here is to provide a nice-looking representation of the fitted curve and it is up to the user to determine <em>why</em> their desired curve is undefined at zero.
</p>


<h3>Value</h3>

<p><code>confint.frboot</code> returns a nested list with m items at the top level and n items at the second level, where m is the number of coefficients and n is the number of types of confidence intervals. Each named object at the second level is a list containing:
</p>
<table>
<tr><td><code>lower</code></td>
<td>
<p>The upper limit.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>The lower limit.</p>
</td></tr>
<tr><td><code>bootciout</code></td>
<td>
<p>The output from <code>boot.ci</code> (if successful; NA otherwise).</p>
</td></tr>
</table>
<p>and optionally:
</p>
<table>
<tr><td><code>errors</code></td>
<td>
<p>The error(s) encountered by <code>boot.ci</code>.</p>
</td></tr>
<tr><td><code>warnings</code></td>
<td>
<p>The warning(s) encountered by <code>boot.ci</code>, plus a warning if extreme values were used.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>A comment on potential instability of intervals, if justified.</p>
</td></tr>
</table>
<p>These last two items combine 'true' warnings and the tests for interval stability described in <code><a href="boot.html#topic+print.bootci">print.bootci</a></code>.
</p>
<p>All confidence intervals are calculated on the original scale. If you want to calculate intervals on a transformed scale, call <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> directly using the <code>boot.ci(object$fit)</code> syntax.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_boot">frair_boot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example is not run to save CRAN build server time...
## Not run: 
data(gammarus)

# Holling's is the wrong fit for these data based on the experimental design
# But it runs more quickly, so is a useful demonstration
outhol &lt;- frair_fit(eaten~density, data=gammarus, response='hollingsII', 
        start=list(a = 1, h = 0.08), fixed=list(T=40/24))
outholb &lt;- frair_boot(outhol)

confint(outholb)

# Illustrate bootlines
plot(outholb, xlim=c(0,30), type='n', main='All bootstrapped lines')
lines(outholb, all_lines=TRUE)
points(outholb, pch=20, col=rgb(0,0,0,0.2))

# Illustrate bootpolys
plot(outholb, xlim=c(0,30), type='n', main='Empirical 95 percent CI')
drawpoly(outholb, col=rgb(0,0.5,0))
points(outholb, pch=20, col=rgb(0,0,0,0.2))

## End(Not run)
</code></pre>

<hr>
<h2 id='frair_compare'>Test the difference between two functional response fits</h2><span id='topic+frair_compare'></span><span id='topic+typeI_diff'></span><span id='topic+typeI_nll_diff'></span><span id='topic+rogersII_diff'></span><span id='topic+rogersII_nll_diff'></span><span id='topic+hollingsII_diff'></span><span id='topic+hollingsII_nll_diff'></span><span id='topic+hassIII_diff'></span><span id='topic+hassIII_nll_diff'></span><span id='topic+hassIIInr_diff'></span><span id='topic+hassIIInr_nll_diff'></span><span id='topic+emdII_diff'></span><span id='topic+emdII_nll_diff'></span><span id='topic+flexp_diff'></span><span id='topic+flexp_nll_diff'></span><span id='topic+flexpnr_diff'></span><span id='topic+flexpnr_nll_diff'></span>

<h3>Description</h3>

<p>Explicitly model, and then test, the difference between two functional response fits.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frair_compare(frfit1, frfit2, start = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_compare_+3A_frfit1">frfit1</code></td>
<td>
<p>An object of class <code>frfit</code></p>
</td></tr>
<tr><td><code id="frair_compare_+3A_frfit2">frfit2</code></td>
<td>
<p>An object of class <code>frfit</code></p>
</td></tr>
<tr><td><code id="frair_compare_+3A_start">start</code></td>
<td>
<p>A named numeric list with starting values for the combined fit. See Details.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a sensible test of the optimised coefficients between two functional responses fitted by <code><a href="#topic+frair_fit">frair_fit</a></code>. This is achieved by explicitly modelling a 'difference' (delta) parameter for each optimised variable following the advice outlined in Juliano (2001). Briefly, consider the following Hollings type-II model:
</p>
<p><code>a*X*T/(1+a*X*h)</code>
</p>
<p>the model containing delta parameters becomes:
</p>
<p><code>(a-Da*grp)*X*T/(1+(a-Da*grp)*X*(h-Dh*grp))</code>
</p>
<p>where <code>grp</code> is a dummy coding variable and <code>Da</code> and <code>Dh</code> are the delta parameters. Here, the first functional response fit (<code>frfit1</code>) is coded <code>grp=0</code> and the second fit (<code>frfit2</code>) is coded <code>grp=1</code>. Therefore<code>Da</code> and <code>Dh</code> represent the difference between the two modelled coefficients and the standard output from the maximum likelihood fitting explicitly tests the null hypothesis of no difference between the two groups. 
</p>
<p>The difference model is re-fit to the combined data in <code>frfit1</code> and <code>frfit2</code> using the same maximum likelihood approaches outlined in <code><a href="#topic+frair_fit">frair_fit</a></code>. 
</p>
<p>This function could be seen as a less computationally intensive alternative to bootstrapping but relies on <code><a href="bbmle.html#topic+mle2">mle2</a></code> successfully returning estimates of the standard error. <code>mle2</code> does this by inverting a Hessian matrix, a procedure which might not always be successful. 
</p>
<p>Future versions of FRAIR will look to improve the integration between <code>mle2</code> and allow users access to the various Hessian control parameters. In the meantime, the following delta functions are exported so users can 'roll their own' maximum likelihood implementation using this approach:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Original Function        </td><td style="text-align: left;"> Difference Function    </td><td style="text-align: left;"> Difference NLL Function</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+typeI">typeI</a></code>      </td><td style="text-align: left;"> <code>typeI_diff</code>      </td><td style="text-align: left;"> <code>typeI_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hollingsII">hollingsII</a></code> </td><td style="text-align: left;"> <code>hollingsII_diff</code> </td><td style="text-align: left;"> <code>hollingsII_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rogersII">rogersII</a></code>   </td><td style="text-align: left;"> <code>rogersII_diff</code>   </td><td style="text-align: left;"> <code>rogersII_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hassIII">hassIII</a></code>    </td><td style="text-align: left;"> <code>hassIII_diff</code>    </td><td style="text-align: left;"> <code>hassIII_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hassIIInr">hassIIInr</a></code>  </td><td style="text-align: left;"> <code>hassIIInr_diff</code>  </td><td style="text-align: left;"> <code>hassIIInr_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    
    <code><a href="#topic+emdII">emdII</a></code>      </td><td style="text-align: left;"> <code>emdII_diff</code>      </td><td style="text-align: left;"> <code>emd_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+flexp">flexp</a></code>      </td><td style="text-align: left;"> <code>flexp_diff</code>      </td><td style="text-align: left;"> <code>flexp_nll_diff</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+flexpnr">flexpnr</a></code>    </td><td style="text-align: left;"> <code>flexpnr_diff</code>    </td><td style="text-align: left;"> <code>flexpnr_nll_diff</code>
  </td>
</tr>

</table>



<h3>Value</h3>

<p>Prints the results of the test to screen and invisibly returns on object of class <code>frcompare</code> inheriting from <code>class(list)</code> containing:
</p>
<table>
<tr><td><code>frfit1</code></td>
<td>
<p>The first FR fit, as supplied.</p>
</td></tr>
<tr><td><code>frfit2</code></td>
<td>
<p>The second FR fit, as supplied.</p>
</td></tr>
<tr><td><code>test_fit</code></td>
<td>
<p>The output of the re-fitted model.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>Coefficients from the test that are otherwise printed to screen.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Juliano SA (2001) Nonlinear curve fitting: Predation and functional response curves. In: Scheiner SM, Gurevitch J (eds). Design and analysis of ecological experiments. Oxford University Press, Oxford, United Kingdom. pp 178&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)

pulex &lt;- gammarus[gammarus$spp=='G.pulex',]
celt &lt;- gammarus[gammarus$spp=='G.d.celticus',]

pulexfit &lt;- frair_fit(eaten~density, data=pulex, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24))
celtfit &lt;- frair_fit(eaten~density, data=celt, 
                response='rogersII', start=list(a = 1.2, h = 0.015), 
                fixed=list(T=40/24))
# The following tests the null hypothesis that the 
# true difference between the coefficients is zero:
frair_compare(pulexfit, celtfit) # Reject null for 'h', do not reject for 'a'

## Not run: 
# Provides a similar conclusion to bootstrapping followed by 95% CIs
pulexfit_b &lt;- frair_boot(pulexfit)
celtfit_b &lt;- frair_boot(celtfit)
confint(pulexfit_b)
confint(celtfit_b) # 'a' definitely overlaps

## End(Not run)
</code></pre>

<hr>
<h2 id='frair_fit'>Fit predator-prey functional responses.</h2><span id='topic+frair_fit'></span>

<h3>Description</h3>

<p>Fits predator-prey functional responses and returns data in a consistent, predictable way, exposing some useful methods.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frair_fit(formula, data, response, start=list(), fixed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_fit_+3A_formula">formula</code></td>
<td>
<p>A simple formula of the form <code>y ~ x</code>.</p>
</td></tr>
<tr><td><code id="frair_fit_+3A_data">data</code></td>
<td>
<p>The dataframe containing <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="frair_fit_+3A_response">response</code></td>
<td>
<p>A string denoting the response to fit.  See Details.</p>
</td></tr>
<tr><td><code id="frair_fit_+3A_start">start</code></td>
<td>
<p>A named list. Starting values for optimised parameters.</p>
</td></tr>
<tr><td><code id="frair_fit_+3A_fixed">fixed</code></td>
<td>
<p>A named list. Values that are not optimised.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frair_fit</code> is a utility function which helps users fit common non-linear predator-prey curves to integer data. It uses maximum likelihood estimation, via <code><a href="bbmle.html#topic+mle2">mle2</a></code> from the <code>bbmle</code> package.  
</p>
<p>The response requested must be known to FRAIR. To establish what is supported, inspect the output from <code>frair_responses()</code>. All parameters listed by <code>frair_responses()</code> (except <code>X</code>) must be provided in either <code>start</code> or <code>fixed</code> and some guidance is given on the help pages for each function about what should (and should not) be optimised.
</p>
<p>Generally speaking fitting non-linear curves to ecological datasets can be challenging. Approaches to fitting predator-prey functional response curves are described in further detail by Juliano (2001) and Bolker (2008). Many of the pitfalls (along with very sound advice) in non-linear curve fitting in general are described by Bolker <em>et al.</em> 2013. Users are directed there for more information.  
</p>
<p>Note that currently all fits encoded by FRAIR use the <code><a href="stats.html#topic+optim">optim</a></code> optimiser with a non-default number of iterations (5000 [frair] vs. 500 [default]) and that all fits except <code>typeI</code> use the 'Nelder-Mead' method (see Note). This is different from the mle2 default, which currently (bbmle v. 1.0.15) uses the 'BFGS' method. 
</p>
<p><code>mle2</code> is clever inasmuch as it will return fitted values even if inverting the Hessian matrix at the optimum fails. However, this will result in a warning along the lines of: 
</p>
<pre>Warning message:
In mle2(fit, start = start, fixed = fixed, data = list(X = dat$X, :
  couldn't invert Hessian
</pre>
<p>If this happens it could mean many things, but generally speaking it is indicative of a poor fit to the data. You might consider:
</p>

<ul>
<li><p> Checking the data for transcription errors or outliers
</p>
</li>
<li><p> Trying different starting values
</p>
</li>
<li><p> Trying a different (simpler) curve
</p>
</li>
<li><p> Fitting the curve outside of FRAIR using another optimiser or another approach (see the Note, below)
</p>
</li>
<li><p> Collecting more data
</p>
</li></ul>

<p>Note that the advice given in <a href="bbmle.html#topic+mle2">mle2</a> to use the 'Nelder-Mead' method, is largely redundant because this is already the default in FRAIR (though you could try the 'BFGS' method quite safely...)
</p>
<p>If convergence (i.e. fitting) fails for other reasons, see the manual page of <code><a href="stats.html#topic+optim">optim</a></code>. 
</p>


<h3>Value</h3>

<p>This function returns a named list of class <code>frfit</code> with the following named items:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original x data supplied to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The original y data supplied to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>A string. The fitted response.</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>A string. The right hand side of <code>formula</code>.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>A string. The left hand side of <code>formula</code>.</p>
</td></tr>
<tr><td><code>optimvars</code></td>
<td>
<p>A character vector. The optimised values (passed to <code>start</code>).</p>
</td></tr>
<tr><td><code>fixedvars</code></td>
<td>
<p>A character vector. The fixed values (passed to <code>fixed</code>).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A named numeric. All coefficients needed to draw the optimised curve.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A numeric vector. Always <code>samp=c(1:nrow(data))</code> (<em>c.f.</em> class <code><a href="#topic+frair_boot">frair_boot</a></code>).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The raw object returned by <code><a href="bbmle.html#topic+mle2">mle2</a></code>.</p>
</td></tr>
</table>
<p>Objects of class <code>frfit</code> have print, plot and lines methods defined. See the help <a href="#topic+frair_fit_methods">for those methods</a> for more information.
</p>


<h3>Note</h3>

<p>Future versions will allow the user more control over the underlying fitting algorithms. In the meantime FRAIR exports all of its (useful) functions so that users can fit the curves directly using their preferred method if the defaults are undesirable. See the Examples for an illustration of this approach.  
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Juliano SA (2001) <em>Nonlinear curve fitting: Predation and functional response curves</em>. In: Scheiner SM, Gurevitch J (eds). <em>Design and analysis of ecological experiments</em>. Oxford University Press, Oxford, United Kingdom. pp 178&ndash;196.
</p>
<p>Bolker BM (2008) <em>Ecological Models and Data in R</em>. Princeton University Press, Princeton, NJ.
</p>
<p>Bolker BM and others (2013) <em>Strategies for fitting nonlinear ecological models in R, AD Model Builder, and BUGS</em>. Methods in Ecology and Evolution 4: 501&ndash;512. doi:10.1111/2041-210X.12044.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_boot">frair_boot</a></code>, <code><a href="#topic+frair_responses">frair_responses</a></code>, <code><a href="#topic+fr_rogersII">fr_rogersII</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)

frair_responses() # See what is available
# A typeII fit
outII &lt;- frair_fit(eaten~density, data=gammarus, response='rogersII', 
        start=list(a = 1.2, h = 0.015), fixed=list(T=40/24))

# A linear fit
outI &lt;- frair_fit(eaten~density, data=gammarus, response='typeI', 
        start=list(a=0.5), fixed=list(T=40/24))

# Visualise fits
plot(outII, pch=20, col=rgb(0,0,0,0.2), xlim=c(0,30))
lines(outII)
lines(outI, lty=3)

# Have a look at original fits returned by mle2 (*highly* recommended)
summary(outII$fit)
summary(outI$fit)
# Compare models using AIC
AIC(outI$fit,outII$fit)

# Bythotrephes
data("bythotrephes")
# Fit several models and examine them using AIC. 
b_flex &lt;- frair_fit(eaten~density, data=bythotrephes, 
                    response='flexpnr', 
                    start=list(b = 1.2, q = 0, h = 0.015), 
                    fixed=list(T=12/24))
b_II &lt;- frair_fit(eaten~density, data=bythotrephes, 
                  response='flexpnr', 
                  start=list(b = 1.2, h = 0.015), 
                  fixed=list(T=12/24, q = 0))
b_rogersII &lt;- frair_fit(eaten~density, data=bythotrephes, 
                  response='rogersII', 
                  start=list(a = 1.2, h = 0.015), 
                  fixed=list(T=12/24))
AIC(b_flex$fit, b_II$fit, b_rogersII$fit)
AICtab(b_flex$fit, b_II$fit, b_rogersII$fit)
# b_II and b_rogersII are identical, by definition when q = 0
# b_flex is strongly preferred (delta AIC = 16.9)

# The role of T
## Users need to be aware that changing T will change 
## the units of fitted coefficients.  
## For example, with the Gammarus dataset:
g_T1 &lt;- frair_fit(formula = eaten~density, data = gammarus, 
                  response = "rogersII", 
                  start = list(a = 2, h = 0.1), fixed = list(T = 1))
g_Td &lt;- frair_fit(formula = eaten~density, data = gammarus, 
                  response = "rogersII", 
                  start = list(a = 1, h = 0.1), fixed = list(T = 40/24))
g_Th &lt;- frair_fit(formula = eaten~density, data = gammarus, 
                  response = "rogersII", 
                  start = list(a = 0.05, h = 4), fixed = list(T = 40))
diff_t &lt;- round(rbind(coef(g_T1), coef(g_Td), coef(g_Th)), 2)
row.names(diff_t) &lt;- c("g_T1 (Experimental Time)", "g_Td (Days)", "g_Th (Hours)")
print(diff_t)

## Not run: 
## Fitting curves outside of FRAIR
# Many advanced users will not be satisfied with FRAIR current limitations.
# To fit models outside FRAIR, you could proceed as follows:

# Using mle2 or mle manually:
strt &lt;- list(a = 1.2, h = 0.015)
fxd &lt;- list(T=40/24)
dat &lt;- list('X'=gammarus$density, 'Y'=gammarus$eaten)
manual_fit &lt;- mle2(rogersII_nll, start=strt, fixed=fxd, 
                   method='SANN', data=dat)
# Note that the SANN method is *not* a general-purpose algorithm, 
# but it will return *something*, so might be helpful for finding starting values.

# Controlling iterations, optimisers, etc... See ?mle2 and ?optim
cntrl &lt;- list(trace = 3, maxit = 1000)
manual_fit_2 &lt;- mle2(rogersII_nll, start=strt, fixed=fxd, 
                     method='BFGS', data=dat, control=cntrl)

## End(Not run)
</code></pre>

<hr>
<h2 id='frair_fit_methods'>frair methods</h2><span id='topic+frair_fit_methods'></span><span id='topic+print.frfit'></span><span id='topic+plot.frfit'></span><span id='topic+lines.frfit'></span>

<h3>Description</h3>

<p>Documentation for methods for class frfit</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frfit'
print(x, ...)
## S3 method for class 'frfit'
plot(x, xlab=x$xvar, ylab=x$yvar, ...)
## S3 method for class 'frfit'
lines(x, tozero=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_fit_methods_+3A_x">x</code></td>
<td>
<p>Output from a call to <code>frair_fit</code>.</p>
</td></tr>
<tr><td><code id="frair_fit_methods_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="frair_fit_methods_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="frair_fit_methods_+3A_tozero">tozero</code></td>
<td>
<p>A logical. Should the line be drawn to the origin? See Details.</p>
</td></tr>
<tr><td><code id="frair_fit_methods_+3A_...">...</code></td>
<td>
<p>Other items passed to underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This documents standard methods for FRAIR objects of class <code>frfit</code>. However, because standard naming conventions have been used, some undocumented utility functions might also work (e.g. <code><a href="stats.html#topic+coefficients">coefficients</a></code>)
</p>
<p><code>lines</code> only adds lines to an existing plot, so an active graphics device needs to be present. <code>lines</code> draws the curve for the fitted response evaluated at values:
</p>
<p><code>seq(from=min(x$x), to=max(x$x), length.out = 50)</code> or 
</p>
<p><code>seq(from=0, to=max(x$x), length.out = 50)</code> if <code>tozero</code> is TRUE.  
</p>
<p>If the supplied function is undefined at zero (and <code>tozero</code> is TRUE), then lines will plot lines to a small, non-zero number (1e-04) instead (with a warning). Clearly the intention here is to provide a nice-looking representation of the fitted curve and it is up to the user to determine <em>why</em> their desired curve is undefined at zero.  
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)
outII &lt;- frair_fit(eaten~density, data=gammarus, response='rogersII', 
        start=list(a = 1.2, h = 0.015), fixed=list(T=40/24))

# Visualise fit
plot(outII, pch=20, col=rgb(0,0,0,0.2), xlim=c(0,30))
lines(outII)
</code></pre>

<hr>
<h2 id='frair_responses'>FRAIR responses</h2><span id='topic+frair_responses'></span>

<h3>Description</h3>

<p>Available predator-prey functional responses.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	frair_responses(show=TRUE)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_responses_+3A_show">show</code></td>
<td>
<p>A logical. If TRUE, information is printed to screen and nothing is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frair_responses</code> is both a vector of useful information (via <code>show=TRUE</code>) and a vehicle to keep track of implemented functional responses.  The latter is enforced by matching responses supplied to <code><a href="#topic+frair_fit">frair_fit</a></code> to the <code>names</code> returned by <code>frair_responses(show=FALSE)</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resp_known &lt;- names(frair_responses(show=FALSE))
frair_responses(show=TRUE)
</code></pre>

<hr>
<h2 id='frair_test'>Test for evidence of type-II or type-III functional responses</h2><span id='topic+frair_test'></span><span id='topic+print.frtest'></span>

<h3>Description</h3>

<p>Implements the phenomenological test of type-II <em>versus</em> type-III functional responses described by Juliano (2001)</p>


<h3>Usage</h3>

<pre><code class='language-R'>frair_test(formula, data)
## S3 method for class 'frtest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair_test_+3A_formula">formula</code></td>
<td>
<p>A simple formula of the form <code>y ~ x</code>.</p>
</td></tr>
<tr><td><code id="frair_test_+3A_data">data</code></td>
<td>
<p>The dataframe containing <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="frair_test_+3A_x">x</code></td>
<td>
<p>Output from <code>frair_test</code>.</p>
</td></tr>
<tr><td><code id="frair_test_+3A_...">...</code></td>
<td>
<p>Other items passed to the print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps up an otherwise trivial test for type-II <em>versus</em> type-III functional responses in a format consistent with the FRAIR syntax. It can be considered 'phenomenological' inasmuch as it tells the user if a type-II or type-III response is preferred, but not what form that curve should take nor if it is sensible to fit such a curve via non-linear regression.  
</p>
<p>The test relies on the established principle that a logistic regression on the <em>proportion</em> of prey consumed is a more sensitive test of functional response shape, especially at low prey densities, when a non-linear curve may not be able to distinguish the subtle difference in curve shape. 
</p>
<p>The logic follows that on the proportion scale, a type-II response will show an increasing (i.e. positive and statistically different from zero) initial slope with respect to density whereas a type-III response will show a negative slope, followed by a positive higher order slope. 
</p>
<p>The test proceeds by fitting two models:
</p>
<p><code>glm(cbind(eaten,noteaten)~density, family='binomial')</code>
</p>
<p><code>glm(cbind(eaten,noteaten)~density+density^2, family='binomial')</code>
</p>
<p>where <code>eaten</code> is the left hand side of the <code>formula</code> input, <code>density</code> is the right hand side and <code>noteaten</code> is the difference between the two. The output from these models to determine which functional response is preferred using the logic above.
</p>
<p>Currently no consideration is given to a type-I (<em>i.e.</em> linear) response or any other potentially sensible fit other than a type-II or type-III response. It is up to the user to decide if it is appropriate to continue with fitting a mechanistic model of the functional response (<em>i.e.</em> <code><a href="#topic+frair_fit">frair_fit</a></code>, <code><a href="#topic+frair_compare">frair_compare</a></code> and/or <code><a href="#topic+frair_boot">frair_boot</a></code>) on the back of the results of this test. 
</p>


<h3>Value</h3>

<p><code>frair_test</code> returns a list of class <code>frtest</code> with the following items:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The original call to <code>frair_test</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original x data supplied to <code>frair_test</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The proportion of prey eaten: <code class="reqn">y/x</code></p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>A string. The right hand side of <code>formula</code>.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>A string. Always <code>'Proportion'</code>.</p>
</td></tr>
<tr><td><code>modT2</code></td>
<td>
<p>The output from the type-II glm</p>
</td></tr>
<tr><td><code>modT3</code></td>
<td>
<p>The output form the type-III glm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>


<h3>References</h3>

<p>Juliano SA (2001) <em>Nonlinear curve fitting: Predation and functional response curves</em>. In: Scheiner SM, Gurevitch J (eds). <em>Design and analysis of ecological experiments</em>. Oxford University Press, Oxford, United Kingdom. pp 178&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frair_fit">frair_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)
frair_test(eaten~density, data=gammarus)

dat &lt;- data.frame(x=1:100, y=floor(hassIII(1:100,b=0.01,c=0.001,h=0.03,T=1)))
frair_test(y~x, data=dat)
</code></pre>

<hr>
<h2 id='frair-deprecated'>Deprecated Functional Response Models</h2><span id='topic+frair-deprecated'></span><span id='topic+fr_bdII'></span><span id='topic+bdII'></span><span id='topic+bdII_fit'></span><span id='topic+bdII_nll'></span><span id='topic+bdII_diff'></span><span id='topic+bdII_nll_diff'></span><span id='topic+fr_real77r'></span><span id='topic+real77r'></span><span id='topic+real77r_fit'></span><span id='topic+real77r_nll'></span><span id='topic+real77r_diff'></span><span id='topic+real77r_nll_diff'></span><span id='topic+fr_real77'></span><span id='topic+real77'></span><span id='topic+real77_fit'></span><span id='topic+real77_nll'></span><span id='topic+real77_diff'></span><span id='topic+real77_nll_diff'></span><span id='topic+fr_hassIIIr'></span><span id='topic+hassIIIr'></span><span id='topic+hassIIIr_fit'></span><span id='topic+hassIIIr_nll'></span><span id='topic+hassIIIr_diff'></span><span id='topic+hassIIIr_nll_diff'></span>

<h3>Description</h3>

<p>A list of deprecated (i.e. no longer in use) functions / models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    bdII(...)
    bdII_fit(...)
    bdII_nll(...)
    bdII_diff(...)
    bdII_nll_diff(...)
    real77r(...)
    real77r_fit(...)
    real77r_nll(...)
    real77r_diff(...)
    real77r_nll_diff(...)
    real77(...)
    real77_fit(...)
    real77_nll(...)
    real77_diff(...)
    real77_nll_diff(...)
    hassIIIr(...)
    hassIIIr_fit(...)
    hassIIIr_nll(...)
    hassIIIr_diff(...)
    hassIIIr_nll_diff(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frair-deprecated_+3A_...">...</code></td>
<td>
<p>Items to pass through a deprecated function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bdII</code>, <code>bdII_fit</code> and <code>bdII_nll</code> were deprecated and removed from FRAIR in version 0.5. Although internally consistent, this code did not actually model the Beddington-DeAngelis type-II curve, as advertised. This code used in these functions was renamed <a href="#topic+emdII">emdII</a>. A correct implementation of the Beddington-DeAngelis type-II curve (assuming replacement) will be added at some point in the future.  
</p>
<p>The <code>real77*</code> family were deprecated and removed from FRAIR in version 0.5. These functions were poorly specified, with unhelpful (that is to say: incorrect) definitions of the exponent term (<code>q</code>). More sensible flexible exponent model specifications (<code><a href="#topic+flexp">flexp</a></code> and <code><a href="#topic+flexpnr">flexpnr</a></code>) have been added as a replacement.  
</p>
<p>The <code>hassIIIr</code> model was renamed to <code><a href="#topic+hassIIInr">hassIIInr</a></code> in version 0.5. The previous name was confusing. The new name better reflects that it is a '<strong>n</strong>on-<strong>r</strong>eplacement' model.  
</p>


<h3>Author(s)</h3>

<p>Daniel Pritchard
</p>

<hr>
<h2 id='frair-package'>Functional Response Analysis in R</h2><span id='topic+frair-package'></span><span id='topic+frair'></span>

<h3>Description</h3>

<p>Tools to support sensible statistics for functional response analysis.</p>


<h3>Details</h3>

<p>The main workhorses are <code><a href="#topic+frair_test">frair_test</a></code>, <code><a href="#topic+frair_fit">frair_fit</a></code>, <code><a href="#topic+frair_compare">frair_compare</a></code> and <code><a href="#topic+frair_boot">frair_boot</a></code>. These should be the starting points for most users.
</p>


<h3>Author(s)</h3>

<p>Development hosted on GitHub: <a href="https://github.com/dpritchard/frair">https://github.com/dpritchard/frair</a>  
</p>
<p>Please file bug reports at: <a href="https://github.com/dpritchard/frair/issues">https://github.com/dpritchard/frair/issues</a>  
</p>

<hr>
<h2 id='gammarus'>Gammarus Functional Response Data</h2><span id='topic+gammarus'></span>

<h3>Description</h3>

<p>Functional response dataset for two species of <em>Gammarus</em> spp. (freshwater amphipods) eating <em>Simulium</em> spp. (black fly) larvae.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gammarus)</code></pre>


<h3>Format</h3>

<p>A dataframe with the following structure:
</p>

<table>
<tr>
 <td style="text-align: right;">
		density: </td><td style="text-align: left;"> An integer. The initial density of prey</td>
</tr>
<tr>
 <td style="text-align: right;">
		eaten: </td><td style="text-align: left;"> An integer. The number of prey eaten</td>
</tr>
<tr>
 <td style="text-align: right;">
		alive:</td><td style="text-align: left;"> An integer. The number of prey left alive</td>
</tr>
<tr>
 <td style="text-align: right;">
		spp: </td><td style="text-align: left;"> A factor with levels <code>G.d.celticus</code> and <code>G.pulex</code>. The species of predator.
	</td>
</tr>

</table>



<h3>Details</h3>

<p>This dataset is a stripped-down version of that presented in Paterson et al. 2014. It contains only <em>Simulium</em> spp. data with all other treatments (other than predator identity) pooled. The predators are amphipods which are either native (<em>Gammarus duebeni celticus</em>) or invasive (<em>Gammarus pulex</em>) to waterways in Ireland.  Total experimental time was 40 hours.  
</p>


<h3>Source</h3>

<p>Paterson RA, Dick JTA, Pritchard DW, Ennis M, Hatcher MJ &amp; Dunn AM. 2014. Predicting invasive species impacts: community module functional response experiments reveal context dependencies. <em>Journal of Animal Ecology</em> 84:453-463 doi:1111/1365-2656.12292</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gammarus)
str(gammarus) 

with(gammarus, 
    plot(density, eaten, type='n', 
	xlab='Density', ylab='No. Prey Eaten'))
with(gammarus[gammarus$spp=='G.d.celticus',], 
	points(density-0.2, eaten, pch=20, col=rgb(0,0.5,0,0.2)))
with(gammarus[gammarus$spp=='G.pulex',], 
	points(density+0.2, eaten, pch=20, col=rgb(0.5,0,0,0.2)))

legend(2,20, c('Native', 'Invasive'), pch=20, 
	col=c(rgb(0,0.5,0), rgb(0.5,0,0)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
