<!DOCTYPE html><html><head><title>Help for package geospt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geospt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ariari'>
<p>Ariari Map.</p></a></li>
<li><a href='#ariprec'>
<p>Data from climatic stations of the Ariari River (Meta-Colombia Department)</p></a></li>
<li><a href='#bestnet'>
<p>Generate a SpatialPoints object corresponding to the best result obtained in an optimized network</p></a></li>
<li><a href='#bp.with.outlier.label'>
<p>geospt internal function</p></a></li>
<li><a href='#COSha10'>
<p>Soil organic carbon database at a sampling depth of 0-10 cm</p></a></li>
<li><a href='#COSha10map'>
<p>Map of total soil carbon stock (t/ha) at 0-10 cm depth</p></a></li>
<li><a href='#COSha30'>
<p>Soil organic carbon database at a sampling depth of 0-30 cm</p></a></li>
<li><a href='#COSha30map'>
<p>Map of total soil carbon stock (t/ha) at 0-30 cm depth</p></a></li>
<li><a href='#criteria.cv'>
<p>Cross-validation summaries</p></a></li>
<li><a href='#criterio.cv'>
<p>Cross-validation summaries</p></a></li>
<li><a href='#est.variograms'>
<p>Variogram Estimator</p></a></li>
<li><a href='#extractFormula'>
<p>geospt internal function</p></a></li>
<li><a href='#geospt-package'>
<p>Geostatistical Analysis and Design of Optimal Spatial Sampling Networks</p></a></li>
<li><a href='#graph.idw'>
<p>Graph that describes the behavior of the optimized <em>p</em> smoothing parameter.</p></a></li>
<li><a href='#graph.rbf'>
<p>Graph that describes the behavior of the optimized <em>eta</em> and <em>rho</em> parameters, associated with a radial basis function</p></a></li>
<li><a href='#idw.cv'>
<p>idw cross validation leave-one-out</p></a></li>
<li><a href='#lalib'>
<p>Map of boundary enclosing La Libertad Research Center</p></a></li>
<li><a href='#network.design'>
<p>Generating <code>AKSE</code> associated with a conditioned network design</p></a></li>
<li><a href='#pocket.plot'>
<p>graphs the probability or standardized variance in the directions north-south or east-west</p></a></li>
<li><a href='#preci'>
<p>Empirical data related to rainfall</p></a></li>
<li><a href='#rbf'>
<p>gaussian, exponential, trigonometric, thin plate spline, inverse multiquadratic, and multiquadratic radial basis function prediction</p></a></li>
<li><a href='#rbf.cv'>
<p>rbf cross validation leave-one-out</p></a></li>
<li><a href='#rbf.cv1'>
<p>Generates a RMSPE value, result of cross validation leave-one-out</p></a></li>
<li><a href='#RBF.phi'>
<p>radial basis function evaluation</p></a></li>
<li><a href='#rbf.tcv'>
<p>table of rbf cross validation, leave-one-out</p></a></li>
<li><a href='#samplePts'>
<p>sample <em>n</em> point locations in (or on) a spatial object</p></a></li>
<li><a href='#seqPtsOptNet'>
<p>Design of optimal sampling networks through the sequential points method</p></a></li>
<li><a href='#simPtsOptNet'>
<p>Design of optimal sampling networks through the simultaneous points method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geostatistical Analysis and Design of Optimal Spatial Sampling
Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Carlos Melo &lt;cmelo@udistrital.edu.co&gt;, Ali Santacruz, Oscar
        Melo &lt;oomelom@unal.edu.co&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ali Santacruz &lt;amsantac@unal.edu.co&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), gstat, genalg, MASS, sp, minqa</td>
</tr>
<tr>
<td>Imports:</td>
<td>limSolve, fields, gsl, plyr, TeachingDemos, sgeostat,
grDevices, stats, methods, graphics, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of the variogram through trimmed mean, radial basis 
        functions (optimization, prediction and cross-validation), summary
        statistics from cross-validation, pocket plot, and design of
        optimal sampling networks through sequential and simultaneous
        points methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/amsantac/geospt/issues">https://github.com/amsantac/geospt/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/amsantac/geospt">https://github.com/amsantac/geospt</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 19:46:48 UTC; spaziu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 05:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='ariari'>
Ariari Map.
</h2><span id='topic+ariari'></span>

<h3>Description</h3>

<p>Map Basin Map. Spatial reference system: UTM 18S
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ariari)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ariari)
pts &lt;- spsample(ariari, n=25000, type="regular")
plot(pts)
</code></pre>

<hr>
<h2 id='ariprec'>
Data from climatic stations of the Ariari River (Meta-Colombia Department)
</h2><span id='topic+ariprec'></span>

<h3>Description</h3>

<p>Data from climatic stations of the Ariari River (Meta-Colombia Department) associated with the rainfall variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ariprec)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 6 variables:
</p>

<dl>
<dt><code>Obs</code></dt><dd><p>a numeric vector; observation number</p>
</dd>
<dt><code>Nombre</code></dt><dd><p>a character vector; station name</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector; x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector; y-coordinate</p>
</dd>
<dt><code>ELEV</code></dt><dd><p>a numeric vector; Elevation above sea level</p>
</dd>
<dt><code>PRECI_TOT</code></dt><dd><p>a numeric vector; the target variable</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ariprec)
summary(ariprec)
</code></pre>

<hr>
<h2 id='bestnet'>
Generate a SpatialPoints object corresponding to the best result obtained in an optimized network 
</h2><span id='topic+bestnet'></span>

<h3>Description</h3>

<p>Generate a SpatialPoints object with the <em>x</em> and <em>y</em> coordinates corresponding to the best result obtained in an optimized network. The parameter to be passed to this function must be the result of <code><a href="#topic+seqPtsOptNet">seqPtsOptNet</a></code> or <code><a href="#topic+simPtsOptNet">simPtsOptNet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestnet(optimnet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestnet_+3A_optimnet">optimnet</code></td>
<td>

<p>object of class rbga resulting from <code><a href="#topic+seqPtsOptNet">seqPtsOptNet</a></code> or <code><a href="#topic+simPtsOptNet">simPtsOptNet</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPoints object
</p>


<h3>See Also</h3>

<p>See function <code><a href="genalg.html#topic+rbga">rbga</a></code> in the <code>genalg</code> package; for examples see <code><a href="#topic+seqPtsOptNet">seqPtsOptNet</a></code> and <code><a href="#topic+simPtsOptNet">simPtsOptNet</a></code>
</p>

<hr>
<h2 id='bp.with.outlier.label'>
geospt internal function
</h2><span id='topic+bp.with.outlier.label'></span>

<h3>Description</h3>

<p>geospt internal function
</p>


<h3>Note</h3>

<p>This function is not meant to be called by users directly
</p>

<hr>
<h2 id='COSha10'>
Soil organic carbon database at a sampling depth of 0-10 cm
</h2><span id='topic+COSha10'></span>

<h3>Description</h3>

<p>Soil organic carbon database of samples taken in several soil and land cover types at La Libertad Research Center at a sampling depth of 0-10 cm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(COSha10)</code></pre>


<h3>Format</h3>

<p>A data frame with 122 observations on the following 10 variables:
</p>

<dl>
<dt><code>ID</code></dt><dd><p>ID of each sampling site</p>
</dd>
<dt><code>x</code></dt><dd><p><em>x</em>-coordinate of each site. Spatial reference system: UTM 18N</p>
</dd>
<dt><code>y</code></dt><dd><p><em>y</em>-coordinate of each site. Spatial reference system: UTM 18N</p>
</dd>
<dt><code>DA10</code></dt><dd><p>measured soil bulk density (g cm<code class="reqn">^{-3}</code>)</p>
</dd>
<dt><code>CO10</code></dt><dd><p>measured soil carbon concentration (%)</p>
</dd>
<dt><code>COB1r</code></dt><dd><p>land cover at each sampling site in 2007. See details below</p>
</dd>
<dt><code>S_UDS</code></dt><dd><p>soil type at each sampling site. See details below</p>
</dd>
<dt><code>COSha10</code></dt><dd><p>calculated total soil carbon stock (t ha<code class="reqn">^{-1}</code>). See details below</p>
</dd>
<dt><code>Cor4DAidep</code></dt><dd><p>total soil carbon stock (t ha<code class="reqn">^{-1}</code>) corrected by soil compaction factors</p>
</dd>
<dt><code>CorT</code></dt><dd><p>corrected total soil carbon stock with Box-Cox transformation applied</p>
</dd>
</dl>



<h3>Details</h3>

<p>A total of 150 samples for a 0-10 cm depth was collected and analyzed for soil bulk density and organic carbon concentration in 2007 at La Libertad Research Center in Villavicencio, Colombia. The samples were taken in soils under different land cover types: rice crops (<code>Az</code>), citrus crops (<code>Ci</code>), forest plantations (<code>Cpf</code>), annual crops (<code>Ctv</code>), grasses (<code>P</code>), and oil palm crops (<code>Pl</code>).
In the soil type names, the first two letters correspond to the short name of the soil series, the lower-case letters indicate the slope class, and the number denotes the type of soil drainage. 
</p>
<p>Total soil carbon stock <code class="reqn">COSha</code> was calculated as follows (Guo &amp; Gifford, 2002):
</p>
<p style="text-align: center;"><code class="reqn">
COSha=DA*CO*d
</code>
</p>

<p>where <code class="reqn">DA</code> is soil bulk density (g cm<code class="reqn">^{-3}</code>), <code class="reqn">CO</code> is soil organic carbon concentration (%) and <code class="reqn">d</code> is sampling depth (cm). 
</p>
<p>Given that the data did not fit a normal distribution, a Box-Cox transformation was applied (Box &amp; Cox, 1964). Some samples were discarded for the design of sampling networks. The complete database and description can be found in Santacruz (2010) and in Santacruz et al., (2014). 
</p>


<h3>Source</h3>

<p>Santacruz, A. 2010. <em>Design of optimal spatial sampling networks for the monitoring of soil organic carbon at La Libertad Research Center through the application of genetic algorithms</em>. M.Sc. Thesis. National University of Colombia, Bogota. 162 p. (In Spanish)
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153">[link]</a>
</p>
<p>Guo, L., Gifford, R., 2002. <em>Soil carbon stocks and land use change: a meta analysis</em>. Global Change Biology 8, 345-360.
</p>
<p>Box, G., Cox, D., 1964. <em>An analysis of transformations</em>. Journal of the Royal Statistical Society. Series B (Methodological) 26 (2), 211-252.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+COSha10map">COSha10map</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(COSha10)
str(COSha10)
</code></pre>

<hr>
<h2 id='COSha10map'>
Map of total soil carbon stock (t/ha) at 0-10 cm depth
</h2><span id='topic+COSha10map'></span>

<h3>Description</h3>

<p>Map of total soil carbon stock (t ha<code class="reqn">^{-1}</code>) at 0-10 cm depth at La Libertad Research Center. The map was obtained through ordinary kriging interpolation. Spatial reference system: UTM 18N
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(COSha10map)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPixelsDataFrame' [package &quot;sp&quot;] 
</p>


<h3>Source</h3>

<p>Santacruz, A., 2010. <em>Design of optimal spatial sampling networks for the monitoring of soil organic carbon at La Libertad Research Center through the application of genetic algorithms</em>. M.Sc. Thesis. National University of Colombia, Bogota. 162 p. (In Spanish)
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153/">[link]</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+COSha10">COSha10</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(COSha10map)
data(lalib)
summary(COSha10map)
l1 = list("sp.polygons", lalib)
spplot(COSha10map, "var1.pred", main="Soil carbon stock (t/ha) at 0-10 cm depth", 
    col.regions=bpy.colors(100), scales = list(draw =TRUE), xlab ="East (m)", 
    ylab = "North (m)", sp.layout=list(l1))
</code></pre>

<hr>
<h2 id='COSha30'>
Soil organic carbon database at a sampling depth of 0-30 cm
</h2><span id='topic+COSha30'></span>

<h3>Description</h3>

<p>Soil organic carbon database of samples taken in several soil and land cover types at La Libertad Research Center at a sampling depth of 0-30 cm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(COSha30)</code></pre>


<h3>Format</h3>

<p>A data frame with 118 observations on the following 10 variables:
</p>

<dl>
<dt><code>ID</code></dt><dd><p>ID of each sampling site</p>
</dd>
<dt><code>x</code></dt><dd><p><em>x</em>-coordinate of each site. Spatial reference system: UTM 18N</p>
</dd>
<dt><code>y</code></dt><dd><p><em>y</em>-coordinate of each site. Spatial reference system: UTM 18N</p>
</dd>
<dt><code>DA30</code></dt><dd><p>measured soil bulk density (g cm<code class="reqn">^{-3}</code>)</p>
</dd>
<dt><code>CO30</code></dt><dd><p>measured soil carbon concentration (%)</p>
</dd>
<dt><code>COB1r</code></dt><dd><p>land cover at each sampling site in 2007. See details below</p>
</dd>
<dt><code>S_UDS</code></dt><dd><p>soil type at each sampling site. See details below</p>
</dd>
<dt><code>COSha30</code></dt><dd><p>calculated total soil carbon stock (t ha<code class="reqn">^{-1}</code>). See details below</p>
</dd>
<dt><code>Cor4DAidep</code></dt><dd><p>total soil carbon stock (t ha<code class="reqn">^{-1}</code>) corrected by soil compaction factors</p>
</dd>
<dt><code>CorT</code></dt><dd><p>corrected total soil carbon stock with Box-Cox transformation applied</p>
</dd>
</dl>



<h3>Details</h3>

<p>A total of 150 samples for a 0-30 cm depth was collected and analyzed for soil bulk density and organic carbon concentration in 2007 at La Libertad Research Center in Villavicencio, Colombia. The samples were taken in soils under different land cover types: rice crops (<code>Az</code>), citrus crops (<code>Ci</code>), forest plantations (<code>Cpf</code>), annual crops (<code>Ctv</code>), grasses (<code>P</code>), and oil palm crops (<code>Pl</code>).
In the soil type names, the first two letters correspond to the short name of the soil series, the lower-case letters indicate the slope class, and the number denotes the type of soil drainage. 
</p>
<p>Total soil carbon stock <code class="reqn">COSha</code> was calculated as follows (Guo &amp; Gifford, 2002):
</p>
<p style="text-align: center;"><code class="reqn">
COSha=DA*CO*d
</code>
</p>

<p>where <code class="reqn">DA</code> is soil bulk density (g cm<code class="reqn">^{-3}</code>), <code class="reqn">CO</code> is soil organic carbon concentration (%) and <code class="reqn">d</code> is sampling depth (cm).
</p>
<p>Given that the data did not fit a normal distribution, a Box-Cox transformation was applied (Box &amp; Cox, 1964). Some samples were discarded for the design of sampling networks. The complete database and description can be found in Santacruz (2010) and in Santacruz et al., (2014). 
</p>


<h3>Source</h3>

<p>Santacruz, A. 2010. <em>Design of optimal spatial sampling networks for the monitoring of soil organic carbon at La Libertad Research Center through the application of genetic algorithms</em>. M.Sc. Thesis. National University of Colombia, Bogota. 162 p. (In Spanish)
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153/">[link]</a> 
</p>
<p>Guo, L., Gifford, R., 2002. <em>Soil carbon stocks and land use change: a meta analysis</em>. Global Change Biology 8, 345-360.
</p>
<p>Box, G., Cox, D., 1964. <em>An analysis of transformations</em>. Journal of the Royal Statistical Society. Series B (Methodological) 26 (2), 211-252.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+COSha30map">COSha30map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(COSha30)
str(COSha30)
</code></pre>

<hr>
<h2 id='COSha30map'>
Map of total soil carbon stock (t/ha) at 0-30 cm depth
</h2><span id='topic+COSha30map'></span>

<h3>Description</h3>

<p>Map of total soil carbon stock (t ha<code class="reqn">^{-1}</code>) at 0-30 cm depth at La Libertad Research Center. The map was obtained through ordinary kriging interpolation. Spatial reference system: UTM 18N
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(COSha30map)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPixelsDataFrame' [package &quot;sp&quot;] 
</p>


<h3>Source</h3>

<p>Santacruz, A., 2010. <em>Design of optimal spatial sampling networks for the monitoring of soil organic carbon at La Libertad Research Center through the application of genetic algorithms</em>. M.Sc. Thesis. National University of Colombia, Bogota. 162 p. (In Spanish)
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153/">[link]</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+COSha30">COSha30</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(COSha30map)
data(lalib)
summary(COSha30map)
l1 = list("sp.polygons", lalib)
spplot(COSha30map, "var1.pred", main="Soil carbon stock (t/ha) at 0-30 cm depth", 
    col.regions=bpy.colors(100), scales = list(draw =TRUE), xlab ="East (m)", 
    ylab = "North (m)", sp.layout=list(l1))
</code></pre>

<hr>
<h2 id='criteria.cv'>
Cross-validation summaries
</h2><span id='topic+criteria.cv'></span>

<h3>Description</h3>

<p>Generate a data frame of statistical values associated with cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criteria.cv(m.cv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criteria.cv_+3A_m.cv">m.cv</code></td>
<td>

<p>data frame containing: the coordinates of data, prediction columns,
prediction variance of cross-validation data points, observed values,
residuals, zscore (residual divided by kriging standard error), and
fold. If the <code><a href="#topic+rbf.tcv">rbf.tcv</a></code> function is used, the prediction variance
and zscore (residual divided by standard error) will have NA's
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing: mean prediction errors (MPE), average kriging
standard error (AKSE), root-mean-square prediction errors (RMSPE),
mean standardized prediction errors (MSPE), root-mean-square standardized
prediction errors (RMSSPE), mean absolute percentage prediction errors (MAPPE), coefficient of correlation of the prediction errors (CCPE), coefficient of determination (R2) and squared coefficient of correlation of the prediction errors (pseudoR2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gstat)
data(meuse)
coordinates(meuse) &lt;- ~x+y
m &lt;- vgm(.59, "Sph", 874, .04)

# leave-one-out cross validation:
out &lt;- krige.cv(log(zinc)~1, meuse, m, nmax = 40)
criterio.cv(out)

# multiquadratic function
data(preci)
coordinates(preci) &lt;- ~x+y

# predefined eta
tab &lt;- rbf.tcv(prec~x+y,preci,eta=1.488733, rho=0, n.neigh=9, func="M")
criterio.cv(tab)
</code></pre>

<hr>
<h2 id='criterio.cv'>
Cross-validation summaries
</h2><span id='topic+criterio.cv'></span>

<h3>Description</h3>

<p>Generate a data frame of statistical values associated with cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterio.cv(m.cv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criterio.cv_+3A_m.cv">m.cv</code></td>
<td>

<p>data frame containing: the coordinates of data, prediction columns,
prediction variance of cross-validation data points, observed values,
residuals, zscore (residual divided by kriging standard error), and
fold. If the <code><a href="#topic+rbf.tcv">rbf.tcv</a></code> function is used, the prediction variance
and zscore (residual divided by standard error) will have NA's
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing: mean prediction errors (MPE), average kriging
standard error (ASEPE), root-mean-square prediction errors (RMSPE),
mean standardized prediction errors (MSPE), root-mean-square standardized
prediction errors (RMSSPE), mean absolute percentage prediction errors (MAPPE), coefficient of correlation of the prediction errors (CCPE), coefficient of determination (R2) and squared coefficient of correlation of the prediction errors (pseudoR2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gstat)
data(meuse) 
coordinates(meuse) &lt;- ~x+y 
m &lt;- vgm(.59, "Sph", 874, .04) 

# leave-one-out cross validation: 
out &lt;- krige.cv(log(zinc)~1, meuse, m, nmax = 40) 
criterio.cv(out)

# multiquadratic function
data(preci)
coordinates(preci) &lt;- ~x+y

# predefined eta
tab &lt;- rbf.tcv(prec~x+y,preci,eta=1.488733, rho=0, n.neigh=9, func="M") 
criterio.cv(tab)
</code></pre>

<hr>
<h2 id='est.variograms'>
Variogram Estimator
</h2><span id='topic+est.variograms'></span>

<h3>Description</h3>

<p>Calculate empirical <code>variogram</code> estimates. An object of class
variogram contains empirical variogram estimates which are generated
from a point object and a pair object. A variogram object is stored
as a data frame containing seven columns: <code>lags</code>, <code>bins</code>,
<code>classic</code>, <code>robust</code>,<code>med</code>, <code>trim</code> and
<code>n</code>. The length of each vector is equal to the number of lags
in the pair object used to create the variogram object, say l. The
<code>lags</code> vector contains the lag numbers for each lag, beginning
with one (1) and going to the number of lags (l). The <code>bins</code> vector
contains the spatial midpoint of each lag. The <code>classic</code>, <code>robust</code>,
<code>med</code> and <code>trimmed.mean</code> vectors contain: the classical,
robust, median, and trimmed mean, respectively, which are given, respectively,
by (see Cressie, 1993, p. 75)
</p>
<p>classical
</p>
<p style="text-align: center;"><code class="reqn">
\gamma_{c}(h)=\frac{1}{n}\sum_{(i,j)\in 
    N(h)}(z(x_{i})-z(x_{j}))^{2}
</code>
</p>

<p>robust,
</p>
<p style="text-align: center;"><code class="reqn">
\gamma_{m}(h)=\frac{(\frac{1}{n}\sum_{(i,j)\in N(h)}
    (\sqrt{|z(x_{i})-z(x_{j})|}))^{4}}{0.457+\frac{0.494}{n}}
</code>
</p>

<p>median
</p>
<p style="text-align: center;"><code class="reqn">
\gamma_{me}(h)=\frac{\mbox(median_{(i,j)\in N(h)}
     (\sqrt{|z(x_{i})-z(x_{j})|}))^{4}}{0.457+\frac{0.494}{|N(h)|}}
</code>
</p>

<p>and trimmed mean
</p>
<p style="text-align: center;"><code class="reqn">
\gamma_{tm}(h)=\frac{(trimmed.mean_{(i,j)\in N(h)}(\sqrt{|z(x_{i})-z(x_{j})|}))^{4}}{0.457+\frac{0.494}{|N(h)|}}
</code>
</p>

<p>The <code class="reqn">n</code> vector contains the number <code class="reqn">|N(h)|</code> of pairs of points
in each lag <code class="reqn">N(h)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.variograms(point.obj, pair.obj, a1, a2, trim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.variograms_+3A_point.obj">point.obj</code></td>
<td>
<p>a point object generated by <code>point()</code></p>
</td></tr>
<tr><td><code id="est.variograms_+3A_pair.obj">pair.obj</code></td>
<td>
<p>a pair object generated by <code>pair()</code></p>
</td></tr>
<tr><td><code id="est.variograms_+3A_a1">a1</code></td>
<td>
<p>a variable to calculate semivariogram for</p>
</td></tr>
<tr><td><code id="est.variograms_+3A_a2">a2</code></td>
<td>
<p>an optional variable name, if entered cross variograms will be created between <code>a1</code> and <code>a2</code></p>
</td></tr>
<tr><td><code id="est.variograms_+3A_trim">trim</code></td>
<td>
<p>percent of trimmed mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variogram object: 
</p>
<table>
<tr><td><code>lags</code></td>
<td>
<p>vector of lag identifiers</p>
</td></tr>
<tr><td><code>bins</code></td>
<td>
<p>vector of midpoints of each lag</p>
</td></tr>
<tr><td><code>classic</code></td>
<td>
<p>vector of classic variogram estimates for each lag</p>
</td></tr>
<tr><td><code>robust</code></td>
<td>
<p>vector of robust variogram estimates for each lag</p>
</td></tr>
<tr><td><code>med</code></td>
<td>
<p>vector of median variogram estimates for each lag</p>
</td></tr>
<tr><td><code>trimmed.mean</code></td>
<td>
<p>vector of trimmed mean variogram estimates for each lag</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>vector of the number of pairs in each lag</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Based on the <code><a href="sgeostat.html#topic+est.variogram">est.variogram</a></code> function of the <code>sgeostat</code> package
</p>


<h3>References</h3>

<p>Bardossy, A., 2001. <em>Introduction to Geostatistics</em>. University of Stuttgart.
</p>
<p>Cressie, N.A.C., 1993. <em>Statistics for Spatial Data</em>. Wiley.
</p>
<p>Majure, J., Gebhardt, A., 2009. sgeostat: An Object-oriented Framework for Geostatistical Modeling in S+. R package version 1.0-23.
</p>
<p>Roustant O., Dupuy, D., Helbert, C., 2007. <em>Robust Estimation of the Variogram in Computer Experiments</em>. Ecole des Mines, Departement 3MI, 158 Cours Fauriel, 42023 Saint-Etienne, France
</p>


<h3>See Also</h3>

<p><code><a href="sgeostat.html#topic+point">point</a></code>, <code><a href="sgeostat.html#topic+pair">pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgeostat, pos=which(search()=="package:gstat")+1)
data(maas)
maas.point &lt;- point(maas) 
maas.pair &lt;- pair(maas.point, num.lags=24, maxdist=2000) 
maas.v &lt;- est.variograms(maas.point,maas.pair,'zinc',trim=0.1) 
maas.v
</code></pre>

<hr>
<h2 id='extractFormula'>
geospt internal function
</h2><span id='topic+extractFormula'></span>

<h3>Description</h3>

<p>geospt internal function
</p>


<h3>Note</h3>

<p>This function is not meant to be called by users directly
</p>

<hr>
<h2 id='geospt-package'>
Geostatistical Analysis and Design of Optimal Spatial Sampling Networks
</h2><span id='topic+geospt-package'></span><span id='topic+geospt'></span>

<h3>Description</h3>

<p>A set of functions for: estimation of the variogram through trimmed mean, radial basis functions 
(optimization, prediction and cross-validation), summary statistics from cross-validation, pocket plot, and
design of optimal sampling networks through sequential and simultaneous points methods</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> geospt</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Carlos Melo &lt;cmelo@udistrital.edu.co&gt;, Ali Santacruz, Oscar Melo &lt;oomelom@unal.edu.co
</p>
<p>Maintainer: Ali Santacruz &lt;amsantac@unal.edu.co&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbf">rbf</a></code>, <code><a href="#topic+est.variograms">est.variograms</a></code>, <code><a href="#topic+seqPtsOptNet">seqPtsOptNet</a></code>, <code><a href="#topic+simPtsOptNet">simPtsOptNet</a></code> 
</p>

<hr>
<h2 id='graph.idw'>
Graph that describes the behavior of the optimized <em>p</em> smoothing parameter.
</h2><span id='topic+graph.idw'></span>

<h3>Description</h3>

<p>Function for plotting the RMSPE for several values of the <em>p</em> smoothing parameter with the same dataset. A curve is fitted to the points, and
then the optimal <em>p</em> that provides the smallest
RMSPE is determined from the curve, by the <code><a href="stats.html#topic+optimize">optimize</a></code> function from the <code>stats</code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.idw(formula, data, locations, np, p.dmax, P.T=NULL, nmax=Inf, nmin=0, pleg, 
    progress=F, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.idw_+3A_formula">formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <em>z</em>, for a <em>idw</em> detrended use <em>z~1</em></p>
</td></tr>
<tr><td><code id="graph.idw_+3A_data">data</code></td>
<td>
<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_locations">locations</code></td>
<td>
<p>object of class <em>Spatial</em>, or (deprecated) formula defines the spatial data locations (coordinates) such as <em>~x+y</em></p>
</td></tr>
<tr><td><code id="graph.idw_+3A_np">np</code></td>
<td>
<p>number of points, where the idw is calculated</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_p.dmax">p.dmax</code></td>
<td>
<p>maximum value of the range of the <em>p</em> parameter that will be evaluated by the <code><a href="stats.html#topic+optimize">optimize</a></code> function</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_p.t">P.T</code></td>
<td>
<p>logical. Print Table (TRUE) or not (FALSE). Default P.T=NULL.</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_nmax">nmax</code></td>
<td>
<p>maximum number of nearest observations that should be used for a <em>idw</em> prediction, where nearest is defined in terms of the spatial locations. By default, all observations are used</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_nmin">nmin</code></td>
<td>
<p>minimum number of nearest observations that should be used for a <em>idw</em> prediction, where nearest is defined in terms of the spatial locations. see <code><a href="gstat.html#topic+krige">krige</a></code></p>
</td></tr>
<tr><td><code id="graph.idw_+3A_pleg">pleg</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>, by default pleg=&quot;topright.</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_progress">progress</code></td>
<td>
<p>logical. Use TRUE to see the percentage of progress of the process and FALSE otherwise). Default progress=FALSE.</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_iter">iter</code></td>
<td>
<p>The maximum allowed number of function evaluations.</p>
</td></tr>
<tr><td><code id="graph.idw_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to the minimization functions <code><a href="stats.html#topic+optimize">optimize</a></code> or <code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>, typically arguments of the type control() which control the behavior of the minimization algorithm. See documentation about the selected minimization function for further details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a graph that describes the behavior of the optimized <em>p</em> parameter associated with the RMSPE, and a table of values associated with the graph including optimal smoothing <em>p</em> parameter, which generates the lowest RMSPE.
</p>


<h3>References</h3>

<p>Johnston, K., Ver, J., Krivoruchko, K., Lucas, N. 2001. <em>Using ArcGIS Geostatistical Analysis</em>. ESRI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ariari)
data(ariprec)
# p optimization
gp &lt;- graph.idw(PRECI_TOT~ 1, ~x+y, data=ariprec, np=50, p.dmax=4, nmax=15, 
    nmin=15,pleg = "center", progress=T)
gp
gp$p

library(sp)
library(fields)
plot(ariari)
gridAri &lt;- spsample(ariari,20000,"regular")
plot(gridAri)

idw.p &lt;- idw(PRECI_TOT~ 1, ~ x+y, ariprec, gridAri, nmax=15, nmin=15, idp=2)
pal2 &lt;- colorRampPalette(c("snow3","royalblue1", "blue4"))

# Inverse Distance Interpolations Precipitation Weighted (P = 2)
p1 &lt;- spplot(idw.p[1], col.regions=pal2(100), cuts =60, scales = list(draw =T), 
    xlab ="East (m)", ylab = "North (m)",
       main = "", auto.key = F)

split.screen( rbind(c(0, 1,0,1), c(1,1,0,1)))
split.screen(c(1,2), screen=1)-&gt; ind
screen( ind[1])
p1
screen( ind[2])
image.plot(legend.only=TRUE, legend.width=0.5, col=pal2(100), 
    smallplot=c(0.6,0.68, 0.5,0.75), 
    zlim=c(min(idw.p$var1.pred),max(idw.p$var1.pred)), 
    axis.args = list(cex.axis = 0.7))
close.screen( all=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='graph.rbf'>
Graph that describes the behavior of the optimized <em>eta</em> and <em>rho</em> parameters, associated with a radial basis function
</h2><span id='topic+graph.rbf'></span>

<h3>Description</h3>

<p>Function for plotting the RMSPE for several values of the smoothing parameter
eta with the same dataset. A curve is fitted to the points, and
then the optimal eta that provides the smallest
RMSPE is determined from the curve, by the <code><a href="stats.html#topic+optimize">optimize</a></code> function from the <code>stats</code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.rbf(formula, data, eta.opt, rho.opt, n.neigh, func, np, x0, eta.dmax,
rho.dmax, P.T, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.rbf_+3A_formula">formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <em>z</em>, for a <em>rbf</em> detrended use <em>z~1</em>; for a <em>rbf</em> with trend, suppose <em>z</em> is linearly dependent on <em>x</em> and <em>y</em>, use the formula <em>z~x+y</em> (linear trend).</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_data">data</code></td>
<td>
<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_eta.opt">eta.opt</code></td>
<td>
<p>logical, indicating whether the parameter <em>eta</em> should be regarded as fixed (eta.opt = FALSE) or should be estimated (eta.opt = TRUE)</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_rho.opt">rho.opt</code></td>
<td>
<p>logical, indicating whether the parameter <em>rho</em> should be regarded as fixed (rho.opt = FALSE) or should be estimated (rho.opt = TRUE)</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_n.neigh">n.neigh</code></td>
<td>
<p>number of nearest observations that should be used for a <em>rbf</em> prediction, where nearest is defined in terms of the spatial locations</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_func">func</code></td>
<td>
<p>function to be optimized. The following radial basis function model types are currently available: gaussian &quot;GAU&quot;, exponential &quot;EXPON&quot;, trigonometric &quot;TRI&quot;, thin plate spline &quot;TPS&quot;, completely regularized spline &quot;CRS&quot;, spline with tension &quot;ST&quot;, inverse multiquadratic &quot;IM&quot;, and multiquadratic &quot;M&quot;, are currently available</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_np">np</code></td>
<td>
<p>number of points, where the radial basis function is calculated</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_x0">x0</code></td>
<td>
<p>starting point for searching the optimum. Defaults to c(0.5, 0.5), <em>eta</em> and <em>rho</em> respectively. Use this statement only if eta and rho are equal to TRUE.</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_eta.dmax">eta.dmax</code></td>
<td>
<p>maximum value of the range of the <em>eta</em> parameter that will be evaluated by the <code><a href="stats.html#topic+optimize">optimize</a></code> function</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_rho.dmax">rho.dmax</code></td>
<td>
<p>maximum value of the range of the <em>rho</em> parameter that will be evaluated by the <code><a href="stats.html#topic+optimize">optimize</a></code> function</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_p.t">P.T</code></td>
<td>
<p>logical. Print Table (TRUE) or not (FALSE). Default P.T=NULL.</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_iter">iter</code></td>
<td>
<p>The maximum allowed number of function evaluations.</p>
</td></tr>
<tr><td><code id="graph.rbf_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to the minimization functions <code><a href="stats.html#topic+optimize">optimize</a></code> or <code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>, typically arguments of the type control() which control the behavior of the minimization algorithm. See documentation about the selected minimization function for further details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a graph that describes the behavior of the optimized <em>eta</em> or <em>rho</em> parameter, and a table of values associated with the graph including optimal smoothing <em>eta</em> or <em>rho</em> parameters. If both <em>eta</em> and <em>rho</em> are FALSE simultaneously, then the function returns a list with; the best value obtained from the combinations smoothing <em>eta</em> and <em>rho</em> parameters and a lattice plot of class &quot;trellis&quot; with RMSPE pixel values associated with combinations of <em>eta</em> and <em>rho</em> parameters. Finally if both <em>eta</em> and <em>rho</em> are TRUE, the function will return a list with the best combination of values of the smoothing <em>eta</em> or <em>rho</em> parameters and the RMSPE associated with these. 
</p>


<h3>References</h3>

<p>Johnston, K., Ver, J., Krivoruchko, K., Lucas, N. 2001. <em>Using ArcGIS Geostatistical Analysis</em>. ESRI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preci)
## Not run: 
coordinates(preci)&lt;-~x+y
# optimizing eta
graph.rbf(prec~1, preci, eta.opt=TRUE, rho.opt=FALSE, n.neigh=9, func="TPS", 
    np=40, eta.dmax=0.2, P.T=TRUE)
# optimizing rho
graph.rbf(prec~x+y, preci, eta.opt=FALSE, rho.opt=TRUE, n.neigh=9, func="M", 
    np=20, rho.dmax=2, P.T=TRUE)
# optimizing eta and rho
tps.lo &lt;- graph.rbf(prec~1, preci, eta.opt=TRUE, rho.opt=TRUE, n.neigh=9, func="TPS", 
    eta.dmax=2, rho.dmax=2, x0=c(0.1,0.1), iter=40)
tps.lo$Opt  # best combination of eta and rho obtained
# other optimization options
opt.u &lt;- uobyqa(c(0.1,0.1), rbf.cv1, control = list(maxfun=40), formula=prec~1, data=preci, 
                n.neigh=9, func="TPS")
opt.n &lt;- newuoa(c(0.1,0.1), rbf.cv1, control = list(maxfun=40), formula=prec~1, data=preci, 
                n.neigh=9, func="TPS")
# lattice of RMSPE values associated with a range of eta and rho, without optimization
tps.l &lt;- graph.rbf(prec~1, preci, eta.opt=FALSE, rho.opt=FALSE, n.neigh=9, func="TPS", 
    np=10, eta.dmax=2, rho.dmax=2)
tps.l$opt.table  # best combination of eta and rho obtained from lattice
tps.ls$pplot     # lattice of RMSPE

## End(Not run)
</code></pre>

<hr>
<h2 id='idw.cv'>
idw cross validation leave-one-out
</h2><span id='topic+idw.cv'></span>

<h3>Description</h3>

<p>Generate the RMSPE value, which is given by the idw function
with <code>p</code> smoothing parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idw.cv(formula, locations, data, nmax = Inf, nmin = 0, p = 2, progress=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idw.cv_+3A_formula">formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <em>z</em>, for a <em>idw</em> detrended use <em>z~1</em></p>
</td></tr>
<tr><td><code id="idw.cv_+3A_data">data</code></td>
<td>
<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.</p>
</td></tr>
<tr><td><code id="idw.cv_+3A_locations">locations</code></td>
<td>
<p>object of class <em>Spatial</em>, or (deprecated) formula defines the spatial data locations (coordinates) such as <em>~x+y</em></p>
</td></tr>
<tr><td><code id="idw.cv_+3A_nmax">nmax</code></td>
<td>

<p>number of nearest observations that should be used for a <em>idw</em> prediction, where nearest is defined in terms of the spatial locations. By default, all observations are used.
</p>
</td></tr>
<tr><td><code id="idw.cv_+3A_nmin">nmin</code></td>
<td>

<p>if the number of nearest observations within distance maxdist is less than nmin, a missing value will be generated; see maxdist.
</p>
</td></tr>
<tr><td><code id="idw.cv_+3A_p">p</code></td>
<td>

<p>value of smoothing parameter; we recommend using the parameter
found by minimizing the root-mean-square prediction errors using cross-validation. Default is 2.
</p>
</td></tr>
<tr><td><code id="idw.cv_+3A_progress">progress</code></td>
<td>
<p>logical. Use TRUE to see the percentage of progress of the process and FALSE otherwise). Default progress=FALSE.</p>
</td></tr>
<tr><td><code id="idw.cv_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <em>idw</em></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the RMSPE value
</p>


<h3>See Also</h3>

<p><code>idw</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preci)
idw.cv(prec~1, ~x+y, preci, nmax=9, nmin=9, p=2, progress=TRUE)
</code></pre>

<hr>
<h2 id='lalib'>
Map of boundary enclosing La Libertad Research Center
</h2><span id='topic+lalib'></span>

<h3>Description</h3>

<p>Map of boundary enclosing La Libertad Research Center
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalib)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'SpatialPolygonsDataFrame' [package &quot;sp&quot;]
</p>


<h3>Details</h3>

<p>Map of boundary enclosing La Libertad Research Center. Spatial reference system: UTM 18N 
</p>


<h3>Source</h3>

<p>Santacruz, A. 2010. <em>Design of optimal spatial sampling networks for the monitoring of soil organic carbon at La Libertad Research Center through the application of genetic algorithms</em>. M.Sc. Thesis. National University of Colombia, Bogota. 162 p. (In Spanish)
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153/">[link]</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalib)
summary(lalib)
plot(lalib)
</code></pre>

<hr>
<h2 id='network.design'>
Generating <code>AKSE</code> associated with a conditioned network design
</h2><span id='topic+network.design'></span>

<h3>Description</h3>

<p>Generates a sampling network for a given sampling distance or type (configuration), and calculates the average kriging standard error (<code>AKSE</code>) associated with the spatial configuration for a given predefined variogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.design(formula, vgm.model, xmin, xmax, ymin, ymax, npoint.x, npoint.y,
npoints, boundary=NULL, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.design_+3A_formula">formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name z, for ordinary and simple kriging use the formula <code>z~1</code>; for simple kriging also define beta (see below); for universal kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>, use the formula <code>z~x+y</code></p>
</td></tr>
<tr><td><code id="network.design_+3A_vgm.model">vgm.model</code></td>
<td>
<p>variogram model of dependent variable (or its residuals), defined by a call to vgm or fit.variogram</p>
</td></tr>
<tr><td><code id="network.design_+3A_npoint.x">npoint.x</code></td>
<td>
<p>number of points to generate on the <code>x</code>-axis</p>
</td></tr>
<tr><td><code id="network.design_+3A_npoint.y">npoint.y</code></td>
<td>
<p>number of points to generate on the <code>y</code>-axis</p>
</td></tr>
<tr><td><code id="network.design_+3A_npoints">npoints</code></td>
<td>
<p>(approximate) sample size inside (shapefile) border</p>
</td></tr>
<tr><td><code id="network.design_+3A_xmin">xmin</code></td>
<td>
<p>minimum <code>x</code>-coordinate of the study area.</p>
</td></tr>
<tr><td><code id="network.design_+3A_ymin">ymin</code></td>
<td>
<p>minimum <code>y</code>-coordinate of the study area.</p>
</td></tr>
<tr><td><code id="network.design_+3A_xmax">xmax</code></td>
<td>
<p>maximum <code>x</code>-coordinate of the study area.</p>
</td></tr>
<tr><td><code id="network.design_+3A_ymax">ymax</code></td>
<td>
<p>maximum <code>y</code>-coordinate of the study area.</p>
</td></tr>
<tr><td><code id="network.design_+3A_boundary">boundary</code></td>
<td>
<p>SpatialPolygons or SpatialPolygonsDataFrame object</p>
</td></tr>
<tr><td><code id="network.design_+3A_type">type</code></td>
<td>
<p>character; &quot;random&quot; for completely spatial random; &quot;regular&quot; for regular (systematically aligned) sampling; &quot;stratified&quot; for stratified random (one single random location in each &quot;cell&quot;); &quot;nonaligned&quot; for nonaligned systematic sampling (nx random y coordinates, ny random x coordinates); &quot;hexagonal&quot; for sampling on a hexagonal lattice; &quot;clustered&quot; for clustered sampling; &quot;Fibonacci&quot; for Fibonacci sampling on the sphere (see references). By default type =&quot;regular&quot;.</p>
</td></tr>
<tr><td><code id="network.design_+3A_...">...</code></td>
<td>
<p>further arguments will be passed of the <code>krige</code> and <code><a href="sp.html#topic+spsample">spsample</a></code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>AKSE</code> value associated with the spatial distribution of points and the kriging method used.
</p>


<h3>References</h3>

<p>Fibonacci sampling: Alvaro Gonzalez, 2010. <em>Measurement of Areas on a Sphere Using Fibonacci and Latitude-Longitude Lattices</em>. Mathematical Geosciences 42(1), p. 49-64
</p>


<h3>See Also</h3>

<p><code>krige</code>,  <code>krige.cv</code>, <code><a href="sp.html#topic+spsample">spsample</a></code>, <code><a href="sp.html#topic+point.in.polygon">point.in.polygon</a></code>, <code><a href="base.html#topic+sample">sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### regular grid 10x10
vgmok &lt;- vgm(112.33, "Sph", 4.3441,0)
vgmsk &lt;- vgm(74.703, "Sph", 3.573,0)
vgmuk &lt;- vgm(53.064, "Sph", 2.8858,0)
vgmuk2 &lt;- vgm(19.201, "Sph", 1.5823,0)
# network: ordinary kriging (without boundary)
net1.ok &lt;- network.design(z~1,vgmok, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=10,
    npoint.y=10, nmax=6)
net2.ok &lt;- network.design(z~1,vgmok, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=20,
    npoint.y=20, nmax=6)
# it's worth noting that the variograms are different in each kriging

# network: simple kriging (without boundary)

net1.sk &lt;- network.design(z~1,vgmsk, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=10,
    npoint.y=10, nmax=6, beta=2)
net2.sk &lt;- network.design(z~1,vgmsk, xmin=0,xmax=10, ymin=0, ymax=10, npoint.x=20,
    npoint.y=20, nmax=6, beta=2)
# network: universal kriging, second order trend (without boundary)
net1.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2),vgmuk, xmin=0,xmax=10, ymin=0,
    ymax=10, npoint.x=10, npoint.y=10, nmax=8)
net2.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2),vgmuk2, xmin=0,xmax=10, ymin=0,
    ymax=10, npoint.x=20, npoint.y=20, nmax=8)


# Creating the grid with the prediction and plotting points
library(geoR)
data(ca20)
Sr1 &lt;- Polygon(ca20$borders)
Srs1 = Polygons(list(Sr1), "s1")
Polygon = SpatialPolygons(list(Srs1))
vgmok.ca &lt;- vgm(112.33, "Sph", 244.9,0)
vgmsk.ca &lt;- vgm(100, "Sph", 150.2,0)
vgmuk.ca &lt;- vgm(85.57, "Sph", 110.5,0)
vgmuk2.ca &lt;- vgm(62.14, "Sph", 89.7,0)

# network: ordinary kriging (with boundary)
netb1.ok&lt;- network.design(z~1, vgmok.ca, npoints=50, boundary=Polygon, nmax=6)
netb2.ok&lt;- network.design(z~1, vgmok.ca, npoints=100, boundary=Polygon, nmax=6)
# network: simple kriging (with boundary)
netb1.sk &lt;- network.design(z~1, vgmsk.ca, npoints=50, boundary=Polygon, nmax=6, beta=2)
netb2.sk &lt;- network.design(z~1, vgmsk.ca, npoints=100, boundary=Polygon, nmax=6, beta=2)
# network: universal kriging, second order trend (with boundary)
netb1.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2), vgmuk.ca, npoints=50,
    boundary=Polygon, nmax=8)
netb2.uk &lt;- network.design(z~x + y + x*y + I(x^2)+I(y^2), vgmuk2.ca, npoints=100,
    boundary=Polygon, nmax=8)

## End(Not run)
</code></pre>

<hr>
<h2 id='pocket.plot'>
graphs the probability or standardized variance in the directions north-south or east-west
</h2><span id='topic+pocket.plot'></span>

<h3>Description</h3>

<p>The pocket-plot (so named because of its use in detecting pockets
of non-stationarity) is a technique necessary to identify a localized
area that is atypical with respect to the stationarity model. It is built
to exploit the spatial nature of the data through the coordinates
of rows and columns (east &quot;X&quot; and north &quot;Y&quot;, respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pocket.plot(data, graph, X, Y, Z, Iden=F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pocket.plot_+3A_data">data</code></td>
<td>
<p>data frame should contain the dependent variable and coordinates X and Y, data must be gridded</p>
</td></tr>
<tr><td><code id="pocket.plot_+3A_graph">graph</code></td>
<td>
<p>type of graph associated with the probability or standardized variance plot pocket in the directions north-south or east-west;
Probabilities PocketPlot by rows, ie horizontal &quot;south-north&quot; (PPR), Probabilities PocketPlot by columns, ie vertical &quot;east-west&quot; (PPC), 
PocketPlot of variance by rows, ie horizontal &quot;south-north&quot; (PVR) and PocketPlot of variance by columns, ie vertical &quot;east-west&quot; (PVC)</p>
</td></tr>
<tr><td><code id="pocket.plot_+3A_x">X</code></td>
<td>
<p>defined by the spatial coordinates</p>
</td></tr>
<tr><td><code id="pocket.plot_+3A_y">Y</code></td>
<td>
<p>defined by the spatial coordinates</p>
</td></tr>
<tr><td><code id="pocket.plot_+3A_z">Z</code></td>
<td>
<p>regionalized variable with which you construct the statistics associated with the probability or standardized variance, these are plotted in the so-called pocket plot</p>
</td></tr>
<tr><td><code id="pocket.plot_+3A_iden">Iden</code></td>
<td>
<p> logical. The users can identify the points by themselves, TRUE or FALSE. FALSE by default is used.</p>
</td></tr>
<tr><td><code id="pocket.plot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For identifying outliers, this function uses a modification of the boxplot.with.outlier.label function, available at 
<a href="https://www.r-statistics.com/2011/01/how-to-label-all-the-outliers-in-a-boxplot/">https://www.r-statistics.com/2011/01/how-to-label-all-the-outliers-in-a-boxplot/</a>
</p>


<h3>Value</h3>

<p>returns (or plots) the pocket plot
</p>


<h3>References</h3>

<p>Cressie, N.A.C. 1993. <em>Statistics for Spatial Data</em>. Wiley.
</p>
<p>Gomez, M., Hazen, K. 1970. <em>Evaluating sulfur and ash distribution in coal seems by statistical
response surface regression analysis</em>. U.S. Bureau of Mines Report RI 7377.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Core measurements (in % coal ash) at reoriented locations. 
# Units on the vertical axis are % coal ash.

# These data was found in mining samples originally reported by 
# Gomez and Hazen (1970), and later used by Cressie (1993). 

# These data are available in the sp and gstat packages

library(gstat)
data(coalash) 
plot(coalash[,1:2], type="n", xlab="x", ylab="y") 
text(coalash$x,coalash$y,coalash$coalash,cex=0.6)

# Pocket plot in the north-south direction. 
# Units on the vertical axis are root (% coal ash) 

# Plot generated with the function pocket.plot 
# Clearly rows 2, 6, and 8 are atypical 

# This serves as verification that these rows are potentially problematic

# Analysis of local stationarity in probabilities of the coal in south-north direction

pocket.plot(coalash, "PPR", coalash$x, coalash$y, coalash$coalash, FALSE)

# Analysis of local stationarity in variance of the coal in south-north direction 

pocket.plot(coalash, "PVR", coalash$x, coalash$y, coalash$coalash, FALSE) 

# Analysis of local stationarity in probabilities of the coal in east-west direction 

pocket.plot(coalash, "PPC", coalash$x, coalash$y, coalash$coalash, FALSE) 

# Analysis of local stationarity in variance of the coal in east-west direction 

pocket.plot(coalash, "PVC", coalash$x, coalash$y, coalash$coalash, FALSE)
</code></pre>

<hr>
<h2 id='preci'>
Empirical data related to rainfall
</h2><span id='topic+preci'></span>

<h3>Description</h3>

<p>Empirically generated data in 10 arbitrary locations associated with
the rainfall variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(preci)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 4 variables:
</p>

<dl>
<dt><code>Obs</code></dt><dd><p>a numeric vector; observation number</p>
</dd>
<dt><code>x</code></dt><dd><p>a numeric vector; x-coordinate; unknown reference </p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector; y-coordinate; unknown reference </p>
</dd>
<dt><code>prec</code></dt><dd><p>a numeric vector; the target variable</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(preci)
summary(preci)
</code></pre>

<hr>
<h2 id='rbf'>
gaussian, exponential, trigonometric, thin plate spline, inverse multiquadratic, and multiquadratic radial basis function prediction
</h2><span id='topic+rbf'></span>

<h3>Description</h3>

               
<p>Function for gaussian (GAU), exponential (EXPON), trigonometric (TRI), thin plate spline (TPS), completely regularized spline (CRS), 
spline with tension (ST), inverse multiquadratic (IM), and multiquadratic (M) radial basis function (<em>rbf</em>),
where <em>rbf</em> is in a local neighbourhood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbf(formula, data, eta, rho, newdata, n.neigh, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbf_+3A_formula">formula</code></td>
<td>
<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <code>z</code>, for a <em>rbf</em> detrended use <code>z~1</code>, for a <em>rbf</em> with trend, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>, use the formula <code>z~x+y</code> (linear trend).</p>
</td></tr>
<tr><td><code id="rbf_+3A_data">data</code></td>
<td>
<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.</p>
</td></tr>
<tr><td><code id="rbf_+3A_eta">eta</code></td>
<td>
<p>the optimal smoothing parameter, we recommend using the parameter
found by minimizing the root-mean-square prediction errors using cross-validation</p>
</td></tr>
<tr><td><code id="rbf_+3A_rho">rho</code></td>
<td>
<p>the optimal parameter robustness, we recommend using the parameter
found by minimizing the root-mean-square prediction errors using cross-validation.
eta and rho parameters can be optimized simultaneously, through the <code>bobyqa</code> function from <code>nloptr</code> or <code>minqa</code> packages</p>
</td></tr>
<tr><td><code id="rbf_+3A_newdata">newdata</code></td>
<td>
<p>data frame or spatial object with prediction/simulation locations; should contain attribute columns with the independent variables (if present) and (if locations is a formula) the coordinates with names, as defined in locations where you want to generate new predictions</p>
</td></tr>
<tr><td><code id="rbf_+3A_n.neigh">n.neigh</code></td>
<td>
<p>number of nearest observations that should be used for a <em>rbf</em>
prediction, where nearest is defined in terms of the spatial locations</p>
</td></tr>
<tr><td><code id="rbf_+3A_func">func</code></td>
<td>
<p>radial basis function model type, e.g. &quot;GAU&quot;, &quot;EXPON&quot;, &quot;TRI&quot;, &quot;TPS&quot;, &quot;CRS&quot;, &quot;ST&quot;, &quot;IM&quot; and &quot;M&quot;, are currently available</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rbf function generates individual predictions from gaussian (GAU), exponential (EXPON), trigonometric (TRI)
thin plate spline (TPS), completely regularized spline (CRS), spline with tension (ST), 
inverse multiquadratic (IM), and multiquadratic (M) functions
</p>


<h3>Value</h3>

<p>Attributes columns contain coordinates, predictions, and the variance
column contains NA's
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preci)
coordinates(preci) &lt;- ~x+y

# prediction case: one point
point &lt;- data.frame(3,4)
names(point) &lt;- c("x","y")
coordinates(point) &lt;- ~x+y
rbf(prec~x+y, preci, eta=0.1460814, rho=0, newdata=point,n.neigh=10, func="TPS")

# prediction case: a grid of points
puntos&lt;-expand.grid(x=seq(min(preci$x),max(preci$x),0.05), y=seq(min(preci$y),
max(preci$y),0.05))
coordinates(puntos) &lt;- ~x+y
pred.rbf &lt;- rbf(prec~x+y, preci, eta=0.1460814, rho=0, newdata=puntos, n.neigh=10, func="TPS")
coordinates(pred.rbf) = c("x", "y")
gridded(pred.rbf) &lt;- TRUE

# show prediction map
spplot(pred.rbf["var1.pred"], cuts=40, col.regions=bpy.colors(100),
main = "rainfall map TPS", key.space=list(space="right", cex=0.8))
</code></pre>

<hr>
<h2 id='rbf.cv'>
rbf cross validation leave-one-out
</h2><span id='topic+rbf.cv'></span>

<h3>Description</h3>

<p>Generate the RMSPE value, which is given by the radial basis function
with smoothing parameter <code>eta</code> and robustness parameter <code>rho</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbf.cv(formula, data, eta, rho, n.neigh, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbf.cv_+3A_formula">formula</code></td>
<td>

<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <code>z</code>, for a <em>rbf</em> detrended use <code>z~1</code>, for a <em>rbf</em> with trend, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>, use the formula <code>z~x+y</code> (linear trend).
</p>
</td></tr>
<tr><td><code id="rbf.cv_+3A_data">data</code></td>
<td>

<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.
</p>
</td></tr>
<tr><td><code id="rbf.cv_+3A_eta">eta</code></td>
<td>

<p>the optimal smoothing parameter; we recommend using the parameter found by minimizing the root-mean-square prediction errors using cross-validation
</p>
</td></tr>
<tr><td><code id="rbf.cv_+3A_rho">rho</code></td>
<td>

<p>value of optimal robustness parameter; we recommend using the parameter
found by minimizing the root-mean-square prediction errors using cross-validation.
<em>eta</em> and <em>rho</em> parameters can be optimized simultaneously, through the <code>bobyqa</code> function from <code>nloptr</code> or <code>minqa</code> packages
</p>
</td></tr>
<tr><td><code id="rbf.cv_+3A_n.neigh">n.neigh</code></td>
<td>

<p>number of nearest observations that should be used for a <em>rbf</em> prediction, where nearest is defined in terms of the spatial locations
</p>
</td></tr>
<tr><td><code id="rbf.cv_+3A_func">func</code></td>
<td>

<p>radial basis function model type, e.g. &quot;GAU&quot;, &quot;EXPON&quot;, &quot;TRI&quot;, &quot;TPS&quot;, &quot;CRS&quot;, &quot;ST&quot;, &quot;IM&quot; and &quot;M&quot;, are currently available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the RMSPE value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbf">rbf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preci)
coordinates(preci)&lt;-~x+y
rbf.cv(prec~1, preci, eta=0.2589, rho=0, n.neigh=9, func="M") 
</code></pre>

<hr>
<h2 id='rbf.cv1'>
Generates a RMSPE value, result of cross validation leave-one-out
</h2><span id='topic+rbf.cv1'></span>

<h3>Description</h3>

<p>Generate the RMSPE value, which is given by the radial basis function
with smoothing parameter <em>eta</em> and robustness parameter <em>rho</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbf.cv1(param, formula, data, n.neigh, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbf.cv1_+3A_param">param</code></td>
<td>

<p>vector starting points (<em>eta</em> and <em>rho</em> respectively) for searching the <em>RMSPE</em> optimum.
</p>
</td></tr>
<tr><td><code id="rbf.cv1_+3A_formula">formula</code></td>
<td>

<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <em>z</em>, for a <em>rbf</em> detrended use <em>z~1</em>, for a <em>rbf</em> with trend, suppose <em>z</em> is linearly dependent on <em>x</em> and <em>y</em>, use the formula <em>z~x+y</em> (linear trend).
</p>
</td></tr>
<tr><td><code id="rbf.cv1_+3A_data">data</code></td>
<td>

<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.
</p>
</td></tr>
<tr><td><code id="rbf.cv1_+3A_n.neigh">n.neigh</code></td>
<td>

<p>number of nearest observations that should be used for a <em>rbf</em> prediction, where nearest is defined in terms of the spatial locations
</p>
</td></tr>
<tr><td><code id="rbf.cv1_+3A_func">func</code></td>
<td>

<p>radial basis function model type, e.g. &quot;GAU&quot;, &quot;EXPON&quot;, &quot;TRI&quot;, &quot;TPS&quot;, &quot;CRS&quot;, &quot;ST&quot;, &quot;IM&quot; and &quot;M&quot;, are currently available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the RMSPE value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbf">rbf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(preci)
coordinates(preci) &lt;- ~x+y
bobyqa(c(0.5, 0.5), rbf.cv1, lower=c(1e-05,0), upper=c(2,2), formula=prec~x+y, data=preci,
    n.neigh=9, func="TRI")
# obtained with the optimal values previously estimated
rbf.cv1(c(0.2126191,0.1454171), prec~x+y, preci, n.neigh=9, func="TRI")  

## End(Not run)
</code></pre>

<hr>
<h2 id='RBF.phi'>
radial basis function evaluation
</h2><span id='topic+RBF.phi'></span>

<h3>Description</h3>

<p>generate the value associated with radial basis functions; gaussian GAU), exponential (EXPON),
trigonometric (TRI), thin plate spline (TPS), completely regularized spline (CRS),
spline with tension (ST), inverse multiquadratic (IM), and multiquadratic (M)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RBF.phi(distance, eta, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RBF.phi_+3A_distance">distance</code></td>
<td>
<p>corresponds to the Euclidean distance between two points in space</p>
</td></tr>
<tr><td><code id="RBF.phi_+3A_eta">eta</code></td>
<td>
<p>the optimal smoothing parameter is found by minimizing the root-mean-square prediction errors using cross-validation</p>
</td></tr>
<tr><td><code id="RBF.phi_+3A_func">func</code></td>
<td>
<p>radial basis function model type, e.g. &quot;GAU&quot;, &quot;EXPON&quot;, &quot;TRI&quot;, &quot;TPS&quot;, &quot;CRS&quot;, &quot;ST&quot;, &quot;IM&quot; and &quot;M&quot;, are currently available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value obtained from the radial basis function generated with a distance,
a <em>eta</em> smoothing parameter, and a function &quot;GAU&quot;, &quot;EXPON&quot;, &quot;TRI&quot;, &quot;TPS&quot;,  &quot;CRS&quot;, &quot;ST&quot;, &quot;IM&quot; or &quot;M&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preci) 
d1 &lt;- dist(rbind(preci[1,],preci[2,])) 
RBF.phi(distance=d1, eta=0.5, func="TPS")
</code></pre>

<hr>
<h2 id='rbf.tcv'>
table of rbf cross validation, leave-one-out
</h2><span id='topic+rbf.tcv'></span>

<h3>Description</h3>

<p>Generates a table with the results of the evaluation of radial basis functions (<em>rbf</em>): gaussian (GAU), exponential (EXPON), trigonometric (TRI), thin plate spline (TPS), completely regularized spline (CRS), spline with tension (ST), inverse multiquadratic (IM), and multiquadratic (M) from the leave-one-out cross validation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbf.tcv(formula, data, eta, rho, n.neigh, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbf.tcv_+3A_formula">formula</code></td>
<td>

<p>formula that defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name <em>z</em>, for a <em>rbf</em> detrended use <em>z~1</em>, for a <em>rbf</em> with trend, suppose <em>z</em> is linearly dependent on <em>x</em> and <em>y</em>, use the formula <em>z~x+y</em> (linear trend).
</p>
</td></tr>
<tr><td><code id="rbf.tcv_+3A_data">data</code></td>
<td>

<p>SpatialPointsDataFrame: should contain the dependent variable, independent variables, and coordinates.
</p>
</td></tr>
<tr><td><code id="rbf.tcv_+3A_eta">eta</code></td>
<td>

<p>the optimal smoothing parameter; we recommend using the parameter found by minimizing the root-mean-square prediction errors using cross-validation
</p>
</td></tr>
<tr><td><code id="rbf.tcv_+3A_rho">rho</code></td>
<td>

<p>value of optimal parameter robustness; we recommend using the parameter
found by minimizing the root-mean-square prediction errors using cross-validation.
<em>eta</em> and <em>rho</em> parameters can be optimized simultaneously, through the <code>bobyqa</code> function from <code>nloptr</code> or <code>minqa</code> packages
</p>
</td></tr>
<tr><td><code id="rbf.tcv_+3A_n.neigh">n.neigh</code></td>
<td>

<p>number of nearest observations that should be used for a <em>rbf</em>
prediction, where nearest is defined in terms of the spatial locations
</p>
</td></tr>
<tr><td><code id="rbf.tcv_+3A_func">func</code></td>
<td>

<p>radial basis function model type, e.g. &quot;GAU&quot;, &quot;EXPON&quot;, &quot;TRI&quot;, &quot;TPS&quot;,
&quot;CRS&quot;, &quot;ST&quot;, &quot;MI&quot; and &quot;M&quot;, are currently available
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leave-one-out cross validation (LOOCV) visits a data point, predicts
the value at that location by leaving out the observed value, and
proceeds with the next data point. The observed value is left out
because rbf would otherwise predict the same value 
</p>


<h3>Value</h3>

<p>data frame contain the data coordinates, prediction columns, observed
values, residuals, the prediction variance, zscore (residual divided
by standard error) which left with NA's, and the fold column which
is associated to cross-validation count. Prediction columns and residuals
are obtained from cross-validation data points
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbf">rbf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preci)
coordinates(preci)&lt;-~x+y
rbf.tcv(prec~x+y, preci, eta=0.1460814, rho=0, n.neigh=9, func="TPS")
</code></pre>

<hr>
<h2 id='samplePts'>
sample <em>n</em> point locations in (or on) a spatial object 
</h2><span id='topic+samplePts'></span>

<h3>Description</h3>

<p>sample location points within a square area, a grid, a polygon, or on a spatial line, using regular or random sampling methods. The function <code>spsample</code> from the package <code>sp</code> is used iteratively to find exactly <em>n</em> sample locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplePts(x, n, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplePts_+3A_x">x</code></td>
<td>
<p>Spatial object; see the <code>sp</code> package for details</p>
</td></tr>
<tr><td><code id="samplePts_+3A_n">n</code></td>
<td>
<p>exact sample size</p>
</td></tr>
<tr><td><code id="samplePts_+3A_type">type</code></td>
<td>
<p>character; &quot;random&quot; for completely spatial random; &quot;regular&quot; for regular (systematically aligned) sampling; &quot;stratified&quot; for stratified random (one single random location in each &quot;cell&quot;); &quot;nonaligned&quot; for nonaligned systematic sampling (nx random y coordinates, ny random x coordinates); &quot;hexagonal&quot; for sampling on a hexagonal lattice; &quot;clustered&quot; for clustered sampling; &quot;Fibonacci&quot; for Fibonacci sampling on the sphere. See the <code>sp</code> package for details</p>
</td></tr>
<tr><td><code id="samplePts_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>spsample</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="sp.html#topic+SpatialPoints-class">SpatialPoints-class</a></code>
</p>


<h3>See Also</h3>

<p>See <code><a href="sp.html#topic+spsample">spsample</a></code> in the <code>sp</code> package 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalib)
hexPts &lt;- samplePts(lalib, 5, "hexagonal")
plot(lalib, xlim=c(bbox(lalib)[1], bbox(lalib)[3]), ylim=c(bbox(lalib)[2],
    bbox(lalib)[4]))
plot(hexPts, add=TRUE)
## Not run: 
randomPts &lt;- samplePts(lalib, 5, "random")
plot(lalib, xlim=c(bbox(lalib)[1], bbox(lalib)[3]), ylim=c(bbox(lalib)[2],
    bbox(lalib)[4]))
plot(randomPts, add=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqPtsOptNet'>
Design of optimal sampling networks through the sequential points method
</h2><span id='topic+seqPtsOptNet'></span>

<h3>Description</h3>

<p>Search for the optimum location of one additional point to be added to an initial network, minimizing the average standard error of kriging through a genetic algorithm. It takes, as input for the optimization, the minimum and maximum values of the coordinates that enclose the study area. This function uses previous samples information to direct additional sampling. The location of the new point is searched randomly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqPtsOptNet(formula, loc=NULL, data, fitmodel, BLUE=FALSE, n=1, prevSeqs=NULL, 
popSize, generations, xmin, ymin, xmax, ymax, plotMap=FALSE, spMap=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqPtsOptNet_+3A_formula">formula</code></td>
<td>

<p>formula that defines the interpolation method to be used. In this parameter, a dependent variable is defined as a linear model of independent variables. Suppose the dependent variable has name
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>;
for simple kriging also define <code>beta</code>; for universal
kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>,
use the formula <code>z~x+y</code>. See the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_loc">loc</code></td>
<td>

<p>object of class Spatial, or (deprecated) formula that defines the spatial data locations (coordinates) such as ~x+y; see the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_data">data</code></td>
<td>

<p>data frame containing the dependent variable, independent variables, and coordinates; see the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_fitmodel">fitmodel</code></td>
<td>

<p>variogram model of dependent variable (or its residuals), defined by a call to <code>vgm</code> or <code>fit.variogram</code>; see the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_blue">BLUE</code></td>
<td>
<p>logical; if TRUE return the BLUE trend estimates only, if FALSE return the BLUP predictions (kriging); see <code><a href="gstat.html#topic+predict.gstat">predict.gstat</a></code> in the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_n">n</code></td>
<td>

<p>by default, set to 1 for the sequential points method
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_prevseqs">prevSeqs</code></td>
<td>

<p>if NULL, the function finds the first optimum sequential point. Otherwise, an object of class <code>SpatialPoints</code> containing optimum points previously found must be provided
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_popsize">popSize</code></td>
<td>

<p>population size; see the <code>genalg</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_generations">generations</code></td>
<td>

<p>number of iterations. Usually, hundreds or thousands are required. See the <code>genalg</code> package for details
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_xmin">xmin</code></td>
<td>

<p>minimum <em>x</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_ymin">ymin</code></td>
<td>

<p>minimum <em>y</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_xmax">xmax</code></td>
<td>

<p>maximum <em>x</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_ymax">ymax</code></td>
<td>

<p>maximum <em>y</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_plotmap">plotMap</code></td>
<td>

<p>logical; if TRUE, the optimized spatial locations of additional points are plotted
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_spmap">spMap</code></td>
<td>

<p>an object of class Spatial; it must be provided if plotMap is set to TRUE
</p>
</td></tr>
<tr><td><code id="seqPtsOptNet_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to <code>gstat</code> or <code>rbga</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class rbga containing the population and the evaluation of the objective function for each chromosome in the last generation, the best and mean evaluation value in each generation, and additional information
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153/">[link]</a>
</p>
<p>Delmelle, E., 2005. <em>Optimization of second-phase spatial sampling using auxiliary information</em>. Ph.D. Thesis, Dept. Geography, State University of New York, Buffalo, NY.
</p>


<h3>See Also</h3>

<p>See <code><a href="genalg.html#topic+rbga">rbga</a></code> in the <code>genalg</code> package and <code><a href="gstat.html#topic+krige">krige</a></code> in the <code>gstat</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load data
data(COSha10)
data(COSha10map)
data(lalib)

## Calculate the sample variogram for data, generate the variogram model and  
## fit ranges and/or sills from the variogram model to the sample variogram
ve &lt;- variogram(CorT~ 1, loc=~x+y, data=COSha10, width = 230.3647)
PSI &lt;- 0.0005346756; RAN &lt;- 1012.6411; NUG &lt;- 0.0005137079
m.esf &lt;- vgm(PSI, "Sph", RAN, NUG)
(m.f.esf &lt;- fit.variogram(ve, m.esf))

## Optimize the location of the first additional point 
## Only 15 generations are evaluated in this example (using ordinary kriging)
## Users can visualize how the location of the additional point is optimized 
## if plotMap is set to TRUE
old.par &lt;- par(no.readonly = TRUE)
par(ask=FALSE)
optpt &lt;- seqPtsOptNet(CorT~ 1, loc=~x+y, COSha10, m.f.esf, popSize=30, 
    generations=15, xmin=bbox(lalib)[1], ymin=bbox(lalib)[2], xmax=bbox(lalib)[3], 
    ymax=bbox(lalib)[4], plotMap=TRUE, spMap=lalib)
par(old.par)

## Summary of the genetic algorithm results
summary(optpt, echo=TRUE)

## Graph of best and mean evaluation value of the objective function 
## (average standard error) along generations
plot(optpt)

## Find and plot the best set of additional points (best chromosome) in   
## the population in the last generation
(bnet1 &lt;- bestnet(optpt))
l1 = list("sp.polygons", lalib)
l2 = list("sp.points", bnet1, col="green", pch="*", cex=5)
spplot(COSha10map, "var1.pred", main="Location of the optimized point", 
    col.regions=bpy.colors(100), scales = list(draw =TRUE), xlab ="East (m)", 
    ylab = "North (m)", sp.layout=list(l1,l2))

## Average standard error of the optimized sequential point
min(optpt$evaluations)

## Optimize the location of the second sequential point, taking into account 
## the first one
plot(lalib)
old.par &lt;- par(no.readonly = TRUE)
par(ask=FALSE)
optpt2 &lt;- seqPtsOptNet(CorT~ 1, loc=~x+y, COSha10, m.f.esf, prevSeqs=bnet1, 
    popSize=30, generations=15, xmin=bbox(lalib)[1], ymin=bbox(lalib)[2], 
    xmax=bbox(lalib)[3], ymax=bbox(lalib)[4], plotMap=TRUE, spMap=lalib)
par(old.par)

## Find the second optimal sequential point and use it, along with the first
## one, to find another optimal sequential point, and so on iteratively  

bnet2 &lt;- bestnet(optpt2)
bnet &lt;- rbind(bnet1, bnet2)

old.par &lt;- par(no.readonly = TRUE)
par(ask=FALSE)
optpt3 &lt;- seqPtsOptNet(CorT~ 1, loc=~x+y, COSha10, m.f.esf, prevSeqs=bnet,
    popSize=30, generations=25, xmin=bbox(lalib)[1], ymin=bbox(lalib)[2], 
    xmax=bbox(lalib)[3], ymax=bbox(lalib)[4], plotMap=TRUE, spMap=lalib)
par(old.par)

## End(Not run)

## Multivariate prediction is also enabled:
## Not run: 
ve &lt;- variogram(CorT~ DA10, loc=~x+y, data=COSha10, width = 230.3647)
(m.f.esf &lt;- fit.variogram(ve, m.esf))

optptMP &lt;- seqPtsOptNet(CorT~ DA10, loc=~x+y, COSha10, m.f.esf, popSize=30, 
    generations=25, xmin=bbox(lalib)[1], ymin=bbox(lalib)[2], xmax=bbox(lalib)[3], 
    ymax=bbox(lalib)[4], plotMap=TRUE, spMap=lalib)

## End(Not run)
</code></pre>

<hr>
<h2 id='simPtsOptNet'>
Design of optimal sampling networks through the simultaneous points method
</h2><span id='topic+simPtsOptNet'></span>

<h3>Description</h3>

<p>Search for an optimum set of simultaneous additional points to an initial network that minimize the average standard error of kriging, using a genetic algorithm. It takes, as input for the optimization, the minimum and maximum values of the coordinates that enclose the study area. This function uses previous samples information to direct
additional sampling for minimum average standard error. The algorithm generates random sampling schemes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPtsOptNet(formula, loc=NULL, data, fitmodel, BLUE=FALSE, n, popSize, 
generations, xmin, ymin, xmax, ymax, plotMap=FALSE, spMap=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simPtsOptNet_+3A_formula">formula</code></td>
<td>

<p>formula that defines the interpolation method to be used. In this parameter, a dependent variable is defined as a linear model of independent variables. Suppose the dependent variable has name
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>;
for simple kriging also define <code>beta</code>; for universal
kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>,
use the formula <code>z~x+y</code>. See the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_loc">loc</code></td>
<td>

<p>object of class Spatial, or (deprecated) formula that defines the spatial data locations (coordinates) such as ~x+y; see the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_data">data</code></td>
<td>

<p>data frame containing the dependent variable, independent variables, and coordinates; see the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_fitmodel">fitmodel</code></td>
<td>

<p>variogram model of dependent variable (or its residuals), defined by a call to <code>vgm</code> or <code>fit.variogram</code>; see the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_blue">BLUE</code></td>
<td>
<p>logical; if TRUE return the BLUE trend estimates only, if FALSE return the BLUP predictions (kriging); see <code><a href="gstat.html#topic+predict.gstat">predict.gstat</a></code> in the <code>gstat</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_n">n</code></td>
<td>

<p>number of additional points to be added to the original network
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_popsize">popSize</code></td>
<td>

<p>population size; see the <code>genalg</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_generations">generations</code></td>
<td>

<p>number of iterations. Usually, hundreds or thousands are required. See the <code>genalg</code> package for details
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_xmin">xmin</code></td>
<td>

<p>minimum <em>x</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_ymin">ymin</code></td>
<td>

<p>minimum <em>y</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_xmax">xmax</code></td>
<td>

<p>maximum <em>x</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_ymax">ymax</code></td>
<td>

<p>maximum <em>y</em>-coordinate of the study area
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_plotmap">plotMap</code></td>
<td>

<p>logical; if TRUE, the optimized spatial locations of additional points are plotted
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_spmap">spMap</code></td>
<td>

<p>an object of class Spatial; it must be provided if plotMap is set to TRUE
</p>
</td></tr>
<tr><td><code id="simPtsOptNet_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to <code>gstat</code> or <code>rbga</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class rbga containing the population and the evaluation of the objective function for each chromosome in the last generation, the best and mean evaluation value in each generation, and additional information
</p>


<h3>References</h3>

<p>Santacruz, A., Rubiano, Y., Melo, C., 2014. <em>Evolutionary optimization of spatial sampling networks designed for the monitoring of soil carbon</em>. In: Hartemink, A., McSweeney, K. (Eds.). <em>Soil Carbon. Series: Progress in Soil Science</em>. (pp. 77-84). Springer. <a href="https://link.springer.com/chapter/10.1007/978-3-319-04084-4_8">[link]</a>
</p>
<p>Santacruz, A., 2011. <em>Evolutionary optimization of spatial sampling networks. An application of genetic algorithms and geostatistics for the monitoring of soil organic carbon</em>. Editorial Academica Espanola. 183 p. ISBN: 978-3-8454-9815-7 (In Spanish) <a href="https://www.amazon.com/Optimizacion-evolutiva-redes-espaciales-muestreo/dp/3845498153/">[link]</a>
</p>
<p>Delmelle, E., 2005. <em>Optimization of second-phase spatial sampling using auxiliary information</em>. Ph.D. Thesis, Dept. Geography, State University of New York, Buffalo, NY.
</p>


<h3>See Also</h3>

<p>See <code><a href="genalg.html#topic+rbga">rbga</a></code> in the <code>genalg</code> package and <code><a href="gstat.html#topic+krige">krige</a></code> in the <code>gstat</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load data
data(COSha30)
data(COSha30map)
data(lalib)

## Calculate the sample variogram for data, generate the variogram model and  
## fit ranges and/or sills from the variogram model to the sample variogram
ve &lt;- variogram(CorT~ 1, loc=~x+y, data=COSha30, width = 236.0536)
PSI &lt;- 0.0001531892; RAN &lt;- 1031.8884; NUG &lt;- 0.0001471817
m.esf &lt;- vgm(PSI, "Sph", RAN, NUG)
(m.f.esf &lt;- fit.variogram(ve, m.esf))

## Number of additional points to be added to the network
npoints &lt;- 5

## Optimize the location of the additional points
## Only 20 generations are evaluated in this example (using ordinary kriging)
## Users can visualize how the location of the additional points is optimized 
## if plotMap is set to TRUE
old.par &lt;- par(no.readonly = TRUE)
par(ask=FALSE)
optnets &lt;- simPtsOptNet(CorT~ 1, loc=~x+y, COSha30, m.f.esf, n=npoints, 
    popSize=30, generations=20, xmin=bbox(lalib)[1], ymin=bbox(lalib)[2], 
    xmax=bbox(lalib)[3], ymax=bbox(lalib)[4], plotMap=TRUE, spMap=lalib)
par(old.par)

## Summary of the genetic algorithm results
summary(optnets, echo=TRUE)

## Graph of best and mean evaluation value of the objective function 
## (average standard error) along generations
plot(optnets)

## Find and plot the best set of additional points (best chromosome) in   
## the population in the last generation
(bnet &lt;- bestnet(optnets))
l1 = list("sp.polygons", lalib)
l2 = list("sp.points", bnet, col="green", pch="*", cex=5)
spplot(COSha30map, "var1.pred", main="Location of the optimized points", 
    col.regions=bpy.colors(100), scales = list(draw =TRUE), xlab ="East (m)", 
    ylab = "North (m)", sp.layout=list(l1,l2))

## Average standard error of the optimized additional points
min(optnets$evaluations)

## End(Not run)

## Multivariate prediction is also enabled:
## Not run: 
ve &lt;- variogram(CorT~ DA30, loc=~x+y, data=COSha30, width = 236.0536)
(m.f.esf &lt;- fit.variogram(ve, m.esf))

optnetsMP &lt;- simPtsOptNet(CorT~ DA30, loc=~x+y, COSha30, m.f.esf, n=npoints, 
    popSize=30, generations=25, xmin=bbox(lalib)[1], ymin=bbox(lalib)[2], 
    xmax=bbox(lalib)[3], ymax=bbox(lalib)[4], plotMap=TRUE, spMap=lalib)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
