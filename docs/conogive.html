<!DOCTYPE html><html><head><title>Help for package conogive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {conogive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conogive'><p>Estimate a Congeneric Normal-Ogive Model</p></a></li>
<li><a href='#massage_cuts'><p>Massage Cuts to the Desired Shape</p></a></li>
<li><a href='#ordered_y'><p>Transform y Into a Form Where Each Category is An Positive Integer</p></a></li>
<li><a href='#predict.conogive'><p>Predict Method for Conogive Objects</p></a></li>
<li><a href='#reliability'><p>Calculate the Ordinal Reliabiltiy</p></a></li>
<li><a href='#standardize'><p>Standardize Parameter Vectors</p></a></li>
<li><a href='#thurstone'><p>Thurstone weights</p></a></li>
<li><a href='#tr'><p>Trace of matrix</p></a></li>
<li><a href='#trim_vector'><p>Remove Infinities from Vector, Append and Prepend <code>-Inf</code> and <code>Inf</code>, and Sort</p></a></li>
<li><a href='#x_hat'><p>Transform Likert data to X_hats.</p></a></li>
<li><a href='#xi_sample'><p>Calculate Sample Xi</p></a></li>
<li><a href='#xi_theoretical'><p>Calculate the Theoretical Xi</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Congeneric Normal-Ogive Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The congeneric normal-ogive model is a popular model for 
   psychometric data (McDonald, R. P. (1997) &lt;<a href="https://doi.org/10.1007%2F978-1-4757-2691-6_15">doi:10.1007/978-1-4757-2691-6_15</a>&gt;).
   This model estimates the model, calculates theoretical and concrete 
   reliability coefficients, and predicts the latent variable of the model. 
   This is the companion package to Moss (2020) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fnvg5d">doi:10.31234/osf.io/nvg5d</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JonasMoss/conogive">https://github.com/JonasMoss/conogive</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JonasMoss/conogive/issues">https://github.com/JonasMoss/conogive/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>psych, mvtnorm, checkmate, assertthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), psychTools, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-30 10:02:28 UTC; jonas</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Moss <a href="https://orcid.org/0000-0002-6876-6964"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Moss &lt;jonas.gjertsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-30 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='conogive'>Estimate a Congeneric Normal-Ogive Model</h2><span id='topic+conogive'></span>

<h3>Description</h3>

<p><code>conogive</code> is used to estimate congeneric normal-ogive models
(McDonald, R. P. (1997)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conogive(data, use = "complete.obs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conogive_+3A_data">data</code></td>
<td>
<p>A data frame of observations or a named list with elements
<code>lambda</code>, <code>sigma</code>, and <code>cuts</code>. See the details.</p>
</td></tr>
<tr><td><code id="conogive_+3A_use">use</code></td>
<td>
<p>Passed to <code>stats::cov</code>; defaults to <code>"complete.obs"</code>.</p>
</td></tr>
<tr><td><code id="conogive_+3A_...">...</code></td>
<td>
<p>Passed to <code>psych::fa</code>, where <code>fm = "ml"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>data</code> argument can be either a list containing the parameters of
a normal-ogive model, or raw data. If actual data is passed to <code>data</code>,
it is passed to <code>psych::polychoric</code> to estimate its polychoric correlation
matrix and cutoffs. This is passed to <code>psych::fa</code> to do a barebones
multivariate normal-ogive model. The <code>...</code> arguments are passed to
<code>psych::fa</code>, which is called with <code>fm = "ml"</code> by default.
</p>
<p>Likert data should start with 1, not 0.
</p>


<h3>Value</h3>

<p>An object of class <code>conogive</code>.
</p>


<h3>References</h3>

<p>McDonald, R. P. (1997). Normal-ogive multidimensional model. In W. J.
van der Linden &amp; R. K. Hambleton (Eds.), Handbook of Modern Item Response
Theory (pp. 257â€“269). Springer.
<a href="https://doi.org/10.1007/978-1-4757-2691-6_15">https://doi.org/10.1007/978-1-4757-2691-6_15</a>
Moss, J. (2020). Please avoid the standardized alpha and the ordinal alpha.
<a href="https://psyarxiv.com/nvg5d">https://psyarxiv.com/nvg5d</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("psychTools")) {
  extraversion = psychTools::bfi[c("E1", "E2", "E3", "E4", "E5")]
  extraversion[, "E1"] = 7 - extraversion[, "E1"] # Reverse-coded item.
  extraversion[, "E2"] = 7 - extraversion[, "E2"] # Reverse-coded item.
  fit = conogive(extraversion)
}
</code></pre>

<hr>
<h2 id='massage_cuts'>Massage Cuts to the Desired Shape</h2><span id='topic+massage_cuts'></span>

<h3>Description</h3>

<p>Massage Cuts to the Desired Shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>massage_cuts(cuts, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="massage_cuts_+3A_cuts">cuts</code></td>
<td>
<p>A matrix, list, or vector of cuts</p>
</td></tr>
<tr><td><code id="massage_cuts_+3A_k">k</code></td>
<td>
<p>Optional <code>k</code> saying how many times the vector of cuts should be
repeated. Only matters when <code>cuts</code> is a vector.</p>
</td></tr>
</table>

<hr>
<h2 id='ordered_y'>Transform y Into a Form Where Each Category is An Positive Integer</h2><span id='topic+ordered_y'></span>

<h3>Description</h3>

<p>Transform y Into a Form Where Each Category is An Positive Integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordered_y(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordered_y_+3A_y">y</code></td>
<td>
<p>An array or data frame of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='predict.conogive'>Predict Method for Conogive Objects</h2><span id='topic+predict.conogive'></span>

<h3>Description</h3>

<p>Predict the latent variable in a congeneric normal-ogive model using the
formula of ((arxiv ref.))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conogive'
predict(object, newdata, weights = c("optimal", "equal"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.conogive_+3A_object">object</code></td>
<td>
<p>An object of class &quot;<code>conogive</code>&quot;.</p>
</td></tr>
<tr><td><code id="predict.conogive_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame with variables to predict with.
The fitted values are used if omitted.</p>
</td></tr>
<tr><td><code id="predict.conogive_+3A_weights">weights</code></td>
<td>
<p>Weights to use; choose between optimal weights and equal
weights.</p>
</td></tr>
<tr><td><code id="predict.conogive_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> if(require("psychTools")) {
   extraversion = psychTools::bfi[c("E1", "E2", "E3", "E4", "E5")]
   extraversion[, "E1"] = 7 - extraversion[, "E1"] # Reverse-coded item.
   extraversion[, "E2"] = 7 - extraversion[, "E2"] # Reverse-coded item.
   object = conogive(extraversion)
   hist(predict(object, extraversion)) # Plot distribution of predictions.
 }
</code></pre>

<hr>
<h2 id='reliability'>Calculate the Ordinal Reliabiltiy</h2><span id='topic+reliability'></span><span id='topic+ordinal_r'></span><span id='topic+theoretical_ordinal_r'></span><span id='topic+theoretical_ordinal_alpha'></span>

<h3>Description</h3>

<p>The function <code>ordinal_r </code> calculates the concrete ordinal reliability.
The functions <code>theoretical_ordinal_r</code> and <code>theoretical_ordinal_alpha</code>
calculates the theoretical ordinal reliability and alpha based on the
polychoric correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_r(
  object,
  xi = c("sample", "theoretical"),
  weights = c("optimal", "equal")
)

theoretical_ordinal_r(object, weights = c("optimal", "equal", "sigma"))

theoretical_ordinal_alpha(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reliability_+3A_object">object</code></td>
<td>
<p>An object of class <code>conogive</code>.</p>
</td></tr>
<tr><td><code id="reliability_+3A_xi">xi</code></td>
<td>
<p>How to calculate the Xi matrix. Option <code>"theoretical"</code> calculates
the theoretical Xi matrix from <code>rho</code>, while  <code>"sample"</code> calculates the
sample Xi matrix.</p>
</td></tr>
<tr><td><code id="reliability_+3A_weights">weights</code></td>
<td>
<p>The weights used to calculate the ordinal reliability.
Option <code>"optimal"</code> uses the optimal weights and <code>"equal"</code> the equal
weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The population value of theoretical ordinal alpha equals the theoretical
ordinal reliability when the underlying multivariate normal is parallel.
The concrete ordinal reliability is the sqaured correlation between the
true latent variable and the best linear predictor of the observed
Likert-type data. See ((ref)) for definitions.
</p>


<h3>Value</h3>

<p>The concrete ordinal reliability, theoretical ordinal reliability, or
theoretical ordinal alpha.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("psychTools")) {
  agreeableness = psychTools::bfi[c("A1", "A2", "A3", "A4", "A5")]
  agreeableness[, "A1"] = 7 - agreeableness[, "A1"] # Reverse-coded item.
  object = conogive(agreeableness)
  ordinal_r(object, weights = "equal") # 0.6394087
  theoretical_ordinal_alpha(object) # 0.7589922
  theoretical_ordinal_r(object, weights = "equal") # 0.7689878
  ordinal_r(object, weights = "optimal") # 0.6763742
  theoretical_ordinal_r(object) # 0.8101108
}
</code></pre>

<hr>
<h2 id='standardize'>Standardize Parameter Vectors</h2><span id='topic+standardize'></span><span id='topic+standardize_lambda'></span><span id='topic+standardize_sigma'></span>

<h3>Description</h3>

<p>The function <code>standardize_lambda</code> standardizes <code>lambda</code> and
<code>standardize_sigma</code> standardizes <code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_lambda(lambda, sigma)

standardize_sigma(lambda, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_lambda">lambda</code></td>
<td>
<p>Vector of loadings.</p>
</td></tr>
<tr><td><code id="standardize_+3A_sigma">sigma</code></td>
<td>
<p>Vector of standard deviations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardized vector.
</p>

<hr>
<h2 id='thurstone'>Thurstone weights</h2><span id='topic+thurstone'></span>

<h3>Description</h3>

<p>Thurstone weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thurstone(lambda, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thurstone_+3A_lambda">lambda</code></td>
<td>
<p>Vector of loadings.</p>
</td></tr>
<tr><td><code id="thurstone_+3A_sigma">sigma</code></td>
<td>
<p>Vector of standard deviations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Thurstone weights.
</p>

<hr>
<h2 id='tr'>Trace of matrix</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Trace of matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_a">A</code></td>
<td>
<p>A square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trace of the matrix.
</p>

<hr>
<h2 id='trim_vector'>Remove Infinities from Vector, Append and Prepend <code>-Inf</code> and <code>Inf</code>, and Sort</h2><span id='topic+trim_vector'></span>

<h3>Description</h3>

<p>Remove Infinities from Vector, Append and Prepend <code>-Inf</code> and <code>Inf</code>, and Sort
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_vector_+3A_x">x</code></td>
<td>
<p>Numeric vector with no <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with <code style="white-space: pre;">&#8288;-Inf`` prepended and &#8288;</code>Inf' appended
</p>

<hr>
<h2 id='x_hat'>Transform Likert data to X_hats.</h2><span id='topic+x_hat'></span>

<h3>Description</h3>

<p>Transform Likert data to X_hats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_hat(y, cuts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_hat_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="x_hat_+3A_cuts">cuts</code></td>
<td>
<p>Vector of cuts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The X_hats associated with <code>y</code> and <code>cuts</code>.
</p>

<hr>
<h2 id='xi_sample'>Calculate Sample Xi</h2><span id='topic+xi_sample'></span>

<h3>Description</h3>

<p>Calculate Sample Xi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xi_sample(y, cuts, use = "complete.obs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xi_sample_+3A_y">y</code></td>
<td>
<p>An array or data frame of observations.</p>
</td></tr>
<tr><td><code id="xi_sample_+3A_cuts">cuts</code></td>
<td>
<p>A matrix, list, or vector of cuts.</p>
</td></tr>
<tr><td><code id="xi_sample_+3A_use">use</code></td>
<td>
<p>Passed to <code>stats::cov</code>; defaults to <code>"complete.obs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sample xi matrix.
</p>

<hr>
<h2 id='xi_theoretical'>Calculate the Theoretical Xi</h2><span id='topic+xi_theoretical'></span>

<h3>Description</h3>

<p>Calculate the Theoretical Xi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xi_theoretical(cuts, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xi_theoretical_+3A_cuts">cuts</code></td>
<td>
<p>A matrix, list, or vector of cuts.</p>
</td></tr>
<tr><td><code id="xi_theoretical_+3A_rho">rho</code></td>
<td>
<p>The polychoric correlation matrix; a numeric matrix with no
missing entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Theoretical xi matrix.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
