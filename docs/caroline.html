<!DOCTYPE html><html><head><title>Help for package caroline</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {caroline}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addFactLevs'><p>Add new levels to the Factors in a DataFrame.</p></a></li>
<li><a href='#bestBy'><p>Find the &quot;best&quot; record within subgroups of a dataframe.</p></a></li>
<li><a href='#dbWriteTable2'><p>Data Import Wrapper for dbWriteTable.</p></a></li>
<li><a href='#distro.dots'><p>Distribution plot of points</p></a></li>
<li><a href='#geomean'><p>Calculate the Geometric Mean</p></a></li>
<li><a href='#groupBy'><p>Group a datafame by a factor and perform aggreate functions.</p></a></li>
<li><a href='#heatmatrix'><p>Simple Heatmap Plot</p></a></li>
<li><a href='#hyperplot'><p>Annotate Outliers in a Scatterplot via an HTML Image-Map</p></a></li>
<li><a href='#install.prev.pkg'><p>Install the next oldest package</p></a></li>
<li><a href='#labsegs'><p>Buffered Segments for Point Labels</p></a></li>
<li><a href='#leghead'><p>Generate a Color Coded Legend dataframe via head and sum.</p></a></li>
<li><a href='#m'><p>Regexp Match Operator</p></a></li>
<li><a href='#makeElipseCoords'><p>Make Elipse Coordinates</p></a></li>
<li><a href='#mvlabs'><p>Move Text Labels Interactively</p></a></li>
<li><a href='#nerge'><p>Named Merge</p></a></li>
<li><a href='#nv'><p>Create a named vector from a dataframe, table or vector</p></a></li>
<li><a href='#pad'><p>Pad a vector of numerical string with zeros.</p></a></li>
<li><a href='#parseArgString'><p>Process Command Line Arguments</p></a></li>
<li><a href='#pct'><p>Add Percentage Columns to a Dataframe</p></a></li>
<li><a href='#pies'><p>Pie chart scatterplot</p></a></li>
<li><a href='#plot.sparge'><p>Visually compare all points from different univariate distributions</p></a></li>
<li><a href='#plotClock'><p>Plot a simple clock.</p></a></li>
<li><a href='#raAddArms'><p>Add Arms to a RA plot.</p></a></li>
<li><a href='#raAddAxLabs'><p>Add axis labels to an RA plot.</p></a></li>
<li><a href='#raAddSigLines'><p>Add Significance Lines to an RA plot.</p></a></li>
<li><a href='#raPlot'><p>Generate a Ratio Average [RAy] Plot.</p></a></li>
<li><a href='#read.tab'><p>Read in a Tab Delimited File.</p></a></li>
<li><a href='#regroup'><p>Regroup a dataframe.</p></a></li>
<li><a href='#rerowname'><p>Rename select rows of a dataframe</p></a></li>
<li><a href='#spie'><p>Spie charts</p></a></li>
<li><a href='#sstable'><p>Sum Sorted Tabulation</p></a></li>
<li><a href='#tab2df'><p>Table to Data Frame</p></a></li>
<li><a href='#textplot'><p>A Text-Only Plot</p></a></li>
<li><a href='#usr2lims'><p>Grab and adjust the current plot dimensions</p></a></li>
<li><a href='#vennMatrix'><p>Create a Venn Ready Matrix out of a List of Factors</p></a></li>
<li><a href='#wjitter'><p>Weighted Jitter</p></a></li>
<li><a href='#write.delim'><p>Write a (tab) delimited text file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-10</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Database, Data Structure, Visualization, and
Utility Functions for R</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schruth</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schruth &lt;code@anthropoidea.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, RSQLite, grid</td>
</tr>
<tr>
<td>Enhances:</td>
<td>DBI, gplots</td>
</tr>
<tr>
<td>Description:</td>
<td>The caroline R library contains dozens of functions useful
    for: database migration (dbWriteTable2), database style joins &amp;
    aggregation (nerge, groupBy &amp; bestBy), data structure
    conversion (nv, tab2df), legend table making (sstable &amp;
    leghead), plot annotation (labsegs &amp; mvlabs), data
    visualization (pies, sparge, &amp; raPlot), character string
    manipulation (m &amp; pad), file I/O (write.delim), batch scripting
    and more.  The package's greatest contributions lie in the 
    database style merge, aggregation and interface functions 
    as well as in it's extensive use and propagation of 
    row, column and vector names in most functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-08 20:15:45 UTC; david</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-09 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addFactLevs'>Add new levels to the Factors in a DataFrame.</h2><span id='topic+addFactLevs'></span>

<h3>Description</h3>

<p>This function loops through all of the factor columns in a dataframe and adds new.levs to the factor levels list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addFactLevs(x, new.levs=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addFactLevs_+3A_x">x</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
<tr><td><code id="addFactLevs_+3A_new.levs">new.levs</code></td>
<td>
<p>new levels to be added.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+factor">factor</a>, <a href="base.html#topic+levels">levels</a>
</p>

<hr>
<h2 id='bestBy'>Find the &quot;best&quot; record within subgroups of a dataframe.</h2><span id='topic+bestBy'></span>

<h3>Description</h3>

<p>Finding the an extreme record for each group within a dataset is a more challenging routine task in R and SQL. 
This function provides a easy interface to that functionality either using R (fast for small data frames) or SQL (fastest for large data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestBy(df, by, best, clmns=names(df), inverse=FALSE, sql=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestBy_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="bestBy_+3A_by">by</code></td>
<td>
<p>the factor (or name of a factor in df) used to determine the grouping.</p>
</td></tr>
<tr><td><code id="bestBy_+3A_clmns">clmns</code></td>
<td>
<p>the colums to include in the output.</p>
</td></tr>
<tr><td><code id="bestBy_+3A_best">best</code></td>
<td>
<p>the column to sort on (both globally and for each sub/group)</p>
</td></tr>
<tr><td><code id="bestBy_+3A_inverse">inverse</code></td>
<td>
<p>the sorting order of the sort column as specified by 'best'</p>
</td></tr>
<tr><td><code id="bestBy_+3A_sql">sql</code></td>
<td>
<p>whether or not to use SQLite to perform the operation.</p>
</td></tr></table>


<h3>Value</h3>

<p>A data frame of 'best' records from each factor level
</p>


<h3>Author(s)</h3>

<p>David Schruth</p>


<h3>See Also</h3>

<p><a href="#topic+groupBy">groupBy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
blast.results &lt;- data.frame(score=c(1,2,34,4,5,3,23), 
                            query=c('z','x','y','z','x','y','z'), 
                            target=c('a','b','c','d','e','f','g')
                            )
best.hits.R &lt;- bestBy(blast.results, by='query', best='score', inverse=TRUE)
best.hits.R
## or using SQLite
best.hits.sql &lt;- bestBy(blast.results, by='query', best='score', inverse=TRUE, sql=TRUE)
best.hits.sql

</code></pre>

<hr>
<h2 id='dbWriteTable2'>Data Import Wrapper for dbWriteTable.</h2><span id='topic+dbWriteTable2'></span>

<h3>Description</h3>

<p>This is wrapper for dbWriteTable written with the the primary improvements focusing on database import into an existing table definition schema.  
The function matches and rearranges columns of the dataframe to database feilds and additionally performs checks for NA's in required variables, overlength strings, and type mismatches.
There also exists support for updating of the PostgreSQL specific sequence for tables with auto incrementing primary keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbWriteTable2(con, table.name, df, fill.null = TRUE, add.id=TRUE, 
                   row.names=FALSE, pg.update.seq=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbWriteTable2_+3A_con">con</code></td>
<td>
<p>connection.</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_table.name">table.name</code></td>
<td>
<p>The name of the table to which the data frame is to be loaded.</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_df">df</code></td>
<td>
<p>A dataframe to be loaded to the database.</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_fill.null">fill.null</code></td>
<td>
<p>Should new db present fields be added to the data.frame before it is loaded?.</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_add.id">add.id</code></td>
<td>
<p>Should a new column should be added for the database id?</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_row.names">row.names</code></td>
<td>
<p>Should the row names be loaded as a seperate column? (unlike the original dbWriteTable, default is FALSE)</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_pg.update.seq">pg.update.seq</code></td>
<td>
<p>should the table primary key's sequence be updated to the highest id value +1? (Postgres specific)</p>
</td></tr>
<tr><td><code id="dbWriteTable2_+3A_...">...</code></td>
<td>
<p>other parameters passed to dbWriteTable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If successful, the ids of the newly added database records (invisible)
</p>


<h3>See Also</h3>

<p><a href="DBI.html#topic+dbReadTable">dbWriteTable</a>
</p>

<hr>
<h2 id='distro.dots'>Distribution plot of points</h2><span id='topic+distro.dots'></span>

<h3>Description</h3>

<p>Plot the raw distribution of points, like a series of horizontal box plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distro.dots(x, jit.f=1, add=FALSE, pd=0,  vv=names(x), vvlabs=NULL,
                  xlim=range(unlist(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distro.dots_+3A_x">x</code></td>
<td>
<p>a list of vectors of values to be plotted</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_jit.f">jit.f</code></td>
<td>
<p>factor for random jittering (see 'jitter()'</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_add">add</code></td>
<td>
<p>should we add to the existing plot?</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_pd">pd</code></td>
<td>
<p>'position dodge' moves all y axis plotting positions up or down by this provided value (useful for adding multiple distributions for the same variable)</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_vv">vv</code></td>
<td>
<p>the variable vector for ordering the y-axis labels</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_vvlabs">vvlabs</code></td>
<td>
<p>the variable vector labels for labeling the plot (defaults to vv)</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_xlim">xlim</code></td>
<td>
<p>x axis plot limits</p>
</td></tr>
<tr><td><code id="distro.dots_+3A_...">...</code></td>
<td>
<p>other parameters passed on to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'distro dot plot' of variable distributions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- rnorm(130, 10, 3)
p &lt;- rpois(110, 4)
u &lt;- runif(300, 0, 20)
l &lt;- rlnorm(130, log(2))
g &lt;- rgamma(140, 3)

X &lt;- list(a=u, random=n, array=p,of=l, variable=u, spreads=g)
distro.dots(x=X, jit.f=3)

</code></pre>

<hr>
<h2 id='geomean'>Calculate the Geometric Mean</h2><span id='topic+geomean'></span>

<h3>Description</h3>

<p>A trivial one-line function for exp(mean(log()))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomean_+3A_x">x</code></td>
<td>
<p>a vector of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the geometric mean (a scalar value)
</p>


<h3>See Also</h3>

<p>geometric.mean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
geomean(rnorm(20,5))

</code></pre>

<hr>
<h2 id='groupBy'>Group a datafame by a factor and perform aggreate functions.</h2><span id='topic+groupBy'></span>

<h3>Description</h3>

<p>The R equvalent of a SQL 'group by' call.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>groupBy(df, by, aggregation,  clmns=names(df), collapse=',',
                distinct=FALSE, sql=FALSE, full.names=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupBy_+3A_df">df</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="groupBy_+3A_by">by</code></td>
<td>
<p>the factor (or name of a factor in df) used to determine the grouping.</p>
</td></tr>
<tr><td><code id="groupBy_+3A_aggregation">aggregation</code></td>
<td>
<p>the functions to perform on the output (default is to sum). Suggested functions are: 'sum','mean','var','sd','max','min','length','paste',NULL.</p>
</td></tr>
<tr><td><code id="groupBy_+3A_clmns">clmns</code></td>
<td>
<p>the colums to include in the output.</p>
</td></tr>
<tr><td><code id="groupBy_+3A_collapse">collapse</code></td>
<td>
<p>string delimiter for columns aggregated via 'paste' concatenation.</p>
</td></tr>
<tr><td><code id="groupBy_+3A_distinct">distinct</code></td>
<td>
<p>used in conjunction with paste and collapse to only return unique elements in a delimited concatenated string</p>
</td></tr>
<tr><td><code id="groupBy_+3A_sql">sql</code></td>
<td>
<p>whether or not to use SQLite to perform the grouping (not yet implimented).</p>
</td></tr>
<tr><td><code id="groupBy_+3A_full.names">full.names</code></td>
<td>
<p>names of the aggregation functions should be appended to the output column names</p>
</td></tr>
<tr><td><code id="groupBy_+3A_...">...</code></td>
<td>
<p>additional parameters (such as na.rm) passed to the underlying aggregate functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an summary/aggregate dataframe
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+aggregate">aggregate</a>, <a href="#topic+bestBy">bestBy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a=runif(12),b=c(runif(11),NA), 
                 z=rep(letters[13:18],2),w=rep(letters[20:23],3))

groupBy(df=df, by='w', clmns=c(rep(c('a','b'),3),'z','w'), 
 aggregation=c('sum','mean','var','sd','min','max','paste','length'), 
 full.names=TRUE, na.rm=TRUE)
# or using SQLite
groupBy(df=df, by='w', clmns=c(rep(c('a','b'),2),'z','w'), 
        aggregation=c('sum','mean','min','max','paste','length'), 
        full.names=TRUE, sql=TRUE)


## passing a custom function
meantop &lt;- function(x,n=2, ...)
  mean(x[order(x, decreasing=TRUE)][1:n], ...)
  
groupBy(df, by='w', aggregation=rep(c('mean','max','meantop'),2), 
                    clmns=rep(c('a','b'),3), na.rm=TRUE)

</code></pre>

<hr>
<h2 id='heatmatrix'>Simple Heatmap Plot</h2><span id='topic+heatmatrix'></span>

<h3>Description</h3>

<p>This is a very simplified heatmap function: basically a convienent wrapper around the 'image' function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmatrix(x, values=TRUE, clp=c('bottom','top'), rlp=c('left','right'), 
                             xadj=.02, yadj=.3, ylab.cntr=FALSE, cex=1, cex.axis=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmatrix_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_values">values</code></td>
<td>
<p>boolean: should the values be plotted over each cell?</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_clp">clp</code></td>
<td>
<p>column label position: either 'bottom' or 'top'.</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_rlp">rlp</code></td>
<td>
<p>row label position: either 'right' or 'left'</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_xadj">xadj</code></td>
<td>
<p>x-adjust of the row labels</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_yadj">yadj</code></td>
<td>
<p>y-adjust of the column labels.</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_ylab.cntr">ylab.cntr</code></td>
<td>
<p>boolean for justification of row labels.</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_cex">cex</code></td>
<td>
<p>character expansion factor for values in cells if values == true</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_cex.axis">cex.axis</code></td>
<td>
<p>character expansion factor for axis tick mark labels</p>
</td></tr>
<tr><td><code id="heatmatrix_+3A_...">...</code></td>
<td>
<p>other paramters passed on to image()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a heatmap plot
</p>


<h3>See Also</h3>

<p><a href="Matrix.html#topic+image">image</a>, <a href="stats.html#topic+heatmap">heatmap</a>, <a href="gplots.html#topic+heatmap.2">heatmap.2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)
x  &lt;- as.matrix(mtcars)

heatmatrix(x)

</code></pre>

<hr>
<h2 id='hyperplot'>Annotate Outliers in a Scatterplot via an HTML Image-Map</h2><span id='topic+hyperplot'></span>

<h3>Description</h3>

<p>This simple function makes R scatter plots interactive by creating an image and wrapping HTML around it: creating a hyperlinked hyperplot.  
Hover over the points to see what each is. 
Click to connect to a table below that will tell you more about each point (if browse ==TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperplot(x, y = NULL, annout = 1:length(x), 
                 name ="hyperplot.imagemap", w = 72 * 8, h = 72 * 6, 
                 link ="internal", browse = TRUE, cex = 1, ...)                 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperplot_+3A_x">x</code></td>
<td>
<p>a plot-able object, a numeric vector or the name of a numeric vector column in annout.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_y">y</code></td>
<td>
<p>a numeric vector or the name of a numeric vector column in annout. Must be the same length as x.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_annout">annout</code></td>
<td>
<p>a named data.frame or table of outliers to annotate the points in the plot. 'x' and 'y' params can indicate column names or numbers of annout.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_name">name</code></td>
<td>
<p>base name of the image &amp; html (map) page that get generated.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_w">w</code></td>
<td>
<p>width of the png image in inches.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_h">h</code></td>
<td>
<p>height of the png image in inches.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_link">link</code></td>
<td>
<p>create a linked lookup table from image to the annout table.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_browse">browse</code></td>
<td>
<p>load the html page automatically via R.</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_cex">cex</code></td>
<td>
<p>character expansion for points</p>
</td></tr>
<tr><td><code id="hyperplot_+3A_...">...</code></td>
<td>
<p>other paramters passed on to plot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HTML page with annotation mapped image</p>


<h3>See Also</h3>

<p><a href="utils.html#topic+browseURL">browseURL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(capabilities()["png"] &amp;&amp; interactive()) {

main.hov &lt;- 'Hover over a point to see the name'
main.subsets &lt;- '(annotated subset in red only)'
main.click.in &lt;- 'click on points to visit table'
main.click.out &lt;-  'click on points to visit external site'
cols &lt;- c('black','red')
ext.url &lt;- 'http://cran.r-project.org'

################################
## x and y as numeric vectors ##
################################
x.out &lt;- nv(rnorm(13,2,sd=5),toupper(letters)[1:13])
x.in &lt;- nv(rnorm(13,1,sd=.5),toupper(letters)[14:26])
y.out &lt;- nv(rnorm(13,2,sd=5),toupper(letters)[1:13])
y.in &lt;- nv(rnorm(13,1,sd=.5),toupper(letters)[14:26])
x &lt;- c(x.out, x.in)
y &lt;- c(y.out, y.in)

## simplest version
hyperplot(x,y, main=main.hov)

## same but with annotations being supplied as a paramter (instead of names on x)
names(x) &lt;- NULL
hyperplot(x,y, annout=toupper(letters), main=main.hov)

## annotate only a subset 
hyperplot(x,y, annout=1:13, col=cols[rep(c(T,F), each=13)+1],
  main=paste(main.hov,main.subsets,sep='\n'))


########################
## annout as dataframe #
########################
## x and y as vectors 
x &lt;- nv(x,toupper(letters)) # reinstate the names of x
df &lt;- data.frame(ab=rep(c('a','b'),13),row.names=toupper(letters))
hyperplot(x,y, annout=df, 
                main=paste(main.hov, main.click.in, sep='\n'))

## x and y as names of columns in df
df &lt;- cbind.data.frame(data.frame(x=x, y=y), df)
hyperplot(x='x',y='y', annout=df, 
                main=paste(main.hov, main.click.in, sep='\n'))

## using 'link' column name parameter to specify external links
df &lt;- cbind.data.frame(df, 
            data.frame(url=ext.url, stringsAsFactors=FALSE))
hyperplot(x='x',y='y', annout=df, link='url', 
                main=paste(main.hov, main.click.out,sep='\n'))

## using reserved column name 'out' as a way to annotate a subset
df &lt;- cbind.data.frame(df, data.frame(out=rep(c(TRUE,FALSE), each=13)))
hyperplot(x='x',y='y', annout=df, col=cols[df$out+1], 
                main=paste(main.hov, main.click.in, main.subsets,sep='\n'))



}

</code></pre>

<hr>
<h2 id='install.prev.pkg'>Install the next oldest package</h2><span id='topic+install.prev.pkg'></span>

<h3>Description</h3>

<p>This funciton will recursively search the package archives backwards in time until it finds a version that installs successfully. This function is useful for installing or troubleshooting package dependency trees where one or more packages &quot;require&quot; the very most recent version of R. Rather than upgrading your base R installation, you can use this function to search back in time until you find a version of the package that works with your existing version of R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install.prev.pkg(pkg.nm, version=NULL, 
  repo.url='https://cran.r-project.org/src/contrib/Archive/')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install.prev.pkg_+3A_pkg.nm">pkg.nm</code></td>
<td>
<p>The package name.</p>
</td></tr>
<tr><td><code id="install.prev.pkg_+3A_version">version</code></td>
<td>
<p>The version number as #.#-# or #.#.# .</p>
</td></tr>
<tr><td><code id="install.prev.pkg_+3A_repo.url">repo.url</code></td>
<td>
<p>The base url for archives of old versions of packages on CRAN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#install.prev.pkg('mnormt')
#install.prev.pkg('mvtnorm')
</code></pre>

<hr>
<h2 id='labsegs'>Buffered Segments for Point Labels</h2><span id='topic+labsegs'></span>

<h3>Description</h3>

<p>This function is a wrapper for segments which trigonometrically shortens the lines that are near the &quot;1&quot; end so as not to cluter or overplot the text label it is attached to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labsegs(x0, y0, x1, y1, buf=.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labsegs_+3A_x0">x0</code></td>
<td>
<p>initial x point coordinate</p>
</td></tr>
<tr><td><code id="labsegs_+3A_y0">y0</code></td>
<td>
<p>initial x point coordinate</p>
</td></tr>
<tr><td><code id="labsegs_+3A_x1">x1</code></td>
<td>
<p>initial x point coordinate</p>
</td></tr>
<tr><td><code id="labsegs_+3A_y1">y1</code></td>
<td>
<p>initial x point coordinate</p>
</td></tr>
<tr><td><code id="labsegs_+3A_buf">buf</code></td>
<td>
<p>the buffer between the label at point &quot;1&quot; and the actual segment</p>
</td></tr>
<tr><td><code id="labsegs_+3A_...">...</code></td>
<td>
<p>other parameters passed to segments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="graphics.html#topic+segments">segments</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(1000,0,.5)
y &lt;- rnorm(1000,-.3,.15)

labdb &lt;- data.frame(x=seq(-.5,.5,by=.5), y=rep(.85,3))
xlims &lt;- c(-1,1)
ylims &lt;- c(-.5,1)

x0.lbd &lt;- x[rev(order(y))][1:3]
y0.lbd &lt;- y[rev(order(y))][1:3]

par(mfrow=c(1,2))
plot(x,y, xlim=xlims, ylim=ylims, main='segments')
segments(x0=x0.lbd, y0=y0.lbd, x1=labdb$x, y1=labdb$y, col=rainbow(3), lwd=3)
text(x=labdb$x, y=labdb$y, labels=letters[1:3], cex=3, col=rainbow(3))

plot(x,y, xlim=xlims, ylim=ylims, main='labsegs')
labsegs(x0=x0.lbd, y0=y0.lbd, x1=labdb$x, y1=labdb$y, col=rainbow(3), lwd=3, buf=.07)
text(x=labdb$x, y=labdb$y, labels=letters[1:3], cex=3, col=rainbow(3))


</code></pre>

<hr>
<h2 id='leghead'>Generate a Color Coded Legend dataframe via head and sum.</h2><span id='topic+leghead'></span>

<h3>Description</h3>

<p>'leghead' is part 'head' and part 'summary'.  It works best on a sorted dataframe where all you are interestesd in only the most (or least) abundant rows.  
An ideal place to use it is in a legend for ~lognormally distributed data.
Additionally, an optional row-wise color coding column is added (the color 'gray' is used for missing row names).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leghead(x, n=7, tabulate=FALSE, colors=TRUE, na.name='NA', 
        na.col = "white", other.col = "gray",  na.last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leghead_+3A_x">x</code></td>
<td>
<p>dataframe or table you wish to summarize</p>
</td></tr>
<tr><td><code id="leghead_+3A_n">n</code></td>
<td>
<p>the number of rows you wish to display as is</p>
</td></tr>
<tr><td><code id="leghead_+3A_colors">colors</code></td>
<td>
<p>list of vectors or a dataframe</p>
</td></tr>
<tr><td><code id="leghead_+3A_tabulate">tabulate</code></td>
<td>
<p>the column name to tabulate on if x is an untabulated dataframe and FALSE otherwise</p>
</td></tr>
<tr><td><code id="leghead_+3A_na.name">na.name</code></td>
<td>
<p>the new rowname for a row with a missing name</p>
</td></tr>
<tr><td><code id="leghead_+3A_na.col">na.col</code></td>
<td>
<p>color for rows labeled as 'NA'</p>
</td></tr>
<tr><td><code id="leghead_+3A_other.col">other.col</code></td>
<td>
<p>color for the rows labeled as 'unknown'</p>
</td></tr>
<tr><td><code id="leghead_+3A_na.last">na.last</code></td>
<td>
<p>boolean specifying if the na category should be listed last in the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A truncated dataframe with a new bottom row summarizing all the truncated ones.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+summary">summary</a>, <a href="utils.html#topic+head">head</a>, <a href="#topic+sstable">sstable</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> e &lt;- data.frame(a=runif(12),b=runif(12), z=rep(letters[13:18],2),w=rep(letters[20:23],3))
tab &lt;- sstable(e, idx.clmns=c('z'), ct.clmns=c('a','b'))
lh &lt;- leghead(tab)
plot(x=lh$a, y=lh$b, cex=lh$sum*3, col=lh$color, pch=20)
legend('topleft',legend=rownames(lh), col=lh$color, pch=20)
</code></pre>

<hr>
<h2 id='m'>Regexp Match Operator</h2><span id='topic+m'></span>

<h3>Description</h3>

<p>A grep/sub-like function that returns one or more back-referenced pattern matches in the form of a vector or as columns in a dataframe (respectively).  
Unlike sub, this function is more geared towards data extraction rather than data cleaning. 
The name is derived from the popular PERL regular expression 'match' operator function 'm' (eg. 'extraction =~ m/sought_text/'). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m(pattern, vect, names="V", types="character", mismatch=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression pattern with at least one back reference.</p>
</td></tr>
<tr><td><code id="m_+3A_vect">vect</code></td>
<td>
<p>A string or vector of strings one which to apply the pattern match.</p>
</td></tr>
<tr><td><code id="m_+3A_names">names</code></td>
<td>
<p>The vector of names of the new variables to be created out of vect. Must be the same length as vect.</p>
</td></tr>
<tr><td><code id="m_+3A_types">types</code></td>
<td>
<p>The vector of types of the new variables to be created out of vect. Must be the same length as vect.</p>
</td></tr>
<tr><td><code id="m_+3A_mismatch">mismatch</code></td>
<td>
<p>What do to when no pattern is found.  NA returns NA, TRUE returns original value (currently only implimented for single match, vector returns)</p>
</td></tr>
<tr><td><code id="m_+3A_...">...</code></td>
<td>
<p>other parameters passed on to grep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector or a dataframe depending on the number of backreferences in the pattern.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sub">sub</a>, <a href="base.html#topic+gsub">gsub</a>, <a href="base.html#topic+regexpr">regexpr</a>, <a href="base.html#topic+grep">grep</a>, <a href="base.html#topic+gregexpr">gregexpr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## single vector output examples
m(pattern="asdf.([A-Z]{4}).", 
  vect=c('asdf.AS.fds','asdf.ABCD.asdf', '12.ASDF.asdf','asdf.REWQ.123'))


Rurls &lt;- c('http://www.r-project.org',    'http://cran.r-project.org',
           'http://journal.r-project.org','http://developer.r-project.org')
m(pattern="http://([a-z]+).r-project.org", vect=Rurls)


# dataframe output examples

data(mtcars)
m(pattern="^([A-Za-z]+) ?(.*)$", 
  vect=rownames(mtcars), names=c('make','model'), types=rep('character',2))


</code></pre>

<hr>
<h2 id='makeElipseCoords'>Make Elipse Coordinates</h2><span id='topic+makeElipseCoords'></span>

<h3>Description</h3>

<p>Create x &amp; y coordinates for an elipse from parameters.
<code>save</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeElipseCoords(x0 = 0, y0 = 0, b = 1, a = 1, alpha = 0, pct.range = c(0,1), len = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeElipseCoords_+3A_x0">x0</code></td>
<td>
<p>x coordinate of center of elipse.</p>
</td></tr>
<tr><td><code id="makeElipseCoords_+3A_y0">y0</code></td>
<td>
<p>y coordinate of center of elipse.</p>
</td></tr>
<tr><td><code id="makeElipseCoords_+3A_b">b</code></td>
<td>
<p>y axis stretch factor.</p>
</td></tr>
<tr><td><code id="makeElipseCoords_+3A_a">a</code></td>
<td>
<p>x axis stretch factor.</p>
</td></tr>
<tr><td><code id="makeElipseCoords_+3A_alpha">alpha</code></td>
<td>
<p>rotation factor.</p>
</td></tr>
<tr><td><code id="makeElipseCoords_+3A_pct.range">pct.range</code></td>
<td>
<p>percentage of the way around the elipse.</p>
</td></tr>
<tr><td><code id="makeElipseCoords_+3A_len">len</code></td>
<td>
<p>number of points used to draw elipse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2 column (x and y) dataframe with coordinates for drawing an elipse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeElipseCoords(x0 = 0, y0 = 0, b = 1, a = 2, alpha = 0)
</code></pre>

<hr>
<h2 id='mvlabs'>Move Text Labels Interactively</h2><span id='topic+mvlabs'></span>

<h3>Description</h3>

<p>There is no easy way to move point labels around interactively on an a plot in R.  This function allows a point and click way to select (using identify) and move (using locator) points by modifying the underlying dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvlabs(df, n=nrow(df), x='x', y='y', l='lab', cols=colors()[grep("dark",colors())], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvlabs_+3A_df">df</code></td>
<td>
<p>A dataframe with x and y coordinates and text labels</p>
</td></tr>
<tr><td><code id="mvlabs_+3A_n">n</code></td>
<td>
<p>the number of points you wish to move</p>
</td></tr>
<tr><td><code id="mvlabs_+3A_x">x</code></td>
<td>
<p>the column name of the x axis coordinates</p>
</td></tr>
<tr><td><code id="mvlabs_+3A_y">y</code></td>
<td>
<p>the column name of the y axis coordinates</p>
</td></tr>
<tr><td><code id="mvlabs_+3A_l">l</code></td>
<td>
<p>the column name of the point labels</p>
</td></tr>
<tr><td><code id="mvlabs_+3A_cols">cols</code></td>
<td>
<p>the color vector to iterate through while assigning new positions.</p>
</td></tr>
<tr><td><code id="mvlabs_+3A_...">...</code></td>
<td>
<p>other paramters passed on to text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a series of violin plots</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+locator">locator</a>,<a href="graphics.html#topic+identify">identify</a>,<a href="#topic+labsegs">labsegs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(20); y &lt;- rnorm(20)
  df &lt;- data.frame(x,y, lab=as.character(letters[1:20]))
  plot(df$x, df$y, pch=''); text(df$x, df$y, df$lab)
  ## df &lt;- mvlabs(df, 'x','y','lab', n=3)  
  plot(df$x, df$y, pch=''); text(df$x, df$y, df$lab)
</code></pre>

<hr>
<h2 id='nerge'>Named Merge</h2><span id='topic+nerge'></span>

<h3>Description</h3>

<p>This function is a wrapper for merge that supports merging multiple vectors and or dataframes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nerge(l, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nerge_+3A_l">l</code></td>
<td>
<p>A named list of named vectors (and/or dataframes)</p>
</td></tr>
<tr><td><code id="nerge_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to each sub-merge</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+merge">merge</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(a=c(6,7,8), b=c(9,8,7))
rownames(df) &lt;- c('a','d','c')

l &lt;- list(x=nv(c(1,2),c('a','b')),y=nv(c(2,3),c('b','d')),z=nv(c(4,1),c('c','d') ), w=df)
nerge(l, all=TRUE)


l2 &lt;- list(a=nv(c(1.23, 1.423, 2.343), c('z','y','x')),b=nv(c(6.34,7.34, 12.545),c('z','w','y')))
nerge(l2, all=TRUE)


</code></pre>

<hr>
<h2 id='nv'>Create a named vector from a dataframe, table or vector</h2><span id='topic+nv'></span>

<h3>Description</h3>

<p>The '$' or &quot;[,&quot; operators for dataframes and tables do not carry along with them the row names.  This function provides a solution for this problem.  Additionally this function will accept a vector of values and a corresponding vector of value names&ndash;an ideal, in-line way for setting named-vectors as default parameters in new functions.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nv(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nv_+3A_x">x</code></td>
<td>
<p>The source dataframe, table, vector, or factor</p>
</td></tr>
<tr><td><code id="nv_+3A_name">name</code></td>
<td>
<p>The column name you would like to pull out as a named vector. OR the names of the vector (if x is a vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector or factor
</p>


<h3>Author(s)</h3>

<p>David Schruth</p>


<h3>See Also</h3>

<p><a href="base.html#topic+vector">vector</a>,<a href="base.html#topic+name">name</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example 1: pulling a row.named vector out of a dataframe
df &lt;- data.frame(a=c(1,2,34,4,5,3,23), b=c('z','x','y','z','x','n','p'))
rownames(df) &lt;- letters[1:nrow(df)]
nv(df,'a')
nv(df,'b')

## example 2: a naming vectors from scratch
nv(c(1,2,3), c('a','b','c'))
nv(df$a, df$b)

</code></pre>

<hr>
<h2 id='pad'>Pad a vector of numerical string with zeros.</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>This function helps to pad numbers on the left side with zeros so that 
they may be used to create strings used in filesystem names (for example). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(vect,np)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_vect">vect</code></td>
<td>
<p>a vector of strings representing numbers.</p>
</td></tr>
<tr><td><code id="pad_+3A_np">np</code></td>
<td>
<p>number of zeros to pad to the left of the string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (vector of) string(s) with np number of zeros padded on as a prefix
</p>


<h3>Author(s)</h3>

<p>Jeremy Tantrum</p>


<h3>Examples</h3>

<pre><code class='language-R'>pad(c(1,10,1000,10000), 4)
</code></pre>

<hr>
<h2 id='parseArgString'>Process Command Line Arguments</h2><span id='topic+parseArgString'></span>

<h3>Description</h3>

<p>generic function for parsing delimited lists from BATCH mode argument strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseArgString(string, delimiter=',', min.param.ct=2, max.param.ct=2, param.range=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseArgString_+3A_string">string</code></td>
<td>
<p>string to parse.</p>
</td></tr>
<tr><td><code id="parseArgString_+3A_delimiter">delimiter</code></td>
<td>
<p>how the string is delmited into a vector.</p>
</td></tr>
<tr><td><code id="parseArgString_+3A_min.param.ct">min.param.ct</code></td>
<td>
<p>minimum number of parameters in the vector.</p>
</td></tr>
<tr><td><code id="parseArgString_+3A_max.param.ct">max.param.ct</code></td>
<td>
<p>maximum number of parameters in the vector.</p>
</td></tr>
<tr><td><code id="parseArgString_+3A_param.range">param.range</code></td>
<td>
<p>the range of the parameter values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or value that has been check for validity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## passes
parseArgString('apple,banana,pear', param.range=c("apple","banana","pear","pineapple"))
parseArgString('1,2,3', param.range=c(1,4))


## fails
## Not run: 
parseArgString('apple,banana,pear', param.range=c("apple","banana"))
parseArgString('1,2,3', param.range=c(1,2))

## End(Not run)

</code></pre>

<hr>
<h2 id='pct'>Add Percentage Columns to a Dataframe</h2><span id='topic+pct'></span>

<h3>Description</h3>

<p>This function will add extra columns to an existing dataframe.  The second argument 'clmn' should specify which column(s) of the dataframe the percentage should be calculated by dividing each column's row-element by it's sum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pct(df, clmns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pct_+3A_df">df</code></td>
<td>
<p>A dataframe with numeric columns.</p>
</td></tr>
<tr><td><code id="pct_+3A_clmns">clmns</code></td>
<td>
<p>the names of the columns for which the percentage column should be calculated from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original dataframe plus extra percentage columns corresponding to original columns in the dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(a=c(1,2,3), b=c('x','y','z'), c=c(5,3,2))
pct(df, c('a','c'))

</code></pre>

<hr>
<h2 id='pies'>Pie chart scatterplot</h2><span id='topic+pies'></span>

<h3>Description</h3>

<p>Plot pie charts in an XY scatterplot. An overhauled wrapper of the original pie plot function.  It is currently very slow: a recommened work around is to plot to something other than the default device (aka png, pdf, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pies(x, show.labels = FALSE, show.slice.labels = FALSE, color.table = NULL, 
		radii = rep(2,length(x)), x0=NULL, y0=NULL, 
		edges = 200,  clockwise = FALSE, 
                init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45, 
                border = NULL, lty = NULL, 
                other.color='gray', na.color='white', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pies_+3A_x">x</code></td>
<td>
<p>a list of named vectors.</p>
</td></tr>
<tr><td><code id="pies_+3A_show.labels">show.labels</code></td>
<td>
<p>boolean specifying if the pie point lables should be plotted.</p>
</td></tr>
<tr><td><code id="pies_+3A_show.slice.labels">show.slice.labels</code></td>
<td>
<p>boolean specifying if the pie slice labels should be plotted.</p>
</td></tr>
<tr><td><code id="pies_+3A_color.table">color.table</code></td>
<td>
<p>a named vector of colors. names should correspond to all possible levels of x</p>
</td></tr>
<tr><td><code id="pies_+3A_radii">radii</code></td>
<td>
<p>a vector of radii used to size the pie points.</p>
</td></tr>
<tr><td><code id="pies_+3A_x0">x0</code>, <code id="pies_+3A_y0">y0</code></td>
<td>
<p>a vector of x and y positions for the pie points.</p>
</td></tr>
<tr><td><code id="pies_+3A_edges">edges</code></td>
<td>
<p>the circular outline of the pie is approximated by a polygon with this many edges.</p>
</td></tr>
<tr><td><code id="pies_+3A_clockwise">clockwise</code></td>
<td>
<p>logical indicating if slices are drawn clockwise or counter clockwise (i.e., mathematically positive direction), the latter is default.</p>
</td></tr>
<tr><td><code id="pies_+3A_init.angle">init.angle</code></td>
<td>
<p>number specifying the starting angle (in degrees) for the slices. Defaults to 0 (i.e., 3 o'clock) unless clockwise is true where init.angle defaults to 90 (degrees), (i.e., 12 o'clock).</p>
</td></tr>
<tr><td><code id="pies_+3A_density">density</code></td>
<td>
<p>the density of shading lines, in lines per inch. The default value of NULL means that no shading lines are drawn. Non-positive values of density also inhibit the drawing of shading lines.</p>
</td></tr>
<tr><td><code id="pies_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in degrees (counter-clockwise).</p>
</td></tr>
<tr><td><code id="pies_+3A_border">border</code></td>
<td>
<p>(possibly vectors) arguments passed to polygon which draws each slice.</p>
</td></tr>
<tr><td><code id="pies_+3A_lty">lty</code></td>
<td>
<p>(possibly vectors) arguments passed to polygon which draws each slice.</p>
</td></tr>
<tr><td><code id="pies_+3A_other.color">other.color</code></td>
<td>
<p>color used for x vector elements for names without corresponding names in the color table</p>
</td></tr>
<tr><td><code id="pies_+3A_na.color">na.color</code></td>
<td>
<p>color used for x vector elements with missing names</p>
</td></tr>
<tr><td><code id="pies_+3A_...">...</code></td>
<td>
<p>other arguments passed to polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pie charts as points on a plot
</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+pie">pie</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## these examples are to the default plot window, which can be slow
## try instead to plot to png or pdf for example

## example 1
  pies(
       list(
            a=nv(c(1,2,3),c('one','two','thre')),
            b=nv(c(2,2,3),c('one','two','thre')),
            c=nv(c(1,2,3),c('one','two','thre'))
            ),
       x0=c(0,.5,1),
       y0=c(0,.5,1), radii=6, border=c('gray', 'black', 'red')
       )


## example 2
n &lt;- 200
n.groups &lt;- 10
n.subgroups &lt;-  6

grps &lt;- paste('gene',seq(1,n.groups), sep='')[round(runif(n,1,n.groups))]
subgrps &lt;- paste('species',seq(1,n.subgroups), sep='')[round(runif(n,1,n.subgroups))]
group.df &lt;- cbind.data.frame(grps,subgrps)
subgroup.list &lt;- by(group.df, group.df$grps, function(x) x$subgrps)

pie.list &lt;- lapply(subgroup.list, table)
col.tab &lt;- nv(rainbow(6), unique(subgrps))

pies(x=pie.list, x0=rnorm(n.groups), y0=rnorm(n.groups), 
     radii=10, show.labels=TRUE, show.slice.labels=TRUE, color.table=col.tab)


## example 3  reading from external flat file
## salt.df &lt;- read.delim('/path/to/my/file.tab')
## create a dummy dataset that might live inside the above file
salt.df &lt;- data.frame(salinity=rnorm(25,5), temperature=rnorm(25,25),spec_a=rpois(25,4), 
							   spec_b=rpois(25,4), 
							   spec_c=rpois(25,4), 
							   spec_d=rpois(25,4),
							   spec_e=rpois(25,4)
							   )
## pull out the colnumn names that are specific to pie wedge numbers	
salt.spec.nms &lt;- names(salt.df)[grep('spec',names(salt.df))]
## turn them into a list
pie.list &lt;- lapply(1:nrow(salt.df), 
 function(i) as.table(nv(as.vector(as.matrix(salt.df[i,salt.spec.nms])),salt.spec.nms)))
names(pie.list)&lt;- letters[1:25]
with(salt.df, pies(x=pie.list, x0=salinity, y0=temperature, radii=2))

</code></pre>

<hr>
<h2 id='plot.sparge'>Visually compare all points from different univariate distributions</h2><span id='topic+plot.sparge'></span><span id='topic+sparge'></span><span id='topic+sparge.plot'></span>

<h3>Description</h3>

<p>Visually compare continuuous univariate distributions using jittered and transparent points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparge'
plot(x, jit.f=1, zl=TRUE, xlim=range(unlist(unlist(x))), 
                  add=FALSE, pd=0, box.brdrs='gray', col=1, alpha=.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparge_+3A_x">x</code></td>
<td>
<p>a list of vectors each with values drawn from the same distribution</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_jit.f">jit.f</code></td>
<td>
<p>factor for random jittering (see 'jitter()'</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_zl">zl</code></td>
<td>
<p>should we add a horizontal [zero] line at x=0?</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_add">add</code></td>
<td>
<p>should we add to the existing plot?</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_pd">pd</code></td>
<td>
<p>'position dodge' moves all y axis plotting positions up or down by this factor</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_xlim">xlim</code></td>
<td>
<p>x axis plot limits</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_alpha">alpha</code></td>
<td>
<p>transparency level for [overlapping] points</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_box.brdrs">box.brdrs</code></td>
<td>
<p>the color of the borders of the box plots surrounding all distributions</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_col">col</code></td>
<td>
<p>(vector of) [base] colors of the points of the distribution(s)</p>
</td></tr>
<tr><td><code id="plot.sparge_+3A_...">...</code></td>
<td>
<p>other parameters passed on to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'sparge' [sprinkle/smear] plot of point distributions
</p>


<h3>See Also</h3>

<p>See also 'boxplot' and 'stripchart' in package 'graphics' as well as 'violin', 'bean', 'ridgelines', and 'raincloud' plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N=300
x=lapply(sample(1:5), function(avg) (rnorm(N,avg)))
plot.sparge(x, col=rep('blue',length(x)), main='sparge plots:\nfor distributional comparison')


</code></pre>

<hr>
<h2 id='plotClock'>Plot a simple clock.</h2><span id='topic+plotClock'></span>

<h3>Description</h3>

<p>Used to create a clock on a plot as a way to keep track of the additional 
parameter of time for use in animated movies of multiple plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClock(hour, minute, x0 = 0, y0 = 0, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClock_+3A_hour">hour</code></td>
<td>
<p>integer specifying the position of the hour hand.</p>
</td></tr>
<tr><td><code id="plotClock_+3A_minute">minute</code></td>
<td>
<p>integer specifying the position of the minute hand.</p>
</td></tr>
<tr><td><code id="plotClock_+3A_x0">x0</code></td>
<td>
<p>number specifying the x position of the clock.</p>
</td></tr>
<tr><td><code id="plotClock_+3A_y0">y0</code></td>
<td>
<p>number specifying the y position of the clock.</p>
</td></tr>
<tr><td><code id="plotClock_+3A_r">r</code></td>
<td>
<p>number specifying the radius of the clock.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of a clock
</p>

<hr>
<h2 id='raAddArms'>Add Arms to a RA plot.</h2><span id='topic+raAddArms'></span>

<h3>Description</h3>

<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raAddArms(epsilon=.55, start=1, end=6, A.shift=0, R.shift=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raAddArms_+3A_epsilon">epsilon</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddArms_+3A_start">start</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddArms_+3A_end">end</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddArms_+3A_a.shift">A.shift</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddArms_+3A_r.shift">R.shift</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddArms_+3A_...">...</code></td>
<td>
<p>other parameters passed to lines.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+raPlot">raPlot</a></code>
</p>

<hr>
<h2 id='raAddAxLabs'>Add axis labels to an RA plot.</h2><span id='topic+raAddAxLabs'></span>

<h3>Description</h3>

<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raAddAxLabs(conditions=nv(c('a','b'),c('ref','obs')), normalize=T, add=TRUE, line=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raAddAxLabs_+3A_conditions">conditions</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddAxLabs_+3A_normalize">normalize</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddAxLabs_+3A_add">add</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddAxLabs_+3A_line">line</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+raPlot">raPlot</a></code>
</p>

<hr>
<h2 id='raAddSigLines'>Add Significance Lines to an RA plot.</h2><span id='topic+raAddSigLines'></span>

<h3>Description</h3>

<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raAddSigLines(n, end=20, alpha=1e-3, nr=0, A.shift=0, plot=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raAddSigLines_+3A_n">n</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddSigLines_+3A_end">end</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddSigLines_+3A_alpha">alpha</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddSigLines_+3A_nr">nr</code></td>
<td>
<p>a numeric value indicating the asymptotic normalization ratio line.</p>
</td></tr>
<tr><td><code id="raAddSigLines_+3A_a.shift">A.shift</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddSigLines_+3A_plot">plot</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="raAddSigLines_+3A_...">...</code></td>
<td>
<p>other parameters passed to lines.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+raPlot">raPlot</a></code>
</p>

<hr>
<h2 id='raPlot'>Generate a Ratio Average [RAy] Plot.</h2><span id='topic+raPlot'></span>

<h3>Description</h3>

<p>A plot which turns two vectors of count data into log scaled fold change ratio and average abundance.  
The plot derives from a Bland-Altman plot and is also very similar to an MA plot.  
The RA plot is unique, however, in it's creative inclusion of the vector-unique 'arms' which are artificially introduced into the plot by adding a &lt;1 epsilon factor before the log function is applied.
The name RAy comes from the fact that the aforementioned 'uniques' arms addition makes it strongly resemble a geometric ray.  
Many of the parameters to the function play off of this convenient anatomical analogy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raPlot(a, b=NULL, uniques=5, normalize=FALSE,  
        nr=0, alpha = 0.01, jitter=FALSE, jit.wgts=NULL,
        rex=1, flat=TRUE, tail=.5, arms=.5, spine=1, border=NULL, plot=TRUE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raPlot_+3A_a">a</code></td>
<td>
<p>a vector of counts for a.  can also be a matrix with two columns 1 for a and 2 for b.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_b">b</code></td>
<td>
<p>a vector of counts for b.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_uniques">uniques</code></td>
<td>
<p>a boolean specifying whether or not to plot the library-unique genes (those with zero counts in one or the other library).</p>
</td></tr>
<tr><td><code id="raPlot_+3A_normalize">normalize</code></td>
<td>
<p>A boolean specifying whether or not to normalize the counts into proportions.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_nr">nr</code></td>
<td>
<p>a numeric value indicating the asymptotic normalization ratio line.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_alpha">alpha</code></td>
<td>
<p>a statisical significance value.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_jitter">jitter</code></td>
<td>
<p>whether or not or how much to jitter the a and b counts into surrounding, non-overlapping space.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_jit.wgts">jit.wgts</code></td>
<td>
<p>a weight vector used to spread the counts of a and b into surrounding, non-overlapping space.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_rex">rex</code></td>
<td>
<p>a numeric value specifying the radial expansion of the plot points.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_flat">flat</code></td>
<td>
<p>a boolean for the radial expansion of points as a function of both R and A axes.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_tail">tail</code></td>
<td>
<p>a numeric or boolean value indicating the line thickness of the two trailing curved significance lines of the RAy.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_arms">arms</code></td>
<td>
<p>a numeric or boolean value indicating the line thickness of the two leading straight separator lines of the RAy.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_spine">spine</code></td>
<td>
<p>a numeric or boolean value indicating the line thickness of the normalization line (whose y position is specified by mm).</p>
</td></tr>
<tr><td><code id="raPlot_+3A_border">border</code></td>
<td>
<p>a vector of strings used to color the borders of the points.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_plot">plot</code></td>
<td>
<p>whether or not to do the actual plot.</p>
</td></tr>
<tr><td><code id="raPlot_+3A_...">...</code></td>
<td>
<p>other parameters passed to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a RAy plot
</p>


<h3>See Also</h3>

<p>limma::plotMA, edgeR::maPlot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rnbinom(n=10000, mu=5, size=2)
b &lt;- rnbinom(n=10000, mu=5, size=2)

## the alternative 
plot(a,b)
## the raPlot version
raPlot(a, b) 

## highlight the condition unique points in the same way as  edgeR's "maPlot"
RA &lt;- raPlot(a, b, pch='')
cond.unique &lt;- apply(cbind(a,b), 1, function(d) any(d==0))
points(RA$A,RA$R, col=c('black','orange')[cond.unique+1])

## try playing with jittering over plotted points
raPlot(a, b, jitter=.3)

</code></pre>

<hr>
<h2 id='read.tab'>Read in a Tab Delimited File.</h2><span id='topic+read.tab'></span>

<h3>Description</h3>

<p>This function is a slight (genome annotation friendly) variant of the built-in read.delim function in R.  
Two non-standard defaults have been set: stringsAsFactors=TRUE, quote=&quot;&quot;. 
An additional parameter &quot;check.row.ct&quot;, triggering a count.fields call, has been added to further ensure the integrity of large data files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.tab(file, check.row.ct = TRUE, stringsAsFactors = FALSE, 
               quote = "", header=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.tab_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.</p>
</td></tr>
<tr><td><code id="read.tab_+3A_check.row.ct">check.row.ct</code></td>
<td>
<p>logical: use 'count.fields' to independently verify the number of rows read.table reads into memory?</p>
</td></tr>
<tr><td><code id="read.tab_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should character vectors be converted to factors?.</p>
</td></tr>
<tr><td><code id="read.tab_+3A_quote">quote</code></td>
<td>
<p>the set of quoting characters.</p>
</td></tr>
<tr><td><code id="read.tab_+3A_header">header</code></td>
<td>
<p>boolean specifying if the first row serves as labels for the columns</p>
</td></tr>
<tr><td><code id="read.tab_+3A_...">...</code></td>
<td>
<p>other paramters passed to read.delim.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe.
</p>

<hr>
<h2 id='regroup'>Regroup a dataframe.</h2><span id='topic+regroup'></span>

<h3>Description</h3>

<p>Used to group a dataframe of numbers by a factor that need not be the same length.  Find the a factor in the old df and use it to group by the new trumping factor (NA's allowed)</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroup(df, old, new, clmns, funcs=rep('sum',length(clmns)), combine=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regroup_+3A_df">df</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
<tr><td><code id="regroup_+3A_old">old</code></td>
<td>
<p>the ids to match the rows in df to the 'new' grouping ids.</p>
</td></tr>
<tr><td><code id="regroup_+3A_new">new</code></td>
<td>
<p>the new ids (must be a vector of the same length as 'old'.</p>
</td></tr>
<tr><td><code id="regroup_+3A_clmns">clmns</code></td>
<td>
<p>the colums to include in the output.</p>
</td></tr>
<tr><td><code id="regroup_+3A_funcs">funcs</code></td>
<td>
<p>the functions to perform on the output (default is to sum) .</p>
</td></tr>
<tr><td><code id="regroup_+3A_combine">combine</code></td>
<td>
<p>Determines wether to combine with existing groupings or to start fresh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with number of rows equal to the number of factor levels in 'new'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(a=rnorm(20),b=rpois(20,1))

mapping &lt;- data.frame(old=rownames(df), new=rep(c('a','b'),10))
regroup(df, old=mapping$old, new=mapping$new)
</code></pre>

<hr>
<h2 id='rerowname'>Rename select rows of a dataframe</h2><span id='topic+rerowname'></span>

<h3>Description</h3>

<p>Used to easily rename the rows of a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rerowname(df, old='NA', new='unknown')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rerowname_+3A_df">df</code></td>
<td>
<p>A dataframe with rownames.</p>
</td></tr>
<tr><td><code id="rerowname_+3A_old">old</code></td>
<td>
<p>The row name to be replaced.</p>
</td></tr>
<tr><td><code id="rerowname_+3A_new">new</code></td>
<td>
<p>The replacment row name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with one new rowname
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(a=c(1,2,3), b=c('x','y','z'), c=c(5,3,2))
rownames(df) &lt;- c('p','q','NA')
rerowname(df)

</code></pre>

<hr>
<h2 id='spie'>Spie charts</h2><span id='topic+spie'></span><span id='topic+plot.spie'></span>

<h3>Description</h3>

<p>Spie Chart</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 spie(p1, p2, init.angle=pi, multi, col = rainbow(length(x$radii)), bg=col, lwd=2, 
              pie.labs=TRUE, grid=TRUE, grid.labs=TRUE, scale=TRUE, p1.circle=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spie_+3A_p1">p1</code></td>
<td>
<p>a positive numeric vector.</p>
</td></tr>
<tr><td><code id="spie_+3A_p2">p2</code></td>
<td>
<p>a positive numeric vector. Angles are the same than those used for the first pie but radii change according to the values in .</p>
</td></tr>
<tr><td><code id="spie_+3A_init.angle">init.angle</code></td>
<td>
<p>initial angle</p>
</td></tr>
<tr><td><code id="spie_+3A_multi">multi</code></td>
<td>
<p>radius scale multiplier</p>
</td></tr>
<tr><td><code id="spie_+3A_col">col</code></td>
<td>
<p>colors of the p2 (foreground) slices</p>
</td></tr>
<tr><td><code id="spie_+3A_bg">bg</code></td>
<td>
<p>colors of the p1 (background) slices</p>
</td></tr> 
<tr><td><code id="spie_+3A_lwd">lwd</code></td>
<td>
<p>line width of the pie wedge boundaries</p>
</td></tr> 
<tr><td><code id="spie_+3A_pie.labs">pie.labs</code></td>
<td>
<p>boolean labels for the pies</p>
</td></tr> 
<tr><td><code id="spie_+3A_grid">grid</code></td>
<td>
<p>boolean</p>
</td></tr> 
<tr><td><code id="spie_+3A_grid.labs">grid.labs</code></td>
<td>
<p>boolean, scale indicators</p>
</td></tr> 
<tr><td><code id="spie_+3A_scale">scale</code></td>
<td>
<p>boolean</p>
</td></tr> 
<tr><td><code id="spie_+3A_p1.circle">p1.circle</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Romain Francois <a href="mailto:francoisromain@free.fr">francoisromain@free.fr</a> &amp; David Schruth <a href="mailto:dschruth@uw.edu">dschruth@uw.edu</a></p>


<h3>References</h3>

<p>D. G. Feitelson (2003), &quot;Comparing Partitions with Spie Charts&quot;.
School of Computer Science and Engineering,
The Hebrew University of Jerusalem.
</p>
<p>Michael Friendly (2022), Spie chart &ndash; a comparison of two pie charts.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pie">pie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  p1  &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)
  p2&lt;- c(0.06, 0.15, 0.52, 0.14, 0.08, 0.05)
  plot(p1, p2, multi=c(.5, 1, 1.5, 2))

</code></pre>

<hr>
<h2 id='sstable'>Sum Sorted Tabulation</h2><span id='topic+sstable'></span>

<h3>Description</h3>

<p>A wrapper for the &quot;table()&quot; function that also calculates the row-wise sum and sorts by the new column.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sstable(x, idx.clmns, ct.clmns = NULL, na.label = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sstable_+3A_x">x</code></td>
<td>
<p>list of vectors or a dataframe</p>
</td></tr>
<tr><td><code id="sstable_+3A_idx.clmns">idx.clmns</code></td>
<td>
<p>index columns</p>
</td></tr>
<tr><td><code id="sstable_+3A_ct.clmns">ct.clmns</code></td>
<td>
<p>count columns</p>
</td></tr>
<tr><td><code id="sstable_+3A_na.label">na.label</code></td>
<td>
<p>row label used for na columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe sorted by the count columns.
</p>


<h3>Author(s)</h3>

<p>David Schruth</p>


<h3>See Also</h3>

<p>ledghead, table, order, sort
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  e &lt;- data.frame(a=runif(12),b=runif(12), z=rep(letters[13:18],2),w=rep(letters[20:23],3))
  e &lt;- data.frame(a=runif(10),b=runif(10), z=rep(letters[12:16],2),w=rep(letters[20:24],2))
  sstable(e, idx.clmns=c('z','w'), ct.clmns='a')
  sstable(e, idx.clmns=c('z'), ct.clmns=c('a','b'))
  sstable(e, idx.clmns=c('z','w'))
  e &lt;- data.frame(a=10,b=0, z=as.factor(NA))
  sstable(e, 'z', c('a','b'))
  e &lt;- data.frame(a=10,b=0, z=NA, w=NA)
  sstable(e, 'z', c('a','b'))
  e &lt;- data.frame(a=runif(10),b=runif(10),m=rep(c('one','two'),5), 
                  z=factor(rep('z',10), levels=c('z','x')))
  sstable(e, idx.clmns=c('m','z'))
  
  
</code></pre>

<hr>
<h2 id='tab2df'>Table to Data Frame</h2><span id='topic+tab2df'></span>

<h3>Description</h3>

<p>Convert a table to a dataframe while perserving the same number of columns and rows and names of each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab2df(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab2df_+3A_x">x</code></td>
<td>
<p>a table or matrix class object (output from the table command).</p>
</td></tr>
<tr><td><code id="tab2df_+3A_...">...</code></td>
<td>
<p>other arguments passed to data.frame(...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe
</p>


<h3>See Also</h3>

<p>table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- data.frame(a=runif(10),b=runif(10), z=rep(letters[1:5],2))
  as.data.frame(x)
  tab2df(x)
  x &lt;- nv(rnorm(10), letters[1:10])
    as.data.frame(x)
  tab2df(x)
  x &lt;- nv(rnorm(2), c('x.b','y.b'))
    as.data.frame(x)
  tab2df(x)
  x &lt;- nv(rnorm(2), c('b.x','b.y'))
    as.data.frame(x)
  tab2df(x)
  e &lt;- data.frame(a=runif(10),b=runif(10), z=rep(letters[13:17],2))
  x &lt;- as.table(sapply(c('a','b'),function(cc) by(e[,'a'],list(e$z), sum)))
    as.data.frame(x)
  tab2df(x)
  x &lt;- as.table(by(1:10, list(a=rep(1:5,2),b=rep(1:2,5)), sum))
    as.data.frame(x)
  tab2df(x)
  x &lt;- as.table(nv(c(54,34), c('a','b')))
    as.data.frame(x)
  tab2df(x)

  x &lt;- table(a='x',b='y')
  tab2df(x)
  
  </code></pre>

<hr>
<h2 id='textplot'>A Text-Only Plot</h2><span id='topic+textplot'></span>

<h3>Description</h3>

<p>Generate a new plot window with just text centered in the middle.  This is ideally used in conjunction with the 'layout' command to label columns and rows of the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textplot(..., x=1, y=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textplot_+3A_...">...</code></td>
<td>
<p>parameters passed to the 'text' function</p>
</td></tr>
<tr><td><code id="textplot_+3A_x">x</code></td>
<td>
<p>the x position of the text.</p>
</td></tr>
<tr><td><code id="textplot_+3A_y">y</code></td>
<td>
<p>the y position of the text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new plot window wiht just text 
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+layout">layout</a>, <a href="graphics.html#topic+text">text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
layout(rbind(c(1,1,1),c(2,3,4), c(5, 6,7)),
       widths=c(5, 10,10) , heights=c(5, 10,10))
textplot('title', cex=2)
textplot('row 1', srt=90, cex=2)
plot(1,2)
hist(c(1,2,34,4,3,2,2))
textplot('row 2', srt=90, cex=2)
pie(c(1,23,3,1,1,2,3,4,54,5))
plot(c(1,2,4,4,23,2), c(1,2,4,3,2,2))

</code></pre>

<hr>
<h2 id='usr2lims'>Grab and adjust the current plot dimensions</h2><span id='topic+usr2lims'></span>

<h3>Description</h3>

<p>This is a simple function which grabs the current plot dimentions and adjusts them by shrinking them by 4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usr2lims(adj=.04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usr2lims_+3A_adj">adj</code></td>
<td>
<p>The automatic adjustment factor 'plot' adds to buffer the specified plot dimentions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2 item (x and y) list of 2 item (min and max) vectors for x and y limits of the current plot area
</p>


<h3>See Also</h3>

<p>par
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(0,1), c(0,1))
usr2lims()
</code></pre>

<hr>
<h2 id='vennMatrix'>Create a Venn Ready Matrix out of a List of Factors</h2><span id='topic+vennMatrix'></span>

<h3>Description</h3>

<p>The limma package has great functions for making venn diagrams from a matrix.  This function is provides upstream functionality to turn a list of factors into this required input format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vennMatrix(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vennMatrix_+3A_l">l</code></td>
<td>
<p>a named list of factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with columns for list elements and rows with globally unique factor levels
</p>


<h3>See Also</h3>

<p>venCounts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
l &lt;- list(a=factor(c('x','y','z')), b=factor(c('w','x','v')))

vennMatrix(l)

</code></pre>

<hr>
<h2 id='wjitter'>Weighted Jitter</h2><span id='topic+wjitter'></span>

<h3>Description</h3>

<p>Use weights to jitter values away fromt their current value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wjitter(x, w, amount=.43)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wjitter_+3A_x">x</code></td>
<td>
<p>a vector of values</p>
</td></tr>
<tr><td><code id="wjitter_+3A_w">w</code></td>
<td>
<p>a vector of weights of the same lenght as x</p>
</td></tr>
<tr><td><code id="wjitter_+3A_amount">amount</code></td>
<td>
<p>the amount to jitter (passed to the parameter by the same name in the jitter function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted jittered vector of the same length as x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1,20)
w &lt;- runif(20, 0,1)
plot(x,wjitter(w,x))
</code></pre>

<hr>
<h2 id='write.delim'>Write a (tab) delimited text file.</h2><span id='topic+write.delim'></span>

<h3>Description</h3>

<p>A simple wrapper for write.table with the same options as read.delim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.delim(df, file, quote = FALSE, row.names = FALSE, sep = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.delim_+3A_df">df</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
<tr><td><code id="write.delim_+3A_file">file</code></td>
<td>
<p>outputfile path.</p>
</td></tr>
<tr><td><code id="write.delim_+3A_quote">quote</code></td>
<td>
<p>should elements of the dataframe be quoted for output.</p>
</td></tr>
<tr><td><code id="write.delim_+3A_row.names">row.names</code></td>
<td>
<p>should the output include rownames.</p>
</td></tr>
<tr><td><code id="write.delim_+3A_sep">sep</code></td>
<td>
<p>the delimiter between fields.</p>
</td></tr>
<tr><td><code id="write.delim_+3A_...">...</code></td>
<td>
<p>other parameters passed to write.table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tab delimited text file
</p>


<h3>See Also</h3>

<p><a href="utils.html#topic+read.delim">read.delim</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- data.frame(a = I("a \" quote"), b = pi)
write.delim(x, file = "foo.tab")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
