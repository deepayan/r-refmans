<!DOCTYPE html><html lang="en"><head><title>Help for package PopED</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PopED}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PopED-package'><p>PopED - <b>Pop</b>ulation (and individual) optimal <b>E</b>xperimental <b>D</b>esign.</p></a></li>
<li><a href='#a_line_search'><p>Optimize using line search</p></a></li>
<li><a href='#bfgsb_min'><p>Nonlinear minimization using BFGS with box constraints</p></a></li>
<li><a href='#blockexp'><p>Summarize your experiment for optimization routines</p></a></li>
<li><a href='#blockfinal'><p>Result function for optimization routines</p></a></li>
<li><a href='#blockheader'><p>Header function for optimization routines</p></a></li>
<li><a href='#blockopt'><p>Summarize your optimization settings for optimization routines</p></a></li>
<li><a href='#build_sfg'><p>Build PopED parameter function from a model function</p></a></li>
<li><a href='#calc_autofocus'><p>Compute the autofocus portion of the stochastic gradient routine</p></a></li>
<li><a href='#calc_ofv_and_fim'><p>Calculate the Fisher Information Matrix (FIM) and the OFV(FIM) for either point values or parameters or distributions.</p></a></li>
<li><a href='#calc_ofv_and_grad'><p>Compute an objective function and gradient</p></a></li>
<li><a href='#cell'><p>Create a cell array (a matrix of lists)</p></a></li>
<li><a href='#convert_variables'><p>Create global variables in the PopED database</p></a></li>
<li><a href='#create_design'><p>Create design variables for a full description of a design.</p></a></li>
<li><a href='#create_design_space'><p>Create design variables and a design space for a full description of an optimization problem.</p></a></li>
<li><a href='#create.poped.database'><p>Create a PopED database</p></a></li>
<li><a href='#design_summary'><p>Display a summary of output from poped_db</p></a></li>
<li><a href='#diag_matlab'><p>Function written to match MATLAB's diag function</p></a></li>
<li><a href='#Doptim'><p>D-family optimization function</p></a></li>
<li><a href='#downsizing_general_design'><p>Downsize a general design to a specific design</p></a></li>
<li><a href='#Dtrace'><p>Trace optimization routines</p></a></li>
<li><a href='#ed_laplace_ofv'><p>Evaluate the expectation of determinant the Fisher Information Matrix (FIM)</p>
using the Laplace approximation.</a></li>
<li><a href='#ed_mftot'><p>Evaluate the expectation of the Fisher Information Matrix (FIM) and the expectation of the OFV(FIM).</p></a></li>
<li><a href='#efficiency'><p>Compute efficiency.</p></a></li>
<li><a href='#evaluate_design'><p>Evaluate a design</p></a></li>
<li><a href='#evaluate_fim_map'><p>Compute the Bayesian Fisher information matrix</p></a></li>
<li><a href='#evaluate_power'><p>Power of a design to estimate a parameter.</p></a></li>
<li><a href='#evaluate.e.ofv.fim'><p>Evaluate the expectation of the Fisher Information Matrix (FIM) and the expectation of the OFV(FIM).</p></a></li>
<li><a href='#evaluate.fim'><p>Evaluate the Fisher Information Matrix (FIM)</p></a></li>
<li><a href='#extract_norm_group_fim'><p>Extract a normalized group FIM</p></a></li>
<li><a href='#feps.add'><p>RUV model:</p>
Additive .</a></li>
<li><a href='#feps.add.prop'><p>RUV model:</p>
Additive and Proportional.</a></li>
<li><a href='#feps.prop'><p>RUV model:</p>
Proportional.</a></li>
<li><a href='#feval'><p>MATLAB feval function</p></a></li>
<li><a href='#ff.PK.1.comp.oral.md.CL'><p>Structural model: one-compartment, oral absorption, multiple bolus dose, parameterized using CL.</p></a></li>
<li><a href='#ff.PK.1.comp.oral.md.KE'><p>Structural model: one-compartment, oral absorption, multiple bolus dose, parameterized using KE.</p></a></li>
<li><a href='#ff.PK.1.comp.oral.sd.CL'><p>Structural model: one-compartment, oral absorption, single bolus dose, parameterized using CL.</p></a></li>
<li><a href='#ff.PK.1.comp.oral.sd.KE'><p>Structural model: one-compartment, oral absorption, single bolus dose, parameterized using KE.</p></a></li>
<li><a href='#ff.PKPD.1.comp.oral.md.CL.imax'><p>Structural model: one-compartment, oral absorption, multiple bolus dose,</p>
parameterized using CL driving an inhibitory IMAX model with a direct effect.</a></li>
<li><a href='#ff.PKPD.1.comp.sd.CL.emax'><p>Structural model: one-compartment, single bolus IV dose, parameterized using CL driving an EMAX model with a direct effect.</p></a></li>
<li><a href='#fileparts'><p>MATLAB fileparts function</p></a></li>
<li><a href='#get_all_params'><p>Extract all model parameters from the PopED database.</p></a></li>
<li><a href='#get_rse'><p>Compute the expected parameter relative standard errors</p></a></li>
<li><a href='#get_unfixed_params'><p>Return all the unfixed parameters</p></a></li>
<li><a href='#getfulld'><p>Create a full D (between subject variability) matrix given a vector of variances and covariances.</p>
Note, this does not test matching vector lengths.</a></li>
<li><a href='#getTruncatedNormal'><p>Generate a random sample from a truncated normal distribution.</p></a></li>
<li><a href='#gradf_eps'><p>Model linearization with respect to epsilon.</p></a></li>
<li><a href='#inv'><p>Compute the inverse of a matrix</p></a></li>
<li><a href='#isempty'><p>Function written to match MATLAB's isempty function</p></a></li>
<li><a href='#LEDoptim'><p>Optimization function for D-family, E-family and Laplace approximated ED designs</p></a></li>
<li><a href='#LinMatrixH'><p>Model linearization with respect to epsilon.</p></a></li>
<li><a href='#LinMatrixL'><p>The linearized matrix L</p></a></li>
<li><a href='#LinMatrixL_occ'><p>Model linearization with respect to occasion variability parameters.</p></a></li>
<li><a href='#LinMatrixLH'><p>Model linearization with respect to epsilon and eta.</p></a></li>
<li><a href='#log_prior_pdf'><p>Compute the natural log of the PDF for the parameters in an E-family design</p></a></li>
<li><a href='#mc_mean'><p>Compute the monte-carlo mean of a function</p></a></li>
<li><a href='#median_hilow_poped'><p>Wrap summary functions from Hmisc and ggplot to work with stat_summary in ggplot</p></a></li>
<li><a href='#mf3'><p>The Fisher Information Matrix (FIM) for one individual</p></a></li>
<li><a href='#mf7'><p>The full Fisher Information Matrix (FIM) for one individual Calculating one model switch at a time, good for large matrices.</p></a></li>
<li><a href='#mfea'><p>Modified Fedorov Exchange Algorithm</p></a></li>
<li><a href='#mftot'><p>Evaluate the Fisher Information Matrix (FIM)</p></a></li>
<li><a href='#model_prediction'><p>Model predictions</p></a></li>
<li><a href='#ofv_criterion'><p>Normalize an objective function by the size of the FIM matrix</p></a></li>
<li><a href='#ofv_fim'><p>Evaluate a criterion of the Fisher Information Matrix (FIM)</p></a></li>
<li><a href='#ones'><p>Create a matrix of ones</p></a></li>
<li><a href='#optim_ARS'><p>Optimize a function using adaptive random search.</p></a></li>
<li><a href='#optim_LS'><p>Optimize a function using a line search algorithm.</p></a></li>
<li><a href='#optimize_groupsize'><p>Title Optimize the proportion of individuals in the design groups</p></a></li>
<li><a href='#optimize_n_eff'><p>Translate efficiency to number of subjects</p></a></li>
<li><a href='#optimize_n_rse'><p>Optimize the number of subjects based on desired uncertainty of a parameter.</p></a></li>
<li><a href='#pargen'><p>Parameter simulation</p></a></li>
<li><a href='#plot_efficiency_of_windows'><p>Plot the efficiency of windows</p></a></li>
<li><a href='#plot_model_prediction'><p>Plot model predictions</p></a></li>
<li><a href='#poped_gui'><p>Run the graphical interface for PopED</p></a></li>
<li><a href='#poped_optim'><p>Optimize a design defined in a PopED database</p></a></li>
<li><a href='#poped_optim_1'><p>Optimization main module for PopED</p>
</p>
<p>Optimize the objective function. The function works for both discrete and</p>
continuous optimization variables. If more than one optimization method is
specified then the methods are run in series.  If <code>loop_methods=TRUE</code>
then the series of optimization methods will be run for <code>iter_max</code>
iterations, or until the efficiency of the design after the current series
(compared to the start of the series) is less than <code>stop_crit_eff</code>.</a></li>
<li><a href='#poped_optim_2'><p>Optimization main module for PopED</p></a></li>
<li><a href='#poped_optim_3'><p>Optimization main module for PopED</p></a></li>
<li><a href='#poped_optimize'><p>Retired optimization module for PopED</p></a></li>
<li><a href='#poped.choose'><p>Choose between <code>arg1</code> and <code>arg2</code></p></a></li>
<li><a href='#rand'><p>Function written to match MATLAB's rand function</p></a></li>
<li><a href='#randn'><p>Function written to match MATLAB's randn function</p></a></li>
<li><a href='#RS_opt'><p>Optimize the objective function using an adaptive random search algorithm for D-family and E-family designs.</p></a></li>
<li><a href='#shrinkage'><p>Predict shrinkage of empirical Bayes estimates (EBEs) in a population model</p></a></li>
<li><a href='#size'><p>Function written to match MATLAB's size function</p></a></li>
<li><a href='#start_parallel'><p>Start parallel computational processes</p></a></li>
<li><a href='#summary.poped_optim'><p>Display a summary of output from poped_optim</p></a></li>
<li><a href='#test_mat_size'><p>Test to make sure that matricies are the right size</p></a></li>
<li><a href='#tic'><p>Timer function (as in MATLAB)</p></a></li>
<li><a href='#toc'><p>Timer function (as in MATLAB)</p></a></li>
<li><a href='#tryCatch.W.E'><p>tryCatch both warnings (with value) and errors</p></a></li>
<li><a href='#zeros'><p>Create a matrix of zeros.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Population (and Individual) Optimal Experimental Design</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, MASS, mvtnorm, dplyr (&ge; 0.7.0), codetools, stats,
utils, magrittr, boot, purrr, stringr, tibble, gtools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, Hmisc, nlme, GA, deSolve, Rcpp, shiny,
rhandsontable, knitr, rmarkdown, gridExtra, covr, devtools,
mrgsolve</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimal experimental designs for both population and individual
    studies based on nonlinear mixed-effect models. Often this is based on a
    computation of the Fisher Information Matrix. This package was developed
    for pharmacometric problems, and examples and predefined models are available
    for these types of systems. The methods are described in Nyberg et al. 
    (2012) &lt;<a href="https://doi.org/10.1016%2Fj.cmpb.2012.05.005">doi:10.1016/j.cmpb.2012.05.005</a>&gt;, and Foracchia et al. (2004) 
    &lt;<a href="https://doi.org/10.1016%2FS0169-2607%2803%2900073-7">doi:10.1016/S0169-2607(03)00073-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://andrewhooker.github.io/PopED/">https://andrewhooker.github.io/PopED/</a>,
<a href="https://github.com/andrewhooker/PopED">https://github.com/andrewhooker/PopED</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/andrewhooker/PopED/issues">https://github.com/andrewhooker/PopED/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>2014-2021 Andrew C. Hooker</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>mrgsolve, kableExtra, PKPDsim, rxode2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-07 18:55:02 UTC; ancho179</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew C. Hooker <a href="https://orcid.org/0000-0002-2676-5912"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, trl, cph],
  Marco Foracchia [aut] (O-Matrix version),
  Eric Stroemberg [ctb] (MATLAB version),
  Martin Fink [ctb] (Streamlining code, added functionality, vignettes),
  Giulia Lestini [ctb] (Streamlining code, added functionality,
    vignettes),
  Sebastian Ueckert <a href="https://orcid.org/0000-0002-3712-0255"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (MATLAB version),
  Joakim Nyberg [aut] (MATLAB version)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew C. Hooker &lt;andrew.hooker@farmaci.uu.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-07 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PopED-package'>PopED - <b>Pop</b>ulation (and individual) optimal <b>E</b>xperimental <b>D</b>esign.</h2><span id='topic+PopED'></span><span id='topic+PopED-package'></span>

<h3>Description</h3>

<p>PopED computes optimal experimental designs for both 
population  and individual studies based on nonlinear mixed-effect models.  
Often this is based on a computation of the Fisher Information Matrix (FIM).
</p>


<h3>Details</h3>

<p>To get started you need to define 
</p>

<ol>
<li><p> A model.
</p>
</li>
<li><p> An initial design (and design space if you want to optimize). 
</p>
</li>
<li><p> The tasks to perform.  
</p>
</li></ol>

<p>There are a number of functions to help you with these tasks.  The user-level functions  defined below are 
meant to be run with a minimum of arguments (for beginners to advanced users).  Many of the other functions in the package
(and not listed here) are called by these user-level functions 
and are often not as user 
friendly (developer level or advanced user functions).
</p>
<p>Define a structural model: 
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a></code>, 
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a></code>, 
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a></code>, 
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a></code>, 
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a></code>, 
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a></code>.
</p>
<p>Define a residual unexplained variability model (residual error model): 
<code><a href="#topic+feps.add.prop">feps.add.prop</a></code>,
<code><a href="#topic+feps.add">feps.add</a></code>, 
<code><a href="#topic+feps.prop">feps.prop</a></code>.
</p>
<p>Create an initial study design (and design space): 
<code><a href="#topic+create.poped.database">create.poped.database</a></code>.
</p>
<p>Evaluate the model and/or design through simulation and graphics:
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a></code>, 
<code><a href="#topic+model_prediction">model_prediction</a></code>, 
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a></code>.
</p>
<p>Evaluate the design using the FIM:
<code><a href="#topic+evaluate_design">evaluate_design</a></code>, 
<code><a href="#topic+evaluate.fim">evaluate.fim</a></code>, 
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a></code>, 
<code><a href="#topic+ofv_fim">ofv_fim</a></code>,
<code><a href="#topic+get_rse">get_rse</a></code>.
</p>
<p>Optimize the design (evaluate afterwards using the above functions): 
<code><a href="#topic+poped_optim">poped_optim</a></code>, 
</p>
<p>See the &quot;Examples&quot; section below for a short introduction to using the above functions. 
There are several other examples, as r-scripts, in the &quot;examples&quot; folder in the 
PopED installation directory located at (run at the R command line):
</p>
<p><code>system.file("examples", package="PopED")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrew C. Hooker <a href="mailto:andrew.hooker@farmaci.uu.se">andrew.hooker@farmaci.uu.se</a> (<a href="https://orcid.org/0000-0002-2676-5912">ORCID</a>) [translator, copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Marco Foracchia (O-Matrix version)
</p>
</li>
<li><p> Sebastian Ueckert (<a href="https://orcid.org/0000-0002-3712-0255">ORCID</a>) (MATLAB version)
</p>
</li>
<li><p> Joakim Nyberg (MATLAB version)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Eric Stroemberg (MATLAB version) [contributor]
</p>
</li>
<li><p> Martin Fink (Streamlining code, added functionality, vignettes) [contributor]
</p>
</li>
<li><p> Giulia Lestini (Streamlining code, added functionality, vignettes) [contributor]
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> J. Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. Hooker, &quot;PopED: An extended, 
parallelized, nonlinear mixed effects models optimal design tool&quot;,  
Computer Methods and Programs in Biomedicine, 108, 2012.
</p>
</li>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. Ruggeri, &quot;PopED, a software for optimal 
experimental design in population kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004. 
</p>
</li>
<li> <p><a href="https://andrewhooker.github.io/PopED/">https://andrewhooker.github.io/PopED/</a>
</p>
</li></ol>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://andrewhooker.github.io/PopED/">https://andrewhooker.github.io/PopED/</a>
</p>
</li>
<li> <p><a href="https://github.com/andrewhooker/PopED">https://github.com/andrewhooker/PopED</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/andrewhooker/PopED/issues">https://github.com/andrewhooker/PopED/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(PopED)

##-- Model: One comp first order absorption
## -- Analytic solution for both mutiple and single dosing
ff &lt;- function(model_switch,xt,parameters,poped.db){
  with(as.list(parameters),{
    y=xt 
    N = floor(xt/TAU)+1
    y=(DOSE*Favail/V)*(KA/(KA - CL/V)) * 
      (exp(-CL/V * (xt - (N - 1) * TAU)) * (1 - exp(-N * CL/V * TAU))/(1 - exp(-CL/V * TAU)) - 
         exp(-KA * (xt - (N - 1) * TAU)) * (1 - exp(-N * KA * TAU))/(1 - exp(-KA * TAU)))  
    return(list( y=y,poped.db=poped.db))
  })
}

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]),
                CL=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU=a[2])
  return( parameters ) 
}

## -- Residual unexplained variablity (RUV) function
## -- Additive + Proportional  
feps &lt;- function(model_switch,xt,parameters,epsi,poped.db){
  returnArgs &lt;- do.call(poped.db$model$ff_pointer,list(model_switch,xt,parameters,poped.db)) 
  y &lt;- returnArgs[[1]]
  poped.db &lt;- returnArgs[[2]]
  
  y = y*(1+epsi[,1])+epsi[,2]
  
  return(list( y= y,poped.db =poped.db )) 
}

## -- Define design and design space
poped.db &lt;- create.poped.database(ff_fun=ff,
                                  fg_fun=sfg,
                                  fError_fun=feps,
                                  bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(V=0.09,KA=0.09,CL=0.25^2), 
                                  sigma=c(0.04,5e-6),
                                  notfixed_sigma=c(0,0),
                                  m=2,
                                  groupsize=20,
                                  xt=c( 1,2,8,240,245),
                                  minxt=c(0,0,0,240,240),
                                  maxxt=c(10,10,10,248,248),
                                  bUseGrouped_xt=1,
                                  a=list(c(DOSE=20,TAU=24),c(DOSE=40, TAU=24)),
                                  maxa=c(DOSE=200,TAU=24),
                                  mina=c(DOSE=0,TAU=24))

##  create plot of model without variability 
plot_model_prediction(poped.db, model_num_points = 300)


## Not run: 
  
  ##  create plot of model with variability 
  plot_model_prediction(poped.db, IPRED=T, DV=T, separate.groups=T, model_num_points = 300)
  

## End(Not run)

## evaluate initial design
evaluate_design(poped.db)

## Not run: 
  
  # Optimization of sample times
  output &lt;- poped_optim(poped.db, opt_xt=TRUE, parallel = TRUE)
  summary(output)
  get_rse(output$FIM, output$poped.db)
  plot_model_prediction(output$poped.db)
  
  # Optimization of sample times and doses
  output_2 &lt;- poped_optim(poped.db, opt_xt=TRUE, opt_a=TRUE, parallel = TRUE)
  summary(output_2)
  get_rse(output_2$FIM,output_2$poped.db)
  plot_model_prediction(output_2$poped.db)
  
  # Optimization of sample times with only integer time points in design space
  # faster than continuous optimization in this case
  poped.db.discrete &lt;- create.poped.database(ff_fun=ff,
                                             fg_fun=sfg,
                                             fError_fun=feps,
                                             bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9), 
                                             notfixed_bpop=c(1,1,1,0),
                                             d=c(V=0.09,KA=0.09,CL=0.25^2), 
                                             sigma=c(0.04,5e-6),
                                             notfixed_sigma=c(0,0),
                                             m=2,
                                             groupsize=20,
                                             xt=c( 1,2,8,240,245),
                                             minxt=c(0,0,0,240,240),
                                             maxxt=c(10,10,10,248,248),
                                             discrete_xt = list(0:248),
                                             bUseGrouped_xt=1,
                                             a=list(c(DOSE=20,TAU=24),c(DOSE=40, TAU=24)),
                                             maxa=c(DOSE=200,TAU=24),
                                             mina=c(DOSE=0,TAU=24),
                                             ourzero = 0)
  
  output_discrete &lt;- poped_optim(poped.db.discrete, opt_xt=T, parallel = TRUE)
  
  
  summary(output_discrete)
  get_rse(output_discrete$FIM,output_discrete$poped.db)
  plot_model_prediction(output_discrete$poped.db)
  
  # Efficiency of sampling windows
  plot_efficiency_of_windows(output_discrete$poped.db,xt_windows=0.5)
  plot_efficiency_of_windows(output_discrete$poped.db,xt_windows=1)
  

## End(Not run)
</code></pre>

<hr>
<h2 id='a_line_search'>Optimize using line search</h2><span id='topic+a_line_search'></span>

<h3>Description</h3>

<p>The function performs a grid search sequentially along 
design variables.  The grid is defined by ls_step_size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_line_search(
  poped.db,
  out_file = "",
  bED = FALSE,
  diff = 0,
  fmf_initial = 0,
  dmf_initial = 0,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  ls_step_size = poped.db$settings$ls_step_size
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a_line_search_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_out_file">out_file</code></td>
<td>
<p>The output file to write to.</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_bed">bED</code></td>
<td>
<p>If the algorithm should use E-family methods. Logical.</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_diff">diff</code></td>
<td>
<p>The OFV difference that is deemed significant for changing a design.  If,
by changing a design variable the difference between the new and old OFV is less than <code>diff</code> 
the change is not made.</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_fmf_initial">fmf_initial</code></td>
<td>
<p>The initial value of the FIM. If <code>0</code> then the FIM is calculated from poped.db.</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_dmf_initial">dmf_initial</code></td>
<td>
<p>The initial value of the objective function value (OFV). 
If <code>0</code> then the OFV is calculated from poped.db.</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="a_line_search_+3A_ls_step_size">ls_step_size</code></td>
<td>
<p>Number of grid points in the line search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>fmf</code></td>
<td>
<p>The FIM.</p>
</td></tr>
<tr><td><code>dmf</code></td>
<td>
<p>The final value of the objective function value.</p>
</td></tr>
<tr><td><code>best_changed</code></td>
<td>
<p>If the algorithm has found a better design than the starting design.</p>
</td></tr>
<tr><td><code>xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code>poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


# very sparse grid to evaluate (4 points for each design valiable)
output &lt;- a_line_search(poped.db, opt_xt=TRUE, opt_a=TRUE, ls_step_size=4)

## Not run:   
  
  # longer run time
  output &lt;- a_line_search(poped.db,opt_xt=TRUE)
  
  # output to a text file
  output &lt;- a_line_search(poped.db,opt_xt=TRUE,out_file="tmp.txt")
  

## End(Not run)

</code></pre>

<hr>
<h2 id='bfgsb_min'>Nonlinear minimization using BFGS with box constraints</h2><span id='topic+bfgsb_min'></span>

<h3>Description</h3>

<p>This is the implementation of a Broyden Fletcher Goldfarb Shanno (BFGS) 
method for nonlinear minimization with box constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfgsb_min(f_name, f_options, x0, l, u, options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bfgsb_min_+3A_f_name">f_name</code></td>
<td>
<p>A function name (as a text string) that returns an objective function and the gradient of that objective function, in that order. 
See <code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a></code> as used in <code><a href="#topic+Doptim">Doptim</a></code>.</p>
</td></tr>
<tr><td><code id="bfgsb_min_+3A_f_options">f_options</code></td>
<td>
<p>Options for the f_name argument.</p>
</td></tr>
<tr><td><code id="bfgsb_min_+3A_x0">x0</code></td>
<td>
<p>the initial values to optimize</p>
</td></tr>
<tr><td><code id="bfgsb_min_+3A_l">l</code></td>
<td>
<p>the lower bounds</p>
</td></tr>
<tr><td><code id="bfgsb_min_+3A_u">u</code></td>
<td>
<p>the upper bounds</p>
</td></tr>
<tr><td><code id="bfgsb_min_+3A_options">options</code></td>
<td>
<p>a list of additional settings arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>x_k</code></td>
<td>
<p>The objective function.</p>
</td></tr>
<tr><td><code>f_k</code></td>
<td>
<p>The gradient.</p>
</td></tr>
<tr><td><code>B_k</code></td>
<td>
<p>The hessian.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


## Not run:   
  
  # BFGS search, DOSE and sample time optimization
  bfgs.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=0,
                                bUseRandomSearch= 0,
                                bUseStochasticGradient = 0,
                                bUseBFGSMinimizer = 1,
                                bUseLineSearch = 0)
  
  f_name &lt;- 'calc_ofv_and_grad' 
  gen_des &lt;- downsizing_general_design(poped.db)
  
  aa &lt;- 0*poped.db$settings$cfaa*matrix(1,poped.db$design$m,size(poped.db$design$a,2))
  axt=1*poped.db$settings$cfaxt*matrix(1,poped.db$design$m,max(poped.db$design_space$maxni))
  
  f_options_1 &lt;- list(gen_des$x,1, 0, gen_des$model_switch,
                    aa=aa,axt=axt,poped.db$design$groupsize,
                    gen_des$ni,
                    gen_des$xt,gen_des$x,gen_des$a,gen_des$bpop[,2,drop=F],
                    getfulld(gen_des$d[,2,drop=F],poped.db$parameters$covd),
                    poped.db$parameters$sigma,
                    getfulld(poped.db$parameters$docc[,2,drop=F],
                             poped.db$parameters$covdocc),poped.db)
  
  options=list('factr'=poped.db$settings$BFGSConvergenceCriteriaMinStep,
               #'factr'=0.01,
               'pgtol'=poped.db$settings$BFGSProjectedGradientTol,
               'ftol'=poped.db$settings$BFGSTolerancef,
               'gtol'=poped.db$settings$BFGSToleranceg,
               'xtol'=poped.db$settings$BFGSTolerancex)
  
  x_k=t(gen_des$xt)
  lb=t(gen_des$minxt)
  ub=t(gen_des$maxxt)
  
  output &lt;- bfgsb_min(f_name,f_options, x_k,lb,ub,options) 
  

## End(Not run)

</code></pre>

<hr>
<h2 id='blockexp'>Summarize your experiment for optimization routines</h2><span id='topic+blockexp'></span>

<h3>Description</h3>

<p>Create some output to the screen and a text file that summarizes the initial design and the design space
you will use to optimize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockexp(
  fn,
  poped.db,
  e_flag = FALSE,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[4],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockexp_+3A_fn">fn</code></td>
<td>
<p>The file handle to write to.</p>
</td></tr>
<tr><td><code id="blockexp_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="blockexp_+3A_e_flag">e_flag</code></td>
<td>
<p>Should output be with uncertainty around parameters?</p>
</td></tr>
<tr><td><code id="blockexp_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="blockexp_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="blockexp_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="blockexp_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="blockexp_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Helper: 
<code><a href="#topic+blockfinal">blockfinal</a>()</code>,
<code><a href="#topic+blockheader">blockheader</a>()</code>,
<code><a href="#topic+blockopt">blockopt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


blockexp("",poped.db, opt_xt=TRUE)

</code></pre>

<hr>
<h2 id='blockfinal'>Result function for optimization routines</h2><span id='topic+blockfinal'></span>

<h3>Description</h3>

<p>Create some output to the screen and a text file that summarizes the problem you solved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockfinal(
  fn,
  fmf,
  dmf,
  groupsize,
  ni,
  xt,
  x,
  a,
  model_switch,
  bpop,
  d,
  docc,
  sigma,
  poped.db,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_inds = poped.db$settings$optsw[5],
  fmf_init = NULL,
  dmf_init = NULL,
  param_cvs_init = NULL,
  compute_inv = TRUE,
  out_file = NULL,
  trflag = TRUE,
  footer_flag = TRUE,
  run_time = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockfinal_+3A_fn">fn</code></td>
<td>
<p>The file handle to write to.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_fmf">fmf</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_fmf_init">fmf_init</code></td>
<td>
<p>Initial FIM.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_dmf_init">dmf_init</code></td>
<td>
<p>Initial OFV.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_param_cvs_init">param_cvs_init</code></td>
<td>
<p>The initial design parameter RSE values in percent.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_compute_inv">compute_inv</code></td>
<td>
<p>should the inverse of the FIM be used to compute expected RSE values?  Often not needed
except for diagnostic purposes.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_out_file">out_file</code></td>
<td>
<p>Which file should the output be directed to?  A string, a file handle using 
<code><a href="base.html#topic+file">file</a></code> or <code>""</code> will output to the screen.</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_footer_flag">footer_flag</code></td>
<td>
<p>Should the footer text be printed out?</p>
</td></tr>
<tr><td><code id="blockfinal_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Helper: 
<code><a href="#topic+blockexp">blockexp</a>()</code>,
<code><a href="#topic+blockheader">blockheader</a>()</code>,
<code><a href="#topic+blockopt">blockopt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


FIM &lt;- evaluate.fim(poped.db) 
dmf &lt;- det(FIM)


blockfinal(fn="",fmf=FIM,
           dmf=dmf,
           groupsize=poped.db$design$groupsize,
           ni=poped.db$design$ni,
           xt=poped.db$design$xt,
           x=poped.db$design$x,a=poped.db$design$a,
           model_switch=poped.db$design$model_switch,
           poped.db$parameters$param.pt.val$bpop,
           poped.db$parameters$param.pt.val$d,
           poped.db$parameters$docc,
           poped.db$parameters$param.pt.val$sigma,
           poped.db,
           opt_xt=TRUE,
           fmf_init=FIM,
           dmf_init=dmf,
           param_cvs_init=get_rse(FIM,poped.db))


</code></pre>

<hr>
<h2 id='blockheader'>Header function for optimization routines</h2><span id='topic+blockheader'></span>

<h3>Description</h3>

<p>Create some output to the screen and a text file that summarizes the problem you are tying to solve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockheader(
  poped.db,
  name = "Default",
  iter = NULL,
  e_flag = !(poped.db$settings$d_switch),
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  fmf = 0,
  dmf = 0,
  bpop = NULL,
  d = NULL,
  docc = NULL,
  sigma = NULL,
  name_header = poped.db$settings$strOutputFileName,
  file_path = poped.db$settings$strOutputFilePath,
  out_file = NULL,
  compute_inv = TRUE,
  trflag = TRUE,
  header_flag = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockheader_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_name">name</code></td>
<td>
<p>The name used for the output file. Combined with <code>name_header</code> and <code>iter</code>. 
If <code>""</code> then output is to the screen.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_iter">iter</code></td>
<td>
<p>The last number in the name printed to the output file, combined with <code>name</code>.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_e_flag">e_flag</code></td>
<td>
<p>Should output be with uncertainty around parameters?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_fmf">fmf</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_name_header">name_header</code></td>
<td>
<p>The initial portion of the file name.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_file_path">file_path</code></td>
<td>
<p>The path to where the file should be created.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_out_file">out_file</code></td>
<td>
<p>Which file should the output be directed to?  A string, a file handle using 
<code><a href="base.html#topic+file">file</a></code> or <code>""</code> will output to the screen.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_compute_inv">compute_inv</code></td>
<td>
<p>should the inverse of the FIM be used to compute expected RSE values?  Often not needed
except for diagnostic purposes.</p>
</td></tr>
<tr><td><code id="blockheader_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_header_flag">header_flag</code></td>
<td>
<p>Should the header text be printed out?</p>
</td></tr>
<tr><td><code id="blockheader_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to further functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fn A file handle (or <code>''</code> if <code>name=''</code>)
</p>


<h3>See Also</h3>

<p>Other Helper: 
<code><a href="#topic+blockexp">blockexp</a>()</code>,
<code><a href="#topic+blockfinal">blockfinal</a>()</code>,
<code><a href="#topic+blockopt">blockopt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


FIM &lt;- evaluate.fim(poped.db) 
dmf &lt;- det(FIM)

blockheader(poped.db,name="")

blockheader(name="",iter=1,poped.db)


blockheader(name='',
              iter=1,
              poped.db,
              e_flag=FALSE,
              opt_xt=TRUE,
              opt_a=TRUE,opt_x=poped.db$settings$optsw[4],
              opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
              fmf=FIM,dmf=dmf,
              bpop=poped.db$parameters$param.pt.val$bpop,
              d=poped.db$parameters$param.pt.val$d,
              docc=poped.db$parameters$docc,sigma=poped.db$parameters$param.pt.val$sigma)



blockheader(name='',
              iter=1,
              poped.db,
              e_flag=TRUE,
              opt_xt=TRUE,
              opt_a=TRUE,opt_x=poped.db$settings$optsw[4],
              opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
              fmf=FIM,dmf=dmf,
              bpop=poped.db$parameters$param.pt.val$bpop,
              d=poped.db$parameters$param.pt.val$d,
              docc=poped.db$parameters$docc,sigma=poped.db$parameters$param.pt.val$sigma)
  
  
poped.db.1 &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  groupsize=32,
                                  xt=rbind(c( 0.5,1,2,6,24,36,72,120),
                                           c( 0.5,1.1,2,6,24,36,72,120)),
                                  minxt=rbind(c(0,1,1.5,3,20,30,70,118),
                                              c(0.1,1.1,1.6,3.1,20.1,30.1,70.1,118.1)),
                                  maxxt=c(12,13,14,15,26,44,78,120),
                                  a=70,
                                  mina=0,
                                  maxa=100)


blockheader(poped.db.1,name="",trflag=2,opt_xt=TRUE)


</code></pre>

<hr>
<h2 id='blockopt'>Summarize your optimization settings for optimization routines</h2><span id='topic+blockopt'></span>

<h3>Description</h3>

<p>Create some output to the screen and a text file that summarizes the optimization settings
you will use to optimize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockopt(fn, poped.db, opt_method = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockopt_+3A_fn">fn</code></td>
<td>
<p>The file handle to write to.</p>
</td></tr>
<tr><td><code id="blockopt_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="blockopt_+3A_opt_method">opt_method</code></td>
<td>
<p>If &quot;RS&quot; (random search), &quot;SG&quot; (stochastic gradient) or &quot;DO&quot; (discrete optimization) then specific output is produced.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Helper: 
<code><a href="#topic+blockexp">blockexp</a>()</code>,
<code><a href="#topic+blockfinal">blockfinal</a>()</code>,
<code><a href="#topic+blockheader">blockheader</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


blockopt(fn="",poped.db,opt_method="SG")
blockopt(fn="",poped.db,opt_method="RS")
blockopt(fn="",poped.db,opt_method="DO")
</code></pre>

<hr>
<h2 id='build_sfg'>Build PopED parameter function from a model function</h2><span id='topic+build_sfg'></span>

<h3>Description</h3>

<p>Build PopED parameter function from a model function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_sfg(
  model = "ff.PK.1.comp.oral.sd.CL",
  covariates = c("dose", "tau"),
  par_names = NULL,
  etas = "exp",
  no_etas = c("F", "Favail"),
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_sfg_+3A_model">model</code></td>
<td>
<p>A string of text describing the model function name</p>
</td></tr>
<tr><td><code id="build_sfg_+3A_covariates">covariates</code></td>
<td>
<p>A list of covariate names to be filtered out of the model</p>
</td></tr>
<tr><td><code id="build_sfg_+3A_par_names">par_names</code></td>
<td>
<p>A list of parameter names in the model file.  If not supplied then 
all undefined variables in the model file are extracted and the covariate names are
filtered out of that list.</p>
</td></tr>
<tr><td><code id="build_sfg_+3A_etas">etas</code></td>
<td>
<p>Can be &quot;exp&quot;, &quot;prop&quot;, &quot;add&quot; or &quot;none&quot;.  Either one value for all parameters or
a list defining the model per parameter.</p>
</td></tr>
<tr><td><code id="build_sfg_+3A_no_etas">no_etas</code></td>
<td>
<p>Parameters that should not have etas associated with them.</p>
</td></tr>
<tr><td><code id="build_sfg_+3A_env">env</code></td>
<td>
<p>The environment to create the function in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parameter model function to be used as input to PopED calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>build_sfg(model="ff.PK.1.comp.oral.md.CL")

etas &lt;- c(Favail="exp",KA="exp",V="add",CL="exp")
build_sfg(model="ff.PK.1.comp.oral.md.CL",etas = etas)
</code></pre>

<hr>
<h2 id='calc_autofocus'>Compute the autofocus portion of the stochastic gradient routine</h2><span id='topic+calc_autofocus'></span>

<h3>Description</h3>

<p>Compute the autofocus portion of the stochastic gradient routine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_autofocus(
  m,
  ni_var,
  dmf,
  varopt,
  varopto,
  maxvar,
  minvar,
  gradvar,
  normgvar,
  avar,
  model_switch,
  groupsize,
  xtopt,
  xopt,
  aopt,
  ni,
  bpop,
  d,
  sigma,
  docc,
  poped.db
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_autofocus_+3A_m">m</code></td>
<td>
<p>Number of groups in the study.  Each individual in a group will have the same design.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_ni_var">ni_var</code></td>
<td>
<p>The ni_var.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_varopt">varopt</code></td>
<td>
<p>The varopt.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_varopto">varopto</code></td>
<td>
<p>The varopto.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_maxvar">maxvar</code></td>
<td>
<p>The maxvar.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_minvar">minvar</code></td>
<td>
<p>The minvar.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_gradvar">gradvar</code></td>
<td>
<p>The gradvar.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_normgvar">normgvar</code></td>
<td>
<p>The normgvar.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_avar">avar</code></td>
<td>
<p>The avar.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_xtopt">xtopt</code></td>
<td>
<p>The optimal sampling times matrix.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_xopt">xopt</code></td>
<td>
<p>The optimal discrete design variables matrix.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_aopt">aopt</code></td>
<td>
<p>The optimal continuous design variables matrix.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="calc_autofocus_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>navar</code></td>
<td>
<p>The autofocus parameter.</p>
</td></tr>
<tr><td><code>poped.db</code></td>
<td>
<p>PopED database.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


## Not run: 
  
# Stochastic gradient search, DOSE and sample time optimization
sg.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1, 
                            bUseRandomSearch= 0,
                            bUseStochasticGradient = 1,
                            bUseBFGSMinimizer = 0,
                            bUseLineSearch = 0,
                            sgit=20)


## End(Not run)
</code></pre>

<hr>
<h2 id='calc_ofv_and_fim'>Calculate the Fisher Information Matrix (FIM) and the OFV(FIM) for either point values or parameters or distributions.</h2><span id='topic+calc_ofv_and_fim'></span>

<h3>Description</h3>

<p>This function computes the expectation of the FIM and OFV(FIM) for either point values of parameter estimates
or parameter distributions given the model, parameters, 
distributions of parameter uncertainty, design and methods defined in the 
PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ofv_and_fim(
  poped.db,
  ofv = 0,
  fim = 0,
  d_switch = poped.db$settings$d_switch,
  bpopdescr = poped.db$parameters$bpop,
  ddescr = poped.db$parameters$d,
  bpop = bpopdescr[, 2, drop = F],
  d = getfulld(ddescr[, 2, drop = F], poped.db$parameters$covd),
  docc_full = getfulld(poped.db$parameters$docc[, 2, drop = F],
    poped.db$parameters$covdocc),
  model_switch = poped.db$design$model_switch,
  ni = poped.db$design$ni,
  xt = poped.db$design$xt,
  x = poped.db$design$x,
  a = poped.db$design$a,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  use_laplace = poped.db$settings$iEDCalculationType,
  laplace.fim = FALSE,
  ofv_fun = poped.db$settings$ofv_fun,
  evaluate_fim = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_ofv_and_fim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_ofv">ofv</code></td>
<td>
<p>The current ofv.  If other than zero then this value is simply returned unchanged.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_fim">fim</code></td>
<td>
<p>The current FIM. If other than zero then this value is simply returned unchanged.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_docc_full">docc_full</code></td>
<td>
<p>A between occasion variability matrix.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_laplace.fim">laplace.fim</code></td>
<td>
<p>Should an E(FIM) be calculated when computing the Laplace approximated E(OFV).  Typically
the FIM does not need to be computed and, if desired,  this calculation
is done using the standard MC integration technique, so can be slow.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_evaluate_fim">evaluate_fim</code></td>
<td>
<p>Should the FIM be calculated?</p>
</td></tr>
<tr><td><code id="calc_ofv_and_fim_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the FIM and OFV(FIM) or the E(FIM) and E(OFV(FIM)) according  to the function arguments.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>
<p>Other E-family: 
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>
</p>
<p>Other evaluate_FIM: 
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error
## to avoid sample times at very low concentrations (time 0 or very late samoples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

# Adding 10% log-normal Uncertainty to fixed effects (not Favail)
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                         bpop_vals,
                         ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
bpop_vals_ed_ln

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=bpop_vals_ed_ln, 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70,
                                  mina=0,
                                  maxa=100)

############# END ###################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################


calc_ofv_and_fim(poped.db)

## Not run: 
  
  calc_ofv_and_fim(poped.db,d_switch=0)
  calc_ofv_and_fim(poped.db,d_switch=0,use_laplace=TRUE)
  calc_ofv_and_fim(poped.db,d_switch=0,use_laplace=TRUE,laplace.fim=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='calc_ofv_and_grad'>Compute an objective function and gradient</h2><span id='topic+calc_ofv_and_grad'></span>

<h3>Description</h3>

<p>Compute an objective function and gradient with respect to the optimization parameters.
This function can be passed to the Broyden Fletcher Goldfarb Shanno (BFGS) 
method for nonlinear minimization with box constraints implemented in <code><a href="#topic+bfgsb_min">bfgsb_min</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ofv_and_grad(
  x,
  optxt,
  opta,
  model_switch,
  aa,
  axt,
  groupsize,
  ni,
  xtopto,
  xopto,
  aopto,
  bpop,
  d,
  sigma,
  docc_full,
  poped.db,
  only_fim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_ofv_and_grad_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_optxt">optxt</code></td>
<td>
<p>If sampling times are optimized</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_opta">opta</code></td>
<td>
<p>If continuous design variables are optimized</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_aa">aa</code></td>
<td>
<p>The aa value</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_axt">axt</code></td>
<td>
<p>the axt value</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_xtopto">xtopto</code></td>
<td>
<p>the xtopto value</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_xopto">xopto</code></td>
<td>
<p>the xopto value</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_aopto">aopto</code></td>
<td>
<p>the aopto value</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_docc_full">docc_full</code></td>
<td>
<p>A between occasion variability matrix.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="calc_ofv_and_grad_+3A_only_fim">only_fim</code></td>
<td>
<p>Should the gradient be calculated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>f</code></td>
<td>
<p>The objective function.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The gradient.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


opta=TRUE
aa=opta*poped.db$settings$cfaa*matrix(1,poped.db$design$m,size(poped.db$design$a,2))
aa

optxt=TRUE
axt=optxt*poped.db$settings$cfaxt*matrix(1,poped.db$design$m,max(poped.db$design_space$maxni))
axt

calc_ofv_and_grad(x=c(poped.db$design$xt,poped.db$design$a),
                  optxt=optxt, opta=opta, 
                  model_switch=poped.db$design$model_switch,
                  aa=aa,
                  axt=axt,
                  groupsize=poped.db$design$groupsize,
                  ni=poped.db$design$ni,
                  xtopto=poped.db$design$xt,
                  xopto=poped.db$design$x,
                  aopto=poped.db$design$a,
                  bpop=poped.db$parameters$param.pt.val$bpop,
                  d=poped.db$parameters$param.pt.val$d,
                  sigma=poped.db$parameters$param.pt.val$sigma,
                  docc_full=poped.db$parameters$param.pt.val$docc,
                  poped.db,
                  only_fim=FALSE)

## Not run: 
  
  # BFGS search, DOSE and sample time optimization
  bfgs.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,
                                bUseRandomSearch= 0,
                                bUseStochasticGradient = 0,
                                bUseBFGSMinimizer = 1,
                                bUseLineSearch = 0)
  

## End(Not run)




</code></pre>

<hr>
<h2 id='cell'>Create a cell array (a matrix of lists)</h2><span id='topic+cell'></span>

<h3>Description</h3>

<p>Create a cell array as in MATLAB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cell_+3A_...">...</code></td>
<td>
<p>Dimensions for the cell array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of empty lists.
</p>


<h3>Note</h3>

<p>This is a modified version of the same function in the matlab R-package.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cell(3)
cell(2,3)

## define possible values of 2 categorical design variable
x.space &lt;- cell(1,2)
x.space[1,1] &lt;- list(seq(10,100,10))
x.space[1,2] &lt;- list(seq(10,300,10))
x.space
x.space[1,1]
x.space[1,2]
</code></pre>

<hr>
<h2 id='convert_variables'>Create global variables in the PopED database</h2><span id='topic+convert_variables'></span>

<h3>Description</h3>

<p>Function takes design variables from input files
and converts them to the global variables needed
in PopED.  Typically not used by the user.  Instead 
use the function <code><a href="#topic+create.poped.database">create.poped.database</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_variables(poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_variables_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PopED database
</p>


<h3>See Also</h3>

<p>Other poped_input: 
<code><a href="#topic+create.poped.database">create.poped.database</a>()</code>,
<code><a href="#topic+create_design">create_design</a>()</code>,
<code><a href="#topic+create_design_space">create_design_space</a>()</code>,
<code><a href="#topic+downsizing_general_design">downsizing_general_design</a>()</code>,
<code><a href="#topic+poped.choose">poped.choose</a>()</code>
</p>

<hr>
<h2 id='create_design'>Create design variables for a full description of a design.</h2><span id='topic+create_design'></span>

<h3>Description</h3>

<p>Create design variables to fully describe a design.
If variables are supplied then these variables are checked for 
consistency and, if possible, changed to sizes that make 
sense if there are inconsistencies.
Returns a list of matricies compatible with PopED.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_design(
  xt,
  groupsize,
  m = NULL,
  x = NULL,
  a = NULL,
  ni = NULL,
  model_switch = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_design_+3A_xt">xt</code></td>
<td>
<p>Matrix defining the  sampling schedule. 
Each row is a group.</p>
</td></tr>
<tr><td><code id="create_design_+3A_groupsize">groupsize</code></td>
<td>
<p>Vector defining the  size of the different groups (number of individuals in each group).</p>
</td></tr>
<tr><td><code id="create_design_+3A_m">m</code></td>
<td>
<p>A number defining the  number of groups. Computed from xt if not defined.</p>
</td></tr>
<tr><td><code id="create_design_+3A_x">x</code></td>
<td>
<p>A matrix defining the  discrete design variables for the model 
Each row is a group.</p>
</td></tr>
<tr><td><code id="create_design_+3A_a">a</code></td>
<td>
<p>Matrix defining the  continuous design variables. Each row is a group.</p>
</td></tr>
<tr><td><code id="create_design_+3A_ni">ni</code></td>
<td>
<p>Vector defining the number of samples for each group, computed as all elements of xt for each group by default.</p>
</td></tr>
<tr><td><code id="create_design_+3A_model_switch">model_switch</code></td>
<td>
<p>Matrix defining which response a certain sampling time belongs to. Defaults to one for all elements of xt.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a value (or a vector/list of values) is supplied that corresponds to only one group and the design has
multiple groups then all groups will have the same value(s). If a matrix is expected then a list of lists can be supplied 
instead, each list corresponding to a group.
</p>


<h3>See Also</h3>

<p>Other poped_input: 
<code><a href="#topic+convert_variables">convert_variables</a>()</code>,
<code><a href="#topic+create.poped.database">create.poped.database</a>()</code>,
<code><a href="#topic+create_design_space">create_design_space</a>()</code>,
<code><a href="#topic+downsizing_general_design">downsizing_general_design</a>()</code>,
<code><a href="#topic+poped.choose">poped.choose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

xt1 &lt;- list(c(1,2,3),c(1,2,3,4))
xt4 &lt;- list(c(1,2,3,4,5),c(1,2,3,4))
xt2 &lt;- rbind(c(1,2,3,4),c(1,2,3,4))
xt3 &lt;- c(1,2,3,4)

design_1 &lt;- create_design(xt=xt1,groupsize=20)
design_2 &lt;- create_design(xt=xt4,groupsize=20)
design_3 &lt;- create_design(xt=xt2,groupsize=20)
design_4 &lt;- create_design(xt=xt3,groupsize=20)

design_5 &lt;- create_design(xt=xt3,groupsize=20,m=3)

design_6 &lt;- create_design(xt=xt1,groupsize=20,model_switch=ones(2,4))

design_7 &lt;-create_design(xt=xt1,groupsize=20,a=c(2,3,4))
design_8 &lt;-create_design(xt=xt1,groupsize=20,a=rbind(c(2,3,4),c(4,5,6)))
design_9 &lt;-create_design(xt=xt1,groupsize=20,a=list(c(2,3,4,6),c(4,5,6)))
design_10 &lt;-create_design(xt=xt1,groupsize=20,a=list(c(2,3,4),c(4,5,6)))

design_11 &lt;-create_design(xt=c(0,1,2,4,6,8,24),
                         groupsize=50,
                         a=c(WT=70,DOSE=1000))

design_12 &lt;-create_design(xt=c(0,1,2,4,6,8,24),
                         groupsize=50,
                         a=c(WT=70,DOSE=1000),m=2)

design_13 &lt;-create_design(xt=c(0,1,2,4,6,8,24),
                         groupsize=50,
                         a=list(c(WT=70,DOSE=1000),c(DOSE=90,WT=200,AGE=45)),m=2)

design_14 &lt;-create_design(xt=c(0,1,2,4,6,8,24),
                         groupsize=50,
                         a=list(list(WT=70,DOSE=1000),list(DOSE=90,WT=200,AGE=45)),m=2)

design_15 &lt;-create_design(xt=xt4,
                          groupsize=c(50,20),
                          a=rbind(c("DOSE"=2,"WT"=3,"AGE"=4),
                                  c(4,5,6)))

</code></pre>

<hr>
<h2 id='create_design_space'>Create design variables and a design space for a full description of an optimization problem.</h2><span id='topic+create_design_space'></span>

<h3>Description</h3>

<p><code>create_design_space</code> takes an initial design and arguments for a design space and 
creates a design and design space for design optimization.
Checks the sizes of supplied design space variables and 
changes them to sizes that  make sense if there are inconsistencies.  
Function arguments can use shorthand notation (single values, vectors, lists of vectors and 
list of list) or matricies.
Returns a list of matricies compatible with PopED.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_design_space(
  design,
  maxni = NULL,
  minni = NULL,
  maxtotni = NULL,
  mintotni = NULL,
  maxgroupsize = NULL,
  mingroupsize = NULL,
  maxtotgroupsize = NULL,
  mintotgroupsize = NULL,
  maxxt = NULL,
  minxt = NULL,
  xt_space = NULL,
  maxa = NULL,
  mina = NULL,
  a_space = NULL,
  x_space = NULL,
  use_grouped_xt = FALSE,
  grouped_xt = NULL,
  use_grouped_a = FALSE,
  grouped_a = NULL,
  use_grouped_x = FALSE,
  grouped_x = NULL,
  our_zero = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_design_space_+3A_design">design</code></td>
<td>
<p>The output from a call to <code><a href="#topic+create_design">create_design</a></code>.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_maxni">maxni</code></td>
<td>
<p>Vector defining the maximum number of samples per group.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_minni">minni</code></td>
<td>
<p>Vector defining the minimum number of samples per group.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_maxtotni">maxtotni</code></td>
<td>
<p>Number defining the maximum number of samples allowed in the experiment.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_mintotni">mintotni</code></td>
<td>
<p>Number defining the minimum number of samples allowed in the experiment.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_maxgroupsize">maxgroupsize</code></td>
<td>
<p>Vector defining the maximum size of the different groups (maximum number of individuals in each group)</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_mingroupsize">mingroupsize</code></td>
<td>
<p>Vector defining the minimum size of the different groups (minimum num individuals in each group)</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_maxtotgroupsize">maxtotgroupsize</code></td>
<td>
<p>The total maximal groupsize over all groups</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_mintotgroupsize">mintotgroupsize</code></td>
<td>
<p>The total minimal groupsize over all groups</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_xt_space">xt_space</code></td>
<td>
<p>Cell array <code><a href="#topic+cell">cell</a></code> defining the discrete variables allowed for each xt value.
Can also be a vector of values <code>c(1:10)</code> (same values allowed for all xt), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in xt in row major order or just for one row in xt, 
and all other rows will be duplicated).</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the maximum value for each covariate. IF a single value is supplied then
all a values are given the same maximum value</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_mina">mina</code></td>
<td>
<p>Vector defining the minimum value for each covariate. IF a single value is supplied then
all a values are given the same minimum value</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_a_space">a_space</code></td>
<td>
<p>Cell array <code><a href="#topic+cell">cell</a></code> defining the discrete variables allowed for each a value.
Can also be a list of values <code>list(1:10)</code> (same values allowed for all a), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in a).</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_x_space">x_space</code></td>
<td>
<p>Cell array <code><a href="#topic+cell">cell</a></code> defining the discrete variables for each x value.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_use_grouped_xt">use_grouped_xt</code></td>
<td>
<p>Group sampling times between groups so that each group has the same values (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_grouped_xt">grouped_xt</code></td>
<td>
<p>Matrix defining the grouping of sample points. Matching integers mean that the points are matched.
Allows for finer control than <code>use_grouped_xt</code></p>
</td></tr>
<tr><td><code id="create_design_space_+3A_use_grouped_a">use_grouped_a</code></td>
<td>
<p>Group continuous design variables between groups so that each group has the same values (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_grouped_a">grouped_a</code></td>
<td>
<p>Matrix defining the grouping of continuous design variables. Matching integers mean that the values are matched.
Allows for finer control than <code>use_grouped_a</code>.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_use_grouped_x">use_grouped_x</code></td>
<td>
<p>Group discrete design variables between groups so that each group has the same values (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_grouped_x">grouped_x</code></td>
<td>
<p>Matrix defining the grouping of discrete design variables. Matching integers mean that the values are matched.
Allows for finer control than <code>use_grouped_x</code>.</p>
</td></tr>
<tr><td><code id="create_design_space_+3A_our_zero">our_zero</code></td>
<td>
<p>Value to interpret as zero in design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a value (or a vector or a list of values) is supplied that corresponds to only one group and the design has
multiple groups then all groups will have the same value(s). If a matrix is expected then a list of lists can be supplied 
instead, each list corresponding to a group.
</p>


<h3>See Also</h3>

<p>Other poped_input: 
<code><a href="#topic+convert_variables">convert_variables</a>()</code>,
<code><a href="#topic+create.poped.database">create.poped.database</a>()</code>,
<code><a href="#topic+create_design">create_design</a>()</code>,
<code><a href="#topic+downsizing_general_design">downsizing_general_design</a>()</code>,
<code><a href="#topic+poped.choose">poped.choose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

design_1 &lt;- create_design(xt=list(c(1,2,3,4,5),
                                  c(1,2,3,4)),
                          groupsize=c(50,20),
                          a=list(c(WT=70,DOSE=1000),
                                 c(DOSE=1000,WT=35)))

ds_1 &lt;- create_design_space(design_1)

ds_1_a &lt;- create_design_space(design_1,our_zero = 1e-5)

ds_2 &lt;- create_design_space(design_1,maxni=10,maxxt=10,minxt=0)

ds_3 &lt;- create_design_space(design_1,maxni=10,mingroupsize=20,maxxt=10,minxt=0)

ds_4 &lt;- create_design_space(design_1,maxa=c(100,2000))

ds_5 &lt;- create_design_space(design_1,mina=c(10,20))

design_2 &lt;- create_design(xt=list(c(1,2,3,4,5),
                                  c(1,2,3,4)),
                          groupsize=c(50,20),
                          a=list(c(WT=70,DOSE=1000),
                                 c(WT=35,DOSE=1000)),
                          x=list(c(SEX=1,DOSE_discrete=100),
                                 c(SEX=2,DOSE_discrete=200)))

ds_6 &lt;- create_design_space(design_2) 

ds_7 &lt;- create_design_space(design_2,
                            x_space=list(SEX=c(1,2),
                                         DOSE_discrete=seq(100,400,by=20)))

ds_8 &lt;- create_design_space(design_2,
                            x_space=list(SEX=c(1,2),
                                         DOSE_discrete=seq(100,400,by=20)),
                            grouped_xt=c(1,2,3,4,5))

ds_9 &lt;- create_design_space(design_2,
                            x_space=list(SEX=c(1,2),
                                         DOSE_discrete=seq(100,400,by=20)),
                            use_grouped_xt=TRUE)

design_3 &lt;- create_design(xt=list(c(1,2,3,4,5),
                                  c(1,2,3,4)),
                          groupsize=c(50,20),
                          a=list(c(WT=35,DOSE=1000)),
                          x=list(c(SEX=1,DOSE_discrete=100)))

ds_10 &lt;- create_design_space(design_3,
                             x_space=list(SEX=c(1,2),DOSE_discrete=seq(100,400,by=20)),
                             use_grouped_a=TRUE)

ds_11 &lt;- create_design_space(design_2,
                             x_space=list(SEX=c(1,2),DOSE_discrete=seq(100,400,by=20)),
                             grouped_a=list(c(1,2),c(3,2)))

ds_12 &lt;- create_design_space(design_3,
                             x_space=list(SEX=c(1,2),DOSE_discrete=seq(100,400,by=20)),
                             use_grouped_x=TRUE)

ds_13 &lt;- create_design_space(design_3,
                             x_space=list(SEX=c(1,2),DOSE_discrete=seq(100,400,by=20)),
                             grouped_x=list(c(1,2),c(3,2)))

seq_1 &lt;- 1:10
ds_14 &lt;- create_design_space(design_1,maxxt=10,minxt=0,
                             xt_space = list(seq_1,seq_1,seq_1,seq_1,seq_1))
ds_15 &lt;- create_design_space(design_1,maxxt=10,minxt=0,xt_space = list(seq_1))

possible_values &lt;- as.matrix(cbind(list(0:10),list(0:10),list(0:10),list(0:20),list(0:20)))
xt_space &lt;- as.matrix(rbind(possible_values,possible_values))

ds_16 &lt;- create_design_space(design_1,maxxt=10,minxt=0,xt_space = xt_space)

ds_17 &lt;- create_design_space(design_1,a_space = list(1:100,seq(1000,100000,by=1000)))

</code></pre>

<hr>
<h2 id='create.poped.database'>Create a PopED database</h2><span id='topic+create.poped.database'></span>

<h3>Description</h3>

<p>This function takes the input file (a previously created poped database) supplied by the user, or function arguments, 
and creates a database that can then be used to 
run all other PopED functions.  The function supplies default values to elements of the 
database that are not specified in the
input file or as function arguments. Default arguments are supplied in the Usage section 
(easiest to use a text search to find values you are interested in).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.poped.database(
  popedInput = list(),
  ff_file = NULL,
  ff_fun = poped.choose(popedInput$model$ff_pointer, NULL),
  fg_file = NULL,
  fg_fun = poped.choose(popedInput$model$fg_pointer, NULL),
  fError_file = NULL,
  fError_fun = poped.choose(popedInput$model$ferror_pointer, NULL),
  optsw = poped.choose(popedInput$settings$optsw, cbind(0, 0, 0, 0, 0)),
  xt = poped.choose(popedInput$design[["xt"]], stop("'xt' needs to be defined")),
  m = poped.choose(popedInput$design[["m"]], NULL),
  x = poped.choose(popedInput$design[["x"]], NULL),
  nx = poped.choose(popedInput$design$nx, NULL),
  a = poped.choose(popedInput$design[["a"]], NULL),
  groupsize = poped.choose(popedInput$design$groupsize,
    stop("'groupsize' needs to be defined")),
  ni = poped.choose(popedInput$design$ni, NULL),
  model_switch = poped.choose(popedInput$design$model_switch, NULL),
  maxni = poped.choose(popedInput$design_space$maxni, NULL),
  minni = poped.choose(popedInput$design_space$minni, NULL),
  maxtotni = poped.choose(popedInput$design_space$maxtotni, NULL),
  mintotni = poped.choose(popedInput$design_space$mintotni, NULL),
  maxgroupsize = poped.choose(popedInput$design_space$maxgroupsize, NULL),
  mingroupsize = poped.choose(popedInput$design_space$mingroupsize, NULL),
  maxtotgroupsize = poped.choose(popedInput$design_space$maxtotgroupsize, NULL),
  mintotgroupsize = poped.choose(popedInput$design_space$mintotgroupsize, NULL),
  maxxt = poped.choose(popedInput$design_space$maxxt, NULL),
  minxt = poped.choose(popedInput$design_space$minxt, NULL),
  discrete_xt = poped.choose(popedInput$design_space$xt_space, NULL),
  discrete_x = poped.choose(popedInput$design_space$discrete_x, NULL),
  maxa = poped.choose(popedInput$design_space$maxa, NULL),
  mina = poped.choose(popedInput$design_space$mina, NULL),
  discrete_a = poped.choose(popedInput$design_space$a_space, NULL),
  bUseGrouped_xt = poped.choose(popedInput$design_space$bUseGrouped_xt, FALSE),
  G_xt = poped.choose(popedInput$design_space$G_xt, NULL),
  bUseGrouped_a = poped.choose(popedInput$design_space$bUseGrouped_a, FALSE),
  G_a = poped.choose(popedInput$design_space$G_a, NULL),
  bUseGrouped_x = poped.choose(popedInput$design_space$bUseGrouped_x, FALSE),
  G_x = poped.choose(popedInput$design_space[["G_x"]], NULL),
  iFIMCalculationType = poped.choose(popedInput$settings$iFIMCalculationType, 1),
  iApproximationMethod = poped.choose(popedInput$settings$iApproximationMethod, 0),
  iFOCENumInd = poped.choose(popedInput$settings$iFOCENumInd, 1000),
  prior_fim = poped.choose(popedInput$settings$prior_fim, matrix(0, 0, 1)),
  strAutoCorrelationFile = poped.choose(popedInput$model$auto_pointer, ""),
  d_switch = poped.choose(popedInput$settings$d_switch, 1),
  ofv_calc_type = poped.choose(popedInput$settings$ofv_calc_type, 4),
  ds_index = popedInput$parameters$ds_index,
  strEDPenaltyFile = poped.choose(popedInput$settings$strEDPenaltyFile, ""),
  ofv_fun = poped.choose(popedInput$settings$ofv_fun, NULL),
  iEDCalculationType = poped.choose(popedInput$settings$iEDCalculationType, 0),
  ED_samp_size = poped.choose(popedInput$settings$ED_samp_size, 45),
  bLHS = poped.choose(popedInput$settings$bLHS, 1),
  strUserDistributionFile = poped.choose(popedInput$model$user_distribution_pointer, ""),
  nbpop = popedInput$parameters$nbpop,
  NumRanEff = popedInput$parameters$NumRanEff,
  NumDocc = popedInput$parameters$NumDocc,
  NumOcc = popedInput$parameters$NumOcc,
  bpop = poped.choose(popedInput$parameters$bpop, stop("bpop must be defined")),
  d = poped.choose(popedInput$parameters$d, NULL),
  covd = popedInput$parameters$covd,
  sigma = popedInput$parameters$sigma,
  docc = poped.choose(popedInput$parameters$docc, matrix(0, 0, 3)),
  covdocc = poped.choose(popedInput$parameters$covdocc, zeros(1, length(docc[, 2, drop =
    F]) * (length(docc[, 2, drop = F]) - 1)/2)),
  notfixed_bpop = popedInput$parameters$notfixed_bpop,
  notfixed_d = popedInput$parameters$notfixed_d,
  notfixed_covd = popedInput$parameters$notfixed_covd,
  notfixed_docc = popedInput$parameters$notfixed_docc,
  notfixed_covdocc = poped.choose(popedInput$parameters$notfixed_covdocc, zeros(1,
    length(covdocc))),
  notfixed_sigma = poped.choose(popedInput$parameters$notfixed_sigma, t(rep(1,
    size(sigma, 2)))),
  notfixed_covsigma = poped.choose(popedInput$parameters$notfixed_covsigma, zeros(1,
    length(notfixed_sigma) * (length(notfixed_sigma) - 1)/2)),
  reorder_parameter_vectors = FALSE,
  bUseRandomSearch = poped.choose(popedInput$settings$bUseRandomSearch, TRUE),
  bUseStochasticGradient = poped.choose(popedInput$settings$bUseStochasticGradient, TRUE),
  bUseLineSearch = poped.choose(popedInput$settings$bUseLineSearch, TRUE),
  bUseExchangeAlgorithm = poped.choose(popedInput$settings$bUseExchangeAlgorithm, FALSE),
  bUseBFGSMinimizer = poped.choose(popedInput$settings$bUseBFGSMinimizer, FALSE),
  EACriteria = poped.choose(popedInput$settings$EACriteria, 1),
  strRunFile = poped.choose(popedInput$settings$run_file_pointer, ""),
  poped_version = poped.choose(popedInput$settings$poped_version,
    packageVersion("PopED")),
  modtit = poped.choose(popedInput$settings$modtit, "PopED model"),
  output_file = poped.choose(popedInput$settings$output_file, paste("PopED_output",
    "_summary", sep = "")),
  output_function_file = poped.choose(popedInput$settings$output_function_file,
    paste("PopED", "_output_", sep = "")),
  strIterationFileName = poped.choose(popedInput$settings$strIterationFileName,
    paste("PopED", "_current.R", sep = "")),
  user_data = poped.choose(popedInput$settings$user_data, cell(0, 0)),
  ourzero = poped.choose(popedInput$settings$ourzero, 1e-05),
  dSeed = poped.choose(popedInput$settings$dSeed, NULL),
  line_opta = poped.choose(popedInput$settings$line_opta, NULL),
  line_optx = poped.choose(popedInput$settings$line_optx, NULL),
  bShowGraphs = poped.choose(popedInput$settings$bShowGraphs, FALSE),
  use_logfile = poped.choose(popedInput$settings$use_logfile, FALSE),
  m1_switch = poped.choose(popedInput$settings$m1_switch, 1),
  m2_switch = poped.choose(popedInput$settings$m2_switch, 1),
  hle_switch = poped.choose(popedInput$settings$hle_switch, 1),
  gradff_switch = poped.choose(popedInput$settings$gradff_switch, 1),
  gradfg_switch = poped.choose(popedInput$settings$gradfg_switch, 1),
  grad_all_switch = poped.choose(popedInput$settings$grad_all_switch, 1),
  rsit_output = poped.choose(popedInput$settings$rsit_output, 5),
  sgit_output = poped.choose(popedInput$settings$sgit_output, 1),
  hm1 = poped.choose(popedInput$settings[["hm1"]], 1e-05),
  hlf = poped.choose(popedInput$settings[["hlf"]], 1e-05),
  hlg = poped.choose(popedInput$settings[["hlg"]], 1e-05),
  hm2 = poped.choose(popedInput$settings[["hm2"]], 1e-05),
  hgd = poped.choose(popedInput$settings[["hgd"]], 1e-05),
  hle = poped.choose(popedInput$settings[["hle"]], 1e-05),
  AbsTol = poped.choose(popedInput$settings$AbsTol, 1e-06),
  RelTol = poped.choose(popedInput$settings$RelTol, 1e-06),
  iDiffSolverMethod = poped.choose(popedInput$settings$iDiffSolverMethod, NULL),
  bUseMemorySolver = poped.choose(popedInput$settings$bUseMemorySolver, FALSE),
  rsit = poped.choose(popedInput$settings[["rsit"]], 300),
  sgit = poped.choose(popedInput$settings[["sgit"]], 150),
  intrsit = poped.choose(popedInput$settings$intrsit, 250),
  intsgit = poped.choose(popedInput$settings$intsgit, 50),
  maxrsnullit = poped.choose(popedInput$settings$maxrsnullit, 50),
  convergence_eps = poped.choose(popedInput$settings$convergence_eps, 1e-08),
  rslxt = poped.choose(popedInput$settings$rslxt, 10),
  rsla = poped.choose(popedInput$settings$rsla, 10),
  cfaxt = poped.choose(popedInput$settings$cfaxt, 0.001),
  cfaa = poped.choose(popedInput$settings$cfaa, 0.001),
  bGreedyGroupOpt = poped.choose(popedInput$settings$bGreedyGroupOpt, FALSE),
  EAStepSize = poped.choose(popedInput$settings$EAStepSize, 0.01),
  EANumPoints = poped.choose(popedInput$settings$EANumPoints, FALSE),
  EAConvergenceCriteria = poped.choose(popedInput$settings$EAConvergenceCriteria, 1e-20),
  bEANoReplicates = poped.choose(popedInput$settings$bEANoReplicates, FALSE),
  BFGSConvergenceCriteriaMinStep = NULL,
  BFGSProjectedGradientTol = poped.choose(popedInput$settings$BFGSProjectedGradientTol,
    1e-04),
  BFGSTolerancef = poped.choose(popedInput$settings$BFGSTolerancef, 0.001),
  BFGSToleranceg = poped.choose(popedInput$settings$BFGSToleranceg, 0.9),
  BFGSTolerancex = poped.choose(popedInput$settings$BFGSTolerancex, 0.1),
  ED_diff_it = poped.choose(popedInput$settings$ED_diff_it, 30),
  ED_diff_percent = poped.choose(popedInput$settings$ED_diff_percent, 10),
  line_search_it = poped.choose(popedInput$settings$ls_step_size, 50),
  Doptim_iter = poped.choose(popedInput$settings$iNumSearchIterationsIfNotLineSearch, 1),
  iCompileOption = poped.choose(popedInput$settings$parallel$iCompileOption, -1),
  iUseParallelMethod = poped.choose(popedInput$settings$parallel$iUseParallelMethod, 1),
  MCC_Dep = NULL,
  strExecuteName = poped.choose(popedInput$settings$parallel$strExecuteName,
    "calc_fim.exe"),
  iNumProcesses = poped.choose(popedInput$settings$parallel$iNumProcesses, 2),
  iNumChunkDesignEvals = poped.choose(popedInput$settings$parallel$iNumChunkDesignEvals,
    -2),
  Mat_Out_Pre = poped.choose(popedInput$settings$parallel$strMatFileOutputPrefix,
    "parallel_output"),
  strExtraRunOptions = poped.choose(popedInput$settings$parallel$strExtraRunOptions, ""),
  dPollResultTime = poped.choose(popedInput$settings$parallel$dPollResultTime, 0.1),
  strFunctionInputName = poped.choose(popedInput$settings$parallel$strFunctionInputName,
    "function_input"),
  bParallelRS = poped.choose(popedInput$settings$parallel$bParallelRS, FALSE),
  bParallelSG = poped.choose(popedInput$settings$parallel$bParallelSG, FALSE),
  bParallelMFEA = poped.choose(popedInput$settings$parallel$bParallelMFEA, FALSE),
  bParallelLS = poped.choose(popedInput$settings$parallel$bParallelLS, FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.poped.database_+3A_popedinput">popedInput</code></td>
<td>
<p>A PopED database file or an empty list <code>list()</code>.  List elements should match the values seen in 
the Usage section (the defaults to function arguments).</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ff_file">ff_file</code></td>
<td>

<ul>
<li> <p><b>******START OF MODEL DEFINITION OPTIONS**********</b>
</p>
</li></ul>

<p>A string giving the function name or filename and path of the structural model. 
The filename and the function name must be the same if giving a filename. 
e.g. <code>"ff.PK.1.comp.oral.md.KE"</code></p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ff_fun">ff_fun</code></td>
<td>
<p>Function describing the structural model. e.g. <code>ff.PK.1.comp.oral.md.KE</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_fg_file">fg_file</code></td>
<td>
<p>A string giving the function name or filename and path of the 
parameter model. 
The filename and the function name must be the same if giving a filename. 
e.g. <code>"parameter.model"</code></p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_fg_fun">fg_fun</code></td>
<td>
<p>Function describing the parameter model. e.g. <code>parameter.model</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ferror_file">fError_file</code></td>
<td>
<p>A string giving the function name or filename and path of the 
residual error model. 
The filename and the function name must be the same if giving a filename. 
e.g. <code>"feps.prop"</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ferror_fun">fError_fun</code></td>
<td>
<p>Function describing the residual error model. e.g. <code>feps.prop</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_optsw">optsw</code></td>
<td>

<ul>
<li> <p><b>******WHAT TO OPTIMIZE**********</b></p>
</li></ul>

<p>Row vector of optimization tasks (1=TRUE,0=FALSE) in the following order: 
(Samples per subject, Sampling schedule, Discrete design variable, Continuous design variable, Number of id per group). 
All elements set to zero =&gt; only calculate the FIM with current design</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_xt">xt</code></td>
<td>

<ul>
<li> <p><b>******START OF INITIAL DESIGN OPTIONS**********</b></p>
</li></ul>

<p>Matrix defining the initial sampling schedule. 
Each row is a group/individual.
If only one vector is supplied, e.g. <code>c(1,2,3,4)</code>, then all groups will 
have the same initial design.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_m">m</code></td>
<td>
<p>Number of groups in the study.  Each individual in a group will have the same design.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_x">x</code></td>
<td>
<p>A matrix defining the initial discrete values for the model 
Each row is a group/individual.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_nx">nx</code></td>
<td>
<p>Number of discrete design variables.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_a">a</code></td>
<td>
<p>Matrix defining the initial continuous covariate values. 
n_rows=number of groups, n_cols=number of covariates.
If the number of rows is one and the number of groups &gt; 1 then all groups are assigned the 
same values.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_groupsize">groupsize</code></td>
<td>
<p>Vector defining the size of the different groups (num individuals in each group).
If only one number then the number will be the same in every group.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ni">ni</code></td>
<td>
<p>Vector defining the number of samples for each group.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_model_switch">model_switch</code></td>
<td>
<p>Matrix defining which response a certain sampling time belongs to.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxni">maxni</code></td>
<td>

<ul>
<li> <p><b>******START OF DESIGN SPACE OPTIONS**********</b></p>
</li></ul>

<p>Max number of samples per group/individual</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_minni">minni</code></td>
<td>
<p>Min number of samples per group/individual</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxtotni">maxtotni</code></td>
<td>
<p>Number defining the maximum number of samples allowed in the experiment.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_mintotni">mintotni</code></td>
<td>
<p>Number defining the minimum number of samples allowed in the experiment.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxgroupsize">maxgroupsize</code></td>
<td>
<p>Vector defining the max size of the different groups (max number of individuals in each group)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_mingroupsize">mingroupsize</code></td>
<td>
<p>Vector defining the min size of the different groups (min num individuals in each group) &ndash;</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxtotgroupsize">maxtotgroupsize</code></td>
<td>
<p>The total maximal groupsize over all groups</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_mintotgroupsize">mintotgroupsize</code></td>
<td>
<p>The total minimal groupsize over all groups</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_discrete_xt">discrete_xt</code></td>
<td>
<p>Cell array <code><a href="#topic+cell">cell</a></code> defining the discrete variables allowed for each xt value.
Can also be a list of values <code>list(1:10)</code> (same values allowed for all xt), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in xt). See examples in <code><a href="#topic+create_design_space">create_design_space</a></code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_discrete_x">discrete_x</code></td>
<td>
<p>Cell array defining the discrete variables for each x value. 
See examples in <code><a href="#topic+create_design_space">create_design_space</a></code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_discrete_a">discrete_a</code></td>
<td>
<p>Cell array <code><a href="#topic+cell">cell</a></code> defining the discrete variables allowed for each a value.
Can also be a list of values <code>list(1:10)</code> (same values allowed for all a), or a list of lists 
<code>list(1:10, 2:23, 4:6)</code> (one for each value in a). See examples in <code><a href="#topic+create_design_space">create_design_space</a></code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_busegrouped_xt">bUseGrouped_xt</code></td>
<td>
<p>Use grouped time points (1=TRUE, 0=FALSE).</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_g_xt">G_xt</code></td>
<td>
<p>Matrix defining the grouping of sample points. Matching integers mean that the points are matched.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_busegrouped_a">bUseGrouped_a</code></td>
<td>
<p>Use grouped covariates (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_g_a">G_a</code></td>
<td>
<p>Matrix defining the grouping of covariates. Matching integers mean that the points are matched.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_busegrouped_x">bUseGrouped_x</code></td>
<td>
<p>Use grouped discrete design variables (1=TRUE, 0=FALSE).</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_g_x">G_x</code></td>
<td>
<p>Matrix defining the grouping of discrete design variables. Matching integers mean that the points are matched.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ifimcalculationtype">iFIMCalculationType</code></td>
<td>

<ul>
<li> <p><b>******START OF FIM CALCULATION OPTIONS**********</b></p>
</li></ul>

<p>Fisher Information Matrix type
</p>

<ul>
<li><p> 0=Full FIM
</p>
</li>
<li><p> 1=Reduced FIM
</p>
</li>
<li><p> 2=weighted models
</p>
</li>
<li><p> 3=Loc models
</p>
</li>
<li><p> 4=reduced FIM with derivative of SD of sigma as in PFIM
</p>
</li>
<li><p> 5=FULL FIM parameterized with A,B,C matrices &amp; derivative of variance
</p>
</li>
<li><p> 6=Calculate one model switch at a time, good for large matrices
</p>
</li>
<li><p> 7=Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance
</p>
</li></ul>
</td></tr>
<tr><td><code id="create.poped.database_+3A_iapproximationmethod">iApproximationMethod</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ifocenumind">iFOCENumInd</code></td>
<td>
<p>Num individuals in each step of FOCE</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_prior_fim">prior_fim</code></td>
<td>
<p>The prior FIM (added to calculated FIM)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_strautocorrelationfile">strAutoCorrelationFile</code></td>
<td>
<p>Filename and path, or function name, for the Autocorrelation function, 
empty string means no autocorrelation.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ds_index">ds_index</code></td>
<td>
<p>Ds_index is a vector set to 1 if a parameter is uninteresting, otherwise 0.
size=(1,num unfixed parameters). First unfixed bpop, then unfixed d, then unfixed docc and last unfixed sigma. 
Default is the fixed effects being important, everything else not important.  Used in conjunction with
<code>ofv_calc_type=6</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_stredpenaltyfile">strEDPenaltyFile</code></td>
<td>
<p>Penalty function name or path and filename, empty string means no penalty.
User defined criterion can be defined this way.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_iedcalculationtype">iEDCalculationType</code></td>
<td>

<ul>
<li> <p><b>******START OF E-FAMILY CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>ED Integral Calculation, 0=Monte-Carlo-Integration, 1=Laplace Approximation, 2=BFGS Laplace Approximation  &ndash; &ndash;</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_struserdistributionfile">strUserDistributionFile</code></td>
<td>
<p>Filename and path, or function name, for user defined distributions for E-family designs</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_nbpop">nbpop</code></td>
<td>

<ul>
<li> <p><b>******START OF Model parameters  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>Number of typical values</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_numraneff">NumRanEff</code></td>
<td>
<p>Number of IIV parameters. Typically can be computed from other values and not supplied.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_numdocc">NumDocc</code></td>
<td>
<p>Number of IOV variance parameters. Typically can be computed from other values and not supplied.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_numocc">NumOcc</code></td>
<td>
<p>Number of occasions. Typically can be computed from other values and not supplied.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_covd">covd</code></td>
<td>
<p>Column major vector defining the covariances of the IIV variances. 
That is, from your full IIV matrix  <code>covd &lt;-  IIV[lower.tri(IIV)]</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_covdocc">covdocc</code></td>
<td>
<p>Column major vector defining the covariance of the IOV, as in covd.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_bpop">notfixed_bpop</code></td>
<td>

<ul>
<li> <p><b>******START OF Model parameters fixed or not  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>Vector defining if a typical value is fixed or not (1=not fixed, 0=fixed). 
The parameter order of 'notfixed_bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'notfixed_bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_d">notfixed_d</code></td>
<td>
<p>Vector defining if a IIV is fixed or not (1=not fixed, 0=fixed). 
The parameter order of 'notfixed_d' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'notfixed_d' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'. .</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_covd">notfixed_covd</code></td>
<td>
<p>Vector defining if a covariance IIV is fixed or not (1=not fixed, 0=fixed)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_docc">notfixed_docc</code></td>
<td>
<p>Vector defining if an IOV variance is fixed or not (1=not fixed, 0=fixed)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_covdocc">notfixed_covdocc</code></td>
<td>
<p>Vector row major order for lower triangular matrix defining if a covariance IOV is fixed or not (1=not fixed, 0=fixed)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_sigma">notfixed_sigma</code></td>
<td>
<p>Vector defining if a residual error parameter is fixed or not (1=not fixed, 0=fixed)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_notfixed_covsigma">notfixed_covsigma</code></td>
<td>
<p>Vector defining if a covariance residual error parameter is fixed or not (1=not fixed, 0=fixed). 
Default is fixed.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_reorder_parameter_vectors">reorder_parameter_vectors</code></td>
<td>
<p>If you use named arguments in 'bpop' or 'd' then PopED will try to figure out the order of the parameters 
based on what is found in the 'fg_fun'. See the resulting &lsquo;poped_db$parameters' and make sure the order matches with &rsquo;fg_fun'.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_buserandomsearch">bUseRandomSearch</code></td>
<td>

<ul>
<li> <p><b>******START OF Optimization algorithm  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>Use random search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_busestochasticgradient">bUseStochasticGradient</code></td>
<td>
<p>Use Stochastic Gradient search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_buselinesearch">bUseLineSearch</code></td>
<td>
<p>Use Line search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_buseexchangealgorithm">bUseExchangeAlgorithm</code></td>
<td>
<p>Use Exchange algorithm (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_busebfgsminimizer">bUseBFGSMinimizer</code></td>
<td>
<p>Use BFGS Minimizer (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_eacriteria">EACriteria</code></td>
<td>
<p>Exchange Algorithm Criteria, 1 = Modified, 2 = Fedorov</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_strrunfile">strRunFile</code></td>
<td>
<p>Filename and path, or function name, for a run file that is used instead of the regular PopED call.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_poped_version">poped_version</code></td>
<td>

<ul>
<li> <p><b>******START OF Labeling and file names  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>The current PopED version</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_modtit">modtit</code></td>
<td>
<p>The model title</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_output_file">output_file</code></td>
<td>
<p>Filename and path of the output file during search</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_output_function_file">output_function_file</code></td>
<td>
<p>Filename suffix of the result function file</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_striterationfilename">strIterationFileName</code></td>
<td>
<p>Filename and path for storage of current optimal design</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_user_data">user_data</code></td>
<td>

<ul>
<li> <p><b>******START OF Miscellaneous SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>User defined data structure that, for example could be used to send in data to the model</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ourzero">ourzero</code></td>
<td>
<p>Value to interpret as zero in design</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_dseed">dSeed</code></td>
<td>
<p>The seed number used for optimization and sampling &ndash; integer or -1 which creates a random seed <code>as.integer(Sys.time())</code> or NULL.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_line_opta">line_opta</code></td>
<td>
<p>Vector for line search on continuous design variables (1=TRUE,0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_line_optx">line_optx</code></td>
<td>
<p>Vector for line search on discrete design variables (1=TRUE,0=FALSE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bshowgraphs">bShowGraphs</code></td>
<td>
<p>Use graph output during search</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_use_logfile">use_logfile</code></td>
<td>
<p>If a log file should be used (0=FALSE, 1=TRUE)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_m1_switch">m1_switch</code></td>
<td>
<p>Method used to calculate M1 
(0=Complex difference, 1=Central difference, 20=Analytic derivative, 30=Automatic differentiation)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_m2_switch">m2_switch</code></td>
<td>
<p>Method used to calculate M2
(0=Central difference, 1=Central difference, 20=Analytic derivative, 30=Automatic differentiation)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hle_switch">hle_switch</code></td>
<td>
<p>Method used to calculate linearization of residual error
(0=Complex difference, 1=Central difference, 30=Automatic differentiation)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_gradff_switch">gradff_switch</code></td>
<td>
<p>Method used to calculate the gradient of the model
(0=Complex difference, 1=Central difference, 20=Analytic derivative, 30=Automatic differentiation)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_gradfg_switch">gradfg_switch</code></td>
<td>
<p>Method used to calculate the gradient of the parameter vector g
(0=Complex difference, 1=Central difference, 20=Analytic derivative, 30=Automatic differentiation)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_grad_all_switch">grad_all_switch</code></td>
<td>
<p>Method used to calculate all the gradients
(0=Complex difference, 1=Central difference)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_rsit_output">rsit_output</code></td>
<td>
<p>Number of iterations in random search between screen output</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_sgit_output">sgit_output</code></td>
<td>
<p>Number of iterations in stochastic gradient search between screen output</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hm1">hm1</code></td>
<td>
<p>Step length of derivative of linearized model w.r.t. typical values</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hlf">hlf</code></td>
<td>
<p>Step length of derivative of model w.r.t. g</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hlg">hlg</code></td>
<td>
<p>Step length of derivative of g w.r.t. b</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hm2">hm2</code></td>
<td>
<p>Step length of derivative of variance w.r.t. typical values</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hgd">hgd</code></td>
<td>
<p>Step length of derivative of OFV w.r.t. time</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_hle">hle</code></td>
<td>
<p>Step length of derivative of model w.r.t. sigma</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_abstol">AbsTol</code></td>
<td>
<p>The absolute tolerance for the diff equation solver</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_reltol">RelTol</code></td>
<td>
<p>The relative tolerance for the diff equation solver</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_idiffsolvermethod">iDiffSolverMethod</code></td>
<td>
<p>The diff equation solver method, NULL as default.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_busememorysolver">bUseMemorySolver</code></td>
<td>
<p>If the differential equation results should be stored in memory (1) or not (0)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_rsit">rsit</code></td>
<td>
<p>Number of Random search iterations</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_sgit">sgit</code></td>
<td>
<p>Number of stochastic gradient iterations</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_intrsit">intrsit</code></td>
<td>
<p>Number of Random search iterations with discrete optimization.</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_intsgit">intsgit</code></td>
<td>
<p>Number of Stochastic Gradient search iterations with discrete optimization</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_maxrsnullit">maxrsnullit</code></td>
<td>
<p>Iterations until adaptive narrowing in random search</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_convergence_eps">convergence_eps</code></td>
<td>
<p>Stochastic Gradient convergence value,
(difference in OFV for D-optimal, difference in gradient for ED-optimal)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_rslxt">rslxt</code></td>
<td>
<p>Random search locality factor for sample times</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_rsla">rsla</code></td>
<td>
<p>Random search locality factor for covariates</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_cfaxt">cfaxt</code></td>
<td>
<p>Stochastic Gradient search first step factor for sample times</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_cfaa">cfaa</code></td>
<td>
<p>Stochastic Gradient search first step factor for covariates</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bgreedygroupopt">bGreedyGroupOpt</code></td>
<td>
<p>Use greedy algorithm for group assignment optimization</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_eastepsize">EAStepSize</code></td>
<td>
<p>Exchange Algorithm StepSize</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_eanumpoints">EANumPoints</code></td>
<td>
<p>Exchange Algorithm NumPoints</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_eaconvergencecriteria">EAConvergenceCriteria</code></td>
<td>
<p>Exchange Algorithm Convergence Limit/Criteria</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_beanoreplicates">bEANoReplicates</code></td>
<td>
<p>Avoid replicate samples when using Exchange Algorithm</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bfgsconvergencecriteriaminstep">BFGSConvergenceCriteriaMinStep</code></td>
<td>
<p>BFGS Minimizer Convergence Criteria Minimum Step</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bfgsprojectedgradienttol">BFGSProjectedGradientTol</code></td>
<td>
<p>BFGS Minimizer Convergence Criteria Normalized Projected Gradient Tolerance</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bfgstolerancef">BFGSTolerancef</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance f</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bfgstoleranceg">BFGSToleranceg</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance g</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bfgstolerancex">BFGSTolerancex</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance x</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ed_diff_it">ED_diff_it</code></td>
<td>
<p>Number of iterations in ED-optimal design to calculate convergence criteria</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_ed_diff_percent">ED_diff_percent</code></td>
<td>
<p>ED-optimal design convergence criteria in percent</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_line_search_it">line_search_it</code></td>
<td>
<p>Number of grid points in the line search</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_doptim_iter">Doptim_iter</code></td>
<td>
<p>Number of iterations of full Random search and full Stochastic Gradient if line search is not used</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_icompileoption">iCompileOption</code></td>
<td>
<p><b>******START OF PARALLEL OPTIONS**********</b> Compile options for PopED
</p>

<ul>
<li><p> -1 = No compilation,
</p>
</li>
<li><p> 0 or 3 = Full compilation,
</p>
</li>
<li><p> 1 or 4 = Only using MCC (shared lib),
</p>
</li>
<li><p> 2 or 5 = Only MPI,
</p>
</li>
<li><p> Option 0,1,2 runs PopED and option 3,4,5 stops after compilation
</p>
</li></ul>
</td></tr>
<tr><td><code id="create.poped.database_+3A_iuseparallelmethod">iUseParallelMethod</code></td>
<td>
<p>Parallel method to use (0 = Matlab PCT, 1 = MPI)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_mcc_dep">MCC_Dep</code></td>
<td>
<p>Additional dependencies used in MCC compilation (mat-files), if several space separated</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_strexecutename">strExecuteName</code></td>
<td>
<p>Compilation output executable name</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_inumprocesses">iNumProcesses</code></td>
<td>
<p>Number of processes to use when running in parallel (e.g. 3 = 2 workers, 1 job manager)</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_inumchunkdesignevals">iNumChunkDesignEvals</code></td>
<td>
<p>Number of design evaluations that should be evaluated in each process before getting new work from job manager</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_mat_out_pre">Mat_Out_Pre</code></td>
<td>
<p>The prefix of the output mat file to communicate with the executable</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_strextrarunoptions">strExtraRunOptions</code></td>
<td>
<p>Extra options send to e$g. the MPI executable or a batch script, see execute_parallel$m for more information and options</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_dpollresulttime">dPollResultTime</code></td>
<td>
<p>Polling time to check if the parallel execution is finished</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_strfunctioninputname">strFunctionInputName</code></td>
<td>
<p>The file containing the popedInput structure that should be used to evaluate the designs</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bparallelrs">bParallelRS</code></td>
<td>
<p>If the random search is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bparallelsg">bParallelSG</code></td>
<td>
<p>If the stochastic gradient search is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bparallelmfea">bParallelMFEA</code></td>
<td>
<p>If the modified exchange algorithm is going to be executed in parallel</p>
</td></tr>
<tr><td><code id="create.poped.database_+3A_bparallells">bParallelLS</code></td>
<td>
<p>If the line search is going to be executed in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PopED database
</p>


<h3>See Also</h3>

<p>Other poped_input: 
<code><a href="#topic+convert_variables">convert_variables</a>()</code>,
<code><a href="#topic+create_design">create_design</a>()</code>,
<code><a href="#topic+create_design_space">create_design_space</a>()</code>,
<code><a href="#topic+downsizing_general_design">downsizing_general_design</a>()</code>,
<code><a href="#topic+poped.choose">poped.choose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
    return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(
  ff_fun=ff.PK.1.comp.oral.sd.CL,
  fg_fun=sfg,
  fError_fun=feps.prop,
  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
  notfixed_bpop=c(1,1,1,0),
  d=c(CL=0.07, V=0.02, KA=0.6), 
  sigma=0.01,
  groupsize=32,
  xt=c( 0.5,1,2,6,24,36,72,120),
  minxt=0,
  maxxt=120,
  a=70)


## evaluate initial design
evaluate_design(poped.db)
</code></pre>

<hr>
<h2 id='design_summary'>Display a summary of output from poped_db</h2><span id='topic+design_summary'></span>

<h3>Description</h3>

<p>Display a summary of output from poped_db
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_summary(poped_db, file = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_summary_+3A_poped_db">poped_db</code></td>
<td>
<p>An object returned from <code><a href="#topic+create.poped.database">create.poped.database</a></code> to summarize.</p>
</td></tr>
<tr><td><code id="design_summary_+3A_file">file</code></td>
<td>
<p>A file handle to write to.  Default is to the R console.</p>
</td></tr>
<tr><td><code id="design_summary_+3A_...">...</code></td>
<td>
<p>Additional arguments. Passed to <code><a href="#topic+blockfinal">blockfinal</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='diag_matlab'>Function written to match MATLAB's diag function</h2><span id='topic+diag_matlab'></span>

<h3>Description</h3>

<p>There are some differences between tha MATLAB and the R version of diag.
Specifically, if a 1xN or a Nx1 matrix is supplied to the R
<code><a href="base.html#topic+diag">diag</a></code> function then just the first element of this vector is
returned. This function tries to match the MATLAB version in handling vectors
(matricies with one dimension equal to one), and will return a diagonal
matrix in these situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_matlab(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diag_matlab_+3A_mat">mat</code></td>
<td>
<p>Either a vector to make into a diagonal matrix or a matrix you 
want to extract the diagonal from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a diagonal matrix or the diagonal of a matrix.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
diag_matlab(3)
diag_matlab(c(1,2,3))
diag_matlab(cbind(1,2,3))
diag_matlab(rbind(1,2,3))

diag_matlab(matrix(c(1, 2, 3),6,6))

# here is where the R default does something different
diag(cbind(1,2,3))
diag(rbind(1,2,3))

</code></pre>

<hr>
<h2 id='Doptim'>D-family optimization function</h2><span id='topic+Doptim'></span>

<h3>Description</h3>

<p>Optimize the objective function. There are 4 different optimization
algorithms used in this function </p>
 <ol>
<li><p> Adaptive random search.
See <code><a href="#topic+RS_opt">RS_opt</a></code>. </p>
</li>
<li><p> Stochastic gradient. </p>
</li>
<li><p> A Broyden Fletcher
Goldfarb Shanno (BFGS) method for nonlinear minimization with box
constraints. </p>
</li>
<li><p> A line search. See <code><a href="#topic+a_line_search">a_line_search</a></code>. </p>
</li></ol>
<p> The
optimization algorithms run in series, taking as input the output from the
previous method. The stopping rule used is to test if the line search
algorithm fids a better optimum then its initial value. If so, then the chain
of algorithms is run again.  If line search is not used then the argument
<code>iter_tot</code> defines the number of times the chain of algorithms is run. 
This function takes information from the PopED database supplied as an
argument. The PopED database supplies information about the the model,
parameters, design and methods to use. Some of the arguments coming from the
PopED database can be overwritten; if they are supplied then they are used
instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Doptim(
  poped.db,
  ni,
  xt,
  model_switch,
  x,
  a,
  bpopdescr,
  ddescr,
  maxxt,
  minxt,
  maxa,
  mina,
  fmf = 0,
  dmf = 0,
  trflag = TRUE,
  bUseRandomSearch = poped.db$settings$bUseRandomSearch,
  bUseStochasticGradient = poped.db$settings$bUseStochasticGradient,
  bUseBFGSMinimizer = poped.db$settings$bUseBFGSMinimizer,
  bUseLineSearch = poped.db$settings$bUseLineSearch,
  sgit = poped.db$settings$sgit,
  ls_step_size = poped.db$settings$ls_step_size,
  BFGSConvergenceCriteriaMinStep = poped.db$settings$BFGSConvergenceCriteriaMinStep,
  BFGSProjectedGradientTol = poped.db$settings$BFGSProjectedGradientTol,
  BFGSTolerancef = poped.db$settings$BFGSTolerancef,
  BFGSToleranceg = poped.db$settings$BFGSToleranceg,
  BFGSTolerancex = poped.db$settings$BFGSTolerancex,
  iter_tot = poped.db$settings$iNumSearchIterationsIfNotLineSearch,
  iter_max = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Doptim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="Doptim_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="Doptim_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="Doptim_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="Doptim_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="Doptim_+3A_fmf">fmf</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="Doptim_+3A_buserandomsearch">bUseRandomSearch</code></td>
<td>

<ul>
<li> <p><b>******START OF Optimization algorithm  SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>Use random search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="Doptim_+3A_busestochasticgradient">bUseStochasticGradient</code></td>
<td>
<p>Use Stochastic Gradient search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="Doptim_+3A_busebfgsminimizer">bUseBFGSMinimizer</code></td>
<td>
<p>Use BFGS Minimizer (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="Doptim_+3A_buselinesearch">bUseLineSearch</code></td>
<td>
<p>Use Line search (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="Doptim_+3A_sgit">sgit</code></td>
<td>
<p>Number of stochastic gradient iterations</p>
</td></tr>
<tr><td><code id="Doptim_+3A_ls_step_size">ls_step_size</code></td>
<td>
<p>Number of grid points in the line search.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_bfgsconvergencecriteriaminstep">BFGSConvergenceCriteriaMinStep</code></td>
<td>
<p>BFGS Minimizer Convergence Criteria Minimum Step</p>
</td></tr>
<tr><td><code id="Doptim_+3A_bfgsprojectedgradienttol">BFGSProjectedGradientTol</code></td>
<td>
<p>BFGS Minimizer Convergence Criteria Normalized Projected Gradient Tolerance</p>
</td></tr>
<tr><td><code id="Doptim_+3A_bfgstolerancef">BFGSTolerancef</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance f</p>
</td></tr>
<tr><td><code id="Doptim_+3A_bfgstoleranceg">BFGSToleranceg</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance g</p>
</td></tr>
<tr><td><code id="Doptim_+3A_bfgstolerancex">BFGSTolerancex</code></td>
<td>
<p>BFGS Minimizer Line Search Tolerance x</p>
</td></tr>
<tr><td><code id="Doptim_+3A_iter_tot">iter_tot</code></td>
<td>
<p>Number of iterations to use if line search is not used. Must
be less than <code>iter_max</code> to be used.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_iter_max">iter_max</code></td>
<td>
<p>If line search is used then the algorithm tests if line
search (always run at the end of the optimization iteration) changes the 
design in any way.  If not, the algorithm stops.  If yes, then a new
iteration is run unless <code>iter_max</code> iterations have already been run.</p>
</td></tr>
<tr><td><code id="Doptim_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

 <ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A.
Ruggeri, &quot;PopED, a software for optimal experimental design in population
kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004. </p>
</li>
<li><p> J.
Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C.
Hooker, &quot;PopED: An extended, parallelized, nonlinear mixed effects models
optimal design tool&quot;, Computer Methods and Programs in Biomedicine, 108,
2012. </p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


## Not run: 
  
  ##############
  # typically one will use poped_optimize 
  # This then calls Doptim for continuous optimization problems
  ##############
  
  
  # RS+SG+LS optimization of sample times
  # optimization with just a few iterations
  # only to check that things are working
  output &lt;- poped_optimize(poped.db,opt_xt=T,
                           rsit=5,sgit=5,ls_step_size=5)
  
  # RS+SG+LS optimization of sample times 
  # (longer run time than above but more likely to reach a maximum)
  output &lt;- poped_optimize(poped.db,opt_xt=T)
  get_rse(output$fmf,output$poped.db)
  plot_model_prediction(output$poped.db)
  
  
  # Random search (just a few samples here)
  rs.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,rsit=20,
                              bUseRandomSearch= 1,
                              bUseStochasticGradient = 0,
                              bUseBFGSMinimizer = 0,
                              bUseLineSearch = 0)
  
  # line search, DOSE and sample time optimization
  ls.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,
                              bUseRandomSearch= 0,
                              bUseStochasticGradient = 0,
                              bUseBFGSMinimizer = 0,
                              bUseLineSearch = 1,
                              ls_step_size=10)
  
  # Stochastic gradient search, DOSE and sample time optimization
  sg.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1, 
                              bUseRandomSearch= 0,
                              bUseStochasticGradient = 1,
                              bUseBFGSMinimizer = 0,
                              bUseLineSearch = 0,
                              sgit=20)
  
  # BFGS search, DOSE and sample time optimization
  bfgs.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,
                                bUseRandomSearch= 0,
                                bUseStochasticGradient = 0,
                                bUseBFGSMinimizer = 1,
                                bUseLineSearch = 0)

  ##############
  # If you really want to you can use Doptim dirtectly
  ##############
  dsl &lt;- downsizing_general_design(poped.db)
  poped.db$settings$optsw[2] &lt;- 1  # sample time optimization
  output &lt;- Doptim(poped.db,dsl$ni, dsl$xt, dsl$model_switch, dsl$x, dsl$a, 
         dsl$bpop, dsl$d, dsl$maxxt, dsl$minxt,dsl$maxa,dsl$mina) 
  

## End(Not run)


</code></pre>

<hr>
<h2 id='downsizing_general_design'>Downsize a general design to a specific design</h2><span id='topic+downsizing_general_design'></span>

<h3>Description</h3>

<p>Function takes a design with potentially empty design 
variables and rescues the design so that a FIM can be calculated using <code><a href="#topic+mftot">mftot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsizing_general_design(poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="downsizing_general_design_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code>xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code>model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code>bpop</code></td>
<td>
<p>A matrix of fixed effect parameter values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other poped_input: 
<code><a href="#topic+convert_variables">convert_variables</a>()</code>,
<code><a href="#topic+create.poped.database">create.poped.database</a>()</code>,
<code><a href="#topic+create_design">create_design</a>()</code>,
<code><a href="#topic+create_design_space">create_design_space</a>()</code>,
<code><a href="#topic+poped.choose">poped.choose</a>()</code>
</p>

<hr>
<h2 id='Dtrace'>Trace optimization routines</h2><span id='topic+Dtrace'></span>

<h3>Description</h3>

<p>A helper function for writing output to the screen and files when optimizing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dtrace(
  fn,
  it,
  ni,
  xtopt,
  xopt,
  aopt,
  gxt,
  ga,
  dmf,
  diff,
  ixt,
  ia,
  itvector,
  dmfvector,
  poped.db,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  rsit = poped.db$settings$rsit,
  convergence_eps = poped.db$settings$convergence_eps
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dtrace_+3A_fn">fn</code></td>
<td>
<p>A file to output information to. Can also be the screen if <code>''</code>.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_it">it</code></td>
<td>
<p>the iteration number.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_xtopt">xtopt</code></td>
<td>
<p>The matrix defining current best sampling schedule.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_xopt">xopt</code></td>
<td>
<p>The cell structure defining the current best discrete design variables.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_aopt">aopt</code></td>
<td>
<p>The matrix defining the current best continuous design variables.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_gxt">gxt</code></td>
<td>
<p>The matrix defining the current gradient of the xt vector.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_ga">ga</code></td>
<td>
<p>The matrix defining the current gradient for the continuous design variables.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_dmf">dmf</code></td>
<td>
<p>The current OFV.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_diff">diff</code></td>
<td>
<p>The difference from the previous iteration.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_ixt">ixt</code></td>
<td>
<p>If xt Gradient Inversion occurred or not.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_ia">ia</code></td>
<td>
<p>If a Gradient Inversion occurred or not.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_itvector">itvector</code></td>
<td>
<p>The iteration vector.  Not currently used.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_dmfvector">dmfvector</code></td>
<td>
<p>The dmf vector. Not currently used.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_rsit">rsit</code></td>
<td>
<p>Number of Random search iterations</p>
</td></tr>
<tr><td><code id="Dtrace_+3A_convergence_eps">convergence_eps</code></td>
<td>
<p>Stochastic Gradient convergence value,
(difference in OFV for D-optimal, difference in gradient for ED-optimal)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


FIM &lt;- evaluate.fim(poped.db) 
dmf &lt;- det(FIM)

Dtrace(fn="",
       it=1,
       ni=poped.db$design$ni,
       xtopt=poped.db$design$xt,
       xopt=poped.db$design$x,
       aopt=poped.db$design$a,
       gxt=0,ga=0,
       dmf=dmf,diff=3,
       ixt=FALSE,
       ia=FALSE, 
       itvector=NULL,
       dmfvector=NULL,
       poped.db,
       opt_xt=poped.db$settings$optsw[2],
       opt_a=poped.db$settings$optsw[4],opt_x=poped.db$settings$optsw[3],
       opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
       rsit=200)

Dtrace(fn="",
       it=1,
       ni=poped.db$design$ni,
       xtopt=poped.db$design$xt,
       xopt=poped.db$design$x,
       aopt=poped.db$design$a,
       gxt=0,ga=0,
       dmf=dmf,diff=3,
       ixt=FALSE,
       ia=FALSE, 
       itvector=NULL,
       dmfvector=NULL,
       poped.db,
       opt_xt=poped.db$settings$optsw[2],
       opt_a=poped.db$settings$optsw[4],opt_x=poped.db$settings$optsw[3],
       opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
       rsit=0)

Dtrace(fn="",
       it=1,
       ni=poped.db$design$ni,
       xtopt=poped.db$design$xt,
       xopt=poped.db$design$x,
       aopt=poped.db$design$a,
       gxt=0,ga=0,
       dmf=dmf,diff=3,
       ixt=FALSE,
       ia=FALSE, 
       itvector=NULL,
       dmfvector=NULL,
       poped.db,
       opt_xt=poped.db$settings$optsw[2],
       opt_a=poped.db$settings$optsw[4],opt_x=poped.db$settings$optsw[3],
       opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
       rsit=1)

Dtrace(fn="",
       it=1,
       ni=poped.db$design$ni,
       xtopt=poped.db$design$xt,
       xopt=poped.db$design$x,
       aopt=poped.db$design$a,
       gxt=0,ga=0,
       dmf=dmf,
       diff=0,
       ixt=FALSE,
       ia=FALSE, 
       itvector=NULL,
       dmfvector=NULL,
       poped.db,
       opt_xt=poped.db$settings$optsw[2],
       opt_a=poped.db$settings$optsw[4],opt_x=poped.db$settings$optsw[3],
       opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
       rsit=1)

Dtrace(fn="",
       it=5,
       ni=poped.db$design$ni,
       xtopt=poped.db$design$xt,
       xopt=poped.db$design$x,
       aopt=poped.db$design$a,
       gxt=0,ga=0,
       dmf=dmf,
       diff=0,
       ixt=FALSE,
       ia=FALSE, 
       itvector=NULL,
       dmfvector=NULL,
       poped.db,
       opt_xt=poped.db$settings$optsw[2],
       opt_a=poped.db$settings$optsw[4],opt_x=poped.db$settings$optsw[3],
       opt_samps=poped.db$settings$optsw[1],opt_inds=poped.db$settings$optsw[5],
       rsit=1)

</code></pre>

<hr>
<h2 id='ed_laplace_ofv'>Evaluate the expectation of determinant the Fisher Information Matrix (FIM)
using the Laplace approximation.</h2><span id='topic+ed_laplace_ofv'></span>

<h3>Description</h3>

<p>Compute the expectation of the <code>det(FIM)</code> using the Laplace
approximation to the expectation. Computations are made based on the model,
parameters, distributions of parameter uncertainty, design and methods
defined in the PopED database or as arguments to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ed_laplace_ofv(
  model_switch,
  groupsize,
  ni,
  xtopto,
  xopto,
  aopto,
  bpopdescr,
  ddescr,
  covd,
  sigma,
  docc,
  poped.db,
  method = 1,
  return_gradient = FALSE,
  optxt = poped.db$settings$optsw[2],
  opta = poped.db$settings$optsw[4],
  x = c(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ed_laplace_ofv_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_xtopto">xtopto</code></td>
<td>
<p>the sampling times</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_xopto">xopto</code></td>
<td>
<p>the discrete design variables</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_aopto">aopto</code></td>
<td>
<p>the continuous design variables</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_covd">covd</code></td>
<td>
<p>Column major vector defining the covariances of the IIV variances. 
That is, from your full IIV matrix  <code>covd &lt;-  IIV[lower.tri(IIV)]</code>.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_method">method</code></td>
<td>
<p>If 0 then use an optimization routine translated from PopED code written in MATLAB to
optimize the parameters in the Laplace approximation.  If 1 then use <code><a href="stats.html#topic+optim">optim</a></code> to compute both
k and the hessian of k (see Dodds et al, JPP, 2005 for more information). If 2 then use <code><a href="nlme.html#topic+fdHess">fdHess</a></code>
to compute the hessian.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_return_gradient">return_gradient</code></td>
<td>
<p>Should the gradient be returned.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_optxt">optxt</code></td>
<td>
<p>If sampling times are optimized</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_opta">opta</code></td>
<td>
<p>If continuous design variables are optimized</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_x">x</code></td>
<td>
<p>The design parameters to compute the gradient on.</p>
</td></tr>
<tr><td><code id="ed_laplace_ofv_+3A_...">...</code></td>
<td>
<p>Arguments passed through from other functions, does not pass anything to another function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computation follows the method outlined in Dodds et al, 
&quot;Robust Population Pharmacokinetic Experiment Design&quot; JPP, 2005, equation 16.
</p>
<p>Typically this function will not be run by the user.  Instead use <code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a></code>.
</p>


<h3>Value</h3>

<p>The FIM and the hessian of the FIM.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>
<p>Other E-family: 
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error to 
##   avoid sample times at very low concentrations (time 0 or very late samoples).
library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

######################
# Normal distribution
######################
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_n &lt;- cbind(ones(length(bpop_vals),1)*1, # normal distribution
                        bpop_vals,
                        ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_n["Favail",]  &lt;- c(0,1,0)
bpop_vals_ed_n

## -- Define initial design  and design space
poped.db.n &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                    fg_fun=sfg,
                                    fError_fun=feps.add.prop,
                                    bpop=bpop_vals_ed_n, 
                                    notfixed_bpop=c(1,1,1,0),
                                    d=c(CL=0.07, V=0.02, KA=0.6), 
                                    sigma=c(0.01,0.25),
                                    groupsize=32,
                                    xt=c( 0.5,1,2,6,24,36,72,120),
                                    minxt=0,
                                    maxxt=120,
                                    a=70,
                                    mina=0,
                                    maxa=100)


## ED evaluate using LaPlace approximation 
tic(); output &lt;- evaluate.e.ofv.fim(poped.db.n,use_laplace=TRUE); toc()
output$E_ofv

## Not run: 
  
  
  ## ED value using MC integration (roughly)
  tic();e_ofv_mc_n &lt;- evaluate.e.ofv.fim(poped.db.n,ED_samp_size=500,ofv_calc_type = 1);toc()
  e_ofv_mc_n$E_ofv
  
  
  ## Using ed_laplce_ofv directly
  ed_laplace_ofv(model_switch=poped.db.n$design$model_switch,
                 groupsize=poped.db.n$design$groupsize,
                 ni=poped.db.n$design$ni,
                 xtopto=poped.db.n$design$xt,
                 xopto=poped.db.n$design$x,
                 aopto=poped.db.n$design$a,
                 bpopdescr=poped.db.n$parameters$bpop,
                 ddescr=poped.db.n$parameters$d,
                 covd=poped.db.n$parameters$covd,
                 sigma=poped.db.n$parameters$sigma,
                 docc=poped.db.n$parameters$docc, 
                 poped.db.n)
  
  
  ######################
  # Log-normal distribution
  ######################
  
  # Adding 10% log-normal Uncertainty to fixed effects (not Favail)
  bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
  bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                           bpop_vals,
                           ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
  bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
  bpop_vals_ed_ln
  
  ## -- Define initial design  and design space
  poped.db.ln &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                       fg_fun=sfg,
                                       fError_fun=feps.add.prop,
                                       bpop=bpop_vals_ed_ln, 
                                       notfixed_bpop=c(1,1,1,0),
                                       d=c(CL=0.07, V=0.02, KA=0.6), 
                                       sigma=c(0.01,0.25),
                                       groupsize=32,
                                       xt=c( 0.5,1,2,6,24,36,72,120),
                                       minxt=0,
                                       maxxt=120,
                                       a=70,
                                       mina=0,
                                       maxa=100)
  
  
  
  ## ED evaluate using LaPlace approximation 
  tic()
  output &lt;- evaluate.e.ofv.fim(poped.db.ln,use_laplace=TRUE)
  toc()
  output$E_ofv
  
  ## expected value (roughly)
  tic()
  e_ofv_mc_ln &lt;- evaluate.e.ofv.fim(poped.db.ln,ED_samp_size=500,ofv_calc_type = 1)[["E_ofv"]]
  toc()
  e_ofv_mc_ln
  
  ## Using ed_laplce_ofv directly
  ed_laplace_ofv(model_switch=poped.db.ln$design$model_switch,
                 groupsize=poped.db.ln$design$groupsize,
                 ni=poped.db.ln$design$ni,
                 xtopto=poped.db.ln$design$xt,
                 xopto=poped.db.ln$design$x,
                 aopto=poped.db.ln$design$a,
                 bpopdescr=poped.db.ln$parameters$bpop,
                 ddescr=poped.db.ln$parameters$d,
                 covd=poped.db.ln$parameters$covd,
                 sigma=poped.db.ln$parameters$sigma,
                 docc=poped.db.ln$parameters$docc, 
                 poped.db.ln)
  
  
  
  

## End(Not run)

</code></pre>

<hr>
<h2 id='ed_mftot'>Evaluate the expectation of the Fisher Information Matrix (FIM) and the expectation of the OFV(FIM).</h2><span id='topic+ed_mftot'></span>

<h3>Description</h3>

<p>Compute the expectation of the FIM given the model, parameters, distributions of parameter uncertainty, design and methods defined in the 
PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ed_mftot(
  model_switch,
  groupsize,
  ni,
  xtoptn,
  xoptn,
  aoptn,
  bpopdescr,
  ddescr,
  covd,
  sigma,
  docc,
  poped.db,
  calc_fim = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ed_mftot_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_xtoptn">xtoptn</code></td>
<td>
<p>The xtoptn value</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_xoptn">xoptn</code></td>
<td>
<p>The xoptn</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_aoptn">aoptn</code></td>
<td>
<p>The aoptn value</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="ed_mftot_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_covd">covd</code></td>
<td>
<p>Column major vector defining the covariances of the IIV variances. 
That is, from your full IIV matrix  <code>covd &lt;-  IIV[lower.tri(IIV)]</code>.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_calc_fim">calc_fim</code></td>
<td>
<p>Should the FIM be calculated or should we just use the user defined ed_penalty_pointer.</p>
</td></tr>
<tr><td><code id="ed_mftot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the E(FIM) and E(OFV(FIM)) and the a poped.db.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>
<p>Other E-family: 
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error
## to avoid sample times at very low concentrations (time 0 or very late samoples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

# Adding 10% log-normal Uncertainty to fixed effects (not Favail)
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                         bpop_vals,
                         ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
bpop_vals_ed_ln

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=bpop_vals_ed_ln, 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70,
                                  mina=0,
                                  maxa=100)

############# END ###################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################


# very few samples
poped.db$settings$ED_samp_size=10
ed_mftot(model_switch=poped.db$design$model_switch,
         groupsize=poped.db$design$groupsize,
         ni=poped.db$design$ni,
         xtoptn=poped.db$design$xt,
         xoptn=poped.db$design$x,
         aoptn=poped.db$design$a,
         bpopdescr=poped.db$parameters$bpop,
         ddescr=poped.db$parameters$d,
         covd=poped.db$parameters$covd,
         sigma=poped.db$parameters$sigma,
         docc=poped.db$parameters$docc, 
         poped.db)["ED_ofv"]

  
</code></pre>

<hr>
<h2 id='efficiency'>Compute efficiency.</h2><span id='topic+efficiency'></span>

<h3>Description</h3>

<p>Efficiency calculation between two designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiency(
  ofv_init,
  ofv_final,
  poped_db,
  npar = get_fim_size(poped_db),
  ofv_calc_type = poped_db$settings$ofv_calc_type,
  ds_index = poped_db$parameters$ds_index,
  use_log = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efficiency_+3A_ofv_init">ofv_init</code></td>
<td>
<p>An initial objective function</p>
</td></tr>
<tr><td><code id="efficiency_+3A_ofv_final">ofv_final</code></td>
<td>
<p>A final objective function.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_poped_db">poped_db</code></td>
<td>
<p>a poped database</p>
</td></tr>
<tr><td><code id="efficiency_+3A_npar">npar</code></td>
<td>
<p>The number of parameters to use for normalization.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="efficiency_+3A_ds_index">ds_index</code></td>
<td>
<p>Ds_index is a vector set to 1 if a parameter is uninteresting, otherwise 0.
size=(1,num unfixed parameters). First unfixed bpop, then unfixed d, then unfixed docc and last unfixed sigma. 
Default is the fixed effects being important, everything else not important.  Used in conjunction with
<code>ofv_calc_type=6</code>.</p>
</td></tr>
<tr><td><code id="efficiency_+3A_use_log">use_log</code></td>
<td>
<p>Are the 'ofv' arguments in the log space?</p>
</td></tr>
<tr><td><code id="efficiency_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The specified efficiency value depending on the ofv_calc_type.  
The attribute &quot;description&quot; tells you how the calculation was made 
<code>attr(return_vale,"description")</code>
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>

<hr>
<h2 id='evaluate_design'>Evaluate a design</h2><span id='topic+evaluate_design'></span>

<h3>Description</h3>

<p>This function evaluates the design defined in a poped database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_design(poped.db, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_design_+3A_poped.db">poped.db</code></td>
<td>
<p>A poped database</p>
</td></tr>
<tr><td><code id="evaluate_design_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a></code> and <code><a href="#topic+get_rse">get_rse</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements evaluating the current design.
</p>


<h3>See Also</h3>

<p>Other evaluate_design: 
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+evaluate_power">evaluate_power</a>()</code>,
<code><a href="#topic+get_rse">get_rse</a>()</code>,
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################

evaluate_design(poped.db)


</code></pre>

<hr>
<h2 id='evaluate_fim_map'>Compute the Bayesian Fisher information matrix</h2><span id='topic+evaluate_fim_map'></span>

<h3>Description</h3>

<p>Computation of the Bayesian Fisher information matrix for 
individual parameters of a population model based on 
Maximum A Posteriori (MAP) estimation of the empirical Bayes estimates (EBEs) in a population model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_fim_map(
  poped.db,
  use_mc = FALSE,
  num_sim_ids = 1000,
  use_purrr = FALSE,
  shrink_mat = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_fim_map_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
<tr><td><code id="evaluate_fim_map_+3A_use_mc">use_mc</code></td>
<td>
<p>Should the calculation be based on monte-carlo simulations. If
not then then a first order approximation is used</p>
</td></tr>
<tr><td><code id="evaluate_fim_map_+3A_num_sim_ids">num_sim_ids</code></td>
<td>
<p>If <code>use_mc=TRUE</code>, how many individuals should be
simulated to make the computations.</p>
</td></tr>
<tr><td><code id="evaluate_fim_map_+3A_use_purrr">use_purrr</code></td>
<td>
<p>If <code>use_mc=TRUE</code> then should the method use the package
purrr in calculations?  This may speed up computations (potentially).</p>
</td></tr>
<tr><td><code id="evaluate_fim_map_+3A_shrink_mat">shrink_mat</code></td>
<td>
<p>Should the shrinkage matrix be returned.  Calculated as the
inverse of the  Bayesian Fisher information matrix times the inverse of the 
omega matrix (variance matrix of the between-subject variability).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Bayesian Fisher information matrix for each design group
</p>


<h3>References</h3>

 
<ol>
<li><p> Combes, F. P., Retout, S.,
Frey, N., &amp; Mentre, F. (2013). Prediction of shrinkage of individual
parameters using the Bayesian information matrix in non-linear mixed effect
models with evaluation in pharmacokinetics. Pharmaceutical Research, 30(9),
2355-67. <a href="https://doi.org/10.1007/s11095-013-1079-3">doi:10.1007/s11095-013-1079-3</a>. 
</p>
</li>
<li><p> Hennig, S., Nyberg, J., Fanta, S., Backman, J.
T., Hoppu, K., Hooker, A. C., &amp; Karlsson, M. O. (2012). Application of the
optimal design approach to improve a pretransplant drug dose finding design
for ciclosporin. Journal of Clinical Pharmacology, 52(3), 347-360.
<a href="https://doi.org/10.1177/0091270010397731">doi:10.1177/0091270010397731</a>. 
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################

shrinkage(poped.db)


</code></pre>

<hr>
<h2 id='evaluate_power'>Power of a design to estimate a parameter.</h2><span id='topic+evaluate_power'></span>

<h3>Description</h3>

<p>Evaluate the power of a design to estimate a parameter value different than
some assumed value (often the assumed value is zero). The power is calculated 
using the linear Wald test and the the design is defined in a poped database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_power(
  poped.db,
  bpop_idx,
  h0 = 0,
  alpha = 0.05,
  power = 0.8,
  twoSided = TRUE,
  find_min_n = TRUE,
  fim = NULL,
  out = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_power_+3A_poped.db">poped.db</code></td>
<td>
<p>A poped database</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_bpop_idx">bpop_idx</code></td>
<td>
<p>Index for an unfixed population parameter (bpop) for 
which the power should be
evaluated for being different than the null hypothesis (h0).</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_h0">h0</code></td>
<td>
<p>The null hypothesized value for the parameter.</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_alpha">alpha</code></td>
<td>
<p>Type 1 error.</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_power">power</code></td>
<td>
<p>Targeted power.</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_twosided">twoSided</code></td>
<td>
<p>Is this a two-sided test.</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_find_min_n">find_min_n</code></td>
<td>
<p>Should the function compute the minimum n needed (given the
current design) to achieve the desired power?</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_fim">fim</code></td>
<td>
<p>Provide the FIM from a previous calculation</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_out">out</code></td>
<td>
<p>provide output from a previous calculation (e.g.,
calc_ofv_and_fim, ...)</p>
</td></tr>
<tr><td><code id="evaluate_power_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a></code> and
<code><a href="#topic+get_rse">get_rse</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements evaluating the current design including the power.
</p>


<h3>References</h3>

 <ol>
<li><p> Retout, S., Comets, E., Samson, A., and Mentre,
F. (2007). Design in nonlinear mixed effects models: Optimization using the
Fedorov-Wynn algorithm and power of the Wald test for binary covariates.
Statistics in Medicine, 26(28), 5162-5179.
<a href="https://doi.org/10.1002/sim.2910">doi:10.1002/sim.2910</a>. </p>
</li>
<li><p> Ueckert, S., Hennig, S.,
Nyberg, J., Karlsson, M. O., and Hooker, A. C. (2013). Optimizing disease
progression study designs for drug effect discrimination. Journal of
Pharmacokinetics and Pharmacodynamics, 40(5), 587-596.
<a href="https://doi.org/10.1007/s10928-013-9331-3">doi:10.1007/s10928-013-9331-3</a>. </p>
</li></ol>



<h3>See Also</h3>

<p>Other evaluate_design: 
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+evaluate_design">evaluate_design</a>()</code>,
<code><a href="#topic+get_rse">get_rse</a>()</code>,
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Folowing the examples presented in Retout, 2007

ff &lt;- function(model_switch,xt,parameters,poped.db){
  with(as.list(parameters),{
    
    lambda1 &lt;- lam1a
    if(TREAT==2) lambda1 &lt;- lam1b
    
    y=log10(P1*exp(-lambda1*xt)+P2*exp(-lam2*xt))
    
    return(list(y=y,poped.db=poped.db))
  })
}

sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(P1=exp(bpop[1]+b[1]),
               P2=exp(bpop[2]+b[2]),
               lam1a=exp(bpop[3]+b[3]),
               lam1b=exp(bpop[3]+bpop[4]+b[3]),
               lam2=exp(bpop[5]+b[4]),
               TREAT=a[1])
  return(parameters) 
}
  

poped.db &lt;- create.poped.database(ff_fun = ff,
                                  fg_fun = sfg,
                                  fError_fun = feps.add,
                                  bpop=c(P1=12, P2=8,
                                         lam1=-0.7,beta=0,lam2=-3.0),
                                  d=c(P1=0.3, P2=0.3,
                                      lam1=0.3,lam2=0.3), 
                                  sigma=c(0.065^2),
                                  groupsize=100,
                                  m=2,
                                  xt=c(1, 3, 7, 14, 28, 56),
                                  minxt=0,
                                  maxxt=100,
                                  a=list(c(TREAT=1),c(TREAT=2)))

plot_model_prediction(poped.db)
evaluate_design(poped.db)

poped.db_2 &lt;- create.poped.database(poped.db,bpop=c(P1=12, P2=8,
                                      lam1=-0.7,beta=0.262,lam2=-3.0))

plot_model_prediction(poped.db_2)
evaluate_design(poped.db_2)

evaluate_power(poped.db_2,bpop_idx = 4)
</code></pre>

<hr>
<h2 id='evaluate.e.ofv.fim'>Evaluate the expectation of the Fisher Information Matrix (FIM) and the expectation of the OFV(FIM).</h2><span id='topic+evaluate.e.ofv.fim'></span>

<h3>Description</h3>

<p>Compute the expectation of the FIM and OFV(FIM) given the model, parameters, distributions of parameter uncertainty, design and methods defined in the 
PopED database. Some of the arguments coming from the PopED database can be overwritten;  
by default these arguments are <code>NULL</code> in the 
function, if they are supplied then they are used instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate.e.ofv.fim(
  poped.db,
  fim.calc.type = NULL,
  bpop = poped.db$parameters$bpop,
  d = poped.db$parameters$d,
  covd = poped.db$parameters$covd,
  docc = poped.db$parameters$docc,
  sigma = poped.db$parameters$sigma,
  model_switch = NULL,
  ni = NULL,
  xt = NULL,
  x = NULL,
  a = NULL,
  groupsize = poped.db$design$groupsize,
  deriv.type = NULL,
  bLHS = poped.db$settings$bLHS,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  ED_samp_size = poped.db$settings$ED_samp_size,
  use_laplace = poped.db$settings$iEDCalculationType,
  laplace.fim = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate.e.ofv.fim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_covd">covd</code></td>
<td>
<p>Column major vector defining the covariances of the IIV variances. 
That is, from your full IIV matrix  <code>covd &lt;-  IIV[lower.tri(IIV)]</code>.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_deriv.type">deriv.type</code></td>
<td>
<p>A number indicating the type of derivative to use:
</p>

<ul>
<li><p> 0=Complex difference 
</p>
</li>
<li><p> 1=Central difference 
</p>
</li>
<li><p> 20=Analytic derivative (placeholder) 
</p>
</li>
<li><p> 30=Automatic differentiation (placeholder)
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_laplace.fim">laplace.fim</code></td>
<td>
<p>Should an E(FIM) be calculated when computing the Laplace approximated E(OFV).  Typically
the FIM does not need to be computed and, if desired,  this calculation
is done using the standard MC integration technique, so can be slow.</p>
</td></tr>
<tr><td><code id="evaluate.e.ofv.fim_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the E(FIM) and E(OFV(FIM)) and the a poped.db updated according  to the function arguments.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>
<p>Other E-family: 
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>
</p>
<p>Other evaluate_FIM: 
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error
## to avoid sample times at very low concentrations (time 0 or very late samoples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

# Adding 10% log-normal Uncertainty to fixed effects (not Favail)
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                         bpop_vals,
                         ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
bpop_vals_ed_ln

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=bpop_vals_ed_ln, 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70,
                                  mina=0,
                                  maxa=100)

############# END ###################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################


## ED evaluate (with very few samples)
output &lt;- evaluate.e.ofv.fim(poped.db,ED_samp_size=10)
output$E_ofv

## API evaluate (with very few samples)
output &lt;- evaluate.e.ofv.fim(poped.db,ED_samp_size=10,ofv_calc_type=4)
output$E_ofv

## ED evaluate using Laplace approximation 
tic()
output &lt;- evaluate.e.ofv.fim(poped.db,use_laplace=TRUE)
toc()
output$E_ofv

## Not run: 

  ## ED expected value with more precision. 
  ## Compare time and value to Laplace approximation.
  ## Run a couple of times to see stochasticity of calculation.
  tic()
  e_ofv_mc &lt;- evaluate.e.ofv.fim(poped.db,ED_samp_size=500)
  toc()
  e_ofv_mc$E_ofv
  
  # If you want to get an E(FIM) from the laplace approximation you have to ask for it
  # and it will take more time.
  output &lt;- evaluate.e.ofv.fim(poped.db,use_laplace=TRUE,laplace.fim=TRUE)
  output$E_fim
  
 


## End(Not run)
</code></pre>

<hr>
<h2 id='evaluate.fim'>Evaluate the Fisher Information Matrix (FIM)</h2><span id='topic+evaluate.fim'></span>

<h3>Description</h3>

<p>Compute the FIM given the model, parameters, design and methods defined in the 
PopED database. Some of the arguments coming from the PopED database can be overwritten;  
by default these arguments are <code>NULL</code> in the 
function, if they are supplied then they are used instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate.fim(
  poped.db,
  fim.calc.type = NULL,
  approx.method = NULL,
  FOCE.num = NULL,
  bpop.val = NULL,
  d_full = NULL,
  docc_full = NULL,
  sigma_full = NULL,
  model_switch = NULL,
  ni = NULL,
  xt = NULL,
  x = NULL,
  a = NULL,
  groupsize = NULL,
  deriv.type = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate.fim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_approx.method">approx.method</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_foce.num">FOCE.num</code></td>
<td>
<p>Number individuals in each step of FOCE approximation method</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_bpop.val">bpop.val</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_d_full">d_full</code></td>
<td>
<p>A between subject variability matrix (OMEGA in NONMEM).</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_docc_full">docc_full</code></td>
<td>
<p>A between occasion variability matrix.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_sigma_full">sigma_full</code></td>
<td>
<p>A residual unexplained variability matrix (SIGMA in NONMEM).</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_deriv.type">deriv.type</code></td>
<td>
<p>A number indicating the type of derivative to use:
</p>

<ul>
<li><p> 0=Complex difference 
</p>
</li>
<li><p> 1=Central difference 
</p>
</li>
<li><p> 20=Analytic derivative (placeholder) 
</p>
</li>
<li><p> 30=Automatic differentiation (placeholder)
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate.fim_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The FIM.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>
<p>Other evaluate_design: 
<code><a href="#topic+evaluate_design">evaluate_design</a>()</code>,
<code><a href="#topic+evaluate_power">evaluate_power</a>()</code>,
<code><a href="#topic+get_rse">get_rse</a>()</code>,
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>
<p>Other evaluate_FIM: 
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
    return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun = ff.PK.1.comp.oral.sd.CL,
                                  fg_fun = sfg,
                                  fError_fun = feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  # notfixed_bpop=c(1,1,1,0),
                                  notfixed_bpop=c(CL=1,V=1,KA=1,Favail=0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=0.01,
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70)


## evaluate initial design with the reduced FIM
FIM.1 &lt;- evaluate.fim(poped.db) 
FIM.1
det(FIM.1)
det(FIM.1)^(1/7)
get_rse(FIM.1,poped.db)

## evaluate initial design with the full FIM
FIM.0 &lt;- evaluate.fim(poped.db,fim.calc.type=0) 
FIM.0
det(FIM.0)
det(FIM.0)^(1/7)
get_rse(FIM.0,poped.db)

## evaluate initial design with the reduced FIM 
## computing all derivatives with respect to the 
## standard deviation of the residual unexplained variation 
FIM.4 &lt;- evaluate.fim(poped.db,fim.calc.type=4) 
FIM.4
det(FIM.4)
get_rse(FIM.4,poped.db,fim.calc.type=4)

## evaluate initial design with the full FIM with A,B,C matricies
## should give same answer as fim.calc.type=0
FIM.5 &lt;- evaluate.fim(poped.db,fim.calc.type=5) 
FIM.5
det(FIM.5)
get_rse(FIM.5,poped.db,fim.calc.type=5)

## evaluate initial design with the reduced FIM with 
## A,B,C matricies and derivative of variance
## should give same answer as fim.calc.type=1 (default)
FIM.7 &lt;- evaluate.fim(poped.db,fim.calc.type=7) 
FIM.7
det(FIM.7)
get_rse(FIM.7,poped.db,fim.calc.type=7)

## evaluate FIM and rse with prior FIM.1
poped.db.prior = create.poped.database(poped.db, prior_fim = FIM.1)
FIM.1.prior &lt;- evaluate.fim(poped.db.prior)
all.equal(FIM.1.prior,FIM.1) # the FIM is only computed from the design in the poped.db
get_rse(FIM.1.prior,poped.db.prior) # the RSE is computed with the prior information
</code></pre>

<hr>
<h2 id='extract_norm_group_fim'>Extract a normalized group FIM</h2><span id='topic+extract_norm_group_fim'></span>

<h3>Description</h3>

<p>Extract an individual FIM for each group in a design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_norm_group_fim(poped.db, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_norm_group_fim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
<tr><td><code id="extract_norm_group_fim_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of FIMs, one for each group in a design.
</p>

<hr>
<h2 id='feps.add'>RUV model:  
Additive .</h2><span id='topic+feps.add'></span>

<h3>Description</h3>

<p>This is a residual unexplained variability (RUV) model function that encodes the model described above.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>fError_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feps.add(model_switch, xt, parameters, epsi, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feps.add_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="feps.add_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="feps.add_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="feps.add_+3A_epsi">epsi</code></td>
<td>
<p>A matrix with the same number of rows as the <code>xt</code> vector, columns match the numbers defined in this 
function.</p>
</td></tr>
<tr><td><code id="feps.add_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other RUV_models: 
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.KE

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(KE=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.KE,
                                  fg_fun=sfg,
                                  fError_fun=feps.add,
                                  bpop=c(KE=0.15/8, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(KE=0.07, V=0.02, KA=0.6), 
                                  sigma=1,
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70)

##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='feps.add.prop'>RUV model:  
Additive and Proportional.</h2><span id='topic+feps.add.prop'></span>

<h3>Description</h3>

<p>This is a residual unexplained variability (RUV) model function that encodes the model described above.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>fError_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feps.add.prop(model_switch, xt, parameters, epsi, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feps.add.prop_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="feps.add.prop_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="feps.add.prop_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="feps.add.prop_+3A_epsi">epsi</code></td>
<td>
<p>A matrix with the same number of rows as the <code>xt</code> vector, columns match the numbers defined in this 
function.</p>
</td></tr>
<tr><td><code id="feps.add.prop_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other RUV_models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

## find the parameters that are needed to define in the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]),
                CL=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU=a[2])
  return( parameters ) 
}

## -- Define design and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.md.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  groupsize=20,
                                  m=2,
                                  sigma=c(0.04,5e-6),
                                  bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9), 
                                  d=c(V=0.09,KA=0.09,CL=0.25^2), 
                                  notfixed_bpop=c(1,1,1,0),
                                  notfixed_sigma=c(0,0),
                                  xt=c( 1,2,8,240,245),
                                  minxt=c(0,0,0,240,240),
                                  maxxt=c(10,10,10,248,248),
                                  a=cbind(c(20,40),c(24,24)),
                                  bUseGrouped_xt=1,
                                  maxa=c(200,24),
                                  mina=c(0,24))

##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='feps.prop'>RUV model:  
Proportional.</h2><span id='topic+feps.prop'></span>

<h3>Description</h3>

<p>This is a residual unexplained variability (RUV) model function that encodes the model described above.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>fError_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feps.prop(model_switch, xt, parameters, epsi, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feps.prop_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="feps.prop_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="feps.prop_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="feps.prop_+3A_epsi">epsi</code></td>
<td>
<p>A matrix with the same number of rows as the <code>xt</code> vector, columns match the numbers defined in this 
function.</p>
</td></tr>
<tr><td><code id="feps.prop_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other RUV_models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################


##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='feval'>MATLAB feval function</h2><span id='topic+feval'></span>

<h3>Description</h3>

<p>This is just a wrapper for the <code><a href="base.html#topic+do.call">do.call</a></code> function to behave like the feval function in MATLAB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feval(file.name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feval_+3A_file.name">file.name</code></td>
<td>
<p>A function or a string that is the name of a function.</p>
</td></tr>
<tr><td><code id="feval_+3A_...">...</code></td>
<td>
<p>Arguments for the function.  Multiple arguments separated by a comma.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from the defined function.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
feval("sin",pi/2)

</code></pre>

<hr>
<h2 id='ff.PK.1.comp.oral.md.CL'>Structural model: one-compartment, oral absorption, multiple bolus dose, parameterized using CL.</h2><span id='topic+ff.PK.1.comp.oral.md.CL'></span>

<h3>Description</h3>

<p>This is a structural model function that encodes a  model that is 
one-compartment, oral absorption, multiple bolus dose, parameterized using CL.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>ff_fun</code> or <code>ff_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.PK.1.comp.oral.md.CL(model_switch, xt, parameters, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.PK.1.comp.oral.md.CL_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.md.CL_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.md.CL_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.md.CL_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other structural_models: 
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

## find the parameters that are needed to define in the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]),
                CL=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU=a[2])
  return( parameters ) 
}

## -- Define design and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.md.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  groupsize=20,
                                  m=2,
                                  sigma=c(0.04,5e-6),
                                  bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9), 
                                  d=c(V=0.09,KA=0.09,CL=0.25^2), 
                                  notfixed_bpop=c(1,1,1,0),
                                  notfixed_sigma=c(0,0),
                                  xt=c( 1,2,8,240,245),
                                  minxt=c(0,0,0,240,240),
                                  maxxt=c(10,10,10,248,248),
                                  a=cbind(c(20,40),c(24,24)),
                                  bUseGrouped_xt=1,
                                  maxa=c(200,24),
                                  mina=c(0,24))

##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='ff.PK.1.comp.oral.md.KE'>Structural model: one-compartment, oral absorption, multiple bolus dose, parameterized using KE.</h2><span id='topic+ff.PK.1.comp.oral.md.KE'></span>

<h3>Description</h3>

<p>This is a structural model function that encodes a  model that is 
one-compartment, oral absorption, multiple bolus dose, parameterized using KE.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>ff_fun</code> or <code>ff_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.PK.1.comp.oral.md.KE(model_switch, xt, parameters, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.PK.1.comp.oral.md.KE_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.md.KE_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.md.KE_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.md.KE_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other structural_models: 
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

## find the parameters that are needed to define in the structural model
ff.PK.1.comp.oral.md.KE

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  ## -- parameter definition function 
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]), 
                KE=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU=a[2])
  return( parameters ) 
}

## -- Define design and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.md.KE,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  groupsize=20,
                                  m=2,
                                  sigma=c(0.04,5e-6),
                                  bpop=c(V=72.8,KA=0.25,KE=3.75/72.8,Favail=0.9), 
                                  d=c(V=0.09,KA=0.09,KE=0.25^2), 
                                  notfixed_bpop=c(1,1,1,0),
                                  notfixed_sigma=c(0,0),
                                  xt=c( 1,2,8,240,245),
                                  minxt=c(0,0,0,240,240),
                                  maxxt=c(10,10,10,248,248),
                                  a=cbind(c(20,40),c(24,24)),
                                  bUseGrouped_xt=1,
                                  maxa=c(200,40),
                                  mina=c(0,2))

##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='ff.PK.1.comp.oral.sd.CL'>Structural model: one-compartment, oral absorption, single bolus dose, parameterized using CL.</h2><span id='topic+ff.PK.1.comp.oral.sd.CL'></span>

<h3>Description</h3>

<p>This is a structural model function that encodes a  model that is 
one-compartment, oral absorption, single bolus dose, parameterized using CL.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>ff_fun</code> or <code>ff_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.PK.1.comp.oral.sd.CL(model_switch, xt, parameters, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.PK.1.comp.oral.sd.CL_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.sd.CL_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.sd.CL_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.sd.CL_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other structural_models: 
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################


##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='ff.PK.1.comp.oral.sd.KE'>Structural model: one-compartment, oral absorption, single bolus dose, parameterized using KE.</h2><span id='topic+ff.PK.1.comp.oral.sd.KE'></span>

<h3>Description</h3>

<p>This is a structural model function that encodes a  model that is 
one-compartment, oral absorption, single bolus dose, parameterized using KE.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>ff_fun</code> or <code>ff_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.PK.1.comp.oral.sd.KE(model_switch, xt, parameters, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.PK.1.comp.oral.sd.KE_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.sd.KE_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.sd.KE_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="ff.PK.1.comp.oral.sd.KE_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other structural_models: 
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.KE

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(KE=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.KE,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(KE=0.15/8, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(KE=0.07, V=0.02, KA=0.6), 
                                  sigma=0.01,
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70)

##  create plot of model without variability 
plot_model_prediction(poped.db)

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='ff.PKPD.1.comp.oral.md.CL.imax'>Structural model: one-compartment, oral absorption, multiple bolus dose, 
parameterized using CL driving an inhibitory IMAX model with a direct effect.</h2><span id='topic+ff.PKPD.1.comp.oral.md.CL.imax'></span>

<h3>Description</h3>

<p>This is a structural model function that encodes the model described above.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>ff_fun</code> or <code>ff_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.PKPD.1.comp.oral.md.CL.imax(model_switch, xt, parameters, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.PKPD.1.comp.oral.md.CL.imax_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="ff.PKPD.1.comp.oral.md.CL.imax_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="ff.PKPD.1.comp.oral.md.CL.imax_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="ff.PKPD.1.comp.oral.md.CL.imax_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>
<p>Other structural_models: 
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.sd.CL.emax">ff.PKPD.1.comp.sd.CL.emax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PopED)

## find the parameters that are needed to define from the structural model
ff.PKPD.1.comp.oral.md.CL.imax
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  ## -- parameter definition function 
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]),
                CL=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU = a[2],
                E0=bpop[5]*exp(b[4]),
                IMAX=bpop[6],
                IC50=bpop[7])
  return( parameters ) 
}



feps &lt;- function(model_switch,xt,parameters,epsi,poped.db){
  ## -- Residual Error function
  returnArgs &lt;- do.call(poped.db$model$ff_pointer,list(model_switch,xt,parameters,poped.db)) 
  y &lt;- returnArgs[[1]]
  poped.db &lt;- returnArgs[[2]]
  
  MS &lt;- model_switch
  
  pk.dv &lt;- y*(1+epsi[,1])+epsi[,2]
  pd.dv &lt;-  y*(1+epsi[,3])+epsi[,4]
  
  y[MS==1] = pk.dv[MS==1]
  y[MS==2] = pd.dv[MS==2]
  
  return(list( y= y,poped.db =poped.db )) 
}


## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PKPD.1.comp.oral.md.CL.imax,
                                  fError_fun=feps,
                                  fg_fun=sfg,
                                  groupsize=20,
                                  m=3,
                                  bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9,
                                         E0=1120,IMAX=0.807,IC50=0.0993),  
                                  notfixed_bpop=c(1,1,1,0,1,1,1),
                                  d=c(V=0.09,KA=0.09,CL=0.25^2,E0=0.09), 
                                  sigma=c(0.04,5e-6,0.09,100),
                                  notfixed_sigma=c(0,0,0,0),
                                  xt=c( 1,2,8,240,240,1,2,8,240,240),
                                  minxt=c(0,0,0,240,240,0,0,0,240,240),
                                  maxxt=c(10,10,10,248,248,10,10,10,248,248),
                                  G_xt=c(1,2,3,4,5,1,2,3,4,5),
                                  model_switch=c(1,1,1,1,1,2,2,2,2,2),
                                  a=cbind(c(20,40,0),c(24,24,24)),
                                  bUseGrouped_xt=1,
                                  ourzero=0,
                                  maxa=c(200,40),
                                  mina=c(0,2))


##  create plot of model without variability 
plot_model_prediction(poped.db,facet_scales="free")

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='ff.PKPD.1.comp.sd.CL.emax'>Structural model: one-compartment, single bolus IV dose, parameterized using CL driving an EMAX model with a direct effect.</h2><span id='topic+ff.PKPD.1.comp.sd.CL.emax'></span>

<h3>Description</h3>

<p>This is a structural model function that encodes the model described above.
The function is suitable for input to the <code><a href="#topic+create.poped.database">create.poped.database</a></code> function using the
<code>ff_fun</code> or <code>ff_file</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.PKPD.1.comp.sd.CL.emax(model_switch, xt, parameters, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.PKPD.1.comp.sd.CL.emax_+3A_model_switch">model_switch</code></td>
<td>
<p>a vector of values, the same size as <code>xt</code>, identifying which model 
response should be computed for the 
corresponding xt value.  Used for multiple response models.</p>
</td></tr>
<tr><td><code id="ff.PKPD.1.comp.sd.CL.emax_+3A_xt">xt</code></td>
<td>
<p>a vector of independent variable values (often time).</p>
</td></tr>
<tr><td><code id="ff.PKPD.1.comp.sd.CL.emax_+3A_parameters">parameters</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="ff.PKPD.1.comp.sd.CL.emax_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database.  This can be used to extract information that may be needed in the model file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>

<ol>
<li><p> y the values of the model at the specified points.
</p>
</li>
<li><p> poped.db A (potentially modified) poped database.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other models: 
<code><a href="#topic+feps.add">feps.add</a>()</code>,
<code><a href="#topic+feps.add.prop">feps.add.prop</a>()</code>,
<code><a href="#topic+feps.prop">feps.prop</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>
</p>
<p>Other structural_models: 
<code><a href="#topic+ff.PK.1.comp.oral.md.CL">ff.PK.1.comp.oral.md.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.md.KE">ff.PK.1.comp.oral.md.KE</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.CL">ff.PK.1.comp.oral.sd.CL</a>()</code>,
<code><a href="#topic+ff.PK.1.comp.oral.sd.KE">ff.PK.1.comp.oral.sd.KE</a>()</code>,
<code><a href="#topic+ff.PKPD.1.comp.oral.md.CL.imax">ff.PKPD.1.comp.oral.md.CL.imax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PopED)

## find the parameters that are needed to define from the structural model
ff.PKPD.1.comp.sd.CL.emax

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  ## -- parameter definition function
  parameters=c( 
    CL=bpop[1]*exp(b[1])  ,
    V=bpop[2]*exp(b[2])  ,
    E0=bpop[3]*exp(b[3])  ,
    EMAX=bpop[4]*exp(b[4])	,
    EC50=bpop[5]*exp(b[5])	,
    DOSE=a[1]
  )
  return( parameters ) 
}

feps &lt;- function(model_switch,xt,parameters,epsi,poped.db){
  ## -- Residual Error function
  ## -- Proportional PK + additive PD
  returnArgs &lt;- do.call(poped.db$model$ff_pointer,list(model_switch,xt,parameters,poped.db)) 
  y &lt;- returnArgs[[1]]
  poped.db &lt;- returnArgs[[2]]
  
  MS &lt;- model_switch
  
  prop.err &lt;- y*(1+epsi[,1])
  add.err &lt;- y+epsi[,2]
  
  y[MS==1] = prop.err[MS==1]
  y[MS==2] = add.err[MS==2]
  
  return(list( y= y,poped.db =poped.db )) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PKPD.1.comp.sd.CL.emax,
                                  fError_fun=feps,
                                  fg_fun=sfg,
                                  groupsize=20,
                                  m=3,
                                  sigma=diag(c(0.15,0.15)),
                                  bpop=c(CL=0.5,V=0.2,E0=1,EMAX=1,EC50=1),  
                                  d=c(CL=0.01,V=0.01,E0=0.01,EMAX=0.01,EC50=0.01), 
                                  xt=c( 0.33,0.66,0.9,5,0.1,1,2,5),
                                  model_switch=c( 1,1,1,1,2,2,2,2),
                                  minxt=0,
                                  maxxt=5,
                                  a=rbind(2.75,5,10),
                                  bUseGrouped_xt=1,
                                  maxa=10,
                                  mina=0.1)


##  create plot of model without variability 
plot_model_prediction(poped.db,facet_scales="free")

## evaluate initial design
FIM &lt;- evaluate.fim(poped.db) 
FIM
det(FIM)
get_rse(FIM,poped.db)

</code></pre>

<hr>
<h2 id='fileparts'>MATLAB fileparts function</h2><span id='topic+fileparts'></span>

<h3>Description</h3>

<p>Get the various parts of a file with path string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileparts(filename.with.path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fileparts_+3A_filename.with.path">filename.with.path</code></td>
<td>
<p>A string of a filename with a path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>pathname</code></td>
<td>
<p>The path name</p>
</td></tr>
<tr><td><code>filename</code></td>
<td>
<p>The file name</p>
</td></tr>
<tr><td><code>fileext</code></td>
<td>
<p>The file extension</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a modified version of the same function in the matlab R-package.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fileparts("ggg/ttt/lll.R")

</code></pre>

<hr>
<h2 id='get_all_params'>Extract all model parameters from the PopED database.</h2><span id='topic+get_all_params'></span>

<h3>Description</h3>

<p>Extract all model parameters from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_params(poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_all_params_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>bpop</code></td>
<td>
<p>A vector of fixed effect parameter values.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>A vector of between subject variability parameters</p>
</td></tr>
<tr><td><code>covd</code></td>
<td>
<p>A vector of the covariances of the between subject variability parameters.  Row major format of the lower triangular portion of the D (OMEGA) matrix</p>
</td></tr>
<tr><td><code>docc</code></td>
<td>
<p>A vector of the between occasion variability (BOV) terms in the model</p>
</td></tr>
<tr><td><code>covdocc</code></td>
<td>
<p>A vector of the covariances between the BOV terms.  Row major of the lower triangular portion of the BOV matrix. </p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>A vector of the residual unexplained variances (RUV)</p>
</td></tr>
<tr><td><code>covsigma</code></td>
<td>
<p>A vector of the covariances between the RUV terms</p>
</td></tr>
<tr><td><code>all</code></td>
<td>
<p>A vector with all of the above, in the order of this list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################


get_all_params(poped.db)


</code></pre>

<hr>
<h2 id='get_rse'>Compute the expected parameter relative standard errors</h2><span id='topic+get_rse'></span>

<h3>Description</h3>

<p>This function  computes the expected relative standard errors of a model given a design and a previously computed
FIM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rse(
  fim,
  poped.db,
  bpop = poped.db$parameters$bpop[, 2],
  d = poped.db$parameters$d[, 2],
  docc = poped.db$parameters$docc,
  sigma = poped.db$parameters$sigma,
  use_percent = TRUE,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  prior_fim = poped.db$settings$prior_fim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rse_+3A_fim">fim</code></td>
<td>
<p>A Fisher Information Matrix (FIM).</p>
</td></tr>
<tr><td><code id="get_rse_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="get_rse_+3A_bpop">bpop</code></td>
<td>
<p>A vector containing the values of the fixed effects used to compute the <code>fim</code>.</p>
</td></tr>
<tr><td><code id="get_rse_+3A_d">d</code></td>
<td>
<p>A vector containing the values of the diagonals of the between subject variability matrix.</p>
</td></tr>
<tr><td><code id="get_rse_+3A_docc">docc</code></td>
<td>
<p>Matrix defining the IOV, the IOV variances and the IOV distribution as for d and bpop.</p>
</td></tr>
<tr><td><code id="get_rse_+3A_sigma">sigma</code></td>
<td>
<p>Matrix defining the variances can covariances of the residual variability terms of the model.
can also just supply the diagonal parameter values (variances) as a <code>c()</code>.</p>
</td></tr>
<tr><td><code id="get_rse_+3A_use_percent">use_percent</code></td>
<td>
<p>Should RSE be reported as percent?</p>
</td></tr>
<tr><td><code id="get_rse_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_rse_+3A_prior_fim">prior_fim</code></td>
<td>
<p>A prior FIM to be added to the <code>fim</code>. Should be the same size as the <code>fim</code>.</p>
</td></tr>
<tr><td><code id="get_rse_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+inv">inv</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of RSE values.  If the estimated parameter is assumed to be zero then for that 
parameter the standard error is returned.
</p>


<h3>See Also</h3>

<p>Other evaluate_design: 
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+evaluate_design">evaluate_design</a>()</code>,
<code><a href="#topic+evaluate_power">evaluate_power</a>()</code>,
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
    return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun = ff.PK.1.comp.oral.sd.CL,
                                  fg_fun = sfg,
                                  fError_fun = feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  # notfixed_bpop=c(1,1,1,0),
                                  notfixed_bpop=c(CL=1,V=1,KA=1,Favail=0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=0.01,
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70)


## evaluate initial design with the reduced FIM
FIM.1 &lt;- evaluate.fim(poped.db) 
FIM.1
det(FIM.1)
det(FIM.1)^(1/7)
get_rse(FIM.1,poped.db)

## evaluate initial design with the full FIM
FIM.0 &lt;- evaluate.fim(poped.db,fim.calc.type=0) 
FIM.0
det(FIM.0)
det(FIM.0)^(1/7)
get_rse(FIM.0,poped.db)

## evaluate initial design with the reduced FIM 
## computing all derivatives with respect to the 
## standard deviation of the residual unexplained variation 
FIM.4 &lt;- evaluate.fim(poped.db,fim.calc.type=4) 
FIM.4
det(FIM.4)
get_rse(FIM.4,poped.db,fim.calc.type=4)

## evaluate initial design with the full FIM with A,B,C matricies
## should give same answer as fim.calc.type=0
FIM.5 &lt;- evaluate.fim(poped.db,fim.calc.type=5) 
FIM.5
det(FIM.5)
get_rse(FIM.5,poped.db,fim.calc.type=5)

## evaluate initial design with the reduced FIM with 
## A,B,C matricies and derivative of variance
## should give same answer as fim.calc.type=1 (default)
FIM.7 &lt;- evaluate.fim(poped.db,fim.calc.type=7) 
FIM.7
det(FIM.7)
get_rse(FIM.7,poped.db,fim.calc.type=7)

## evaluate FIM and rse with prior FIM.1
poped.db.prior = create.poped.database(poped.db, prior_fim = FIM.1)
FIM.1.prior &lt;- evaluate.fim(poped.db.prior)
all.equal(FIM.1.prior,FIM.1) # the FIM is only computed from the design in the poped.db
get_rse(FIM.1.prior,poped.db.prior) # the RSE is computed with the prior information
</code></pre>

<hr>
<h2 id='get_unfixed_params'>Return all the unfixed parameters</h2><span id='topic+get_unfixed_params'></span>

<h3>Description</h3>

<p>all = vector of all unfixed params var derivative is a vector of 1 and 0, 1
means derivative of parameter is taken w.r.t. variance otherwise w.r.t. sd If
params is supplied then the parameter is taken from this vector instead of
poped.db
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unfixed_params(poped.db, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_unfixed_params_+3A_poped.db">poped.db</code></td>
<td>
<p>a PopED database.</p>
</td></tr>
<tr><td><code id="get_unfixed_params_+3A_params">params</code></td>
<td>
<p>If params is supplied then the parameters are taken from this vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the  parameters.  All unfixed parameters are also
returned in the &quot;<code>all</code> output with the specified order 
(bpop,d,covd,docc,covdocc,sigma,covsigma). <code>var_derivative</code>  is a
vector of 1's or 0's, 1 means derivative of parameter is taken with respect
to the variance otherwise with respect to standard deviation.
</p>

<hr>
<h2 id='getfulld'>Create a full D (between subject variability) matrix given a vector of variances and covariances.
Note, this does not test matching vector lengths.</h2><span id='topic+getfulld'></span>

<h3>Description</h3>

<p>Create a full D (between subject variability) matrix given a vector of variances and covariances.
Note, this does not test matching vector lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getfulld(variance_vector, covariance_vector = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getfulld_+3A_variance_vector">variance_vector</code></td>
<td>
<p>The vector of the variances.</p>
</td></tr>
<tr><td><code id="getfulld_+3A_covariance_vector">covariance_vector</code></td>
<td>
<p>A vector of the covariances. Written in column major 
order for the lower triangular matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full matrix of variances for the between subject variances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getfulld(c(1,2,3))

getfulld(c(1,2,3),c(7,6,5))

</code></pre>

<hr>
<h2 id='getTruncatedNormal'>Generate a random sample from a truncated normal distribution.</h2><span id='topic+getTruncatedNormal'></span>

<h3>Description</h3>

<p>Generate a random sample from a truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTruncatedNormal(mean, variance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTruncatedNormal_+3A_mean">mean</code></td>
<td>
<p>the mean of the normal distribution</p>
</td></tr>
<tr><td><code id="getTruncatedNormal_+3A_variance">variance</code></td>
<td>
<p>The variance of the normal distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random sample from the specified truncated normal distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getTruncatedNormal(mean=3,variance=100)


</code></pre>

<hr>
<h2 id='gradf_eps'>Model linearization with respect to epsilon.</h2><span id='topic+gradf_eps'></span>

<h3>Description</h3>

<p>The function performs a linearization of the model with respect to the residual variability.
Derivative of model w.r.t. eps evaluated at eps=0 and b=b_ind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradf_eps(model_switch, xt_ind, x, a, bpop, b_ind, bocc_ind, num_eps, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradf_eps_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_xt_ind">xt_ind</code></td>
<td>
<p>A vector of the individual/group sample times</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_b_ind">b_ind</code></td>
<td>
<p>vector of individual realization of the BSV terms b</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_bocc_ind">bocc_ind</code></td>
<td>
<p>Vector of individual realizations of the BOV terms bocc</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_num_eps">num_eps</code></td>
<td>
<p>The number of <code>eps()</code> in the model.</p>
</td></tr>
<tr><td><code id="gradf_eps_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size (samples per individual x number of epsilons)
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


#for the FO approximation
ind=1
gradf_eps(model_switch=t(poped.db$design$model_switch[ind,,drop=FALSE]),
          xt_ind=t(poped.db$design$xt[ind,,drop=FALSE]),
          x=zeros(0,1),
          a=t(poped.db$design$a[ind,,drop=FALSE]),
          bpop=poped.db$parameters$bpop[,2,drop=FALSE],
          b_ind=zeros(poped.db$parameters$NumRanEff,1),
          bocc_ind=zeros(poped.db$parameters$NumDocc,1),
          num_eps=size(poped.db$parameters$sigma,1),
          poped.db)["dfeps_de0"]
</code></pre>

<hr>
<h2 id='inv'>Compute the inverse of a matrix</h2><span id='topic+inv'></span>

<h3>Description</h3>

<p>Function computes the inverse of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv(mat, method = 1, tol = .Machine$double.eps, pseudo_on_fail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="inv_+3A_method">method</code></td>
<td>
<p>Which method to use. 1 is Cholesky <code>chol2inv(chol(mat)</code>, 
2 is using <code>solve(mat)</code> and 3 is the Moore-Penrose generalized inverse (pseudoinverse).</p>
</td></tr>
<tr><td><code id="inv_+3A_tol">tol</code></td>
<td>
<p>The tolerance at which we should identify a singular value as zero (used in pseudoinverse calculation).</p>
</td></tr>
<tr><td><code id="inv_+3A_pseudo_on_fail">pseudo_on_fail</code></td>
<td>
<p>If another method fails should the Moore-Penrose generalized inverse (pseudoinverse) be used?</p>
</td></tr>
<tr><td><code id="inv_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse matrix
</p>

<hr>
<h2 id='isempty'>Function written to match MATLAB's isempty function</h2><span id='topic+isempty'></span>

<h3>Description</h3>

<p>Function written to match MATLAB's isempty function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isempty(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isempty_+3A_...">...</code></td>
<td>
<p>arguments to pass to the function. Typically a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical. True if the passed object has any dimension that is zero.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
isempty(zeros(2,3))

isempty(zeros(2,0))

isempty(c(1,2,3))

</code></pre>

<hr>
<h2 id='LEDoptim'>Optimization function for D-family, E-family and Laplace approximated ED designs</h2><span id='topic+LEDoptim'></span>

<h3>Description</h3>

<p>Optimize the objective function for D-family, E-family and Laplace approximated ED designs.  
Right now there is only one optimization algorithm used in this 
function 
</p>

<ol>
<li><p> Adaptive random search. See <code><a href="#topic+RS_opt">RS_opt</a></code>.
</p>
</li></ol>

<p>This function takes information from the PopED database supplied as an argument.
The PopED database supplies information about the the model, parameters, design and methods to use.
Some of the arguments coming from the PopED database can be overwritten;  
if they are supplied then they are used instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LEDoptim(
  poped.db,
  model_switch = NULL,
  ni = NULL,
  xt = NULL,
  x = NULL,
  a = NULL,
  bpopdescr = NULL,
  ddescr = NULL,
  maxxt = NULL,
  minxt = NULL,
  maxa = NULL,
  mina = NULL,
  ofv_init = 0,
  fim_init = 0,
  trflag = TRUE,
  header_flag = TRUE,
  footer_flag = TRUE,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  out_file = NULL,
  d_switch = FALSE,
  use_laplace = T,
  laplace.fim = FALSE,
  use_RS = poped.db$settings$bUseRandomSearch,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LEDoptim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="LEDoptim_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_ofv_init">ofv_init</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_fim_init">fim_init</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_header_flag">header_flag</code></td>
<td>
<p>Should the header text be printed out?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_footer_flag">footer_flag</code></td>
<td>
<p>Should the footer text be printed out?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_out_file">out_file</code></td>
<td>
<p>Which file should the output be directed to?  A string, a file handle using 
<code><a href="base.html#topic+file">file</a></code> or <code>""</code> will output to the screen.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_laplace.fim">laplace.fim</code></td>
<td>
<p>Should an E(FIM) be calculated when computing the Laplace approximated E(OFV).  Typically
the FIM does not need to be computed and, if desired,  this calculation
is done using the standard MC integration technique, so can be slow.</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_use_rs">use_RS</code></td>
<td>
<p>should the function use a random search algorithm?</p>
</td></tr>
<tr><td><code id="LEDoptim_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error
## to avoid sample times at very low concentrations (time 0 or very late samoples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

# Adding 10% log-normal Uncertainty to fixed effects (not Favail)
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                         bpop_vals,
                         ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
bpop_vals_ed_ln

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=bpop_vals_ed_ln, 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70,
                                  mina=0,
                                  maxa=100)

############# END ###################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################

# warfarin ed model

## Not run: 
  
  LEDoptim(poped.db) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE) 

  LEDoptim(poped.db,opt_xt=T,rsit=10,laplace.fim=TRUE) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,use_laplace=FALSE) 
  
  ## testing header and footer
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           out_file="foobar.txt") 
  
  ff &lt;- LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
                 trflag=FALSE) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           header_flag=FALSE) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           out_file="") 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           footer_flag=FALSE) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           footer_flag=FALSE, header_flag=FALSE) 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           footer_flag=FALSE, header_flag=FALSE,out_file="foobar.txt") 
  
  LEDoptim(poped.db,opt_xt=T,rsit=10,d_switch=TRUE,
           footer_flag=FALSE, header_flag=FALSE,out_file="") 


## End(Not run)
</code></pre>

<hr>
<h2 id='LinMatrixH'>Model linearization with respect to epsilon.</h2><span id='topic+LinMatrixH'></span>

<h3>Description</h3>

<p>The function performs a linearization of the model with respect to the residual variability.
Derivative of model w.r.t. eps evaluated at eps=0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinMatrixH(model_switch, xt_ind, x, a, bpop, b_ind, bocc_ind, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LinMatrixH_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_xt_ind">xt_ind</code></td>
<td>
<p>A vector of the individual/group sample times</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_b_ind">b_ind</code></td>
<td>
<p>vector of individual realization of the BSV terms b</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_bocc_ind">bocc_ind</code></td>
<td>
<p>Vector of individual realizations of the BOV terms bocc</p>
</td></tr>
<tr><td><code id="LinMatrixH_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size (samples per individual x number of epsilons)
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>

<hr>
<h2 id='LinMatrixL'>The linearized matrix L</h2><span id='topic+LinMatrixL'></span>

<h3>Description</h3>

<p>Function computes the derivative of the model with respect to the between subject variability 
terms in the model (b's and bocc's) evaluated at
a defined point 
(b_ind and bocc_ind).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinMatrixL(model_switch, xt_ind, x, a, bpop, b_ind, bocc_ind, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LinMatrixL_+3A_model_switch">model_switch</code></td>
<td>
<p>A vector that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="LinMatrixL_+3A_x">x</code></td>
<td>
<p>A vector for the discrete design variables.</p>
</td></tr>
<tr><td><code id="LinMatrixL_+3A_a">a</code></td>
<td>
<p>A vector of covariates.</p>
</td></tr>
<tr><td><code id="LinMatrixL_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="LinMatrixL_+3A_b_ind">b_ind</code></td>
<td>
<p>The point at which to evaluate the derivative</p>
</td></tr>
<tr><td><code id="LinMatrixL_+3A_bocc_ind">bocc_ind</code></td>
<td>
<p>The point at which to evaluate the derivative</p>
</td></tr>
<tr><td><code id="LinMatrixL_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a list:
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>A matrix of size (samples per individual x number of random effects)</p>
</td></tr>
<tr><td><code>poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


#for the FO approximation
ind=1
LinMatrixL(model_switch=t(poped.db$design$model_switch[ind,,drop=FALSE]),
          xt_ind=t(poped.db$design$xt[ind,,drop=FALSE]),
          x=zeros(0,1),
          a=t(poped.db$design$a[ind,,drop=FALSE]),
          bpop=poped.db$parameters$bpop[,2,drop=FALSE],
          b_ind=zeros(poped.db$parameters$NumRanEff,1),
          bocc_ind=zeros(poped.db$parameters$NumDocc,1),
          poped.db)["y"]

</code></pre>

<hr>
<h2 id='LinMatrixL_occ'>Model linearization with respect to occasion variability parameters.</h2><span id='topic+LinMatrixL_occ'></span>

<h3>Description</h3>

<p>The function performs a linearization of the model with respect to the occasion  variability parameter..
Derivative of model w.r.t. eta_occ, evaluated bocc_ind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinMatrixL_occ(
  model_switch,
  xt_ind,
  x,
  a,
  bpop,
  b_ind,
  bocc_ind,
  iCurrentOcc,
  poped.db
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LinMatrixL_occ_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_xt_ind">xt_ind</code></td>
<td>
<p>A vector of the individual/group sample times</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_b_ind">b_ind</code></td>
<td>
<p>vector of individual realization of the BSV terms b</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_bocc_ind">bocc_ind</code></td>
<td>
<p>Vector of individual realizations of the BOV terms bocc</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_icurrentocc">iCurrentOcc</code></td>
<td>
<p>The current occasion.</p>
</td></tr>
<tr><td><code id="LinMatrixL_occ_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size (samples per individual x number of iovs)
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


#for the FO approximation
ind=1

# no occasion defined in this example, so result is zero
LinMatrixL_occ(model_switch=t(poped.db$design$model_switch[ind,,drop=FALSE]),
          xt_ind=t(poped.db$design$xt[ind,,drop=FALSE]),
          x=zeros(0,1),
          a=t(poped.db$design$a[ind,,drop=FALSE]),
          bpop=poped.db$parameters$bpop[,2,drop=FALSE],
          b_ind=zeros(poped.db$parameters$NumRanEff,1),
          bocc_ind=zeros(poped.db$parameters$NumDocc,1),
          iCurrentOcc=1,
          poped.db)["y"]

</code></pre>

<hr>
<h2 id='LinMatrixLH'>Model linearization with respect to epsilon and eta.</h2><span id='topic+LinMatrixLH'></span>

<h3>Description</h3>

<p>The function performs a linearization of the model with respect to the residual variability and 
then the between subject variability.
Derivative of model w.r.t. eps then eta, evaluated at eps=0 and b=b_ind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinMatrixLH(
  model_switch,
  xt_ind,
  x,
  a,
  bpop,
  b_ind,
  bocc_ind,
  NumEPS,
  poped.db
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LinMatrixLH_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_xt_ind">xt_ind</code></td>
<td>
<p>A vector of the individual/group sample times</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_b_ind">b_ind</code></td>
<td>
<p>vector of individual realization of the BSV terms b</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_bocc_ind">bocc_ind</code></td>
<td>
<p>Vector of individual realizations of the BOV terms bocc</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_numeps">NumEPS</code></td>
<td>
<p>The number of eps() terms in the model.</p>
</td></tr>
<tr><td><code id="LinMatrixLH_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size (samples per individual x (number of sigma x number of omega))
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


#for the FOI approximation
ind=1
poped.db$settings$iApproximationMethod=3 # FOI approximation method

LinMatrixLH(model_switch=t(poped.db$design$model_switch[ind,,drop=FALSE]),
          xt_ind=t(poped.db$design$xt[ind,,drop=FALSE]),
          x=zeros(0,1),
          a=t(poped.db$design$a[ind,,drop=FALSE]),
          bpop=poped.db$parameters$bpop[,2,drop=FALSE],
          b_ind=zeros(poped.db$parameters$NumRanEff,1),
          bocc_ind=zeros(poped.db$parameters$NumDocc,1),
          NumEPS=size(poped.db$parameters$sigma,1),
          poped.db)["y"]

  
</code></pre>

<hr>
<h2 id='log_prior_pdf'>Compute the natural log of the PDF for the parameters in an E-family design</h2><span id='topic+log_prior_pdf'></span>

<h3>Description</h3>

<p>Compute the natural log of the PDF for the parameters in an E-family design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_prior_pdf(
  alpha,
  bpopdescr,
  ddescr,
  return_gradient = F,
  return_hessian = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_prior_pdf_+3A_alpha">alpha</code></td>
<td>
<p>A parameter vector.</p>
</td></tr>
<tr><td><code id="log_prior_pdf_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="log_prior_pdf_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="log_prior_pdf_+3A_return_gradient">return_gradient</code></td>
<td>
<p>Should the gradient be returned.</p>
</td></tr>
<tr><td><code id="log_prior_pdf_+3A_return_hessian">return_hessian</code></td>
<td>
<p>Should the hessian be returned?</p>
</td></tr>
</table>

<hr>
<h2 id='mc_mean'>Compute the monte-carlo mean of a function</h2><span id='topic+mc_mean'></span>

<h3>Description</h3>

<p>Function computes the monte-carlo mean of a function by varying the parameter inputs to the function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_mean(
  ofv_fcn,
  poped.db,
  bpopdescr = poped.db$parameters$bpop,
  ddescr = poped.db$parameters$d,
  doccdescr = poped.db$parameters$d,
  user_distribution_pointer = poped.db$model$user_distribution_pointer,
  ED_samp_size = poped.db$settings$ED_samp_size,
  bLHS = poped.db$settings$bLHS,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc_mean_+3A_ofv_fcn">ofv_fcn</code></td>
<td>
<p>A function with poped.db as the first input</p>
</td></tr>
<tr><td><code id="mc_mean_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="mc_mean_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="mc_mean_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="mc_mean_+3A_doccdescr">doccdescr</code></td>
<td>
<p>Matrix defining the IOV.
per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean of the variance.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_mean_+3A_user_distribution_pointer">user_distribution_pointer</code></td>
<td>
<p>Function name for user defined distributions for E-family designs</p>
</td></tr>
<tr><td><code id="mc_mean_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="mc_mean_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="mc_mean_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of the function evaluated at different parameter values.
</p>

<hr>
<h2 id='median_hilow_poped'>Wrap summary functions from Hmisc and ggplot to work with stat_summary in ggplot</h2><span id='topic+median_hilow_poped'></span>

<h3>Description</h3>

<p>Created for back compatibility with older versions of ggplot, and so that 
PopED does not have to load ggplot when started.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_hilow_poped(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="median_hilow_poped_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="median_hilow_poped_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to Hmisc's smedian.hilow function or 
ggplot2's median_hilow function, depending on your version of ggplot.</p>
</td></tr>
</table>

<hr>
<h2 id='mf3'>The Fisher Information Matrix (FIM) for one individual</h2><span id='topic+mf3'></span>

<h3>Description</h3>

<p>Compute the FIM for one individual given specific model(s), parameters, design and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mf3(model_switch, xt, x, a, bpop, d, sigma, docc, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mf3_+3A_model_switch">model_switch</code></td>
<td>
<p>A vector that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="mf3_+3A_xt">xt</code></td>
<td>
<p>A vector of sample times.</p>
</td></tr>
<tr><td><code id="mf3_+3A_x">x</code></td>
<td>
<p>A vector for the discrete design variables.</p>
</td></tr>
<tr><td><code id="mf3_+3A_a">a</code></td>
<td>
<p>A vector of covariates.</p>
</td></tr>
<tr><td><code id="mf3_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="mf3_+3A_d">d</code></td>
<td>
<p>A between subject variability matrix (OMEGA in NONMEM).</p>
</td></tr>
<tr><td><code id="mf3_+3A_sigma">sigma</code></td>
<td>
<p>A residual unexplained variability matrix (SIGMA in NONMEM).</p>
</td></tr>
<tr><td><code id="mf3_+3A_docc">docc</code></td>
<td>
<p>A between occasion variability matrix.</p>
</td></tr>
<tr><td><code id="mf3_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a list:
</p>
<table role = "presentation">
<tr><td><code>ret</code></td>
<td>
<p>The FIM for one individual</p>
</td></tr>
<tr><td><code>poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>

<hr>
<h2 id='mf7'>The full Fisher Information Matrix (FIM) for one individual Calculating one model switch at a time, good for large matrices.</h2><span id='topic+mf7'></span>

<h3>Description</h3>

<p>Compute the full FIM for one individual given specific model(s), parameters, design and methods. 
This computation calculates the FIM for each model switch separately.  Correlations between the models parameters are assumed to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mf7(model_switch, xt_ind, x, a, bpop, d, sigma, docc, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mf7_+3A_model_switch">model_switch</code></td>
<td>
<p>A vector that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="mf7_+3A_x">x</code></td>
<td>
<p>A vector for the discrete design variables.</p>
</td></tr>
<tr><td><code id="mf7_+3A_a">a</code></td>
<td>
<p>A vector of covariates.</p>
</td></tr>
<tr><td><code id="mf7_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="mf7_+3A_d">d</code></td>
<td>
<p>A between subject variability matrix (OMEGA in NONMEM).</p>
</td></tr>
<tr><td><code id="mf7_+3A_sigma">sigma</code></td>
<td>
<p>A residual unexplained variability matrix (SIGMA in NONMEM).</p>
</td></tr>
<tr><td><code id="mf7_+3A_docc">docc</code></td>
<td>
<p>A between occasion variability matrix.</p>
</td></tr>
<tr><td><code id="mf7_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a list:
</p>
<table role = "presentation">
<tr><td><code>ret</code></td>
<td>
<p>The FIM for one individual</p>
</td></tr>
<tr><td><code>poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>

<hr>
<h2 id='mfea'>Modified Fedorov Exchange Algorithm</h2><span id='topic+mfea'></span>

<h3>Description</h3>

<p>Optimize the objective function using a modified Fedorov exchange algorithm.
The function works for continuous and discrete optimization variables.
This function takes information from the PopED database supplied as an argument.
The PopED database supplies information about the the model, parameters, design and methods to use.
Some of the arguments coming from the PopED database can be overwritten;  
if they are supplied then they are used instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfea(
  poped.db,
  model_switch,
  ni,
  xt,
  x,
  a,
  bpopdescr,
  ddescr,
  maxxt,
  minxt,
  maxa,
  mina,
  fmf,
  dmf,
  EAStepSize = poped.db$settings$EAStepSize,
  ourzero = poped.db$settings$ourzero,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  trflag = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mfea_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="mfea_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="mfea_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="mfea_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="mfea_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="mfea_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="mfea_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="mfea_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="mfea_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="mfea_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="mfea_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="mfea_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="mfea_+3A_fmf">fmf</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="mfea_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="mfea_+3A_eastepsize">EAStepSize</code></td>
<td>
<p>Exchange Algorithm StepSize</p>
</td></tr>
<tr><td><code id="mfea_+3A_ourzero">ourzero</code></td>
<td>
<p>Value to interpret as zero in design</p>
</td></tr>
<tr><td><code id="mfea_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="mfea_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="mfea_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="mfea_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="mfea_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>


<ol>
<li><p> J. Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. Hooker, &quot;PopED: An extended, 
parallelized, nonlinear mixed effects models optimal design tool&quot;,  
Computer Methods and Programs in Biomedicine, 108, 2012.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################

##############
# typically one will use poped_optimize 
# This then calls mfea 
##############

# optimization of covariate, with coarse grid
out_1 &lt;- poped_optimize(poped.db,opt_a=1,
                              bUseExchangeAlgorithm=1,
                              EAStepSize=25,out_file = "")


## Not run: 
  
  
  
  # MFEA optimization with only integer times allowed
  out_2 &lt;- poped_optimize(poped.db,opt_xt=1,
                                bUseExchangeAlgorithm=1,
                                EAStepSize=1)
  get_rse(out_2$fmf,out_2$poped.db)
  plot_model_prediction(out_2$poped.db)
  
  
  ##############
  # If you really want to you can use mfea dirtectly
  ##############
  dsl &lt;- downsizing_general_design(poped.db)
  
  output &lt;- mfea(poped.db,
                 model_switch=dsl$model_switch,
                 ni=dsl$ni,
                 xt=dsl$xt,
                 x=dsl$x,
                 a=dsl$a,
                 bpopdescr=dsl$bpop,
                 ddescr=dsl$d,
                 maxxt=dsl$maxxt,
                 minxt=dsl$minxt,
                 maxa=dsl$maxa,
                 mina=dsl$mina,
                 fmf=0,dmf=0,
                 EAStepSize=1,
                 opt_xt=1)
  
  

## End(Not run)


</code></pre>

<hr>
<h2 id='mftot'>Evaluate the Fisher Information Matrix (FIM)</h2><span id='topic+mftot'></span>

<h3>Description</h3>

<p>Compute the FIM given specific model(s), parameters, design and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mftot(
  model_switch,
  groupsize,
  ni,
  xt,
  x,
  a,
  bpop,
  d,
  sigma,
  docc,
  poped.db,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mftot_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="mftot_+3A_groupsize">groupsize</code></td>
<td>
<p>A vector of the number of individuals in each group.</p>
</td></tr>
<tr><td><code id="mftot_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="mftot_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="mftot_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="mftot_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="mftot_+3A_bpop">bpop</code></td>
<td>
<p>The fixed effects parameter values.  Supplied as a vector.</p>
</td></tr>
<tr><td><code id="mftot_+3A_d">d</code></td>
<td>
<p>A between subject variability matrix (OMEGA in NONMEM).</p>
</td></tr>
<tr><td><code id="mftot_+3A_sigma">sigma</code></td>
<td>
<p>A residual unexplained variability matrix (SIGMA in NONMEM).</p>
</td></tr>
<tr><td><code id="mftot_+3A_docc">docc</code></td>
<td>
<p>A between occasion variability matrix.</p>
</td></tr>
<tr><td><code id="mftot_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a list:
</p>
<table role = "presentation">
<tr><td><code>ret</code></td>
<td>
<p>The FIM</p>
</td></tr>
<tr><td><code>poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For an easier function to use, please see <code><a href="#topic+evaluate.fim">evaluate.fim</a></code>.
</p>
<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


mftot(model_switch=poped.db$design$model_switch,
      groupsize=poped.db$design$groupsize,
      ni=poped.db$design$ni,
      xt=poped.db$design$xt,
      x=poped.db$design$x,
      a=poped.db$design$a,
      bpop=poped.db$parameters$param.pt.val$bpop,
      d=poped.db$parameters$param.pt.val$d,
      sigma=poped.db$parameters$sigma,
      docc=poped.db$parameters$param.pt.val$docc,
      poped.db)["ret"]

</code></pre>

<hr>
<h2 id='model_prediction'>Model predictions</h2><span id='topic+model_prediction'></span>

<h3>Description</h3>

<p>Function generates a data frame of model predictions for the typical value in the population,
individual predictions and data predictions.  The function can also be used to generate datasets
without predictions using the design specified in the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_prediction(
  poped.db = NULL,
  design = list(xt = poped.db$design[["xt"]], groupsize = poped.db$design$groupsize, m =
    poped.db$design[["m"]], x = poped.db$design[["x"]], a = poped.db$design[["a"]], ni =
    poped.db$design$ni, model_switch = poped.db$design$model_switch),
  model = list(fg_pointer = poped.db$model$fg_pointer, ff_pointer =
    poped.db$model$ff_pointer, ferror_pointer = poped.db$model$ferror_pointer),
  parameters = list(docc = poped.db$parameters$docc, d = poped.db$parameters$d, bpop =
    poped.db$parameters$bpop, covd = poped.db$parameters$covd, covdocc =
    poped.db$parameters$covdocc, sigma = poped.db$parameters$sigma),
  IPRED = FALSE,
  DV = FALSE,
  dosing = NULL,
  predictions = NULL,
  filename = NULL,
  models_to_use = "all",
  model_num_points = NULL,
  model_minxt = NULL,
  model_maxxt = NULL,
  include_sample_times = T,
  groups_to_use = "all",
  include_a = TRUE,
  include_x = TRUE,
  manipulation = NULL,
  PI = FALSE,
  PI_conf_level = 0.95,
  PI_ln_dist = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_prediction_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database created by <code><a href="#topic+create.poped.database">create.poped.database</a></code>.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_design">design</code></td>
<td>
<p>A list that is passed as arguments to the function <code><a href="#topic+create_design">create_design</a></code> to create a design object.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_model">model</code></td>
<td>
<p>A list containing the model elements to use for the predictions</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_parameters">parameters</code></td>
<td>
<p>A list of parameters to use in the model predictions.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_ipred">IPRED</code></td>
<td>
<p>Should we simulate individual predictions?</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_dv">DV</code></td>
<td>
<p>should we simulate observations?</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_dosing">dosing</code></td>
<td>
<p>A list of lists that adds dosing records to the data frame (Each inner list corresponding to a group in the design).</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_predictions">predictions</code></td>
<td>
<p>Should the resulting data frame have predictions?  Either <code>TRUE</code> or <code>FALSE</code> 
or <code>NULL</code> in which case the function decides based on other arguments.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_filename">filename</code></td>
<td>
<p>A filename that the data frame should be written to in comma separate value (csv) format.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_models_to_use">models_to_use</code></td>
<td>
<p>Which model numbers should we use? 
Model numbers are defined in <code>design</code> below using <code>model_switch</code>. For an explanation see <code><a href="#topic+create_design">create_design</a></code>.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_model_num_points">model_num_points</code></td>
<td>
<p>How many extra observation rows should be created in the data frame for each group or individual 
per model.  If used then the points are placed evenly between <code>model_minxt</code> and <code>model_maxxt</code>. This option
is used by <code><a href="#topic+plot_model_prediction">plot_model_prediction</a></code> to simulate the response of the model on a finer grid then the defined design.
If <code>NULL</code> then only the input design is used.  Can be a single value or a vector the same length as the number of models.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_model_minxt">model_minxt</code></td>
<td>
<p>The minimum time value for extra observation rows indicated by <code>model_num_points</code>. 
A vector the same length as the number of models</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_model_maxxt">model_maxxt</code></td>
<td>
<p>The minimum time value for extra observation rows indicated by <code>model_num_points</code>. 
A vector the same length as the number of models</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_include_sample_times">include_sample_times</code></td>
<td>
<p>Should observations rows in the output data frame include the times indicated in the input design?</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_groups_to_use">groups_to_use</code></td>
<td>
<p>Which groups should we include in the output data frame?Allowed values are <code>"all"</code> or 
a vector of numbers indicating the groups to include, e.g. <code>c(1,3,6)</code>.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_include_a">include_a</code></td>
<td>
<p>Should we include the continuous design variables in the output?</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_include_x">include_x</code></td>
<td>
<p>Should we include the discrete design variables in the output?</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_manipulation">manipulation</code></td>
<td>
<p>A list of one or more <code><a href="base.html#topic+expression">expression</a></code> arguments.  Each expression is 
evaluated using the code <code>for(i in 1:length(manipulation)){df &lt;- within(df,{eval(manipulation[[i]])})}</code>. 
Can be used to transform 
or create new columns in the resulting data frame. Note that these transformations are created after any model predictions occur,
so transformations in columns having to do with input to model predictions  will not affect the predictions.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_pi">PI</code></td>
<td>
<p>Compute prediction intervals for the data given the model.  Predictions are based on first-order approximations to 
the model variance and a log-normality assumption of that variance (by default), if all predictions are positive, otherwise a 
normal distribution is assumed.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_pi_conf_level">PI_conf_level</code></td>
<td>
<p>The confidence level for the prediction interval computed.</p>
</td></tr>
<tr><td><code id="model_prediction_+3A_pi_ln_dist">PI_ln_dist</code></td>
<td>
<p>Should the PI calculation be done assuming log-normal or a normal distribution. TRUE is the default and
indicates a log-normal distribution. If any of the PRED values from the model are negative then a normal distribution is
assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing a design and (potentially) simulated data with some dense grid of samples and/or 
based on the input design.
</p>


<h3>See Also</h3>

<p>Other evaluate_design: 
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+evaluate_design">evaluate_design</a>()</code>,
<code><a href="#topic+evaluate_power">evaluate_power</a>()</code>,
<code><a href="#topic+get_rse">get_rse</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>
<p>Other Simulation: 
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
    return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=0.01,
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70)

## data frame with model predictions
df_1 &lt;- model_prediction(poped.db)
head(df_1,n=20)

##  data frame with variability 
df_2 &lt;- model_prediction(poped.db,DV=TRUE)
head(df_2,n=20)

## data frame with variability (only IPRED, no DV)
df_3 &lt;- model_prediction(poped.db,IPRED=TRUE)
head(df_3,n=20)

## data frame with model predictions, no continuous design variables in data frame
df_4 &lt;- model_prediction(poped.db,include_a = FALSE)
head(df_4,n=20)

## -- 2 groups
poped.db.2 &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                    fg_fun=sfg,
                                    fError_fun=feps.prop,
                                    bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                    notfixed_bpop=c(1,1,1,0),
                                    d=c(CL=0.07, V=0.02, KA=0.6), 
                                    sigma=0.01,
                                    groupsize=rbind(3,3),
                                    m=2,
                                    xt=c( 0.5,1,2,6,24,36,72,120),
                                    minxt=0,
                                    maxxt=120,
                                    a=rbind(70,50))

df_5 &lt;- model_prediction(poped.db.2,DV=TRUE)
head(df_5,n=20)

## without a poped database, just describing the design
## Useful for creating datasets for use in other software (like NONMEM)
design_1 &lt;- list(
  xt=c( 0.5,1,2,6,24,36,72,120),
  m=2,
  groupsize=3)

design_2 &lt;- list(
  xt=c( 0.5,1,2,6,24,36,72,120),
  m=2,
  groupsize=3,
  a=c(WT=70,AGE=50))

design_3 &lt;- list(
  xt=c( 0.5,1,2,6,24,36,72,120),
  m=2,
  groupsize=3,
  a=list(c(WT=70,AGE=50),c(AGE=45,WT=60)))

(df_6 &lt;- model_prediction(design=design_1))
(df_7 &lt;- model_prediction(design=design_2))
(df_8 &lt;- model_prediction(design=design_3))
(df_9 &lt;- model_prediction(design=design_3,DV=TRUE))

# generate random deviations in WT for each individual
df_10 &lt;- model_prediction(design=design_3,DV=TRUE,
                          manipulation=expression({for(id in unique(ID)) 
                              WT[ID==id] = rnorm(1,WT[ID==id],WT[ID==id]*0.1);id &lt;- NULL}))
head(df_10,n=20)

# generate random deviations in WT and AGE for each individual
df_11 &lt;- model_prediction(design=design_3,DV=TRUE,
                          manipulation=list(
                            expression(for(id in unique(ID)) 
                              WT[ID==id] = rnorm(1,WT[ID==id],WT[ID==id]*0.1)),
                            expression(for(id in unique(ID)) 
                              AGE[ID==id] = rnorm(1,AGE[ID==id],AGE[ID==id]*0.2)),
                            expression(id &lt;- NULL)
                          ))
head(df_10,n=20)

## create dosing rows 
dosing_1 &lt;- list(list(AMT=1000,RATE=NA,Time=0.5),list(AMT=3000,RATE=NA,Time=0.5))
dosing_2 &lt;- list(list(AMT=1000,RATE=NA,Time=0.5))
dosing_3 &lt;- list(list(AMT=1000,Time=0.5))
dosing_4 &lt;- list(list(AMT=c(1000,20),Time=c(0.5,10))) # multiple dosing


(df_12 &lt;- model_prediction(design=design_3,DV=TRUE,dosing=dosing_1))
(df_13 &lt;- model_prediction(design=design_3,DV=TRUE,dosing=dosing_2))
(df_14 &lt;- model_prediction(design=design_3,DV=TRUE,dosing=dosing_3))
(df_15 &lt;- model_prediction(design=design_3,DV=TRUE,dosing=dosing_4))


model_prediction(design=design_3,DV=TRUE,dosing=dosing_4,model_num_points = 10)
model_prediction(design=design_3,DV=TRUE,dosing=dosing_4,model_num_points = 10,model_minxt=20)

design_4 &lt;- list(
  xt=c( 0.5,1,2,6,24,36,72,120),
  model_switch=c(1,1,1,1,2,2,2,2),
  m=2,
  groupsize=3,
  a=list(c(WT=70,AGE=50),c(AGE=45,WT=60)))

model_prediction(design=design_4,DV=TRUE,dosing=dosing_4)
model_prediction(design=design_4,DV=TRUE,dosing=dosing_4,model_num_points = 10)
model_prediction(design=design_4,DV=TRUE,dosing=dosing_4,model_num_points = 10,
                 model_minxt=10,model_maxxt=100)
model_prediction(design=design_4,DV=TRUE,dosing=dosing_4,model_num_points = 10,
                 model_minxt=c(20,20),model_maxxt=c(100,100))
model_prediction(design=design_4,DV=TRUE,dosing=dosing_4,model_num_points = c(10,10),
                 model_minxt=c(20,20),model_maxxt=c(100,100))

</code></pre>

<hr>
<h2 id='ofv_criterion'>Normalize an objective function by the size of the FIM matrix</h2><span id='topic+ofv_criterion'></span>

<h3>Description</h3>

<p>Compute a normalized OFV based on the size of the FIM matrix.  This value can then be used in 
efficiency calculations. This is NOT the OFV used in optimization, see <code><a href="#topic+ofv_fim">ofv_fim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ofv_criterion(
  ofv_f,
  num_parameters,
  poped.db,
  ofv_calc_type = poped.db$settings$ofv_calc_type
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ofv_criterion_+3A_ofv_f">ofv_f</code></td>
<td>
<p>An objective function</p>
</td></tr>
<tr><td><code id="ofv_criterion_+3A_num_parameters">num_parameters</code></td>
<td>
<p>The number of parameters to use for normalization</p>
</td></tr>
<tr><td><code id="ofv_criterion_+3A_poped.db">poped.db</code></td>
<td>
<p>a poped database</p>
</td></tr>
<tr><td><code id="ofv_criterion_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The specified criterion value.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_fim">ofv_fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


## evaluate initial design 
FIM &lt;- evaluate.fim(poped.db) # new name for function needed
FIM
get_rse(FIM,poped.db)

ofv_criterion(ofv_fim(FIM,poped.db,ofv_calc_type=1),
              length(get_unfixed_params(poped.db)[["all"]]),
              poped.db,
              ofv_calc_type=1) # det(FIM)

ofv_criterion(ofv_fim(FIM,poped.db,ofv_calc_type=2),
              length(get_unfixed_params(poped.db)[["all"]]),
              poped.db,
              ofv_calc_type=2) 

ofv_criterion(ofv_fim(FIM,poped.db,ofv_calc_type=4),
              length(get_unfixed_params(poped.db)[["all"]]),
              poped.db,
              ofv_calc_type=4)

ofv_criterion(ofv_fim(FIM,poped.db,ofv_calc_type=6),
              length(get_unfixed_params(poped.db)[["all"]]),
              poped.db,
              ofv_calc_type=6)

ofv_criterion(ofv_fim(FIM,poped.db,ofv_calc_type=7),
              length(get_unfixed_params(poped.db)[["all"]]),
              poped.db,
              ofv_calc_type=7) 

</code></pre>

<hr>
<h2 id='ofv_fim'>Evaluate a criterion of the Fisher Information Matrix (FIM)</h2><span id='topic+ofv_fim'></span>

<h3>Description</h3>

<p>Compute a criterion of the FIM given the model, parameters, design and methods defined in the 
PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ofv_fim(
  fmf,
  poped.db,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  ds_index = poped.db$parameters$ds_index,
  use_log = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ofv_fim_+3A_fmf">fmf</code></td>
<td>
<p>The FIM</p>
</td></tr>
<tr><td><code id="ofv_fim_+3A_poped.db">poped.db</code></td>
<td>
<p>A poped database</p>
</td></tr>
<tr><td><code id="ofv_fim_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="ofv_fim_+3A_ds_index">ds_index</code></td>
<td>
<p>Ds_index is a vector set to 1 if a parameter is uninteresting, otherwise 0.
size=(1,num unfixed parameters). First unfixed bpop, then unfixed d, then unfixed docc and last unfixed sigma. 
Default is the fixed effects being important, everything else not important.  Used in conjunction with
<code>ofv_calc_type=6</code>.</p>
</td></tr>
<tr><td><code id="ofv_fim_+3A_use_log">use_log</code></td>
<td>
<p>Should the criterion be in the log domain?</p>
</td></tr>
<tr><td><code id="ofv_fim_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The specified criterion value.
</p>


<h3>See Also</h3>

<p>Other FIM: 
<code><a href="#topic+LinMatrixH">LinMatrixH</a>()</code>,
<code><a href="#topic+LinMatrixLH">LinMatrixLH</a>()</code>,
<code><a href="#topic+LinMatrixL_occ">LinMatrixL_occ</a>()</code>,
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+ed_laplace_ofv">ed_laplace_ofv</a>()</code>,
<code><a href="#topic+ed_mftot">ed_mftot</a>()</code>,
<code><a href="#topic+efficiency">efficiency</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+gradf_eps">gradf_eps</a>()</code>,
<code><a href="#topic+mf3">mf3</a>()</code>,
<code><a href="#topic+mf7">mf7</a>()</code>,
<code><a href="#topic+mftot">mftot</a>()</code>,
<code><a href="#topic+ofv_criterion">ofv_criterion</a>()</code>
</p>
<p>Other evaluate_FIM: 
<code><a href="#topic+calc_ofv_and_fim">calc_ofv_and_fim</a>()</code>,
<code><a href="#topic+evaluate.e.ofv.fim">evaluate.e.ofv.fim</a>()</code>,
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


## evaluate initial design 
FIM &lt;- evaluate.fim(poped.db) 
FIM
get_rse(FIM,poped.db)

det(FIM)
ofv_fim(FIM,poped.db,ofv_calc_type=1) # det(FIM)
ofv_fim(FIM,poped.db,ofv_calc_type=2) # 1/trace_matrix(inv(FIM))
ofv_fim(FIM,poped.db,ofv_calc_type=4) # log(det(FIM)) 
ofv_fim(FIM,poped.db,ofv_calc_type=6) # Ds with fixed effects as "important"
ofv_fim(FIM,poped.db,ofv_calc_type=6,
        ds_index=c(1,1,1,0,0,0,1,1)) # Ds with random effects as "important"
ofv_fim(FIM,poped.db,ofv_calc_type=7) # 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))

</code></pre>

<hr>
<h2 id='ones'>Create a matrix of ones</h2><span id='topic+ones'></span>

<h3>Description</h3>

<p>Create a matrix of ones of size (dim1 x dim2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ones(dim1, dim2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ones_+3A_dim1">dim1</code></td>
<td>
<p>The dimension of the matrix (if square) or the number of rows.</p>
</td></tr>
<tr><td><code id="ones_+3A_dim2">dim2</code></td>
<td>
<p>The number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of ones
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ones(4)
ones(3,4)
</code></pre>

<hr>
<h2 id='optim_ARS'>Optimize a function using adaptive random search.</h2><span id='topic+optim_ARS'></span>

<h3>Description</h3>

<p>Optimize an objective function using an adaptive random search algorithm.  
The function works for both discrete and continuous optimization parameters 
and allows for box-constraints and sets of allowed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_ARS(
  par,
  fn,
  lower = NULL,
  upper = NULL,
  allowed_values = NULL,
  loc_fac = 4,
  no_bounds_sd = par,
  iter = 400,
  iter_adapt = 50,
  adapt_scale = 1,
  max_run = 200,
  trace = TRUE,
  trace_iter = 5,
  new_par_max_it = 200,
  maximize = F,
  parallel = F,
  parallel_type = NULL,
  num_cores = NULL,
  mrgsolve_model = NULL,
  seed = round(runif(1, 0, 1e+07)),
  allow_replicates = TRUE,
  replicates_index = seq(1, length(par)),
  generator = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optim_ARS_+3A_par">par</code></td>
<td>
<p>A vector of initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_fn">fn</code></td>
<td>
<p>A function to be minimized (or maximized), 
with first argument the vector of parameters over which minimization is to take place. 
It should return a scalar result.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_lower">lower</code></td>
<td>
<p>Lower bounds on the parameters. A vector.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_upper">upper</code></td>
<td>
<p>Upper bounds on the parameters. A vector.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_allowed_values">allowed_values</code></td>
<td>
<p>A list containing allowed values for each parameter <code>list(par1=c(2,3,4,5,6),par2=c(5,6,7,8))</code>. 
A vector containing allowed values for all parameters is also allowed <code>c(2,3,4,5,6)</code>.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_loc_fac">loc_fac</code></td>
<td>
<p>Locality factor for determining the standard deviation of the sampling distribution around the current
position of the parameters. The initial standard deviation is normally calculated as <code>(upper - lower)/loc_fac</code> 
except in cases when  there are no upper or lower limits (e.g. when <code>upper=Inf</code> or <code>lower=-Inf</code>).</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_no_bounds_sd">no_bounds_sd</code></td>
<td>
<p>The standard deviation of the sampling distribution around the current
position of the parameters when there are no upper or lower limits (e.g. when <code>upper=Inf</code> or <code>lower=-Inf</code>).</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_iter">iter</code></td>
<td>
<p>The number of iterations for the algorithm to perform (this is a maximum number, it could be less).</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_iter_adapt">iter_adapt</code></td>
<td>
<p>The number of iterations before adapting (shrinking) the parameter search space.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_adapt_scale">adapt_scale</code></td>
<td>
<p>The scale for adapting the size of the sampling distribution.  The adaptation of the 
standard deviation of the sampling distribution around the current
position of the parameters is done after <code>iter_adapt</code> iteration with no change in the best objective function.  
When adapting, the  standard deviation of the sampling distribution is calculated as 
<code>(upper - lower)/(loc_fac*ff*adapt_scale)</code> where ff starts at 1 and increases by 1 for each adaptation.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_max_run">max_run</code></td>
<td>
<p>The maximum number of iterations to run without a change in the best parameter estimates.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_trace">trace</code></td>
<td>
<p>Should the algorithm output results intermittently.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_trace_iter">trace_iter</code></td>
<td>
<p>How many iterations between each update to the screen about the result of the search.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_new_par_max_it">new_par_max_it</code></td>
<td>
<p>The algorithm randomly chooses samples based on the current best set of parameters.  If when drawing 
these samples the new parameter set has already been tested then a new draw is performed. After <code>new_par_max_it</code> draws, with
no new parameter sets, then the algorithm stops.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_maximize">maximize</code></td>
<td>
<p>Should the function be maximized?  Default is to minimize.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations?</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? 
Can be &quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows. &quot;multicore&quot; works only on 
Linux-like systems.  By default this is chosen for you depending on your operating system. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use in the parallelization.  By default  is set to the number 
output from 
<code>parallel::detectCores()</code>. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_mrgsolve_model">mrgsolve_model</code></td>
<td>
<p>If the computations require a mrgsolve model and you
are using the &quot;snow&quot; method then you need to specify the name of the model
object created by <code>mread</code> or <code>mcode</code>.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_seed">seed</code></td>
<td>
<p>The random seed to use in the algorithm,</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_allow_replicates">allow_replicates</code></td>
<td>
<p>Should the algorithm allow parameters to have the same value?</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_replicates_index">replicates_index</code></td>
<td>
<p>A vector, the same length as the parameters.
If two values are the same in this vector then the parameters may not assume the same value in the optimization.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_generator">generator</code></td>
<td>
<p>A user-defined function that generates new parameter sets to try in the algorithm.  See examples below.</p>
</td></tr>
<tr><td><code id="optim_ARS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code> and <code>start_parallel</code>.</p>
</td></tr>
</table>


<h3>References</h3>


<ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. Ruggeri, &quot;PopED, a software fir optimal 
experimental design in population kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004.
</p>
</li>
<li><p> J. Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. Hooker, &quot;PopED: An extended, 
parallelized, nonlinear mixed effects models optimal design tool&quot;,  
Computer Methods and Programs in Biomedicine, 108, 2012.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## "wild" function , global minimum at about -15.81515
fw &lt;- function(x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80

# optimization with fewer function evaluations compared to SANN
res1 &lt;- optim_ARS(50, fw,lower = -50, upper=100)

# often not as good performance when upper and lower bounds are poor
res2 &lt;- optim_ARS(50, fw, lower=-Inf,upper=Inf)

# Only integer values allowed
## Not run:  
res_int &lt;- optim_ARS(50, fw, allowed_values = seq(-50,100,by=1))

## End(Not run)

## Not run:  
  #plot of the function and solutions
  require(graphics)
  plot(fw, -50, 50, n = 1000, main = "Minimizing 'wild function'")
  points(-15.81515, fw(-15.81515), pch = 16, col = "red", cex = 1)
  points(res1$par, res1$ofv, pch = 16, col = "green", cex = 1)
  points(res2$par, res2$ofv, pch = 16, col = "blue", cex = 1)

## End(Not run) 

# optim_ARS does not work great for hard to find minima on flat surface:
# Rosenbrock Banana function
# f(x, y) = (a-x)^2 + b(y-x^2)^2
# global minimum at (x, y)=(a, a^2), where f(x, y)=0. 
# Usually a = 1 and b = 100.
## Not run:  
  fr &lt;- function(x,a=1,b=100) {   
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    b*(x2 - x1*x1)^2 + (a - x1)^2
  }
  
  res3 &lt;- optim_ARS(c(-1.2,1), fr,lower = -5, upper = 5)
  
  # plot the surface
  x &lt;- seq(-50, 50, length= 30)
  y &lt;- x
  f &lt;- function(x,y){apply(cbind(x,y),1,fr)}
  z &lt;- outer(x, y, f)
  persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue", ticktype="detailed") -&gt; res
  points(trans3d(1, 1, 0, pmat = res), col = 2, pch = 16,cex=2)
  points(trans3d(res3$par[1], res3$par[1], res3$ofv, pmat = res), col = "green", pch = 16,cex=2)

## End(Not run)

# box constraints
flb &lt;- function(x){
  p &lt;- length(x) 
  sum(c(1, rep(4, p-1)) * (x - c(1, x[-p])^2)^2) 
}
## 25-dimensional box constrained
#optim(rep(3, 25), flb,lower = rep(2, 25), upper = rep(4, 25),method = "L-BFGS-B") 
res_box &lt;- optim_ARS(rep(3, 25), flb,lower = rep(2, 25), upper = rep(4, 25)) 


## Combinatorial optimization: Traveling salesman problem
eurodistmat &lt;- as.matrix(eurodist)

distance &lt;- function(sq) {  # Target function
  sq2 &lt;- embed(sq, 2)
  sum(eurodistmat[cbind(sq2[,2], sq2[,1])])
}

genseq &lt;- function(sq) {  # Generate new candidate sequence
  idx &lt;- seq(2, NROW(eurodistmat)-1)
  changepoints &lt;- sample(idx, size = 2, replace = FALSE)
  tmp &lt;- sq[changepoints[1]]
  sq[changepoints[1]] &lt;- sq[changepoints[2]]
  sq[changepoints[2]] &lt;- tmp
  sq
}

sq &lt;- c(1:nrow(eurodistmat), 1)  # Initial sequence: alphabetic
res3 &lt;- optim_ARS(sq,distance,generator=genseq) # Near optimum distance around 12842

## Not run:  
  # plot of initial sequence
  # rotate for conventional orientation
  loc &lt;- -cmdscale(eurodist, add = TRUE)$points
  x &lt;- loc[,1]; y &lt;- loc[,2]
  s &lt;- seq_len(nrow(eurodistmat))
  tspinit &lt;- loc[sq,]
  
  plot(x, y, type = "n", asp = 1, xlab = "", ylab = "",
       main = paste("Initial sequence of traveling salesman problem\n",
                    "Distance =",distance(sq)), axes = FALSE)
  arrows(tspinit[s,1], tspinit[s,2], tspinit[s+1,1], tspinit[s+1,2],
         angle = 10, col = "green")
  text(x, y, labels(eurodist), cex = 0.8)
  
  # plot of final sequence from optim_ARS
  tspres &lt;- loc[res3$par,]
  plot(x, y, type = "n", asp = 1, xlab = "", ylab = "",
       main = paste("optim_ARS() 'solving' traveling salesman problem\n",
                    "Distance =",distance(c(1,res3$par,1))),axes = FALSE)
  arrows(tspres[s,1], tspres[s,2], tspres[s+1,1], tspres[s+1,2],
         angle = 10, col = "red")
  text(x, y, labels(eurodist), cex = 0.8)
  
  # using optim
  set.seed(123) # chosen to get a good soln relatively quickly
  (res4 &lt;- optim(sq, distance, genseq, method = "SANN",
                 control = list(maxit = 30000, temp = 2000, trace = TRUE,
                                REPORT = 500))) 
  
  tspres &lt;- loc[res4$par,]
  plot(x, y, type = "n", asp = 1, xlab = "", ylab = "",
       main = paste("optim() 'solving' traveling salesman problem\n",
                    "Distance =",distance(res4$par)),axes = FALSE)
  arrows(tspres[s,1], tspres[s,2], tspres[s+1,1], tspres[s+1,2],
         angle = 10, col = "red")
  text(x, y, labels(eurodist), cex = 0.8)

## End(Not run)  

# one-dimensional function
## Not run:  
  f &lt;- function(x)  abs(x)+cos(x)
  res5 &lt;- optim_ARS(-20,f,lower=-20, upper=20)
  
  curve(f, -20, 20)
  abline(v = res5$par, lty = 4,col="green")

## End(Not run)  

# one-dimensional function
f &lt;- function(x)  (x^2+x)*cos(x) # -10 &lt; x &lt; 10
res_max &lt;- optim_ARS(0,f,lower=-10, upper=10,maximize=TRUE) # sometimes to local maxima

## Not run:  
  res_min &lt;- optim_ARS(0,f,lower=-10, upper=10) # sometimes to local minima
  
  curve(f, -10, 10)
  abline(v = res_min$par, lty = 4,col="green")
  abline(v = res_max$par, lty = 4,col="red")

## End(Not run)


# two-dimensional Rastrigin function
#It has a global minimum at f(x) = f(0) = 0.
## Not run:  
  Rastrigin &lt;- function(x1, x2){
    20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
  }
  
  
  x1 &lt;- x2 &lt;- seq(-5.12, 5.12, by = 0.1)
  z &lt;- outer(x1, x2, Rastrigin)
  
  res6 &lt;- optim_ARS(c(-4,4),function(x) Rastrigin(x[1], x[2]),lower=-5.12, upper=5.12)
  
  # color scale
  nrz &lt;- nrow(z)
  ncz &lt;- ncol(z)
  jet.colors &lt;-
    colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                       "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
  # Generate the desired number of colors from this palette
  nbcol &lt;- 100
  color &lt;- jet.colors(nbcol)
  # Compute the z-value at the facet centres
  zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
  # Recode facet z-values into color indices
  facetcol &lt;- cut(zfacet, nbcol)
  persp(x1, x2, z, col = color[facetcol], phi = 30, theta = 30)
  filled.contour(x1, x2, z, color.palette = jet.colors)

## End(Not run)


## Parallel computation  
## works better when each evaluation takes longer
## here we have added extra time to the computations
## just to show that it works
## Not run:  
  res7 &lt;- optim_ARS(c(-4,4),function(x){Sys.sleep(0.01); Rastrigin(x[1], x[2])},
                    lower=-5.12, upper=5.12)
  res8 &lt;- optim_ARS(c(-4,4),function(x){Sys.sleep(0.01); Rastrigin(x[1], x[2])},
                    lower=-5.12, upper=5.12,parallel = T)
  res9 &lt;- optim_ARS(c(-4,4),function(x){Sys.sleep(0.01); Rastrigin(x[1], x[2])},
                    lower=-5.12, upper=5.12,parallel = T,parallel_type = "snow")

## End(Not run)
</code></pre>

<hr>
<h2 id='optim_LS'>Optimize a function using a line search algorithm.</h2><span id='topic+optim_LS'></span>

<h3>Description</h3>

<p><code>optim_LS</code> performs sequential grid search optimization of an arbitrary function with respect 
to each of the parameters to be optimized over. 
The function works for both discrete and continuous optimization parameters 
and allows for box-constraints (by using the upper and lower function arguments) or sets of allowed values (by using the 
allowed_values function argument) for all parameters, or on a parameter per parameter basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_LS(
  par,
  fn,
  lower = NULL,
  upper = NULL,
  allowed_values = NULL,
  line_length = 50,
  trace = TRUE,
  maximize = F,
  parallel = F,
  parallel_type = NULL,
  num_cores = NULL,
  mrgsolve_model = NULL,
  seed = round(runif(1, 0, 1e+07)),
  allow_replicates = TRUE,
  replicates_index = seq(1, length(par)),
  ofv_initial = NULL,
  closed_bounds = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optim_LS_+3A_par">par</code></td>
<td>
<p>A vector of initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_fn">fn</code></td>
<td>
<p>A function to be minimized (or maximized), 
with first argument the vector of parameters over which minimization is to take place. 
It should return a scalar result.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_lower">lower</code></td>
<td>
<p>Lower bounds on the parameters. A vector.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_upper">upper</code></td>
<td>
<p>Upper bounds on the parameters. A vector.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_allowed_values">allowed_values</code></td>
<td>
<p>A list containing allowed values for each parameter <code>list(par1=c(2,3,4,5,6),par2=c(5,6,7,8))</code>. 
A vector containing allowed values for all parameters is also allowed <code>c(2,3,4,5,6)</code>.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_line_length">line_length</code></td>
<td>
<p>The number of different parameter values per parameter to evaluate.  The values are 
selected as an evenly spaced grid between the upper and lower bounds.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_trace">trace</code></td>
<td>
<p>Should the algorithm output results intermittently.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_maximize">maximize</code></td>
<td>
<p>Should the function be maximized?  Default is to minimize.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations?</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? 
Can be &quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows. &quot;multicore&quot; works only on 
Linux-like systems.  By default this is chosen for you depending on your operating system. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use in the parallelization.  By default  is set to the number 
output from 
<code>parallel::detectCores()</code>. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_mrgsolve_model">mrgsolve_model</code></td>
<td>
<p>If the computations require a mrgsolve model and you
are using the &quot;snow&quot; method then you need to specify the name of the model
object created by <code>mread</code> or <code>mcode</code>.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_seed">seed</code></td>
<td>
<p>The random seed to use in the algorithm,</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_allow_replicates">allow_replicates</code></td>
<td>
<p>Should the algorithm allow parameters to have the same value?</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_replicates_index">replicates_index</code></td>
<td>
<p>A vector, the same length as the parameters.
If two values are the same in this vector then the parameters may not assume the same value in the optimization.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_ofv_initial">ofv_initial</code></td>
<td>
<p>An initial objective function value (OFV).  If not NULL then the initial design is not evaluated
and the OFV value is assumed to be this number.</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_closed_bounds">closed_bounds</code></td>
<td>
<p>Are the upper and lower limits open (boundaries not allowed) or closed (boundaries allowed) bounds?</p>
</td></tr>
<tr><td><code id="optim_LS_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code> and <code>start_parallel</code>.</p>
</td></tr>
</table>


<h3>References</h3>


<ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. Ruggeri, &quot;PopED, a software fir optimal 
experimental design in population kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004.
</p>
</li>
<li><p> J. Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. Hooker, &quot;PopED: An extended, 
parallelized, nonlinear mixed effects models optimal design tool&quot;,  
Computer Methods and Programs in Biomedicine, 108, 2012.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># "wild" function 
fw &lt;- function(x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80

# Global minimum of 67.47 at about -15.81515
(fw_min &lt;- fw(-15.81515))

if (interactive()){  
  #plot of the function
  require(graphics)
  plot(fw, -50, 50, n = 10000, main = "Minimizing 'wild function'")
  
  # Known minimum
  points(-15.81515, fw_min, pch = 21, col = "red", cex = 1.5)
} 

# optimization with fewer function evaluations 
# compared to SANN: see examples in '?optim'
res1 &lt;- optim_LS(50, fw,lower = -50, upper=50, line_length = 10000)

if (interactive()){ 
  require(graphics)
  plot(fw, -20, 0, n = 10000, main = "Minimizing 'wild function'")
  
  # Known minimum
  points(-15.81515, fw_min, pch = 21, col = "red", cex = 1.5)
  
  #plot of the optimization
  points(res1$par, res1$ofv, pch = 16, col = "green", cex = 1)
} 

# Upper and lower bounds and line_length should be considered carefully
res2 &lt;- optim_LS(50, fw, lower=-Inf,upper=Inf,line_length = 10000)

# Only integer values allowed
res_int &lt;- optim_LS(50, fw, allowed_values = seq(-50,50,by=1))


# Rosenbrock Banana function
# f(x, y) = (a-x)^2 + b*(y-x^2)^2
# global minimum at (x, y)=(a, a^2), where f(x, y)=0. 
# Usually a = 1 and b = 100 so x=1 and y=1
if (interactive()){ 
  fr &lt;- function(x,a=1,b=100) {   
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    b*(x2 - x1*x1)^2 + (a - x1)^2
  }
  
  res3 &lt;- optim_LS(c(-1.2,1), fr,lower = -5, upper = 5, line_length = 1000)

  # plot the surface
  x &lt;- seq(-50, 50, length= 30)
  y &lt;- x
  f &lt;- function(x,y){apply(cbind(x,y),1,fr)}
  z &lt;- outer(x, y, f)
  persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue", ticktype="detailed") -&gt; res
  points(trans3d(1, 1, 0, pmat = res), col = 2, pch = 16,cex=2)
  points(trans3d(res3$par[1], res3$par[1], res3$ofv, pmat = res), col = "green", pch = 16,cex=1.5)
}

# box constraints
flb &lt;- function(x){
  p &lt;- length(x) 
  sum(c(1, rep(4, p-1)) * (x - c(1, x[-p])^2)^2) 
}

## 25-dimensional box constrained
if (interactive()){ 
  optim(rep(3, 25), flb,lower = rep(2, 25), upper = rep(4, 25),method = "L-BFGS-B") 
}
res_box &lt;- optim_LS(rep(3, 25), flb,
                    lower = rep(2, 25), 
                    upper = rep(4, 25),
                    line_length = 1000) 

# one-dimensional function
if (interactive()){ 
  f &lt;- function(x)  abs(x)+cos(x)
  res5 &lt;- optim_LS(-20,f,lower=-20, upper=20, line_length = 500)
  
  curve(f, -20, 20)
  abline(v = res5$par, lty = 4,col="green")
}  

# one-dimensional function
f &lt;- function(x)  (x^2+x)*cos(x) # -10 &lt; x &lt; 10
res_max &lt;- optim_LS(0,f,lower=-10, upper=10,maximize=TRUE,line_length = 1000) 

if (interactive()){ 
  res_min &lt;- optim_LS(0,f,lower=-10, upper=10, line_length = 1000) 
  
  curve(f, -10, 10)
  abline(v = res_min$par, lty = 4,col="green")
  abline(v = res_max$par, lty = 4,col="red")
}


# two-dimensional Rastrigin function
#It has a global minimum at f(x) = f(0) = 0.
if (interactive()){ 
  Rastrigin &lt;- function(x1, x2){
    20 + x1^2 + x2^2 - 10*(cos(2*pi*x1) + cos(2*pi*x2))
  }
  
  
  x1 &lt;- x2 &lt;- seq(-5.12, 5.12, by = 0.1)
  z &lt;- outer(x1, x2, Rastrigin)
  
  res6 &lt;- optim_LS(c(-4,4),function(x) Rastrigin(x[1], x[2]),
                   lower=-5.12, upper=5.12, line_length = 1000)
  
  # color scale
  nrz &lt;- nrow(z)
  ncz &lt;- ncol(z)
  jet.colors &lt;-
    colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                       "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
  # Generate the desired number of colors from this palette
  nbcol &lt;- 100
  color &lt;- jet.colors(nbcol)
  # Compute the z-value at the facet centres
  zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
  # Recode facet z-values into color indices
  facetcol &lt;- cut(zfacet, nbcol)
  persp(x1, x2, z, col = color[facetcol], phi = 30, theta = 30)
  filled.contour(x1, x2, z, color.palette = jet.colors)
}


## Parallel computation  
## works better when each evaluation takes longer
## here we have added extra time to the computations
## just to show that it works
if (interactive()){ 
  res7 &lt;- optim_LS(c(-4,4),function(x){Sys.sleep(0.01); Rastrigin(x[1], x[2])},
                   lower=-5.12, upper=5.12, line_length = 200)
  res8 &lt;- optim_LS(c(-4,4),function(x){Sys.sleep(0.01); Rastrigin(x[1], x[2])},
                   lower=-5.12, upper=5.12, line_length = 200, parallel = TRUE)
  res9 &lt;- optim_LS(c(-4,4),function(x){Sys.sleep(0.01); Rastrigin(x[1], x[2])},
                   lower=-5.12, upper=5.12, line_length = 200, parallel = TRUE, 
                   parallel_type = "snow")
}
</code></pre>

<hr>
<h2 id='optimize_groupsize'>Title Optimize the proportion of individuals in the design groups</h2><span id='topic+optimize_groupsize'></span>

<h3>Description</h3>

<p>Title Optimize the proportion of individuals in the design groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_groupsize(
  poped.db,
  props = c(poped.db$design$groupsize/sum(poped.db$design$groupsize)),
  trace = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_groupsize_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="optimize_groupsize_+3A_props">props</code></td>
<td>
<p>The proportions of individuals in each group 
(relative to the total number of individuals) 
to start the optimization from.</p>
</td></tr>
<tr><td><code id="optimize_groupsize_+3A_trace">trace</code></td>
<td>
<p>Should there be tracing of the optimization? Value can be integer values.
Larger numbers give more information.</p>
</td></tr>
<tr><td><code id="optimize_groupsize_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+ofv_fim">ofv_fim</a></code> and <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the  initial objective function value, optimal proportions,
the objective function value with those proportions, 
the optimal number of individuals in each group (with integer number of individuals),
and the objective function value with that number of individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 design groups with either early or late samples
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=function(x,a,bpop,b,bocc){
                                    parameters=c(CL=bpop[1]*exp(b[1]),
                                                 V=bpop[2]*exp(b[2]),
                                                 KA=bpop[3]*exp(b[3]),
                                                 Favail=bpop[4],
                                                 DOSE=a[1])
                                    return(parameters) 
                                  },
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  xt=list(c(1,2,3),c(4,5,20,120)),
                                  groupsize=50,
                                  minxt=0.01,
                                  maxxt=120,
                                  a=70,
                                  mina=0.01,
                                  maxa=100)


plot_model_prediction(poped.db)

evaluate_design(poped.db)


# what are the optimal proportions of 
# individuals in the two groups in the study?
(n_opt &lt;- optimize_groupsize(poped.db))

# How many individuals in the original design are needed to achieve an
# efficiency of 1 compared to the optimized design with n=100?
optimize_n_eff(poped.db,
               ofv_ref=n_opt$opt_ofv_with_n)



</code></pre>

<hr>
<h2 id='optimize_n_eff'>Translate efficiency to number of subjects</h2><span id='topic+optimize_n_eff'></span>

<h3>Description</h3>

<p>optimize HOW MANY n there should be to achieve efficiency=1 compared to a reference OFV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_n_eff(poped.db, ofv_ref, norm_group_fim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_n_eff_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="optimize_n_eff_+3A_ofv_ref">ofv_ref</code></td>
<td>
<p>A reference OFV value to compare to.</p>
</td></tr>
<tr><td><code id="optimize_n_eff_+3A_norm_group_fim">norm_group_fim</code></td>
<td>
<p>The FIM per individual in each design group. If <code>NULL</code>, then
these are computed.</p>
</td></tr>
<tr><td><code id="optimize_n_eff_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code>efficiency</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of individuals needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 design groups with either early or late samples
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=function(x,a,bpop,b,bocc){
                                    parameters=c(CL=bpop[1]*exp(b[1]),
                                                 V=bpop[2]*exp(b[2]),
                                                 KA=bpop[3]*exp(b[3]),
                                                 Favail=bpop[4],
                                                 DOSE=a[1])
                                    return(parameters) 
                                  },
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  xt=list(c(1,2,3),c(4,5,20,120)),
                                  groupsize=50,
                                  minxt=0.01,
                                  maxxt=120,
                                  a=70,
                                  mina=0.01,
                                  maxa=100)


plot_model_prediction(poped.db)

evaluate_design(poped.db)


# what are the optimal proportions of 
# individuals in the two groups in the study?
(n_opt &lt;- optimize_groupsize(poped.db))

# How many individuals in the original design are needed to achieve an
# efficiency of 1 compared to the optimized design with n=100?
optimize_n_eff(poped.db,
               ofv_ref=n_opt$opt_ofv_with_n)



</code></pre>

<hr>
<h2 id='optimize_n_rse'>Optimize the number of subjects based on desired uncertainty of a parameter.</h2><span id='topic+optimize_n_rse'></span>

<h3>Description</h3>

<p>Optimize the number of subjects, 
based on the current design and the desired uncertainty of a single parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_n_rse(
  poped.db,
  bpop_idx,
  need_rse,
  use_percent = TRUE,
  allowed_values = seq(poped.db$design$m, sum(poped.db$design$groupsize) * 5, by =
    poped.db$design$m)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_n_rse_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="optimize_n_rse_+3A_bpop_idx">bpop_idx</code></td>
<td>
<p>The index number of the parameter, currently only bpop parameters are allowed.</p>
</td></tr>
<tr><td><code id="optimize_n_rse_+3A_need_rse">need_rse</code></td>
<td>
<p>The relative standard error (RSE) one would like to achieve (in percent, by default).</p>
</td></tr>
<tr><td><code id="optimize_n_rse_+3A_use_percent">use_percent</code></td>
<td>
<p>Should the RSE be represented as a percentage (T/F)?</p>
</td></tr>
<tr><td><code id="optimize_n_rse_+3A_allowed_values">allowed_values</code></td>
<td>
<p>A vector of the allowed total number of subjects in the study.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total number of subjects needed and the RSE of the parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 design groups with either early or late samples
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=function(x,a,bpop,b,bocc){
                                    parameters=c(CL=bpop[1]*exp(b[1]),
                                                 V=bpop[2]*exp(b[2]),
                                                 KA=bpop[3]*exp(b[3]),
                                                 Favail=bpop[4],
                                                 DOSE=a[1])
                                    return(parameters) 
                                  },
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  xt=list(c(1,2,3),c(4,5,20,120)),
                                  groupsize=50,
                                  minxt=0.01,
                                  maxxt=120,
                                  a=70,
                                  mina=0.01,
                                  maxa=100)

# plot of the design
plot_model_prediction(poped.db)

# the current RSE values
evaluate_design(poped.db)$rse

# number of individuals if CL should have 10% RSE
optimize_n_rse(poped.db,
                bpop_idx=1, # for CL
                need_rse=10) # the RSE you want


</code></pre>

<hr>
<h2 id='pargen'>Parameter simulation</h2><span id='topic+pargen'></span>

<h3>Description</h3>

<p>Function generates random samples for a list of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pargen(par, user_dist_pointer, sample_size, bLHS, sample_number, poped.db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pargen_+3A_par">par</code></td>
<td>
<p>A matrix describing the parameters. Each row is a parameter and 
the matrix has three columns: 
</p>
 
<ol>
<li><p> First column - Type of
distribution (0-fixed, 1-normal, 2-uniform, 3-user specified, 4-lognormal,
5-Truncated normal). 
</p>
</li>
<li><p> Second column - Mean of distribution. 
</p>
</li>
<li><p> Third
column - Variance or range of distribution. 
</p>
</li></ol>
</td></tr>
<tr><td><code id="pargen_+3A_user_dist_pointer">user_dist_pointer</code></td>
<td>
<p>A text string of the name of a function that
generates random samples from a user defined distribution.</p>
</td></tr>
<tr><td><code id="pargen_+3A_sample_size">sample_size</code></td>
<td>
<p>The number of random samples per parameter to generate</p>
</td></tr>
<tr><td><code id="pargen_+3A_blhs">bLHS</code></td>
<td>
<p>Logical, indicating if Latin Hypercube Sampling should be used.</p>
</td></tr>
<tr><td><code id="pargen_+3A_sample_number">sample_number</code></td>
<td>
<p>The sample number to extract from a user distribution.</p>
</td></tr>
<tr><td><code id="pargen_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of random samples of size (sample_size x
number_of_parameters)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################


# Adding 40% Uncertainty to fixed effects log-normal (not Favail)
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                      bpop_vals,
                      ones(length(bpop_vals),1)*(bpop_vals*0.4)^2) # 40% of bpop value
bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)

pars.ln &lt;- pargen(par=bpop_vals_ed_ln,
               user_dist_pointer=NULL,
               sample_size=1000,
               bLHS=1,
               sample_number=NULL,
               poped.db)


# Adding 10% Uncertainty to fixed effects normal-distribution (not Favail)
bpop_vals_ed_n &lt;- cbind(ones(length(bpop_vals),1)*1, # log-normal distribution
                      bpop_vals,
                      ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_n["Favail",]  &lt;- c(0,1,0)

pars.n &lt;- pargen(par=bpop_vals_ed_n,
               user_dist_pointer=NULL,
               sample_size=1000,
               bLHS=1,
               sample_number=NULL,
               poped.db)


# Adding 10% Uncertainty to fixed effects uniform-distribution (not Favail)
bpop_vals_ed_u &lt;- cbind(ones(length(bpop_vals),1)*2, # uniform distribution
                        bpop_vals,
                        ones(length(bpop_vals),1)*(bpop_vals*0.1)) # 10% of bpop value
bpop_vals_ed_u["Favail",]  &lt;- c(0,1,0)

pars.u &lt;- pargen(par=bpop_vals_ed_u,
                 user_dist_pointer=NULL,
                 sample_size=1000,
                 bLHS=1,
                 sample_number=NULL,
                 poped.db)


# Adding user defined distributions
bpop_vals_ed_ud &lt;- cbind(ones(length(bpop_vals),1)*3, # user dfined distribution
                         bpop_vals,
                         bpop_vals*0.1) # 10% of bpop value
bpop_vals_ed_ud["Favail",]  &lt;- c(0,1,0)

# A normal distribution
my_dist &lt;- function(...){
  par_vec &lt;- rnorm(c(1,1,1,1),mean=bpop_vals_ed_ud[,2],sd=bpop_vals_ed_ud[,3])
}

pars.ud &lt;- pargen(par=bpop_vals_ed_ud,
                  user_dist_pointer=my_dist,
                  sample_size=1000,
                  bLHS=1,
                  sample_number=NULL,
                  poped.db)


</code></pre>

<hr>
<h2 id='plot_efficiency_of_windows'>Plot the efficiency of windows</h2><span id='topic+plot_efficiency_of_windows'></span>

<h3>Description</h3>

<p>Function plots the efficiency of windows around the sample time points. 
The function samples from a uniform distribution around the sample time  
points for each group (or each individual with <code>deviate_by_id=TRUE</code>, 
with slower calculation times) and compares the results with the 
design defined in <code>poped.db</code>. The maximal and minimal allowed values for all design variables as 
defined in poped.db are respected (e.g. poped.db$design_space$minxt and 
poped.db$design_space$maxxt).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_efficiency_of_windows(
  poped.db,
  xt_windows = NULL,
  xt_plus = xt_windows,
  xt_minus = xt_windows,
  iNumSimulations = 100,
  y_eff = TRUE,
  y_rse = TRUE,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  mean_line = TRUE,
  mean_color = "red",
  deviate_by_id = FALSE,
  parallel = F,
  seed = round(runif(1, 0, 1e+07)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_efficiency_of_windows_+3A_poped.db">poped.db</code></td>
<td>
<p>A poped database</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_xt_windows">xt_windows</code></td>
<td>
<p>The distance on one direction from the optimal sample 
times.  Can be a number or a matrix of the same size as the xt matrix found
in <code>poped.db$design$xt</code>.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_xt_plus">xt_plus</code></td>
<td>
<p>The upper distance from the optimal sample times (xt + 
xt_plus). Can be a number or a matrix of the same size as the xt matrix 
found in <code>poped.db$design$xt</code>.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_xt_minus">xt_minus</code></td>
<td>
<p>The lower distance from the optimal sample times (xt - 
xt_minus). Can be a number or a matrix of the same size as the xt matrix 
found in <code>poped.db$design$xt</code>.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_inumsimulations">iNumSimulations</code></td>
<td>
<p>The number of design simulations to make within the 
specified windows.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_y_eff">y_eff</code></td>
<td>
<p>Should one of the plots created have efficiency on the y-axis?</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_y_rse">y_rse</code></td>
<td>
<p>Should created plots include the relative standard error of each
parameter as a value on the y-axis?</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_mean_line">mean_line</code></td>
<td>
<p>Should a mean value line be created?</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_mean_color">mean_color</code></td>
<td>
<p>The color of the mean value line.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_deviate_by_id">deviate_by_id</code></td>
<td>
<p>Should the computations look at deviations per
individual instead of per group?</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations (T/F)?
Other options can be defined in this function and passed 
to <code><a href="#topic+start_parallel">start_parallel</a></code>.  See especially 
the options <code>dlls</code> and <code>mrgsolve_model</code> from that function 
if you have a model defined with 
compiled code or are using mrgsolve.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_seed">seed</code></td>
<td>
<p>The random seed to use.</p>
</td></tr>
<tr><td><code id="plot_efficiency_of_windows_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>evaluate.fim</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>See Also</h3>

<p>Other evaluate_design: 
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+evaluate_design">evaluate_design</a>()</code>,
<code><a href="#topic+evaluate_power">evaluate_power</a>()</code>,
<code><a href="#topic+get_rse">get_rse</a>()</code>,
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>
<p>Other Simulation: 
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>
<p>Other Graphics: 
<code><a href="#topic+plot_model_prediction">plot_model_prediction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################




# Examine efficiency of sampling windows at plus/minus 0.5 hours from 
# sample points in the design
plot_efficiency_of_windows(poped.db,xt_windows=0.5)


if(interactive()){  

  plot_efficiency_of_windows(poped.db,
                             xt_plus=c( 0.5,1,2,1,2,3,7,1),
                             xt_minus=c( 0.1,2,5,4,2,3,6,2))
  
  plot_efficiency_of_windows(poped.db,xt_windows=c( 0.5,1,2,1,2,3,7,1))
  
  
  plot_efficiency_of_windows(poped.db,
                             xt_plus=c( 0.5,1,2,1,2,3,7,1),
                             xt_minus=c( 0.1,2,5,4,2,3,6,2),
                             y_rse=FALSE)
  
  plot_efficiency_of_windows(poped.db,
                             xt_plus=c( 0.5,1,2,1,2,3,7,1),
                             xt_minus=c( 0.1,2,5,4,2,3,6,2),
                             y_eff=FALSE)
}

</code></pre>

<hr>
<h2 id='plot_model_prediction'>Plot model predictions</h2><span id='topic+plot_model_prediction'></span>

<h3>Description</h3>

<p>Function plots model predictions for the typical value in the population,
individual predictions and data predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_model_prediction(
  poped.db,
  model_num_points = 100,
  groupsize_sim = 100,
  separate.groups = F,
  sample.times = T,
  sample.times.IPRED = F,
  sample.times.DV = F,
  PRED = T,
  IPRED = F,
  IPRED.lines = F,
  IPRED.lines.pctls = F,
  alpha.IPRED.lines = 0.1,
  alpha.IPRED = 0.3,
  sample.times.size = 4,
  DV = F,
  alpha.DV = 0.3,
  DV.lines = F,
  DV.points = F,
  alpha.DV.lines = 0.3,
  alpha.DV.points = 0.3,
  sample.times.DV.points = F,
  sample.times.DV.lines = F,
  alpha.sample.times.DV.points = 0.3,
  alpha.sample.times.DV.lines = 0.3,
  y_lab = "Model Predictions",
  facet_scales = "fixed",
  facet_label_names = T,
  model.names = NULL,
  DV.mean.sd = FALSE,
  PI = FALSE,
  PI_alpha = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_model_prediction_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_model_num_points">model_num_points</code></td>
<td>
<p>How many extra observation rows should be created in the data frame for each group or individual 
per model.  If used then the points are placed evenly between <code>model_minxt</code> and <code>model_maxxt</code>. This option
is used by <code><a href="#topic+plot_model_prediction">plot_model_prediction</a></code> to simulate the response of the model on a finer grid then the defined design.
If <code>NULL</code> then only the input design is used.  Can be a single value or a vector the same length as the number of models.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_groupsize_sim">groupsize_sim</code></td>
<td>
<p>How many individuals per group  should be 
simulated when DV=TRUE or IPRED=TRUE to create prediction intervals?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_separate.groups">separate.groups</code></td>
<td>
<p>Should there be separate plots for each group.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_sample.times">sample.times</code></td>
<td>
<p>Should sample times be shown on the plots.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_sample.times.ipred">sample.times.IPRED</code></td>
<td>
<p>Should sample times be shown based on the IPRED y-values.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_sample.times.dv">sample.times.DV</code></td>
<td>
<p>Should sample times be shown based on the DV y-values.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_pred">PRED</code></td>
<td>
<p>Should a PRED line be drawn.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_ipred">IPRED</code></td>
<td>
<p>Should we simulate individual predictions?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_ipred.lines">IPRED.lines</code></td>
<td>
<p>Should IPRED lines be drawn?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_ipred.lines.pctls">IPRED.lines.pctls</code></td>
<td>
<p>Should lines be drawn at the chosen percentiles of the IPRED values?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.ipred.lines">alpha.IPRED.lines</code></td>
<td>
<p>What should the transparency for the IPRED.lines be?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.ipred">alpha.IPRED</code></td>
<td>
<p>What should the transparency of the IPRED CI?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_sample.times.size">sample.times.size</code></td>
<td>
<p>What should the size of the sample.times be?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_dv">DV</code></td>
<td>
<p>should we simulate observations?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.dv">alpha.DV</code></td>
<td>
<p>What should the transparency of the DV CI?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_dv.lines">DV.lines</code></td>
<td>
<p>Should DV lines be drawn?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_dv.points">DV.points</code></td>
<td>
<p>Should DV points be drawn?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.dv.lines">alpha.DV.lines</code></td>
<td>
<p>What should the transparency for the DV.lines be?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.dv.points">alpha.DV.points</code></td>
<td>
<p>What should the transparency for the DV.points be?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_sample.times.dv.points">sample.times.DV.points</code></td>
<td>
<p>TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_sample.times.dv.lines">sample.times.DV.lines</code></td>
<td>
<p>TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.sample.times.dv.points">alpha.sample.times.DV.points</code></td>
<td>
<p>What should the transparency for the sample.times.DV.points be?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_alpha.sample.times.dv.lines">alpha.sample.times.DV.lines</code></td>
<td>
<p>What should the transparency for the sample.times.DV.lines be?</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_y_lab">y_lab</code></td>
<td>
<p>The label of the y-axis.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_facet_scales">facet_scales</code></td>
<td>
<p>Can be &quot;free&quot;, &quot;fixed&quot;, &quot;free_x&quot; or &quot;free_y&quot;</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_facet_label_names">facet_label_names</code></td>
<td>
<p>TRUE or FALSE</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_model.names">model.names</code></td>
<td>
<p>A vector of names of the response model/s (the length of the 
vector should be equal to the number of response models). It is Null by default.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_dv.mean.sd">DV.mean.sd</code></td>
<td>
<p>Plot the mean and standard deviation of simulated observations.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_pi">PI</code></td>
<td>
<p>Plot prediction intervals for the expected data given the model.
Predictions are based on first-order approximations to 
the model variance and a normality assumption of that variance.  As such these computations are 
more approximate than using <code>DV=T</code> and <code>groupsize_sim = some large number</code>.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_pi_alpha">PI_alpha</code></td>
<td>
<p>The transparency of the PI.</p>
</td></tr>
<tr><td><code id="plot_model_prediction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="#topic+model_prediction">model_prediction</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot</a> object.  If you would like to further edit this plot don't 
forget to load the ggplot2 library using <code>library(ggplot2)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_prediction">model_prediction</a></code>
</p>
<p>Other evaluate_design: 
<code><a href="#topic+evaluate.fim">evaluate.fim</a>()</code>,
<code><a href="#topic+evaluate_design">evaluate_design</a>()</code>,
<code><a href="#topic+evaluate_power">evaluate_power</a>()</code>,
<code><a href="#topic+get_rse">get_rse</a>()</code>,
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>
</p>
<p>Other Simulation: 
<code><a href="#topic+model_prediction">model_prediction</a>()</code>,
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>
</p>
<p>Other Graphics: 
<code><a href="#topic+plot_efficiency_of_windows">plot_efficiency_of_windows</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

library(PopED)

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.md.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
    return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(
  ff_fun=ff.PK.1.comp.oral.sd.CL,
  fg_fun=sfg,
  fError_fun=feps.prop,
  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
  notfixed_bpop=c(1,1,1,0),
  d=c(CL=0.07, V=0.02, KA=0.6), 
  sigma=0.01,
  groupsize=32,
  xt=c( 0.5,1,2,6,24,36,72,120),
  minxt=0,
  maxxt=120,
  a=70)

##  create plot of model without variability 
plot_model_prediction(poped.db)

##  create plot of model with variability by simulating from OMEGA and SIGMA
plot_model_prediction(poped.db,IPRED=TRUE,DV=TRUE)

##  create plot of model with variability by 
##  computing the expected variance (using an FO approximation) 
##  and then computing a prediction interval 
##  based on an assumption of normality
##  computation is faster but less accurate 
##  compared to using DV=TRUE (and groupsize_sim = 500)
plot_model_prediction(poped.db,PI=TRUE)

##-- Model: One comp first order absorption + inhibitory imax
## -- works for both mutiple and single dosing  
ff &lt;- function(model_switch,xt,parameters,poped.db){
  with(as.list(parameters),{
    
    y=xt
    MS &lt;- model_switch
    
    # PK model
    N = floor(xt/TAU)+1
    CONC=(DOSE*Favail/V)*(KA/(KA - CL/V)) * 
      (exp(-CL/V * (xt - (N - 1) * TAU)) * (1 - exp(-N * CL/V * TAU))/(1 - exp(-CL/V * TAU)) - 
         exp(-KA * (xt - (N - 1) * TAU)) * (1 - exp(-N * KA * TAU))/(1 - exp(-KA * TAU)))  
    
    # PD model
    EFF = E0*(1 - CONC*IMAX/(IC50 + CONC))
    
    y[MS==1] = CONC[MS==1]
    y[MS==2] = EFF[MS==2]
    
    return(list( y= y,poped.db=poped.db))
  })
}

## -- parameter definition function 
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c( V=bpop[1]*exp(b[1]),
                KA=bpop[2]*exp(b[2]),
                CL=bpop[3]*exp(b[3]),
                Favail=bpop[4],
                DOSE=a[1],
                TAU = a[2],
                E0=bpop[5]*exp(b[4]),
                IMAX=bpop[6],
                IC50=bpop[7])
  return( parameters ) 
}


## -- Residual Error function
feps &lt;- function(model_switch,xt,parameters,epsi,poped.db){
  returnArgs &lt;- ff(model_switch,xt,parameters,poped.db) 
  y &lt;- returnArgs[[1]]
  poped.db &lt;- returnArgs[[2]]
  
  MS &lt;- model_switch
  
  pk.dv &lt;- y*(1+epsi[,1])+epsi[,2]
  pd.dv &lt;-  y*(1+epsi[,3])+epsi[,4]
  
  y[MS==1] = pk.dv[MS==1]
  y[MS==2] = pd.dv[MS==2]
  
  return(list( y= y,poped.db =poped.db )) 
}

poped.db &lt;- 
  create.poped.database(
    ff_fun=ff,
    fError_fun=feps,
    fg_fun=sfg,
    groupsize=20,
    m=3,
    bpop=c(V=72.8,KA=0.25,CL=3.75,Favail=0.9,
           E0=1120,IMAX=0.807,IC50=0.0993),  
    notfixed_bpop=c(1,1,1,0,1,1,1),
    d=c(V=0.09,KA=0.09,CL=0.25^2,E0=0.09), 
    sigma=c(0.04,5e-6,0.09,100),
    notfixed_sigma=c(0,0,0,0),
    xt=c( 1,2,8,240,240,1,2,8,240,240),
    minxt=c(0,0,0,240,240,0,0,0,240,240),
    maxxt=c(10,10,10,248,248,10,10,10,248,248),
    discrete_xt = list(0:248),
    G_xt=c(1,2,3,4,5,1,2,3,4,5),
    bUseGrouped_xt=1,
    model_switch=c(1,1,1,1,1,2,2,2,2,2),
    a=list(c(DOSE=20,TAU=24),c(DOSE=40, TAU=24),c(DOSE=0, TAU=24)),
    maxa=c(DOSE=200,TAU=40),
    mina=c(DOSE=0,TAU=2),
    ourzero=0)

##  create plot of model and design 
plot_model_prediction(poped.db,facet_scales="free",
                      model.names = c("PK","PD"))

##  create plot of model with variability by  
##  computing the expected variance (using an FO approximation) 
##  and then computing a prediction interval 
##  based on an assumption of normality
##  computation is faster but less accurate 
##  compared to using DV=TRUE (and groupsize_sim = 500)
plot_model_prediction(poped.db,facet_scales="free",
                      model.names = c("PK","PD"),
                      PI=TRUE,
                      separate.groups = TRUE)


</code></pre>

<hr>
<h2 id='poped_gui'>Run the graphical interface for PopED</h2><span id='topic+poped_gui'></span>

<h3>Description</h3>

<p>Run the graphical interface for PopED
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped_gui()
</code></pre>

<hr>
<h2 id='poped_optim'>Optimize a design defined in a PopED database</h2><span id='topic+poped_optim'></span>

<h3>Description</h3>

<p>Optimize a design defined in a PopED database using the objective function
described in the database (or in the arguments to this function). The 
function works for both discrete and 
continuous optimization variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped_optim(
  poped.db,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  method = c("ARS", "BFGS", "LS"),
  control = list(),
  trace = TRUE,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  ds_index = poped.db$parameters$ds_index,
  approx_type = poped.db$settings$iApproximationMethod,
  d_switch = poped.db$settings$d_switch,
  ED_samp_size = poped.db$settings$ED_samp_size,
  bLHS = poped.db$settings$bLHS,
  use_laplace = poped.db$settings$iEDCalculationType,
  out_file = "",
  parallel = F,
  parallel_type = NULL,
  num_cores = NULL,
  mrgsolve_model = NULL,
  loop_methods = ifelse(length(method) &gt; 1, TRUE, FALSE),
  iter_max = 10,
  stop_crit_eff = 1.001,
  stop_crit_diff = NULL,
  stop_crit_rel = NULL,
  ofv_fun = poped.db$settings$ofv_fun,
  maximize = T,
  allow_replicates = TRUE,
  allow_replicates_xt = TRUE,
  allow_replicates_a = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poped_optim_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_method">method</code></td>
<td>
<p>A vector of optimization methods to use in a sequential 
fashion.  Options are <code>c("ARS","BFGS","LS","GA")</code>. <code>c("ARS")</code> is 
for Adaptive Random Search <code><a href="#topic+optim_ARS">optim_ARS</a></code>.  <code>c("LS")</code> is for 
Line Search <code><a href="#topic+optim_LS">optim_LS</a></code>. <code>c("BFGS")</code> is for Method 
&quot;L-BFGS-B&quot; from <code><a href="stats.html#topic+optim">optim</a></code>. <code>c("GA")</code> is for the 
genetic algorithm from <code><a href="GA.html#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_control">control</code></td>
<td>
<p>Contains control arguments for each method specified.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_trace">trace</code></td>
<td>
<p>Should the algorithm output results intermittently.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_+3A_ds_index">ds_index</code></td>
<td>
<p>Ds_index is a vector set to 1 if a parameter is uninteresting, otherwise 0.
size=(1,num unfixed parameters). First unfixed bpop, then unfixed d, then unfixed docc and last unfixed sigma. 
Default is the fixed effects being important, everything else not important.  Used in conjunction with
<code>ofv_calc_type=6</code>.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_approx_type">approx_type</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_out_file">out_file</code></td>
<td>
<p>Save output from the optimization to a file.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? 
Can be &quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows. &quot;multicore&quot; works only on 
Linux-like systems.  By default this is chosen for you depending on your operating system. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use in the parallelization.  By default  is set to the number 
output from 
<code>parallel::detectCores()</code>. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_mrgsolve_model">mrgsolve_model</code></td>
<td>
<p>If the computations require a mrgsolve model and you
are using the &quot;snow&quot; method then you need to specify the name of the model
object created by <code>mread</code> or <code>mcode</code>.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_loop_methods">loop_methods</code></td>
<td>
<p>Should the optimization methods be looped for
<code>iter_max</code> iterations, or until the efficiency of the design after the
current series (compared to the start of the series) is less than, or equal to,
<code>stop_crit_eff</code>?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_iter_max">iter_max</code></td>
<td>
<p>If line search is used then the algorithm tests if line
search (always run at the end of the optimization iteration) changes the 
design in any way.  If not, the algorithm stops.  If yes, then a new
iteration is run unless <code>iter_max</code> iterations have already been run.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_stop_crit_eff">stop_crit_eff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
efficiency of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_eff</code> (if <code>maximize==FALSE</code> then 1/stop_crit_eff is the cut
off and the efficiency must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_stop_crit_diff">stop_crit_diff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_diff</code> (if <code>maximize==FALSE</code> then -stop_crit_diff is the cut
off and the difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_stop_crit_rel">stop_crit_rel</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
relative difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_rel</code> (if <code>maximize==FALSE</code> then -stop_crit_rel is the cut
off and the relative difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_maximize">maximize</code></td>
<td>
<p>Should the objective function be maximized or minimized?</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_allow_replicates">allow_replicates</code></td>
<td>
<p>Should the algorithm allow optimized design components to have the same value? If FALSE then
all discrete optimizations will not allow replicates within variable types 
(equivalent to <code>allow_replicates_xt=FALSE</code> and <code>allow_replicates_a=FALSE</code>).</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_allow_replicates_xt">allow_replicates_xt</code></td>
<td>
<p>Should the algorithm allow optimized <code>xt</code> design components to have the same value? If FALSE then
all discrete optimizations will not allow replicates.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_allow_replicates_a">allow_replicates_a</code></td>
<td>
<p>Should the algorithm allow optimized <code>a</code> design components to have the same value? If FALSE then
all discrete optimizations will not allow replicates.</p>
</td></tr>
<tr><td><code id="poped_optim_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes information from the PopED database supplied as an 
argument. The PopED database supplies information about the the model, 
parameters, design and methods to use. Some of the arguments coming from the 
PopED database can be overwritten; if they are supplied then they are used 
instead of the arguments from the PopED database.
</p>
<p>If more than one optimization method is 
specified then the methods are run in series.  If <code>loop_methods=TRUE</code> 
then the series of optimization methods will be run for <code>iter_max</code> 
iterations, or until the efficiency of the design after the current series 
(compared to the start of the series) is less than <code>stop_crit_eff</code>.
</p>


<h3>References</h3>

 <ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. 
Ruggeri, &quot;PopED, a software fir optimal experimental design in population 
kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004. </p>
</li>
<li><p> J.
Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. 
Hooker, &quot;PopED: An extended, parallelized, nonlinear mixed effects models 
optimal design tool&quot;, Computer Methods and Programs in Biomedicine, 108, 
2012. </p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################

##############
# D-family Optimization
##############

# below are a number of ways to optimize the problem


# ARS+BFGS+LS optimization of dose
# optimization with just a few iterations
# only to check that things are working
out_1 &lt;- poped_optim(poped.db,opt_a =TRUE,
                      control = list(ARS=list(iter=2),
                                     BFGS=list(maxit=2),
                                     LS=list(line_length=2)),
                      iter_max = 1)


# cost function
# PRED at 120 hours
crit_fcn &lt;- function(poped.db,...){
  pred_df &lt;- model_prediction(poped.db)
  return(pred_df[pred_df$Time==120,"PRED"])
}

# maximize cost function
out_2 &lt;- poped_optim(poped.db,opt_a =TRUE,
                     ofv_fun=crit_fcn,
                     control = list(ARS=list(iter=2),
                                    BFGS=list(maxit=2),
                                    LS=list(line_length=2)),
                     iter_max = 2)

# minimize the cost function
out_3 &lt;- poped_optim(poped.db,opt_a =TRUE,
                     ofv_fun=crit_fcn,
                     control = list(ARS=list(iter=2),
                                    BFGS=list(maxit=2),
                                    LS=list(line_length=2)),
                     iter_max = 2,
                     maximize = FALSE,
                     evaluate_fim = FALSE)


## Not run: 
  
  # RS+BFGS+LS optimization of sample times 
  # (longer run time than above but more likely to reach a maximum)
  output &lt;- poped_optim(poped.db,opt_xt=T,parallel = TRUE)
  
  get_rse(output$FIM,output$poped.db)
  plot_model_prediction(output$poped.db)
  
  # optimization with only integer times allowed
  poped.db.2 &lt;- poped.db
  poped.db.2$design_space$xt_space &lt;- matrix(list(seq(1,120)),1,8)
  output_2 &lt;- poped_optim(poped.db.2,opt_xt=T,parallel = TRUE)

  get_rse(output_2$FIM,output_2$poped.db)
  plot_model_prediction(output_2$poped.db)
  
  # Examine efficiency of sampling windows
  plot_efficiency_of_windows(output_2$poped.db,xt_windows=0.5)
  plot_efficiency_of_windows(output_2$poped.db,xt_windows=1)
  
  # Adaptive Random Search (ARS, just a few samples here)
  rs.output &lt;- poped_optim(poped.db,opt_xt=T,method = "ARS",
                           control = list(ARS=list(iter=5)))
  
  get_rse(rs.output$FIM,rs.output$poped.db)
  
  # line search, DOSE and sample time optimization
  ls.output &lt;- poped_optim(poped.db,opt_xt=T,opt_a=T,method = "LS",
                           control = list(LS=list(line_length=5)))
  
  # Adaptive random search, 
  # DOSE and sample time optimization
  ars.output &lt;- poped_optim(poped.db,opt_xt=T,opt_a=T,method = "ARS",
                           control = list(ARS=list(iter=5)))
  
  # BFGS gradient search from the stats::optim() function, 
  # DOSE and sample time optimization
  bfgs.output &lt;- poped_optim(poped.db,opt_xt=T,opt_a=T,method = "BFGS",
                            control = list(BFGS=list(maxit=5)))
  
  
  # genetic algorithm from the GA::ga() function, 
  # DOSE and sample time optimization
  ga.output &lt;- poped_optim(poped.db,opt_xt=T,opt_a=F,method = "GA",parallel=T)
  
  # cost function with GA
  # maximize
  out_2 &lt;- poped_optim(poped.db,opt_a =TRUE,
                       ofv_fun=crit_fcn,
                       parallel = T,
                       method=c("GA"))
  
  # cost function with GA
  # minimize
  out_2 &lt;- poped_optim(poped.db,opt_a =TRUE,
                       ofv_fun=crit_fcn,
                       parallel = T,
                       method=c("GA"),
                       iter_max = 1,
                       maximize = F,
                       evaluate_fim = F)
  
  # optimize distribution of individuals in 3 groups
  poped_db_2 &lt;- create.poped.database(
    ff_fun=ff.PK.1.comp.oral.sd.CL,
    fg_fun=sfg,
    fError_fun=feps.add.prop,
    bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
    notfixed_bpop=c(1,1,1,0),
    d=c(CL=0.07, V=0.02, KA=0.6), 
    sigma=c(prop=0.01,add=0.25),
    groupsize=32,
    m=3,
    xt=list(c( 0.5,1,2,6,8),c(36,72,120),
            c(10,12,14,16,18,20,22,24)),
    minxt=0.01,
    maxxt=120,
    a=c(DOSE=70),
    mina=c(DOSE=0.01),
    maxa=c(DOSE=100))
  
  opt_xt_inds &lt;- 
    poped_optim(poped_db_2,
                opt_a =TRUE,
                opt_inds = TRUE,
                control = list(ARS=list(iter=2),
                               BFGS=list(maxit=2),
                               LS=list(line_length=2)),
                iter_max = 1)
  
  
  
  ##############
  # E-family Optimization
  ##############
  
  # Adding 10% log-normal Uncertainty to fixed effects (not Favail)
  bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
  bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                           bpop_vals,
                           ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
  bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
  bpop_vals_ed_ln
  
  ## -- Define initial design  and design space
  poped.db &lt;- create.poped.database(
    ff_fun=ff.PK.1.comp.oral.sd.CL,
    fg_fun=sfg,
    fError_fun=feps.add.prop,
    bpop=bpop_vals_ed_ln, 
    notfixed_bpop=c(1,1,1,0),
    d=c(CL=0.07, V=0.02, KA=0.6), 
    sigma=c(0.01,0.25),
    groupsize=32,
    xt=c( 0.5,1,2,6,24,36,72,120),
    minxt=0,
    maxxt=120,
    a=70,
    mina=0,
    maxa=100)
  
  
  # E_ln(D) optimization using Random search (just a few samples here)
  output &lt;- poped_optim(poped.db,opt_xt=TRUE,opt_a=TRUE,d_switch=0,
                        method = c("ARS","LS"),
                        control = list(ARS=list(iter=2),
                                       LS=list(line_length=2)),
                        iter_max = 1)
  get_rse(output$FIM,output$poped.db)
  
  # ED with laplace approximation, 
  # optimization using Random search (just a few iterations here)
  ars.output &lt;- poped_optim(poped.db,opt_xt=T,opt_a=T,method = "ARS",
                            d_switch=0,use_laplace=TRUE,#laplace.fim=TRUE,
                            parallel=T,
                            control = list(ARS=list(iter=5)))
  

## End(Not run)
</code></pre>

<hr>
<h2 id='poped_optim_1'>Optimization main module for PopED 
Optimize the objective function. The function works for both discrete and 
continuous optimization variables. If more than one optimization method is 
specified then the methods are run in series.  If <code>loop_methods=TRUE</code> 
then the series of optimization methods will be run for <code>iter_max</code> 
iterations, or until the efficiency of the design after the current series 
(compared to the start of the series) is less than <code>stop_crit_eff</code>.</h2><span id='topic+poped_optim_1'></span>

<h3>Description</h3>

<p>This function takes information from the PopED database supplied as an 
argument. The PopED database supplies information about the the model, 
parameters, design and methods to use. Some of the arguments coming from the 
PopED database can be overwritten; if they are supplied then they are used 
instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped_optim_1(
  poped.db,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  method = c("ARS", "BFGS", "LS"),
  control = list(),
  trace = TRUE,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  approx_type = poped.db$settings$iApproximationMethod,
  d_switch = poped.db$settings$d_switch,
  ED_samp_size = poped.db$settings$ED_samp_size,
  bLHS = poped.db$settings$bLHS,
  use_laplace = poped.db$settings$iEDCalculationType,
  out_file = "",
  parallel = F,
  parallel_type = NULL,
  num_cores = NULL,
  loop_methods = ifelse(length(method) &gt; 1, TRUE, FALSE),
  iter_max = 10,
  stop_crit_eff = 1.001,
  stop_crit_diff = NULL,
  stop_crit_rel = NULL,
  ofv_fun = poped.db$settings$ofv_fun,
  maximize = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poped_optim_1_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_method">method</code></td>
<td>
<p>A vector of optimization methods to use in a sequential 
fashion.  Options are <code>c("ARS","BFGS","LS","GA")</code>. <code>c("ARS")</code> is 
for Adaptive Random Search <code><a href="#topic+optim_ARS">optim_ARS</a></code>.  <code>c("LS")</code> is for 
Line Search <code><a href="#topic+optim_LS">optim_LS</a></code>. <code>c("BFGS")</code> is for Method 
&quot;L-BFGS-B&quot; from <code><a href="stats.html#topic+optim">optim</a></code>. <code>c("GA")</code> is for the 
genetic algorithm from <code><a href="GA.html#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_control">control</code></td>
<td>
<p>Contains control arguments for each method specified.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_trace">trace</code></td>
<td>
<p>Should the algorithm output results intermittently.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_approx_type">approx_type</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_out_file">out_file</code></td>
<td>
<p>Save output from the optimization to a file.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? 
Can be &quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows. &quot;multicore&quot; works only on 
Linux-like systems.  By default this is chosen for you depending on your operating system. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use in the parallelization.  By default  is set to the number 
output from 
<code>parallel::detectCores()</code>. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_loop_methods">loop_methods</code></td>
<td>
<p>Should the optimization methods be looped for
<code>iter_max</code> iterations, or until the efficiency of the design after the
current series (compared to the start of the series) is less than, or equal to,
<code>stop_crit_eff</code>?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_iter_max">iter_max</code></td>
<td>
<p>If line search is used then the algorithm tests if line
search (always run at the end of the optimization iteration) changes the 
design in any way.  If not, the algorithm stops.  If yes, then a new
iteration is run unless <code>iter_max</code> iterations have already been run.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_stop_crit_eff">stop_crit_eff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
efficiency of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_eff</code> (if <code>maximize==FALSE</code> then 1/stop_crit_eff is the cut
off and the efficiency must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_stop_crit_diff">stop_crit_diff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_diff</code> (if <code>maximize==FALSE</code> then -stop_crit_diff is the cut
off and the difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_stop_crit_rel">stop_crit_rel</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
relative difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_rel</code> (if <code>maximize==FALSE</code> then -stop_crit_rel is the cut
off and the relative difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_maximize">maximize</code></td>
<td>
<p>Should the objective function be maximized or minimized?</p>
</td></tr>
<tr><td><code id="poped_optim_1_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions.</p>
</td></tr>
</table>


<h3>References</h3>

 <ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. 
Ruggeri, &quot;PopED, a software fir optimal experimental design in population 
kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004. </p>
</li>
<li><p> J.
Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. 
Hooker, &quot;PopED: An extended, parallelized, nonlinear mixed effects models 
optimal design tool&quot;, Computer Methods and Programs in Biomedicine, 108, 
2012. </p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>

<hr>
<h2 id='poped_optim_2'>Optimization main module for PopED</h2><span id='topic+poped_optim_2'></span>

<h3>Description</h3>

<p>Optimize the objective function. The function works for both discrete and 
continuous optimization variables. If more than one optimization method is 
specified then the methods are run in series.  If <code>loop_methods=TRUE</code> 
then the series of optimization methods will be run for <code>iter_max</code> 
iterations, or until the efficiency of the design after the current series 
(compared to the start of the series) is less than <code>stop_crit_eff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped_optim_2(
  poped.db,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  method = c("ARS", "BFGS", "LS"),
  control = list(),
  trace = TRUE,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  approx_type = poped.db$settings$iApproximationMethod,
  d_switch = poped.db$settings$d_switch,
  ED_samp_size = poped.db$settings$ED_samp_size,
  bLHS = poped.db$settings$bLHS,
  use_laplace = poped.db$settings$iEDCalculationType,
  out_file = "",
  parallel = F,
  parallel_type = NULL,
  num_cores = NULL,
  loop_methods = ifelse(length(method) &gt; 1, TRUE, FALSE),
  iter_max = 10,
  stop_crit_eff = 1.001,
  stop_crit_diff = NULL,
  stop_crit_rel = NULL,
  ofv_fun = poped.db$settings$ofv_fun,
  maximize = T,
  transform_parameters = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poped_optim_2_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_method">method</code></td>
<td>
<p>A vector of optimization methods to use in a sequential 
fashion.  Options are <code>c("ARS","BFGS","LS","GA")</code>. <code>c("ARS")</code> is 
for Adaptive Random Search <code><a href="#topic+optim_ARS">optim_ARS</a></code>.  <code>c("LS")</code> is for 
Line Search <code><a href="#topic+optim_LS">optim_LS</a></code>. <code>c("BFGS")</code> is for Method 
&quot;L-BFGS-B&quot; from <code><a href="stats.html#topic+optim">optim</a></code>. <code>c("GA")</code> is for the 
genetic algorithm from <code><a href="GA.html#topic+ga">ga</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_control">control</code></td>
<td>
<p>Contains control arguments for each method specified.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_trace">trace</code></td>
<td>
<p>Should the algorithm output results intermittently.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_approx_type">approx_type</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_out_file">out_file</code></td>
<td>
<p>Save output from the optimization to a file.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? 
Can be &quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows. &quot;multicore&quot; works only on 
Linux-like systems.  By default this is chosen for you depending on your operating system. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use in the parallelization.  By default  is set to the number 
output from 
<code>parallel::detectCores()</code>. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_loop_methods">loop_methods</code></td>
<td>
<p>Should the optimization methods be looped for
<code>iter_max</code> iterations, or until the efficiency of the design after the
current series (compared to the start of the series) is less than, or equal to,
<code>stop_crit_eff</code>?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_iter_max">iter_max</code></td>
<td>
<p>If line search is used then the algorithm tests if line
search (always run at the end of the optimization iteration) changes the 
design in any way.  If not, the algorithm stops.  If yes, then a new
iteration is run unless <code>iter_max</code> iterations have already been run.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_stop_crit_eff">stop_crit_eff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
efficiency of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_eff</code> (if <code>maximize==FALSE</code> then 1/stop_crit_eff is the cut
off and the efficiency must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_stop_crit_diff">stop_crit_diff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_diff</code> (if <code>maximize==FALSE</code> then -stop_crit_diff is the cut
off and the difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_stop_crit_rel">stop_crit_rel</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
relative difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_rel</code> (if <code>maximize==FALSE</code> then -stop_crit_rel is the cut
off and the relative difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_maximize">maximize</code></td>
<td>
<p>Should the objective function be maximized or minimized?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_transform_parameters">transform_parameters</code></td>
<td>
<p>Should we transform the parameters before optimization?</p>
</td></tr>
<tr><td><code id="poped_optim_2_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes information from the PopED database supplied as an 
argument. The PopED database supplies information about the the model, 
parameters, design and methods to use. Some of the arguments coming from the 
PopED database can be overwritten; if they are supplied then they are used 
instead of the arguments from the PopED database.
</p>


<h3>References</h3>

 <ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. 
Ruggeri, &quot;PopED, a software fir optimal experimental design in population 
kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004. </p>
</li>
<li><p> J.
Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. 
Hooker, &quot;PopED: An extended, parallelized, nonlinear mixed effects models 
optimal design tool&quot;, Computer Methods and Programs in Biomedicine, 108, 
2012. </p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>

<hr>
<h2 id='poped_optim_3'>Optimization main module for PopED</h2><span id='topic+poped_optim_3'></span>

<h3>Description</h3>

<p>Optimize the objective function. The function works for both discrete and 
continuous optimization variables. If more than one optimization method is 
specified then the methods are run in series.  If <code>loop_methods=TRUE</code> 
then the series of optimization methods will be run for <code>iter_max</code> 
iterations, or until the efficiency of the design after the current series 
(compared to the start of the series) is less than <code>stop_crit_eff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped_optim_3(
  poped.db,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  method = c("ARS", "BFGS", "LS"),
  control = list(),
  trace = TRUE,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  ds_index = poped.db$parameters$ds_index,
  approx_type = poped.db$settings$iApproximationMethod,
  d_switch = poped.db$settings$d_switch,
  ED_samp_size = poped.db$settings$ED_samp_size,
  bLHS = poped.db$settings$bLHS,
  use_laplace = poped.db$settings$iEDCalculationType,
  out_file = "",
  parallel = F,
  parallel_type = NULL,
  num_cores = NULL,
  loop_methods = ifelse(length(method) &gt; 1, TRUE, FALSE),
  iter_max = 10,
  stop_crit_eff = 1.001,
  stop_crit_diff = NULL,
  stop_crit_rel = NULL,
  ofv_fun = poped.db$settings$ofv_fun,
  maximize = T,
  allow_replicates = TRUE,
  allow_replicates_xt = TRUE,
  allow_replicates_a = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poped_optim_3_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_method">method</code></td>
<td>
<p>A vector of optimization methods to use in a sequential 
fashion.  Options are <code>c("ARS","BFGS","LS","GA")</code>. <code>c("ARS")</code> is 
for Adaptive Random Search <code><a href="#topic+optim_ARS">optim_ARS</a></code>.  <code>c("LS")</code> is for 
Line Search <code><a href="#topic+optim_LS">optim_LS</a></code>. <code>c("BFGS")</code> is for Method 
&quot;L-BFGS-B&quot; from <code><a href="stats.html#topic+optim">optim</a></code>. <code>c("GA")</code> is for the 
genetic algorithm from <code><a href="GA.html#topic+ga">ga</a></code>. If <code>opt_inds=TRUE</code> then
this optimization is always added to the end of the sequential optimization.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_control">control</code></td>
<td>
<p>Contains control arguments specified for each method separately.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_trace">trace</code></td>
<td>
<p>Should the algorithm output results intermittently.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_ds_index">ds_index</code></td>
<td>
<p>Ds_index is a vector set to 1 if a parameter is uninteresting, otherwise 0.
size=(1,num unfixed parameters). First unfixed bpop, then unfixed d, then unfixed docc and last unfixed sigma. 
Default is the fixed effects being important, everything else not important.  Used in conjunction with
<code>ofv_calc_type=6</code>.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_approx_type">approx_type</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_out_file">out_file</code></td>
<td>
<p>Save output from the optimization to a file.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_parallel">parallel</code></td>
<td>
<p>Should we use parallel computations?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? 
Can be &quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows. &quot;multicore&quot; works only on 
Linux-like systems.  By default this is chosen for you depending on your operating system. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use in the parallelization.  By default  is set to the number 
output from 
<code>parallel::detectCores()</code>. 
See <code><a href="#topic+start_parallel">start_parallel</a></code>.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_loop_methods">loop_methods</code></td>
<td>
<p>Should the optimization methods be looped for
<code>iter_max</code> iterations, or until the efficiency of the design after the
current series (compared to the start of the series) is less than, or equal to,
<code>stop_crit_eff</code>?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_iter_max">iter_max</code></td>
<td>
<p>If line search is used then the algorithm tests if line
search (always run at the end of the optimization iteration) changes the 
design in any way.  If not, the algorithm stops.  If yes, then a new
iteration is run unless <code>iter_max</code> iterations have already been run.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_stop_crit_eff">stop_crit_eff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
efficiency of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_eff</code> (if <code>maximize==FALSE</code> then 1/stop_crit_eff is the cut
off and the efficiency must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_stop_crit_diff">stop_crit_diff</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_diff</code> (if <code>maximize==FALSE</code> then -stop_crit_diff is the cut
off and the difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_stop_crit_rel">stop_crit_rel</code></td>
<td>
<p>If <code>loop_methods==TRUE</code>, the looping will stop if the
relative difference in criterion value of the design after the current series (compared to the start of
the series) is less than, or equal to, <code>stop_crit_rel</code> (if <code>maximize==FALSE</code> then -stop_crit_rel is the cut
off and the relative difference in criterion value must be greater than or equal to this value to stop the looping).</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_ofv_fun">ofv_fun</code></td>
<td>
<p>User defined function used to compute the objective function. The function must have a poped database object as its first
argument and have &quot;...&quot; in its argument list.  Can be referenced as a function or as a file name where the function defined in the file has the same name as the file.
e.g. &quot;cost.txt&quot; has a function named &quot;cost&quot; in it.</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_maximize">maximize</code></td>
<td>
<p>Should the objective function be maximized or minimized?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_allow_replicates">allow_replicates</code></td>
<td>
<p>Should the algorithm allow parameters to have the same value?</p>
</td></tr>
<tr><td><code id="poped_optim_3_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes information from the PopED database supplied as an 
argument. The PopED database supplies information about the the model, 
parameters, design and methods to use. Some of the arguments coming from the 
PopED database can be overwritten; if they are supplied then they are used 
instead of the arguments from the PopED database.
</p>


<h3>References</h3>

 <ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. 
Ruggeri, &quot;PopED, a software fir optimal experimental design in population 
kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004. </p>
</li>
<li><p> J.
Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. 
Hooker, &quot;PopED: An extended, parallelized, nonlinear mixed effects models 
optimal design tool&quot;, Computer Methods and Programs in Biomedicine, 108, 
2012. </p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>

<hr>
<h2 id='poped_optimize'>Retired optimization module for PopED</h2><span id='topic+poped_optimize'></span>

<h3>Description</h3>

<p>This function is an older version of <code><a href="#topic+poped_optim">poped_optim</a></code>.  Please use <code><a href="#topic+poped_optim">poped_optim</a></code>
unless you have a specific reason to use this function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped_optimize(
  poped.db,
  ni = NULL,
  xt = NULL,
  model_switch = NULL,
  x = NULL,
  a = NULL,
  bpop = NULL,
  d = NULL,
  maxxt = NULL,
  minxt = NULL,
  maxa = NULL,
  mina = NULL,
  fmf = 0,
  dmf = 0,
  trflag = TRUE,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  opt_samps = poped.db$settings$optsw[1],
  opt_inds = poped.db$settings$optsw[5],
  cfaxt = poped.db$settings$cfaxt,
  cfaa = poped.db$settings$cfaa,
  rsit = poped.db$settings$rsit,
  rsit_output = poped.db$settings$rsit_output,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  ofv_calc_type = poped.db$settings$ofv_calc_type,
  approx_type = poped.db$settings$iApproximationMethod,
  bUseExchangeAlgorithm = poped.db$settings$bUseExchangeAlgorithm,
  iter = 1,
  d_switch = poped.db$settings$d_switch,
  ED_samp_size = poped.db$settings$ED_samp_size,
  bLHS = poped.db$settings$bLHS,
  use_laplace = poped.db$settings$iEDCalculationType,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poped_optimize_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_bpop">bpop</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number = parameter_number) we should have:
</p>

<ul>
<li><p> column 1 the type of the distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform,
3 = User Defined Distribution, 4 = lognormal and 5 = truncated normal)
</p>
</li>
<li><p> column 2  defines the mean.
</p>
</li>
<li><p> column 3 defines the variance of the distribution (or length of uniform distribution).
</p>
</li></ul>

<p>Can also just supply the parameter values as a vector <code>c()</code> if no uncertainty around the 
parameter value is to be used. The parameter order of  'bpop' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'bpop' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_d">d</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for the fixed effects 
matrix bpop to define uncertainty). One can also just supply the parameter values as a <code>c()</code>. 
The parameter order of 'd' is defined in the 'fg_fun' or 'fg_file'. If you use named 
arguments in 'd' then the order of this vector can be rearranged to match the 'fg_fun' or 'fg_file'. 
See 'reorder_parameter_vectors'.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_fmf">fmf</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_opt_samps">opt_samps</code></td>
<td>
<p>Are the number of sample times per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_opt_inds">opt_inds</code></td>
<td>
<p>Are the number of individuals per group being optimized?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_cfaxt">cfaxt</code></td>
<td>
<p>First step factor for sample times</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_cfaa">cfaa</code></td>
<td>
<p>Stochastic Gradient search first step factor for covariates</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_rsit">rsit</code></td>
<td>
<p>Number of Random search iterations</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_rsit_output">rsit_output</code></td>
<td>
<p>Number of iterations in random search between screen output</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optimize_+3A_ofv_calc_type">ofv_calc_type</code></td>
<td>
<p>OFV calculation type for FIM 
</p>
 
<ul>
<li><p> 1 = &quot;D-optimality&quot;. Determinant of the FIM: det(FIM)
</p>
</li>
<li><p> 2 = &quot;A-optimality&quot;.  Inverse of the sum of the expected parameter variances: 
1/trace_matrix(inv(FIM)) 
</p>
</li>
<li><p> 4 = &quot;lnD-optimality&quot;.  Natural logarithm of the determinant of the FIM: log(det(FIM)) 
</p>
</li>
<li><p> 6 = &quot;Ds-optimality&quot;. Ratio of the Determinant of the FIM and the Determinant of the uninteresting
rows and columns of the FIM: det(FIM)/det(FIM_u)
</p>
</li>
<li><p> 7 = Inverse of the sum of the expected parameter RSE: 1/sum(get_rse(FIM,poped.db,use_percent=FALSE))
</p>
</li></ul>
</td></tr>
<tr><td><code id="poped_optimize_+3A_approx_type">approx_type</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_buseexchangealgorithm">bUseExchangeAlgorithm</code></td>
<td>
<p>Use Exchange algorithm (1=TRUE, 0=FALSE)</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_iter">iter</code></td>
<td>
<p>The number of iterations entered into the <code>blockheader_2</code> function.</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_ed_samp_size">ED_samp_size</code></td>
<td>
<p>Sample size for E-family sampling</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_blhs">bLHS</code></td>
<td>
<p>How to sample from distributions in E-family calculations. 0=Random Sampling, 1=LatinHyperCube &ndash;</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="poped_optimize_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions. See <code><a href="#topic+Doptim">Doptim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimized the objective function.
The function works for both discrete and continuous optimization variables.
This function takes information from the PopED database supplied as an argument.
The PopED database supplies information about the the model, parameters, design and methods to use.
Some of the arguments coming from the PopED database can be overwritten;  
if they are supplied then they are used instead of the arguments from the PopED database.
</p>


<h3>References</h3>


<ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. Ruggeri, &quot;PopED, a software fir optimal 
experimental design in population kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004.
</p>
</li>
<li><p> J. Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. Hooker, &quot;PopED: An extended, 
parallelized, nonlinear mixed effects models optimal design tool&quot;,  
Computer Methods and Programs in Biomedicine, 108, 2012.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+RS_opt">RS_opt</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################


##############
# D-family Optimization
##############

# below are a number of ways to optimize the problem

# RS+SG+LS optimization of DOSE and sample times
# optimization with just a few iterations
# only to check that things are working
out_1 &lt;- poped_optimize(poped.db,opt_a=TRUE,opt_xt=TRUE,
                         rsit=2,sgit=2,ls_step_size=2, 
                         iter_max=1,out_file = "")

## Not run: 
  
  # RS+SG+LS optimization of sample times 
  # (longer run time than above but more likely to reach a maximum)
  output &lt;- poped_optimize(poped.db,opt_xt=T)
  get_rse(output$fmf,output$poped.db)
  plot_model_prediction(output$poped.db)
  
  # MFEA optimization with only integer times allowed
  mfea.output &lt;- poped_optimize(poped.db,opt_xt=1,
                                bUseExchangeAlgorithm=1,
                                EAStepSize=1)
  get_rse(mfea.output$fmf,mfea.output$poped.db)
  plot_model_prediction(mfea.output$poped.db)
  
  # Examine efficiency of sampling windows
  plot_efficiency_of_windows(mfea.output$poped.db,xt_windows=0.5)
  plot_efficiency_of_windows(mfea.output$poped.db,xt_windows=1)
  
  # Random search (just a few samples here)
  rs.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,rsit=20,
                              bUseRandomSearch= 1,
                              bUseStochasticGradient = 0,
                              bUseBFGSMinimizer = 0,
                              bUseLineSearch = 0)
  get_rse(rs.output$fmf,rs.output$poped.db)
  
  # line search, DOSE and sample time optimization
  ls.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,
                              bUseRandomSearch= 0,
                              bUseStochasticGradient = 0,
                              bUseBFGSMinimizer = 0,
                              bUseLineSearch = 1,
                              ls_step_size=10)
  
  # Stochastic gradient search, DOSE and sample time optimization
  sg.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1, 
                              bUseRandomSearch= 0,
                              bUseStochasticGradient = 1,
                              bUseBFGSMinimizer = 0,
                              bUseLineSearch = 0,
                              sgit=20)
  
  # BFGS search, DOSE and sample time optimization
  bfgs.output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,
                                bUseRandomSearch= 0,
                                bUseStochasticGradient = 0,
                                bUseBFGSMinimizer = 1,
                                bUseLineSearch = 0)
  
  ##############
  # E-family Optimization
  ##############
  
  # Adding 10% log-normal Uncertainty to fixed effects (not Favail)
  bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
  bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                           bpop_vals,
                           ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
  bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
  bpop_vals_ed_ln
  
  ## -- Define initial design  and design space
  poped.db &lt;- create.poped.database(
    ff_fun=ff.PK.1.comp.oral.sd.CL,
    fg_fun=sfg,
    fError_fun=feps.add.prop,
    bpop=bpop_vals_ed_ln, 
    notfixed_bpop=c(1,1,1,0),
    d=c(CL=0.07, V=0.02, KA=0.6), 
    sigma=c(0.01,0.25),
    groupsize=32,
    xt=c( 0.5,1,2,6,24,36,72,120),
    minxt=0,
    maxxt=120,
    a=70,
    mina=0,
    maxa=100)
  
  # ED optimization using Random search (just a few samples here)
  output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,rsit=10,d_switch=0)
  get_rse(output$fmf,output$poped.db)
  
  # ED with laplace approximation, 
  # optimization using Random search (just a few samples here)
  output &lt;- poped_optimize(poped.db,opt_xt=1,opt_a=1,rsit=10,
                           d_switch=0,use_laplace=TRUE,laplace.fim=TRUE)
  get_rse(output$fmf,output$poped.db)
  
  

## End(Not run)
</code></pre>

<hr>
<h2 id='poped.choose'>Choose between <code>arg1</code> and <code>arg2</code></h2><span id='topic+poped.choose'></span>

<h3>Description</h3>

<p>Function chooses <code>arg1</code> unless it is <code>NULL</code> in which case <code>arg2</code> is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poped.choose(arg1, arg2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poped.choose_+3A_arg1">arg1</code></td>
<td>
<p>The first argument</p>
</td></tr>
<tr><td><code id="poped.choose_+3A_arg2">arg2</code></td>
<td>
<p>The second argument</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other poped_input: 
<code><a href="#topic+convert_variables">convert_variables</a>()</code>,
<code><a href="#topic+create.poped.database">create.poped.database</a>()</code>,
<code><a href="#topic+create_design">create_design</a>()</code>,
<code><a href="#topic+create_design_space">create_design_space</a>()</code>,
<code><a href="#topic+downsizing_general_design">downsizing_general_design</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
poped.choose(2,5)

poped.choose("foo",66)

poped.choose(NULL,"hello")
</code></pre>

<hr>
<h2 id='rand'>Function written to match MATLAB's rand function</h2><span id='topic+rand'></span>

<h3>Description</h3>

<p>Generate random samples from a uniform distribution [0,1] and return in matrix form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand(dim1, dim2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rand_+3A_dim1">dim1</code></td>
<td>
<p>The dimension of the matrix (if square), otherwise the number of rows.</p>
</td></tr>
<tr><td><code id="rand_+3A_dim2">dim2</code></td>
<td>
<p>The number of columns, if different from the number of rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of random generated samples.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rand(2,3)

rand(5)
</code></pre>

<hr>
<h2 id='randn'>Function written to match MATLAB's randn function</h2><span id='topic+randn'></span>

<h3>Description</h3>

<p>Generate random samples from a standardized normal distribution and return in matrix form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randn(dim1, dim2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randn_+3A_dim1">dim1</code></td>
<td>
<p>The dimension of the matrix (if square), otherwise the number of rows.</p>
</td></tr>
<tr><td><code id="randn_+3A_dim2">dim2</code></td>
<td>
<p>The number of columns, if different from the number of rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of random generated samples.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
randn(2,3)

randn(5)
</code></pre>

<hr>
<h2 id='RS_opt'>Optimize the objective function using an adaptive random search algorithm for D-family and E-family designs.</h2><span id='topic+RS_opt'></span>

<h3>Description</h3>

<p>Optimize the objective function using an adaptive random search algorithm.  
Optimization can be performed for both D-family and E-family designs.
The function works for both discrete and continuous optimization variables.
This function takes information from the PopED database supplied as an argument.
The PopED database supplies information about the the model, parameters, design and methods to use.
Some of the arguments coming from the PopED database can be overwritten;  
by default these arguments are <code>NULL</code> in the 
function, if they are supplied then they are used instead of the arguments from the PopED database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RS_opt(
  poped.db,
  ni = NULL,
  xt = NULL,
  model_switch = NULL,
  x = NULL,
  a = NULL,
  bpopdescr = NULL,
  ddescr = NULL,
  maxxt = NULL,
  minxt = NULL,
  maxa = NULL,
  mina = NULL,
  fmf = 0,
  dmf = 0,
  trflag = TRUE,
  opt_xt = poped.db$settings$optsw[2],
  opt_a = poped.db$settings$optsw[4],
  opt_x = poped.db$settings$optsw[3],
  cfaxt = poped.db$settings$cfaxt,
  cfaa = poped.db$settings$cfaa,
  rsit = poped.db$settings$rsit,
  rsit_output = poped.db$settings$rsit_output,
  fim.calc.type = poped.db$settings$iFIMCalculationType,
  approx_type = poped.db$settings$iApproximationMethod,
  iter = NULL,
  d_switch = poped.db$settings$d_switch,
  use_laplace = poped.db$settings$iEDCalculationType,
  laplace.fim = FALSE,
  header_flag = TRUE,
  footer_flag = TRUE,
  out_file = NULL,
  compute_inv = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RS_opt_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_ni">ni</code></td>
<td>
<p>A vector of the number of samples in each group.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_xt">xt</code></td>
<td>
<p>A matrix of sample times.  Each row is a vector of sample times for a group.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_model_switch">model_switch</code></td>
<td>
<p>A matrix that is the same size as xt, specifying which model each sample belongs to.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_x">x</code></td>
<td>
<p>A matrix for the discrete design variables.  Each row is a group.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_a">a</code></td>
<td>
<p>A matrix of covariates.  Each row is a group.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_bpopdescr">bpopdescr</code></td>
<td>
<p>Matrix defining the fixed effects, per row (row number =
parameter_number) we should have: </p>
 <ul>
<li><p> column 1 the type of the
distribution for E-family designs (0 = Fixed, 1 = Normal, 2 = Uniform, 3 =
User Defined Distribution, 4 = lognormal and 5 = truncated normal) </p>
</li>
<li>
<p>column 2  defines the mean. </p>
</li>
<li><p> column 3 defines the variance of the
distribution (or length of uniform distribution). </p>
</li></ul>
</td></tr>
<tr><td><code id="RS_opt_+3A_ddescr">ddescr</code></td>
<td>
<p>Matrix defining the diagonals of the IIV (same logic as for
the <code>bpopdescr</code>).</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_maxxt">maxxt</code></td>
<td>
<p>Matrix or single value defining the maximum value for each xt sample.  If a single value is 
supplied then all xt values are given the same maximum value.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_minxt">minxt</code></td>
<td>
<p>Matrix or single value defining the minimum value for each xt sample.  If a single value is 
supplied then all xt values are given the same minimum value</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_maxa">maxa</code></td>
<td>
<p>Vector defining the max value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_mina">mina</code></td>
<td>
<p>Vector defining the min value for each covariate. If a single value is supplied then
all a values are given the same max value</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_fmf">fmf</code></td>
<td>
<p>The initial value of the FIM. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_dmf">dmf</code></td>
<td>
<p>The initial OFV. If set to zero then it is computed.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_trflag">trflag</code></td>
<td>
<p>Should the optimization be output to the screen and to a file?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_opt_xt">opt_xt</code></td>
<td>
<p>Should the sample times be optimized?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_opt_a">opt_a</code></td>
<td>
<p>Should the continuous design variables be optimized?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_opt_x">opt_x</code></td>
<td>
<p>Should the discrete design variables be optimized?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_cfaxt">cfaxt</code></td>
<td>
<p>First step factor for sample times</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_cfaa">cfaa</code></td>
<td>
<p>Stochastic Gradient search first step factor for covariates</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_rsit">rsit</code></td>
<td>
<p>Number of Random search iterations</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_rsit_output">rsit_output</code></td>
<td>
<p>Number of iterations in random search between screen output</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_fim.calc.type">fim.calc.type</code></td>
<td>
<p>The method used for calculating the FIM. Potential values:
</p>

<ul>
<li><p> 0 = Full FIM.  No assumption that fixed and random effects are uncorrelated.  
</p>
</li>
<li><p> 1 = Reduced FIM. Assume that there is no correlation in the FIM between the fixed and random effects, and set these elements in 
the FIM to zero. 
</p>
</li>
<li><p> 2 = weighted models (placeholder).
</p>
</li>
<li><p> 3 = Not currently used.
</p>
</li>
<li><p> 4 = Reduced FIM and computing all derivatives with respect to the standard deviation of the residual unexplained variation (sqrt(SIGMA) in NONMEM). 
This matches what is done in PFIM, and assumes that the standard deviation of the residual unexplained variation is the estimated parameter
(NOTE: NONMEM estimates the variance of the residual unexplained variation by default). 
</p>
</li>
<li><p> 5 = Full FIM parameterized with A,B,C matrices &amp; derivative of variance. 
</p>
</li>
<li><p> 6 = Calculate one model switch at a time, good for large matrices. 
</p>
</li>
<li><p> 7 = Reduced FIM parameterized with A,B,C matrices &amp; derivative of variance.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RS_opt_+3A_approx_type">approx_type</code></td>
<td>
<p>Approximation method for model, 0=FO, 1=FOCE, 2=FOCEI, 3=FOI.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_iter">iter</code></td>
<td>
<p>The number of iterations entered into the <code>blockheader_2</code> function.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_d_switch">d_switch</code></td>
<td>

<ul>
<li> <p><b>******START OF CRITERION SPECIFICATION OPTIONS**********</b></p>
</li></ul>

<p>D-family design (1) or ED-family design (0) (with or without parameter uncertainty)</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_use_laplace">use_laplace</code></td>
<td>
<p>Should the Laplace method be used in calculating the expectation of the OFV?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_laplace.fim">laplace.fim</code></td>
<td>
<p>Should an E(FIM) be calculated when computing the Laplace approximated E(OFV).  Typically
the FIM does not need to be computed and, if desired,  this calculation
is done using the standard MC integration technique, so can be slow.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_header_flag">header_flag</code></td>
<td>
<p>Should the header text be printed out?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_footer_flag">footer_flag</code></td>
<td>
<p>Should the footer text be printed out?</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_out_file">out_file</code></td>
<td>
<p>Which file should the output be directed to?  A string, a file handle using 
<code><a href="base.html#topic+file">file</a></code> or <code>""</code> will output to the screen.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_compute_inv">compute_inv</code></td>
<td>
<p>should the inverse of the FIM be used to compute expected RSE values?  Often not needed
except for diagnostic purposes.</p>
</td></tr>
<tr><td><code id="RS_opt_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+evaluate.fim">evaluate.fim</a></code> and <code><a href="#topic+ofv_fim">ofv_fim</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>


<ol>
<li><p> M. Foracchia, A.C. Hooker, P. Vicini and A. Ruggeri, &quot;PopED, a software fir optimal 
experimental design in population kinetics&quot;, Computer Methods and Programs in Biomedicine, 74, 2004.
</p>
</li>
<li><p> J. Nyberg, S. Ueckert, E.A. Stroemberg, S. Hennig, M.O. Karlsson and A.C. Hooker, &quot;PopED: An extended, 
parallelized, nonlinear mixed effects models optimal design tool&quot;,  
Computer Methods and Programs in Biomedicine, 108, 2012.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Optimize: 
<code><a href="#topic+Doptim">Doptim</a>()</code>,
<code><a href="#topic+LEDoptim">LEDoptim</a>()</code>,
<code><a href="#topic+a_line_search">a_line_search</a>()</code>,
<code><a href="#topic+bfgsb_min">bfgsb_min</a>()</code>,
<code><a href="#topic+calc_autofocus">calc_autofocus</a>()</code>,
<code><a href="#topic+calc_ofv_and_grad">calc_ofv_and_grad</a>()</code>,
<code><a href="#topic+mfea">mfea</a>()</code>,
<code><a href="#topic+optim_ARS">optim_ARS</a>()</code>,
<code><a href="#topic+optim_LS">optim_LS</a>()</code>,
<code><a href="#topic+poped_optim">poped_optim</a>()</code>,
<code><a href="#topic+poped_optim_1">poped_optim_1</a>()</code>,
<code><a href="#topic+poped_optim_2">poped_optim_2</a>()</code>,
<code><a href="#topic+poped_optim_3">poped_optim_3</a>()</code>,
<code><a href="#topic+poped_optimize">poped_optimize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error
## to avoid sample times at very low concentrations (time 0 or very late samoples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

# Adding 10% log-normal Uncertainty to fixed effects (not Favail)
bpop_vals &lt;- c(CL=0.15, V=8, KA=1.0, Favail=1)
bpop_vals_ed_ln &lt;- cbind(ones(length(bpop_vals),1)*4, # log-normal distribution
                         bpop_vals,
                         ones(length(bpop_vals),1)*(bpop_vals*0.1)^2) # 10% of bpop value
bpop_vals_ed_ln["Favail",]  &lt;- c(0,1,0)
bpop_vals_ed_ln

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=bpop_vals_ed_ln, 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(0.01,0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0,
                                  maxxt=120,
                                  a=70,
                                  mina=0,
                                  maxa=100)

############# END ###################
## Create PopED database
## (warfarin model for optimization
##  with parameter uncertainty)
#####################################


# Just a few iterations, optimize on DOSE and sample times using the full FIM
out_1 &lt;- RS_opt(poped.db,opt_xt=1,opt_a=1,rsit=3,fim.calc.type=0, out_file = "")

## Not run: 
  
  RS_opt(poped.db)
  
  RS_opt(poped.db,opt_xt=TRUE,rsit=100,compute_inv=F)
  RS_opt(poped.db,opt_xt=TRUE,rsit=20,d_switch=0)
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,d_switch=0,use_laplace=T)
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,d_switch=0,use_laplace=T,laplace.fim=T)
  
  ## Different headers and footers of output
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,out_file="foo.txt")
  output &lt;- RS_opt(poped.db,opt_xt=TRUE,rsit=100,trflag=FALSE)
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,out_file="")
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,header_flag=FALSE)
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,footer_flag=FALSE)
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,header_flag=FALSE,footer_flag=FALSE)
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,header_flag=FALSE,footer_flag=FALSE,out_file="foo.txt")
  RS_opt(poped.db,opt_xt=TRUE,rsit=10,header_flag=FALSE,footer_flag=FALSE,out_file="") 


## End(Not run)
</code></pre>

<hr>
<h2 id='shrinkage'>Predict shrinkage of empirical Bayes estimates (EBEs) in a population model</h2><span id='topic+shrinkage'></span>

<h3>Description</h3>

<p>Predict shrinkage of empirical Bayes estimates (EBEs) in a population model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkage(poped.db, use_mc = FALSE, num_sim_ids = 1000, use_purrr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrinkage_+3A_poped.db">poped.db</code></td>
<td>
<p>A PopED database</p>
</td></tr>
<tr><td><code id="shrinkage_+3A_use_mc">use_mc</code></td>
<td>
<p>Should the calculation be based on monte-carlo simulations. If
not then then a first order approximation is used</p>
</td></tr>
<tr><td><code id="shrinkage_+3A_num_sim_ids">num_sim_ids</code></td>
<td>
<p>If <code>use_mc=TRUE</code>, how many individuals should be
simulated to make the computations.</p>
</td></tr>
<tr><td><code id="shrinkage_+3A_use_purrr">use_purrr</code></td>
<td>
<p>If <code>use_mc=TRUE</code> then should the method use the package
purrr in calculations?  This may speed up computations (potentially).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The shrinkage computed in variance units, standard deviation units
and the relative standard errors of the EBEs.
</p>


<h3>References</h3>

 
<ol>
<li><p> Combes, F. P., Retout, S.,
Frey, N., &amp; Mentre, F. (2013). Prediction of shrinkage of individual
parameters using the Bayesian information matrix in non-linear mixed effect
models with evaluation in pharmacokinetics. Pharmaceutical Research, 30(9),
2355-67. <a href="https://doi.org/10.1007/s11095-013-1079-3">doi:10.1007/s11095-013-1079-3</a>. 
</p>
</li>
<li><p> Hennig, S., Nyberg, J., Fanta, S., Backman, J.
T., Hoppu, K., Hooker, A. C., &amp; Karlsson, M. O. (2012). Application of the
optimal design approach to improve a pretransplant drug dose finding design
for ciclosporin. Journal of Clinical Pharmacology, 52(3), 347-360.
<a href="https://doi.org/10.1177/0091270010397731">doi:10.1177/0091270010397731</a>. 
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin example)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define model, parameters, initial design
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  a=c(DOSE=70))

############# END ###################
## Create PopED database
## (warfarin example)
#####################################

shrinkage(poped.db)


</code></pre>

<hr>
<h2 id='size'>Function written to match MATLAB's size function</h2><span id='topic+size'></span>

<h3>Description</h3>

<p>Function written to match MATLAB's size function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(obj, dimension.index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="size_+3A_obj">obj</code></td>
<td>
<p>An object you want to know the various dimensions of.  Typically a matrix.</p>
</td></tr>
<tr><td><code id="size_+3A_dimension.index">dimension.index</code></td>
<td>
<p>Which dimension you are interested in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimensions of the object or specific dimension you are interested in.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
size(c(2,3,4,5,6))

size(10)

size(zeros(4,7))

</code></pre>

<hr>
<h2 id='start_parallel'>Start parallel computational processes</h2><span id='topic+start_parallel'></span>

<h3>Description</h3>

<p>This tool chooses the type of parallelization process to use based on the
computer OS being used.  For windows the default is &quot;snow&quot; and for Linux-like
systems the default is &quot;multicore&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_parallel(
  parallel = TRUE,
  num_cores = NULL,
  parallel_type = NULL,
  seed = NULL,
  dlls = NULL,
  mrgsolve_model = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_parallel_+3A_parallel">parallel</code></td>
<td>
<p>Should the parallel functionality start up?</p>
</td></tr>
<tr><td><code id="start_parallel_+3A_num_cores">num_cores</code></td>
<td>
<p>How many cores to use.  Default is
<code>parallel::detectCores()</code>-1 . See <code><a href="parallel.html#topic+detectCores">detectCores</a></code> for more information.</p>
</td></tr>
<tr><td><code id="start_parallel_+3A_parallel_type">parallel_type</code></td>
<td>
<p>Which type of parallelization should be used? Can be
&quot;snow&quot; or &quot;multicore&quot;.  &quot;snow&quot;  works on Linux-like systems &amp; Windows.
&quot;multicore&quot; works only on Linux-like systems.  By default this is chosen
for you depending on your operating system.</p>
</td></tr>
<tr><td><code id="start_parallel_+3A_seed">seed</code></td>
<td>
<p>The random seed to use.</p>
</td></tr>
<tr><td><code id="start_parallel_+3A_dlls">dlls</code></td>
<td>
<p>If the computations require compiled code (DLL's) and you are
using the &quot;snow&quot; method then you need to specify the name of the DLL's without 
the extension as a text vector <code>c("this_file","that_file")</code>.</p>
</td></tr>
<tr><td><code id="start_parallel_+3A_mrgsolve_model">mrgsolve_model</code></td>
<td>
<p>If the computations require a mrgsolve model and you 
are using the &quot;snow&quot; method&quot; then you need to specify the name of the model 
object created by <code>mread</code> or <code>mcode</code></p>
</td></tr>
<tr><td><code id="start_parallel_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An atomic vector (TRUE or FALSE) with two attributes: &quot;type&quot; and &quot;cores&quot;.
</p>

<hr>
<h2 id='summary.poped_optim'>Display a summary of output from poped_optim</h2><span id='topic+summary.poped_optim'></span>

<h3>Description</h3>

<p>Display a summary of output from poped_optim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poped_optim'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.poped_optim_+3A_object">object</code></td>
<td>
<p>An object returned from <code><a href="#topic+poped_optim">poped_optim</a></code> to summarize.</p>
</td></tr>
<tr><td><code id="summary.poped_optim_+3A_...">...</code></td>
<td>
<p>Additional arguments. Passed to <code><a href="#topic+blockfinal">blockfinal</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(PopED)

############# START #################
## Create PopED database
## (warfarin model for optimization)
#####################################

## Warfarin example from software comparison in:
## Nyberg et al., "Methods and software tools for design evaluation 
##   for population pharmacokinetics-pharmacodynamics studies", 
##   Br. J. Clin. Pharm., 2014. 

## Optimization using an additive + proportional reidual error  
## to avoid sample times at very low concentrations (time 0 or very late samples).

## find the parameters that are needed to define from the structural model
ff.PK.1.comp.oral.sd.CL

## -- parameter definition function 
## -- names match parameters in function ff
sfg &lt;- function(x,a,bpop,b,bocc){
  parameters=c(CL=bpop[1]*exp(b[1]),
               V=bpop[2]*exp(b[2]),
               KA=bpop[3]*exp(b[3]),
               Favail=bpop[4],
               DOSE=a[1])
  return(parameters) 
}

## -- Define initial design  and design space
poped.db &lt;- create.poped.database(ff_fun=ff.PK.1.comp.oral.sd.CL,
                                  fg_fun=sfg,
                                  fError_fun=feps.add.prop,
                                  bpop=c(CL=0.15, V=8, KA=1.0, Favail=1), 
                                  notfixed_bpop=c(1,1,1,0),
                                  d=c(CL=0.07, V=0.02, KA=0.6), 
                                  sigma=c(prop=0.01,add=0.25),
                                  groupsize=32,
                                  xt=c( 0.5,1,2,6,24,36,72,120),
                                  minxt=0.01,
                                  maxxt=120,
                                  a=c(DOSE=70),
                                  mina=c(DOSE=0.01),
                                  maxa=c(DOSE=100))

############# END ###################
## Create PopED database
## (warfarin model for optimization)
#####################################

##############
# D-family Optimization
##############


# ARS+BFGS+LS optimization of dose
# optimization with just a few iterations
# only to check that things are working
out_1 &lt;- poped_optim(poped.db,opt_a =TRUE,
                      control = list(ARS=list(iter=2),
                                     BFGS=list(maxit=2),
                                     LS=list(line_length=2)),
                      iter_max = 1)


summary(out_1)
</code></pre>

<hr>
<h2 id='test_mat_size'>Test to make sure that matricies are the right size</h2><span id='topic+test_mat_size'></span>

<h3>Description</h3>

<p>Test to make sure that matricies are the right size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_mat_size(correct_size, mat, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_mat_size_+3A_correct_size">correct_size</code></td>
<td>
<p>the correct size of a matrix</p>
</td></tr>
<tr><td><code id="test_mat_size_+3A_mat">mat</code></td>
<td>
<p>The matrix to test.</p>
</td></tr>
<tr><td><code id="test_mat_size_+3A_name">name</code></td>
<td>
<p>The name of the matrix as a string.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
test_mat_size(c(2,3),zeros(2,3),"foo")

## Not run: 
  test_mat_size(c(2,3),zeros(2,6),"foo")

## End(Not run)

test_mat_size(c(1,3),c(2,6,7),"foo")



</code></pre>

<hr>
<h2 id='tic'>Timer function (as in MATLAB)</h2><span id='topic+tic'></span>

<h3>Description</h3>

<p>Function to start a timer.  Stop with toc().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tic(gcFirst = FALSE, name = ".poped_savedTime")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tic_+3A_gcfirst">gcFirst</code></td>
<td>
<p>Perform garbage collection?</p>
</td></tr>
<tr><td><code id="tic_+3A_name">name</code></td>
<td>
<p>The saved name of the time object.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a modified version of the same function in the matlab R-package.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tic()
toc()

tic(name="foo")
toc()
tic()
toc()
toc()
tic()
toc(name="foo")
</code></pre>

<hr>
<h2 id='toc'>Timer function (as in MATLAB)</h2><span id='topic+toc'></span>

<h3>Description</h3>

<p>Function to stop a timer.  Start with tic().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toc(echo = TRUE, name = ".poped_savedTime")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toc_+3A_echo">echo</code></td>
<td>
<p>Print time to screen?</p>
</td></tr>
<tr><td><code id="toc_+3A_name">name</code></td>
<td>
<p>The saved name of the time object.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a modified version of the same function in the matlab R-package.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+zeros">zeros</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tic()
toc()

tic(name="foo")
toc()
tic()
toc()
toc()
tic()
toc(name="foo")
</code></pre>

<hr>
<h2 id='tryCatch.W.E'>tryCatch both warnings (with value) and errors</h2><span id='topic+tryCatch.W.E'></span>

<h3>Description</h3>

<p>Catch *and* save both errors and warnings, and in the case of
a warning, also keep the computed result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryCatch.W.E(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tryCatch.W.E_+3A_expr">expr</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> expression to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 'value' and 'warning', where
'value' may be an error caught.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, The R Core Team
</p>

<hr>
<h2 id='zeros'>Create a matrix of zeros.</h2><span id='topic+zeros'></span>

<h3>Description</h3>

<p>Create a matrix of zeros of size (dim1 x dim2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeros(dim1, dim2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zeros_+3A_dim1">dim1</code></td>
<td>
<p>The dimension of the matrix (if square) or the number of rows.</p>
</td></tr>
<tr><td><code id="zeros_+3A_dim2">dim2</code></td>
<td>
<p>The number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of zeros.
</p>


<h3>See Also</h3>

<p>Other MATLAB: 
<code><a href="#topic+cell">cell</a>()</code>,
<code><a href="#topic+diag_matlab">diag_matlab</a>()</code>,
<code><a href="#topic+feval">feval</a>()</code>,
<code><a href="#topic+fileparts">fileparts</a>()</code>,
<code><a href="#topic+isempty">isempty</a>()</code>,
<code><a href="#topic+ones">ones</a>()</code>,
<code><a href="#topic+rand">rand</a>()</code>,
<code><a href="#topic+randn">randn</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tic">tic</a>()</code>,
<code><a href="#topic+toc">toc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zeros(3)
zeros(0,3)
zeros(4,7)
zeros(1,4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
