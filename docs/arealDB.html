<!DOCTYPE html><html lang="en-gb"><head><title>Help for package arealDB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {arealDB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.editMatches'><p>Edit matches manually in a csv-table</p></a></li>
<li><a href='#.getColTypes'><p>Get the column types of a tibble</p></a></li>
<li><a href='#.matchOntology'><p>Match target terms with an ontology</p></a></li>
<li><a href='#.updateOntology'><p>Update an ontology</p></a></li>
<li><a href='#adb_archive'><p>Archive the data from an areal database</p></a></li>
<li><a href='#adb_backup'><p>Backup the current state of an areal database</p></a></li>
<li><a href='#adb_diagnose'><p>Diagnose databse contents</p></a></li>
<li><a href='#adb_example'><p>Build an example areal database</p></a></li>
<li><a href='#adb_init'><p>Initiate an areal database</p></a></li>
<li><a href='#adb_inventory'><p>Load the inventory of the currently active areal database</p></a></li>
<li><a href='#adb_metadata'><p>Load the metadata from an areal database</p></a></li>
<li><a href='#adb_ontology'><p>Load the currently active ontology</p></a></li>
<li><a href='#adb_querry'><p>Extract database contents</p></a></li>
<li><a href='#adb_reset'><p>Reset an areal database to its unfilled state</p></a></li>
<li><a href='#adb_restore'><p>Restore the database from a backup</p></a></li>
<li><a href='#adb_schemas'><p>Load the schemas of the currently active areal database</p></a></li>
<li><a href='#adb_translations'><p>Load the translation tables of the currently active areal database</p></a></li>
<li><a href='#normGeometry'><p>Normalise geometries</p></a></li>
<li><a href='#normTable'><p>Normalise data tables</p></a></li>
<li><a href='#regDataseries'><p>Register a new dataseries</p></a></li>
<li><a href='#regGeometry'><p>Register a new geometry entry</p></a></li>
<li><a href='#regTable'><p>Register a new areal data table</p></a></li>
<li><a href='#territories'><p>Example <code>gazetteer</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Harmonise and Integrate Heterogeneous Areal Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Many relevant applications in the environmental and socioeconomic 
    sciences use areal data, such as biodiversity checklists, agricultural statistics, 
    or socioeconomic surveys. For applications that surpass the spatial, temporal or 
    thematic scope of any single data source, data must be integrated from several 
    heterogeneous sources. Inconsistent concepts, definitions, or messy data tables 
    make this a tedious and error-prone process. 'arealDB' tackles those problems and 
    helps the user to integrate a harmonised databases of areal data. Read the paper
    at Ehrmann, Seppelt &amp; Meyer (2020) &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2020.104799">doi:10.1016/j.envsoft.2020.104799</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.4</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/luckinet/arealDB">https://github.com/luckinet/arealDB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luckinet/arealDB/issues">https://github.com/luckinet/arealDB/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>archive, beepr, checkmate, dplyr, fuzzyjoin, magrittr,
ontologics, progress, purrr, readr, rlang, rmapshaper, stringr,
sf, tabshiftr, tibble, tidyr, tidyselect,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, bookdown, covr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-gb</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-20 13:26:14 UTC; se87kuhe</td>
</tr>
<tr>
<td>Author:</td>
<td>Steffen Ehrmann <a href="https://orcid.org/0000-0002-2958-0796"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Arne RÃ¼mmler <a href="https://orcid.org/0000-0001-8637-9071"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Felipe Melges <a href="https://orcid.org/0000-0003-0833-8973"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Carsten Meyer <a href="https://orcid.org/0000-0003-3927-5856"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steffen Ehrmann &lt;steffen.ehrmann@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-20 13:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.editMatches'>Edit matches manually in a csv-table</h2><span id='topic+.editMatches'></span>

<h3>Description</h3>

<p>Allows the user to match concepts with an already existing ontology, without
actually writing into the ontology, but instead storing the resulting
matching table as csv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.editMatches(
  new,
  topLevel,
  source = NULL,
  ontology = NULL,
  matchDir = NULL,
  stringdist = TRUE,
  verbose = TRUE,
  beep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".editMatches_+3A_new">new</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame(.)</a></code><br /> the new concepts that shall be
manually matched, includes &quot;label&quot;, &quot;class&quot; and &quot;has_broader&quot; columns.</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_toplevel">topLevel</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the new concepts
are at the highest level only, i.e., have to be matched without context, or
whether they are contain columns that must be matched within parent
columns.</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_source">source</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> any character uniquely
identifying the source dataset of the new concepts.</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">ontology(1)</a></code><br /> either a path where the ontology is
stored, or an already loaded ontology.</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_matchdir">matchDir</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the directory where to store
source-specific matching tables.</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_stringdist">stringdist</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to use string
distance to find matches (should not be used for large datasets/when a
memory error is shown).</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to give detailed
information on the process of this function.</p>
</td></tr>
<tr><td><code id=".editMatches_+3A_beep">beep</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code><a href="beepr.html#topic+beep">beep</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to match new concepts into an already existing ontology, it
may become necessary to carry out manual matches of the new concepts with
already harmonised concepts, for example, when the new concepts are
described with terms that are not yet in the ontology. This function puts
together a table, in which the user would edit matches by hand. Whith the
argument <code>verbose = TRUE</code>, detailed information about the edit process
are shown to the user. After defining matches, and even if not all
necessary matches are finished, the function stores a specific &quot;matching
table&quot; with the name <em>match_SOURCE.csv</em> in the respective directory
(<code>matchDir</code>), from where work can be picked up and continued at
another time.
</p>
<p>Fuzzy matching is carried out and matches with 0, 1 or 2 differing
charcters are presented in a respective column.
</p>


<h3>Value</h3>

<p>A table that contains all new matches, or if none of the new concepts
weren't already in the ontology, a table of the already sucessful matches.
</p>

<hr>
<h2 id='.getColTypes'>Get the column types of a tibble</h2><span id='topic+.getColTypes'></span>

<h3>Description</h3>

<p>(internal function not for user interaction)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getColTypes(input = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".getColTypes_+3A_input">input</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a><br /> table from which to get column
types.</p>
</td></tr>
</table>

<hr>
<h2 id='.matchOntology'>Match target terms with an ontology</h2><span id='topic+.matchOntology'></span>

<h3>Description</h3>

<p>This function takes a table to replace the values of various columns with
harmonised values listed in the project specific gazetteer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.matchOntology(
  table = NULL,
  columns = NULL,
  dataseries = NULL,
  ontology = NULL,
  beep = NULL,
  colsAsClass = TRUE,
  groupMatches = FALSE,
  stringdist = TRUE,
  strictMatch = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".matchOntology_+3A_table">table</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame(1)</a></code><br /> a table that contains columns
that should be harmonised by matching with the gazetteer.</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_columns">columns</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the columns containing the
concepts</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_dataseries">dataseries</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the source dataseries from
which territories are sourced.</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="ontologics.html#topic+onto-class">onto</a></code><br /> path where the ontology/gazetteer is stored.</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_beep">beep</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code><a href="beepr.html#topic+beep">beep</a></code>.</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_colsasclass">colsAsClass</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether to match <code>columns</code>
by their name with the respective classes, or with concepts of all classes.</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_groupmatches">groupMatches</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to group
harmonized concepts when there are more than one match (for example for
broader or narrower matches).</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_stringdist">stringdist</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to use string
distance to find matches (should not be used for large datasets/when a
memory error is shown).</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_strictmatch">strictMatch</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not matches are
strict, i.e., there should be clear one-to-one relationships and no changes
in broader concepts.</p>
</td></tr>
<tr><td><code id=".matchOntology_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to give detailed
information on the process of this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table that resembles the input table where the target
columns were translated according to the provided ontology.
</p>

<hr>
<h2 id='.updateOntology'>Update an ontology</h2><span id='topic+.updateOntology'></span>

<h3>Description</h3>

<p>This function takes a table (spatial) and updates all territorial concepts in
the provided gazetteer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.updateOntology(
  table = NULL,
  threshold = NULL,
  dataseries = NULL,
  ontology = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".updateOntology_+3A_table">table</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> a table that contains a match
column as the basis to update the gazetteer.</p>
</td></tr>
<tr><td><code id=".updateOntology_+3A_threshold">threshold</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric(1)</a></code><br /> a threshold value above which
matches are updated in the gazetteer.</p>
</td></tr>
<tr><td><code id=".updateOntology_+3A_dataseries">dataseries</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the source dataseries of the
external concepts for which the gazetteer shall be updated.</p>
</td></tr>
<tr><td><code id=".updateOntology_+3A_ontology">ontology</code></td>
<td>
<p><a href="ontologics.html#topic+onto-class">onto</a><br /> path where the ontology/gazetteer
is stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>called for its side-effect of updating a gazetteer
</p>

<hr>
<h2 id='adb_archive'>Archive the data from an areal database</h2><span id='topic+adb_archive'></span>

<h3>Description</h3>

<p>Archive the data from an areal database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_archive(pattern = NULL, variables = NULL, compress = FALSE, outPath = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_archive_+3A_pattern">pattern</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> a regular expression used to
filter files to load.</p>
</td></tr>
<tr><td><code id="adb_archive_+3A_variables">variables</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> columns, typically observed
variables, to select.</p>
</td></tr>
<tr><td><code id="adb_archive_+3A_compress">compress</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the database should
be compressed into a <em>tar.gz</em> archive. Will delete the database folder
in <code>outPath</code>.</p>
</td></tr>
<tr><td><code id="adb_archive_+3A_outpath">outPath</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> directory, where the archive
should be stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prepares and packages the data into an archiveable
form. This contains geopacakge files for geometries and csv files for all
tables, such as inventory, matching and thematic data tables.
</p>


<h3>Value</h3>

<p>no return value, called for the side-effect of creating a database
archive.
</p>

<hr>
<h2 id='adb_backup'>Backup the current state of an areal database</h2><span id='topic+adb_backup'></span>

<h3>Description</h3>

<p>Backup the current state of an areal database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_backup()
</code></pre>


<h3>Details</h3>

<p>This function creates a tag that is composed of the version and the
date, appends it to all stage3 files (tables and geometries), the inventory
and the ontology/gazetteer files and stores them in the backup folder of
the current areal database.
</p>


<h3>Value</h3>

<p>No return value, called for the side effect of saving the inventory,
the stage3 files and modified ontology/gazetteer into the backup directory.
</p>

<hr>
<h2 id='adb_diagnose'>Diagnose databse contents</h2><span id='topic+adb_diagnose'></span>

<h3>Description</h3>

<p>work in progress, not yet useable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_diagnose(
  territory = NULL,
  concept = NULL,
  variable = NULL,
  level = NULL,
  year = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_diagnose_+3A_territory">territory</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_diagnose_+3A_concept">concept</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_diagnose_+3A_variable">variable</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_diagnose_+3A_level">level</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_diagnose_+3A_year">year</code></td>
<td>
<p>description</p>
</td></tr>
</table>

<hr>
<h2 id='adb_example'>Build an example areal database</h2><span id='topic+adb_example'></span>

<h3>Description</h3>

<p>This function helps setting up an example database up until a certain step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_example(path = NULL, until = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_example_+3A_path">path</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> The database gets created by
default in tempdir(), but if you want it in a particular location, specify
that in this argument.</p>
</td></tr>
<tr><td><code id="adb_example_+3A_until">until</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> The database building step in
terms of the function names until which the example database shall be
built, one of <code>"start_arealDB"</code>, <code>"regDataseries"</code>,
<code>"regGeometry"</code>, <code>"regTable"</code>, <code>"normGeometry"</code> or
<code>"normTable"</code>.</p>
</td></tr>
<tr><td><code id="adb_example_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> be verbose about building the
example database (default <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting up a database with an R-based tool can appear to be
cumbersome and too complex and thus intimidating. By creating an example
database, this functions allows interested users to learn step by step how
to build a database of areal data. Moreover, all functions in this package
contain verbose information and ask for information that would be missing
or lead to an inconsistent database, before a failure renders hours of work
useless.
</p>


<h3>Value</h3>

<p>No return value, called for the side effect of creating an example
database at the specified <code>path</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
# to build the full example database
adb_example(path = paste0(tempdir(), "/newDB"))

# to make the example database until a certain step
adb_example(path = paste0(tempdir(), "/newDB"), until = "regDataseries")

}
</code></pre>

<hr>
<h2 id='adb_init'>Initiate an areal database</h2><span id='topic+adb_init'></span>

<h3>Description</h3>

<p>Initiate a geospatial database or register a database that exists at the root
path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_init(
  root,
  version,
  author,
  licence,
  ontology,
  gazetteer = NULL,
  top = NULL,
  staged = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_init_+3A_root">root</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> path to the root directory that
contains or shall contain an areal database.</p>
</td></tr>
<tr><td><code id="adb_init_+3A_version">version</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> version identifier for this
areal database.</p>
</td></tr>
<tr><td><code id="adb_init_+3A_author">author</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> authors that contributed to
building this areal database. Should be a list with items <code>"cre"</code>
(creator), <code>"aut"</code> (authors) and <code>"ctb"</code> (contributors).</p>
</td></tr>
<tr><td><code id="adb_init_+3A_licence">licence</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> licence (link) for this areal
database.</p>
</td></tr>
<tr><td><code id="adb_init_+3A_ontology">ontology</code></td>
<td>
<p><code><a href="base.html#topic+list">list(.)</a></code><br /> named list with the path(s) of
ontologies, where the list name identifies the variable that shall be
matched with the ontology at the path.</p>
</td></tr>
<tr><td><code id="adb_init_+3A_gazetteer">gazetteer</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> path to the gazetteer that
holds the (hierarchical) information of territorial units used in this
database.</p>
</td></tr>
<tr><td><code id="adb_init_+3A_top">top</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the label of the class in the
gazetteer that represents the top-most unit (e.g. country) of the areal
database that shall be started.</p>
</td></tr>
<tr><td><code id="adb_init_+3A_staged">staged</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the file structure is
arranged according to stages (with geometries and tables separated), or
merely as input/output (of all types).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the first function that is run in a project, as it initiates
the areal database by creating the default sub-directories and initial
inventory tables. When a database has already been set up, this function is
used to register that path in the options of the current R session.
</p>


<h3>Value</h3>

<p>No return value, called for the side effect of creating the
directory structure of the new areal database and tables that contain the
database metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adb_init(root = paste0(tempdir(), "/newDB"),
         version = "1.0.0", licence = "CC-BY-0.4",
         author = list(cre = "Gordon Freeman", aut = "Alyx Vance", ctb = "The G-Man"),
         gazetteer = paste0(tempdir(), "/newDB/territories.rds"),
         top = "al1",
         ontology = list(var = paste0(tempdir(), "/newDB/ontology.rds")))

getOption("adb_path"); getOption("gazetteer_path")
</code></pre>

<hr>
<h2 id='adb_inventory'>Load the inventory of the currently active areal database</h2><span id='topic+adb_inventory'></span>

<h3>Description</h3>

<p>Load the inventory of the currently active areal database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_inventory(type = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_inventory_+3A_type">type</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the inventory sub-table to load,
either <code>"dataseries"</code>, <code>"tables"</code>, <code>"geometries"</code> or
<code>"references"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the table selected in <code>type</code>
</p>

<hr>
<h2 id='adb_metadata'>Load the metadata from an areal database</h2><span id='topic+adb_metadata'></span>

<h3>Description</h3>

<p>Load the metadata from an areal database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_metadata()
</code></pre>

<hr>
<h2 id='adb_ontology'>Load the currently active ontology</h2><span id='topic+adb_ontology'></span>

<h3>Description</h3>

<p>Load the currently active ontology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_ontology(..., type = "ontology")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_ontology_+3A_...">...</code></td>
<td>
<p>combination of column name in the ontology and value to filter
that column by to build a tree of the concepts nested into it; see
<code><a href="ontologics.html#topic+make_tree">make_tree</a></code>.</p>
</td></tr>
<tr><td><code id="adb_ontology_+3A_type">type</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the type of ontology to load,
either <code>"ontology"</code> to get the thematic concepts, or
<code>"gazetteer"</code> to get the territories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a tidy table of an ontology or gazetteer that is used in an
areal database.
</p>

<hr>
<h2 id='adb_querry'>Extract database contents</h2><span id='topic+adb_querry'></span>

<h3>Description</h3>

<p>Extract database contents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_querry(
  territory = NULL,
  concept = NULL,
  variable = NULL,
  level = NULL,
  year = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_querry_+3A_territory">territory</code></td>
<td>
<p><a href="base.html#topic+character">'character(.)</a><br /> combination of column name in
the ontology and value to filter that column by to build a tree of the
territories nested into it.</p>
</td></tr>
<tr><td><code id="adb_querry_+3A_concept">concept</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_querry_+3A_variable">variable</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_querry_+3A_level">level</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="adb_querry_+3A_year">year</code></td>
<td>
<p>description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
adb_example(path = paste0(tempdir(), "/newDB"))

adb_querry(territory = list(al1 = "a_nation"),
           concept = list(commodity = "barley"),
           variable = "harvested")
}
</code></pre>

<hr>
<h2 id='adb_reset'>Reset an areal database to its unfilled state</h2><span id='topic+adb_reset'></span>

<h3>Description</h3>

<p>Reset an areal database to its unfilled state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_reset(what = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_reset_+3A_what">what</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> what to reset, either <code>"onto"</code>,
<code>"gaz"</code>, <code>"schemas"</code>, <code>"tables"</code>, <code>"geometries"</code> or
<code>"all"</code>, the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value, called for its side effect of reorganising an areal
database into a state where no reg* or norm* functions have been run
</p>

<hr>
<h2 id='adb_restore'>Restore the database from a backup</h2><span id='topic+adb_restore'></span>

<h3>Description</h3>

<p>Restore the database from a backup
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_restore(version = NULL, date = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_restore_+3A_version">version</code></td>
<td>
<p><a href="base.html#topic+character">'character(1)</a><br /> a version tag for which to
restore files.</p>
</td></tr>
<tr><td><code id="adb_restore_+3A_date">date</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> a date for which to restore files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function searches for files that have the version and date tag,
as it was defined in a previous run of <code><a href="#topic+adb_backup">adb_backup</a></code>, to restore
them to their original folders. This function overwrites by default, so use
with care.
</p>


<h3>Value</h3>

<p>No return value, called for the side effect of restoring files that
were previously stored in a backup.
</p>

<hr>
<h2 id='adb_schemas'>Load the schemas of the currently active areal database</h2><span id='topic+adb_schemas'></span>

<h3>Description</h3>

<p>Load the schemas of the currently active areal database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_schemas(pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_schemas_+3A_pattern">pattern</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> an optional regular expression.
Only schema names which match the regular expression will be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of schema descriptions
</p>

<hr>
<h2 id='adb_translations'>Load the translation tables of the currently active areal database</h2><span id='topic+adb_translations'></span>

<h3>Description</h3>

<p>Load the translation tables of the currently active areal database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adb_translations(type = NULL, dataseries = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adb_translations_+3A_type">type</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the type of ontology for which to
load translation tables, either <code>"ontology"</code> to get the thematic
concepts, or <code>"gazetteer"</code> to get the territories.</p>
</td></tr>
<tr><td><code id="adb_translations_+3A_dataseries">dataseries</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the name of a dataseries as
registered in <code><a href="#topic+regDataseries">regDataseries</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the selected translation table
</p>

<hr>
<h2 id='normGeometry'>Normalise geometries</h2><span id='topic+normGeometry'></span>

<h3>Description</h3>

<p>Harmonise and integrate geometries into a standardised format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normGeometry(
  input = NULL,
  pattern = NULL,
  query = NULL,
  thresh = 10,
  beep = NULL,
  simplify = FALSE,
  stringdist = TRUE,
  strictMatch = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normGeometry_+3A_input">input</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> path of the file to normalise. If
this is left empty, all files at stage two as subset by <code>pattern</code> are
chosen.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_pattern">pattern</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> an optional regular expression.
Only dataset names which match the regular expression will be processed.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_query">query</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> part of the SQL query (starting
from
WHERE) used to subset the input geometries, for example <code>"where NAME_0
  = 'Estonia'"</code>. The first part of the query (where the layer is defined) is
derived from the meta-data of the currently handled geometry.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_thresh">thresh</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> percent value of overlap below
which two geometries (the input and the base) are considered to be the
same. This is required, because often the polygons from different sources,
albeit describing the same territorial unit, aren't completely the same.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_beep">beep</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code><a href="beepr.html#topic+beep">beep</a></code>.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_simplify">simplify</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to simplify
geometries.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_stringdist">stringdist</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to use string
distance to find matches (should not be used for large datasets/when a
memory error is shown).</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_strictmatch">strictMatch</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not matches are
strict, i.e., there should be clear one-to-one relationships and no changes
in broader concepts.</p>
</td></tr>
<tr><td><code id="normGeometry_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> be verbose about what is happening
(default <code>FALSE</code>). Furthermore, you can use
<code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> to make this function completely silent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To normalise geometries, this function proceeds as follows:
</p>
 <ol>
<li><p> Read in <code>input</code> and extract initial metadata from
the file name. </p>
</li>
<li><p> In case filters are set, the new geometry is filtered
by those. </p>
</li>
<li><p> The territorial names are matched with the gazetteer to
harmonise new territorial names (at this step, the function might ask the
user to edit the file 'matching.csv' to align new names with already
harmonised names). </p>
</li>
<li><p> Loop through every nation potentially included in
the file that shall be processed and carry out the following steps:
</p>
 <ul>
<li><p> In case the geometries are provided as a list of simple
feature POLYGONS, they are dissolved into a single MULTIPOLYGON per main
polygon. </p>
</li>
<li><p> In case the nation to which a geometry belongs has not yet
been created at stage three, the following steps are carried out:
</p>
 <ol>
<li><p> Store the current geometry as basis of the respective
level (the user needs to make sure that all following levels of the same
dataseries are perfectly nested into those parent territories, for example
by using the GADM dataset) </p>
</li></ol>
 </li>
<li><p> In case the nation to which the geometry
belongs has already been created, the following steps are carried out:
</p>
 <ol>
<li><p> Check whether the new geometries have the same coordinate
reference system as the already existing database and re-project the new
geometries if this is not the case. </p>
</li>
<li><p> Check whether all new geometries
are already exactly matched spatially and stop if that is the case. </p>
</li>
<li>
<p>Check whether the new geometries are all within the already defined
parents, and save those that are not as a new geometry. </p>
</li>
<li><p> Calculate
spatial overlap and distinguish the geometries into those that overlap with
more and those with less than <code>thresh</code>. </p>
</li>
<li><p> For all units that dName
match, copy gazID from the geometries they overlap. </p>
</li>
<li><p> For all units
that dName not match, rebuild metadata and a new gazID.</p>
</li></ol>
 </li>
<li><p> store the
processed geometry at stage three.</p>
</li></ul>
 </li>
<li><p> Move the geometry to the folder
'/processed', if it is fully processed.</p>
</li></ol>



<h3>Value</h3>

<p>This function harmonises and integrates so far unprocessed geometries
at stage two into stage three of the geospatial database. It produces for
each main polygon (e.g. nation) in the registered geometries a spatial file
of the specified file-type.
</p>


<h3>See Also</h3>

<p>Other normalise functions: 
<code><a href="#topic+normTable">normTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
  library(sf)

  # build the example database
  adb_example(until = "regGeometry", path = tempdir())

  # normalise all geometries ...
  normGeometry(pattern = "estonia")

  # ... and check the result
  st_layers(paste0(tempdir(), "/geometries/stage3/Estonia.gpkg"))
  output &lt;- st_read(paste0(tempdir(), "/geometries/stage3/Estonia.gpkg"))
}
</code></pre>

<hr>
<h2 id='normTable'>Normalise data tables</h2><span id='topic+normTable'></span>

<h3>Description</h3>

<p>Harmonise and integrate data tables into standardised format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normTable(
  input = NULL,
  pattern = NULL,
  query = NULL,
  ontoMatch = NULL,
  beep = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normTable_+3A_input">input</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> path of the file to normalise. If
this is left empty, all files at stage two as subset by <code>pattern</code> are
chosen.</p>
</td></tr>
<tr><td><code id="normTable_+3A_pattern">pattern</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> an optional regular expression.
Only dataset names which match the regular expression will be processed.</p>
</td></tr>
<tr><td><code id="normTable_+3A_query">query</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the expression that would be used
in <code><a href="dplyr.html#topic+filter">filter</a></code> to subset a tibble in terms of the columns
defined via the schema and given as a single character string, such as
<code>"al1 == 'Estonia'"</code>.</p>
</td></tr>
<tr><td><code id="normTable_+3A_ontomatch">ontoMatch</code></td>
<td>
<p><code><a href="base.html#topic+character">character(.)</a></code><br /> name of the column(s) that
shall be matched with an ontology (defined in <code><a href="#topic+adb_init">adb_init</a></code>).</p>
</td></tr>
<tr><td><code id="normTable_+3A_beep">beep</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> Number specifying what sound to be
played to signal the user that a point of interaction is reached by the
program, see <code><a href="beepr.html#topic+beep">beep</a></code>.</p>
</td></tr>
<tr><td><code id="normTable_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> be verbose about translating terms
(default <code>FALSE</code>). Furthermore, you can use
<code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> to make this function completely silent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To normalise data tables, this function proceeds as follows:
</p>
 <ol>
<li><p> Read in <code>input</code> and extract initial metadata from
the file name. </p>
</li>
<li><p> Employ the function
<code><a href="tabshiftr.html#topic+reorganise">tabshiftr::reorganise()</a></code> to reshape <code>input</code> according to
the respective schema description. </p>
</li>
<li><p> The territorial names are matched
with the gazetteer to harmonise new territorial names (at this step, the
function might ask the user to edit the file 'matching.csv' to align new
names with already harmonised names). </p>
</li>
<li><p> Harmonise territorial unit
names. </p>
</li>
<li><p> store the processed data table at
stage three.</p>
</li></ol>



<h3>Value</h3>

<p>This function harmonises and integrates so far unprocessed data
tables at stage two into stage three of the areal database. It produces for
each main polygon (e.g. nation) in the registered data tables a file that
includes all thematic areal data.
</p>


<h3>See Also</h3>

<p>Other normalise functions: 
<code><a href="#topic+normGeometry">normGeometry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
  # build the example database
  adb_example(until = "normGeometry", path = tempdir())

  # normalise all available data tables ...
  normTable()

  # ... and check the result
  output &lt;- readRDS(paste0(tempdir(), "/tables/stage3/Estonia.rds"))
}
</code></pre>

<hr>
<h2 id='regDataseries'>Register a new dataseries</h2><span id='topic+regDataseries'></span>

<h3>Description</h3>

<p>This function registers a new dataseries of both, geometries or areal data
into the geospatial database. This contains the name and relevant meta-data
of a dataseries to enable provenance tracking and reproducability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regDataseries(
  name = NULL,
  description = NULL,
  homepage = NULL,
  version = NULL,
  licence_link = NULL,
  reference = NULL,
  notes = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regDataseries_+3A_name">name</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the dataseries abbreviation or
name.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_description">description</code></td>
<td>
<p><code><a href="base.html#topic+character">character()</a></code><br /> the &quot;long name&quot; or &quot;brief
description&quot; of the dataseries.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_homepage">homepage</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the homepage of the data
provider where the dataseries or additional information can be found.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_version">version</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the version number or date when
meta data of the dataseries were recorded.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_licence_link">licence_link</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> link to the licence or the
webpage from which the licence was copied.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_reference">reference</code></td>
<td>
<p><code><a href="utils.html#topic+bibentry">bibentry(1)</a></code><br /> in case the dataseries comes
with a reference, provide this here as bibentry object.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_notes">notes</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optional notes.</p>
</td></tr>
<tr><td><code id="regDataseries_+3A_overwrite">overwrite</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the dataseries to
register shall overwrite a potentially already existing older version.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble of the new entry that is appended to
'inv_dataseries.csv'.
</p>


<h3>See Also</h3>

<p>Other register functions: 
<code><a href="#topic+regGeometry">regGeometry</a>()</code>,
<code><a href="#topic+regTable">regTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
  # start the example database
  adb_exampleDB(until = "match_gazetteer", path = tempdir())

  regDataseries(name = "gadm",
                description = "Database of Global Administrative Areas",
                version = "3.6",
                homepage = "https://gadm.org/index.html",
                licence_link = "https://gadm.org/license.html")
}
</code></pre>

<hr>
<h2 id='regGeometry'>Register a new geometry entry</h2><span id='topic+regGeometry'></span>

<h3>Description</h3>

<p>This function registers a new geometry of territorial units into the
geospatial database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regGeometry(
  ...,
  subset = NULL,
  gSeries = NULL,
  label = NULL,
  ancillary = NULL,
  layer = NULL,
  archive = NULL,
  archiveLink = NULL,
  downloadDate = NULL,
  updateFrequency = NULL,
  notes = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regGeometry_+3A_...">...</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optional named argument selecting
the main territory into which this geometry is nested. The name of this
must be a class of the gazetteer and the value must be one of the territory
names of that class, e.g. <em>nation = &quot;Estonia&quot;</em>.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_subset">subset</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optional argument to specify
which subset the file contains. This could be a subset of territorial units
(e.g. only one municipality) or of a target variable.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_gseries">gSeries</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the name of the geometry
dataseries (see <code><a href="#topic+regDataseries">regDataseries</a></code>).</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_label">label</code></td>
<td>
<p><code><a href="base.html#topic+list">list(.)</a></code><br /> list of as many columns as there are in
common in the ontology and this geometry. Must be of the form
<code>list(class = columnName)</code>, with 'class' as the class of the ontology
corresponding to the respective column name in the geometry.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_ancillary">ancillary</code></td>
<td>
<p><code><a href="base.html#topic+list">list(.)</a></code><br /> optinal list of columns containing
ancillary information. Must be of the form <code>list(attribute =
  columnName)</code>, where <code>attribute</code> can be one or
several of </p>

<ul>
<li> <p><code>"name_ltn"</code> (the english name in latin letters)
</p>
</li>
<li> <p><code>"name_lcl"</code> (the name in local language and letters)
</p>
</li>
<li> <p><code>"code"</code> (any code describing the unit)
</p>
</li>
<li> <p><code>"type"</code> (the type of territorial unit)
</p>
</li>
<li> <p><code>"uri"</code> (the semantic web URI) or
</p>
</li>
<li> <p><code>"flag"</code> (any flag attributed to the unit).</p>
</li></ul>
</td></tr>
<tr><td><code id="regGeometry_+3A_layer">layer</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the name of the file's layer from
which the geometry should be created (if applicable).</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_archive">archive</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the original file (perhaps a
*.zip) from which the geometry emerges.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_archivelink">archiveLink</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> download-link of the
archive.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_downloaddate">downloadDate</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> value describing the
download date of this dataset (in YYYY-MM-DD format).</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_updatefrequency">updateFrequency</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> value describing the
frequency with which the dataset is updated, according to the ISO 19115
Codelist, MD_MaintenanceFrequencyCode. Possible values are: 'continual',
'daily', 'weekly', 'fortnightly', 'quarterly', 'biannually', 'annually',
'asNeeded', 'irregular', 'notPlanned', 'unknown', 'periodic',
'semimonthly', 'biennially'.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_notes">notes</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optional notes that are assigned
to all features of this geometry.</p>
</td></tr>
<tr><td><code id="regGeometry_+3A_overwrite">overwrite</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the geometry to
register shall overwrite a potentially already existing older version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When processing geometries to which areal data shall be linked,
carry out the following steps: </p>
 <ol>
<li><p> Determine the main
territory (such as a nation, or any other polygon), a <code>subset</code> (if
applicable), the dataseries of the geometry and the ontology <code>label</code>,
and provide them as arguments to this function. </p>
</li>
<li><p> Run the function.
</p>
</li>
<li><p> Export the shapefile with the following properties: </p>
 <ul>
<li>
<p>Format: GeoPackage </p>
</li>
<li><p> File name: What is provided as message by this
function </p>
</li>
<li><p> CRS: EPSG:4326 - WGS 84 </p>
</li>
<li><p> make sure that 'all fields are
exported'</p>
</li></ul>
 </li>
<li><p> Confirm that you have saved the file.</p>
</li></ol>



<h3>Value</h3>

<p>Returns a tibble of the entry that is appended to
'inv_geometries.csv'.
</p>


<h3>See Also</h3>

<p>Other register functions: 
<code><a href="#topic+regDataseries">regDataseries</a>()</code>,
<code><a href="#topic+regTable">regTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
  # build the example database
  adb_exampleDB(until = "regDataseries", path = tempdir())

  # The GADM dataset comes as *.7z archive
  regGeometry(gSeries = "gadm",
              label = list(al1 = "NAME_0"),
              layer = "example_geom1",
              archive = "example_geom.7z|example_geom1.gpkg",
              archiveLink = "https://gadm.org/",
              nextUpdate = "2019-10-01",
              updateFrequency = "quarterly")

  # The second administrative level in GADM contains names in the columns
  # NAME_0 and NAME_1
  regGeometry(gSeries = "gadm",
              label = list(al1 = "NAME_0", al2 = "NAME_1"),
              ancillary = list(name_lcl = "VARNAME_1", code = "GID_1", type = "TYPE_1"),
              layer = "example_geom2",
              archive = "example_geom.7z|example_geom2.gpkg",
              archiveLink = "https://gadm.org/",
              nextUpdate = "2019-10-01",
              updateFrequency = "quarterly")
}
</code></pre>

<hr>
<h2 id='regTable'>Register a new areal data table</h2><span id='topic+regTable'></span>

<h3>Description</h3>

<p>This function registers a new areal data table into the geospatial database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regTable(
  ...,
  subset = NULL,
  dSeries = NULL,
  gSeries = NULL,
  label = NULL,
  begin = NULL,
  end = NULL,
  schema = NULL,
  archive = NULL,
  archiveLink = NULL,
  downloadDate = NULL,
  updateFrequency = NULL,
  metadataLink = NULL,
  metadataPath = NULL,
  notes = NULL,
  diagnose = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regTable_+3A_...">...</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> name and value of the topmost unit
under which the table shall be registered. The name of this must be a class
of the gazetteer and the value must be one of the territory names of that
class, e.g. <em>nation = &quot;Estonia&quot;</em>.</p>
</td></tr>
<tr><td><code id="regTable_+3A_subset">subset</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optional argument to specify
which subset the file contains. This could be a subset of territorial units
(e.g. only one municipality) or of a target variable.</p>
</td></tr>
<tr><td><code id="regTable_+3A_dseries">dSeries</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the dataseries of the areal
data (see <code><a href="#topic+regDataseries">regDataseries</a></code>).</p>
</td></tr>
<tr><td><code id="regTable_+3A_gseries">gSeries</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optionally, the dataseries of
the geometries, if the geometry dataseries deviates from the dataseries of
the areal data (see <code><a href="#topic+regDataseries">regDataseries</a></code>).</p>
</td></tr>
<tr><td><code id="regTable_+3A_label">label</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> the label in the onology this
geometry should correspond to.</p>
</td></tr>
<tr><td><code id="regTable_+3A_begin">begin</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> the date from which on the data
are valid.</p>
</td></tr>
<tr><td><code id="regTable_+3A_end">end</code></td>
<td>
<p><code><a href="base.html#topic+integer">integerish(1)</a></code><br /> the date until which the data are
valid.</p>
</td></tr>
<tr><td><code id="regTable_+3A_schema">schema</code></td>
<td>
<p><code><a href="tabshiftr.html#topic+schema-class">schema</a></code><br /> the schema description of the
table to read in (must have been placed in the global environment before
calling it here).</p>
</td></tr>
<tr><td><code id="regTable_+3A_archive">archive</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> the original file from which
the boundaries emerge.</p>
</td></tr>
<tr><td><code id="regTable_+3A_archivelink">archiveLink</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> download-link of the
archive.</p>
</td></tr>
<tr><td><code id="regTable_+3A_downloaddate">downloadDate</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> value describing the
download date of this dataset (in YYYY-MM-DD format).</p>
</td></tr>
<tr><td><code id="regTable_+3A_updatefrequency">updateFrequency</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> value describing the
frequency with which the dataset is updated, according to the ISO 19115
Codelist, MD_MaintenanceFrequencyCode. Possible values are: 'continual',
'daily', 'weekly', 'fortnightly', 'quarterly', 'biannually', 'annually',
'asNeeded', 'irregular', 'notPlanned', 'unknown', 'periodic',
'semimonthly', 'biennially'.</p>
</td></tr>
<tr><td><code id="regTable_+3A_metadatalink">metadataLink</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> if there is already
metadata existing: link to the meta dataset.</p>
</td></tr>
<tr><td><code id="regTable_+3A_metadatapath">metadataPath</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> if an existing meta
dataset was downloaded along the data: the path where it is stored locally.</p>
</td></tr>
<tr><td><code id="regTable_+3A_notes">notes</code></td>
<td>
<p><code><a href="base.html#topic+character">character(1)</a></code><br /> optional notes.</p>
</td></tr>
<tr><td><code id="regTable_+3A_diagnose">diagnose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not to try to
reorganise the table with the provided schema. note: this does not save the
reogranised table into the database yet, further steps of harmonisation are
carried out by <code><a href="#topic+normTable">normTable</a></code> before that.</p>
</td></tr>
<tr><td><code id="regTable_+3A_overwrite">overwrite</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical(1)</a></code><br /> whether or not the geometry to
register shall overwrite a potentially already existing older version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When processing areal data tables, carry out the following steps:
</p>
 <ol>
<li><p> Determine the main territory (such as a nation, or any
other polygon), a <code>subset</code> (if applicable), the ontology
<code>label</code> and the dataseries of the areal data and of the geometry, and
provide them as arguments to this function. </p>
</li>
<li><p> Provide a <code>begin</code>
and <code>end</code> date for the areal data. </p>
</li>
<li><p> Run the function. </p>
</li>
<li>
<p>(Re)Save the table with the following properties: </p>
<ul>
<li><p> Format:
csv </p>
</li>
<li><p> Encoding: UTF-8 </p>
</li>
<li><p> File name: What is provided as message by
this function </p>
</li>
<li><p> make sure that the file is not modified or reshaped.
This will happen during data normalisation via the schema description,
which expects the original table.</p>
</li></ul>
 </li>
<li><p> Confirm that you have saved the
file.</p>
</li></ol>

<p>Every areal data dataseries (<code>dSeries</code>) may come as a slight
permutation of a particular table arrangement. The function
<code><a href="#topic+normTable">normTable</a></code> expects internally a schema description (a list
that describes the position of the data components) for each data table,
which is saved as <code>paste0("meta_", dSeries, TAB_NUMBER)</code>. See package
<code>tabshiftr</code>.
</p>


<h3>Value</h3>

<p>Returns a tibble of the entry that is appended to 'inv_tables.csv' in
case <code>update = TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other register functions: 
<code><a href="#topic+regDataseries">regDataseries</a>()</code>,
<code><a href="#topic+regGeometry">regGeometry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(dev.interactive()){
  # build the example database
  adb_exampleDB(until = "regGeometry", path = tempdir())

  # the schema description for this table
  library(tabshiftr)

  schema_madeUp &lt;-
    setIDVar(name = "al1", columns = 1) %&gt;%
    setIDVar(name = "year", columns = 2) %&gt;%
    setIDVar(name = "commodities", columns = 3) %&gt;%
    setObsVar(name = "harvested",
              factor = 1, columns = 4) %&gt;%
    setObsVar(name = "production",
              factor = 1, columns = 5)

  regTable(nation = "Estonia",
           subset = "barleyMaize",
           label = "al1",
           dSeries = "madeUp",
           gSeries = "gadm",
           begin = 1990,
           end = 2017,
           schema = schema_madeUp,
           archive = "example_table.7z|example_table1.csv",
           archiveLink = "...",
           nextUpdate = "2024-10-01",
           updateFrequency = "quarterly",
           metadataLink = "...",
           metadataPath = "my/local/path")
}
</code></pre>

<hr>
<h2 id='territories'>Example <code>gazetteer</code></h2><span id='topic+territories'></span>

<h3>Description</h3>

<p>An ontology of territory names (gazetteer)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>territories
</code></pre>


<h3>Format</h3>

<p>object of class <code>onto</code> for the example territories used in
<code><a href="#topic+adb_example">adb_example</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
