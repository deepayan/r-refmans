<!DOCTYPE html><html><head><title>Help for package ordinalNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ordinalNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.ordinalNet'><p>Method to extract fitted coefficients from an &quot;ordinalNet&quot; object.</p></a></li>
<li><a href='#ordinalNet'><p>Ordinal regression models with elastic net penalty</p></a></li>
<li><a href='#ordinalNetCV'><p>Uses K-fold cross validation to obtain out-of-sample log-likelihood and</p>
misclassification rates. Lambda is tuned within each cross validation fold.</a></li>
<li><a href='#ordinalNetTune'><p>Uses K-fold cross validation to obtain out-of-sample log-likelihood and</p>
misclassification rates for a sequence of lambda values.</a></li>
<li><a href='#plot.ordinalNetTune'><p>Plot method for &quot;ordinalNetTune&quot; object.</p></a></li>
<li><a href='#predict.ordinalNet'><p>Predict method for an &quot;ordinalNet&quot; object</p></a></li>
<li><a href='#print.ordinalNet'><p>Print method for an &quot;ordinalNet&quot; object.</p></a></li>
<li><a href='#print.ordinalNetCV'><p>Print method for an &quot;ordinalNetCV&quot; object.</p></a></li>
<li><a href='#print.ordinalNetTune'><p>Print method for an &quot;ordinalNetTune&quot; object.</p></a></li>
<li><a href='#summary.ordinalNet'><p>Summary method for an &quot;ordinalNet&quot; object.</p></a></li>
<li><a href='#summary.ordinalNetCV'><p>Summary method for an &quot;ordinalNetCV&quot; object.</p></a></li>
<li><a href='#summary.ordinalNetTune'><p>Summary method for an &quot;ordinalNetTune&quot; object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalized Ordinal Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.12</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits ordinal regression models with elastic net penalty.
    Supported model families include cumulative probability, stopping ratio, 
    continuation ratio, and adjacent category. These families are a subset of 
    vector glm's which belong to a model class we call the elementwise link 
    multinomial-ordinal (ELMO) class. Each family in this class links a vector 
    of covariates to a vector of class probabilities. Each of these families 
    has a parallel form, which is appropriate for ordinal response data, as 
    well as a nonparallel form that is appropriate for an unordered categorical
    response, or as a more flexible model for ordinal data. The parallel model
    has a single set of coefficients, whereas the nonparallel model has a set of
    coefficients for each response category except the baseline category. It is 
    also possible to fit a model with both parallel and nonparallel terms, which 
    we call the semi-parallel model. The semi-parallel model has the flexibility 
    of the nonparallel model, but the elastic net penalty shrinks it toward the 
    parallel model. For details, refer to Wurm, Hanlon, and Rathouz (2021) 
    &lt;<a href="https://doi.org/10.18637%2Fjss.v099.i06">doi:10.18637/jss.v099.i06</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.2), MASS (&ge; 7.3-45), glmnet (&ge; 2.0-5),
penalized (&ge; 0.9-50), VGAM (&ge; 1.0-3), rms (&ge; 5.1-0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-22 02:50:08 UTC; mike</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Wurm [aut, cre],
  Paul Rathouz [aut],
  Bret Hanlon [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Wurm &lt;wurm@uwalumni.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-22 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.ordinalNet'>Method to extract fitted coefficients from an &quot;ordinalNet&quot; object.</h2><span id='topic+coef.ordinalNet'></span>

<h3>Description</h3>

<p>Method to extract fitted coefficients from an &quot;ordinalNet&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNet'
coef(
  object,
  matrix = FALSE,
  whichLambda = NULL,
  criteria = c("aic", "bic"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.ordinalNet_+3A_object">object</code></td>
<td>
<p>An &quot;ordinalNet&quot; S3 object.</p>
</td></tr>
<tr><td><code id="coef.ordinalNet_+3A_matrix">matrix</code></td>
<td>
<p>Logical. If <code>TRUE</code>, coefficient estimates are returned in
matrix form. Otherwise a vector is returned.</p>
</td></tr>
<tr><td><code id="coef.ordinalNet_+3A_whichlambda">whichLambda</code></td>
<td>
<p>Optional index number of the desired <code>lambda</code> within
the sequence of <code>lambdaVals</code>. By default, the solution with the best AIC
is returned.</p>
</td></tr>
<tr><td><code id="coef.ordinalNet_+3A_criteria">criteria</code></td>
<td>
<p>Selects the best <code>lambda</code> value by AIC or BIC. Only used
if <code>whichLambda=NULL</code>.</p>
</td></tr>
<tr><td><code id="coef.ordinalNet_+3A_...">...</code></td>
<td>
<p>Not used. Additional coef arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on <code>matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNet">ordinalNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNet() documentation for examples.

</code></pre>

<hr>
<h2 id='ordinalNet'>Ordinal regression models with elastic net penalty</h2><span id='topic+ordinalNet'></span>

<h3>Description</h3>

<p>Fits ordinal regression models with elastic net penalty by coordinate descent.
Supported model families include cumulative probability, stopping ratio, continuation ratio,
and adjacent category. These families are a subset of vector glm's which belong to a model
class we call the elementwise link multinomial-ordinal (ELMO) class. Each family
in this class links a vector of covariates to a vector of class probabilities.
Each of these families has a parallel form, which is appropriate for ordinal response
data, as well as a nonparallel form that is appropriate for an unordered categorical
response, or as a more flexible model for ordinal data. The parallel model
has a single set of coefficients, whereas the nonparallel model has a set of coefficients
for each response category except the baseline category. It is also possible
to fit a model with both parallel and nonparallel terms, which we call the semi-parallel
model. The semi-parallel model has the flexibility of the nonparallel model,
but the elastic net penalty shrinks it toward the parallel model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinalNet(
  x,
  y,
  alpha = 1,
  standardize = TRUE,
  penaltyFactors = NULL,
  positiveID = NULL,
  family = c("cumulative", "sratio", "cratio", "acat"),
  reverse = FALSE,
  link = c("logit", "probit", "cloglog", "cauchit"),
  customLink = NULL,
  parallelTerms = TRUE,
  nonparallelTerms = FALSE,
  parallelPenaltyFactor = 1,
  lambdaVals = NULL,
  nLambda = 20,
  lambdaMinRatio = 0.01,
  includeLambda0 = FALSE,
  alphaMin = 0.01,
  pMin = 1e-08,
  stopThresh = 1e-08,
  threshOut = 1e-08,
  threshIn = 1e-08,
  maxiterOut = 100,
  maxiterIn = 100,
  printIter = FALSE,
  printBeta = FALSE,
  warn = TRUE,
  keepTrainingData = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinalNet_+3A_x">x</code></td>
<td>
<p>Covariate matrix. It is recommended that categorical covariates are
converted to a set of indicator variables with a variable for each category
(i.e. no baseline category); otherwise the choice of baseline category will
affect the model fit.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_y">y</code></td>
<td>
<p>Response variable. Can be a factor, ordered factor, or a matrix
where each row is a multinomial vector of counts. A weighted fit can be obtained
using the matrix option, since the row sums are essentially observation weights.
Non-integer matrix entries are allowed.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_alpha">alpha</code></td>
<td>
<p>The elastic net mixing parameter, with <code>0 &lt;= alpha &lt;= 1</code>.
<code>alpha=1</code> corresponds to the lasso penalty, and <code>alpha=0</code> corresponds
to the ridge penalty.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_standardize">standardize</code></td>
<td>
<p>If <code>standardize=TRUE</code>, the predictor variables are
scaled to have unit variance. Coefficient estimates are returned on the
original scale.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_penaltyfactors">penaltyFactors</code></td>
<td>
<p>Optional nonnegative vector of penalty factors with
length equal to the number of columns in <code>x</code>. If this argument is used,
then the penalty for each variable is scaled by its corresponding factor.
If <code>NULL</code>, the penalty factor is one for each coefficient.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_positiveid">positiveID</code></td>
<td>
<p>Logical vector indicating whether each coefficient should
be constrained to be non-negative. If <code>NULL</code>, the default value is <code>FALSE</code>
for all coefficients.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_family">family</code></td>
<td>
<p>Specifies the type of model family. Options are &quot;cumulative&quot;
for cumulative probability, &quot;sratio&quot; for stopping ratio, &quot;cratio&quot; for continuation ratio,
and &quot;acat&quot; for adjacent category.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_reverse">reverse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the &quot;backward&quot; form of the model
is fit, i.e. the model is defined with response categories in reverse order.
For example, the reverse cumulative model with <code class="reqn">K+1</code> response categories
applies the link function to the cumulative probabilities <code class="reqn">P(Y \ge 2),
\ldots, P(Y \ge K+1)</code>, rather then <code class="reqn">P(Y \le 1), \ldots, P(Y \le K)</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_link">link</code></td>
<td>
<p>Specifies the link function. The options supported are logit,
probit, complementary log-log, and cauchit. Only used if <code>customLink=NULL</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_customlink">customLink</code></td>
<td>
<p>Optional list containing a vectorized link function <code>g</code>,
a vectorized inverse link <code>h</code>, and the Jacobian function of the inverse link
<code>getQ</code>. The Jacobian should be defined as <code class="reqn">\partial h(\eta) / \partial \eta^T</code>
(as opposed to the transpose of this matrix).</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_parallelterms">parallelTerms</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then parallel coefficient terms
will be included in the model. <code>parallelTerms</code> and <code>nonparallelTerms</code>
cannot both be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_nonparallelterms">nonparallelTerms</code></td>
<td>
<p>Logical. if <code>TRUE</code>, then nonparallel coefficient terms
will be included in the model. <code>parallelTerms</code> and <code>nonparallelTerms</code>
cannot both be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_parallelpenaltyfactor">parallelPenaltyFactor</code></td>
<td>
<p>Nonnegative numeric value equal to one by
default. The penalty on all parallel terms is scaled by this factor (as well
as variable-specific <code>penaltyFactors</code>). Only used if
<code>parallelTerms=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_lambdavals">lambdaVals</code></td>
<td>
<p>An optional user-specified lambda sequence (vector). If <code>NULL</code>,
a sequence will be generated based on <code>nLambda</code> and <code>lambdaMinRatio</code>.
In this case, the maximum lambda is the smallest value that sets all penalized
coefficients to zero, and the minimum lambda is the maximum value multiplied
by the factor <code>lambdaMinRatio</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_nlambda">nLambda</code></td>
<td>
<p>Positive integer. The number of lambda values in the solution path.
Only used if <code>lambdaVals=NULL</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_lambdaminratio">lambdaMinRatio</code></td>
<td>
<p>A factor greater than zero and less than one. Only used
if <code>lambdaVals=NULL</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_includelambda0">includeLambda0</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then zero is added to the end
of the sequence of <code>lambdaVals</code>. This is not done by default because
it can significantly increase computational time. An unpenalized saturated model
may have infinite coefficient solutions, in which case the fitting algorithm
will still terminate when the relative change in log-likelihood becomes small.
Only used if <code>lambdaVals=NULL</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_alphamin">alphaMin</code></td>
<td>
<p><code>max(alpha, alphaMin)</code> is used to calculate the starting
lambda value when <code>lambdaVals=NULL</code>. In this case, the default lambda
sequence begins with the smallest lambda value such that all penalized
coefficients are set to zero (i.e. the value where the first penalized
coefficient enters the solution path). The purpose of this argument is to
help select a starting value for the lambda sequence when <code>alpha = 0</code>,
because otherwise it would be infinite. Note that <code>alphaMin</code> is only
used to determine the default lamba sequence and that the model is always fit
using <code>alpha</code> to calculate the penalty.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_pmin">pMin</code></td>
<td>
<p>Value greater than zero, but much less than one. During the optimization
routine, the Fisher information is calculated using fitted probabilities. For
this calculation, fitted probabilities are capped below by this value to prevent
numerical instability.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_stopthresh">stopThresh</code></td>
<td>
<p>In the relative log-likelihood change between successive
lambda values falls below this threshold, then the last model fit is used for all
remaining lambda.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_threshout">threshOut</code></td>
<td>
<p>Convergence threshold for the coordinate descent outer loop.
The optimization routine terminates when the relative change in the
penalized log-likelihood between successive iterations falls below this threshold.
It is recommended to set <code>theshOut</code> equal to <code>threshIn</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_threshin">threshIn</code></td>
<td>
<p>Convergence threshold for the coordinate descent inner loop. Each
iteration consists of a single loop through each coefficient. The inner
loop terminates when the relative change in the penalized approximate
log-likelihood between successive iterations falls below this threshold.
It is recommended to set <code>theshOut</code> equal to <code>threshIn</code>.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_maxiterout">maxiterOut</code></td>
<td>
<p>Maximum number of outer loop iterations.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_maxiterin">maxiterIn</code></td>
<td>
<p>Maximum number of inner loop iterations.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_printiter">printIter</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the optimization routine progress is
printed to the terminal.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_printbeta">printBeta</code></td>
<td>
<p>Logical. If <code>TRUE</code>, coefficient estimates are printed
after each coordinate descent outer loop iteration.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the following warning message is displayed
when fitting a cumulative probability model with <code>nonparallelTerms=TRUE</code>
(i.e. nonparallel or semi-parallel model).
&quot;Warning message: For out-of-sample data, the cumulative probability model
with nonparallelTerms=TRUE may predict cumulative probabilities that are not
monotone increasing.&quot;
The warning is displayed by default, but the user may wish to disable it.</p>
</td></tr>
<tr><td><code id="ordinalNet_+3A_keeptrainingdata">keepTrainingData</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>x</code> and <code>y</code>
are saved with the returned &quot;ordinalNet&quot; object. This allows
<code>predict.ordinalNet</code> to return fitted values for the training data
without passing a <code>newx</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ordinalNet</code> function fits regression models for a categorical response
variable with <code class="reqn">K+1</code> levels. Conditional on the covariate vector <code class="reqn">x_i</code>
(the <code class="reqn">i^{th}</code> row of <code>x</code>), each observation has a vector of <code class="reqn">K+1</code>
class probabilities <code class="reqn">(p_{i1}, \ldots, p_{i(K+1)})</code>. These probabilities
sum to one, and can therefore be parametrized by <code class="reqn">p_i = (p_{i1}, \ldots, p_{iK})</code>.
The probabilities are mapped to a set of <code class="reqn">K</code> quantities
<code class="reqn">\delta_i = (\delta_{i1}, \ldots, \delta_{iK}) \in (0, 1)^K</code>, which depends on the choice
of model <code>family</code>. The elementwise <code>link</code> function maps
<code class="reqn">\delta_i</code> to a set of <code class="reqn">K</code> linear predictors. Together, the <code>family</code>
and <code>link</code> specifiy a link function between <code class="reqn">p_i</code> and <code class="reqn">\eta_i</code>.
</p>
<p><strong><em>Model families:</em></strong>
</p>
<p>Let <code class="reqn">Y</code> denote the random response variable for a single observation,
conditional on the covariates values of the observation. The random variable
<code class="reqn">Y</code> is discrete with support {<code class="reqn">1, \ldots, K+1</code>}. The following model
families are defined according to these mappings between the class
probabilities and the values <code class="reqn">\delta_1, \ldots, \delta_K</code>:
</p>

<dl>
<dt>Cumulative probability</dt><dd><p><code class="reqn">\delta_j = P(Y \le j)</code></p>
</dd>
<dt>Reverse cumulative probability</dt><dd><p><code class="reqn">\delta_j = P(Y \ge j + 1)</code></p>
</dd>
<dt>Stopping ratio</dt><dd><p><code class="reqn">\delta_j = P(Y = j | Y \ge j)</code></p>
</dd>
<dt>Reverse stopping ratio</dt><dd><p><code class="reqn">\delta_j = P(Y=j + 1 | Y \le j + 1)</code></p>
</dd>
<dt>Continuation ratio</dt><dd><p><code class="reqn">\delta_j = P(Y &gt; j | Y \ge j)</code></p>
</dd>
<dt>Reverse continuation ratio</dt><dd><p><code class="reqn">\delta_j = P(Y &lt; j | Y \le j)</code></p>
</dd>
<dt>Adjacent category</dt><dd><p><code class="reqn">\delta_j = P(Y = j + 1 | j \le Y \le j+1)</code></p>
</dd>
<dt>Reverse adjacent category</dt><dd><p><code class="reqn">\delta_j = P(Y = j | j \le Y \le j+1)</code></p>
</dd>
</dl>

<p><strong><em>Parallel, nonparallel, and semi-parallel model forms:</em></strong>
</p>
<p>Models within each of these families can take one of three forms, which have
different definitions for the linear predictor <code class="reqn">\eta_i</code>. Suppose each
<code class="reqn">x_i</code> has length <code class="reqn">P</code>. Let <code class="reqn">b</code> be a length <code class="reqn">P</code> vector of
regression coefficients. Let <code class="reqn">B</code> be a <code class="reqn">P \times K</code> matrix of regression
coefficient. Let <code class="reqn">b_0</code> be a vector of <code class="reqn">K</code> intercept terms.
The three model forms are the following:
</p>

<dl>
<dt>Parallel</dt><dd><p><code class="reqn">\eta_i = b_0 + b^T x_i</code> (<code>parallelTerms=TRUE</code>, <code>nonparallelTerms=FALSE</code>)</p>
</dd>
<dt>Nonparallel</dt><dd><p><code class="reqn">\eta_i = b_0 + B^T x_i</code> (<code>parallelTerms=FALSE</code>, <code>nonparallelTerms=TRUE</code>)</p>
</dd>
<dt>Semi-parallel</dt><dd><p><code class="reqn">\eta_i = b_0 + b^T x_i + B^T x_i</code> (<code>parallelTerms=TRUE</code>, <code>nonparallelTerms=TRUE</code>)</p>
</dd>
</dl>

<p>The parallel form has the defining property of ordinal models, which is that
a single linear combination <code class="reqn">b^T x_i</code> shifts the cumulative class probabilities
<code class="reqn">P(Y \le j)</code> in favor of either higher or lower categories. The linear predictors
are parallel because they only differ by their intercepts (<code class="reqn">b_0</code>). The nonparallel form
is a more flexible model, and it does not shift the cumulative probabilities together.
The semi-parallel model is equivalent to the nonparallel model, but the
elastic net penalty shrinks the semi-parallel coefficients toward a common
value (i.e. the parallel model), as well as shrinking all coefficients toward zero.
The nonparallel model, on the other hand, simply shrinks all coefficients toward zero.
When the response categories are ordinal, any of the three model forms could
be applied. When the response categories are unordered, only the nonparallel
model is appropriate.
</p>
<p><strong><em>Elastic net penalty:</em></strong>
</p>
<p>The elastic net penalty is defined for each model form as follows. <code class="reqn">\lambda</code>
and <code class="reqn">\alpha</code> are the usual elastic net tuning parameters, where <code class="reqn">\lambda</code>
determines the degree to which coefficients are shrunk toward zero, and <code class="reqn">\alpha</code>
specifies the amound of weight given to the L1 norm and squared L2 norm penalties.
Each covariate is allowed a unique penalty factor <code class="reqn">c_j</code>, which is specified with the
<code>penaltyFactors</code> argument. By default <code class="reqn">c_j = 1</code> for all <code class="reqn">j</code>.
The semi-parallel model has a tuning parameter <code class="reqn">\rho</code> which determines the degree to
which the parallel coefficients are penalized. Small values of <code class="reqn">\rho</code> will
result in a fit closer to the parallel model, and large values of <code class="reqn">\rho</code>
will result in a fit closer to the nonparallel model.
</p>

<dl>
<dt>Parallel</dt><dd><p><code class="reqn">\lambda \sum_{j=1}^P c_j \{ \alpha |b_j| +
                       \frac{1}{2} (1-\alpha) b_j^2 \}</code></p>
</dd>
<dt>Nonparallel</dt><dd><p><code class="reqn">\lambda \sum_{j=1}^P c_j \{ \sum_{k=1}^K \alpha |B_{jk}| +
                          \frac{1}{2} (1-\alpha) B_{jk}^2 \}</code></p>
</dd>
<dt>Semi-parallel</dt><dd><p><code class="reqn">\lambda [ \rho \sum_{j=1}^P c_j \{ \alpha |b_j| +
                            \frac{1}{2} (1-\alpha) b_j^2 \} +
                            \sum_{j=1}^P c_j \{ \sum_{k=1}^K \alpha |B_{jk}| +
                            \frac{1}{2} (1-\alpha) B_{jk}^2 \}]</code></p>
</dd>
</dl>

<p><code>ordinalNet</code> minimizes the following objective function. Let <code class="reqn">N</code> be
the number of observations, which is defined as the sum of the <code>y</code> elements
when <code>y</code> is a matrix.
</p>
<p style="text-align: center;"><code class="reqn">objective = -1/N*loglik + penalty</code>
</p>



<h3>Value</h3>

<p>An object with S3 class &quot;ordinalNet&quot;.  Model fit information can be accessed
through the <code>coef</code>, <code>predict</code>, and <code>summary</code> methods.
</p>

<dl>
<dt>coefs</dt><dd><p>Matrix of coefficient estimates, with each row corresponding to a lambda value.
(If covariates were scaled with <code>standardize=TRUE</code>, the coefficients are
returned on the original scale).</p>
</dd>
<dt>lambdaVals</dt><dd><p>Sequence of lambda values. If user passed a sequence to the
<code>lambdaVals</code>, then it is this sequence. If <code>lambdaVals</code> argument
was <code>NULL</code>, then it is the sequence generated.</p>
</dd>
<dt>loglik</dt><dd><p>Log-likelihood of each model fit.</p>
</dd>
<dt>nNonzero</dt><dd><p>Number of nonzero coefficients of each model fit, including intercepts.</p>
</dd>
<dt>aic</dt><dd><p>AIC, defined as <code>-2*loglik + 2*nNonzero</code>.</p>
</dd>
<dt>bic</dt><dd><p>BIC, defined as <code>-2*loglik + log(N)*nNonzero</code>.</p>
</dd>
<dt>devPct</dt><dd><p>Percentage deviance explained, defined as <code class="reqn">1 - loglik/loglik_0</code>,
where <code class="reqn">loglik_0</code> is the log-likelihood of the null model.</p>
</dd>
<dt>iterOut</dt><dd><p>Number of coordinate descent outer loop iterations until
convergence for each lambda value.</p>
</dd>
<dt>iterIn</dt><dd><p>Number of coordinate descent inner loop iterations on last outer loop
for each lambda value.</p>
</dd>
<dt>dif</dt><dd><p>Relative improvement in objective function on last outer loop
for each lambda value. Can be used to diagnose convergence issues. If <code>iterOut</code>
reached <code>maxiterOut</code> and <code>dif</code> is large, then <code>maxiterOut</code> should
be increased. If <code>dif</code> is negative, this means the objective did not improve
between successive iterations. This usually only occurs when the model is
saturated and/or close to convergence, so a small negative value is not of concern.
(When this happens, the algorithm is terminated for the current lambda value,
and the coefficient estimates from the previous outer loop iteration are returned.)</p>
</dd>
<dt>nLev</dt><dd><p>Number of response categories.</p>
</dd>
<dt>nVar</dt><dd><p>Number of covariates in <code>x</code>.</p>
</dd>
<dt>xNames</dt><dd><p>Covariate names.</p>
</dd>
<dt>args</dt><dd><p>List of arguments passed to the <code>ordinalNet</code> function.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Simulate x as independent standard normal
# Simulate y|x from a parallel cumulative logit (proportional odds) model
set.seed(1)
n &lt;- 50
intercepts &lt;- c(-1, 1)
beta &lt;- c(1, 1, 0, 0, 0)
ncat &lt;- length(intercepts) + 1  # number of response categories
p &lt;- length(beta)  # number of covariates
x &lt;- matrix(rnorm(n*p), ncol=p)  # n x p covariate matrix
eta &lt;- c(x %*% beta) + matrix(intercepts, nrow=n, ncol=ncat-1, byrow=TRUE)
invlogit &lt;- function(x) 1 / (1+exp(-x))
cumprob &lt;- t(apply(eta, 1, invlogit))
prob &lt;- cbind(cumprob, 1) - cbind(0, cumprob)
yint &lt;- apply(prob, 1, function(p) sample(1:ncat, size=1, prob=p))
y &lt;- as.factor(yint)

# Fit parallel cumulative logit model
fit1 &lt;- ordinalNet(x, y, family="cumulative", link="logit",
                   parallelTerms=TRUE, nonparallelTerms=FALSE)
summary(fit1)
coef(fit1)
coef(fit1, matrix=TRUE)
predict(fit1, type="response")
predict(fit1, type="class")

# Fit nonparallel cumulative logit model
fit2 &lt;- ordinalNet(x, y, family="cumulative", link="logit",
                   parallelTerms=FALSE, nonparallelTerms=TRUE)
fit2
coef(fit2)
coef(fit2, matrix=TRUE)
predict(fit2, type="response")
predict(fit2, type="class")

# Fit semi-parallel cumulative logit model (with both parallel and nonparallel terms)
fit3 &lt;- ordinalNet(x, y, family="cumulative", link="logit",
                   parallelTerms=TRUE, nonparallelTerms=TRUE)
fit3
coef(fit3)
coef(fit3, matrix=TRUE)
predict(fit3, type="response")
predict(fit3, type="class")

</code></pre>

<hr>
<h2 id='ordinalNetCV'>Uses K-fold cross validation to obtain out-of-sample log-likelihood and
misclassification rates. Lambda is tuned within each cross validation fold.</h2><span id='topic+ordinalNetCV'></span>

<h3>Description</h3>

<p>The data is divided into K folds. <code>ordinalNet</code> is fit <code class="reqn">K</code> times, each time
leaving out one fold as a test set. For each of the <code class="reqn">K</code> model fits, lambda
can be tuned by AIC or BIC, or cross validation. If cross validation is used,
the user can choose whether to user the best average out-of-sample log-likelihood,
misclassification rate, Brier score, or percentage of deviance explained.
The user can also choose the number of cross validation folds to use for tuning.
Once the model is tuned, the out of sample log-likelihood,
misclassification rate, Brier score, and percentage of deviance explained
are calculated on the held out test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinalNetCV(
  x,
  y,
  lambdaVals = NULL,
  folds = NULL,
  nFolds = 5,
  nFoldsCV = 5,
  tuneMethod = c("cvLoglik", "cvMisclass", "cvBrier", "cvDevPct", "aic", "bic"),
  printProgress = TRUE,
  warn = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinalNetCV_+3A_x">x</code></td>
<td>
<p>Covariate matrix.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_y">y</code></td>
<td>
<p>Response variable. Can be a factor, ordered factor, or a matrix
where each row is a multinomial vector of counts. A weighted fit can be obtained
using the matrix option, since the row sums are essentially observation weights.
Non-integer matrix entries are allowed.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_lambdavals">lambdaVals</code></td>
<td>
<p>An optional user-specified lambda sequence (vector). If <code>NULL</code>,
a sequence will be generated using the model fit to the full training data.
This default sequence is based on <code>nLambda</code> and <code>lambdaMinRatio</code>,
which can be passed as additional arguments (otherwise <code>ordinalNet</code> default
values are used). The maximum lambda is the smallest value that sets all penalized
coefficients to zero, and the minimum lambda is the maximum value multiplied
by the factor <code>lambdaMinRatio</code>.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_folds">folds</code></td>
<td>
<p>An optional list, where each element is a vector of row indices
corresponding to a different cross validation fold. Indices correspond to rows
of the <code>x</code> matrix. Each index number should be used in exactly one fold.
If <code>NULL</code>, the data will be randomly divided into equally-sized partitions.
It is recommended to call <code>set.seed</code> before calling <code>ordinalNetCV</code>
for reproducibility.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_nfolds">nFolds</code></td>
<td>
<p>Numer of cross validation folds. Only used if <code>folds=NULL</code>.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_nfoldscv">nFoldsCV</code></td>
<td>
<p>Number of cross validation folds used to tune lambda for each
training set (i.e. within each training fold). Only used of <code>tuneMethod</code> is
&quot;cvLoglik&quot;, &quot;cvMisclass&quot;, &quot;cvBrier&quot;, or &quot;cvDevPct.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_tunemethod">tuneMethod</code></td>
<td>
<p>Method used to tune lambda for each training set (ie. within
each training fold). The &quot;cvLoglik&quot;, &quot;cvMisclass&quot;, &quot;cvBrier&quot;, and &quot;cvDevPct&quot;
methods use cross validation with <code>nFoldsCV</code> folds and select the
lambda value with the best average out-of-sample performance. The &quot;aic&quot; and &quot;bic&quot;
methods are less computationally intensive because they do not require the
model to be fit multiple times.
Note that for the methods that require cross validation, the fold splits are
determined randomly and cannot be specified by the user. The <code>set.seed()</code>
function should be called prior to <code>ordinalNetCV</code> for reproducibility.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_printprogress">printProgress</code></td>
<td>
<p>Logical. If <code>TRUE</code> the fitting progress is printed
to the terminal.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the following warning message is displayed
when fitting a cumulative probability model with <code>nonparallelTerms=TRUE</code>
(i.e. nonparallel or semi-parallel model).
&quot;Warning message: For out-of-sample data, the cumulative probability model
with nonparallelTerms=TRUE may predict cumulative probabilities that are not
monotone increasing.&quot;
The warning is displayed by default, but the user may wish to disable it.</p>
</td></tr>
<tr><td><code id="ordinalNetCV_+3A_...">...</code></td>
<td>
<p>Other arguments (besides <code>x</code>, <code>y</code>, <code>lambdaVals</code>, and <code>warn</code>)
passed to <code>ordinalNet</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The fold partition splits can be passed by the user via the <code>folds</code>
argument. By default, the data are randomly divided into equally-sized partitions.
Note that if lambda is tuned by cross validation, the fold splits are
determined randomly and cannot be specified by the user. The <code>set.seed</code>
function should be called prior to <code>ordinalNetCV</code> for reproducibility.
</p>
</li>
<li><p> A sequence of lambda values can be passed by the user via the
<code>lambdaVals</code> argument. By default, the sequence is generated by first
fitting the model to the full data set (this sequence is determined by the
<code>nLambda</code> and <code>lambdaMinRatio</code> arguments of <code>ordinalNet</code>).
</p>
</li>
<li><p> The <code>standardize</code> argument of <code>ordinalNet</code> can be modified through
the additional arguments (...). If <code>standardize=TRUE</code>, then the data are scaled
within each cross validation fold. If <code>standardize=TRUE</code> and lambda is tuned by
cross validation, then the data are also scaled within each tuning sub-fold.
This is done because scaling is part of the statistical procedure and should
be repeated each time the procedure is applied.
</p>
</li></ul>



<h3>Value</h3>

<p>An S3 object of class &quot;ordinalNetCV&quot;, which contains the following:
</p>

<dl>
<dt>loglik</dt><dd><p>Vector of out-of-sample log-likelihood values.
Each value corresponds to a different fold.</p>
</dd>
<dt>misclass</dt><dd><p>Vector of out-of-sample misclassificaton rates.
Each value corresponds to a different fold.</p>
</dd>
<dt>brier</dt><dd><p>Vector of out-of-sample Brier scores.
Each value corresponds to a different fold.</p>
</dd>
<dt>devPct</dt><dd><p>Vector of out-of-sample percentages of deviance explained.
Each value corresponds to a different fold.</p>
</dd>
<dt>bestLambdaIndex</dt><dd><p>The index of the value within the lambda sequence
selected for each fold by the tuning method.</p>
</dd>
<dt>lambdaVals</dt><dd><p>The sequence of lambda values used for all cross validation folds.</p>
</dd>
<dt>folds</dt><dd><p>A list containing the index numbers of each fold.</p>
</dd>
<dt>fit</dt><dd><p>An object of class &quot;ordinalNet&quot;, resulting from fitting
<code>ordinalNet</code> to the entire dataset.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate x as independent standard normal
# Simulate y|x from a parallel cumulative logit (proportional odds) model
set.seed(1)
n &lt;- 50
intercepts &lt;- c(-1, 1)
beta &lt;- c(1, 1, 0, 0, 0)
ncat &lt;- length(intercepts) + 1  # number of response categories
p &lt;- length(beta)  # number of covariates
x &lt;- matrix(rnorm(n*p), ncol=p)  # n x p covariate matrix
eta &lt;- c(x %*% beta) + matrix(intercepts, nrow=n, ncol=ncat-1, byrow=TRUE)
invlogit &lt;- function(x) 1 / (1+exp(-x))
cumprob &lt;- t(apply(eta, 1, invlogit))
prob &lt;- cbind(cumprob, 1) - cbind(0, cumprob)
yint &lt;- apply(prob, 1, function(p) sample(1:ncat, size=1, prob=p))
y &lt;- as.factor(yint)

# Evaluate out-of-sample performance of the  cumulative logit model
# when lambda is tuned by cross validation (best average out-of-sample log-likelihood)
cv &lt;- ordinalNetCV(x, y, tuneMethod="cvLoglik")
summary(cv)

## End(Not run)

</code></pre>

<hr>
<h2 id='ordinalNetTune'>Uses K-fold cross validation to obtain out-of-sample log-likelihood and
misclassification rates for a sequence of lambda values.</h2><span id='topic+ordinalNetTune'></span>

<h3>Description</h3>

<p>The data is divided into K folds. <code>ordinalNet</code> is fit <code class="reqn">K</code> times (<code>K=nFolds</code>),
each time leaving out one fold as a test set. The same sequence of lambda values is used
each time. The out-of-sample log-likelihood, misclassification rate, Brier score,
and percentage of deviance explained are obtained for each lambda value from
the held out test set. It is up to the user to determine how to tune the model
using this information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinalNetTune(
  x,
  y,
  lambdaVals = NULL,
  folds = NULL,
  nFolds = 5,
  printProgress = TRUE,
  warn = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinalNetTune_+3A_x">x</code></td>
<td>
<p>Covariate matrix.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_y">y</code></td>
<td>
<p>Response variable. Can be a factor, ordered factor, or a matrix
where each row is a multinomial vector of counts. A weighted fit can be obtained
using the matrix option, since the row sums are essentially observation weights.
Non-integer matrix entries are allowed.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_lambdavals">lambdaVals</code></td>
<td>
<p>An optional user-specified lambda sequence (vector). If <code>NULL</code>,
a sequence will be generated using the model fit to the full training data.
This default sequence is based on <code>nLambda</code> and <code>lambdaMinRatio</code>,
which can be passed as additional arguments (otherwise <code>ordinalNet</code> default
values are used). The maximum lambda is the smallest value that sets all penalized
coefficients to zero, and the minimum lambda is the maximum value multiplied
by the factor <code>lambdaMinRatio</code>.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_folds">folds</code></td>
<td>
<p>An optional list, where each element is a vector of row indices
corresponding to a different cross validation fold. Indices correspond to rows
of the <code>x</code> matrix. Each index number should be used in exactly one fold.
If <code>NULL</code>, the data will be randomly divided into equal-sized partitions.
It is recommended to use <code>set.seed</code> before calling this function to make
results reproducible.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_nfolds">nFolds</code></td>
<td>
<p>Numer of cross validation folds. Only used if <code>folds=NULL</code>.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_printprogress">printProgress</code></td>
<td>
<p>Logical. If <code>TRUE</code> the fitting progress is printed
to the terminal.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the following warning message is displayed
when fitting a cumulative probability model with <code>nonparallelTerms=TRUE</code>
(i.e. nonparallel or semi-parallel model).
&quot;Warning message: For out-of-sample data, the cumulative probability model
with nonparallelTerms=TRUE may predict cumulative probabilities that are not
monotone increasing.&quot;
The warning is displayed by default, but the user may wish to disable it.</p>
</td></tr>
<tr><td><code id="ordinalNetTune_+3A_...">...</code></td>
<td>
<p>Other arguments (besides <code>x</code>, <code>y</code>, <code>lambdaVals</code>, and <code>warn</code>)
passed to <code>ordinalNet</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The fold partition splits can be passed by the user via the <code>folds</code>
argument. By default, the data are randomly divided into equally-sized partitions.
The <code>set.seed</code> function should be called prior to <code>ordinalNetCV</code> for reproducibility.
</p>
</li>
<li><p> A sequence of lambda values can be passed by the user via the
<code>lambdaVals</code> argument. By default, the sequence is generated by first
fitting the model to the full data set (this sequence is determined by the
<code>nLambda</code> and <code>lambdaMinRatio</code> arguments of <code>ordinalNet</code>).
</p>
</li>
<li><p> The <code>standardize</code> argument of <code>ordinalNet</code> can be modified through
the additional arguments (...). If <code>standardize=TRUE</code>, then the data are scaled
within each cross validation fold. This is done because scaling is part of
the statistical procedure and should be repeated each time the procedure is applied.
</p>
</li></ul>



<h3>Value</h3>

<p>An S3 object of class &quot;ordinalNetTune&quot;, which contains the following:
</p>

<dl>
<dt>loglik</dt><dd><p>Matrix of out-of-sample log-likelihood values.
Each row corresponds to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>misclass</dt><dd><p>Matrix of out-of-sample misclassificaton rates.
Each row corresponds to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>brier</dt><dd><p>Matrix of out-of-sample Brier scores. Each row corresponds
to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>devPct</dt><dd><p>Matrix of out-of-sample percentages of deviance explained.
Each row corresponds to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>lambdaVals</dt><dd><p>The sequence of lambda values used for all cross validation folds.</p>
</dd>
<dt>folds</dt><dd><p>A list containing the index numbers of each fold.</p>
</dd>
<dt>fit</dt><dd><p>An object of class &quot;ordinalNet&quot;, resulting from fitting
<code>ordinalNet</code> to the entire dataset.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate x as independent standard normal
# Simulate y|x from a parallel cumulative logit (proportional odds) model
set.seed(1)
n &lt;- 50
intercepts &lt;- c(-1, 1)
beta &lt;- c(1, 1, 0, 0, 0)
ncat &lt;- length(intercepts) + 1  # number of response categories
p &lt;- length(beta)  # number of covariates
x &lt;- matrix(rnorm(n*p), ncol=p)  # n x p covariate matrix
eta &lt;- c(x %*% beta) + matrix(intercepts, nrow=n, ncol=ncat-1, byrow=TRUE)
invlogit &lt;- function(x) 1 / (1+exp(-x))
cumprob &lt;- t(apply(eta, 1, invlogit))
prob &lt;- cbind(cumprob, 1) - cbind(0, cumprob)
yint &lt;- apply(prob, 1, function(p) sample(1:ncat, size=1, prob=p))
y &lt;- as.factor(yint)

# Fit parallel cumulative logit model; select lambda by cross validation
tunefit &lt;- ordinalNetTune(x, y)
summary(tunefit)
plot(tunefit)
bestLambdaIndex &lt;- which.max(rowMeans(tunefit$loglik))
coef(tunefit$fit, whichLambda=bestLambdaIndex, matrix=TRUE)
predict(tunefit$fit, whichLambda=bestLambdaIndex)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.ordinalNetTune'>Plot method for &quot;ordinalNetTune&quot; object.</h2><span id='topic+plot.ordinalNetTune'></span>

<h3>Description</h3>

<p>Plots the average out-of-sample log-likelihood, misclassification rate,
Brier score, or percentage of deviance explained for each lambda value in the
solution path. The averae is taken over all cross validation folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNetTune'
plot(x, type = c("loglik", "misclass", "brier", "devPct"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ordinalNetTune_+3A_x">x</code></td>
<td>
<p>An &quot;ordinalNetTune&quot; S3 object.</p>
</td></tr>
<tr><td><code id="plot.ordinalNetTune_+3A_type">type</code></td>
<td>
<p>Which performance measure to plot. Either &quot;loglik&quot;, &quot;misclass&quot;,
&quot;brier&quot;, or &quot;devPct&quot;.</p>
</td></tr>
<tr><td><code id="plot.ordinalNetTune_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNetTune">ordinalNetTune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNetTune() documentation for examples.

</code></pre>

<hr>
<h2 id='predict.ordinalNet'>Predict method for an &quot;ordinalNet&quot; object</h2><span id='topic+predict.ordinalNet'></span>

<h3>Description</h3>

<p>Obtains predicted probabilities, predicted class, or linear predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNet'
predict(
  object,
  newx = NULL,
  whichLambda = NULL,
  criteria = c("aic", "bic"),
  type = c("response", "class", "link"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ordinalNet_+3A_object">object</code></td>
<td>
<p>An &quot;ordinalNet&quot; S3 object.</p>
</td></tr>
<tr><td><code id="predict.ordinalNet_+3A_newx">newx</code></td>
<td>
<p>Optional covariate matrix. If NULL, fitted values will be obtained
for the training data, as long as the model was fit with the argument
<code>keepTrainingData=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.ordinalNet_+3A_whichlambda">whichLambda</code></td>
<td>
<p>Optional index number of the desired lambda value within
the solution path sequence.</p>
</td></tr>
<tr><td><code id="predict.ordinalNet_+3A_criteria">criteria</code></td>
<td>
<p>Selects the best lambda value by AIC or BIC. Only used
if <code>whichLambda=NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.ordinalNet_+3A_type">type</code></td>
<td>
<p>The type of prediction required.  Type &quot;response&quot; returns a
matrix of fitted probabilities. Type &quot;class&quot; returns a vector containing the
class number with the highest fitted probability. Type &quot;link&quot; returns a
matrix of linear predictors.</p>
</td></tr>
<tr><td><code id="predict.ordinalNet_+3A_...">...</code></td>
<td>
<p>Not used. Additional predict arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on <code>type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNet">ordinalNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNet() documentation for examples.

</code></pre>

<hr>
<h2 id='print.ordinalNet'>Print method for an &quot;ordinalNet&quot; object.</h2><span id='topic+print.ordinalNet'></span>

<h3>Description</h3>

<p>Prints the data frame returned by the <code>summary.ordinalNet()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNet'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ordinalNet_+3A_x">x</code></td>
<td>
<p>An &quot;ordinalNet&quot; S3 object</p>
</td></tr>
<tr><td><code id="print.ordinalNet_+3A_...">...</code></td>
<td>
<p>Not used. Additional plot arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNet">ordinalNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNet() documentation for examples.

</code></pre>

<hr>
<h2 id='print.ordinalNetCV'>Print method for an &quot;ordinalNetCV&quot; object.</h2><span id='topic+print.ordinalNetCV'></span>

<h3>Description</h3>

<p>Prints the data frame returned by the <code>summary.ordinalNetCV()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNetCV'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ordinalNetCV_+3A_x">x</code></td>
<td>
<p>An &quot;ordinalNetCV&quot; S3 object</p>
</td></tr>
<tr><td><code id="print.ordinalNetCV_+3A_...">...</code></td>
<td>
<p>Not used. Additional print arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNetCV">ordinalNetCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNetCV() documentation for examples.

</code></pre>

<hr>
<h2 id='print.ordinalNetTune'>Print method for an &quot;ordinalNetTune&quot; object.</h2><span id='topic+print.ordinalNetTune'></span>

<h3>Description</h3>

<p>Prints the data frame returned by the <code>summary.ordinalNetTune()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNetTune'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ordinalNetTune_+3A_x">x</code></td>
<td>
<p>An &quot;ordinalNetTune&quot; S3 object.</p>
</td></tr>
<tr><td><code id="print.ordinalNetTune_+3A_...">...</code></td>
<td>
<p>Not used. Additional print arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNetTune">ordinalNetTune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNetTune() documentation for examples.

</code></pre>

<hr>
<h2 id='summary.ordinalNet'>Summary method for an &quot;ordinalNet&quot; object.</h2><span id='topic+summary.ordinalNet'></span>

<h3>Description</h3>

<p>Provides a data frame which summarizes the model fit at each lambda value in
the solution path.model fit summary as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNet'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ordinalNet_+3A_object">object</code></td>
<td>
<p>An &quot;ordinalNet&quot; S3 object</p>
</td></tr>
<tr><td><code id="summary.ordinalNet_+3A_...">...</code></td>
<td>
<p>Not used. Additional summary arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a record for each lambda value in the solution
path. Each record contains the following fields: lambda value, degrees of freedom
(number of nonzero parameters), log-likelihood, AIC, BIC, and percent deviance explained.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNet">ordinalNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNet() documentation for examples.

</code></pre>

<hr>
<h2 id='summary.ordinalNetCV'>Summary method for an &quot;ordinalNetCV&quot; object.</h2><span id='topic+summary.ordinalNetCV'></span>

<h3>Description</h3>

<p>Provides a data frame which summarizes the cross validation results, which
can be used as an estimate of the out-of-sample performance of a model tuned
by a particular method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNetCV'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ordinalNetCV_+3A_object">object</code></td>
<td>
<p>An &quot;ordinalNetCV&quot; S3 object</p>
</td></tr>
<tr><td><code id="summary.ordinalNetCV_+3A_...">...</code></td>
<td>
<p>Not used. Additional summary arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a record for each cross validation fold.
Each record contains the following: lambda value, log-likelihood,
misclassification rate, Brier score, and percentage of deviance explained.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNetCV">ordinalNetCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNetCV() documentation for examples.

</code></pre>

<hr>
<h2 id='summary.ordinalNetTune'>Summary method for an &quot;ordinalNetTune&quot; object.</h2><span id='topic+summary.ordinalNetTune'></span>

<h3>Description</h3>

<p>Provides a data frame which summarizes the cross validation results and may
be useful for selecting an appropriate value for the tuning parameter lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinalNetTune'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ordinalNetTune_+3A_object">object</code></td>
<td>
<p>An &quot;ordinalNetTune&quot; S3 object.</p>
</td></tr>
<tr><td><code id="summary.ordinalNetTune_+3A_...">...</code></td>
<td>
<p>Not used. Additional summary arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing a record for each lambda value in the solution
path. Each record contains the following: lambda value, average log-likelihood,
average misclassification rate, average Brier score, and average percentage
of deviance explained. Averages are taken across all cross validation folds.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinalNetTune">ordinalNetTune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ordinalNetTune() documentation for examples.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
