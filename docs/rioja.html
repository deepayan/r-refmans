<!DOCTYPE html><html lang="en"><head><title>Help for package rioja</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rioja}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rioja-package'>
<p>Analysis of Quaternary Science Data</p></a></li>
<li><a href='#aber'><p>Abernethy Forest pollen data</p></a></li>
<li><a href='#chclust'><p>Constrained hierarchical clustering</p></a></li>
<li><a href='#compare.datasets'><p>Compare datasets for matching variables (species)</p></a></li>
<li><a href='#gutils'><p>Graphic utilities.</p></a></li>
<li><a href='#IK'><p>Imbrie and Kipp foraminifera data</p></a></li>
<li><a href='#IKFA'><p>Imbrie &amp; Kipp Factor Analysis</p></a></li>
<li><a href='#inkspot'><p>Two-way ordered bubble plot of a species by sites data table</p></a></li>
<li><a href='#interp.dataset'><p>Interpolate a dataset</p></a></li>
<li><a href='#LWR'><p>Weighted averaging (LWR) regression and calibration</p></a></li>
<li><a href='#MAT'><p>Palaeoenvironmental reconstruction using the Modern Analogue Technique (MAT)</p></a></li>
<li><a href='#Merge'><p>Merges two or more data frames on the basis of common column names.</p></a></li>
<li><a href='#MLRC'><p>Palaeoenvironmental reconstruction using Maximum Likelihood Response Surfaces</p></a></li>
<li><a href='#MLRC2'><p>Palaeoenvironmental reconstruction using Maximum Likelihood Response Surfaces</p></a></li>
<li><a href='#MR'><p>Multiple regression</p></a></li>
<li><a href='#Ponds'><p>Southeast England ponds and pools diatom and water chemistry dataset.</p></a></li>
<li><a href='#PTF'><p>Palaeoecological transfer functions</p></a></li>
<li><a href='#randomPTF'><p>Random transfer functions to calculate variable importance</p></a></li>
<li><a href='#rioja-internal'><p>Internal rioja functions.</p></a></li>
<li><a href='#RLGH'><p>Diatom stratigraphic data from the Round Loch of Glenhead, Galloway, Southwest Scotland</p></a></li>
<li><a href='#strat.plot'><p> Plot a stratigraphic diagram</p></a></li>
<li><a href='#SWAP'><p>SWAP surface sediment diatom data and lake-water pH.</p></a></li>
<li><a href='#utils'><p>Utility functions.</p></a></li>
<li><a href='#WA'><p>Weighted averaging (WA) regression and calibration</p></a></li>
<li><a href='#WAPLS'><p>Weighted averaging partial least squares (WAPLS) regression and calibration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Quaternary Science Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Juggins &lt;Stephen.Juggins@ncl.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>vegan, mgcv, grDevices, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreach</td>
</tr>
<tr>
<td>Description:</td>
<td>Constrained clustering, transfer functions, and other methods for analysing Quaternary science data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.staff.ncl.ac.uk/stephen.juggins/">http://www.staff.ncl.ac.uk/stephen.juggins/</a>,
<a href="https://github.com/nsj3/rioja">https://github.com/nsj3/rioja</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-26 10:16:28 UTC; Steph</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Juggins <a href="https://orcid.org/0000-0003-4466-424X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-26 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rioja-package'>
Analysis of Quaternary Science Data
</h2><span id='topic+rioja-package'></span><span id='topic+rioja'></span>

<h3>Description</h3>

<p><code>rioja</code>: An R package for the analysis of Quaternary science data. Contains functions for constrained clustering, transfer functions, and plotting stratigraphic data.
</p>


<h3>Details</h3>

<p>The <em>rioja</em> package contains a number of tools for analysing and visualising (bio)stratigraphic data and for developing palaeoecological transfer functions from a dataset of modern species counts and environmental measurements. Resulting models can be cross-validated using the <em>crossval</em> function, which allows internal cross-validation using leave-one-out, leave-n-out, bootstrapping or h-block cross-validation.
</p>

<p>Index of help topics:
</p>
<pre>
IK                      Imbrie and Kipp foraminifera data
IKFA                    Imbrie &amp; Kipp Factor Analysis
LWR                     Weighted averaging (LWR) regression and
                        calibration
MAT                     Palaeoenvironmental reconstruction using the
                        Modern Analogue Technique (MAT)
MLRC                    Palaeoenvironmental reconstruction using
                        Maximum Likelihood Response Surfaces
MLRC2                   Palaeoenvironmental reconstruction using
                        Maximum Likelihood Response Surfaces
MR                      Multiple regression
Merge                   Merges two or more data frames on the basis of
                        common column names.
Ponds                   Southeast England ponds and pools diatom and
                        water chemistry dataset.
RLGH                    Diatom stratigraphic data from the Round Loch
                        of Glenhead, Galloway, Southwest Scotland
SWAP                    SWAP surface sediment diatom data and
                        lake-water pH.
WA                      Weighted averaging (WA) regression and
                        calibration
WAPLS                   Weighted averaging partial least squares
                        (WAPLS) regression and calibration
aber                    Abernethy Forest pollen data
chclust                 Constrained hierarchical clustering
compare.datasets        Compare datasets for matching variables
                        (species)
hulls                   Graphic utilities.
inkspot                 Two-way ordered bubble plot of a species by
                        sites data table
interp.dataset          Interpolate a dataset
make.dummy              Utility functions.
performance             Palaeoecological transfer functions
randomPTF               Random transfer functions to calculate variable
                        importance
rioja-package           Analysis of Quaternary Science Data
strat.plot              Plot a stratigraphic diagram
</pre>


<h3>Author(s)</h3>

<p>Steve Juggins
</p>
<p>Maintainer: Steve Juggins &lt;Stephen.Juggins@ncl.ac.uk&gt;
</p>

<hr>
<h2 id='aber'>Abernethy Forest pollen data</h2><span id='topic+aber'></span>

<h3>Description</h3>

<p>Pollen stratigraphic data from Abernethy Forest, Scotland, spanning approximately 5500 - 12100 BP (from Birks &amp; Mathews 1978).  The data are a list with the following named components: <code>spec</code> Data are percentages of 36 dryland pollen taxa in 49 samples, (<code>ages</code>) core depths and ages for the 49 stratigraphic levels, and (<code>names</code>) codes and full names for the 36 taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(aber)
</code></pre>


<h3>Source</h3>

<p>Birks, HH &amp; Mathews, RW (1978). Studies in the vegetational history of Scotland V. Late Devensian and early Flandrian macrofossil stratigraphy at Abernethy Forest, Invernessshire. <em>New Phytologist</em> <b>80</b>, 455-84.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aber)
strat.plot(aber$spec, scale.percent=TRUE, y.rev=TRUE)
</code></pre>

<hr>
<h2 id='chclust'>Constrained hierarchical clustering</h2><span id='topic+chclust'></span><span id='topic+plot.chclust'></span><span id='topic+bstick'></span><span id='topic+bstick.chclust'></span>

<h3>Description</h3>

<p>Constrained hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chclust(d, method = "coniss")

## S3 method for class 'chclust'
plot(x, labels = NULL, hang = 0.1, axes = TRUE,
      xvar=1:(length(x$height)+1), xlim=NULL, ylim=NULL, 
      x.rev = FALSE, y.rev=FALSE, horiz=FALSE, ...)

bstick(n, ...)

## S3 method for class 'chclust'
bstick(n, ng=10, plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chclust_+3A_d">d</code></td>
<td>
<p> a dissimilarity structure as produced, for example, by <code>dist</code> or <code>vegdist</code>. </p>
</td></tr>
<tr><td><code id="chclust_+3A_method">method</code></td>
<td>
<p> the agglomeration method to be used. This should be (an unambiguous abbreviation of) either &quot;coniss&quot; or &quot;conslink&quot;. </p>
</td></tr>
<tr><td><code id="chclust_+3A_x">x</code>, <code id="chclust_+3A_n">n</code></td>
<td>
<p> a constrained cluster object of class <code>chclust</code> produced by chclust. </p>
</td></tr>
<tr><td><code id="chclust_+3A_xvar">xvar</code></td>
<td>
<p> numeric vector containing x-coordinates for the leaves of the dendrogram (see <em>details</em> below). </p>
</td></tr>
<tr><td><code id="chclust_+3A_x.rev">x.rev</code>, <code id="chclust_+3A_y.rev">y.rev</code></td>
<td>
<p> logical flags to reverse the x- or y-axis (and dendrogram labels). Defaults to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="chclust_+3A_horiz">horiz</code></td>
<td>
<p> logical indicating if the dendrogram should be drawn horizontally or not. Note that y-axis still refers to the dendrogram height even after rotating. </p>
</td></tr>
<tr><td><code id="chclust_+3A_xlim">xlim</code>, <code id="chclust_+3A_ylim">ylim</code></td>
<td>
<p> optional x- and y-limits of the plot, passed to the underlying plto function. The defaults for these show the full dendrogram. </p>
</td></tr>
<tr><td><code id="chclust_+3A_labels">labels</code>, <code id="chclust_+3A_hang">hang</code>, <code id="chclust_+3A_axes">axes</code></td>
<td>
<p> further arguments as in <code>hclust</code>. </p>
</td></tr>
<tr><td><code id="chclust_+3A_ng">ng</code></td>
<td>
<p> number of groups to display. </p>
</td></tr>
<tr><td><code id="chclust_+3A_plot">plot</code></td>
<td>
<p> logical to plot a broken stick model. Defaults to <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="chclust_+3A_...">...</code></td>
<td>
<p> further graphical arguments. Use <code>cex</code> to change the text size of the x-axis labels, and <code>cex.axis</code> to change size of the y-axis values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chclust</code> performs a constrained hierarchical clustering of a distance matrix, with clusters constrained by sample order.  Returns an object of class <code>chclust</code> which can be plotted and interrogated.  See Grimm (1987), Gordon &amp; Birks (1972) and Birks &amp; Gordon (1985) for discusssiom of the coniss and conslink algorithms. The resulting dendrogram can be plotted with <code>plot</code>.  This is an extension of <code>plot</code> method for hclust that allows the dendrogram to be plotted horizontally or vertically (default). <code>plot</code> also accepts a numeric vector coordinates for x-axis positions of the leaves of the dendrogram.  These could, for example, be the stratigraphic depths of core samples or geographic distances along a line transect.
</p>
<p><code>bstick.chclust</code> compares the dispersion of a hierarchical classification to that obtained from a broken stick model and displays the results graphically.  See Bennett (1996) for details. <code>bstick</code> is a generic function and the default method is defined in package <code>vegan</code>. If package <code>vegan</code> is installed the function may be called using <code>vegan::bstick</code>, otherwise use <code>bstick.chclust</code>.
</p>


<h3>Value</h3>

<p>Function <code>chclust</code> returns an object of class <code>chclust</code>, derived from <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Bennett, K. (1996) Determination of the number of zones in a biostratigraphic sequence. <em>New Phytologist</em>, <b>132</b>, 155-170.
</p>
<p>Birks, H.J.B. &amp; Gordon, A.D. (1985) <em>Numerical Methods in Quaternary Pollen Analysis</em> Academic Press, London.
</p>
<p>Gordon, A.D. &amp; Birks, H.J.B. (1972) Numerical methods in Quaternary palaeoecology I. Zonation of pollen diagrams. <em>New Phytologist</em>, <b>71</b>, 961-979.
</p>
<p>Grimm, E.C. (1987) CONISS: A FORTRAN 77 program for stratigraphically constrained cluster analysis by the method of incremental sum of squares. <em>Computers &amp; Geosciences</em>, <b>13</b>, 13-35.
</p>


<h3>See Also</h3>

 
<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>, <code><a href="stats.html#topic+dendrogram">dendrogram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RLGH)
diss &lt;- dist(sqrt(RLGH$spec/100))
clust &lt;- chclust(diss)
bstick(clust, 10)
# Basic diagram
plot(clust, hang=-1)
# Rotated through 90 degrees
plot(clust, hang=-1, horiz=TRUE)
# Rotated and observations plotted according to sample depth.
plot(clust, xvar=RLGH$depths$Depth, hang=-1, horiz=TRUE, x.rev=TRUE)

# Conslink for comparison
clust &lt;- chclust(diss, method = "conslink")
plot(clust, hang=-1)
</code></pre>

<hr>
<h2 id='compare.datasets'>Compare datasets for matching variables (species)</h2><span id='topic+compare.datasets'></span><span id='topic+plot.compare.datasets'></span>

<h3>Description</h3>

<p>Compare two datasets and summarise species occurrance and abundance of species recorded in dataset one across dataset two. Useful for examining the conformity between sediment core and training set species data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.datasets(y1, y2, n.cut=c(5, 10, 20, 50), 
      max.cut=c(2, 5, 10, 20, 50))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare.datasets_+3A_y1">y1</code>, <code id="compare.datasets_+3A_y2">y2</code></td>
<td>
<p> two data frames or matrices, usually of biological species abundance data, to compare. </p>
</td></tr>
<tr><td><code id="compare.datasets_+3A_n.cut">n.cut</code></td>
<td>
<p> vector of abundances to be used for species occurrence calculations (see details). </p>
</td></tr>
<tr><td><code id="compare.datasets_+3A_max.cut">max.cut</code></td>
<td>
<p> vector of occurences to be used for species maximum abundance calculations (see details). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>compare.datasets</code> compares two datasets. It summarise the species profile (number of occurences etc.) and sample profile (number of species in each sample etc.) of dataset 1.  For those species recorded in dataset 1 it also provides summaries of their occurence and abundance in dataset 2.  It is useful diagnostic for checking the conformity between core and training set data, specifically for identifying core taxa absent from the training set, and core samples with portions of their assemblage missing from the training set.
</p>
<p><code><a href="#topic+plot.compare.datasets">plot.compare.datasets</a></code> provides a simple visualisation of the comparisons.  It produces a matrix of plots, one for each sample in dataset 1, showing the abundance of each taxon in dataset 1 (x-axis) against the N2 value of that taxon in dataset 2 (y-axis, with symbols scaled according to abundance in dataset 2.  The plots shouls aid identification of samples with high abundance of taxa that are rare (low N2) or have low abundance in the training set. Taxa thar are absent from the training set are indicated with a red &quot;+&quot;.
</p>


<h3>Value</h3>

<p>Function <code>compare.datasets</code> returns a list with two names elements:
</p>
<table role = "presentation">
<tr><td><code>vars</code></td>
<td>
<p> data frame listing for each variable in the first dataset: N.occur = number of occurences in dataset 1, N2, Hill's N2 for species in dataset 1, Max = maximum value in dataset 1, N.2 = number of occurences in dataset 2, N2.2 = Hill's N2 for species in dataset 2, Max.2 = maximum value in dataset 2, N.005, number of occurences where the species is greater than 5 etc. </p>
</td></tr>
<tr><td><code>objs</code></td>
<td>
<p> data frame listing for each observation in the first dataset: N.taxa = number of species greater than zero abundance, N2, Hill's N2 for samples, Max = maximum value, total =  sample total, M.002 = number of taxa with a maximum abundance greater than 2 2 etc., N2.005 = number of taxa in dataset 1 with more than 5 occurences in 2 dataset 2 etc., Sum.N2.005 = sample total including only those taxa with at least 5 occurrences in dataset 2 etc., M2.005 = number of taxa in dataset 1 with maximum abundance greater than 2 in dataset 2 etc., and Sum. M2.005 = sample total including only those taxa with a maximum abundance greater than 2 in dataset 2 etc. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare diatom data from core from Round Loch of Glenhead
# with SWAP surface sample dataset
data(RLGH)
data(SWAP)
result &lt;- compare.datasets(RLGH$spec, SWAP$spec)
result

</code></pre>

<hr>
<h2 id='gutils'>Graphic utilities. </h2><span id='topic+hulls'></span><span id='topic+figCnvt'></span>

<h3>Description</h3>

<p>Functions to perform simple graphics or enhance existing plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hulls(x, y, gr, col.gr=NULL)

figCnvt(fig1, fig2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gutils_+3A_x">x</code>, <code id="gutils_+3A_y">y</code></td>
<td>
<p> vectors of x, y coordinates. </p>
</td></tr>
<tr><td><code id="gutils_+3A_gr">gr</code></td>
<td>
<p> factor to grop observations. </p>
</td></tr>
<tr><td><code id="gutils_+3A_col.gr">col.gr</code></td>
<td>
<p> a single colour or a vector of colours of length nG, where nG is the number of groups. </p>
</td></tr>
<tr><td><code id="gutils_+3A_fig1">fig1</code>, <code id="gutils_+3A_fig2">fig2</code></td>
<td>
<p> original <code>fig</code> dimensions (<code>fig1</code>) and new <code>fig2</code> dimensions (<code>fig2</code>). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>hulls</code> is a wrapper for <code><a href="grDevices.html#topic+chull">chull</a></code> to add convex hulls to a scatterplot, optionally specifying a different colour for each hull.
</p>
<p>Function <code>figCnvt</code> projects a set of <code>fig</code> dimensions <code>fig2</code> with respect to an original set <code>fig1</code>.  Useful for laying out plots where the ploting region has already been partitioned using <code>fig</code>.
</p>


<h3>Value</h3>

<p>Function <code>figCnvt</code> returns a vector of 4 values specifying the new new figure dimensions.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
with(iris, plot(Sepal.Width, Sepal.Length, col=as.integer(Species)))
with(iris, hulls(Sepal.Width, Sepal.Length, gr=(Species)))
</code></pre>

<hr>
<h2 id='IK'>Imbrie and Kipp foraminifera data</h2><span id='topic+IK'></span>

<h3>Description</h3>

<p>Core-top foraminifera data from the Atlantic and Indian Oceans and core V12.122 from the Carribean published by Imbrie and Kipp (1971).  The data are a list with the following named components: <code>spec</code> relative abundances (percentages) of 22 foraminifera taxa in 61 core-top samples, (<code>env</code>) sea surface temperature and salinity measurements for the core-top samples, and (<code>core</code>) relative abundances of 28 foraminifer taxa in 110 samples from core V12.122.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(IK)
</code></pre>


<h3>References</h3>

<p>Imbrie, J. &amp; Kipp, N.G. (1971). A new micropaleontological method for quantitative paleoclimatology: application to a Late Pleistocene Caribbean core. In <em>The Late Cenozoic Glacial Ages</em> (ed K.K. Turekian), pp. 77-181. Yale University Press, New Haven.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IK)
names(IK$spec)
pairs(IK$env)
</code></pre>

<hr>
<h2 id='IKFA'>Imbrie &amp; Kipp Factor Analysis</h2><span id='topic+IKFA'></span><span id='topic+IKFA.fit'></span><span id='topic+predict.IKFA'></span><span id='topic+crossval.IKFA'></span><span id='topic+performance.IKFA'></span><span id='topic+print.IKFA'></span><span id='topic+summary.IKFA'></span><span id='topic+plot.IKFA'></span><span id='topic+coef.IKFA'></span><span id='topic+fitted.IKFA'></span><span id='topic+residuals.IKFA'></span><span id='topic+screeplot.IKFA'></span><span id='topic+rand.t.test.IKFA'></span><span id='topic+communality'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using Imbrie &amp; Kipp Factor Analysis (IKFA), as used in palaeoceanography.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IKFA(y, x, nFact = 5, IsPoly = FALSE, IsRot = TRUE, 
      ccoef = 1:nFact, check.data=TRUE, lean=FALSE, ...)

IKFA.fit(y, x, nFact = 5, IsPoly = FALSE, IsRot = TRUE, 
      ccoef = 1:nFact, lean=FALSE)

## S3 method for class 'IKFA'
 predict(object, newdata=NULL, sse=FALSE, nboot=100,
      match.data=TRUE, verbose=TRUE, ...)

communality(object, y)

## S3 method for class 'IKFA'
crossval(object, cv.method="loo", verbose=TRUE, ngroups=10,
      nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'IKFA'
performance(object, ...)

## S3 method for class 'IKFA'
rand.t.test(object, n.perm=999, ...)

## S3 method for class 'IKFA'
screeplot(x, rand.test=TRUE, ...)

## S3 method for class 'IKFA'
print(x, ...)

## S3 method for class 'IKFA'
summary(object, full=FALSE, ...)

## S3 method for class 'IKFA'
plot(x, resid=FALSE, xval=FALSE, nFact=max(x$ccoef), 
      xlab="", ylab="", ylim=NULL, xlim=NULL, add.ref=TRUE,
      add.smooth=FALSE, ...)

## S3 method for class 'IKFA'
residuals(object, cv=FALSE, ...)

## S3 method for class 'IKFA'
coef(object, ...)

## S3 method for class 'IKFA'
fitted(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IKFA_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_x">x</code>, <code id="IKFA_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>wa</code>. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_nfact">nFact</code></td>
<td>
<p> number of factor to extract.</p>
</td></tr>
<tr><td><code id="IKFA_+3A_isrot">IsRot</code></td>
<td>
<p> logical to rotate factors. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_ccoef">ccoef</code></td>
<td>
<p> vector of factor numbers to include in the predictions. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_ispoly">IsPoly</code></td>
<td>
<p> logical to include quadratic of the factors as predictors in the regression. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="IKFA_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_resid">resid</code></td>
<td>
<p> logical to plot residuals instead of fitted values. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_xval">xval</code></td>
<td>
<p> logical to plot cross-validation estimates. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_xlab">xlab</code>, <code id="IKFA_+3A_ylab">ylab</code>, <code id="IKFA_+3A_xlim">xlim</code>, <code id="IKFA_+3A_ylim">ylim</code></td>
<td>
<p> additional graphical arguments to <code>plot.wa</code>. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_add.ref">add.ref</code></td>
<td>
<p> add 1:1 line on plot. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_add.smooth">add.smooth</code></td>
<td>
<p> add loess smooth to plot. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;loo&quot;, &quot;lgo&quot;, &quot;bootstrap&quot; or &quot;h-block&quot;. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="IKFA_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation, or a vector contain leave-out group menbership. </p>
</td></tr>  
<tr><td><code id="IKFA_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation. Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation. Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>    
<tr><td><code id="IKFA_+3A_rand.test">rand.test</code></td>
<td>
<p> logical to perform a randomisation t-test to test significance of cross validated factors. </p>
</td></tr> 
<tr><td><code id="IKFA_+3A_n.perm">n.perm</code></td>
<td>
<p> number of permutations for randomisation t-test. </p>
</td></tr> 
<tr><td><code id="IKFA_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="IKFA_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>IKFA</code> performs Imbrie and Kipp Factor Analysis, a form of Principal Components Regrssion (Imbrie &amp; Kipp 1971). 
</p>
<p>Function <code>predict</code> predicts values of the environemntal variable for <code>newdata</code> or returns the fitted (predicted) values from the original modern dataset if <code>newdata</code> is <code>NULL</code>. Variables are matched between training and newdata by column name (if <code>match.data</code> is <code>TRUE</code>).  Use <code><a href="#topic+compare.datasets">compare.datasets</a></code> to assess conformity of two species datasets and identify possible no-analogue samples.
</p>
<p><code>IKFA</code> has methods <code>fitted</code> and <code>rediduals</code> that return the fitted values (estimates) and residuals for the training set, <code>performance</code>, which returns summary performance statistics (see below), <code>coef</code> which returns the species coefficients, and <code>print</code> and <code>summary</code> to summarise the output. <code>IKFA</code> also has a <code>plot</code> method that produces scatter plots of predicted vs observed measurements for the training set.
</p>
<p>Function <code><a href="#topic+rand.t.test">rand.t.test</a></code> performs a randomisation t-test to test the significance of the cross-validated components after van der Voet (1994).
</p>
<p>Function <code>screeplot</code> displays the RMSE of prediction for the training set as a function of the number of factors and is useful for estimating the optimal number for use in prediction. By default <code>screeplot</code> will also carry out a randomisation t-test and add a line to scree plot indicating percentage change in RMSE with each component annotate with the p-value from the randomisation test.
</p>


<h3>Value</h3>

<p>Function <code>IKFA</code> returns an object of class <code>IKFA</code> with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> species coefficients (the updated &quot;optima&quot;). </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> fitted values for the training set. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> original function call. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> environmental variable used in the model. </p>
</td></tr>
<tr><td><code>standx</code>, <code>meanT sdx</code></td>
<td>
<p> additional information returned for a PLSif model. </p>
</td></tr>
</table>
<p>Function <code>crossval</code> also returns an object of class <code>IKFA</code> and adds the following named elements:
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p> predicted values of each training set sample under cross-validation. </p>
</td></tr>
<tr><td><code>residuals.cv</code></td>
<td>
<p> prediction residuals. </p>
</td></tr>
</table>
<p>If function <code>predict</code> is called with <code>newdata=NULL</code> it returns the fitted values of the original model, otherwise it returns a list with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> predicted values for <code>newdata</code>. </p>
</td></tr>
</table>
<p>If sample specific errors were requested the list will also include:
</p>
<table role = "presentation">
<tr><td><code>fit.boot</code></td>
<td>
<p> mean of the bootstrap estimates of newdata. </p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p> standard error of the bootstrap estimates for each new sample. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p> root mean squared error for the training set samples, across all bootstram samples. </p>
</td></tr>
<tr><td><code>SEP</code></td>
<td>
<p> standard error of prediction, calculated as the square root of v1^2 + v2^2. </p>
</td></tr>
</table>
<p>Function <code>performance</code> returns a matrix of performance statistics for the IKFA model.  See <code><a href="#topic+performance">performance</a></code>, for a description of the summary.
</p>
<p>Function <code><a href="#topic+rand.t.test">rand.t.test</a></code> returns a matrix of performance statistics together with columns indicating the p-value and percentage change in RMSE with each higher component (see van der Veot (1994) for details).
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Imbrie, J. &amp; Kipp, N.G. (1971). A new micropaleontological method for quantitative paleoclimatology: application to a Late Pleistocene Caribbean core. In <em>The Late Cenozoic Glacial Ages</em> (ed K.K. Turekian), pp. 77-181. Yale University Press, New Haven.
</p>
<p>van der Voet, H. (1994) Comparing the predictive accuracy of models uing a simple randomization test. <em>Chemometrics and Intelligent Laboratory Systems</em>, <b>25</b>, 313-323.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+MAT">MAT</a></code>, <code><a href="#topic+performance">performance</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IK)
spec &lt;- IK$spec
SumSST &lt;- IK$env$SumSST
core &lt;- IK$core

fit &lt;- IKFA(spec, SumSST)
fit
# cross-validate model
fit.cv &lt;- crossval(fit, cv.method="lgo")
# How many components to use?
screeplot(fit.cv)

#predict the core
pred &lt;- predict(fit, core, npls=2)

#plot predictions - depths are in rownames
depth &lt;- as.numeric(rownames(core))
plot(depth, pred$fit[, 2], type="b")

# fit using only factors 1, 2, 4, &amp; 5
# and using polynomial terms
# as Imbrie &amp; Kipp (1971)
fit2 &lt;- IKFA(spec, SumSST, ccoef=c(1, 2, 4, 5), IsPoly=TRUE)
fit2.cv &lt;- crossval(fit2, cv.method="lgo")
screeplot(fit2.cv)

## Not run: 
# predictions with sample specific errors
# takes approximately 1 minute to run
pred &lt;- predict(fit, core, sse=TRUE, nboot=1000)
pred

## End(Not run)
</code></pre>

<hr>
<h2 id='inkspot'>Two-way ordered bubble plot of a species by sites data table</h2><span id='topic+inkspot'></span>

<h3>Description</h3>

<p>Plots a two-way ordered bubble plot of a species by sites data table, where species are rows and sites are columns.  The sites can be ordered and the functions will sort species to cluster abundances on the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inkspot(data, gradient=1:nrow(data), use.rank=FALSE, 
      reorder.species = TRUE, x.axis=c("sites", "gradient", 
      "none"), x.axis.top=FALSE, site.names=NULL, spec.names=NULL, 
      pch=21, cex.max=3, col="black", bg="darkgrey", 
      x.grid=FALSE, y.grid=FALSE, grid.col="grey", grid.lty="dotted",
      legend.values=c(2, 5, 10, 20, 50), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inkspot_+3A_data">data</code></td>
<td>
<p> data frame to be plotted. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_gradient">gradient</code></td>
<td>
<p> a vector for ordering sites along the x-axis. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_use.rank">use.rank</code></td>
<td>
<p> logical to indicate that the rank rather than absolute values of gradient should be used to plot site positions. Defaults to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_reorder.species">reorder.species</code></td>
<td>
<p> should species be reordered to reflect pattern in site ordering?  Defaults to <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_x.axis">x.axis</code></td>
<td>
<p> controls labelling of x.axis. <code>sites</code> uses site names, <code>gradient</code> plots an axis relecting values of the supplied gradient, and <code>none</code> omits labels and draws ticks at the site positions. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_x.axis.top">x.axis.top</code></td>
<td>
<p> logical to include  an x-axis on the top of the figure labelled with values of the gradient. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_site.names">site.names</code>, <code id="inkspot_+3A_spec.names">spec.names</code></td>
<td>
<p> character vectors of site or species names to annotate the axes.  Defaults to row and column names. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_cex.max">cex.max</code></td>
<td>
<p> maximum size of plotting symbol.  Symbols are scaled so maximum species abundance has a symbol of this size. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_pch">pch</code>, <code id="inkspot_+3A_col">col</code>, <code id="inkspot_+3A_bg">bg</code></td>
<td>
<p> plotting symbol and line / fill colour. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>plot</code>. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_legend.values">legend.values</code></td>
<td>
<p> if not null, places a legend in the top-left corner displaying the listed values. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_x.grid">x.grid</code>, <code id="inkspot_+3A_y.grid">y.grid</code></td>
<td>
<p> draw grid at x and y ticks. </p>
</td></tr>
<tr><td><code id="inkspot_+3A_grid.col">grid.col</code>, <code id="inkspot_+3A_grid.lty">grid.lty</code></td>
<td>
<p>grid colour and line type. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>inkspot</code> plots a two-way table of species by sites as a bubble plot, with sites ordered along the x-axis, species on the y-axis, and abundance indiacted by scaled symbols (&quot;bubbles&quot;). It is a useful way to visualise species distribution along an envionmental, spatial or temporal gradient. If <code>gradient</code> is not given sites are plotting in the order they appear in the input data. Otherwise sites are plotting according to the values in <code>gradient</code>. If site labels overlap (multiple sites at similar values of <code>gradient</code>), labels can be suppressed <code>x.axis= "none"</code>, or replaced with the gradient axis <code>x.axis="gradient"</code>. A gradient axis can also be added to the top x.axis (<code>x.axis.top=TRUE</code>.  Symbols are scaled so that the maximu abundance has a symbol size of <code>cex.max</code>. If sites are spaced unvenly along the gradient, or if many labels overlap, sites may be plotted evenly spaced using <code>use.rank=TRUE</code>. In this case the function will place top axis labels (if requested) at the appropriate positions along the gradient.
</p>


<h3>Value</h3>

<p>Function <code>inkspot</code> returns a list with two named elements:
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>index of the species order. </p>
</td></tr> 
<tr><td><code>site</code></td>
<td>
<p>index of the site order. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>See Also</h3>

 
<p><code><a href="vegan.html#topic+vegemite">vegemite</a></code> in package <code>vegan</code> for a tabular alternative.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SWAP)
mx &lt;- apply(SWAP$spec, 2, max)
spec &lt;- SWAP$spec[, mx &gt; 10]
#basic plot of data with legend
inkspot(spec, cex.axis=0.6)

#order sites by pH
pH &lt;- SWAP$pH
inkspot(spec, pH, cex.axis=0.6)

# add a top axis
inkspot(spec, pH, x.axis.top=TRUE, cex.axis=0.6)

# order by pH but plot sites at regular intervals to avoid label overlap
inkspot(spec, pH, use.rank=TRUE, x.axis.top=TRUE, cex.axis=0.6)

# or add long taxon names
oldmar &lt;- par("mar")
par(mar=c(3,12,2,1))
nms &lt;- SWAP$names[mx &gt; 10, 2]
inkspot(spec, pH, spec.names=as.character(nms), use.rank=TRUE, 
x.axis.top=TRUE, cex.axis=0.6)
par(mar=oldmar)
</code></pre>

<hr>
<h2 id='interp.dataset'>Interpolate a dataset</h2><span id='topic+interp.dataset'></span>

<h3>Description</h3>

<p>Given a data frame of variables measured along a temporal or spatial gradient, interpolate each variable to new values of the gradient.  Useful for interpolating sediment core data to the depths ot ages of another sequences, or to evenly spaced intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp.dataset(y, x, xout, method=c("linear","loess","sspline"), 
     rep.negt=TRUE, span=0.25, df=min(20, nrow(y)*.7), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp.dataset_+3A_y">y</code></td>
<td>
<p> data frame to be interpolated. </p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_x">x</code></td>
<td>
<p> numeric vector giving ages, depths (ie. x-values( for data frame to be interpolated. </p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_xout">xout</code></td>
<td>
<p> numeric vector of values to interpolate to. </p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_method">method</code></td>
<td>
<p> interpolation method, should be an unambiguous abbreviation of either linear, loess, sspline
or aspline. See details.</p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_rep.negt">rep.negt</code></td>
<td>
<p> logical to indicate whether or not to replace negative values with zero in the interpolated data. </p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_span">span</code></td>
<td>
<p> span for loess, default=0.25. </p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_df">df</code></td>
<td>
<p> degress of freedome for smoothing spline, default is the lower of 20 or 0.7 * number of samples. </p>
</td></tr>
<tr><td><code id="interp.dataset_+3A_...">...</code></td>
<td>
<p> additional arguments to <code>approx</code>, <code>loess</code> and <code>smooth.spline</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>interp.dataset</code> interpolates the columns of data frame with rows measured at intervals given by <code>x</code>, to new intervals given by <code>xout</code>. This function is useful to interpolation one set of sediment core data to the depth or ages of another, or to a regular set of intervals. Interpolation can be done using linear interpolation between data points in the original series (default) using function 'approx' in package 'stats', using <code><a href="stats.html#topic+loess">loess</a></code> locally weighted regression, or by <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. The latter two methods will also smooth the data and additional arguments may be passed to these functions to control the amount of smoothing. 
</p>


<h3>Value</h3>

<p>Function <code>interp.datasets</code> returns a data frame of the input data interpolated to the values given in <code>xout</code>. Values of <code>xout</code> outside the range of the original data are replaced by <code>NA</code>.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>See Also</h3>

 
<p><code><a href="stats.html#topic+loess">loess</a></code>, and <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for details of interpolation methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RLGH)
spec &lt;- RLGH$spec
depth &lt;- RLGH$depths$Depth

# interpolate new dataset to every 0.5 cm
# using default method (linear)
x.new &lt;- seq(0, 20, by=0.5)
sp.interp &lt;- interp.dataset(y=spec, x=depth, xout=x.new)
## Not run: 
# examine the results and compare to original data 
strat.plot.simple(spec, depth, sp.interp, x.new)

## End(Not run)
</code></pre>

<hr>
<h2 id='LWR'>Weighted averaging (LWR) regression and calibration</h2><span id='topic+LWR'></span><span id='topic+LWR.fit'></span><span id='topic+predict.LWR'></span><span id='topic+crossval.LWR'></span><span id='topic+performance.LWR'></span><span id='topic+print.LWR'></span><span id='topic+summary.LWR'></span><span id='topic+plot.LWR'></span><span id='topic+coef.LWR'></span><span id='topic+fitted.LWR'></span><span id='topic+residuals.LWR'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using weighted averaging (LWR) regression and calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LWR(y, x, FUN=WA, dist.method="sq.chord", k=30, lean=TRUE, 
       fit.model=TRUE, check.data=TRUE, verbose=TRUE, ...)

## S3 method for class 'LWR'
 predict(object, newdata=NULL, k = object$k, sse=FALSE, 
      nboot=100, match.data=TRUE, verbose=TRUE, lean=TRUE, ...)

## S3 method for class 'LWR'
crossval(object, k=object$k, cv.method="lgo", verbose=TRUE, 
      ngroups=10, nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'LWR'
performance(object, ...)

## S3 method for class 'LWR'
print(x, ...)

## S3 method for class 'LWR'
summary(object, full=FALSE, ...)

## S3 method for class 'LWR'
residuals(object, cv=FALSE, ...)

## S3 method for class 'LWR'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LWR_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="LWR_+3A_x">x</code>, <code id="LWR_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>LWR</code>. </p>
</td></tr>
<tr><td><code id="LWR_+3A_dist.method">dist.method</code></td>
<td>
<p> distance measure used to derfine closest analogues. </p>
</td></tr>
<tr><td><code id="LWR_+3A_k">k</code></td>
<td>
<p> number of close analogues to use in calibration function. </p>
</td></tr>
<tr><td><code id="LWR_+3A_fun">FUN</code></td>
<td>
<p> calibration function (e.g. <code>WA</code>, <code>WAPLS</code> etc). </p>
</td></tr>
<tr><td><code id="LWR_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="LWR_+3A_fit.model">fit.model</code></td>
<td>
<p> TRUE fits model to training set.  FALSE omist this step and builds a LWR object than can be used for prediction. </p>
</td></tr>
<tr><td><code id="LWR_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="LWR_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="LWR_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="LWR_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="LWR_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;lgo&quot; or &quot;bootstrap&quot;. </p>
</td></tr>
<tr><td><code id="LWR_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validaton. </p>
</td></tr>
<tr><td><code id="LWR_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="LWR_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation. </p>
</td></tr>
<tr><td><code id="LWR_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation.  Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="LWR_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation.  Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="LWR_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>    
<tr><td><code id="LWR_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="LWR_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>LWR</code> performs ... To do.
</p>


<h3>Value</h3>

<p>Function <code>LWR</code> returns an object of class <code>LWR</code> with the following named elements:
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WAPLS">WAPLS</a></code>, <code><a href="#topic+MAT">MAT</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>

<hr>
<h2 id='MAT'>Palaeoenvironmental reconstruction using the Modern Analogue Technique (MAT)</h2><span id='topic+MAT'></span><span id='topic+predict.MAT'></span><span id='topic+paldist'></span><span id='topic+paldist2'></span><span id='topic+performance.MAT'></span><span id='topic+crossval.MAT'></span><span id='topic+print.MAT'></span><span id='topic+summary.MAT'></span><span id='topic+plot.MAT'></span><span id='topic+fitted.MAT'></span><span id='topic+residuals.MAT'></span><span id='topic+screeplot.MAT'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using the Modern Analogue Technique (MAT), also know as k nearest neighbours (k-NN).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAT(y, x, dist.method="sq.chord", k=5, lean=TRUE)

## S3 method for class 'MAT'
predict(object, newdata=NULL, k=object$k, sse=FALSE, 
        nboot=100, match.data=TRUE, verbose=TRUE, lean=TRUE, 
        ...)

## S3 method for class 'MAT'
performance(object, ...)

## S3 method for class 'MAT'
crossval(object, k=object$k, cv.method="lgo", 
        verbose=TRUE, ngroups=10, nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'MAT'
print(x, ...)

## S3 method for class 'MAT'
summary(object, full=FALSE, ...)

## S3 method for class 'MAT'
plot(x, resid=FALSE, xval=FALSE, k=5, wMean=FALSE, xlab="", 
      ylab="", ylim=NULL, xlim=NULL, add.ref=TRUE,
      add.smooth=FALSE, ...)

## S3 method for class 'MAT'
residuals(object, cv=FALSE, ...)

## S3 method for class 'MAT'
fitted(object, ...)

## S3 method for class 'MAT'
screeplot(x, ...)

paldist(y, dist.method="sq.chord")

paldist2(y1, y2, dist.method="sq.chord")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAT_+3A_y">y</code>, <code id="MAT_+3A_y1">y1</code>, <code id="MAT_+3A_y2">y2</code></td>
<td>
<p> data frame containing biological data. </p>
</td></tr>
<tr><td><code id="MAT_+3A_newdata">newdata</code></td>
<td>
<p> data frame containing biological data to predict from. </p>
</td></tr>
<tr><td><code id="MAT_+3A_x">x</code></td>
<td>
<p> a vector of environmental values to be modelled, matched to y. </p>
</td></tr>
<tr><td><code id="MAT_+3A_dist.method">dist.method</code></td>
<td>
<p> dissimilarity coefficient. See details for options.</p>
</td></tr>
<tr><td><code id="MAT_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="MAT_+3A_k">k</code></td>
<td>
<p> number of analogues to use. </p>
</td></tr>
<tr><td><code id="MAT_+3A_lean">lean</code></td>
<td>
<p> logical to remove items form the output. </p>
</td></tr>
<tr><td><code id="MAT_+3A_object">object</code></td>
<td>
<p> an object of class <code>MAT</code>. </p>
</td></tr>
<tr><td><code id="MAT_+3A_resid">resid</code></td>
<td>
<p> logical to plot residuals instead of fitted values. </p>
</td></tr>
<tr><td><code id="MAT_+3A_xval">xval</code></td>
<td>
<p> logical to plot cross-validation estimates. </p>
</td></tr>
<tr><td><code id="MAT_+3A_wmean">wMean</code></td>
<td>
<p> logical to plot weighted-mean estimates. </p>
</td></tr>
<tr><td><code id="MAT_+3A_xlab">xlab</code>, <code id="MAT_+3A_ylab">ylab</code>, <code id="MAT_+3A_xlim">xlim</code>, <code id="MAT_+3A_ylim">ylim</code></td>
<td>
<p> additional graphical arguments to <code>plot.wa</code>. </p>
</td></tr>
<tr><td><code id="MAT_+3A_add.ref">add.ref</code></td>
<td>
<p> add 1:1 line on plot. </p>
</td></tr>
<tr><td><code id="MAT_+3A_add.smooth">add.smooth</code></td>
<td>
<p> add loess smooth to plot. </p>
</td></tr>
<tr><td><code id="MAT_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;lgo&quot;, &quot;bootstrap&quot; or &quot;h-block&quot;. </p>
</td></tr>
<tr><td><code id="MAT_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="MAT_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="MAT_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation, or a vector contain leave-out group menbership. </p>
</td></tr>  
<tr><td><code id="MAT_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation.  Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="MAT_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation.  Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="MAT_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>  
<tr><td><code id="MAT_+3A_full">full</code></td>
<td>
<p> logical to indicate a full or abbreviated summary. </p>
</td></tr>
<tr><td><code id="MAT_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="MAT_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MAT</code> performs an environmental reconstruction using the modern analogue technique. Function <code>MAT</code> takes a training dataset of biological data (species abundances) <code>y</code> and a single associated environmental variable <code>x</code>, and generates a model of closest analogues, or matches, for the modern data data using one of a number of dissimilarity coefficients. Options for the latter are: &quot;euclidean&quot;, &quot;sq.euclidean&quot;, &quot;chord&quot;, &quot;sq.chord&quot;, &quot;chord.t&quot;, &quot;sq.chord.t&quot;, &quot;chi.squared&quot;, &quot;sq.chi.squared&quot;, &quot;bray&quot;. &quot;chord.t&quot; are true chord distances, &quot;chord&quot; refers to the the variant of chord distance using in palaeoecology (e.g. Overpeck et al. 1985), which is actually Hellinger's distance (Legendre &amp; Gallagher 2001). There are various help functions to plot and extract information from the results of a <code>MAT</code> transfer function. The function <code>predict</code> takes <code>MAT</code> object and uses it to predict environmental values for a new set of species data, or returns the fitted (predicted) values from the original modern dataset if <code>newdata</code> is <code>NULL</code>. Variables are matched between training and newdata by column name (if <code>match.data</code> is <code>TRUE</code>).  Use <code><a href="#topic+compare.datasets">compare.datasets</a></code> to assess conformity of two species datasets and identify possible no-analogue samples.
</p>
<p><code>MAT</code> has methods <code>fitted</code> and <code>rediduals</code> that return the fitted values (estimates) and residuals for the training set, <code>performance</code>, which returns summary performance statistics (see below), and <code>print</code> and <code>summary</code> to summarise the output. <code>MAT</code> also has a <code>plot</code> method that produces scatter plots of predicted vs observed measurements for the training set.
</p>
<p>Function <code>screeplot</code> displays the RMSE of prediction for the training set as a function of the number of analogues (k) and is useful for estimating the optimal value of k for use in prediction. 
</p>
<p><code>paldist</code> and <code>paldist1</code> are helper functions though they may be called directly. <code>paldist</code> takes a single data frame or matrix returns a distance matrix of the row-wise dissimilarities.  <code>paldist2</code> takes two data frames of matrices and returns a matrix of all row-wise dissimilarities between the two datasets.
</p>


<h3>Value</h3>

<p>Function <code>MAT</code> returns an object of class <code>MAT</code> which contains the following items:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p> original function call to <code>MAT</code>. </p>
</td></tr>
<tr><td><code>fitted.vales</code></td>
<td>
<p> fitted (predicted) values for the training set, as the mean and weighted mean (weighed by dissimilarity) of the k closest analogues. </p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p> standard deviation of the k analogues and dissimilarity of the closest analogue. </p>
</td></tr>
<tr><td><code>dist.n</code></td>
<td>
<p> dissimilarities of the k closest analogues. </p>
</td></tr>
<tr><td><code>x.n</code></td>
<td>
<p> environmental values of the k closest analogues. </p>
</td></tr>
<tr><td><code>match.name</code></td>
<td>
<p> column names of the k closest analogues. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> environmental variable used in the model. </p>
</td></tr>
<tr><td><code>dist.method</code></td>
<td>
<p> dissimilarity coefficient. </p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p> number of closest analogues to use. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> original species data. </p>
</td></tr>
<tr><td><code>cv.summary</code></td>
<td>
<p> summary of the cross-validation (not yet implemented). </p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p> dissimilarity matrix (returned if <code>lean=FALSE</code>). </p>
</td></tr>
</table>
<p>If function <code>predict</code> is called with <code>newdata=NULL</code> it returns a matrix of fitted values from the original training set analysis.  If <code>newdata</code> is not <code>NULL</code> it returns list with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> predictions for <code>newdata</code>. </p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p> standard deviations of the k closest analogues and distance of closest analogue. </p>
</td></tr>
<tr><td><code>dist.n</code></td>
<td>
<p> dissimilarities of the k closest analogues. </p>
</td></tr>
<tr><td><code>x.n</code></td>
<td>
<p> environmental values of the k closest analogues. </p>
</td></tr>
<tr><td><code>match.name</code></td>
<td>
<p> column names of the k closest analogues. </p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p> dissimilarity matrix (returned if <code>lean=FALSE</code>). </p>
</td></tr>
</table>
<p>If sample specific errors were requested the list will also include:
</p>
<table role = "presentation">
<tr><td><code>fit.boot</code></td>
<td>
<p> mean of the bootstrap estimates of newdata. </p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p> standard error of the bootstrap estimates for each new sample. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p> root mean squared error for the training set samples, across all bootstram samples. </p>
</td></tr>
<tr><td><code>SEP</code></td>
<td>
<p> standard error of prediction, calculated as the square root of v1^2 + v2^2. </p>
</td></tr>
</table>
<p>Functions <code>paldist</code> and <code>paldist2</code> return dissimilarity matrices.  <code>performance</code> returns a matrix of performance statistics for the MAT model, with columns for RMSE, R2, mean and max bias for each number of analogues up to k. See <code><a href="#topic+performance">performance</a></code> for a description of the output.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Legendre, P. &amp; Gallagher, E. (2001) Ecologically meaningful transformations for ordination of species. <em>Oecologia</em>, <b>129</b>, 271-280.
</p>
<p>Overpeck, J.T., Webb, T., III, &amp; Prentice, I.C. (1985) Quantitative interpretation of fossil pollen spectra: dissimilarity coefficients and the method of modern analogs. <em>Quaternary Research</em>, <b>23</b>, 87-108.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WAPLS">WAPLS</a></code>, <code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+performance">performance</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pH reconstruction of the RLGH, Scotland, using SWAP training set 
# shows recent acidification history
data(SWAP)
data(RLGH)
fit &lt;- MAT(SWAP$spec, SWAP$pH, k=20)  # generate results for k 1-20
#examine performance
performance(fit)
print(fit)
# How many analogues?
screeplot(fit)
# do the reconstruction
pred.mat &lt;- predict(fit, RLGH$spec, k=10)
# plot the reconstruction
plot(RLGH$depths$Age, pred.mat$fit[, 1], type="b", ylab="pH", xlab="Age")

#compare to a weighted average model
fit &lt;- WA(SWAP$spec, SWAP$pH)
pred.wa &lt;- predict(fit, RLGH$spec)
points(RLGH$depths$Age, pred.wa$fit[, 1], col="red", type="b")
legend("topleft", c("MAT", "WA"), lty=1, col=c("black", "red"))
</code></pre>

<hr>
<h2 id='Merge'>Merges two or more data frames on the basis of common column names. </h2><span id='topic+Merge'></span>

<h3>Description</h3>

<p>Merges two or more data frames on the basis of common column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Merge(..., join="outer", fill=0, split=FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Merge_+3A_...">...</code></td>
<td>
<p> two or more data frames to merge. </p>
</td></tr>
<tr><td><code id="Merge_+3A_join">join</code></td>
<td>
<p> type of join to perform.  Should be an unambiguous abbreviation of either &quot;outer&quot;, &quot;inner&quot;, or &quot;leftouter&quot;. An outer join produces a data frame that contains all the unique column names of the input data, ie, the union of all input column names. An inner join produces a data frame containing only column names that are common across the input data, ie. the intersection of the input column names. A left outer join produces a data frame containing all column names of the first data frame only: column names that occur in subsequent data frames are omitted. </p>
</td></tr>
<tr><td><code id="Merge_+3A_fill">fill</code></td>
<td>
<p> value to use to fill non-matched columns. Defaults to zero which is appropriate for species abundance data. </p>
</td></tr>
<tr><td><code id="Merge_+3A_split">split</code></td>
<td>
<p> logical to return a single data frame (TRUE) or a named list containing separate (original) data frames with a common set of merged columns (FALSE). Defaults to TRUE (a single data frame). </p>
</td></tr>
<tr><td><code id="Merge_+3A_verbose">verbose</code></td>
<td>
<p> logical to suppress warning messages. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Merge</code> is a utilty function for combining separate datasets of biological count data that have only a subset of taxa (column names) in common.  The outer join is appropriate for merging prior to a joint ordination or for merging a training set and core data prior to environmental reconstruction using the modern analogue technique (MAT).  A left outer join should be used to prepare data for an ordination of a training set and subsequent projection of a second onto the ordination axes. The function is capitalised to distinguish it from <code>merge</code> in the base R.
</p>


<h3>Value</h3>

<p>If split is set to FALSE the function returns a single data frame with the number of rows equal to the combined rows of the input data and columns sorted alphabetically according to the join type.  Otherwise returns a named list of the merged data frames.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>See Also</h3>

 
<p><code><a href="base.html#topic+merge">merge</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RLGH)
data(SWAP)
# Merge RLGH core data with SWAP training set
# Extract species data from datasets
SWAPsp &lt;- SWAP$spec
RLGHsp &lt;- RLGH$spec
# full outer join for joint ordination of both datasets
comb &lt;- Merge(SWAPsp, RLGHsp)

## Not run: 
# superimpose core trajectory on ordination plot
library(vegan) # decorana
ord &lt;- decorana(comb, iweigh=1)
par(mfrow=c(1,2))
plot(ord, display="sites")
sc &lt;- scores(ord, display="sites")
sc &lt;- sc[(nrow(SWAPsp)+1):nrow(comb), ]
lines(sc, col="red")
title("Joint DCA ordination of surface and core")

# Do the same but this time project core passively
# Note we cannot use data from the outer join since decorana
# will delete taxa only present in the core - the resulting
# ordination model will then not match the taxa in the core
comb2 &lt;- Merge(SWAPsp, RLGHsp, join="leftouter", split=TRUE)
ord2 &lt;- decorana(comb2$SWAPsp, iweigh=1)
sc2 &lt;- predict(ord2, comb2$RLGHsp, type="sites")
plot(ord2, display="sites")
lines(sc2, col="red")
title("DCA with core added \"passively\"")

## End(Not run)
</code></pre>

<hr>
<h2 id='MLRC'>Palaeoenvironmental reconstruction using Maximum Likelihood Response Surfaces</h2><span id='topic+MLRC'></span><span id='topic+MLRC.fit'></span><span id='topic+predict.MLRC'></span><span id='topic+crossval.MLRC'></span><span id='topic+performance.MLRC'></span><span id='topic+print.MLRC'></span><span id='topic+summary.MLRC'></span><span id='topic+plot.MLRC'></span><span id='topic+coef.MLRC'></span><span id='topic+fitted.MLRC'></span><span id='topic+residuals.MLRC'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using Maximum Likelihood response Surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLRC(y, x, check.data=TRUE, lean=FALSE, n.cut=5, verbose=TRUE, ...)

MLRC.fit(y, x, n.cut=2, use.glm=FALSE, max.iter=50, lean=FALSE, verbose=FALSE, ...)

## S3 method for class 'MLRC'
 predict(object, newdata=NULL, sse=FALSE, nboot=100,
      match.data=TRUE, verbose=TRUE, ...)

## S3 method for class 'MLRC'
crossval(object, cv.method="loo", verbose=TRUE, ngroups=10,
      nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'MLRC'
performance(object, ...)

## S3 method for class 'MLRC'
print(x, ...)

## S3 method for class 'MLRC'
summary(object, full=FALSE, ...)

## S3 method for class 'MLRC'
plot(x, resid=FALSE, xval=FALSE, xlab="", ylab="", 
      ylim=NULL, xlim=NULL, add.ref=TRUE, add.smooth=FALSE, ...)

## S3 method for class 'MLRC'
residuals(object, cv=FALSE, ...)

## S3 method for class 'MLRC'
coef(object, ...)

## S3 method for class 'MLRC'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLRC_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_x">x</code>, <code id="MLRC_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>wa</code>. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_n.cut">n.cut</code></td>
<td>
<p> cutoff value for number of occurrences.  Species with fewer than n.cut occurrences will be excluded from the analysis.</p>
</td></tr>
<tr><td><code id="MLRC_+3A_use.glm">use.glm</code></td>
<td>
<p> logical to use <code>glm</code> to fit responses rather than internal code.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MLRC_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_max.iter">max.iter</code></td>
<td>
<p> maximum iterations of the logit regression algorithm.</p>
</td></tr>
<tr><td><code id="MLRC_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="MLRC_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_resid">resid</code></td>
<td>
<p> logical to plot residuals instead of fitted values. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_xval">xval</code></td>
<td>
<p> logical to plot cross-validation estimates. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_xlab">xlab</code>, <code id="MLRC_+3A_ylab">ylab</code>, <code id="MLRC_+3A_xlim">xlim</code>, <code id="MLRC_+3A_ylim">ylim</code></td>
<td>
<p> additional graphical arguments to <code>plot.wa</code>. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_add.ref">add.ref</code></td>
<td>
<p> add 1:1 line on plot. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_add.smooth">add.smooth</code></td>
<td>
<p> add loess smooth to plot. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;loo&quot;, &quot;lgo&quot;, &quot;bootstrap&quot; or &quot;h-block&quot;. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="MLRC_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation, or a vector contain leave-out group menbership. </p>
</td></tr>  
<tr><td><code id="MLRC_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation.  Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation.  Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>    
<tr><td><code id="MLRC_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="MLRC_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>MLRC</code> Maximim likelihood reconstruction using response curves.
</p>
<p>Function <code>predict</code> predicts values of the environemntal variable for <code>newdata</code> or returns the fitted (predicted) values from the original modern dataset if <code>newdata</code> is <code>NULL</code>. Variables are matched between training and newdata by column name (if <code>match.data</code> is <code>TRUE</code>).  Use <code><a href="#topic+compare.datasets">compare.datasets</a></code> to assess conformity of two species datasets and identify possible no-analogue samples.
</p>
<p><code>MLRC</code> has methods <code>fitted</code> and <code>rediduals</code> that return the fitted values (estimates) and residuals for the training set, <code>performance</code>, which returns summary performance statistics (see below), <code>coef</code> which returns the species coefficients, and <code>print</code> and <code>summary</code> to summarise the output. <code>MLRC</code> also has a <code>plot</code> method that produces scatter plots of predicted vs observed measurements for the training set.
</p>


<h3>Value</h3>

<p>Function <code>MLRC</code> returns an object of class <code>MLRC</code> with the following named elements:
</p>
<p>Function <code>crossval</code> also returns an object of class <code>MLRC</code> and adds the following named elements:
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p> predicted values of each training set sample under cross-validation. </p>
</td></tr>
<tr><td><code>residuals.cv</code></td>
<td>
<p> prediction residuals. </p>
</td></tr>
</table>
<p>If function <code>predict</code> is called with <code>newdata=NULL</code> it returns the fitted values of the original model, otherwise it returns a list with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> predicted values for <code>newdata</code>. </p>
</td></tr>
</table>
<p>If sample specific errors were requested the list will also include:
</p>
<table role = "presentation">
<tr><td><code>fit.boot</code></td>
<td>
<p> mean of the bootstrap estimates of newdata. </p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p> standard error of the bootstrap estimates for each new sample. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p> root mean squared error for the training set samples, across all bootstram samples. </p>
</td></tr>
<tr><td><code>SEP</code></td>
<td>
<p> standard error of prediction, calculated as the square root of v1^2 + v2^2. </p>
</td></tr>
</table>
<p>Function <code>performance</code> returns a matrix of performance statistics for the MLRC model.  See <code><a href="#topic+performance">performance</a></code>, for a description of the summary.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Birks, H.J.B., Line, J.M., Juggins, S., Stevenson, A.C., &amp; ter Braak, C.J.F. (1990) Diatoms and pH reconstruction. <em>Philosophical Transactions of the Royal Society of London</em>, <b>B, 327</b>, 263-278.
</p>
<p>Juggins, S. (1992) Diatoms in the Thames Estuary, England: Ecology, Palaeoecology, and Salinity Transfer Function. <em>Bibliotheca Diatomologica</em>, <b>Band 25</b>, 216pp.
</p>
<p>Oksanen, J., Laara, E., Huttunen, P., &amp; Merilainen, J. (1990) Maximum likelihood prediction of lake acidity based on sedimented diatoms. <em>Journal of Vegetation Science</em>, <b>1</b>, 49-56.
</p>
<p>ter Braak, C.J.F. &amp; van Dam, H. (1989) Inferring pH from diatoms: a comparison of old and new calibration methods. <em>Hydrobiologia</em>, <b>178</b>, 209-223.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+MAT">MAT</a></code>, <code><a href="#topic+performance">performance</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IK)
spec &lt;- IK$spec / 100
SumSST &lt;- IK$env$SumSST
core &lt;- IK$core / 100

fit &lt;- MLRC(spec, SumSST)
fit

#predict the core
pred &lt;- predict(fit, core)

#plot predictions - depths are in rownames
depth &lt;- as.numeric(rownames(core))
plot(depth, pred$fit[, 1], type="b")

## Not run: 
# this is slow!
# cross-validate model
fit.cv &lt;- crossval(fit, cv.method="loo", verbose=5)

# predictions with sample specific errors
pred &lt;- predict(fit, core, sse=TRUE, nboot=1000, verbose=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='MLRC2'>Palaeoenvironmental reconstruction using Maximum Likelihood Response Surfaces</h2><span id='topic+MLRC2'></span><span id='topic+MLRC2.fit'></span><span id='topic+predict.MLRC2'></span><span id='topic+performance.MLRC2'></span><span id='topic+print.MLRC2'></span><span id='topic+summary.MLRC2'></span><span id='topic+coef.MLRC2'></span><span id='topic+fitted.MLRC2'></span><span id='topic+residuals.MLRC2'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using Maximum Likelihood response Surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLRC2(y, x, n.out=100, expand.grad=0.1, use.gam=FALSE, check.data=TRUE, 
       lean=FALSE, n.cut=5, verbose=TRUE, ...)

MLRC2.fit(y, x, n.out=100, expand.grad=0.1, use.gam=FALSE, check.data=TRUE, 
       lean=FALSE, n.cut=5, verbose=TRUE, ...)

## S3 method for class 'MLRC2'
 predict(object, newdata=NULL, sse=FALSE, nboot=100,
      match.data=TRUE, verbose=TRUE, ...)

## S3 method for class 'MLRC2'
performance(object, ...)

## S3 method for class 'MLRC2'
print(x, ...)

## S3 method for class 'MLRC2'
summary(object, full=FALSE, ...)

## S3 method for class 'MLRC2'
residuals(object, cv=FALSE, ...)

## S3 method for class 'MLRC2'
coef(object, ...)

## S3 method for class 'MLRC2'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MLRC2_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_x">x</code>, <code id="MLRC2_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>wa</code>. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_n.cut">n.cut</code></td>
<td>
<p> cutoff value for number of occurrences.  Species with fewer than n.cut occurrences will be excluded from the analysis. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_n.out">n.out</code></td>
<td>
<p> to do </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_expand.grad">expand.grad</code></td>
<td>
<p> to do </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_use.gam">use.gam</code></td>
<td>
<p> logical to use <code>gam</code> to fit responses rather than internal code.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MLRC2_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="MLRC2_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>    
<tr><td><code id="MLRC2_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="MLRC2_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>MLRC2</code> Maximim likelihood reconstruction using 2D response curves.
</p>


<h3>Value</h3>

<p>Function <code>MLRC2</code> returns an object of class <code>MLRC2</code> with the following named elements:
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Birks, H.J.B., Line, J.M., Juggins, S., Stevenson, A.C., &amp; ter Braak, C.J.F. (1990) Diatoms and pH reconstruction. <em>Philosophical Transactions of the Royal Society of London</em>, <b>B, 327</b>, 263-278.
</p>
<p>Juggins, S. (1992) Diatoms in the Thames Estuary, England: Ecology, Palaeoecology, and Salinity Transfer Function. <em>Bibliotheca Diatomologica</em>, <b>Band 25</b>, 216pp.
</p>
<p>Oksanen, J., Laara, E., Huttunen, P., &amp; Merilainen, J. (1990) Maximum likelihood prediction of lake acidity based on sedimented diatoms. <em>Journal of Vegetation Science</em>, <b>1</b>, 49-56.
</p>
<p>ter Braak, C.J.F. &amp; van Dam, H. (1989) Inferring pH from diatoms: a comparison of old and new calibration methods. <em>Hydrobiologia</em>, <b>178</b>, 209-223.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+MAT">MAT</a></code>, <code><a href="#topic+performance">performance</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>

<hr>
<h2 id='MR'>Multiple regression</h2><span id='topic+MR'></span><span id='topic+MR.fit'></span><span id='topic+predict.MR'></span><span id='topic+crossval.MR'></span><span id='topic+performance.MR'></span><span id='topic+print.MR'></span><span id='topic+summary.MR'></span><span id='topic+plot.MR'></span><span id='topic+coef.MR'></span><span id='topic+fitted.MR'></span><span id='topic+residuals.MR'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using multiple regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MR(y, x, check.data=TRUE, lean=FALSE, ...)

MR.fit(y, x, lean=FALSE)

## S3 method for class 'MR'
 predict(object, newdata=NULL, sse=FALSE, nboot=100,
      match.data=TRUE, verbose=TRUE, ...)

## S3 method for class 'MR'
crossval(object, cv.method="loo", verbose=TRUE, ngroups=10,
      nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'MR'
performance(object, ...)

## S3 method for class 'MR'
print(x, ...)

## S3 method for class 'MR'
summary(object, full=FALSE, ...)

## S3 method for class 'MR'
plot(x, resid=FALSE, xval=FALSE, xlab="", 
      ylab="", ylim=NULL, xlim=NULL, add.ref=TRUE,
      add.smooth=FALSE, ...)

## S3 method for class 'MR'
residuals(object, cv=FALSE, ...)

## S3 method for class 'MR'
coef(object, ...)

## S3 method for class 'MR'
fitted(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MR_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="MR_+3A_x">x</code>, <code id="MR_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>wa</code>. </p>
</td></tr>
<tr><td><code id="MR_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="MR_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="MR_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="MR_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="MR_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="MR_+3A_resid">resid</code></td>
<td>
<p> logical to plot residuals instead of fitted values. </p>
</td></tr>
<tr><td><code id="MR_+3A_xval">xval</code></td>
<td>
<p> logical to plot cross-validation estimates. </p>
</td></tr>
<tr><td><code id="MR_+3A_xlab">xlab</code>, <code id="MR_+3A_ylab">ylab</code>, <code id="MR_+3A_xlim">xlim</code>, <code id="MR_+3A_ylim">ylim</code></td>
<td>
<p> additional graphical arguments to <code>plot.wa</code>. </p>
</td></tr>
<tr><td><code id="MR_+3A_add.ref">add.ref</code></td>
<td>
<p> add 1:1 line on plot. </p>
</td></tr>
<tr><td><code id="MR_+3A_add.smooth">add.smooth</code></td>
<td>
<p> add loess smooth to plot. </p>
</td></tr>
<tr><td><code id="MR_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;loo&quot;, &quot;lgo&quot;, &quot;bootstrap&quot; or &quot;h-block&quot;. </p>
</td></tr>
<tr><td><code id="MR_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="MR_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="MR_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation, or a vector contain leave-out group menbership. </p>
</td></tr>  
<tr><td><code id="MR_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation. Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="MR_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation. Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="MR_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>    
<tr><td><code id="MR_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="MR_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>MR</code> performs multiple regrssion.  It is a wrapper to <code>lm</code>. 
</p>
<p>Function <code>predict</code> predicts values of the environmental variable for <code>newdata</code> or returns the fitted (predicted) values from the original modern dataset if <code>newdata</code> is <code>NULL</code>. Variables are matched between training and newdata by column name (if <code>match.data</code> is <code>TRUE</code>).  Use <code><a href="#topic+compare.datasets">compare.datasets</a></code> to assess conformity of two species datasets and identify possible no-analogue samples. 
</p>
<p><code>MR</code> has methods <code>fitted</code> and <code>rediduals</code> that return the fitted values (estimates) and residuals for the training set, <code>performance</code>, which returns summary performance statistics (see below), <code>coef</code> which returns the species coefficients, and <code>print</code> and <code>summary</code> to summarise the output. <code>MR</code> also has a <code>plot</code> method that produces scatter plots of predicted vs observed measurements for the training set. </p>


<h3>Value</h3>

<p>Function <code>MR</code> returns an object of class <code>MR</code> with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> species coefficients (the updated &quot;optima&quot;). </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> fitted values for the training set. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> original function call. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> environmental variable used in the model. </p>
</td></tr>
</table>
<p>Function <code>crossval</code> also returns an object of class <code>MR</code> and adds the following named elements:
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p> predicted values of each training set sample under cross-validation. </p>
</td></tr>
<tr><td><code>residuals.cv</code></td>
<td>
<p> prediction residuals. </p>
</td></tr>
</table>
<p>If function <code>predict</code> is called with <code>newdata=NULL</code> it returns the fitted values of the original model, otherwise it returns a list with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> predicted values for <code>newdata</code>. </p>
</td></tr>
</table>
<p>If sample specific errors were requested the list will also include:
</p>
<table role = "presentation">
<tr><td><code>fit.boot</code></td>
<td>
<p> mean of the bootstrap estimates of newdata. </p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p> standard error of the bootstrap estimates for each new sample. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p> root mean squared error for the training set samples, across all bootstram samples. </p>
</td></tr>
<tr><td><code>SEP</code></td>
<td>
<p> standard error of prediction, calculated as the square root of v1^2 + v2^2. </p>
</td></tr>
</table>
<p>Function <code>performance</code> returns a matrix of performance statistics for the MR model.  See <code><a href="#topic+performance">performance</a></code>, for a description of the summary.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+MAT">MAT</a></code>, <code><a href="#topic+performance">performance</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IK)
spec &lt;- IK$spec
SumSST &lt;- IK$env$SumSST
core &lt;- IK$core

# Generate a MR model using taxa with max abun &gt; 20%

mx &lt;- apply(spec, 2, max)
spec2 &lt;- spec[, mx &gt; 20]

fit &lt;- MR(spec2, SumSST)
fit
# cross-validate model
fit.cv &lt;- crossval(fit, cv.method="lgo")
fit.cv

#predict the core
pred &lt;- predict(fit, core)

#plot predictions - depths are in rownames
depth &lt;- as.numeric(rownames(core))
plot(depth, pred$fit[, 1], type="b")

## Not run: 
# predictions with sample specific errors
# takes approximately 1 minute to run
pred &lt;- predict(fit, core, sse=TRUE, nboot=1000)
pred

## End(Not run)
</code></pre>

<hr>
<h2 id='Ponds'>Southeast England ponds and pools diatom and water chemistry dataset. </h2><span id='topic+Ponds'></span>

<h3>Description</h3>

<p>Diatom and associated water chemistry data for 30 small ponds &amp; pools from SE England collected by, and described in Bennion (1994). Dataset is a list with the following named elements: (<code>spec</code>) diatom relative abundances for 48 selected common taxa, (<code>env</code>) lake names, UK GB grid references, lake depth (m) and mean lake-water chemistry. Units are ueq/l except pH, conductivity (uS/cm), alkalinity (meq/l), total phoshporus and chlorophyll-a (ug/l), and nitrate (mg/l). Column names in <code>spec</code> are short, 6-character alphanumeric codes for each diatom taxon. <code>Ponds$names</code> contains the full names for each taxon, in the correct order).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Ponds)
</code></pre>


<h3>Source</h3>

<p>Bennion, H. (1994) A diatom-phosphorus transfer function for shallow, eutrophic ponds in southeast England. <em>Hydrobiologia</em>, <b>275/276</b>, 391-410.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Ponds)
names(Ponds$spec)
hist(Ponds$env$TP)
</code></pre>

<hr>
<h2 id='PTF'>Palaeoecological transfer functions</h2><span id='topic+performance'></span><span id='topic+performance.default'></span><span id='topic+crossval'></span><span id='topic+crossval.default'></span><span id='topic+rand.t.test'></span><span id='topic+rand.t.test.default'></span>

<h3>Description</h3>

<p>Functions for diagnosing and interpreting palaeoecological transfer functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
performance(object, ...)

## Default S3 method:
crossval(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PTF_+3A_object">object</code></td>
<td>
<p> a transfer function model from <code>wa</code>, <code>wapls</code> etc. </p>
</td></tr>
<tr><td><code id="PTF_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <code><a href="#topic+rioja">rioja</a></code> implements a number of numerical methods for inferring the value of an environmental variable from a set of sepecies abundances, given a modern training set of species data and  associated environmental values.  In palaeoecology these are known as &quot;transfer functions&quot; or &quot;inference models&quot; and are used to hindcast or &quot;reconstruct&quot; past environmental conditions from sub-fossil species assemblages preserved in sediment cores. The techniques included are weighted averaging (<code><a href="#topic+WA">WA</a></code>), partial least squares (PLS) and weighted average partial least squared (<code><a href="#topic+WAPLS">WAPLS</a></code>), Imbrie and Kipp Factor Analysis (<code><a href="#topic+IKFA">IKFA</a></code>) a form of principal components regression, Maximum Likelihood Response Curves (<code><a href="#topic+MLRC">MLRC</a></code>), and the Modern Analogue Technique (<code><a href="#topic+MAT">MAT</a></code>, a form of k-NN non-parametric regression (see Juggins &amp; Birks (2010) for a review). 
</p>
<p>The techniques are implemented in a consistent way and include functions for fitting a model to a training set of species and environmental data, with the function name named after the technique: that is, <code>WA</code> fits a weighted averaging model. Any model can be cross-validated using the <code>crossval</code> function, which allows internal cross-validation using leave-one-out, leave-n-out, bootstrapping or h-block cross-validation. There are a number of generic functions that can be used to summarise and diagnose the models: (<code>print</code>, <code>summary</code>, <code>performance</code> and <code>plot</code>. Some techniques have additional diagnostic functions such as <code>screeplot</code> and <code>rand.t.test</code> to help estimate the approproate number of components (WAPLS), factors (IKFA) or number of analogues (IKFA).
</p>
<p>Predictions for new species data can be made using <code>predict</code>, with an option to calculate sample-specific errors using bootstrapping, after the method described in Birks et al. (1990).
</p>


<h3>Value</h3>

<p>Function <code>performance</code> returns a list with a named matrix <code>object</code> which contains the following columns:
</p>
<table role = "presentation">
<tr><td><code>RMSE</code></td>
<td>
<p> root mean squared error, defined as the square root of the average sqaured error between the observed and predicted values for the training set.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p> squared correlation betweenn observed and predicted values.</p>
</td></tr>
<tr><td><code>Avg.Bias</code></td>
<td>
<p> mean bias (mean of the residuals between measured and predicted values). </p>
</td></tr> 
<tr><td><code>Max.Bias</code></td>
<td>
<p> maximum bias, calculated by dividing the environmental gradient into a number of equal spaced segments (10 by default) and calculating the average bias for each segment.  The maximum bias is maximum of these 10 values and quantifies the tendendy for the model to over- or under-estimate at particular part of the gradient (ter Braak &amp; Juggins 1993). </p>
</td></tr>
</table>
<p>If the transfer function object has been cross-validated, (ie. is the output of <code>crossval</code>, the list returned by <code>performance</code> also contains a matrix named crossval, which contains the above statistics calculated for the cross-validation predictions.
</p>
<p>Function <code>crossval</code> returns an object of the original class and adds the following named elements:
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p> predicted values of each training set sample under cross-validation. </p>
</td></tr>
<tr><td><code>residuals.cv</code></td>
<td>
<p> prediction residuals. </p>
</td></tr>
</table>
<p>Function <code>rand.t.test</code> is a generic function that performs a randomisation t-test to test the significance of a cross-validated model, after van der Voet (1994).  Methods exist for <code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+WAPLS">WAPLS</a></code> and <code><a href="#topic+IKFA">IKFA</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Birks, H.J.B., Line, J.M., Juggins, S., Stevenson, A.C., &amp; ter Braak, C.J.F. (1990) Diatoms and pH reconstruction. <em>Philosophical Transactions of the Royal Society of London</em>, <b>B, 327</b>, 263-278.
</p>
<p>Juggins, S., &amp; Birks, HJB. (2010) Environmental Reconstructions. In Birks et al. (eds) <em>Tracking Environmental Change using Lake Sediments: Data Handling and Statistical Techniques</em>., Kluwer Academic Publishers.
</p>
<p>van der Voet, H. (1994) Comparing the predictive accuracy of models uing a simple randomization test. <em>Chemometrics and Intelligent Laboratory Systems</em>, <b>25</b>, 313-323.
</p>

<hr>
<h2 id='randomPTF'>Random transfer functions to calculate variable importance</h2><span id='topic+randomPTF'></span><span id='topic+plot.randomPTF'></span><span id='topic+print.randomPTF'></span>

<h3>Description</h3>

<p>Function for calculating the important of each taxon (predictor) in palaeoecological transfer functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPTF(spec, env, fun, ncol = 1, nVar, nTF = 500, verbose = TRUE, 
          do.parallel = FALSE, ...)

## S3 method for class 'randomPTF'
plot(x, use.pointLabel=TRUE, ...)

## S3 method for class 'randomPTF'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomPTF_+3A_spec">spec</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_env">env</code></td>
<td>
<p> a vector of environmental values to be modelled. </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_fun">fun</code></td>
<td>
<p> a transfer function method.  Additional arguments can be passed with ...) </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_ncol">ncol</code></td>
<td>
<p> some transfer functions return more than one column of results, for example with different WAPLS components. col selects which column to use. See the relevant transfer function method help file. </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_nvar">nVar</code></td>
<td>
<p> number of variables (ie. species) to use in each randomisation (defaults to nsp/3). </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_ntf">nTF</code></td>
<td>
<p> number of random transfer functions to create (default=500). </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_verbose">verbose</code></td>
<td>
<p> logical show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_do.parallel">do.parallel</code></td>
<td>
<p> logical to run in parallel on multi-core machines.  If true a suitable parallel back-end should be installed (see examples). </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_...">...</code></td>
<td>
<p> additional parameters to the transfer function call. </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_x">x</code></td>
<td>
<p> an object of class randomPTF. </p>
</td></tr>
<tr><td><code id="randomPTF_+3A_use.pointlabel">use.pointLabel</code></td>
<td>
<p> argument is deprecated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>randomPTF</code> calculates taxon importance values using a method analogous to that used in random forests and described in Juggins et al. (2015).
</p>
<p>The parallel version can give c. 3 times speed-up on a quad-core machine.
</p>


<h3>Value</h3>

<p>Function <code>randomPTF</code> returns an object of class <code>randomPTF</code> with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>VI</code></td>
<td>
<p> taxon importance values, ordered form high to low. </p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p> original species data frame. </p>
</td></tr>
<tr><td><code>env</code></td>
<td>
<p> original vector of environmental values. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Steve Juggins
</p>


<h3>References</h3>

<p>Juggins S, Simpson GL, Telford RJ. Taxon selection using statistical learning techniques to improve transfer function prediction. The Holocene 2015; 25: 130-136.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(SWAP)
result &lt;- randomPTF(SWAP$spec, SWAP$pH, fun=WA)
plot(result, cex=0.6)
print(result)
# parallel version
if (.Platform$OS.type=='windows') {
  library(doParallel)
  registerDoParallel(cores=4)
} else {
  library(doMC)
  registerDoMC(cores=4)
}
system.time(result &lt;- randomPTF(SWAP$spec, SWAP$pH, fun=WA, do.parallel=TRUE, nTF=5000))
## End(Not run)
</code></pre>

<hr>
<h2 id='rioja-internal'>Internal rioja functions. </h2><span id='topic+.max.bias'></span><span id='topic+.r2'></span><span id='topic+.crossval'></span><span id='topic+.predict'></span><span id='topic+.check.data'></span><span id='topic+.print.crossval'></span><span id='topic+.performance'></span><span id='topic+.print.performance'></span><span id='topic+.set.rand.seed'></span><span id='topic+.get.rand'></span><span id='topic+predict.internal.WA'></span><span id='topic+predict.internal.WAPLS'></span><span id='topic+predict.internal.IKFA'></span><span id='topic+predict.internal.MLRC'></span><span id='topic+predict.internal.MR'></span><span id='topic+predict.internal.LWR'></span><span id='topic+.rmse'></span><span id='topic+.mono.fit'></span><span id='topic+.mono.predict'></span>

<h3>Description</h3>

<p>Internal rioja functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.max.bias(resi, x, ng = 10)
.rmse(x)
.r2(x, obs)
.mono.fit(x, y)
.mono.predict(mod, newdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rioja-internal_+3A_resi">resi</code></td>
<td>
<p> vector of residuals. </p>
</td></tr>
<tr><td><code id="rioja-internal_+3A_x">x</code>, <code id="rioja-internal_+3A_y">y</code></td>
<td>
<p> vector of observed or predicted values. </p>
</td></tr>
<tr><td><code id="rioja-internal_+3A_obs">obs</code></td>
<td>
<p> vector of observed values. </p>
</td></tr>
<tr><td><code id="rioja-internal_+3A_mod">mod</code></td>
<td>
<p> model fitted by .mono.fit. </p>
</td></tr>
<tr><td><code id="rioja-internal_+3A_newdata">newdata</code></td>
<td>
<p> data frame or matrix of new data to predict. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal <code>rioja</code> functions, not to be called by the user.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>

<hr>
<h2 id='RLGH'>Diatom stratigraphic data from the Round Loch of Glenhead, Galloway, Southwest Scotland</h2><span id='topic+RLGH'></span>

<h3>Description</h3>

<p>Diatom stratigraphic data from the Round Loch of Glenhead, Galloway, Southwest Scotland from core K05, first published in Allott et al. (1992) and re-analysed in Juggins et al. (1996) and Battarbee et al. (2005).  Data are relative abundances (percentages) of a subset of 41 diatom taxa in 20 samples, and includes all taxa with a maximum abundance of 1 percent in any core sample. Dataset is a list with the following named elements: <code>spec</code> diatom relative abundances, <code>depths</code> associated sediment core depths and 210Pb ages. Column names in <code>RLGH$spec</code> are short, 6-character alphanumeric codes for each diatom taxon. <code>RLGH$names</code> contains the full names for each taxon, in the correct order).  Note that some rare and low abundance taxa have been removed so the percentages do not sum to 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(RLGH)
</code></pre>


<h3>References</h3>

<p>Battarbee, R.W., Monteith, D.T., Juggins, S. Evans, C.D., Jenkins, A. &amp; Simpson, G.L. (2005) Reconstructing pre-acidification pH for an acidified Scottish loch: A comparison of palaeolimnological and modelling approaches. <em>Environmental Pollution</em>, <b>137</b>, 135-149.
</p>
<p>Allott, T.E.H., Harriman, R., &amp; Battarbee, R.W. (1992) Reversibility of acidification at the Round Loch of Glenhead, Galloway, Scotland. <em>Environmental Pollution</em>, <b>77</b>, 219-225.
</p>
<p>Juggins, S., Flower, R., &amp; Battarbee, R. (1996) Palaeolimnological evidence for recent chemical and biological changes in UK Acid Waters Monitoring Network sites. <em>Freshwater Biology</em>, <b>36</b>, 203-219.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RLGH)
names(RLGH$spec)
names(RLGH$depths)
</code></pre>

<hr>
<h2 id='strat.plot'> Plot a stratigraphic diagram </h2><span id='topic+strat.plot'></span><span id='topic+addZone'></span><span id='topic+addClustZone'></span>

<h3>Description</h3>

<p>Plots a diagram of multiple biological, physical or chemical parameters agains depth or time, as used in geology &amp; palaeoecology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat.plot (d, yvar=NULL, scale.percent=FALSE, graph.widths=1, minmax=NULL, 
            scale.minmax=TRUE, xLeft=0.07, xRight=1, yBottom=0.07, 
            yTop=0.8, title="", cex.title=1.8, y.axis=TRUE, x.axis=TRUE,
            min.width=5, ylim=NULL, y.rev=FALSE, y.tks=NULL, y.tks.labels=NULL, 
            ylabel="", cex.ylabel=1, cex.yaxis=0.8, xSpace=0.01, x.pc.inc=10, 
            x.pc.lab=TRUE, x.pc.omit0=TRUE, wa.order="none", plot.line=TRUE, 
            col.line="black", lwd.line=1, col.symb="black", plot.bar=TRUE, 
            lwd.bar=1, col.bar="grey", sep.bar=FALSE, bar.back=FALSE,
            plot.poly=FALSE, col.poly="grey", col.poly.line=NA, lwd.poly=1,
            plot.symb=FALSE, symb.pch=19, symb.cex=1, x.names=NULL, cex.xlabel=1.1, 
            srt.xlabel=90, mgp=NULL, ylabPos=2, cex.axis=.8, clust=NULL, clust.width=0.1,
            orig.fig=NULL, exag=FALSE, exag.mult=5, col.exag="grey90", exag.alpha=0.2, 
            col.bg=NULL, fun1=NULL, fun2=NULL, add=FALSE, omitMissing=TRUE, ...)

addZone (x, upper, lower=NULL, ...)

addClustZone(x, clust, nZone, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat.plot_+3A_d">d</code></td>
<td>
<p> a matrix or data frame of variables to plot. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_yvar">yvar</code></td>
<td>
<p> a vector of depths or ages to use for the y-axis (defaults to sample number). </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_scale.percent">scale.percent</code></td>
<td>
<p> logical to scale x-axes for (biological) percentage data. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_graph.widths">graph.widths</code></td>
<td>
<p> a vector of relative widths for each curve, used if <code>scale.percent=FALSE</code>. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_minmax">minmax</code></td>
<td>
<p> 2 * nvar matrix of min and max values to scale each curve if <code>scale.percent=FALSE</code>. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_scale.minmax">scale.minmax</code></td>
<td>
<p> logical to show only min and max values on x-axes (to avoid label crowding). </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_xleft">xLeft</code>, <code id="strat.plot_+3A_xright">xRight</code>, <code id="strat.plot_+3A_ybottom">yBottom</code>, <code id="strat.plot_+3A_ytop">yTop</code></td>
<td>
<p> x, y position of plot on page, in relative units. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_title">title</code></td>
<td>
<p> main title for plot. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_x.names">x.names</code></td>
<td>
<p> character vector of names for each graph, of same length as <code>ncol(d)</code>. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_cex.title">cex.title</code></td>
<td>
<p> size of label for title. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_y.axis">y.axis</code></td>
<td>
<p> logical to control drawing of left-hand y-axis scale. Defaults to TRUE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_x.axis">x.axis</code></td>
<td>
<p> logical or logical vector to control drawing of x-axes. Defaults to TRUE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_min.width">min.width</code></td>
<td>
<p> minimum upper value of x-axis when scaled for percent data. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_ylim">ylim</code></td>
<td>
<p> numeric vector of 2 values to control limist of y-axis. Defaults to data range. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_y.rev">y.rev</code></td>
<td>
<p> logical to reverse y-axis. Defaults to FALSE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_y.tks">y.tks</code></td>
<td>
<p> numerical vector listing values of y-axis ticks. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_y.tks.labels">y.tks.labels</code></td>
<td>
<p> character vector listing values of y-axis labels. </p>
</td></tr>  
<tr><td><code id="strat.plot_+3A_ylabel">ylabel</code></td>
<td>
<p> label for y-axis. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_ylabpos">ylabPos</code></td>
<td>
<p> position for y-axis label.</p>
</td></tr>
<tr><td><code id="strat.plot_+3A_cex.ylabel">cex.ylabel</code>, <code id="strat.plot_+3A_cex.yaxis">cex.yaxis</code></td>
<td>
<p> text size for y-axis labels and values. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_xspace">xSpace</code></td>
<td>
<p> space between graphs, in relative units. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_x.pc.inc">x.pc.inc</code></td>
<td>
<p> increment for x-axis values when <code>scale.percent</code> is TRUE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_x.pc.lab">x.pc.lab</code></td>
<td>
<p> logical to control drawing of x-axis values when <code>scale.percent</code> is TRUE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_x.pc.omit0">x.pc.omit0</code></td>
<td>
<p> logical to omit initial zero x-axis label when <code>scale.percent</code> is TRUE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_wa.order">wa.order</code></td>
<td>
<p> &quot;none&quot;, &quot;topleft&quot; or &quot;bottomleft&quot;, to sort variables according to the weighted average with y. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_plot.line">plot.line</code>, <code id="strat.plot_+3A_plot.poly">plot.poly</code>, <code id="strat.plot_+3A_plot.bar">plot.bar</code>, <code id="strat.plot_+3A_plot.symb">plot.symb</code></td>
<td>
<p> logical flags to plot graphs as lines, silhouettes, bars or symbols. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_col.line">col.line</code>, <code id="strat.plot_+3A_col.poly.line">col.poly.line</code></td>
<td>
<p> colour of lines and silhouette outlines. Can be a single colour or a vector of colours, one for each graph. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_col.poly">col.poly</code></td>
<td>
<p> silhouette fill colour. Can be a single colour or a vector of colours, one for each graph. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_lwd.line">lwd.line</code>, <code id="strat.plot_+3A_lwd.poly">lwd.poly</code>, <code id="strat.plot_+3A_lwd.bar">lwd.bar</code></td>
<td>
<p> line widths for line, silhouette or bar graphs. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_col.bar">col.bar</code></td>
<td>
<p> colour of bars in a bar graph. <code>col.bar</code> can be a vector to specify colours of individual bars or graphs.</p>
</td></tr>
<tr><td><code id="strat.plot_+3A_col.symb">col.symb</code></td>
<td>
<p> symbol colour.</p>
</td></tr>
<tr><td><code id="strat.plot_+3A_sep.bar">sep.bar</code></td>
<td>
<p> If true, colours in <code>col.bar</code> are applied to individual bars, otherwise individual graphs. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_bar.back">bar.back</code></td>
<td>
<p> logical to plot bars behind (TRUE) or on top (FALSE: default) of curves. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_cex.xlabel">cex.xlabel</code></td>
<td>
<p> size of label for variable names. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_srt.xlabel">srt.xlabel</code></td>
<td>
<p> rotation angle for variable names. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_symb.pch">symb.pch</code>, <code id="strat.plot_+3A_symb.cex">symb.cex</code></td>
<td>
<p> symbol type / size. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_exag">exag</code></td>
<td>
<p> logical to add exaggerated curves when <code>plot.poly=TRUE</code>. Can be a single value or a vector to add exaggeration to individual curves.</p>
</td></tr>
<tr><td><code id="strat.plot_+3A_exag.mult">exag.mult</code></td>
<td>
<p> multiplier for exaggerated curves. Can be a single value or a vector to control exaggeration to individual curves.</p>
</td></tr>
<tr><td><code id="strat.plot_+3A_col.exag">col.exag</code></td>
<td>
<p> colour for exaggerated curves. Can be a single value, a vector to control colour of individual curves, or <code>"auto"</code> for transparent version of main curve.</p>
</td></tr>
<tr><td><code id="strat.plot_+3A_exag.alpha">exag.alpha</code></td>
<td>
<p> alpha channel for transparent exaggerated curves when <code>col.exag="auto"</code>. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_mgp">mgp</code></td>
<td>
<p> value of mgp for x-axes.  See <code>par</code> for details. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_cex.axis">cex.axis</code></td>
<td>
<p> text size for x-axis labels.  See <code>par</code> for details. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_clust">clust</code></td>
<td>
<p> an constrained classification object of class <code>chclust</code> to add to plot. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_fun1">fun1</code>, <code id="strat.plot_+3A_fun2">fun2</code></td>
<td>
<p> custom functions to add additional features to curve. Can be a single function applied to all curves or a vector to apply individual functions to individual curves. fun1 draws behind curves, fun2 draws on top of curves. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_clust.width">clust.width</code></td>
<td>
<p> width of dendrogram to add to right of plot, in relative units. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_orig.fig">orig.fig</code></td>
<td>
<p> fig values to specify area of window in which to place diagram.  See <code>par</code> for details. Defaults to whole window. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_add">add</code></td>
<td>
<p> logical to contol drawing of new page. See <code>par</code> for details. Defaults to FALSE in which a call to strat.plot will start a new diagram. Set to  TRUE to add a diagram to an existing plot. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_x">x</code></td>
<td>
<p> a stratigraphic diagram object produced by strat.plot. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_upper">upper</code>, <code id="strat.plot_+3A_lower">lower</code></td>
<td>
<p> upper and (optional) lower limits of a zone to add to an existing stratigraphic diagram. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_nzone">nZone</code></td>
<td>
<p> number of zones to draw. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_omitmissing">omitMissing</code></td>
<td>
<p> remove missing values before plotting.  Defaults to TRUE. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_col.bg">col.bg</code></td>
<td>
<p> background colour for each curve. </p>
</td></tr>
<tr><td><code id="strat.plot_+3A_...">...</code></td>
<td>
<p> further graphical arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>strat.plot</code> plots a series of variables in a stratigraphic diagram. Diagrams can be plotted as line graphs and / or bar charts. Samples are plotted on the y-axis by sample number by default but may be plotted against sample age or depth by specifying a variable for yvar. Margins of the plotting area can be changed using xLeft, xRight, yBottom and yTop.  A dendrogram produced by <code>chclust</code> can be added to the right of the diagram.
</p>
<p>The function <code>addZone</code> can be used to add a horizontal line or box to an existing plot, and 
<code>addClustZone</code> will add a specified number of zones from a dendrogram (see examples).
</p>
<p>The function uses fig to split the screen and may be incompatible with <code>par(mfrow)</code> and 
<code>split.screen</code>.
</p>


<h3>Value</h3>

<p>Returns (invisibly) a list containing the following objects:
</p>
<table role = "presentation">
<tr><td><code>box</code></td>
<td>
<p> Vector of 4 values giving the coordinates of the left, right, bottom
and top of the plotting area, in relative units. </p>
</td></tr>
<tr><td><code>usr</code></td>
<td>
<p> Ranges of the plotting area, in data units. </p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p> Variable used for the y-axis. </p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p> Limits of the y-axis. </p>
</td></tr>
<tr><td><code>figs</code></td>
<td>
<p> list of coordinates of each curve, in relative units. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+chclust">chclust</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(vegan) ## decorana
data(RLGH)
## Not run: 
# create appropriately sized graphics window
windows(width=12, height=7) # quartz() on Mac, X11 on linux

## End(Not run)
# remove less abundant taxa
mx &lt;- apply(RLGH$spec, 2, max)
spec &lt;- RLGH$spec[, mx &gt; 3]
depth &lt;- RLGH$depths$Depth
#basic stratigraphic plot
strat.plot(spec, y.rev=TRUE)
#scale for percentage data
strat.plot(spec, y.rev=TRUE, scale.percent=TRUE)
# plot by sample depth
strat.plot(spec, yvar = depth, y.rev=TRUE, scale.percent=TRUE,
title="Round Loch of Glenhead", ylabel="Depth (cm)")
# add a dendromgram from constrained cluster analysis
diss &lt;- dist(sqrt(RLGH$spec/100)^2)
clust &lt;- chclust(diss, method="coniss")
# broken stick model suggest 3 significant zones
bstick(clust)
x &lt;- strat.plot(spec, yvar = depth, y.rev=TRUE,
scale.percent=TRUE, title="Round Loch of Glenhead", ylabel="Depth (cm)",
clust=clust)
# add zones
addClustZone(x, clust, 3, col="red")
# use fig to contol diagram size and position
x &lt;- strat.plot(spec, xRight = 0.7, yvar = depth, y.rev=TRUE,
scale.percent=TRUE, title="Round Loch of Glenhead", ylabel="Depth (cm)")
# add curves for first two DCA components of diatom data
dca &lt;- decorana(spec, iweigh=1)
sc &lt;- scores(dca, display="sites", choices=1:2)
strat.plot(sc, xLeft = 0.7, yvar = depth, y.rev=TRUE, xRight=0.99,
y.axis=FALSE, clust=clust, clust.width=0.08, add=TRUE)

# Use custom function to add smooth to curve

sm.fun &lt;- function(x, y, i, nm) {
  tmp &lt;- data.frame(x=y, y=x)
  tmp &lt;- na.omit(tmp)
  lo &lt;- lowess(tmp, f=0.3)
  lines(lo$y, lo$x, col="red", lwd=1)
}

x &lt;- strat.plot(spec, yvar = depth, y.rev=TRUE, scale.percent=TRUE, 
title="Round Loch of Glenhead", ylabel="Depth (cm)", fun1=sm.fun)

# Pollen diagram using built-in Abernethy Forest dataset
data(aber)
depth &lt;- aber$ages$Age
spec &lt;- aber$spec

# basic silhouette plot
strat.plot(spec, yvar = depth, y.rev=TRUE, scale.percent=TRUE, ylabel="Depth (cm)", 
plot.poly=TRUE, col.poly="darkgreen", col.poly.line=NA)

# now with horizontal lines at sample positions
strat.plot(spec, yvar = depth, y.rev=TRUE, scale.percent=TRUE, ylabel="Depth (cm)", 
plot.poly=TRUE, col.poly="darkgreen", plot.bar="Full", col.poly.line=NA)

# add exaggerated curves
strat.plot(spec, yvar = depth, y.rev=TRUE, scale.percent=TRUE, ylabel="Depth (cm)", 
plot.poly=TRUE, col.poly="darkgreen", plot.bar="Full", col.poly.line=NA, exag=TRUE)

# use different colours for trees
xx &lt;- 1:ncol(spec)
cc &lt;- ifelse(xx &lt; 8, "darkgreen", "darkred")
strat.plot(spec, yvar = depth, y.rev=TRUE, scale.percent=TRUE, ylabel="Depth (cm)", 
plot.poly=TRUE, col.poly=cc, plot.bar="Full", col.poly.line=NA, exag=TRUE, col.exag="auto")
</code></pre>

<hr>
<h2 id='SWAP'>SWAP surface sediment diatom data and lake-water pH. </h2><span id='topic+SWAP'></span>

<h3>Description</h3>

<p>SWAP (Surface Water Acidification Programme) surface sediment diatom data from Birks et al. (1990) and Stevenson et al. (1990). Dataset is a list with the following named elements: (<code>spec</code>) diatom relative abundances for 277 taxa in 167 surface samples, (<code>pH</code>) associated lake-water pH. Column names in <code>spec</code> are short, 6-character alphanumeric codes for each diatom taxon. <code>SWAP$names</code> contains the full names for each taxon, in the correct order).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(SWAP)
</code></pre>


<h3>Source</h3>

<p>Birks, H.J.B., Line, J.M., Juggins, S., Stevenson, A.C., &amp; ter Braak, C.J.F. (1990) Diatoms and pH reconstruction. <em>Philosophical Transactions of the Royal Society of London</em>, <b>B 327</b>, 263-278.
</p>
<p>Stevenson, A.C., Juggins, S., Birks, H.J.B., Anderson, D.S., Anderson, N.J., Battarbee, R.W., Berge, F., Davis, R.B., Flower, R.J., Haworth, E.Y., Jones, V.J., Kingston, J.C., Kreiser, A.M., Line, J.M., Munro, M.A.R., &amp; Renberg, I. (1991) <em>The Surface Waters Acidification Project Palaeolimnology Programme: Modern Diatom / Lake-Water Chemistry Data-Set</em> ENSIS Ltd, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SWAP)
names(SWAP$spec)
hist(SWAP$pH)
</code></pre>

<hr>
<h2 id='utils'>Utility functions. </h2><span id='topic+make.dummy'></span><span id='topic+dummy2factor'></span><span id='topic+dot'></span><span id='topic+dot.default'></span><span id='topic+dot.data.frame'></span><span id='topic+Hill.N2'></span><span id='topic+site.summ'></span><span id='topic+sp.summ'></span>

<h3>Description</h3>

<p>Utility functions to perform simple computations, transformations, formatting etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.dummy(fact)

dummy2factor(x)

Hill.N2(df, margin=2)

site.summ(y, max.cut=c(2, 5, 10, 20))

sp.summ(y, n.cut=c(5, 10, 20))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utils_+3A_fact">fact</code></td>
<td>
<p> a factor to convert to a matrix of dummy variables. </p>
</td></tr>
<tr><td><code id="utils_+3A_x">x</code></td>
<td>
<p> a matrix or data frame of dummy variables to convert to a factor. </p>
</td></tr>
<tr><td><code id="utils_+3A_df">df</code></td>
<td>
<p> a data frame of species abundance data. </p>
</td></tr>
<tr><td><code id="utils_+3A_margin">margin</code></td>
<td>
<p> margin to calculate over: 1 = by rows, 2 = by columns. </p>
</td></tr>
<tr><td><code id="utils_+3A_y">y</code></td>
<td>
<p> data frame or matrix of species by sites data. </p>
</td></tr>
<tr><td><code id="utils_+3A_n.cut">n.cut</code></td>
<td>
<p> cut levels of abundance for species summary (see below). </p>
</td></tr>
<tr><td><code id="utils_+3A_max.cut">max.cut</code></td>
<td>
<p> cut levels of occurence for species sumamry. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>make.dummy</code> converts a factor into a matrix of dummy (1/0) variables. <code>dummy2factor</code> converts a matrix or data frame of dummy variables into a factor.
</p>
<p>Function <code>Hill.N2</code> returns Hill's N2 values for species or samples for a given species by sites dataset (Hill 1973).
</p>


<h3>Value</h3>

<p><code>make.dummy</code> returns a matrix of dummay variables. <code>dummy2factor</code> returns a factor.
</p>
<p><code>Hill.N2</code> returns a numeric vector of N2 values.
</p>
<p><code>sp.summ</code> returns a matrix with columns for the number of occurences, Hill's N2 and maximum abundance of each species, and the number of occurences at abundance greater than the cut levels given in <code>n.cut</code>.
</p>
<p><code>sam.summ</code> returns a matrix with columns for the number of taxa, Hill's N2, maximum value and site total of each site (sample), and the number of taxa in each site with abundance greater than the cut levels given in <code>max.cut</code>.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Hill, M.O. (1973) Diversity and evenness: a unifying notation and its consequences. <em>Ecology</em>, <b>54</b>, 427-432.
</p>

<hr>
<h2 id='WA'>Weighted averaging (WA) regression and calibration</h2><span id='topic+WA'></span><span id='topic+WA.fit'></span><span id='topic+predict.WA'></span><span id='topic+crossval.WA'></span><span id='topic+performance.WA'></span><span id='topic+print.WA'></span><span id='topic+summary.WA'></span><span id='topic+plot.WA'></span><span id='topic+coef.WA'></span><span id='topic+fitted.WA'></span><span id='topic+residuals.WA'></span><span id='topic+rand.t.test.WA'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using weighted averaging (WA) regression and calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WA(y, x, mono=FALSE, tolDW = FALSE, use.N2=TRUE, tol.cut=.01, 
      check.data=TRUE, lean=FALSE)

WA.fit(y, x, mono=FALSE, tolDW=FALSE, use.N2=TRUE, tol.cut=.01,
       lean=FALSE)

## S3 method for class 'WA'
 predict(object, newdata=NULL, sse=FALSE, nboot=100,
      match.data=TRUE, verbose=TRUE, ...)

## S3 method for class 'WA'
crossval(object, cv.method="loo", verbose=TRUE, ngroups=10, 
      nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'WA'
performance(object, ...)

## S3 method for class 'WA'
rand.t.test(object, n.perm=999, ...)

## S3 method for class 'WA'
print(x, ...)

## S3 method for class 'WA'
summary(object, full=FALSE, ...)

## S3 method for class 'WA'
plot(x, resid=FALSE, xval=FALSE, tolDW=FALSE, deshrink="inverse",
      xlab="", ylab="", ylim=NULL, xlim=NULL, add.ref=TRUE,
      add.smooth=FALSE, ...)

## S3 method for class 'WA'
residuals(object, cv=FALSE, ...)

## S3 method for class 'WA'
coef(object, ...)

## S3 method for class 'WA'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WA_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="WA_+3A_x">x</code>, <code id="WA_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>WA</code>. </p>
</td></tr>
<tr><td><code id="WA_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="WA_+3A_mono">mono</code></td>
<td>
<p> logical to perform monotonic curvilinear deshrinking. </p>
</td></tr>
<tr><td><code id="WA_+3A_toldw">tolDW</code></td>
<td>
<p> logical to include regressions and predictions using tolerance downweighting. </p>
</td></tr>
<tr><td><code id="WA_+3A_use.n2">use.N2</code></td>
<td>
<p> logical to adjust tolerance by species N2 values. </p>
</td></tr>
<tr><td><code id="WA_+3A_tol.cut">tol.cut</code></td>
<td>
<p> tolerances less than <code>tol.cut</code> are replaced by the mean tolerance. </p>
</td></tr>
<tr><td><code id="WA_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="WA_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="WA_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="WA_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="WA_+3A_resid">resid</code></td>
<td>
<p> logical to plot residuals instead of fitted values. </p>
</td></tr>
<tr><td><code id="WA_+3A_xval">xval</code></td>
<td>
<p> logical to plot cross-validation estimates. </p>
</td></tr>
<tr><td><code id="WA_+3A_xlab">xlab</code>, <code id="WA_+3A_ylab">ylab</code>, <code id="WA_+3A_xlim">xlim</code>, <code id="WA_+3A_ylim">ylim</code></td>
<td>
<p> additional graphical arguments to <code>plot.WA</code>. </p>
</td></tr>
<tr><td><code id="WA_+3A_deshrink">deshrink</code></td>
<td>
<p> deshrinking type to show in plot. </p>
</td></tr>
<tr><td><code id="WA_+3A_add.ref">add.ref</code></td>
<td>
<p> add 1:1 line on plot. </p>
</td></tr>
<tr><td><code id="WA_+3A_add.smooth">add.smooth</code></td>
<td>
<p> add loess smooth to plot. </p>
</td></tr>
<tr><td><code id="WA_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;loo&quot;, &quot;lgo&quot;, &quot;bootstrap&quot; or &quot;h-block&quot;. </p>
</td></tr>
<tr><td><code id="WA_+3A_verbose">verbose</code></td>
<td>
<p> logical to show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="WA_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="WA_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation. </p>
</td></tr> 
<tr><td><code id="WA_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation.  Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="WA_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation.  Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="WA_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>    
<tr><td><code id="WA_+3A_n.perm">n.perm</code></td>
<td>
<p> number of permutations for randomisation t-test. </p>
</td></tr> 
<tr><td><code id="WA_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="WA_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>WA</code> performs weighted average (WA) regression and calibration. Weighted averaging has a long history in ecology and forms the basis of many biotic indices.  It WAs popularised in palaeolimnology by ter Brakk and van Dam (1989) and Birks et al. (1990) follwoing ter Braak &amp; Barendregt (1986) and ter Braak and Looman (1986) who demonstrated it's theroetical properties in providing a robust and simple alternative to species response modelling using Gaussian logistic regression. Function <code>WA</code> predicts environmental values from sub-fossil biological assemblages, given a training dataset of modern species and envionmental data. It calculates estimates using inverse and classical deshrinking, and, optionally, with taxa downweighted by their tolerances.  Prediction errors and model complexity (simple or tolerance downweighted WA) can be estimated by cross-validation using <code>crossval</code> which implements leave-one out, leave-group-out, or bootstrapping. With leave-group out one may also supply a vector of group memberships for more carefully designed cross-validation experiments.
</p>
<p>Function <code>predict</code> predicts values of the environemntal variable for <code>newdata</code> or returns the fitted (predicted) values from the original modern dataset if <code>newdata</code> is <code>NULL</code>. Variables are matched between training and newdata by column name (if <code>match.data</code> is <code>TRUE</code>).  Use <code><a href="#topic+compare.datasets">compare.datasets</a></code> to assess conformity of two species datasets and identify possible no-analogue samples.
</p>
<p>Function <code>rand.t.test</code> performs a randomisation t-test to test the significance of the difference in cross-validation RMSE between tolerance-downweighted and simple WA, after van der Voet (1994).
</p>
<p><code>WA</code> has methods <code>fitted</code> and <code>rediduals</code> that return the fitted values (estimates) and residuals for the training set, <code>performance</code>, which returns summary performance statistics (see below), <code>coef</code> which returns the species coefficients (optima and tolerances), and <code>print</code> and <code>summary</code> to summarise the output. <code>WA</code> also has a <code>plot</code> method that produces scatter plots of predicted vs observed measurements for the training set.
</p>


<h3>Value</h3>

<p>Function <code>WA</code> returns an object of class <code>WA</code> with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> species coefficients (&quot;optima&quot; and, optionally, &quot;tolerances&quot;). </p>
</td></tr>
<tr><td><code>deshrink.coefficients</code></td>
<td>
<p> deshrinking coefficients. </p>
</td></tr>
<tr><td><code>tolDW</code></td>
<td>
<p> logical to indicate tolerance downweighted results in model. </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> fitted values for the training set. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> original function call. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> environmental variable used in the model. </p>
</td></tr>
</table>
<p>If function <code>predict</code> is called with <code>newdata=NULL</code> it returns the fitted values of the original model, otherwise it returns a list with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> predicted values for <code>newdata</code>. </p>
</td></tr>
</table>
<p>If sample specific errors were requested the list will also include:
</p>
<table role = "presentation">
<tr><td><code>fit.boot</code></td>
<td>
<p> mean of the bootstrap estimates of newdata. </p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p> standard error of the bootstrap estimates for each new sample. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p> root mean squared error for the training set samples, across all bootstram samples. </p>
</td></tr>
<tr><td><code>SEP</code></td>
<td>
<p> standard error of prediction, calculated as the square root of v1^2 + v2^2. </p>
</td></tr>
</table>
<p>Function <code>crossval</code> also returns an object of class <code>WA</code> and adds the following named elements:
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p> predicted values of each training set sample under cross-validation. </p>
</td></tr>
<tr><td><code>residuals.cv</code></td>
<td>
<p> prediction residuals. </p>
</td></tr>
</table>
<p>Function <code>performance</code> returns a matrix of performance statistics for the WA model.  See <code><a href="#topic+performance">performance</a></code>, for a description of the summary.
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>Birks, H.J.B., Line, J.M., Juggins, S., Stevenson, A.C., &amp; ter Braak, C.J.F. (1990) Diatoms and pH reconstruction. <em>Philosophical Transactions of the Royal Society of London</em>, <b>B, 327</b>, 263-278.
</p>
<p>ter Braak, C.J.F. &amp; Barendregt, L.G. (1986) Weighted averaging of species indicator values: its efficiency in environmental calibration. Mathematical Biosciences, 78, 57-72.
</p>
<p>ter Braak, C.J.F. &amp; Looman, C.W.N. (1986) Weighted averaging, logistic regression and the Gaussian response model. <em>Vegetatio</em>, <b>65</b>, 3-11.
</p>
<p>ter Braak, C.J.F. &amp; van Dam, H. (1989) Inferring pH from diatoms: a comparison of old and new calibration methods. <em>Hydrobiologia</em>, <b>178</b>, 209-223.
</p>
<p>van der Voet, H. (1994) Comparing the predictive accuracy of models uing a simple randomization test. <em>Chemometrics and Intelligent Laboratory Systems</em>, <b>25</b>, 313-323.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WAPLS">WAPLS</a></code>, <code><a href="#topic+MAT">MAT</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pH reconstruction of core K05 from the Round Loch of Glenhead,
# Galloway, SW Scotland. This lake has become acidified over the 
# last c. 150 years

data(SWAP)
data(RLGH)
spec &lt;- SWAP$spec
pH &lt;- SWAP$pH
core &lt;- RLGH$spec
age &lt;- RLGH$depths$Age

fit &lt;- WA(spec, pH, tolDW=TRUE)
# plot predicted vs. observed
plot(fit)
plot(fit, resid=TRUE)

# RLGH reconstruction
pred &lt;- predict(fit, core)

#plot the reconstructio
plot(age, pred$fit[, 1], type="b")

# cross-validation model using bootstrapping
## Not run: 
fit.xv &lt;- crossval(fit, cv.method="boot", nboot=1000)
par(mfrow=c(1,2))
plot(fit)
plot(fit, resid=TRUE)
plot(fit.xv, xval=TRUE)
plot(fit.xv, xval=TRUE, resid=TRUE)

# RLGH reconstruction with sample specific errors
pred &lt;- predict(fit, core, sse=TRUE, nboot=1000)

## End(Not run)
</code></pre>

<hr>
<h2 id='WAPLS'>Weighted averaging partial least squares (WAPLS) regression and calibration</h2><span id='topic+WAPLS'></span><span id='topic+WAPLS.fit'></span><span id='topic+predict.WAPLS'></span><span id='topic+crossval.WAPLS'></span><span id='topic+performance.WAPLS'></span><span id='topic+print.WAPLS'></span><span id='topic+summary.WAPLS'></span><span id='topic+plot.WAPLS'></span><span id='topic+coef.WAPLS'></span><span id='topic+fitted.WAPLS'></span><span id='topic+residuals.WAPLS'></span><span id='topic+screeplot.WAPLS'></span><span id='topic+rand.t.test.WAPLS'></span>

<h3>Description</h3>

<p>Functions for reconstructing (predicting) environmental values from biological assemblages using weighted averaging partial least squares (WAPLS) regression and calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAPLS(y, x, npls=5, iswapls=TRUE, standx=FALSE, lean=FALSE,
      check.data=TRUE, ...)

WAPLS.fit(y, x, npls=5, iswapls=TRUE, standx=FALSE, lean=FALSE)

## S3 method for class 'WAPLS'
 predict(object, newdata=NULL, sse=FALSE, nboot=100,
      match.data=TRUE, verbose=TRUE, ...)

## S3 method for class 'WAPLS'
crossval(object, cv.method="loo", verbose=TRUE, ngroups=10, 
      nboot=100, h.cutoff=0, h.dist=NULL, ...)

## S3 method for class 'WAPLS'
performance(object, ...)

## S3 method for class 'WAPLS'
rand.t.test(object, n.perm=999, ...)

## S3 method for class 'WAPLS'
screeplot(x, rand.test=TRUE, ...)

## S3 method for class 'WAPLS'
print(x, ...)

## S3 method for class 'WAPLS'
summary(object, full=FALSE, ...)

## S3 method for class 'WAPLS'
plot(x, resid=FALSE, xval=FALSE, npls=1, 
      xlab="", ylab="", ylim=NULL, xlim=NULL, add.ref=TRUE,
      add.smooth=FALSE, ...)

## S3 method for class 'WAPLS'
residuals(object, cv=FALSE, ...)

## S3 method for class 'WAPLS'
coef(object, ...)

## S3 method for class 'WAPLS'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WAPLS_+3A_y">y</code></td>
<td>
<p> a data frame or matrix of biological abundance data. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_x">x</code>, <code id="WAPLS_+3A_object">object</code></td>
<td>
<p> a vector of environmental values to be modelled or an object of class <code>wa</code>. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_newdata">newdata</code></td>
<td>
<p> new biological data to be predicted. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_iswapls">iswapls</code></td>
<td>
<p> logical logical to perform WAPLS or PLS. Defaults to TRUE = WAPLS.</p>
</td></tr>
<tr><td><code id="WAPLS_+3A_standx">standx</code></td>
<td>
<p> logical to standardise x-data in PLS, defaults to FALSE. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_npls">npls</code></td>
<td>
<p> number of pls components to extract. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_check.data">check.data</code></td>
<td>
<p> logical to perform simple checks on the input data. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_match.data">match.data</code></td>
<td>
<p> logical indicate the function will match two species datasets by their column names.  You should only set this to <code>FALSE</code> if you are sure the column names match exactly. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_lean">lean</code></td>
<td>
<p> logical to exclude some output from the resulting models (used when cross-validating to speed calculations). </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_full">full</code></td>
<td>
<p> logical to show head and tail of output in summaries. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_resid">resid</code></td>
<td>
<p> logical to plot residuals instead of fitted values. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_xval">xval</code></td>
<td>
<p> logical to plot cross-validation estimates. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_xlab">xlab</code>, <code id="WAPLS_+3A_ylab">ylab</code>, <code id="WAPLS_+3A_xlim">xlim</code>, <code id="WAPLS_+3A_ylim">ylim</code></td>
<td>
<p> additional graphical arguments to <code>plot.wa</code>. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_add.ref">add.ref</code></td>
<td>
<p> add 1:1 line on plot. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_add.smooth">add.smooth</code></td>
<td>
<p> add loess smooth to plot. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_cv.method">cv.method</code></td>
<td>
<p> cross-validation method, either &quot;loo&quot;, &quot;lgo&quot;, &quot;bootstrap&quot; or &quot;h-block&quot;. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_verbose">verbose</code></td>
<td>
<p> logical show feedback during cross-validation. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_nboot">nboot</code></td>
<td>
<p> number of bootstrap samples. </p>
</td></tr>  
<tr><td><code id="WAPLS_+3A_ngroups">ngroups</code></td>
<td>
<p> number of groups in leave-group-out cross-validation, or a vector contain leave-out group menbership. </p>
</td></tr> 
<tr><td><code id="WAPLS_+3A_h.cutoff">h.cutoff</code></td>
<td>
<p> cutoff for h-block cross-validation.  Only training samples greater than <code>h.cutoff</code> from each test sample will be used. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_h.dist">h.dist</code></td>
<td>
<p> distance matrix for use in h-block cross-validation.  Usually a matrix of geographical distances between samples. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_sse">sse</code></td>
<td>
<p> logical indicating that sample specific errors should be calculated. </p>
</td></tr>  
<tr><td><code id="WAPLS_+3A_rand.test">rand.test</code></td>
<td>
<p> logical to perform a randomisation t-test to test significance of cross validated components. </p>
</td></tr> 
<tr><td><code id="WAPLS_+3A_n.perm">n.perm</code></td>
<td>
<p> number of permutations for randomisation t-test. </p>
</td></tr>  
<tr><td><code id="WAPLS_+3A_cv">cv</code></td>
<td>
<p> logical to indicate model or cross-validation residuals. </p>
</td></tr>
<tr><td><code id="WAPLS_+3A_...">...</code></td>
<td>
<p> additional arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>WAPLS</code> performs partial least squares (PLS) or weighted averaging partial least squares (WAPLS) regression. WAPLS was first described in ter Braak and Juggins (1993) and ter Braak et al. (1993) and has since become popular in palaeolimnology for reconstructing (predicting) environmental values from sub-fossil biological assemblages, given a training dataset of modern species and envionmental data. Prediction errors and model complexity (number of components) can be estimated by cross-validation using <code>crossval</code> which implements leave-one out, leave-group-out, or bootstrapping. With leave-group out one may also supply a vector of group memberships for more carefully designed cross-validation experiments.
</p>
<p>Function <code>predict</code> predicts values of the environemntal variable for <code>newdata</code> or returns the fitted (predicted) values from the original modern dataset if <code>newdata</code> is <code>NULL</code>. Variables are matched between training and newdata by column name (if <code>match.data</code> is <code>TRUE</code>).  Use <code><a href="#topic+compare.datasets">compare.datasets</a></code> to assess conformity of two species datasets and identify possible no-analogue samples.
</p>
<p><code>WAPLS</code> has methods <code>fitted</code> and <code>rediduals</code> that return the fitted values (estimates) and residuals for the training set, <code>performance</code>, which returns summary performance statistics (see below), <code>coef</code> which returns the species coefficients, and <code>print</code> and <code>summary</code> to summarise the output. <code>WAPLS</code> also has a <code>plot</code> method that produces scatter plots of predicted vs observed measurements for the training set.
</p>
<p>Function <code>rand.t.test</code> performs a randomisation t-test to test the significance of the cross-validated components after van der Voet (1994).
</p>
<p>Function <code>screeplot</code> displays the RMSE of prediction for the training set as a function of the number of components and is useful for estimating the optimal number for use in prediction. By default <code>screeplot</code> will also carry out a randomisation t-test and add a line to scree plot indicating percentage change in RMSE with each component annotate with the p-value from the randomisation test.
</p>


<h3>Value</h3>

<p>Function <code>WAPLS</code> returns an object of class <code>WAPLS</code> with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> species coefficients (the updated &quot;optima&quot;). </p>
</td></tr>
<tr><td><code>meanY</code></td>
<td>
<p> weighted mean of the environmental variable. </p>
</td></tr>
<tr><td><code>iswapls</code></td>
<td>
<p> logical indicating whether analysis was WAPLS (TRUE) or PLS (FALSE). </p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p> sample scores. </p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p> variable (species) scores. </p>
</td></tr>
<tr><td><code>npls</code></td>
<td>
<p> number of pls components extracted. </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> fitted values for the training set. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> original function call. </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> environmental variable used in the model. </p>
</td></tr>
<tr><td><code>standx</code>, <code>meanT sdx</code></td>
<td>
<p> additional information returned for a PLS model. </p>
</td></tr>
</table>
<p>Function <code>crossval</code> also returns an object of class <code>WAPLS</code> and adds the following named elements:
</p>
<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p> predicted values of each training set sample under cross-validation. </p>
</td></tr>
<tr><td><code>residuals.cv</code></td>
<td>
<p> prediction residuals. </p>
</td></tr>
</table>
<p>If function <code>predict</code> is called with <code>newdata=NULL</code> it returns the fitted values of the original model, otherwise it returns a list with the following named elements:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p> predicted values for <code>newdata</code>. </p>
</td></tr>
</table>
<p>If sample specific errors were requested the list will also include:
</p>
<table role = "presentation">
<tr><td><code>fit.boot</code></td>
<td>
<p> mean of the bootstrap estimates of newdata. </p>
</td></tr>
<tr><td><code>v1</code></td>
<td>
<p> standard error of the bootstrap estimates for each new sample. </p>
</td></tr>
<tr><td><code>v2</code></td>
<td>
<p> root mean squared error for the training set samples, across all bootstram samples. </p>
</td></tr>
<tr><td><code>SEP</code></td>
<td>
<p> standard error of prediction, calculated as the square root of v1^2 + v2^2. </p>
</td></tr>
</table>
<p>Function <code>performance</code> returns a matrix of performance statistics for the WAPLS model.  See <code><a href="#topic+performance">performance</a></code>, for a description of the summary.
</p>
<p>Function <code><a href="#topic+rand.t.test">rand.t.test</a></code> returns a matrix of performance statistics together with columns indicating the p-value and percentage change in RMSE with each higher component (see van der Veot (1994) for details).
</p>


<h3>Author(s)</h3>

 
<p>Steve Juggins
</p>


<h3>References</h3>

<p>ter Braak, C.J.F. &amp; Juggins, S. (1993) Weighted averaging partial least squares regression (WA-PLS): an improved method for reconstructing environmental variables from species assemblages. <em>Hydrobiologia</em>, <b>269/270</b>, 485-502.
</p>
<p>ter Braak, C.J.F., Juggins, S., Birks, H.J.B., &amp; Voet, H., van der (1993). Weighted averaging partial least squares regression (WA-PLS): definition and comparison with other methods for species-environment calibration. In <em>Multivariate Environmental Statistics</em> (eds G.P. Patil &amp; C.R. Rao), pp. 525-560. Elsevier Science Publishers.
</p>
<p>van der Voet, H. (1994) Comparing the predictive accuracy of models uing a simple randomization test. <em>Chemometrics and Intelligent Laboratory Systems</em>, <b>25</b>, 313-323.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+WA">WA</a></code>, <code><a href="#topic+MAT">MAT</a></code>, <code><a href="#topic+performance">performance</a></code>, and <code><a href="#topic+compare.datasets">compare.datasets</a></code> for diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IK)
spec &lt;- IK$spec
SumSST &lt;- IK$env$SumSST
core &lt;- IK$core

fit &lt;- WAPLS(spec, SumSST)
fit
# cross-validate model
fit.cv &lt;- crossval(fit, cv.method="loo")
# How many components to use?
rand.t.test(fit.cv)
screeplot(fit.cv)

#predict the core
pred &lt;- predict(fit, core, npls=2)

#plot predictions - depths are in rownames
depth &lt;- as.numeric(rownames(core))
plot(depth, pred$fit[, 2], type="b", ylab="Predicted SumSST", las=1)

# predictions with sample specific errors
## Not run: 
pred &lt;- predict(fit, core, npls=2, sse=TRUE, nboot=1000)
pred

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
