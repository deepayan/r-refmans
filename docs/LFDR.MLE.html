<!DOCTYPE html><html><head><title>Help for package LFDR.MLE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LFDR.MLE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LFDR.MLE-package'><p>Estimation of the Local False Discovery Rate using Type II Maximum Likelihood Estimation.</p></a></li>
<li><a href='#dabsTd'>
<p>Density of the absolute Student t Distribution.</p></a></li>
<li><a href='#internals'><p>Internal Functions and Methods</p></a></li>
<li><a href='#lfdr.lho, lfdr.l1o'><p>Leave-one-out (L1O) and leave-half-out (LHO) method for LFDR estimation.</p></a></li>
<li><a href='#lfdr.mdl'><p>Minimum description length (MDL) method for estimation of LFDR.</p></a></li>
<li><a href='#lfdr.mle'><p>Type II Maximum likelihood estimate of LFDR (LFDR-MLE).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of the Local False Discovery Rates by Type II Maximum
Likelihood Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Ye Yang, Marta Padilla, Alaa Ali, Kyle Leckett, Zhenyu Yang, Zuojing Li, Corey M. Yanofsky and David R. Bickel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>M. Padilla &lt;padilla.mpf@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Suite of R functions for the estimation of the local false discovery rate (LFDR) using Type II maximum likelihood estimation (MLE).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.cran.r-project.org">http://www.cran.r-project.org</a>, <a href="http://www.statomics.com">http://www.statomics.com</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-10-02 15:47:36 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-10-02 15:53:57 UTC</td>
</tr>
</table>
<hr>
<h2 id='LFDR.MLE-package'>Estimation of the Local False Discovery Rate using Type II Maximum Likelihood Estimation.</h2><span id='topic+LFDR.MLE-package'></span><span id='topic+LFDR.MLE'></span>

<h3>Description</h3>

<p>Suite of R functions for the estimation of the local false discovery rate (LFDR) using Type II maximum likelihood estimation (MLE).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> LFDR.MLE</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-07-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.14.0), stats, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://www.cran.r-project.org, http://www.statomics.com</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Code: Ye Yang, Marta Padilla, Zhenyu Yang, Zuojing Li, Corey M. Yanofsky<br />
Documentation: Alaa Ali, Kyle Leckett, Marta Padilla<br />
Maintainer: D. R. Bickel &lt;dbickel@uOttawa.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y., &amp; Bickel, D. R. (2010). Minimum description length and empirical Bayes methods of identifying SNPs associated with disease. Technical Report, Ottawa Institute of Systems Biology, COBRA Preprint Series, Article 74, available at biostats.bepress.com/cobra/ps/art74.
</p>
<p>Bickel, D. R. (2010). Minimum description length methods of medium-scale simultaneous inference. arXiv preprint arXiv:1009.5981.
</p>
<p>Padilla, M., &amp; Bickel, D. R. (2012). Estimators of the local false discovery rate designed for small numbers of tests. Statistical Applications in Genetics and Molecular Biology, 11(5), art. 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dFUN&lt;-dabsTd; dfx &lt;- 4
n.alternative &lt;- 3; n.null &lt;- 4; true.ncp &lt;- 7

#NOTE: arguments for dFUN are x, df, ncp. If dFUN has other arguments, 
#please adapt them. For example:
#dFUN&lt;-function(x,df,ncp){dnorm(x=x,mean=ncp,sd=df)};attr(dFUN,'name')&lt;-'dnorm'

#In the examples, W is the result of the absolute value of the t.test statistics 
#on the data

W&lt;-abs(c(rt(n=n.alternative,ncp=true.ncp,df=dfx),rt(n=n.null,ncp=0,df=dfx)))
W[c(1,3,5)]&lt;-NA

z1&lt;-lfdr.mle(x=W,dFUN=dFUN, df=dfx)
z2&lt;-lfdr.mle(x=W,dFUN=dFUN, df=dfx,fixed.p0=0.4,fixed.ncp=4)
z3&lt;-lfdr.mdl(x=W,df=dfx,dFUN=dFUN)
z4&lt;-lfdr.l1o(x=W,df=dfx,dFUN=dFUN)
z5&lt;-lfdr.lho(x=W,df=dfx,dFUN=dFUN,fixed.ncp=5)
z6&lt;-lfdr.lo(x=W,v=1/3,df=dfx,dFUN=dFUN)
z7&lt;-lfdr.mdlo(x=W,v=1/3,df=dfx,dFUN=dFUN)



</code></pre>

<hr>
<h2 id='dabsTd'>
Density of the absolute Student t Distribution.
</h2><span id='topic+dabsTd'></span>

<h3>Description</h3>

<p>Density of the absolute t distribution with df degrees of freedom and non-centrality parameter ncp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dabsTd(x, df, ncp = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dabsTd_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dabsTd_+3A_df">df</code></td>
<td>

<p>degrees of freedom (&gt;0).
</p>
</td></tr>
<tr><td><code id="dabsTd_+3A_ncp">ncp</code></td>
<td>

<p>noncentrality parameter.
</p>
</td></tr>
<tr><td><code id="dabsTd_+3A_...">...</code></td>
<td>

<p>arguments to pass to functions <code>dt</code> from basic R.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric of length equal to the length of x.
</p>


<h3>Author(s)</h3>

<p>Code: David R. Bickel,<br />
Documentation: Alaa Ali, Kyle Leckett, Marta Padilla.
</p>


<h3>See Also</h3>

<p>Function <code><a href="stats.html#topic+dt">dt</a></code> from basic R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z1&lt;-dabsTd(x = c(1:4), df = 3, ncp = 3)
 </code></pre>

<hr>
<h2 id='internals'>Internal Functions and Methods</h2><span id='topic+internals'></span><span id='topic+est.lfdrmle-class'></span><span id='topic+as.numeric-methods'></span><span id='topic+as.numeric+2Cest.lfdrmle-method'></span><span id='topic++5B+2Cest.lfdrmle+2CANY+2Cmissing-method'></span><span id='topic+is_prob+2Cest.lfdrmle-method'></span><span id='topic+length+2Cest.lfdrmle-method'></span><span id='topic+names+2Cest.lfdrmle-method'></span><span id='topic+names+3C-+2Cest.lfdrmle+2Ccharacter-method'></span><span id='topic+is_prob-methods'></span><span id='topic+is_prob+2Cnumeric-method'></span><span id='topic+length-methods'></span><span id='topic+names-methods'></span><span id='topic+names+3C--methods'></span><span id='topic++5B-methods'></span><span id='topic+MakeNames'></span><span id='topic+are'></span><span id='topic+are_null'></span><span id='topic+are_prob'></span><span id='topic+assert.are'></span><span id='topic+assert.is'></span><span id='topic+est2list'></span><span id='topic+get_groups'></span><span id='topic+get_n.groups'></span><span id='topic+get_null.groups'></span><span id='topic+get_null.n.groups'></span><span id='topic+get_simulated_W'></span><span id='topic+is_any'></span><span id='topic+is_err'></span><span id='topic+is_error'></span><span id='topic+is_unk'></span><span id='topic+is_vide'></span><span id='topic+is_prob'></span><span id='topic+lfdr.hats'></span><span id='topic+make_labels'></span><span id='topic+new_est.lfdrmle'></span><span id='topic+nsize'></span><span id='topic+rFUN_generator'></span><span id='topic+sameAsX_names'></span><span id='topic+simulated_W'></span><span id='topic+vect2string'></span><span id='topic+vectorized.dabsTd'></span><span id='topic+ye.mle'></span><span id='topic++5B'></span><span id='topic+as.numeric'></span><span id='topic+length'></span><span id='topic+names'></span>

<h3>Description</h3>

<p>These functions are for internal use and/or for upcoming packages or not yet documented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeNames(x, nmvar = c("X", "I"), ...)
are(object, class2)
	are_null(object)
are_prob(object, ...)

assert.are(object, class2,
	 ...)
assert.is(object, class2, text = "")
est2list(x)
	get_groups(n.features, n.null, n.groups)
get_n.groups(n.features, n.null,
	 group.size)
get_null.groups(n.null, null.n.groups)
get_null.n.groups(n.null,
	 null_group.size)
get_simulated_W(n.features, true.p0, list.ncp1,
	 rFUN, df)
is_any(object, class2)
is_err(object)
is_error(object)
	is_unk(object)
is_vide(object)


lfdr.hats(stat = NULL, lfdr.fun = "lfdr.mle",
	 dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20, lower.p0 = 0,
	 upper.p0 = 1, fixed.p0 = NULL, fixed.ncp = NULL, d0 = 0, v = 1,
	 w = 1, ...)
make_labels(n, nmvar = c("X"), n.ini = 1)


new_est.lfdrmle(LFDR.hat,
	 p0.hat, ncp.hat, stat, method = NULL, info = list())
nsize(x)
rFUN_generator(base_rFUN, ...)
sameAsX_names(x = NULL, y = NULL)
simulated_W(n.features, n.null, rFUN = rFUN_generator(rchisq), true.ncp1, df,
	 N = (n.features - n.null), sided = ifelse(identical(rFUN,
	 rFUN_generator(rchisq)), 1, 2), logic = TRUE)
vect2string(x, sep = "", ...)
	vectorized.dabsTd(ncp, ...)
ye.mle(W, df, dFUN = dabsTd, lower.ncp = 0.001,
	 upper.ncp = 20, lower.p0 = 0, upper.p0 = 1, d0 = 0, fixed.ncp = NULL,
	 fixed.p0 = NULL, ...)
</code></pre>

<hr>
<h2 id='lfdr.lho+2C+20lfdr.l1o'>Leave-one-out (L1O) and leave-half-out (LHO) method for LFDR estimation.</h2><span id='topic+lfdr.l1o'></span><span id='topic+lfdr.lho'></span><span id='topic+lfdr.lo'></span>

<h3>Description</h3>

<p>Estimate the local false discovery rate using the leave-one-out method (L1O) or the leave-half-out method (LHO).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfdr.l1o(x, dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20, lower.p0 = 0,
      upper.p0 = 1, fixed.p0 = NULL, fixed.ncp = NULL, d0 = 0, ...)

lfdr.lho(x, dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20, lower.p0 = 0,  
      upper.p0 = 1, fixed.p0 = NULL, fixed.ncp = NULL, d0 = 0, ...)

lfdr.lo(x, dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20, lower.p0 = 0,
      upper.p0 = 1, fixed.p0 = NULL, fixed.ncp = NULL, v = 0, d0 = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_x">x</code></td>
<td>
<p>Input numeric  vector of statistics. </p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_dfun">dFUN</code></td>
<td>
<p>Density function; default <code>dabsTd</code> (from absolute value of the Student t distribution)</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_lower.ncp">lower.ncp</code></td>
<td>
<p>The lowerbound of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is 0.001</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_upper.ncp">upper.ncp</code></td>
<td>
<p>The upperbound of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is 20</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_lower.p0">lower.p0</code></td>
<td>
<p>The lowerbound of p0 (proportion of unaffected features (null hypothesis)); default value is 0</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_upper.p0">upper.p0</code></td>
<td>
<p>The upperbound of p0 (proportion of unaffected features (null hypothesis)); default value is 1</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_fixed.p0">fixed.p0</code></td>
<td>
<p>A fixed value of p0 (proportion of unaffected features (null hypothesis)); default value is NULL</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_fixed.ncp">fixed.ncp</code></td>
<td>
<p>A fixed value of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is NULL</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_v">v</code></td>
<td>
<p>v in [0,1], portion of one feature that is considered in turn to estimate the LFDR; default value is v=0 (for <code>lfdr.l1o</code> (L1O)) and v=1/2 (for <code>lfdr.lho</code> (LHO)). For other values of v, use <code>lfdr.lo</code>.</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_d0">d0</code></td>
<td>
<p>the numeric value of the null hypothesis for <code>dFUN</code>, default value is 0.</p>
</td></tr>
<tr><td><code id="lfdr.lho+2B2C+2B20lfdr.l1o_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to <code>dFUN</code> (see notes and examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>
<table>
<tr><td><code>LFDR.hat</code></td>
<td>
<p>estimates of the LFDR</p>
</td></tr>
<tr><td><code>p0.hat</code></td>
<td>
<p>estimate of the proportion of unaffected features p0 (true null hypothesis). </p>
</td></tr>
<tr><td><code>ncp.hat</code></td>
<td>
<p>estimate of the location parameter of the distribution <code>dFUN</code> (ncp: noncentrality parameter of <code>dFUN=dabsTd</code> by default). </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>method name and information about computation failure.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>- Requires <code>fixed.p0=NULL</code>. 
</p>
<p>- The probability density function (<code>dFUN</code>) can be set to any other distribution, adapted so that the location parameter corresponds to ncp, other parameter to df and any other can be passed to <code>dFUN</code> by the dots (see examples in <code><a href="#topic+lfdr.mle">lfdr.mle</a></code>).
</p>
<p>- If computation fails for all features, <code>p0.hat</code> is set to NA and so is <code>LFDR.hat</code>, which is a vector of NA with lengh equal to the number of features. If it fails for a given feature, only the resulting LFDR for that feature is set to NA. Error messages are not suppressed.
</p>


<h3>Author(s)</h3>

<p>Code: Marta Padilla<br />
Documentation: Alaa Ali, Kyle Leckett, Marta Padilla.
</p>


<h3>References</h3>

<p>Padilla, M., &amp; Bickel, D. R. (2012). Estimators of the local false discovery rate designed for small numbers of tests. Statistical Applications in Genetics and Molecular Biology, 11(5), art. 4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lfdr.mle">lfdr.mle</a></code>, <code><a href="#topic+lfdr.mdl">lfdr.mdl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfx &lt;- 4;n.alt &lt;- 1;n.null &lt;- 4;true.ncp &lt;- 7
#numeric imput data: statistics of the data with missing values (removed internally)
#(result of a absolute t.test statistics on the data)
W&lt;-abs(c(rt(n=n.alt,ncp=true.ncp,df=dfx),rt(n=n.null,ncp=0,df=dfx)))
W[3]&lt;-NA

z1&lt;-lfdr.l1o(x=W,df=dfx)
z2&lt;-lfdr.lho(x=W,df=dfx,fixed.ncp=10)
z3&lt;-lfdr.lo(x=W,df=dfx,v=1/3,fixed.p0=0.3)

</code></pre>

<hr>
<h2 id='lfdr.mdl'>Minimum description length (MDL) method for estimation of LFDR.</h2><span id='topic+lfdr.mdl'></span><span id='topic+lfdr.mdlo'></span>

<h3>Description</h3>

<p>Estimate the local false discovery rate using the minimum description length (MDL) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
lfdr.mdl(x, dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20, lower.p0 = 0,
        upper.p0 = 1, fixed.p0 = NULL, fixed.ncp = NULL, d0 = 0, ...)

lfdr.mdlo(x, v = 0, dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20, 
        lower.p0 = 0, upper.p0 = 1, fixed.p0 = NULL, fixed.ncp = NULL,
        d0 = 0, ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfdr.mdl_+3A_x">x</code></td>
<td>
<p>Input numeric  vector of statistics. </p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_dfun">dFUN</code></td>
<td>
<p>Density function; default <code>dabsTd</code> (from absolute value of the Student t distribution)</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_v">v</code></td>
<td>
<p>v in [0,1], portion of one feature that is considered in turn to estimate the LFDR; default value is v=0 (for <code>lfdr.l1o</code> (L1O)) and v=1/2 (for <code>lfdr.lho</code> (LHO)). For other values of v, use <code>lfdr.lo</code>.</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_lower.ncp">lower.ncp</code></td>
<td>
<p>The lowerbound of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is 0.001</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_upper.ncp">upper.ncp</code></td>
<td>
<p>The upperbound of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is 20</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_lower.p0">lower.p0</code></td>
<td>
<p>The lowerbound of p0 (proportion of unaffected features (null hypothesis)); default value is 0</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_upper.p0">upper.p0</code></td>
<td>
<p>The upperbound of p0 (proportion of unaffected features (null hypothesis)); default value is 1</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_fixed.p0">fixed.p0</code></td>
<td>
<p>A fixed value of p0 (proportion of unaffected features (null hypothesis)); default value is NULL</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_fixed.ncp">fixed.ncp</code></td>
<td>
<p>A fixed value of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is NULL</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_d0">d0</code></td>
<td>
<p>the numeric value of the null hypothesis for <code>dFUN</code>, default value is 0.</p>
</td></tr>
<tr><td><code id="lfdr.mdl_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to <code>dFUN</code> (see notes and examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>
<table>
<tr><td><code>LFDR.hat</code></td>
<td>
<p>estimates of the LFDR</p>
</td></tr>
<tr><td><code>p0.hat</code></td>
<td>
<p>estimate of the proportion of unaffected features p0 (true null hypothesis). </p>
</td></tr>
<tr><td><code>ncp.hat</code></td>
<td>
<p>estimate of the location parameter of the distribution <code>dFUN</code> (ncp: noncentrality parameter of <code>dFUN=dabsTd</code> by default). </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>method name and information about computation failure.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>- The probability density function (<code>dFUN</code>) can be set to any other distribution, adapted so that the location parameter corresponds to ncp, other parameter to df and any other can be passed to <code>dFUN</code> by the dots (see examples in <code><a href="#topic+lfdr.mle">lfdr.mle</a></code>).
</p>
<p>- If computation fails for all features, <code>p0.hat</code> is set to NA and so is <code>LFDR.hat</code>, which is a vector of NA with lengh equal to the number of features. If it fails for a given feature, only the resulting LFDR for that feature is set to NA. Error messages are not suppressed.
</p>


<h3>Author(s)</h3>

<p>Code: Marta Padilla<br />
Documentation: Alaa Ali, Kyle Leckett, Marta Padilla.
</p>


<h3>References</h3>

<p>Bickel, D. R. (2010). Minimum description length methods of medium-scale simultaneous inference. arXiv preprint arXiv:1009.5981.
</p>
<p>Padilla, M., &amp; Bickel, D. R. (2012). Estimators of the local false discovery rate designed for small numbers of tests. Statistical Applications in Genetics and Molecular Biology, 11(5), art. 4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lfdr.mle">lfdr.mle</a></code>, <code><a href="#topic+lfdr.l1o">lfdr.l1o</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfx &lt;- 4;n.alt &lt;- 1;n.null &lt;- 4;true.ncp &lt;- 7
#numeric imput data: statistics of the data with missing values (removed internally)
#(result of a absolute t.test statistics on the data)
W&lt;-abs(c(rt(n=n.alt,ncp=true.ncp,df=dfx),rt(n=n.null,ncp=0,df=dfx)))
W[3]&lt;-NA

z1&lt;-lfdr.mdl(x=W,df=dfx)
z2&lt;-lfdr.mdl(x=W,df=dfx,fixed.ncp=10)
z3&lt;-lfdr.mdlo(x=W,df=dfx,v=1/3,fixed.p0=0.3)

</code></pre>

<hr>
<h2 id='lfdr.mle'>Type II Maximum likelihood estimate of LFDR (LFDR-MLE).</h2><span id='topic+lfdr.mle'></span>

<h3>Description</h3>

<p>Estimates the local false discovery rate by the Type II maximum likelihood estimates (MLE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfdr.mle(x, dFUN = dabsTd, lower.ncp = 0.001, upper.ncp = 20,lower.p0 = 0, upper.p0 = 1,
         fixed.p0 = NULL, fixed.ncp = NULL, d0 = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfdr.mle_+3A_x">x</code></td>
<td>
<p>Input numeric  vector of statistics. </p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_dfun">dFUN</code></td>
<td>
<p>Density function; default <code>dabsTd</code> (from absolute value of the Student t distribution)</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_lower.ncp">lower.ncp</code></td>
<td>
<p>The lowerbound of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is 0.001</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_upper.ncp">upper.ncp</code></td>
<td>
<p>The upperbound of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is 20</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_lower.p0">lower.p0</code></td>
<td>
<p>The lowerbound of p0 (proportion of unaffected features (null hypothesis)); default value is 0</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_upper.p0">upper.p0</code></td>
<td>
<p>The upperbound of p0 (proportion of unaffected features (null hypothesis)); default value is 1</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_fixed.p0">fixed.p0</code></td>
<td>
<p>A fixed value of p0 (proportion of unaffected features (null hypothesis)); default value is NULL</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_fixed.ncp">fixed.ncp</code></td>
<td>
<p>A fixed value of the location parameter of <code>dFUN</code> (noncentrality parameter for default <code>dFUN=dabsTd</code>); default value is NULL</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_d0">d0</code></td>
<td>
<p>the numeric value of the null hypothesis for <code>dFUN</code>, default value is 0.</p>
</td></tr>
<tr><td><code id="lfdr.mle_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to <code>dFUN</code> (see notes and examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>
<table>
<tr><td><code>LFDR.hat</code></td>
<td>
<p>estimates of the LFDR</p>
</td></tr>
<tr><td><code>p0.hat</code></td>
<td>
<p>estimate of the proportion of unaffected features p0 (true null hypothesis). </p>
</td></tr>
<tr><td><code>ncp.hat</code></td>
<td>
<p>estimate of the location parameter of the distribution <code>dFUN</code> (ncp: noncentrality parameter of <code>dFUN=dabsTd</code> by default). </p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>method name and information about computation failure.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>- The probability density function (<code>dFUN</code>) can be set to any other distribution, adapted so that the location parameter corresponds to ncp, other parameter to df and any other can be passed to <code>dFUN</code> by the dots (see examples in <code><a href="#topic+lfdr.mle">lfdr.mle</a></code>).
</p>
<p>- If computation fails for all features, <code>p0.hat</code> is set to NA and so is <code>LFDR.hat</code>, which is a vector of NA with lengh equal to the number of features. If it fails for a given feature, only the resulting LFDR for that feature is set to NA. Error messages are not suppressed.
</p>


<h3>Author(s)</h3>


<p>Code: Ye Yang, Marta Padilla, Zhenyu Yang, Zuojing Li, Corey M. Yanofsky<br />
Documentation: Alaa Ali, Kyle Leckett, Marta Padilla.
</p>


<h3>References</h3>

<p>Yang, Y., &amp; Bickel, D. R. (2010). Minimum description length and empirical Bayes methods of identifying SNPs associated with disease. Technical Report, Ottawa Institute of Systems Biology, COBRA Preprint Series, Article 74, available at biostats.bepress.com/cobra/ps/art74.
</p>
<p>Bickel, D. R. (2010). Minimum description length methods of medium-scale simultaneous inference. arXiv preprint arXiv:1009.5981.
</p>
<p>Padilla, M., &amp; Bickel, D. R. (2012). Estimators of the local false discovery rate designed for small numbers of tests. Statistical Applications in Genetics and Molecular Biology, 11(5), art. 4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lfdr.mdl">lfdr.mdl</a></code>, <code><a href="#topic+lfdr.l1o">lfdr.l1o</a></code>, <code><a href="#topic+lfdr.lho">lfdr.lho</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#numeric imput data: statistics of the data with missing values (removed internally)
#(result of a absolute t.test statistics on the data)
dfx &lt;- 4;n.alt &lt;- 1;n.null &lt;- 4;true.ncp &lt;- 7
W&lt;-abs(c(rt(n=n.alt,ncp=true.ncp,df=dfx),rt(n=n.null,ncp=0,df=dfx)))
W[3]&lt;-NA

z1&lt;-lfdr.mle(x=W,dFUN=dabsTd, df=dfx)
z2&lt;-lfdr.mle(x=W,dFUN=dabsTd, df=dfx, fixed.p0=0.4, fixed.ncp=4)

#other dFUN -------
#NOTE: arguments for dFUN are x, df, ncp. If dFUN has other arguments, 
#please adapt them. For example:

new.df&lt;-function(x,df,ncp,...){df(x=x,ncp=ncp,df1=df,...)}
z3&lt;-lfdr.mle(x=W,df=dfx,dFUN=new.df,df2=5)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
