<!DOCTYPE html><html lang="en-GB"><head><title>Help for package fake</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fake}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BlockDiagonal'><p>Block diagonal matrix</p></a></li>
<li><a href='#BlockMatrix'><p>Block matrix</p></a></li>
<li><a href='#BlockStructure'><p>Block structure</p></a></li>
<li><a href='#Concordance'><p>Concordance statistic</p></a></li>
<li><a href='#Contrast'><p>Matrix contrast</p></a></li>
<li><a href='#ExpectedCommunities'><p>Expected community structure</p></a></li>
<li><a href='#ExpectedConcordance'><p>Expected concordance statistic</p></a></li>
<li><a href='#Heatmap'><p>Heatmap visualisation</p></a></li>
<li><a href='#HugeAdjacency'><p>Simulation of undirected graph</p></a></li>
<li><a href='#LayeredDAG'><p>Layered Directed Acyclic Graph</p></a></li>
<li><a href='#MakePositiveDefinite'><p>Making positive definite matrix</p></a></li>
<li><a href='#MatchingArguments'><p>Matching arguments</p></a></li>
<li><a href='#MaxContrast'><p>Maximising matrix contrast</p></a></li>
<li><a href='#MinWithinProba'><p>Within-group probabilities for communities</p></a></li>
<li><a href='#plot.roc_curve'><p>Receiver Operating Characteristic (ROC) curve</p></a></li>
<li><a href='#Rates'><p>True and False Positive Rates</p></a></li>
<li><a href='#ROC'><p>Receiver Operating Characteristic (ROC)</p></a></li>
<li><a href='#SamplePredictors'><p>Simulation of binary contribution status</p></a></li>
<li><a href='#SimulateAdjacency'><p>Simulation of undirected graph with block structure</p></a></li>
<li><a href='#SimulateClustering'><p>Simulation of data with underlying clusters</p></a></li>
<li><a href='#SimulateComponents'><p>Data simulation for sparse Principal Component Analysis</p></a></li>
<li><a href='#SimulateCorrelation'><p>Simulation of a correlation matrix</p></a></li>
<li><a href='#SimulateGraphical'><p>Data simulation for Gaussian Graphical Modelling</p></a></li>
<li><a href='#SimulatePrecision'><p>Simulation of precision matrix</p></a></li>
<li><a href='#SimulateRegression'><p>Data simulation for multivariate regression</p></a></li>
<li><a href='#SimulateStructural'><p>Data simulation for Structural Causal Modelling</p></a></li>
<li><a href='#SimulateSymmetricMatrix'><p>Simulation of symmetric matrix with block structure</p></a></li>
<li><a href='#TuneCStatisticLogit'><p>Tuning function (logistic regression)</p></a></li>
<li><a href='#TuneExplainedVarianceCor'><p>Tuning function (correlation)</p></a></li>
<li><a href='#TuneExplainedVarianceCov'><p>Tuning function (covariance)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Flexible Data Simulation Using the Multivariate Normal
Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Barbara Bodinier [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barbara Bodinier &lt;barbara.bodinier@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This R package can be used to generate artificial data conditionally on pre-specified (simulated or user-defined) relationships between the variables and/or observations. Each observation is drawn from a multivariate Normal distribution where the mean vector and covariance matrix reflect the desired relationships. Outputs can be used to evaluate the performances of variable selection, graphical modelling, or clustering approaches by comparing the true and estimated structures (B Bodinier et al (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2106.02521">doi:10.48550/arXiv.2106.02521</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>huge, igraph, MASS, Rdpack, withr (&ge; 2.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0),</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-13 13:24:39 UTC; barbara</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-13 22:30:24 UTC</td>
</tr>
</table>
<hr>
<h2 id='BlockDiagonal'>Block diagonal matrix</h2><span id='topic+BlockDiagonal'></span>

<h3>Description</h3>

<p>Generates a binary block diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlockDiagonal(pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlockDiagonal_+3A_pk">pk</code></td>
<td>
<p>vector encoding the grouping structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary block diagonal matrix.
</p>


<h3>See Also</h3>

<p>Other block matrix functions: 
<code><a href="#topic+BlockMatrix">BlockMatrix</a>()</code>,
<code><a href="#topic+BlockStructure">BlockStructure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
BlockDiagonal(pk = c(2, 3))

# Example 2
BlockDiagonal(pk = c(2, 3, 2))
</code></pre>

<hr>
<h2 id='BlockMatrix'>Block matrix</h2><span id='topic+BlockMatrix'></span>

<h3>Description</h3>

<p>Generates a symmetric block matrix of size (<code>sum(pk)</code> x <code>sum(pk)</code>).
The sizes of the submatrices is defined based on <code>pk</code>. For each
submatrix, all entries are equal to the submatrix (block) index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlockMatrix(pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlockMatrix_+3A_pk">pk</code></td>
<td>
<p>vector encoding the grouping structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric block matrix.
</p>


<h3>See Also</h3>

<p>Other block matrix functions: 
<code><a href="#topic+BlockDiagonal">BlockDiagonal</a>()</code>,
<code><a href="#topic+BlockStructure">BlockStructure</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
BlockMatrix(pk = c(2, 3))

# Example 2
BlockMatrix(pk = c(2, 3, 2))
</code></pre>

<hr>
<h2 id='BlockStructure'>Block structure</h2><span id='topic+BlockStructure'></span>

<h3>Description</h3>

<p>Generates a symmetric matrix of size (<code>length(pk)</code> x <code>length(pk)</code>)
where entries correspond to block indices. This function can be used to
visualise block indices of a matrix generated with <code><a href="#topic+BlockMatrix">BlockMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlockStructure(pk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlockStructure_+3A_pk">pk</code></td>
<td>
<p>vector encoding the grouping structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix of size <code>length(pk))</code>.
</p>


<h3>See Also</h3>

<p>Other block matrix functions: 
<code><a href="#topic+BlockDiagonal">BlockDiagonal</a>()</code>,
<code><a href="#topic+BlockMatrix">BlockMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
BlockMatrix(pk = c(2, 3))
BlockStructure(pk = c(2, 3))

# Example 2
BlockMatrix(pk = c(2, 3, 2))
BlockStructure(pk = c(2, 3, 2))
</code></pre>

<hr>
<h2 id='Concordance'>Concordance statistic</h2><span id='topic+Concordance'></span>

<h3>Description</h3>

<p>Computes the concordance statistic given observed binary outcomes and
predicted probabilities of event. In logistic regression, the concordance
statistic is equal to the area under the Receiver Operating Characteristic
(ROC) curve and estimates the probability that an individual who experienced
the event (<code class="reqn">Y_i=1</code>) had a higher probability of event than an individual
who did not experience the event (<code class="reqn">Y_i=0</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Concordance(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Concordance_+3A_observed">observed</code></td>
<td>
<p>vector of binary outcomes.</p>
</td></tr>
<tr><td><code id="Concordance_+3A_predicted">predicted</code></td>
<td>
<p>vector of predicted probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The concordance statistic.
</p>


<h3>See Also</h3>

<p>Other goodness of fit functions: 
<code><a href="#topic+ROC">ROC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data simulation
set.seed(1)
proba &lt;- runif(n = 200)
ydata &lt;- rbinom(n = length(proba), size = 1, prob = proba)

# Observed concordance in simulated data
Concordance(observed = ydata, predicted = proba)

</code></pre>

<hr>
<h2 id='Contrast'>Matrix contrast</h2><span id='topic+Contrast'></span>

<h3>Description</h3>

<p>Computes matrix contrast, defined as the number of unique truncated
entries with a specified number of digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Contrast(mat, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Contrast_+3A_mat">mat</code></td>
<td>
<p>input matrix.</p>
</td></tr>
<tr><td><code id="Contrast_+3A_digits">digits</code></td>
<td>
<p>number of digits to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, the contrast of the input matrix.
</p>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
mat &lt;- matrix(c(0.1, 0.2, 0.2, 0.2), ncol = 2, byrow = TRUE)
Contrast(mat)

# Example 2
mat &lt;- matrix(c(0.1, 0.2, 0.2, 0.3), ncol = 2, byrow = TRUE)
Contrast(mat)

</code></pre>

<hr>
<h2 id='ExpectedCommunities'>Expected community structure</h2><span id='topic+ExpectedCommunities'></span>

<h3>Description</h3>

<p>Computes expected metrics related to the community structure of a graph
simulated with given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectedCommunities(pk, nu_within = 0.1, nu_between = 0, nu_mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectedCommunities_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="ExpectedCommunities_+3A_nu_within">nu_within</code></td>
<td>
<p>probability of having an edge between two nodes belonging to
the same group, as defined in <code>pk</code>. If <code>length(pk)=1</code>, this is
the expected density of the graph. If <code>implementation=HugeAdjacency</code>,
this argument is only used for <code>topology="random"</code> or
<code>topology="cluster"</code> (see argument <code>prob</code> in
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>). Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="ExpectedCommunities_+3A_nu_between">nu_between</code></td>
<td>
<p>probability of having an edge between two nodes belonging
to different groups, as defined in <code>pk</code>. By default, the same density
is used for within and between blocks (<code>nu_within</code>=<code>nu_between</code>).
Only used if <code>length(pk)&gt;1</code>. Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="ExpectedCommunities_+3A_nu_mat">nu_mat</code></td>
<td>
<p>matrix of probabilities of having an edge between nodes
belonging to a given pair of node groups defined in <code>pk</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a group of nodes, the within degree <code class="reqn">d^w_i</code> of node
<code class="reqn">i</code> is defined as the number of nodes from the same group node <code class="reqn">i</code>
is connected to. The between degree <code class="reqn">d^b_i</code> is the number of nodes from
other groups node <code class="reqn">i</code> is connected to. A weak community in the network
is defined as a group of nodes for which the total within degree (sum of
the <code class="reqn">d^w_i</code> for all nodes in the community) is stricly greater than the
total between degree (sum of <code class="reqn">d^b_i</code> for all nodes in the community).
For more details, see
<a href="http://networksciencebook.com/chapter/9#basics">Network Science</a> by
Albert-Laszlo Barabasi.
</p>
<p>The expected total within and between degrees for the groups defined in
<code>pk</code> in a network simulated using <code>SimulateAdjacency</code> can be
computed given the group sizes (stored in <code>pk</code>) and probabilities of
having an edge between nodes from a given group pair (defined by
<code>nu_within</code> and <code>nu_between</code> or by <code>nu_mat</code>). The expected
presence of weak communities can be inferred from these quantities.
</p>
<p>The expected modularity, measuring the difference between observed and
expected number of within-community edges, is also returned. For more
details on this metric, see <code><a href="igraph.html#topic+modularity">modularity</a></code>.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>total_within_degree_c</code></td>
<td>
<p>total within degree by node
group, i.e. sum of expected within degree over all nodes in a given group.</p>
</td></tr>
<tr><td><code>total_between_degree</code></td>
<td>
<p>total between degree by node group, i.e. sum of
expected between degree over all nodes in a given group.</p>
</td></tr>
<tr><td><code>weak_community</code></td>
<td>
<p>binary indicator for a given node group to be an
expected weak community.</p>
</td></tr> <tr><td><code>total_number_edges_c</code></td>
<td>
<p>matrix of expected
number of edges between nodes from a given node pair.</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>
<p>expected modularity (see
<code><a href="igraph.html#topic+modularity">modularity</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SimulateGraphical">SimulateGraphical</a></code>, <code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a></code>,
<code><a href="#topic+MinWithinProba">MinWithinProba</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
pk &lt;- rep(20, 4)
nu_within &lt;- 0.8
nu_between &lt;- 0.1

# Expected metrics
expected &lt;- ExpectedCommunities(
  pk = pk,
  nu_within = nu_within,
  nu_between = nu_between
)

# Example of simulated graph
set.seed(1)
theta &lt;- SimulateAdjacency(
  pk = pk,
  nu_within = nu_within,
  nu_between = nu_between
)

# Comparing observed and expected numbers of edges
bigblocks &lt;- BlockMatrix(pk)
BlockStructure(pk)
sum(theta[which(bigblocks == 2)]) / 2
expected$total_number_edges_c[1, 2]

# Comparing observed and expected modularity
igraph::modularity(igraph::graph_from_adjacency_matrix(theta, mode = "undirected"),
  membership = rep.int(1:length(pk), times = pk)
)
expected$modularity

</code></pre>

<hr>
<h2 id='ExpectedConcordance'>Expected concordance statistic</h2><span id='topic+ExpectedConcordance'></span>

<h3>Description</h3>

<p>Computes the expected concordance statistic given true probabilities of
event. In logistic regression, the concordance statistic is equal to the area
under the Receiver Operating Characteristic (ROC) curve and estimates the
probability that an individual who experienced the event (<code class="reqn">Y_i=1</code>) had a
higher probability of event than an individual who did not experience the
event (<code class="reqn">Y_i=0</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectedConcordance(probabilities)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpectedConcordance_+3A_probabilities">probabilities</code></td>
<td>
<p>vector of probabilities of event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected concordance statistic.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Concordance">Concordance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulation of probabilities
set.seed(1)
proba &lt;- runif(n = 1000)

# Expected concordance
ExpectedConcordance(proba)

# Simulation of binary outcome
ydata &lt;- rbinom(n = length(proba), size = 1, prob = proba)

# Observed concordance in simulated data
Concordance(observed = ydata, predicted = proba)

</code></pre>

<hr>
<h2 id='Heatmap'>Heatmap visualisation</h2><span id='topic+Heatmap'></span>

<h3>Description</h3>

<p>Produces a heatmap for visualisation of matrix entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Heatmap(
  mat,
  col = c("ivory", "navajowhite", "tomato", "darkred"),
  resolution = 10000,
  bty = "o",
  axes = TRUE,
  cex.axis = 1,
  xlas = 2,
  ylas = 2,
  text = FALSE,
  cex = 1,
  legend = TRUE,
  legend_length = NULL,
  legend_range = NULL,
  cex.legend = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Heatmap_+3A_mat">mat</code></td>
<td>
<p>data matrix.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_col">col</code></td>
<td>
<p>vector of colours.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_resolution">resolution</code></td>
<td>
<p>number of different colours to use.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_bty">bty</code></td>
<td>
<p>character string indicating if the box around the plot should be
drawn. Possible values include: <code>"o"</code> (default, the box is drawn), or
<code>"n"</code> (no box).</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_axes">axes</code></td>
<td>
<p>logical indicating if the row and column names of <code>mat</code>
should be displayed.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_cex.axis">cex.axis</code></td>
<td>
<p>font size for axes.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_xlas">xlas</code></td>
<td>
<p>orientation of labels on the x-axis, as <code>las</code> in
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_ylas">ylas</code></td>
<td>
<p>orientation of labels on the y-axis, as <code>las</code> in
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_text">text</code></td>
<td>
<p>logical indicating if numbers should be displayed.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_cex">cex</code></td>
<td>
<p>font size for numbers. Only used if <code>text=TRUE</code>.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_legend">legend</code></td>
<td>
<p>logical indicating if the colour bar should be included.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_legend_length">legend_length</code></td>
<td>
<p>length of the colour bar.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_legend_range">legend_range</code></td>
<td>
<p>range of the colour bar.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_cex.legend">cex.legend</code></td>
<td>
<p>font size for legend.</p>
</td></tr>
<tr><td><code id="Heatmap_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+formatC">formatC</a></code> for
number formatting. Only used if <code>text=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
par(mar = c(3, 3, 1, 5))

# Data simulation
set.seed(1)
mat &lt;- matrix(rnorm(100), ncol = 10)
rownames(mat) &lt;- paste0("r", 1:nrow(mat))
colnames(mat) &lt;- paste0("c", 1:ncol(mat))

# Generating heatmaps
Heatmap(mat = mat)
Heatmap(mat = mat, text = TRUE, format = "f", digits = 2)
Heatmap(
  mat = mat,
  col = c("lightgrey", "blue", "black"),
  legend = FALSE
)

par(oldpar)
</code></pre>

<hr>
<h2 id='HugeAdjacency'>Simulation of undirected graph</h2><span id='topic+HugeAdjacency'></span>

<h3>Description</h3>

<p>Simulates the adjacency matrix encoding an unweighted, undirected graph with
no self-loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HugeAdjacency(pk = 10, topology = "random", nu = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HugeAdjacency_+3A_pk">pk</code></td>
<td>
<p>number of nodes.</p>
</td></tr>
<tr><td><code id="HugeAdjacency_+3A_topology">topology</code></td>
<td>
<p>topology of the simulated graph. If using
<code>implementation=HugeAdjacency</code>, possible values are listed for the
argument <code>graph</code> of <code><a href="huge.html#topic+huge.generator">huge.generator</a></code>. These are:
&quot;random&quot;, &quot;hub&quot;, &quot;cluster&quot;, &quot;band&quot; and &quot;scale-free&quot;.</p>
</td></tr>
<tr><td><code id="HugeAdjacency_+3A_nu">nu</code></td>
<td>
<p>expected density (number of edges over the number of node pairs) of
the graph. This argument is only used for <code>topology="random"</code> or
<code>topology="cluster"</code> (see argument <code>prob</code> in
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>).</p>
</td></tr>
<tr><td><code id="HugeAdjacency_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric adjacency matrix encoding an unweighted, undirected graph
with no self-loops.
</p>

<hr>
<h2 id='LayeredDAG'>Layered Directed Acyclic Graph</h2><span id='topic+LayeredDAG'></span>

<h3>Description</h3>

<p>Returns the adjacency matrix of a layered Directed Acyclic Graph. In this
graph, arrows go from all members of a layer to all members of the following
layers. There are no arrows between members of the same layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LayeredDAG(layers, n_manifest = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LayeredDAG_+3A_layers">layers</code></td>
<td>
<p>list of vectors. Each vector in the list corresponds to a
layer. There are as many layers as items in the list. Alternatively, this
argument can be a vector of the number of variables per layer.</p>
</td></tr>
<tr><td><code id="LayeredDAG_+3A_n_manifest">n_manifest</code></td>
<td>
<p>vector of the number of manifest (observed) variables
measuring each of the latent variables. If <code>n_manifest</code> is provided,
the variables defined in argument <code>layers</code> are considered latent. All
entries of <code>n_manifest</code> must be strictly positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjacency matrix of the layered Directed Acyclic Graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with 3 layers specified in a list
layers &lt;- list(
  c("x1", "x2", "x3"),
  c("x4", "x5"),
  c("x6", "x7", "x8")
)
dag &lt;- LayeredDAG(layers)
plot(dag)

# Example with 3 layers specified in a vector
dag &lt;- LayeredDAG(layers = c(3, 2, 3))
plot(dag)

</code></pre>

<hr>
<h2 id='MakePositiveDefinite'>Making positive definite matrix</h2><span id='topic+MakePositiveDefinite'></span>

<h3>Description</h3>

<p>Determines the diagonal entries of a symmetric matrix to make it is positive
definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakePositiveDefinite(
  omega,
  pd_strategy = "diagonally_dominant",
  ev_xx = NULL,
  scale = TRUE,
  u_list = c(1e-10, 1),
  tol = .Machine$double.eps^0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakePositiveDefinite_+3A_omega">omega</code></td>
<td>
<p>input matrix.</p>
</td></tr>
<tr><td><code id="MakePositiveDefinite_+3A_pd_strategy">pd_strategy</code></td>
<td>
<p>method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). If
<code>pd_strategy="diagonally_dominant"</code>, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. If
<code>pd_strategy="min_eigenvalue"</code>, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue of the precision matrix with
zeros on the diagonal and a constant u.</p>
</td></tr>
<tr><td><code id="MakePositiveDefinite_+3A_ev_xx">ev_xx</code></td>
<td>
<p>expected proportion of explained variance by the first Principal
Component (PC1) of a Principal Component Analysis. This is the largest
eigenvalue of the correlation (if <code>scale_ev=TRUE</code>) or covariance (if
<code>scale_ev=FALSE</code>) matrix divided by the sum of eigenvalues. If
<code>ev_xx=NULL</code> (the default), the constant u is chosen by maximising the
contrast of the correlation matrix.</p>
</td></tr>
<tr><td><code id="MakePositiveDefinite_+3A_scale">scale</code></td>
<td>
<p>logical indicating if the proportion of explained variance by
PC1 should be computed from the correlation (<code>scale=TRUE</code>) or
covariance (<code>scale=FALSE</code>) matrix.</p>
</td></tr>
<tr><td><code id="MakePositiveDefinite_+3A_u_list">u_list</code></td>
<td>
<p>vector with two numeric values defining the range of values to
explore for constant u.</p>
</td></tr>
<tr><td><code id="MakePositiveDefinite_+3A_tol">tol</code></td>
<td>
<p>accuracy for the search of parameter u as defined in
<code><a href="stats.html#topic+optimise">optimise</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two strategies are implemented to ensure positive definiteness: by
diagonally dominance or using eigendecomposition.
</p>
<p>A diagonally dominant symmetric matrix with positive diagonal entries is
positive definite. With <code>pd_strategy="diagonally_dominant"</code>, the
diagonal entries of the matrix are defined to be strictly higher than the
sum of entries on the corresponding row in absolute value, which ensures
diagonally dominance. Let <code class="reqn">\Omega*</code> denote the input matrix with zeros
on the diagonal and <code class="reqn">\Omega</code> be the output positive definite matrix. We
have:
</p>
<p><code class="reqn">\Omega_{ii} = \sum_{j = 1}^p | \Omega_{ij}* | + u</code>, where <code class="reqn">u &gt; 0</code>
is a parameter.
</p>
<p>A matrix is positive definite if all its eigenvalues are positive. With
<code>pd_strategy="diagonally_dominant"</code>, diagonal entries of the matrix
are defined to be higher than the absolute value of the smallest eigenvalue
of the same matrix with a diagonal of zeros. Let <code class="reqn">\lambda_1</code> denote the
smallest eigenvvalue of the input matrix <code class="reqn">\Omega*</code> with a diagonal of
zeros, and <code class="reqn">v_1</code> be the corresponding eigenvector. Diagonal entries in
the output matrix <code class="reqn">\Omega</code> are defined as:
</p>
<p><code class="reqn">\Omega_{ii} = | \lambda_1 | + u</code>, where <code class="reqn">u &gt; 0</code> is a parameter.
</p>
<p>It can be showed that <code class="reqn">\Omega</code> has stricly positive eigenvalues. Let
<code class="reqn">\lambda</code> and <code class="reqn">v</code> denote any eigenpair of <code class="reqn">\Omega*</code>:
</p>
<p><code class="reqn">\Omega* v = \lambda v</code>
</p>
<p><code class="reqn">\Omega* v + (| \lambda_1 | + u) v = \lambda v + (| \lambda_1 | + u) v</code>
</p>
<p><code class="reqn">(\Omega* + (| \lambda_1 | + u) I) v = (\lambda + | \lambda_1 | + u) v</code>
</p>
<p><code class="reqn">\Omega v = (\lambda + | \lambda_1 | + u) v</code>
</p>
<p>The eigenvalues of <code class="reqn">\Omega</code> are equal to the eigenvalues of
<code class="reqn">\Omega*</code> plus <code class="reqn">| \lambda_1 |</code>. The smallest eigenvalue of
<code class="reqn">\Omega</code> is <code class="reqn">(\lambda_1 + | \lambda_1 | + u) &gt; 0</code>.
</p>
<p>Considering the matrix to make positive definite is a precision matrix, its
standardised inverse matrix is the correlation matrix. In both cases, the
magnitude of correlations is controlled by the constant u.
</p>
<p>If <code>ev_xx=NULL</code>, the constant u is chosen to maximise the
<code><a href="#topic+Contrast">Contrast</a></code> of the corresponding correlation matrix.
</p>
<p>If <code>ev_xx</code> is provided, the constant u is chosen to generate a
correlation matrix with required proportion of explained variance by the
first Principal Component, if possible. This proportion of explained
variance is equal to the largest eigenvalue of the correlation matrix
divided by the sum of its eigenvalues. If <code>scale=FALSE</code>, the
covariance matrix is used instead of the correlation matrix for faster
computations.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>omega</code></td>
<td>
<p>positive definite matrix.</p>
</td></tr> <tr><td><code>u</code></td>
<td>
<p>value
of the constant u.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a symmetric matrix
p &lt;- 5
set.seed(1)
omega &lt;- matrix(rnorm(p * p), ncol = p)
omega &lt;- omega + t(omega)
diag(omega) &lt;- 0

# Diagonal dominance maximising contrast
omega_pd &lt;- MakePositiveDefinite(omega,
  pd_strategy = "diagonally_dominant"
)
eigen(omega_pd$omega)$values # positive eigenvalues

# Diagonal dominance with specific proportion of explained variance by PC1
omega_pd &lt;- MakePositiveDefinite(omega,
  pd_strategy = "diagonally_dominant",
  ev_xx = 0.55
)
lambda_inv &lt;- eigen(cov2cor(solve(omega_pd$omega)))$values
max(lambda_inv) / sum(lambda_inv) # expected ev

# Version not scaled (using eigenvalues from the covariance)
omega_pd &lt;- MakePositiveDefinite(omega,
  pd_strategy = "diagonally_dominant",
  ev_xx = 0.55, scale = FALSE
)
lambda_inv &lt;- 1 / eigen(omega_pd$omega)$values
max(lambda_inv) / sum(lambda_inv) # expected ev

# Non-negative eigenvalues maximising contrast
omega_pd &lt;- MakePositiveDefinite(omega,
  pd_strategy = "min_eigenvalue"
)
eigen(omega_pd$omega)$values # positive eigenvalues

# Non-negative eigenvalues with specific proportion of explained variance by PC1
omega_pd &lt;- MakePositiveDefinite(omega,
  pd_strategy = "min_eigenvalue",
  ev_xx = 0.7
)
lambda_inv &lt;- eigen(cov2cor(solve(omega_pd$omega)))$values
max(lambda_inv) / sum(lambda_inv)

# Version not scaled (using eigenvalues from the covariance)
omega_pd &lt;- MakePositiveDefinite(omega,
  pd_strategy = "min_eigenvalue",
  ev_xx = 0.7, scale = FALSE
)
lambda_inv &lt;- 1 / eigen(omega_pd$omega)$values
max(lambda_inv) / sum(lambda_inv)
</code></pre>

<hr>
<h2 id='MatchingArguments'>Matching arguments</h2><span id='topic+MatchingArguments'></span>

<h3>Description</h3>

<p>Returns a vector of overlapping character strings between <code>extra_args</code>
and arguments from function <code>FUN</code>. If <code>FUN</code> is taking <code>...</code> as
input, this function returns <code>extra_args</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchingArguments(extra_args, FUN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatchingArguments_+3A_extra_args">extra_args</code></td>
<td>
<p>vector of character strings.</p>
</td></tr>
<tr><td><code id="MatchingArguments_+3A_fun">FUN</code></td>
<td>
<p>function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of overlapping arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MatchingArguments(
  extra_args = list(Sigma = 1, test = FALSE),
  FUN = MASS::mvrnorm
)
</code></pre>

<hr>
<h2 id='MaxContrast'>Maximising matrix contrast</h2><span id='topic+MaxContrast'></span>

<h3>Description</h3>

<p>Computes the contrast of the correlation matrix obtained by adding u to the
diagonal of the precision matrix. This function is used to find the value of
u that maximises the contrast when constructing a diagonally dominant
precision matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxContrast(u, omega, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxContrast_+3A_u">u</code></td>
<td>
<p>constant u added to the diagonal of the precision matrix.</p>
</td></tr>
<tr><td><code id="MaxContrast_+3A_omega">omega</code></td>
<td>
<p>positive semi-definite precision matrix.</p>
</td></tr>
<tr><td><code id="MaxContrast_+3A_digits">digits</code></td>
<td>
<p>number of digits to use in the definition of the contrast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, the contrast of the generated precision matrix.
</p>

<hr>
<h2 id='MinWithinProba'>Within-group probabilities for communities</h2><span id='topic+MinWithinProba'></span>

<h3>Description</h3>

<p>Computes the smallest within-group probabilities that can be used to simulate
a graph where communities can be expected for given probabilities of
between-group probabilities and group sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinWithinProba(pk, nu_between = 0, nu_mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinWithinProba_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="MinWithinProba_+3A_nu_between">nu_between</code></td>
<td>
<p>probability of having an edge between two nodes belonging
to different groups, as defined in <code>pk</code>. By default, the same density
is used for within and between blocks (<code>nu_within</code>=<code>nu_between</code>).
Only used if <code>length(pk)&gt;1</code>. Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="MinWithinProba_+3A_nu_mat">nu_mat</code></td>
<td>
<p>matrix of probabilities of having an edge between nodes
belonging to a given pair of node groups defined in <code>pk</code>. Only
off-diagonal entries are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector of within-group probabilities is the smallest one that
can be used to generate an expected total within degree <code class="reqn">D^w_k</code>
strictly higher than the expected total between degree <code class="reqn">D^b_k</code> for all
communities <code class="reqn">k</code> (see <code><a href="#topic+ExpectedCommunities">ExpectedCommunities</a></code>). Namely, using
the suggested within-group probabilities would give expected <code class="reqn">D^w_k =
  D^b_k + 1</code>.
</p>


<h3>Value</h3>

<p>A vector of within-group probabilities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ExpectedCommunities">ExpectedCommunities</a></code>, <code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a></code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
pk &lt;- rep(20, 4)
nu_between &lt;- 0.1

# Estimating smallest nu_within
nu_within &lt;- MinWithinProba(pk = pk, nu_between = nu_between)

# Expected metrics
ExpectedCommunities(
  pk = pk,
  nu_within = max(nu_within),
  nu_between = nu_between
)

</code></pre>

<hr>
<h2 id='plot.roc_curve'>Receiver Operating Characteristic (ROC) curve</h2><span id='topic+plot.roc_curve'></span>

<h3>Description</h3>

<p>Plots the True Positive Rate (TPR) as a function of the False Positive Rate
(FPR) for different thresholds in predicted probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc_curve'
plot(x, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.roc_curve_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+ROC">ROC</a></code>.</p>
</td></tr>
<tr><td><code id="plot.roc_curve_+3A_add">add</code></td>
<td>
<p>logical indicating if the curve should be added to the current
plot.</p>
</td></tr>
<tr><td><code id="plot.roc_curve_+3A_...">...</code></td>
<td>
<p>additional plotting arguments (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ROC">ROC</a></code>, <code><a href="#topic+Concordance">Concordance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data simulation
set.seed(1)
simul &lt;- SimulateRegression(
  n = 500, pk = 20,
  family = "binomial", ev_xy = 0.8
)

# Logistic regression
fitted &lt;- glm(simul$ydata ~ simul$xdata, family = "binomial")$fitted.values

# Constructing the ROC curve
roc &lt;- ROC(predicted = fitted, observed = simul$ydata)
plot(roc)

</code></pre>

<hr>
<h2 id='Rates'>True and False Positive Rates</h2><span id='topic+Rates'></span>

<h3>Description</h3>

<p>Computes the True and False Positive Rates by comparing the true (observed) and
predicted status. The predicted status is obtained by applying a threshold on
the predicted scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rates(observed, predicted, thr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rates_+3A_observed">observed</code></td>
<td>
<p>vector of binary outcomes.</p>
</td></tr>
<tr><td><code id="Rates_+3A_predicted">predicted</code></td>
<td>
<p>vector of predicted scores.</p>
</td></tr>
<tr><td><code id="Rates_+3A_thr">thr</code></td>
<td>
<p>threshold for predicted scores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True and False Positive Rates (TPR and FPR, respectively).
</p>

<hr>
<h2 id='ROC'>Receiver Operating Characteristic (ROC)</h2><span id='topic+ROC'></span>

<h3>Description</h3>

<p>Computes the True and False Positive Rates (TPR and FPR, respectively) and
Area Under the Curve (AUC) by comparing the true (observed) and predicted
status using a range of thresholds on the predicted score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROC(observed, predicted, n_thr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROC_+3A_observed">observed</code></td>
<td>
<p>vector of binary outcomes.</p>
</td></tr>
<tr><td><code id="ROC_+3A_predicted">predicted</code></td>
<td>
<p>vector of predicted scores.</p>
</td></tr>
<tr><td><code id="ROC_+3A_n_thr">n_thr</code></td>
<td>
<p>number of thresholds to use to construct the ROC curve. For
faster computations on large data, values below <code>length(predicted)-1</code>
can be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>TPR</code></td>
<td>
<p>True Positive Rate.</p>
</td></tr> <tr><td><code>FPR</code></td>
<td>
<p>False
Positive Rate.</p>
</td></tr> <tr><td><code>AUC</code></td>
<td>
<p>Area Under the Curve.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other goodness of fit functions: 
<code><a href="#topic+Concordance">Concordance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data simulation
set.seed(1)
simul &lt;- SimulateRegression(
  n = 500, pk = 20,
  family = "binomial", ev_xy = 0.8
)

# Logistic regression
fitted &lt;- glm(simul$ydata ~ simul$xdata, family = "binomial")$fitted.values

# Constructing the ROC curve
roc &lt;- ROC(predicted = fitted, observed = simul$ydata)
plot(roc)

</code></pre>

<hr>
<h2 id='SamplePredictors'>Simulation of binary contribution status</h2><span id='topic+SamplePredictors'></span>

<h3>Description</h3>

<p>Simulates the binary contribution status of potential predictor variables
from different blocks to outcome variables. For each outcome, the set of true
predictors is sampled from one block of potential predictors. If the blocks
of variables are independent, the outcomes will be independent too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SamplePredictors(pk, q = NULL, nu = 0.1, orthogonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SamplePredictors_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group, defining the block
structure.</p>
</td></tr>
<tr><td><code id="SamplePredictors_+3A_q">q</code></td>
<td>
<p>number of outcome variables. By default, one block of predictor is
linked to one outcome, i.e. <code>q=sum(pk)</code>.</p>
</td></tr>
<tr><td><code id="SamplePredictors_+3A_nu">nu</code></td>
<td>
<p>vector of probabilities. Each entry corresponds to one block of
predictors and defines the probability for each predictor within the block
to be chosen as true predictor of the corresponding outcome variable.</p>
</td></tr>
<tr><td><code id="SamplePredictors_+3A_orthogonal">orthogonal</code></td>
<td>
<p>logical indicating if the outcomes have to be defined from
independent blocks of predictors as encoded in <code>pk</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary matrix encoding the contribution status of each predictor
variable (columns) to each outcome variable (rows).
</p>

<hr>
<h2 id='SimulateAdjacency'>Simulation of undirected graph with block structure</h2><span id='topic+SimulateAdjacency'></span>

<h3>Description</h3>

<p>Simulates the adjacency matrix of an unweighted, undirected graph with no
self-loops. If <code>topology="random"</code>, different densities in diagonal
(<code>nu_within</code>) compared to off-diagonal (<code>nu_between</code>) blocks can be
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateAdjacency(
  pk = 10,
  implementation = HugeAdjacency,
  topology = "random",
  nu_within = 0.1,
  nu_between = 0,
  nu_mat = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateAdjacency_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateAdjacency_+3A_implementation">implementation</code></td>
<td>
<p>function for simulation of the graph. By default,
algorithms implemented in <code><a href="huge.html#topic+huge.generator">huge.generator</a></code> are used.
Alternatively, a user-defined function can be used. It must take <code>pk</code>,
<code>topology</code> and <code>nu</code> as arguments and return a
<code>(sum(pk)*(sum(pk)))</code> binary and symmetric matrix for which diagonal
entries are all equal to zero. This function is only applied if
<code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateAdjacency_+3A_topology">topology</code></td>
<td>
<p>topology of the simulated graph. If using
<code>implementation=HugeAdjacency</code>, possible values are listed for the
argument <code>graph</code> of <code><a href="huge.html#topic+huge.generator">huge.generator</a></code>. These are:
&quot;random&quot;, &quot;hub&quot;, &quot;cluster&quot;, &quot;band&quot; and &quot;scale-free&quot;.</p>
</td></tr>
<tr><td><code id="SimulateAdjacency_+3A_nu_within">nu_within</code></td>
<td>
<p>probability of having an edge between two nodes belonging to
the same group, as defined in <code>pk</code>. If <code>length(pk)=1</code>, this is
the expected density of the graph. If <code>implementation=HugeAdjacency</code>,
this argument is only used for <code>topology="random"</code> or
<code>topology="cluster"</code> (see argument <code>prob</code> in
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>). Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateAdjacency_+3A_nu_between">nu_between</code></td>
<td>
<p>probability of having an edge between two nodes belonging
to different groups, as defined in <code>pk</code>. By default, the same density
is used for within and between blocks (<code>nu_within</code>=<code>nu_between</code>).
Only used if <code>length(pk)&gt;1</code>. Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateAdjacency_+3A_nu_mat">nu_mat</code></td>
<td>
<p>matrix of probabilities of having an edge between nodes
belonging to a given pair of node groups defined in <code>pk</code>.</p>
</td></tr>
<tr><td><code id="SimulateAdjacency_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the graph simulation function
provided in <code>implementation</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random graphs are simulated using the Erdos-Renyi algorithm.
Scale-free graphs are simulated using a preferential attachment algorithm.
More details are provided in <code><a href="huge.html#topic+huge.generator">huge.generator</a></code>.
</p>


<h3>Value</h3>

<p>A symmetric adjacency matrix encoding an unweighted, undirected graph
with no self-loops, and with different densities in diagonal compared to
off-diagonal blocks.
</p>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>
<p>Jiang H, Fei X, Liu H, Roeder K, Lafferty J, Wasserman L, Li X, Zhao T (2021).
<em>huge: High-Dimensional Undirected Graph Estimation</em>.
R package version 1.3.5, <a href="https://CRAN.R-project.org/package=huge">https://CRAN.R-project.org/package=huge</a>.
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+SimulateClustering">SimulateClustering</a>()</code>,
<code><a href="#topic+SimulateComponents">SimulateComponents</a>()</code>,
<code><a href="#topic+SimulateCorrelation">SimulateCorrelation</a>()</code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a>()</code>,
<code><a href="#topic+SimulateRegression">SimulateRegression</a>()</code>,
<code><a href="#topic+SimulateStructural">SimulateStructural</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a scale-free graph with 20 nodes
adjacency &lt;- SimulateAdjacency(pk = 20, topology = "scale-free")
plot(adjacency)

# Simulation of a random graph with three connected components
adjacency &lt;- SimulateAdjacency(
  pk = rep(10, 3),
  nu_within = 0.7, nu_between = 0
)
plot(adjacency)

# Simulation of a random graph with block structure
adjacency &lt;- SimulateAdjacency(
  pk = rep(10, 3),
  nu_within = 0.7, nu_between = 0.03
)
plot(adjacency)

# User-defined function for graph simulation
CentralNode &lt;- function(pk, hub = 1) {
  theta &lt;- matrix(0, nrow = sum(pk), ncol = sum(pk))
  theta[hub, ] &lt;- 1
  theta[, hub] &lt;- 1
  diag(theta) &lt;- 0
  return(theta)
}
simul &lt;- SimulateAdjacency(pk = 10, implementation = CentralNode)
plot(simul) # star
simul &lt;- SimulateAdjacency(pk = 10, implementation = CentralNode, hub = 2)
plot(simul) # variable 2 is the central node
</code></pre>

<hr>
<h2 id='SimulateClustering'>Simulation of data with underlying clusters</h2><span id='topic+SimulateClustering'></span>

<h3>Description</h3>

<p>Simulates mixture multivariate Normal data with clusters of items (rows)
sharing similar profiles along (a subset of) attributes (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateClustering(
  n = c(10, 10),
  pk = 10,
  sigma = NULL,
  theta_xc = NULL,
  nu_xc = 1,
  ev_xc = 0.5,
  output_matrices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateClustering_+3A_n">n</code></td>
<td>
<p>vector of the number of items per cluster in the simulated data. The
total number of items is <code>sum(n)</code>.</p>
</td></tr>
<tr><td><code id="SimulateClustering_+3A_pk">pk</code></td>
<td>
<p>vector of the number of attributes in the simulated data.</p>
</td></tr>
<tr><td><code id="SimulateClustering_+3A_sigma">sigma</code></td>
<td>
<p>optional within-cluster correlation matrix.</p>
</td></tr>
<tr><td><code id="SimulateClustering_+3A_theta_xc">theta_xc</code></td>
<td>
<p>optional binary matrix encoding which attributes (columns)
contribute to the clustering structure between which clusters (rows). If
<code>theta_xc=NULL</code>, variables contributing to the clustering are sampled
with probability <code>nu_xc</code>.</p>
</td></tr>
<tr><td><code id="SimulateClustering_+3A_nu_xc">nu_xc</code></td>
<td>
<p>expected proportion of variables contributing to the clustering
over the total number of variables. Only used if <code>theta_xc</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateClustering_+3A_ev_xc">ev_xc</code></td>
<td>
<p>vector of expected proportion of variance in each of the
contributing attributes that can be explained by the clustering.</p>
</td></tr>
<tr><td><code id="SimulateClustering_+3A_output_matrices">output_matrices</code></td>
<td>
<p>logical indicating if the cluster and attribute
specific means and cluster specific covariance matrix should be included
in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is simulated from a Gaussian mixture where for all <code class="reqn">i
  \in {1, \dots, n}</code>:
</p>
<p><code class="reqn">Z_i i.i.d. ~ M(1, \kappa)</code>
</p>
<p><code class="reqn">X_i | Z_i indep. ~ N_p(\mu_{Z_i}, \Sigma)</code>
</p>
<p>where <code class="reqn">M(1, \kappa)</code> is the multinomial distribution with parameters 1
and <code class="reqn">\kappa</code>, the vector of length <code class="reqn">G</code> (the number of clusters)
with probabilities of belonging to each of the clusters, and
<code class="reqn">N_p(\mu_{Z_i}, \Sigma)</code> is the multivariate Normal distribution with a
mean vector <code class="reqn">\mu_{Z_i}</code> that depends on the cluster membership encoded
in <code class="reqn">Z_i</code> and the same covariance matrix <code class="reqn">\Sigma</code> within all <code class="reqn">G</code>
clusters.
</p>
<p>The mean vectors <code class="reqn">\mu_{g}, g \in {1, \dots G}</code> are simulated so that
the desired proportion of variance in each of attributes explained by the
clustering (argument <code>ev_xc</code>) is reached.
</p>
<p>The covariance matrix <code class="reqn">\Sigma</code> is obtained by re-scaling a correlation
matrix (argument <code>sigma</code>) to ensure that the desired proportions of
explained variances by the clustering (argument <code>ev_xc</code>) are reached.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>simulated data with <code>sum(n)</code>
observation and <code>sum(pk)</code> variables</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>simulated (true)
cluster membership.</p>
</td></tr> <tr><td><code>theta_xc</code></td>
<td>
<p>binary vector encoding variables
contributing to the clustering structure.</p>
</td></tr> <tr><td><code>ev</code></td>
<td>
<p>vector of marginal
expected proportions of explained variance for each variable.</p>
</td></tr>
<tr><td><code>mu_mixture</code></td>
<td>
<p>simulated (true) cluster-specific means. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>sigma</code></td>
<td>
<p>simulated (true) covariance
matrix. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>
</p>
<p>Other simulation functions: 
<code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a>()</code>,
<code><a href="#topic+SimulateComponents">SimulateComponents</a>()</code>,
<code><a href="#topic+SimulateCorrelation">SimulateCorrelation</a>()</code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a>()</code>,
<code><a href="#topic+SimulateRegression">SimulateRegression</a>()</code>,
<code><a href="#topic+SimulateStructural">SimulateStructural</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
par(mar = rep(7, 4))

## Example with 3 clusters

# Data simulation
set.seed(1)
simul &lt;- SimulateClustering(
  n = c(10, 30, 15),
  nu_xc = 1,
  ev_xc = 0.5
)
print(simul)
plot(simul)

# Checking the proportion of explained variance
x &lt;- simul$data[, 1]
z &lt;- as.factor(simul$theta)
summary(lm(x ~ z)) # R-squared


## Example with 2 variables contributing to clustering

# Data simulation
set.seed(1)
simul &lt;- SimulateClustering(
  n = c(20, 10, 15), pk = 10,
  theta_xc = c(1, 1, rep(0, 8)),
  ev_xc = 0.8
)
print(simul)
plot(simul)

# Visualisation of the data
Heatmap(
  mat = simul$data,
  col = c("navy", "white", "red")
)
simul$ev # marginal proportions of explained variance

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta, pch = 19)


## Example with different levels of separation

# Data simulation
set.seed(1)
simul &lt;- SimulateClustering(
  n = c(20, 10, 15), pk = 10,
  theta_xc = c(1, 1, rep(0, 8)),
  ev_xc = c(0.99, 0.5, rep(0, 8))
)

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta, pch = 19)


## Example with correlated contributors

# Data simulation
pk &lt;- 10
adjacency &lt;- matrix(0, pk, pk)
adjacency[1, 2] &lt;- adjacency[2, 1] &lt;- 1
set.seed(1)
sigma &lt;- SimulateCorrelation(
  pk = pk,
  theta = adjacency,
  pd_strategy = "min_eigenvalue",
  v_within = 0.6, v_sign = -1
)$sigma
simul &lt;- SimulateClustering(
  n = c(200, 100, 150), pk = pk, sigma = sigma,
  theta_xc = c(1, 1, rep(0, 8)),
  ev_xc = c(0.9, 0.8, rep(0, 8))
)

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta, pch = 19)

# Checking marginal proportions of explained variance
mymodel &lt;- lm(simul$data[, 1] ~ as.factor(simul$theta))
summary(mymodel)$r.squared
mymodel &lt;- lm(simul$data[, 2] ~ as.factor(simul$theta))
summary(mymodel)$r.squared

par(oldpar)

</code></pre>

<hr>
<h2 id='SimulateComponents'>Data simulation for sparse Principal Component Analysis</h2><span id='topic+SimulateComponents'></span>

<h3>Description</h3>

<p>Simulates data with with independent groups of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateComponents(
  n = 100,
  pk = c(10, 10),
  adjacency = NULL,
  nu_within = 1,
  v_within = c(0.5, 1),
  v_sign = -1,
  continuous = TRUE,
  pd_strategy = "min_eigenvalue",
  ev_xx = 0.1,
  scale_ev = TRUE,
  u_list = c(1e-10, 1),
  tol = .Machine$double.eps^0.25,
  scale = TRUE,
  output_matrices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateComponents_+3A_n">n</code></td>
<td>
<p>number of observations in the simulated dataset.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_adjacency">adjacency</code></td>
<td>
<p>optional binary and symmetric adjacency matrix encoding the
conditional graph structure between observations. The clusters encoded in
this argument must be in line with those indicated in <code>pk</code>. Edges in
off-diagonal blocks are not allowed to ensure that the simulated orthogonal
components are sparse. Corresponding entries in the precision matrix will
be set to zero.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_nu_within">nu_within</code></td>
<td>
<p>probability of having an edge between two nodes belonging to
the same group, as defined in <code>pk</code>. If <code>length(pk)=1</code>, this is
the expected density of the graph. If <code>implementation=HugeAdjacency</code>,
this argument is only used for <code>topology="random"</code> or
<code>topology="cluster"</code> (see argument <code>prob</code> in
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>). Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_v_within">v_within</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if <code>pd_strategy="min_eigenvalue"</code>. If <code>continuous=FALSE</code>,
<code>v_within</code> is the set of possible precision values. If
<code>continuous=TRUE</code>, <code>v_within</code> is the range of possible precision
values.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_v_sign">v_sign</code></td>
<td>
<p>vector of possible signs for precision matrix entries. Possible
inputs are: <code>-1</code> for positive partial correlations, <code>1</code> for
negative partial correlations, or <code>c(-1, 1)</code> for both positive and
negative partial correlations.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
<code>v_within</code> (diagonal blocks) or <code>v_between</code> (off-diagonal blocks)
(if <code>continuous=TRUE</code>) or from proposed values in <code>v_within</code>
(diagonal blocks) or <code>v_between</code> (off-diagonal blocks) (if
<code>continuous=FALSE</code>).</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_pd_strategy">pd_strategy</code></td>
<td>
<p>method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). If
<code>pd_strategy="diagonally_dominant"</code>, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. If
<code>pd_strategy="min_eigenvalue"</code>, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue of the precision matrix with
zeros on the diagonal and a constant u.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_ev_xx">ev_xx</code></td>
<td>
<p>expected proportion of explained variance by the first Principal
Component (PC1) of a Principal Component Analysis. This is the largest
eigenvalue of the correlation (if <code>scale_ev=TRUE</code>) or covariance (if
<code>scale_ev=FALSE</code>) matrix divided by the sum of eigenvalues. If
<code>ev_xx=NULL</code> (the default), the constant u is chosen by maximising the
contrast of the correlation matrix.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_scale_ev">scale_ev</code></td>
<td>
<p>logical indicating if the proportion of explained variance by
PC1 should be computed from the correlation (<code>scale_ev=TRUE</code>) or
covariance (<code>scale_ev=FALSE</code>) matrix. If <code>scale_ev=TRUE</code>, the
correlation matrix is used as parameter of the multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_u_list">u_list</code></td>
<td>
<p>vector with two numeric values defining the range of values to
explore for constant u.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_tol">tol</code></td>
<td>
<p>accuracy for the search of parameter u as defined in
<code><a href="stats.html#topic+optimise">optimise</a></code>.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_scale">scale</code></td>
<td>
<p>logical indicating if the true mean is zero and true variance is
one for all simulated variables. The observed mean and variance may be
slightly off by chance.</p>
</td></tr>
<tr><td><code id="SimulateComponents_+3A_output_matrices">output_matrices</code></td>
<td>
<p>logical indicating if the true precision and (partial)
correlation matrices should be included in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is simulated from a centered multivariate Normal
distribution with a block-diagonal covariance matrix. Independence between
variables from the different blocks ensures that sparse orthogonal
components can be generated.
</p>
<p>The block-diagonal partial correlation matrix is obtained using a graph
structure encoding the conditional independence between variables. The
orthogonal latent variables are obtained from eigendecomposition of the
true correlation matrix. The sparse eigenvectors contain the weights of the
linear combination of variables to construct the latent variable (loadings
coefficients). The proportion of explained variance by each of the latent
variable is computed from eigenvalues.
</p>
<p>As latent variables are defined from the true correlation matrix, the
number of sparse orthogonal components is not limited by the number of
observations and is equal to <code>sum(pk)</code>.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>simulated data with <code>n</code> observation and
<code>sum(pk)</code> variables.</p>
</td></tr> <tr><td><code>loadings</code></td>
<td>
<p>loadings coefficients of the
orthogonal latent variables (principal components).</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>support
of the loadings coefficients.</p>
</td></tr> <tr><td><code>ev</code></td>
<td>
<p>proportion of explained variance
by each of the orthogonal latent variables.</p>
</td></tr> <tr><td><code>adjacency</code></td>
<td>
<p>adjacency
matrix of the simulated graph.</p>
</td></tr> <tr><td><code>omega</code></td>
<td>
<p>simulated (true) precision
matrix. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>phi</code></td>
<td>
<p>simulated
(true) partial correlation matrix. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>C</code></td>
<td>
<p> simulated (true) correlation
matrix. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>
</p>
<p>Other simulation functions: 
<code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a>()</code>,
<code><a href="#topic+SimulateClustering">SimulateClustering</a>()</code>,
<code><a href="#topic+SimulateCorrelation">SimulateCorrelation</a>()</code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a>()</code>,
<code><a href="#topic+SimulateRegression">SimulateRegression</a>()</code>,
<code><a href="#topic+SimulateStructural">SimulateStructural</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulation of 3 components with high e.v.
set.seed(1)
simul &lt;- SimulateComponents(pk = c(5, 3, 4), ev_xx = 0.4)
print(simul)
plot(simul)
plot(cumsum(simul$ev), ylim = c(0, 1), las = 1)

# Simulation of 3 components with moderate e.v.
set.seed(1)
simul &lt;- SimulateComponents(pk = c(5, 3, 4), ev_xx = 0.25)
print(simul)
plot(simul)
plot(cumsum(simul$ev), ylim = c(0, 1), las = 1)

# Simulation of multiple components with low e.v.
pk &lt;- sample(3:10, size = 5, replace = TRUE)
simul &lt;- SimulateComponents(
  pk = pk,
  nu_within = 0.3, v_within = c(0.8, 0.5), v_sign = -1, ev_xx = 0.1
)
plot(simul)
plot(cumsum(simul$ev), ylim = c(0, 1), las = 1)

</code></pre>

<hr>
<h2 id='SimulateCorrelation'>Simulation of a correlation matrix</h2><span id='topic+SimulateCorrelation'></span>

<h3>Description</h3>

<p>Simulates a correlation matrix. This is done in three steps with (i) the
simulation of an undirected graph encoding conditional independence, (ii) the
simulation of a (positive definite) precision matrix given the graph, and
(iii) the re-scaling of the inverse of the precision matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateCorrelation(
  pk = 10,
  theta = NULL,
  implementation = HugeAdjacency,
  topology = "random",
  nu_within = 0.1,
  nu_between = NULL,
  nu_mat = NULL,
  v_within = c(0.5, 1),
  v_between = c(0.1, 0.2),
  v_sign = c(-1, 1),
  continuous = TRUE,
  pd_strategy = "diagonally_dominant",
  ev_xx = NULL,
  scale_ev = TRUE,
  u_list = c(1e-10, 1),
  tol = .Machine$double.eps^0.25,
  output_matrices = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateCorrelation_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_theta">theta</code></td>
<td>
<p>optional binary and symmetric adjacency matrix encoding the
conditional independence structure.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_implementation">implementation</code></td>
<td>
<p>function for simulation of the graph. By default,
algorithms implemented in <code><a href="huge.html#topic+huge.generator">huge.generator</a></code> are used.
Alternatively, a user-defined function can be used. It must take <code>pk</code>,
<code>topology</code> and <code>nu</code> as arguments and return a
<code>(sum(pk)*(sum(pk)))</code> binary and symmetric matrix for which diagonal
entries are all equal to zero. This function is only applied if
<code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_topology">topology</code></td>
<td>
<p>topology of the simulated graph. If using
<code>implementation=HugeAdjacency</code>, possible values are listed for the
argument <code>graph</code> of <code><a href="huge.html#topic+huge.generator">huge.generator</a></code>. These are:
&quot;random&quot;, &quot;hub&quot;, &quot;cluster&quot;, &quot;band&quot; and &quot;scale-free&quot;.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_nu_within">nu_within</code></td>
<td>
<p>probability of having an edge between two nodes belonging to
the same group, as defined in <code>pk</code>. If <code>length(pk)=1</code>, this is
the expected density of the graph. If <code>implementation=HugeAdjacency</code>,
this argument is only used for <code>topology="random"</code> or
<code>topology="cluster"</code> (see argument <code>prob</code> in
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>). Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_nu_between">nu_between</code></td>
<td>
<p>probability of having an edge between two nodes belonging
to different groups, as defined in <code>pk</code>. By default, the same density
is used for within and between blocks (<code>nu_within</code>=<code>nu_between</code>).
Only used if <code>length(pk)&gt;1</code>. Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_nu_mat">nu_mat</code></td>
<td>
<p>matrix of probabilities of having an edge between nodes
belonging to a given pair of node groups defined in <code>pk</code>.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_v_within">v_within</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if <code>pd_strategy="min_eigenvalue"</code>. If <code>continuous=FALSE</code>,
<code>v_within</code> is the set of possible precision values. If
<code>continuous=TRUE</code>, <code>v_within</code> is the range of possible precision
values.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_v_between">v_between</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
<code>v_within</code> but for off-diagonal blocks. It is only used if
<code>length(pk)&gt;1</code>.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_v_sign">v_sign</code></td>
<td>
<p>vector of possible signs for precision matrix entries. Possible
inputs are: <code>-1</code> for positive partial correlations, <code>1</code> for
negative partial correlations, or <code>c(-1, 1)</code> for both positive and
negative partial correlations.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
<code>v_within</code> (diagonal blocks) or <code>v_between</code> (off-diagonal blocks)
(if <code>continuous=TRUE</code>) or from proposed values in <code>v_within</code>
(diagonal blocks) or <code>v_between</code> (off-diagonal blocks) (if
<code>continuous=FALSE</code>).</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_pd_strategy">pd_strategy</code></td>
<td>
<p>method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). If
<code>pd_strategy="diagonally_dominant"</code>, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. If
<code>pd_strategy="min_eigenvalue"</code>, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue of the precision matrix with
zeros on the diagonal and a constant u.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_ev_xx">ev_xx</code></td>
<td>
<p>expected proportion of explained variance by the first Principal
Component (PC1) of a Principal Component Analysis. This is the largest
eigenvalue of the correlation (if <code>scale_ev=TRUE</code>) or covariance (if
<code>scale_ev=FALSE</code>) matrix divided by the sum of eigenvalues. If
<code>ev_xx=NULL</code> (the default), the constant u is chosen by maximising the
contrast of the correlation matrix.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_scale_ev">scale_ev</code></td>
<td>
<p>logical indicating if the proportion of explained variance by
PC1 should be computed from the correlation (<code>scale_ev=TRUE</code>) or
covariance (<code>scale_ev=FALSE</code>) matrix. If <code>scale_ev=TRUE</code>, the
correlation matrix is used as parameter of the multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_u_list">u_list</code></td>
<td>
<p>vector with two numeric values defining the range of values to
explore for constant u.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_tol">tol</code></td>
<td>
<p>accuracy for the search of parameter u as defined in
<code><a href="stats.html#topic+optimise">optimise</a></code>.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_output_matrices">output_matrices</code></td>
<td>
<p>logical indicating if the true precision and (partial)
correlation matrices should be included in the output.</p>
</td></tr>
<tr><td><code id="SimulateCorrelation_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the graph simulation function
provided in <code>implementation</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Step 1, the conditional independence structure between the
variables is simulated. This is done using <code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a></code>.
</p>
<p>In Step 2, the precision matrix is simulated using
<code><a href="#topic+SimulatePrecision">SimulatePrecision</a></code> so that (i) its nonzero entries correspond
to edges in the graph simulated in Step 1, and (ii) it is positive definite
(see <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>).
</p>
<p>In Step 3, the covariance is calculated as the inverse of the precision
matrix. The correlation matrix is then obtained by re-scaling the
covariance matrix (see <code><a href="stats.html#topic+cov2cor">cov2cor</a></code>).
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>sigma</code></td>
<td>
<p>simulated correlation matrix.</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>simulated precision matrix. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>adjacency matrix of the
simulated graph. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+SimulatePrecision">SimulatePrecision</a></code>, <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>
</p>
<p>Other simulation functions: 
<code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a>()</code>,
<code><a href="#topic+SimulateClustering">SimulateClustering</a>()</code>,
<code><a href="#topic+SimulateComponents">SimulateComponents</a>()</code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a>()</code>,
<code><a href="#topic+SimulateRegression">SimulateRegression</a>()</code>,
<code><a href="#topic+SimulateStructural">SimulateStructural</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
par(mar = rep(7, 4))

# Random correlation matrix
set.seed(1)
simul &lt;- SimulateCorrelation(pk = 10)
Heatmap(simul$sigma,
  col = c("navy", "white", "darkred"),
  text = TRUE, format = "f", digits = 2,
  legend_range = c(-1, 1)
)

# Correlation matrix with homogeneous block structure
set.seed(1)
simul &lt;- SimulateCorrelation(
  pk = c(5, 5),
  nu_within = 1,
  nu_between = 0,
  v_sign = -1,
  v_within = 1
)
Heatmap(simul$sigma,
  col = c("navy", "white", "darkred"),
  text = TRUE, format = "f", digits = 2,
  legend_range = c(-1, 1)
)

# Correlation matrix with heterogeneous block structure
set.seed(1)
simul &lt;- SimulateCorrelation(
  pk = c(5, 5),
  nu_within = 0.5,
  nu_between = 0,
  v_sign = -1
)
Heatmap(simul$sigma,
  col = c("navy", "white", "darkred"),
  text = TRUE, format = "f", digits = 2,
  legend_range = c(-1, 1)
)

par(oldpar)

</code></pre>

<hr>
<h2 id='SimulateGraphical'>Data simulation for Gaussian Graphical Modelling</h2><span id='topic+SimulateGraphical'></span>

<h3>Description</h3>

<p>Simulates data from a Gaussian Graphical Model (GGM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateGraphical(
  n = 100,
  pk = 10,
  theta = NULL,
  implementation = HugeAdjacency,
  topology = "random",
  nu_within = 0.1,
  nu_between = NULL,
  nu_mat = NULL,
  v_within = c(0.5, 1),
  v_between = c(0.1, 0.2),
  v_sign = c(-1, 1),
  continuous = TRUE,
  pd_strategy = "diagonally_dominant",
  ev_xx = NULL,
  scale_ev = TRUE,
  u_list = c(1e-10, 1),
  tol = .Machine$double.eps^0.25,
  scale = TRUE,
  output_matrices = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateGraphical_+3A_n">n</code></td>
<td>
<p>number of observations in the simulated dataset.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_theta">theta</code></td>
<td>
<p>optional binary and symmetric adjacency matrix encoding the
conditional independence structure.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_implementation">implementation</code></td>
<td>
<p>function for simulation of the graph. By default,
algorithms implemented in <code><a href="huge.html#topic+huge.generator">huge.generator</a></code> are used.
Alternatively, a user-defined function can be used. It must take <code>pk</code>,
<code>topology</code> and <code>nu</code> as arguments and return a
<code>(sum(pk)*(sum(pk)))</code> binary and symmetric matrix for which diagonal
entries are all equal to zero. This function is only applied if
<code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_topology">topology</code></td>
<td>
<p>topology of the simulated graph. If using
<code>implementation=HugeAdjacency</code>, possible values are listed for the
argument <code>graph</code> of <code><a href="huge.html#topic+huge.generator">huge.generator</a></code>. These are:
&quot;random&quot;, &quot;hub&quot;, &quot;cluster&quot;, &quot;band&quot; and &quot;scale-free&quot;.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_nu_within">nu_within</code></td>
<td>
<p>probability of having an edge between two nodes belonging to
the same group, as defined in <code>pk</code>. If <code>length(pk)=1</code>, this is
the expected density of the graph. If <code>implementation=HugeAdjacency</code>,
this argument is only used for <code>topology="random"</code> or
<code>topology="cluster"</code> (see argument <code>prob</code> in
<code><a href="huge.html#topic+huge.generator">huge.generator</a></code>). Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_nu_between">nu_between</code></td>
<td>
<p>probability of having an edge between two nodes belonging
to different groups, as defined in <code>pk</code>. By default, the same density
is used for within and between blocks (<code>nu_within</code>=<code>nu_between</code>).
Only used if <code>length(pk)&gt;1</code>. Only used if <code>nu_mat</code> is not
provided.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_nu_mat">nu_mat</code></td>
<td>
<p>matrix of probabilities of having an edge between nodes
belonging to a given pair of node groups defined in <code>pk</code>.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_v_within">v_within</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if <code>pd_strategy="min_eigenvalue"</code>. If <code>continuous=FALSE</code>,
<code>v_within</code> is the set of possible precision values. If
<code>continuous=TRUE</code>, <code>v_within</code> is the range of possible precision
values.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_v_between">v_between</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
<code>v_within</code> but for off-diagonal blocks. It is only used if
<code>length(pk)&gt;1</code>.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_v_sign">v_sign</code></td>
<td>
<p>vector of possible signs for precision matrix entries. Possible
inputs are: <code>-1</code> for positive partial correlations, <code>1</code> for
negative partial correlations, or <code>c(-1, 1)</code> for both positive and
negative partial correlations.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
<code>v_within</code> (diagonal blocks) or <code>v_between</code> (off-diagonal blocks)
(if <code>continuous=TRUE</code>) or from proposed values in <code>v_within</code>
(diagonal blocks) or <code>v_between</code> (off-diagonal blocks) (if
<code>continuous=FALSE</code>).</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_pd_strategy">pd_strategy</code></td>
<td>
<p>method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). If
<code>pd_strategy="diagonally_dominant"</code>, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. If
<code>pd_strategy="min_eigenvalue"</code>, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue of the precision matrix with
zeros on the diagonal and a constant u.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_ev_xx">ev_xx</code></td>
<td>
<p>expected proportion of explained variance by the first Principal
Component (PC1) of a Principal Component Analysis. This is the largest
eigenvalue of the correlation (if <code>scale_ev=TRUE</code>) or covariance (if
<code>scale_ev=FALSE</code>) matrix divided by the sum of eigenvalues. If
<code>ev_xx=NULL</code> (the default), the constant u is chosen by maximising the
contrast of the correlation matrix.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_scale_ev">scale_ev</code></td>
<td>
<p>logical indicating if the proportion of explained variance by
PC1 should be computed from the correlation (<code>scale_ev=TRUE</code>) or
covariance (<code>scale_ev=FALSE</code>) matrix. If <code>scale_ev=TRUE</code>, the
correlation matrix is used as parameter of the multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_u_list">u_list</code></td>
<td>
<p>vector with two numeric values defining the range of values to
explore for constant u.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_tol">tol</code></td>
<td>
<p>accuracy for the search of parameter u as defined in
<code><a href="stats.html#topic+optimise">optimise</a></code>.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_scale">scale</code></td>
<td>
<p>logical indicating if the true mean is zero and true variance is
one for all simulated variables. The observed mean and variance may be
slightly off by chance.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_output_matrices">output_matrices</code></td>
<td>
<p>logical indicating if the true precision and (partial)
correlation matrices should be included in the output.</p>
</td></tr>
<tr><td><code id="SimulateGraphical_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the graph simulation function
provided in <code>implementation</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is done in two steps with (i) generation of a graph,
and (ii) sampling from multivariate Normal distribution for which nonzero
entries in the partial correlation matrix correspond to the edges of the
simulated graph. This procedure ensures that the conditional independence
structure between the variables corresponds to the simulated graph.
</p>
<p>Step 1 is done using <code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a></code>.
</p>
<p>In Step 2, the precision matrix (inverse of the covariance matrix) is
simulated using <code><a href="#topic+SimulatePrecision">SimulatePrecision</a></code> so that (i) its nonzero
entries correspond to edges in the graph simulated in Step 1, and (ii) it
is positive definite (see <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>). The inverse
of the precision matrix is used as covariance matrix to simulate data from
a multivariate Normal distribution.
</p>
<p>The outputs of this function can be used to evaluate the ability of a
graphical model to recover the conditional independence structure.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>simulated data with <code>n</code> observation and
<code>sum(pk)</code> variables.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>adjacency matrix of the simulated
graph.</p>
</td></tr> <tr><td><code>omega</code></td>
<td>
<p>simulated (true) precision matrix. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>phi</code></td>
<td>
<p>simulated (true) partial
correlation matrix. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>simulated (true) covariance matrix. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>u</code></td>
<td>
<p>value of the constant u used for the
simulation of <code>omega</code>. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulatePrecision">SimulatePrecision</a></code>, <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>
</p>
<p>Other simulation functions: 
<code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a>()</code>,
<code><a href="#topic+SimulateClustering">SimulateClustering</a>()</code>,
<code><a href="#topic+SimulateComponents">SimulateComponents</a>()</code>,
<code><a href="#topic+SimulateCorrelation">SimulateCorrelation</a>()</code>,
<code><a href="#topic+SimulateRegression">SimulateRegression</a>()</code>,
<code><a href="#topic+SimulateStructural">SimulateStructural</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
par(mar = rep(7, 4))

# Simulation of random graph with 50 nodes
set.seed(1)
simul &lt;- SimulateGraphical(n = 100, pk = 50, topology = "random", nu_within = 0.05)
print(simul)
plot(simul)

# Simulation of scale-free graph with 20 nodes
set.seed(1)
simul &lt;- SimulateGraphical(n = 100, pk = 20, topology = "scale-free")
plot(simul)

# Extracting true precision/correlation matrices
set.seed(1)
simul &lt;- SimulateGraphical(
  n = 100, pk = 20,
  topology = "scale-free", output_matrices = TRUE
)
str(simul)

# Simulation of multi-block data
set.seed(1)
pk &lt;- c(20, 30)
simul &lt;- SimulateGraphical(
  n = 100, pk = pk,
  pd_strategy = "min_eigenvalue"
)
mycor &lt;- cor(simul$data)
Heatmap(mycor,
  col = c("darkblue", "white", "firebrick3"),
  legend_range = c(-1, 1), legend_length = 50,
  legend = FALSE, axes = FALSE
)
for (i in 1:2) {
  axis(side = i, at = c(0.5, pk[1] - 0.5), labels = NA)
  axis(
    side = i, at = mean(c(0.5, pk[1] - 0.5)),
    labels = ifelse(i == 1, yes = "Group 1", no = "Group 2"),
    tick = FALSE, cex.axis = 1.5
  )
  axis(side = i, at = c(pk[1] + 0.5, sum(pk) - 0.5), labels = NA)
  axis(
    side = i, at = mean(c(pk[1] + 0.5, sum(pk) - 0.5)),
    labels = ifelse(i == 1, yes = "Group 2", no = "Group 1"),
    tick = FALSE, cex.axis = 1.5
  )
}

# User-defined function for graph simulation
CentralNode &lt;- function(pk, hub = 1) {
  theta &lt;- matrix(0, nrow = sum(pk), ncol = sum(pk))
  theta[hub, ] &lt;- 1
  theta[, hub] &lt;- 1
  diag(theta) &lt;- 0
  return(theta)
}
simul &lt;- SimulateGraphical(n = 100, pk = 10, implementation = CentralNode)
plot(simul) # star
simul &lt;- SimulateGraphical(n = 100, pk = 10, implementation = CentralNode, hub = 2)
plot(simul) # variable 2 is the central node

# User-defined adjacency matrix
mytheta &lt;- matrix(c(
  0, 1, 1, 0,
  1, 0, 0, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
), ncol = 4, byrow = TRUE)
simul &lt;- SimulateGraphical(n = 100, theta = mytheta)
plot(simul)

# User-defined adjacency and block structure
simul &lt;- SimulateGraphical(n = 100, theta = mytheta, pk = c(2, 2))
mycor &lt;- cor(simul$data)
Heatmap(mycor,
  col = c("darkblue", "white", "firebrick3"),
  legend_range = c(-1, 1), legend_length = 50, legend = FALSE
)

par(oldpar)

</code></pre>

<hr>
<h2 id='SimulatePrecision'>Simulation of precision matrix</h2><span id='topic+SimulatePrecision'></span>

<h3>Description</h3>

<p>Simulates a sparse precision matrix from a binary adjacency matrix
<code>theta</code> encoding conditional independence in a Gaussian Graphical Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulatePrecision(
  pk = NULL,
  theta,
  v_within = c(0.5, 1),
  v_between = c(0, 0.1),
  v_sign = c(-1, 1),
  continuous = TRUE,
  pd_strategy = "diagonally_dominant",
  ev_xx = NULL,
  scale = TRUE,
  u_list = c(1e-10, 1),
  tol = .Machine$double.eps^0.25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulatePrecision_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group in the simulated
dataset. The number of nodes in the simulated graph is <code>sum(pk)</code>. With
multiple groups, the simulated (partial) correlation matrix has a block
structure, where blocks arise from the integration of the <code>length(pk)</code>
groups. This argument is only used if <code>theta</code> is not provided.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_theta">theta</code></td>
<td>
<p>binary and symmetric adjacency matrix encoding the conditional
independence structure.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_v_within">v_within</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if <code>pd_strategy="min_eigenvalue"</code>. If <code>continuous=FALSE</code>,
<code>v_within</code> is the set of possible precision values. If
<code>continuous=TRUE</code>, <code>v_within</code> is the range of possible precision
values.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_v_between">v_between</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
<code>v_within</code> but for off-diagonal blocks. It is only used if
<code>length(pk)&gt;1</code>.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_v_sign">v_sign</code></td>
<td>
<p>vector of possible signs for precision matrix entries. Possible
inputs are: <code>-1</code> for positive partial correlations, <code>1</code> for
negative partial correlations, or <code>c(-1, 1)</code> for both positive and
negative partial correlations.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
<code>v_within</code> (diagonal blocks) or <code>v_between</code> (off-diagonal blocks)
(if <code>continuous=TRUE</code>) or from proposed values in <code>v_within</code>
(diagonal blocks) or <code>v_between</code> (off-diagonal blocks) (if
<code>continuous=FALSE</code>).</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_pd_strategy">pd_strategy</code></td>
<td>
<p>method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). If
<code>pd_strategy="diagonally_dominant"</code>, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. If
<code>pd_strategy="min_eigenvalue"</code>, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue of the precision matrix with
zeros on the diagonal and a constant u.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_ev_xx">ev_xx</code></td>
<td>
<p>expected proportion of explained variance by the first Principal
Component (PC1) of a Principal Component Analysis. This is the largest
eigenvalue of the correlation (if <code>scale_ev=TRUE</code>) or covariance (if
<code>scale_ev=FALSE</code>) matrix divided by the sum of eigenvalues. If
<code>ev_xx=NULL</code> (the default), the constant u is chosen by maximising the
contrast of the correlation matrix.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_scale">scale</code></td>
<td>
<p>logical indicating if the proportion of explained variance by
PC1 should be computed from the correlation (<code>scale=TRUE</code>) or
covariance (<code>scale=FALSE</code>) matrix.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_u_list">u_list</code></td>
<td>
<p>vector with two numeric values defining the range of values to
explore for constant u.</p>
</td></tr>
<tr><td><code id="SimulatePrecision_+3A_tol">tol</code></td>
<td>
<p>accuracy for the search of parameter u as defined in
<code><a href="stats.html#topic+optimise">optimise</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entries that are equal to zero in the adjacency matrix <code>theta</code>
are also equal to zero in the generated precision matrix. These zero
entries indicate conditional independence between the corresponding pair of
variables (see <code><a href="#topic+SimulateGraphical">SimulateGraphical</a></code>).
</p>
<p>Argument <code>pk</code> can be specified to create groups of variables and allow
for nonzero precision entries to be sampled from different distributions
between two variables belonging to the same group or to different groups.
</p>
<p>If <code>continuous=FALSE</code>, nonzero off-diagonal entries of the precision
matrix are sampled from a discrete uniform distribution taking values in
<code>v_within</code> (for entries in the diagonal block) or <code>v_between</code>
(for entries in off-diagonal blocks). If <code>continuous=TRUE</code>, nonzero
off-diagonal entries are sampled from a continuous uniform distribution
taking values in the range given by <code>v_within</code> or <code>v_between</code>.
</p>
<p>Diagonal entries of the precision matrix are defined to ensure positive
definiteness as described in <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>.
</p>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>omega</code></td>
<td>
<p>true simulated precision matrix.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>value of the constant u used to ensure that <code>omega</code> is
positive definite.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulateGraphical">SimulateGraphical</a></code>, <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of an adjacency matrix
theta &lt;- SimulateAdjacency(pk = c(5, 5), nu_within = 0.7)
print(theta)

# Simulation of a precision matrix maximising the contrast
simul &lt;- SimulatePrecision(theta = theta)
print(simul$omega)

# Simulation of a precision matrix with specific ev by PC1
simul &lt;- SimulatePrecision(
  theta = theta,
  pd_strategy = "min_eigenvalue",
  ev_xx = 0.3, scale = TRUE
)
print(simul$omega)
</code></pre>

<hr>
<h2 id='SimulateRegression'>Data simulation for multivariate regression</h2><span id='topic+SimulateRegression'></span>

<h3>Description</h3>

<p>Simulates data with outcome(s) and predictors, where only a subset of the
predictors actually contributes to the definition of the outcome(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateRegression(
  n = 100,
  pk = 10,
  xdata = NULL,
  family = "gaussian",
  q = 1,
  theta = NULL,
  nu_xy = 0.2,
  beta_abs = c(0.1, 1),
  beta_sign = c(-1, 1),
  continuous = TRUE,
  ev_xy = 0.7
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateRegression_+3A_n">n</code></td>
<td>
<p>number of observations in the simulated dataset. Not used if
<code>xdata</code> is provided.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_pk">pk</code></td>
<td>
<p>number of predictor variables. A subset of these variables
contribute to the outcome definition (see argument <code>nu_xy</code>). Not used
if <code>xdata</code> is provided.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_xdata">xdata</code></td>
<td>
<p>optional data matrix for the predictors with variables as
columns and observations as rows. A subset of these variables contribute to
the outcome definition (see argument <code>nu_xy</code>).</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_family">family</code></td>
<td>
<p>type of regression model. Possible values include
<code>"gaussian"</code> for continuous outcome(s) or <code>"binomial"</code> for binary
outcome(s).</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_q">q</code></td>
<td>
<p>number of outcome variables.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_theta">theta</code></td>
<td>
<p>binary matrix with as many rows as predictors and as many
columns as outcomes. A nonzero entry on row <code class="reqn">i</code> and column <code class="reqn">j</code>
indicates that predictor <code class="reqn">i</code> contributes to the definition of outcome
<code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_nu_xy">nu_xy</code></td>
<td>
<p>vector of length <code>q</code> with expected proportion of predictors
contributing to the definition of each of the <code>q</code> outcomes.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_beta_abs">beta_abs</code></td>
<td>
<p>vector defining the range of nonzero regression coefficients
in absolute values. If <code>continuous=FALSE</code>, <code>beta_abs</code> is the set
of possible precision values. If <code>continuous=TRUE</code>, <code>beta_abs</code> is
the range of possible precision values. Note that regression coefficients
are re-scaled if <code>family="binomial"</code> to ensure that the desired
concordance statistic can be achieved (see argument <code>ev_xy</code>) so they
may not be in this range.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_beta_sign">beta_sign</code></td>
<td>
<p>vector of possible signs for regression coefficients.
Possible inputs are: <code>1</code> for positive coefficients, <code>-1</code> for
negative coefficients, or <code>c(-1, 1)</code> for both positive and negative
coefficients.</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample regression
coefficients from a uniform distribution between the minimum and maximum
values in <code>beta_abs</code> (if <code>continuous=TRUE</code>) or from proposed
values in <code>beta_abs</code> (if <code>continuous=FALSE</code>).</p>
</td></tr>
<tr><td><code id="SimulateRegression_+3A_ev_xy">ev_xy</code></td>
<td>
<p>vector of length <code>q</code> with expected goodness of fit measures
for each of the <code>q</code> outcomes. If <code>family="gaussian"</code>, the vector
contains expected proportions of variance in each of the <code>q</code> outcomes
that can be explained by the predictors. If <code>family="binomial"</code>, the
vector contains expected concordance statistics (i.e. area under the ROC
curve) given the true probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>xdata</code></td>
<td>
<p>input or simulated predictor data.</p>
</td></tr>
<tr><td><code>ydata</code></td>
<td>
<p>simulated outcome data.</p>
</td></tr> <tr><td><code>beta</code></td>
<td>
<p>matrix of true beta
coefficients used to generate outcomes in <code>ydata</code> from predictors in
<code>xdata</code>.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>binary matrix indicating the predictors from
<code>xdata</code> contributing to the definition of each of the outcome
variables in <code>ydata</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bodinier B, Filippi S, Nost TH, Chiquet J, Chadeau-Hyam M (2021).
&ldquo;Automated calibration for stability selection in penalised regression and graphical models: a multi-OMICs network application exploring the molecular response to tobacco smoking.&rdquo;
<a href="https://arxiv.org/abs/2106.02521">https://arxiv.org/abs/2106.02521</a>.
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a>()</code>,
<code><a href="#topic+SimulateClustering">SimulateClustering</a>()</code>,
<code><a href="#topic+SimulateComponents">SimulateComponents</a>()</code>,
<code><a href="#topic+SimulateCorrelation">SimulateCorrelation</a>()</code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a>()</code>,
<code><a href="#topic+SimulateStructural">SimulateStructural</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Independent predictors

# Univariate continuous outcome
set.seed(1)
simul &lt;- SimulateRegression(pk = 15)
summary(simul)

# Univariate binary outcome
set.seed(1)
simul &lt;- SimulateRegression(pk = 15, family = "binomial")
table(simul$ydata)

# Multiple continuous outcomes
set.seed(1)
simul &lt;- SimulateRegression(pk = 15, q = 3)
summary(simul)


## Blocks of correlated predictors

# Simulation of predictor data
set.seed(1)
xsimul &lt;- SimulateGraphical(pk = rep(5, 3), nu_within = 0.8, nu_between = 0, v_sign = -1)
Heatmap(cor(xsimul$data),
  legend_range = c(-1, 1),
  col = c("navy", "white", "darkred")
)

# Simulation of outcome data
simul &lt;- SimulateRegression(xdata = xsimul$data)
print(simul)
summary(simul)


## Choosing expected proportion of explained variance

# Data simulation
set.seed(1)
simul &lt;- SimulateRegression(n = 1000, pk = 15, q = 3, ev_xy = c(0.9, 0.5, 0.2))
summary(simul)

# Comparing with estimated proportion of explained variance
summary(lm(simul$ydata[, 1] ~ simul$xdata))
summary(lm(simul$ydata[, 2] ~ simul$xdata))
summary(lm(simul$ydata[, 3] ~ simul$xdata))


## Choosing expected concordance (AUC)

# Data simulation
set.seed(1)
simul &lt;- SimulateRegression(
  n = 500, pk = 10,
  family = "binomial", ev_xy = 0.9
)

# Comparing with estimated concordance
fitted &lt;- glm(simul$ydata ~ simul$xdata,
  family = "binomial"
)$fitted.values
Concordance(observed = simul$ydata, predicted = fitted)

</code></pre>

<hr>
<h2 id='SimulateStructural'>Data simulation for Structural Causal Modelling</h2><span id='topic+SimulateStructural'></span>

<h3>Description</h3>

<p>Simulates data from a multivariate Normal distribution where relationships
between the variables correspond to a Structural Causal Model (SCM). To
ensure that the generated SCM is identifiable, the nodes are organised by
layers, with no causal effects within layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateStructural(
  n = 100,
  pk = c(5, 5, 5),
  theta = NULL,
  n_manifest = NULL,
  nu_between = 0.5,
  v_between = c(0.5, 1),
  v_sign = c(-1, 1),
  continuous = TRUE,
  ev = 0.5,
  ev_manifest = 0.8,
  output_matrices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateStructural_+3A_n">n</code></td>
<td>
<p>number of observations in the simulated dataset.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_pk">pk</code></td>
<td>
<p>vector of the number of (latent) variables per layer.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_theta">theta</code></td>
<td>
<p>optional binary adjacency matrix of the Directed Acyclic Graph
(DAG) of causal relationships. This DAG must have a structure with layers
so that a variable can only be a parent of variable in one of the following
layers (see <code><a href="#topic+LayeredDAG">LayeredDAG</a></code> for examples). The layers must be
provided in <code>pk</code>.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_n_manifest">n_manifest</code></td>
<td>
<p>vector of the number of manifest (observed) variables
measuring each of the latent variables. If <code>n_manifest=NULL</code>, there
are <code>sum(pk)</code> manifest variables and no latent variables. Otherwise,
there are <code>sum(pk)</code> latent variables and <code>sum(n_manifest)</code>
manifest variables. All entries of <code>n_manifest</code> must be strictly
positive.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_nu_between">nu_between</code></td>
<td>
<p>probability of having an edge between two nodes belonging
to different layers, as defined in <code>pk</code>. If <code>length(pk)=1</code>, this
is the expected density of the graph.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_v_between">v_between</code></td>
<td>
<p>vector defining the (range of) nonzero path coefficients. If
<code>continuous=FALSE</code>, <code>v_between</code> is the set of possible values. If
<code>continuous=TRUE</code>, <code>v_between</code> is the range of possible values.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_v_sign">v_sign</code></td>
<td>
<p>vector of possible signs for path coefficients. Possible inputs
are: <code>1</code> for positive coefficients, <code>-1</code> for negative
coefficients, or <code>c(-1, 1)</code> for both positive and negative
coefficients.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample path coefficients from
a uniform distribution between the minimum and maximum values in
<code>v_between</code> (if <code>continuous=FALSE</code>) or from proposed values in
<code>v_between</code> (if <code>continuous=FALSE</code>).</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_ev">ev</code></td>
<td>
<p>vector of proportions of variance in each of the (latent) variables
that can be explained by its parents. If there are no latent variables (if
<code>n_manifest=NULL</code>), these are the proportions of explained variances
in the manifest variables. Otherwise (if <code>n_manifest</code> is provided),
these are the proportions of explained variances in the latent variables.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_ev_manifest">ev_manifest</code></td>
<td>
<p>vector of proportions of variance in each of the manifest
variable that can be explained by its latent parent. Only used if
<code>n_manifest</code> is provided.</p>
</td></tr>
<tr><td><code id="SimulateStructural_+3A_output_matrices">output_matrices</code></td>
<td>
<p>logical indicating if the true path coefficients,
residual variances, and precision and (partial) correlation matrices should
be included in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with: </p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>simulated data with <code>n</code> observations
for manifest variables.</p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p>adjacency matrix of the simulated
Directed Acyclic Graph encoding causal relationships.</p>
</td></tr>
<tr><td><code>Amat</code></td>
<td>
<p>simulated (true) asymmetric matrix A in RAM notation. Only
returned if <code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>Smat</code></td>
<td>
<p>simulated (true)
symmetric matrix S in RAM notation. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr> <tr><td><code>Fmat</code></td>
<td>
<p>simulated (true) filter matrix F
in RAM notation. Only returned if <code>output_matrices=TRUE</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>simulated (true) covariance matrix. Only returned if
<code>output_matrices=TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jacobucci R, Grimm KJ, McArdle JJ (2016).
&ldquo;Regularized structural equation modeling.&rdquo;
<em>Structural equation modeling: a multidisciplinary journal</em>, <b>23</b>(4), 555&ndash;566.
<a href="https://doi.org/10.1080/10705511.2016.1154793">doi:10.1080/10705511.2016.1154793</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulatePrecision">SimulatePrecision</a></code>, <code><a href="#topic+MakePositiveDefinite">MakePositiveDefinite</a></code>,
<code><a href="#topic+Contrast">Contrast</a></code>
</p>
<p>Other simulation functions: 
<code><a href="#topic+SimulateAdjacency">SimulateAdjacency</a>()</code>,
<code><a href="#topic+SimulateClustering">SimulateClustering</a>()</code>,
<code><a href="#topic+SimulateComponents">SimulateComponents</a>()</code>,
<code><a href="#topic+SimulateCorrelation">SimulateCorrelation</a>()</code>,
<code><a href="#topic+SimulateGraphical">SimulateGraphical</a>()</code>,
<code><a href="#topic+SimulateRegression">SimulateRegression</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulation of a layered SCM
set.seed(1)
pk &lt;- c(3, 5, 4)
simul &lt;- SimulateStructural(n = 100, pk = pk)
print(simul)
summary(simul)
plot(simul)

# Choosing the proportions of explained variances for endogenous variables
set.seed(1)
simul &lt;- SimulateStructural(
  n = 1000,
  pk = c(2, 3),
  nu_between = 1,
  ev = c(NA, NA, 0.5, 0.7, 0.9),
  output_matrices = TRUE
)

# Checking expected proportions of explained variances
1 - simul$Smat["x3", "x3"] / simul$sigma["x3", "x3"]
1 - simul$Smat["x4", "x4"] / simul$sigma["x4", "x4"]
1 - simul$Smat["x5", "x5"] / simul$sigma["x5", "x5"]

# Checking observed proportions of explained variances (R-squared)
summary(lm(simul$data[, 3] ~ simul$data[, which(simul$theta[, 3] != 0)]))
summary(lm(simul$data[, 4] ~ simul$data[, which(simul$theta[, 4] != 0)]))
summary(lm(simul$data[, 5] ~ simul$data[, which(simul$theta[, 5] != 0)]))

# Simulation including latent and manifest variables
set.seed(1)
simul &lt;- SimulateStructural(
  n = 100,
  pk = c(2, 3),
  n_manifest = c(2, 3, 2, 1, 2)
)
plot(simul)

# Showing manifest variables in red
if (requireNamespace("igraph", quietly = TRUE)) {
  mygraph &lt;- plot(simul)
  ids &lt;- which(igraph::V(mygraph)$name %in% colnames(simul$data))
  igraph::V(mygraph)$color[ids] &lt;- "red"
  igraph::V(mygraph)$frame.color[ids] &lt;- "red"
  plot(mygraph)
}

# Choosing proportions of explained variances for latent and manifest variables
set.seed(1)
simul &lt;- SimulateStructural(
  n = 100,
  pk = c(3, 2),
  n_manifest = c(2, 3, 2, 1, 2),
  ev = c(NA, NA, NA, 0.7, 0.9),
  ev_manifest = 0.8,
  output_matrices = TRUE
)
plot(simul)

# Checking expected proportions of explained variances
(simul$sigma_full["f4", "f4"] - simul$Smat["f4", "f4"]) / simul$sigma_full["f4", "f4"]
(simul$sigma_full["f5", "f5"] - simul$Smat["f5", "f5"]) / simul$sigma_full["f5", "f5"]
(simul$sigma_full["x1", "x1"] - simul$Smat["x1", "x1"]) / simul$sigma_full["x1", "x1"]

</code></pre>

<hr>
<h2 id='SimulateSymmetricMatrix'>Simulation of symmetric matrix with block structure</h2><span id='topic+SimulateSymmetricMatrix'></span>

<h3>Description</h3>

<p>Simulates a symmetric matrix with block structure. If
<code>continuous=FALSE</code>, matrix entries are sampled from a discrete uniform
distribution taking values in <code>v_within</code> (for entries in the diagonal
block) or <code>v_between</code> (for entries in off-diagonal blocks). If
<code>continuous=TRUE</code>, entries are sampled from a continuous uniform
distribution taking values in the range given by <code>v_within</code> or
<code>v_between</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateSymmetricMatrix(
  pk = 10,
  v_within = c(0.5, 1),
  v_between = c(0, 0.1),
  v_sign = c(-1, 1),
  continuous = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimulateSymmetricMatrix_+3A_pk">pk</code></td>
<td>
<p>vector of the number of variables per group, defining the block
structure.</p>
</td></tr>
<tr><td><code id="SimulateSymmetricMatrix_+3A_v_within">v_within</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
diagonal blocks. If <code>continuous=FALSE</code>, <code>v_within</code> is the set of
possible values. If <code>continuous=FALSE</code>, <code>v_within</code> is the range
of possible values.</p>
</td></tr>
<tr><td><code id="SimulateSymmetricMatrix_+3A_v_between">v_between</code></td>
<td>
<p>vector defining the (range of) nonzero entries in the
off-diagonal blocks. If <code>continuous=FALSE</code>, <code>v_between</code> is the
set of possible precision values. If <code>continuous=FALSE</code>,
<code>v_between</code> is the range of possible precision values. This argument
is only used if <code>length(pk)&gt;1</code>.</p>
</td></tr>
<tr><td><code id="SimulateSymmetricMatrix_+3A_v_sign">v_sign</code></td>
<td>
<p>vector of possible signs for matrix entries. Possible inputs
are: <code>-1</code> for negative entries only, <code>1</code> for positive entries
only, or <code>c(-1, 1)</code> for both positive and negative entries.</p>
</td></tr>
<tr><td><code id="SimulateSymmetricMatrix_+3A_continuous">continuous</code></td>
<td>
<p>logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
<code>v_within</code> (diagonal blocks) or <code>v_between</code> (off-diagonal blocks)
(<code>continuous=TRUE</code>) or from proposed values in <code>v_within</code>
(diagonal blocks) or <code>v_between</code> (off-diagonal blocks)
(<code>continuous=FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix with uniformly distributed entries sampled from
different distributions for diagonal and off-diagonal blocks.
</p>

<hr>
<h2 id='TuneCStatisticLogit'>Tuning function (logistic regression)</h2><span id='topic+TuneCStatisticLogit'></span>

<h3>Description</h3>

<p>Computes the difference in absolute value between the desired and expected C
statistic given the vector of true probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TuneCStatisticLogit(scaling_factor, crude_log_odds, auc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TuneCStatisticLogit_+3A_scaling_factor">scaling_factor</code></td>
<td>
<p>constant by which log-odds (or beta coefficients when
there is no intercept) are multiplied.</p>
</td></tr>
<tr><td><code id="TuneCStatisticLogit_+3A_crude_log_odds">crude_log_odds</code></td>
<td>
<p>vector of log-odds to be multiplied by the
<code>scaling_factor</code>.</p>
</td></tr>
<tr><td><code id="TuneCStatisticLogit_+3A_auc">auc</code></td>
<td>
<p>desired concordance statistic (area under the ROC curve). If
<code>auc=NULL</code>, the obtained concordance statistic is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The absolute difference between desired and expected concordance (if
<code>auc</code> is provided) or expected concordance (if <code>auc=NULL</code>).
</p>

<hr>
<h2 id='TuneExplainedVarianceCor'>Tuning function (correlation)</h2><span id='topic+TuneExplainedVarianceCor'></span>

<h3>Description</h3>

<p>Computes the difference in absolute value between the desired and observed
proportion of explained variance from the first Principal Component of a
Principal Component Analysis applied on the correlation matrix. The precision
matrix is obtained by adding u to the diagonal of a positive semidefinite
matrix. This function is used to find the value of the constant u that
generates a correlation matrix with desired proportion of explained variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TuneExplainedVarianceCor(u, ev_xx = NULL, omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TuneExplainedVarianceCor_+3A_u">u</code></td>
<td>
<p>constant u added to the diagonal of the precision matrix.</p>
</td></tr>
<tr><td><code id="TuneExplainedVarianceCor_+3A_ev_xx">ev_xx</code></td>
<td>
<p>desired proportion of explained variance. If <code>ev_xx=NULL</code>,
the obtained proportion of explained variance is returned.</p>
</td></tr>
<tr><td><code id="TuneExplainedVarianceCor_+3A_omega">omega</code></td>
<td>
<p>positive semidefinite precision matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The absolute difference in proportion of explained variance (if
<code>ev_xx</code> is provided) or observed proportion of explained variance (if
<code>ev_xx=NULL</code>).
</p>

<hr>
<h2 id='TuneExplainedVarianceCov'>Tuning function (covariance)</h2><span id='topic+TuneExplainedVarianceCov'></span>

<h3>Description</h3>

<p>Computes the difference in absolute value between the desired and observed
proportion of explained variance from the first Principal Component of a
Principal Component Analysis applied on the covariance matrix. The precision
matrix is obtained by adding u to the diagonal of a positive semidefinite
matrix. This function is used to find the value of the constant u that
generates a covariance matrix with desired proportion of explained variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TuneExplainedVarianceCov(u, ev_xx = NULL, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TuneExplainedVarianceCov_+3A_u">u</code></td>
<td>
<p>constant u added to the diagonal of the precision matrix.</p>
</td></tr>
<tr><td><code id="TuneExplainedVarianceCov_+3A_ev_xx">ev_xx</code></td>
<td>
<p>desired proportion of explained variance. If <code>ev_xx=NULL</code>,
the obtained proportion of explained variance is returned.</p>
</td></tr>
<tr><td><code id="TuneExplainedVarianceCov_+3A_lambda">lambda</code></td>
<td>
<p>eigenvalues of the positive semidefinite precision matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The absolute difference in proportion of explained variance (if
<code>ev_xx</code> is provided) or observed proportion of explained variance (if
<code>ev_xx=NULL</code>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
