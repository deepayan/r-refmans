<!DOCTYPE html><html><head><title>Help for package swdft</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {swdft}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coefficients.swdft_mod'><p>Coefficients method for swdft_cosreg objects</p></a></li>
<li><a href='#complex_demod'><p>Complex Demodulation</p></a></li>
<li><a href='#cosine'><p>Cosine signal with adjustable parameters</p></a></li>
<li><a href='#cosine_taper'><p>Cosine bell data taper</p></a></li>
<li><a href='#cosreg'><p>Cosine regression</p></a></li>
<li><a href='#cov_swdft_cnum'><p>Covariance between two complex-numbered outputs</p></a></li>
<li><a href='#demod_swdft'><p>Demodulate a Fourier Frequency with the SWDFT</p></a></li>
<li><a href='#dirichlet'><p>Dirichlet Kernel (Weight) for arbitrary summation indices</p></a></li>
<li><a href='#dirichlet_kernel'><p>Dirichlet Kernel</p></a></li>
<li><a href='#fitted.swdft_mod'><p>Fitted values method for swdft_cosreg objects</p></a></li>
<li><a href='#get_aphi'><p>Extract amplitude and phase</p></a></li>
<li><a href='#get_freq_range'><p>Get range of frequencies to search</p></a></li>
<li><a href='#get_loglik'><p>Compute the log likelihood</p></a></li>
<li><a href='#get_max_freq'><p>Get the maximum DFT coefficient</p></a></li>
<li><a href='#get_p_range'><p>Get range of P's to search</p></a></li>
<li><a href='#get_sigma'><p>Extract estimator of sigma</p></a></li>
<li><a href='#get_sl'><p>Extract signal parameters</p></a></li>
<li><a href='#get_taper'><p>Create taper for the SWDFT</p></a></li>
<li><a href='#lcr_loglik'><p>Log Likelihood</p></a></li>
<li><a href='#local_cosreg'><p>Local cosine regression</p></a></li>
<li><a href='#local_signal'><p>Local Periodic Signal</p></a></li>
<li><a href='#matching_demod'><p>Matching Demodulation</p></a></li>
<li><a href='#moving_average'><p>Simple high pass filter</p></a></li>
<li><a href='#new_swdft'><p>Constructor function for class 'swdft'</p></a></li>
<li><a href='#new_swdft_cosreg'><p>Constructor function for class swdft_mod</p></a></li>
<li><a href='#new_swdft_demod'><p>Constructor function for class 'swdft_demod'</p></a></li>
<li><a href='#new_swdft_local_cosreg'><p>Constructor function for class 'swdft_local_cosreg'</p></a></li>
<li><a href='#new_swdft_matching_demod'><p>Constructor function for class 'swdft_matching_demod'</p></a></li>
<li><a href='#new_swdft2d'><p>Constructor function for class 'swdft2d'</p></a></li>
<li><a href='#new_swdft3d'><p>Constructor function for class 'swdft3d'</p></a></li>
<li><a href='#plot.swdft'><p>Plot method for 'swdft' object</p></a></li>
<li><a href='#plot.swdft_mod'><p>Plot method for swdft_mod object</p></a></li>
<li><a href='#prou'><p>The principal nth root of unity</p></a></li>
<li><a href='#residuals.swdft_mod'><p>Residuals method for swdft_cosreg objects</p></a></li>
<li><a href='#sine'><p>Sine signal with adjustable parameters</p></a></li>
<li><a href='#smooth_pgram'><p>Smooth SWDFT coefficients with a convolution</p></a></li>
<li><a href='#smooth_swdft'><p>Smooth the SWDFT coefficients</p></a></li>
<li><a href='#swdft'><p>Sliding Window Discrete Fourier Transform</p></a></li>
<li><a href='#swdft_base_3d'><p>3D SWDFT using base R</p></a></li>
<li><a href='#swdft_fft'><p>Sliding Window Discrete Fourier Transform with base R</p></a></li>
<li><a href='#swdft_fftw'><p>Sliding Window Discrete Fourier Transform using fftw</p></a></li>
<li><a href='#swdft_to_props'><p>Convert the SWDFT to proportions of frequency</p></a></li>
<li><a href='#swdft2d'><p>2D Sliding Window Discrete Fourier Transform</p></a></li>
<li><a href='#swdft2d_fft'><p>2D Sliding Window Discrete Fourier Transform using base R</p></a></li>
<li><a href='#swdft2d_fftw'><p>2D Sliding Window Discrete Fourier Transform using fftw</p></a></li>
<li><a href='#swdft3d'><p>3D Sliding Window Discrete Fourier Transform</p></a></li>
<li><a href='#unwrap_phase'><p>Phase unwrapping</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sliding Window Discrete Fourier Transform (SWDFT)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Sliding Window Discrete Fourier Transform (SWDFT). Also provides 
             statistical methods based on the SWDFT, and graphical tools to display the outputs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fftwtools, fields, signal, nloptr, knitr,
rmarkdown, devtools</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-16 23:32:05 UTC; lee</td>
</tr>
<tr>
<td>Author:</td>
<td>Lee F. Richardson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lee F. Richardson &lt;leerichardson2013@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-17 04:22:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='coefficients.swdft_mod'>Coefficients method for swdft_cosreg objects</h2><span id='topic+coefficients.swdft_mod'></span>

<h3>Description</h3>

<p>Coefficients method for swdft_cosreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swdft_mod'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coefficients.swdft_mod_+3A_object">object</code></td>
<td>
<p>A swdft_cosreg object</p>
</td></tr>
<tr><td><code id="coefficients.swdft_mod_+3A_...">...</code></td>
<td>
<p>optional arguments to match generic function</p>
</td></tr>
</table>

<hr>
<h2 id='complex_demod'>Complex Demodulation</h2><span id='topic+complex_demod'></span>

<h3>Description</h3>

<p>Complex Demodulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complex_demod(x, f0, smooth = "butterworth", order = 5,
  passfreq = 0.1, match_swdft = FALSE, window_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex_demod_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="complex_demod_+3A_f0">f0</code></td>
<td>
<p>numeric scalar. Frequency to demodulate</p>
</td></tr>
<tr><td><code id="complex_demod_+3A_smooth">smooth</code></td>
<td>
<p>character. Type of smoothing to use, accepts either 'ma', 'double_ma',
or 'butterworth' (the default)</p>
</td></tr>
<tr><td><code id="complex_demod_+3A_order">order</code></td>
<td>
<p>moving average parameter if 'smooth' argument equals 'ma' or 'double_ma'. Defaults to 5</p>
</td></tr>
<tr><td><code id="complex_demod_+3A_passfreq">passfreq</code></td>
<td>
<p>numeric scalar. Pass frequency used in butterworth low-pass filter. Defaults to .1
which corresponds to a pass frequency of 2 * f0.</p>
</td></tr>
<tr><td><code id="complex_demod_+3A_match_swdft">match_swdft</code></td>
<td>
<p>logical. Only used to demonstrate equivalence w/ SWDFT when
a moving average filter is used. Otherwise, never used.</p>
</td></tr>
<tr><td><code id="complex_demod_+3A_window_size">window_size</code></td>
<td>
<p>defaults to NULL, only used when match_swdft=TRUE, so can ignore.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 'swdft_demod' object. See ?new_swdft_matching_demod for details.
</p>


<h3>References</h3>

<p>Chapter 7 of 'Fourier Analysis of Time-Series' by Peter Bloomfield and this
blog post: https://dankelley.github.io/r/2014/02/17/demodulation.html for the idea of using
a butterworth filter.
</p>

<hr>
<h2 id='cosine'>Cosine signal with adjustable parameters</h2><span id='topic+cosine'></span>

<h3>Description</h3>

<p>Cosine signal with adjustable parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine(N, A = 1, Fr = 1, phase = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine_+3A_n">N</code></td>
<td>
<p>signal length</p>
</td></tr>
<tr><td><code id="cosine_+3A_a">A</code></td>
<td>
<p>Amplitude</p>
</td></tr>
<tr><td><code id="cosine_+3A_fr">Fr</code></td>
<td>
<p>Frequency: Number of cycles in a length N period</p>
</td></tr>
<tr><td><code id="cosine_+3A_phase">phase</code></td>
<td>
<p>phase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with cosine function of x
</p>

<hr>
<h2 id='cosine_taper'>Cosine bell data taper</h2><span id='topic+cosine_taper'></span>

<h3>Description</h3>

<p>Cosine bell data taper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine_taper(n, p = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine_taper_+3A_n">n</code></td>
<td>
<p>length of time-series to taper</p>
</td></tr>
<tr><td><code id="cosine_taper_+3A_p">p</code></td>
<td>
<p>proportion of ends to taper</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length n cosine bell taper w/ proportion p
</p>

<hr>
<h2 id='cosreg'>Cosine regression</h2><span id='topic+cosreg'></span>

<h3>Description</h3>

<p>Cosine regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosreg(x, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosreg_+3A_x">x</code></td>
<td>
<p>numeric. Signal.</p>
</td></tr>
<tr><td><code id="cosreg_+3A_f">f</code></td>
<td>
<p>numeric. scalar or vector of frequencies to fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object of class 'swdft_cosreg'. See ?new_swdft_cosreg for details.
</p>

<hr>
<h2 id='cov_swdft_cnum'>Covariance between two complex-numbered outputs</h2><span id='topic+cov_swdft_cnum'></span>

<h3>Description</h3>

<p>Covariance between two complex-numbered outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_swdft_cnum(k, l, delta, n, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_swdft_cnum_+3A_k">k</code></td>
<td>
<p>frequency of first coefficient</p>
</td></tr>
<tr><td><code id="cov_swdft_cnum_+3A_l">l</code></td>
<td>
<p>frequency of second coefficient</p>
</td></tr>
<tr><td><code id="cov_swdft_cnum_+3A_delta">delta</code></td>
<td>
<p>window position shift of second coefficient</p>
</td></tr>
<tr><td><code id="cov_swdft_cnum_+3A_n">n</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="cov_swdft_cnum_+3A_sigma">sigma</code></td>
<td>
<p>white noise standard error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>complex-valued number of the covariance
</p>

<hr>
<h2 id='demod_swdft'>Demodulate a Fourier Frequency with the SWDFT</h2><span id='topic+demod_swdft'></span>

<h3>Description</h3>

<p>Demodulate a Fourier Frequency with the SWDFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demod_swdft(a, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demod_swdft_+3A_a">a</code></td>
<td>
<p>swdft</p>
</td></tr>
<tr><td><code id="demod_swdft_+3A_k">k</code></td>
<td>
<p>frequency to demodulate</p>
</td></tr>
</table>

<hr>
<h2 id='dirichlet'>Dirichlet Kernel (Weight) for arbitrary summation indices</h2><span id='topic+dirichlet'></span>

<h3>Description</h3>

<p>Dirichlet Kernel (Weight) for arbitrary summation indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirichlet(x, phase = 0, a = 0, b = length(x) - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet_+3A_x">x</code></td>
<td>
<p>numeric to evaluate</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_phase">phase</code></td>
<td>
<p>defaults to 0</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_a">a</code></td>
<td>
<p>start of summation index</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_b">b</code></td>
<td>
<p>end of summation index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum of a complex exponential sum
</p>

<hr>
<h2 id='dirichlet_kernel'>Dirichlet Kernel</h2><span id='topic+dirichlet_kernel'></span>

<h3>Description</h3>

<p>Dirichlet Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirichlet_kernel(x, n, dw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet_kernel_+3A_x">x</code></td>
<td>
<p>variable evaluated by dirichlet kernel</p>
</td></tr>
<tr><td><code id="dirichlet_kernel_+3A_n">n</code></td>
<td>
<p>size of Dirichlet kernel</p>
</td></tr>
<tr><td><code id="dirichlet_kernel_+3A_dw">dw</code></td>
<td>
<p>logical whether to add the Dirichlet Weight (DW) factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluation of the Dirichlet Kernel (D_n(x))
</p>

<hr>
<h2 id='fitted.swdft_mod'>Fitted values method for swdft_cosreg objects</h2><span id='topic+fitted.swdft_mod'></span>

<h3>Description</h3>

<p>Fitted values method for swdft_cosreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swdft_mod'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.swdft_mod_+3A_object">object</code></td>
<td>
<p>A swdft_cosreg object</p>
</td></tr>
<tr><td><code id="fitted.swdft_mod_+3A_...">...</code></td>
<td>
<p>optional arguments to match generic function</p>
</td></tr>
</table>

<hr>
<h2 id='get_aphi'>Extract amplitude and phase</h2><span id='topic+get_aphi'></span>

<h3>Description</h3>

<p>Extract amplitude and phase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_aphi(x, S, L, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_aphi_+3A_x">x</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="get_aphi_+3A_s">S</code></td>
<td>
<p>start parameter</p>
</td></tr>
<tr><td><code id="get_aphi_+3A_l">L</code></td>
<td>
<p>length pe</p>
</td></tr>
<tr><td><code id="get_aphi_+3A_f">f</code></td>
<td>
<p>frequency</p>
</td></tr>
</table>

<hr>
<h2 id='get_freq_range'>Get range of frequencies to search</h2><span id='topic+get_freq_range'></span>

<h3>Description</h3>

<p>Get range of frequencies to search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_freq_range(a, kwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_freq_range_+3A_a">a</code></td>
<td>
<p>2D complex-valued array. The SWDFT to search</p>
</td></tr>
<tr><td><code id="get_freq_range_+3A_kwidth">kwidth</code></td>
<td>
<p>integer. the width of frequencies to search</p>
</td></tr>
</table>

<hr>
<h2 id='get_loglik'>Compute the log likelihood</h2><span id='topic+get_loglik'></span>

<h3>Description</h3>

<p>Compute the log likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_loglik(x, fitted, sigma, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_loglik_+3A_x">x</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="get_loglik_+3A_fitted">fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code id="get_loglik_+3A_sigma">sigma</code></td>
<td>
<p>estimated standard deviation</p>
</td></tr>
<tr><td><code id="get_loglik_+3A_n">N</code></td>
<td>
<p>length of x</p>
</td></tr>
</table>

<hr>
<h2 id='get_max_freq'>Get the maximum DFT coefficient</h2><span id='topic+get_max_freq'></span>

<h3>Description</h3>

<p>Get the maximum DFT coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_max_freq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_max_freq_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric of largest frequency. Will be between 0 and .5
</p>

<hr>
<h2 id='get_p_range'>Get range of P's to search</h2><span id='topic+get_p_range'></span>

<h3>Description</h3>

<p>Get range of P's to search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p_range(phat, n, N, pwidth, type = "around_max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_p_range_+3A_phat">phat</code></td>
<td>
<p>integer. Window position with largest SWDFT coefficient</p>
</td></tr>
<tr><td><code id="get_p_range_+3A_n">n</code></td>
<td>
<p>integer. window size</p>
</td></tr>
<tr><td><code id="get_p_range_+3A_n">N</code></td>
<td>
<p>integer. Signal length</p>
</td></tr>
<tr><td><code id="get_p_range_+3A_pwidth">pwidth</code></td>
<td>
<p>integer. the range of window positions to search for each window size</p>
</td></tr>
<tr><td><code id="get_p_range_+3A_type">type</code></td>
<td>
<p>character. either 'around max' or 'fullp'.</p>
</td></tr>
</table>

<hr>
<h2 id='get_sigma'>Extract estimator of sigma</h2><span id='topic+get_sigma'></span>

<h3>Description</h3>

<p>Extract estimator of sigma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sigma(x, fitted, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sigma_+3A_x">x</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_fitted">fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code id="get_sigma_+3A_n">N</code></td>
<td>
<p>length of x</p>
</td></tr>
</table>

<hr>
<h2 id='get_sl'>Extract signal parameters</h2><span id='topic+get_sl'></span>

<h3>Description</h3>

<p>Extract signal parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sl(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sl_+3A_n">n</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="get_sl_+3A_p">p</code></td>
<td>
<p>window position</p>
</td></tr>
</table>

<hr>
<h2 id='get_taper'>Create taper for the SWDFT</h2><span id='topic+get_taper'></span>

<h3>Description</h3>

<p>Create taper for the SWDFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taper(n, taper, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taper_+3A_n">n</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="get_taper_+3A_taper">taper</code></td>
<td>
<p>taper type. Can be either 'none' (default) or 'cosine'</p>
</td></tr>
<tr><td><code id="get_taper_+3A_p">p</code></td>
<td>
<p>proportion to taper on each end, if cosine taper is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length n taper
</p>

<hr>
<h2 id='lcr_loglik'>Log Likelihood</h2><span id='topic+lcr_loglik'></span>

<h3>Description</h3>

<p>Log Likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcr_loglik(f, x, S, L, ftype = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcr_loglik_+3A_f">f</code></td>
<td>
<p>frequency</p>
</td></tr>
<tr><td><code id="lcr_loglik_+3A_x">x</code></td>
<td>
<p>signal</p>
</td></tr>
<tr><td><code id="lcr_loglik_+3A_s">S</code></td>
<td>
<p>start parameter</p>
</td></tr>
<tr><td><code id="lcr_loglik_+3A_l">L</code></td>
<td>
<p>length pe</p>
</td></tr>
<tr><td><code id="lcr_loglik_+3A_ftype">ftype</code></td>
<td>
<p>what to return</p>
</td></tr>
</table>

<hr>
<h2 id='local_cosreg'>Local cosine regression</h2><span id='topic+local_cosreg'></span>

<h3>Description</h3>

<p>Local cosine regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_cosreg(x, lmin = 6, pwidth = 5, kwidth = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_cosreg_+3A_x">x</code></td>
<td>
<p>numeric signal to apply local cosine regression on</p>
</td></tr>
<tr><td><code id="local_cosreg_+3A_lmin">lmin</code></td>
<td>
<p>integer. minimum signal length (L parameter) to search</p>
</td></tr>
<tr><td><code id="local_cosreg_+3A_pwidth">pwidth</code></td>
<td>
<p>integer. the range of window positions to search for each window size</p>
</td></tr>
<tr><td><code id="local_cosreg_+3A_kwidth">kwidth</code></td>
<td>
<p>integer. the width of frequencies to search</p>
</td></tr>
<tr><td><code id="local_cosreg_+3A_verbose">verbose</code></td>
<td>
<p>logical. whether or not to print intermediate results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object of class 'swdft_local_cosreg'
</p>

<hr>
<h2 id='local_signal'>Local Periodic Signal</h2><span id='topic+local_signal'></span>

<h3>Description</h3>

<p>Local Periodic Signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_signal(N, A = 1, Fr = 1, phase = 0, S = 0, L = N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_signal_+3A_n">N</code></td>
<td>
<p>signal length</p>
</td></tr>
<tr><td><code id="local_signal_+3A_a">A</code></td>
<td>
<p>Amplitude</p>
</td></tr>
<tr><td><code id="local_signal_+3A_fr">Fr</code></td>
<td>
<p>Frequency: Number of cycles in a length N period</p>
</td></tr>
<tr><td><code id="local_signal_+3A_phase">phase</code></td>
<td>
<p>phase</p>
</td></tr>
<tr><td><code id="local_signal_+3A_s">S</code></td>
<td>
<p>start of local signal</p>
</td></tr>
<tr><td><code id="local_signal_+3A_l">L</code></td>
<td>
<p>length of local signal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length N local periodic signal
</p>

<hr>
<h2 id='matching_demod'>Matching Demodulation</h2><span id='topic+matching_demod'></span>

<h3>Description</h3>

<p>Matching Demodulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matching_demod(x, n, thresh = 0.05, max_cycles = 5,
  smooth = "butterworth", order = 5, passfreq = 0.1, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matching_demod_+3A_x">x</code></td>
<td>
<p>numeric. Signal to demodulate</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_n">n</code></td>
<td>
<p>integer. Window size for SWDFT</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_thresh">thresh</code></td>
<td>
<p>numeric. Threshold to determine whether to continue demodulating</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_max_cycles">max_cycles</code></td>
<td>
<p>maximum number of demodulation cycles</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_smooth">smooth</code></td>
<td>
<p>character. Type of smoothing to use, accepts either 'ma', 'double_ma',
or 'butterworth' (the default)</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_order">order</code></td>
<td>
<p>moving average parameter if 'smooth' argument equals 'ma' or 'double_ma'. Defaults to 5</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_passfreq">passfreq</code></td>
<td>
<p>numeric scalar. Pass frequency used in butterworth low-pass filter. defaults to .1</p>
</td></tr>
<tr><td><code id="matching_demod_+3A_debug">debug</code></td>
<td>
<p>Logical. Whether to print out intermediate output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 'swdft_matching_demod' object. See ?new_swdft_matching_demod for details.
</p>

<hr>
<h2 id='moving_average'>Simple high pass filter</h2><span id='topic+moving_average'></span>

<h3>Description</h3>

<p>Simple high pass filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_average(x, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moving_average_+3A_x">x</code></td>
<td>
<p>the vector or time-series</p>
</td></tr>
<tr><td><code id="moving_average_+3A_order">order</code></td>
<td>
<p>the order of the filter</p>
</td></tr>
</table>

<hr>
<h2 id='new_swdft'>Constructor function for class 'swdft'</h2><span id='topic+new_swdft'></span>

<h3>Description</h3>

<p>Constructor function for class 'swdft'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft(a, x, n, type, pad, taper_type, taper, p, smooth, m, num_convs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft_+3A_a">a</code></td>
<td>
<p>2D complex array of SWDFT coefficients. If there is smoothing, then
this represents the smoothed squared modulus coefficients.</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_x">x</code></td>
<td>
<p>numeric input signal</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_n">n</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_type">type</code></td>
<td>
<p>'fftw' or 'fft'</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_pad">pad</code></td>
<td>
<p>whether or not it was padded</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_taper_type">taper_type</code></td>
<td>
<p>type of taper</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_taper">taper</code></td>
<td>
<p>numeric values of the taper</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_p">p</code></td>
<td>
<p>of cosine taper (if used)</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_smooth">smooth</code></td>
<td>
<p>type of smoother</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_m">m</code></td>
<td>
<p>width of kernel for smoothing (optional)</p>
</td></tr>
<tr><td><code id="new_swdft_+3A_num_convs">num_convs</code></td>
<td>
<p>number of kernel convolutions (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list w/ the same elements as the arguments, an S3 object of class 'swdft'
</p>

<hr>
<h2 id='new_swdft_cosreg'>Constructor function for class swdft_mod</h2><span id='topic+new_swdft_cosreg'></span>

<h3>Description</h3>

<p>Constructor function for class swdft_mod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft_cosreg(coefficients, fitted, residuals, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft_cosreg_+3A_coefficients">coefficients</code></td>
<td>
<p>matrix of coefficients for cosine regression model</p>
</td></tr>
<tr><td><code id="new_swdft_cosreg_+3A_fitted">fitted</code></td>
<td>
<p>fitted values of cosine regression model</p>
</td></tr>
<tr><td><code id="new_swdft_cosreg_+3A_residuals">residuals</code></td>
<td>
<p>residuals of cosine regression model</p>
</td></tr>
<tr><td><code id="new_swdft_cosreg_+3A_data">data</code></td>
<td>
<p>original signal used to fit cosine regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p> coefficients. A matrix of parameters, the three columns are: 1. amplitude 2. phase, and 3. frequency.
There is only more that one row used when multiple frequencies are fit sequentially.
</p>
</li>
<li><p> fitted. fitted values of cosine regression model
</p>
</li>
<li><p> residuals. residuals of cosine regression model
</p>
</li>
<li><p> data. original signal used to fit cosine regression
</p>
</li></ul>


<hr>
<h2 id='new_swdft_demod'>Constructor function for class 'swdft_demod'</h2><span id='topic+new_swdft_demod'></span>

<h3>Description</h3>

<p>Constructor function for class 'swdft_demod'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft_demod(x, f0, A_t, Phi_t, fitted, y, y_smooth, smooth, order,
  passfreq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft_demod_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_f0">f0</code></td>
<td>
<p>numeric scalar. Frequency to demodulate</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_a_t">A_t</code></td>
<td>
<p>extracted amplitude from y_smooth</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_phi_t">Phi_t</code></td>
<td>
<p>extracted phase from y_smooth</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_fitted">fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_y">y</code></td>
<td>
<p>non-smoothed demodulated signal</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_y_smooth">y_smooth</code></td>
<td>
<p>smoothed demodulated signal</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_smooth">smooth</code></td>
<td>
<p>character. Type of smoothing to use, accepts either 'ma', 'double_ma',
or 'butterworth' (the default)</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_order">order</code></td>
<td>
<p>moving average parameter if 'smooth' argument equals 'ma' or 'double_ma'. Defaults to 5</p>
</td></tr>
<tr><td><code id="new_swdft_demod_+3A_passfreq">passfreq</code></td>
<td>
<p>numeric frequency used as the passfreq in the low-pass filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p> coefficients. A matrix of parameters, the three columns are: 1. amplitude 2. phase, and 3. frequency.
There is only more that one row used when multiple frequencies are fit sequentially.
</p>
</li>
<li><p> fitted. fitted values of cosine regression model
</p>
</li>
<li><p> residuals. residuals of cosine regression model
</p>
</li>
<li><p> data. original signal used to fit cosine regression
</p>
</li>
<li><p> list with the filter used ('smooth') and parameters ('order' for 'ma' or 'double_ma', 'passfreq' for butterworth)
</p>
</li>
<li><p> list w/ the demodulated signal, and smoothed demodulated signal
</p>
</li></ul>


<hr>
<h2 id='new_swdft_local_cosreg'>Constructor function for class 'swdft_local_cosreg'</h2><span id='topic+new_swdft_local_cosreg'></span>

<h3>Description</h3>

<p>Constructor function for class 'swdft_local_cosreg'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft_local_cosreg(coefficients, fitted, residuals, data,
  window_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft_local_cosreg_+3A_coefficients">coefficients</code></td>
<td>
<p>matrix of coefficients for cosine regression model</p>
</td></tr>
<tr><td><code id="new_swdft_local_cosreg_+3A_fitted">fitted</code></td>
<td>
<p>fitted values of cosine regression model</p>
</td></tr>
<tr><td><code id="new_swdft_local_cosreg_+3A_residuals">residuals</code></td>
<td>
<p>residuals of cosine regression model</p>
</td></tr>
<tr><td><code id="new_swdft_local_cosreg_+3A_data">data</code></td>
<td>
<p>original signal used to fit cosine regression</p>
</td></tr>
<tr><td><code id="new_swdft_local_cosreg_+3A_window_params">window_params</code></td>
<td>
<p>data frame of fitted coefficients for each window size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p> coefficients. A matrix of parameters, the three columns are: 1. amplitude 2. phase, and 3. frequency.
There is only more that one row used when multiple frequencies are fit sequentially.
</p>
</li>
<li><p> fitted. fitted values of cosine regression model
</p>
</li>
<li><p> residuals. residuals of cosine regression model
</p>
</li>
<li><p> data. original signal used to fit cosine regression
</p>
</li>
<li><p> window_params. data frame of fitted coefficients for each window size
</p>
</li></ul>


<hr>
<h2 id='new_swdft_matching_demod'>Constructor function for class 'swdft_matching_demod'</h2><span id='topic+new_swdft_matching_demod'></span>

<h3>Description</h3>

<p>Constructor function for class 'swdft_matching_demod'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft_matching_demod(x, n, fitted, thresh, max_cycles, smooth, order,
  passfreqs, maxvals, freqs, khats, amps, phases, demods, cycle, resids,
  fits, return_rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft_matching_demod_+3A_x">x</code></td>
<td>
<p>numeric. Signal to demodulate</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_n">n</code></td>
<td>
<p>integer. Window size for SWDFT</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_fitted">fitted</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_thresh">thresh</code></td>
<td>
<p>numeric. Threshold to determine whether to continue demodulating</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_max_cycles">max_cycles</code></td>
<td>
<p>maximum number of demodulation cycles</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_smooth">smooth</code></td>
<td>
<p>character. Type of smoothing to use, accepts either 'ma', 'double_ma',
or 'butterworth' (the default)</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_order">order</code></td>
<td>
<p>moving average parameter if 'smooth' argument equals 'ma' or 'double_ma'. Defaults to 5</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_passfreqs">passfreqs</code></td>
<td>
<p>pass frequency used in each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_maxvals">maxvals</code></td>
<td>
<p>Maximum SWDFT coefficient for each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_freqs">freqs</code></td>
<td>
<p>Frequencies used in each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_khats">khats</code></td>
<td>
<p>Integer version of frequency.</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_amps">amps</code></td>
<td>
<p>Instantaneous amplitude for each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_phases">phases</code></td>
<td>
<p>Instantaneous phase for each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_demods">demods</code></td>
<td>
<p>List of demodulated signal and smoothed demodulated signal for each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_cycle">cycle</code></td>
<td>
<p>Number of cycles used</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_resids">resids</code></td>
<td>
<p>Residuals for each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_fits">fits</code></td>
<td>
<p>Fitted values for each iteration</p>
</td></tr>
<tr><td><code id="new_swdft_matching_demod_+3A_return_rows">return_rows</code></td>
<td>
<p>Logical vector indicating which iterations occurred. Used for subsetting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p> coefficients. coefficients from the R local signals with time-varying amplitude and phase model.
</p>
</li>
<li><p> fitted. fitted values of cosine regression model
</p>
</li>
<li><p> residuals. residuals of cosine regression model
</p>
</li>
<li><p> data. original signal used to fit cosine regression
</p>
</li>
<li><p> smooth. list with the filter used ('smooth') and parameters ('order' for 'ma' or 'double_ma', 'passfreq' for butterworth)
</p>
</li>
<li><p> demod. list w/ the demodulated signal, and smoothed demodulated signal
</p>
</li>
<li><p> thresh. Threshold used.
</p>
</li>
<li><p> iterations. List of fits, residuals, and maximum values for each iteration
</p>
</li></ul>


<hr>
<h2 id='new_swdft2d'>Constructor function for class 'swdft2d'</h2><span id='topic+new_swdft2d'></span>

<h3>Description</h3>

<p>Constructor function for class 'swdft2d'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft2d(a, x, n0, n1, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft2d_+3A_a">a</code></td>
<td>
<p>4D complex-valued array of 2D SWDFT coefficients</p>
</td></tr>
<tr><td><code id="new_swdft2d_+3A_x">x</code></td>
<td>
<p>2D real or complex valued signal</p>
</td></tr>
<tr><td><code id="new_swdft2d_+3A_n0">n0</code></td>
<td>
<p>window size in row direction</p>
</td></tr>
<tr><td><code id="new_swdft2d_+3A_n1">n1</code></td>
<td>
<p>window size in column direction</p>
</td></tr>
<tr><td><code id="new_swdft2d_+3A_type">type</code></td>
<td>
<p>algorithm to implement. defaults to &quot;fftw&quot;, other option 'fft' for R's base FFT function.
R's base fft function is used if</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object w/ the same elements as arguments to this constructor function
</p>

<hr>
<h2 id='new_swdft3d'>Constructor function for class 'swdft3d'</h2><span id='topic+new_swdft3d'></span>

<h3>Description</h3>

<p>Constructor function for class 'swdft3d'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_swdft3d(a, x, n0, n1, n2, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_swdft3d_+3A_a">a</code></td>
<td>
<p>4D complex-valued array of 2D SWDFT coefficients</p>
</td></tr>
<tr><td><code id="new_swdft3d_+3A_x">x</code></td>
<td>
<p>3D real or complex-valued array</p>
</td></tr>
<tr><td><code id="new_swdft3d_+3A_n0">n0</code></td>
<td>
<p>window size in dimension 0</p>
</td></tr>
<tr><td><code id="new_swdft3d_+3A_n1">n1</code></td>
<td>
<p>window size in dimension 1</p>
</td></tr>
<tr><td><code id="new_swdft3d_+3A_n2">n2</code></td>
<td>
<p>window size in dimension 2</p>
</td></tr>
<tr><td><code id="new_swdft3d_+3A_type">type</code></td>
<td>
<p>defaults to 'base', which is the only option</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object w/ the same elements as arguments to this constructor function
</p>

<hr>
<h2 id='plot.swdft'>Plot method for 'swdft' object</h2><span id='topic+plot.swdft'></span>

<h3>Description</h3>

<p>Plot method for 'swdft' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swdft'
plot(x, freq_type = "cycles", fs = NULL,
  hertz_range = NULL, take_log = FALSE, log_thresh = 1e-05,
  use_fields = TRUE, scale_shrink = 0.9, zlim = NULL,
  xlab = "Window Position", ylab = "Frequency (Cycles/Window)",
  title = "SWDFT", cex_main = 1, cex_lab = 1, cex_axis = 1,
  xaxis_subset = NULL, custom_xaxis = NULL, custom_yaxis = NULL,
  col = "grayscale", display = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.swdft_+3A_x">x</code></td>
<td>
<p>Object of class 'swdft'. If x$a is complex-valued, it is converted to the squared
modulus. If x$a is real-valued, then we assume that it represents the squared</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_freq_type">freq_type</code></td>
<td>
<p>Specify how to display the frequency axis. Either 'cycles' (default), 'fraction', or 'hertz'</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_fs">fs</code></td>
<td>
<p>sample rate. Used if freq_type='hertz'</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_hertz_range">hertz_range</code></td>
<td>
<p>integer vector, given by (low, high). Specifies the range of hertz to display and
is only used when freq_type='hertz'</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_take_log">take_log</code></td>
<td>
<p>logical. Whether to take the log before plotting</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_log_thresh">log_thresh</code></td>
<td>
<p>numeric. Threshold for smallest possible value. Defaults to .000001, and is
used to keep plots from displaying of ~ -40.</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_use_fields">use_fields</code></td>
<td>
<p>logical. Determines whether we use image.plot from the fields package, or 'image'
from the graphics package. The advantage of image.plot is that we get a color scale, so the default is TRUE</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_scale_shrink">scale_shrink</code></td>
<td>
<p>Proportion between 0 and 1 to shrink the scale</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_zlim">zlim</code></td>
<td>
<p>Custom z range</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_xlab">xlab</code></td>
<td>
<p>Custom x-label</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_ylab">ylab</code></td>
<td>
<p>Custom y-label</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_title">title</code></td>
<td>
<p>Custom title</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_cex_main">cex_main</code></td>
<td>
<p>how large to make the title</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_cex_lab">cex_lab</code></td>
<td>
<p>how large to make the labels</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_cex_axis">cex_axis</code></td>
<td>
<p>how large to make the axis labels</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_xaxis_subset">xaxis_subset</code></td>
<td>
<p>subset of x-axis (time / window position) for plotting</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_custom_xaxis">custom_xaxis</code></td>
<td>
<p>Defaults to NULL. Otherwise, used to change the x-axis</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_custom_yaxis">custom_yaxis</code></td>
<td>
<p>Defaults to NULL. Otherwise, used to change the y-axis</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_col">col</code></td>
<td>
<p>defaults to grayscale, can also be 'tim.colors' from fields package</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_display">display</code></td>
<td>
<p>logical. Defaults to TRUE, only used for testing purposes, so it should always be TRUE.</p>
</td></tr>
<tr><td><code id="plot.swdft_+3A_...">...</code></td>
<td>
<p>optional arguments to match the plot generic function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.swdft_mod'>Plot method for swdft_mod object</h2><span id='topic+plot.swdft_mod'></span>

<h3>Description</h3>

<p>Plot method for swdft_mod object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swdft_mod'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.swdft_mod_+3A_x">x</code></td>
<td>
<p>A swdft_cosreg object</p>
</td></tr>
<tr><td><code id="plot.swdft_mod_+3A_y">y</code></td>
<td>
<p>not used, but required by plot generic function</p>
</td></tr>
<tr><td><code id="plot.swdft_mod_+3A_...">...</code></td>
<td>
<p>optional arguments to match the plot generic function</p>
</td></tr>
</table>

<hr>
<h2 id='prou'>The principal nth root of unity</h2><span id='topic+prou'></span>

<h3>Description</h3>

<p>The principal nth root of unity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prou(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prou_+3A_n">n</code></td>
<td>
<p>integer root</p>
</td></tr>
</table>


<h3>Value</h3>

<p>complex number
</p>

<hr>
<h2 id='residuals.swdft_mod'>Residuals method for swdft_cosreg objects</h2><span id='topic+residuals.swdft_mod'></span>

<h3>Description</h3>

<p>Residuals method for swdft_cosreg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swdft_mod'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.swdft_mod_+3A_object">object</code></td>
<td>
<p>A swdft_cosreg object</p>
</td></tr>
<tr><td><code id="residuals.swdft_mod_+3A_...">...</code></td>
<td>
<p>optional arguments to match generic function</p>
</td></tr>
</table>

<hr>
<h2 id='sine'>Sine signal with adjustable parameters</h2><span id='topic+sine'></span>

<h3>Description</h3>

<p>Sine signal with adjustable parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sine(N, A = 1, Fr = 1, phase = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sine_+3A_n">N</code></td>
<td>
<p>length signal</p>
</td></tr>
<tr><td><code id="sine_+3A_a">A</code></td>
<td>
<p>Amplitude</p>
</td></tr>
<tr><td><code id="sine_+3A_fr">Fr</code></td>
<td>
<p>Frequency: Number of cycles in a length N period</p>
</td></tr>
<tr><td><code id="sine_+3A_phase">phase</code></td>
<td>
<p>phase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with sine
</p>

<hr>
<h2 id='smooth_pgram'>Smooth SWDFT coefficients with a convolution</h2><span id='topic+smooth_pgram'></span>

<h3>Description</h3>

<p>Smooth SWDFT coefficients with a convolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_pgram(a, fft_weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_pgram_+3A_a">a</code></td>
<td>
<p>real-valued length n periodogram</p>
</td></tr>
<tr><td><code id="smooth_pgram_+3A_fft_weight">fft_weight</code></td>
<td>
<p>optionally specify the pre-computed FFT of the weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed coefficients
</p>

<hr>
<h2 id='smooth_swdft'>Smooth the SWDFT coefficients</h2><span id='topic+smooth_swdft'></span>

<h3>Description</h3>

<p>Smooth the SWDFT coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_swdft(a, ktype = "daniell", m = 2, num_convs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_swdft_+3A_a">a</code></td>
<td>
<p>real or complex-valued swdft. If real-valued, then we assume it's the squared
modules already. If it's complex valued, we convert to the squared modulus.</p>
</td></tr>
<tr><td><code id="smooth_swdft_+3A_ktype">ktype</code></td>
<td>
<p>either 'daniell' or 'modified.daniell'</p>
</td></tr>
<tr><td><code id="smooth_swdft_+3A_m">m</code></td>
<td>
<p>kernel width from stats::kernel</p>
</td></tr>
<tr><td><code id="smooth_swdft_+3A_num_convs">num_convs</code></td>
<td>
<p>num_convs from stats::kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smooth squared modulues SWDFT coefficients
</p>

<hr>
<h2 id='swdft'>Sliding Window Discrete Fourier Transform</h2><span id='topic+swdft'></span>

<h3>Description</h3>

<p>Sliding Window Discrete Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft(x, n, type = "fftw", pad = TRUE, taper_type = "none",
  p = 0.1, smooth = "none", m = 2, num_convs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft_+3A_x">x</code></td>
<td>
<p>real or complex vector</p>
</td></tr>
<tr><td><code id="swdft_+3A_n">n</code></td>
<td>
<p>integer window size.</p>
</td></tr>
<tr><td><code id="swdft_+3A_type">type</code></td>
<td>
<p>algorithm to implement. defaults to &quot;fftw&quot;, other option 'fft' for R's base FFT function.
R's base fft function is used if</p>
</td></tr>
<tr><td><code id="swdft_+3A_pad">pad</code></td>
<td>
<p>optionally zero-pad the array to that the output
array has the same dimension as the original time-series</p>
</td></tr>
<tr><td><code id="swdft_+3A_taper_type">taper_type</code></td>
<td>
<p>type of taper for each window position. defaults to 'none', can also be 'cosine'.</p>
</td></tr>
<tr><td><code id="swdft_+3A_p">p</code></td>
<td>
<p>Proportion to be tapered at each end of the series. Argument
copied from the spec.taper function in the default stats package. Defaults to .1.</p>
</td></tr>
<tr><td><code id="swdft_+3A_smooth">smooth</code></td>
<td>
<p>Type of smoother. Defaults to 'none', can also be 'daniell' or 'modified daniell'.
If smooth is 'none', then the SWDFT returns the smoothed squared modulus coefficients, not the  complex numbers</p>
</td></tr>
<tr><td><code id="swdft_+3A_m">m</code></td>
<td>
<p>width of kernel. Defaults to 2</p>
</td></tr>
<tr><td><code id="swdft_+3A_num_convs">num_convs</code></td>
<td>
<p>Number of times to convolve the kernel. Defaults to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 'swdft' object. See ?new_swdft for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(n = 20)
a &lt;- swdft(x, n = 2^3)

</code></pre>

<hr>
<h2 id='swdft_base_3d'>3D SWDFT using base R</h2><span id='topic+swdft_base_3d'></span>

<h3>Description</h3>

<p>3D SWDFT using base R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft_base_3d(x, n0, n1, n2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft_base_3d_+3A_x">x</code></td>
<td>
<p>3D real or complex-valued array</p>
</td></tr>
<tr><td><code id="swdft_base_3d_+3A_n0">n0</code></td>
<td>
<p>window size in dimension 0</p>
</td></tr>
<tr><td><code id="swdft_base_3d_+3A_n1">n1</code></td>
<td>
<p>window size in dimension 1</p>
</td></tr>
<tr><td><code id="swdft_base_3d_+3A_n2">n2</code></td>
<td>
<p>window size in dimension 2</p>
</td></tr>
</table>

<hr>
<h2 id='swdft_fft'>Sliding Window Discrete Fourier Transform with base R</h2><span id='topic+swdft_fft'></span>

<h3>Description</h3>

<p>Sliding Window Discrete Fourier Transform with base R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft_fft(x, n, taper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft_fft_+3A_x">x</code></td>
<td>
<p>real or complex vector</p>
</td></tr>
<tr><td><code id="swdft_fft_+3A_n">n</code></td>
<td>
<p>integer window size.</p>
</td></tr>
<tr><td><code id="swdft_fft_+3A_taper">taper</code></td>
<td>
<p>length n vector to multiply against the input data for each window position</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n x P array, where P = length(x) - n + 1
</p>

<hr>
<h2 id='swdft_fftw'>Sliding Window Discrete Fourier Transform using fftw</h2><span id='topic+swdft_fftw'></span>

<h3>Description</h3>

<p>Sliding Window Discrete Fourier Transform using fftw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft_fftw(x, n, taper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft_fftw_+3A_x">x</code></td>
<td>
<p>real or complex vector</p>
</td></tr>
<tr><td><code id="swdft_fftw_+3A_n">n</code></td>
<td>
<p>integer window size.</p>
</td></tr>
<tr><td><code id="swdft_fftw_+3A_taper">taper</code></td>
<td>
<p>length n vector to multiply against the input data for each window position</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n x P array, where P = length(x) - n + 1
</p>

<hr>
<h2 id='swdft_to_props'>Convert the SWDFT to proportions of frequency</h2><span id='topic+swdft_to_props'></span>

<h3>Description</h3>

<p>Convert the SWDFT to proportions of frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft_to_props(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft_to_props_+3A_a">a</code></td>
<td>
<p>swdft</p>
</td></tr>
</table>

<hr>
<h2 id='swdft2d'>2D Sliding Window Discrete Fourier Transform</h2><span id='topic+swdft2d'></span>

<h3>Description</h3>

<p>2D Sliding Window Discrete Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft2d(x, n0, n1, type = "fftw")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft2d_+3A_x">x</code></td>
<td>
<p>2D input signal</p>
</td></tr>
<tr><td><code id="swdft2d_+3A_n0">n0</code></td>
<td>
<p>window size in row direction</p>
</td></tr>
<tr><td><code id="swdft2d_+3A_n1">n1</code></td>
<td>
<p>window size in column direction</p>
</td></tr>
<tr><td><code id="swdft2d_+3A_type">type</code></td>
<td>
<p>algorithm to implement. defaults to &quot;fftw&quot;, other option 'fft' for R's base FFT function.
R's base fft function is used if 'fftwtools' library is not installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 'swdft2d' object. See ?new_swdft for details.
</p>

<hr>
<h2 id='swdft2d_fft'>2D Sliding Window Discrete Fourier Transform using base R</h2><span id='topic+swdft2d_fft'></span>

<h3>Description</h3>

<p>2D Sliding Window Discrete Fourier Transform using base R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft2d_fft(x, n0, n1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft2d_fft_+3A_x">x</code></td>
<td>
<p>2D input signal</p>
</td></tr>
<tr><td><code id="swdft2d_fft_+3A_n0">n0</code></td>
<td>
<p>window size in row direction</p>
</td></tr>
<tr><td><code id="swdft2d_fft_+3A_n1">n1</code></td>
<td>
<p>window size in column direction</p>
</td></tr>
</table>

<hr>
<h2 id='swdft2d_fftw'>2D Sliding Window Discrete Fourier Transform using fftw</h2><span id='topic+swdft2d_fftw'></span>

<h3>Description</h3>

<p>2D Sliding Window Discrete Fourier Transform using fftw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft2d_fftw(x, n0, n1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft2d_fftw_+3A_x">x</code></td>
<td>
<p>2D input signal</p>
</td></tr>
<tr><td><code id="swdft2d_fftw_+3A_n0">n0</code></td>
<td>
<p>window size in row direction</p>
</td></tr>
<tr><td><code id="swdft2d_fftw_+3A_n1">n1</code></td>
<td>
<p>window size in column direction</p>
</td></tr>
</table>

<hr>
<h2 id='swdft3d'>3D Sliding Window Discrete Fourier Transform</h2><span id='topic+swdft3d'></span>

<h3>Description</h3>

<p>3D Sliding Window Discrete Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swdft3d(x, n0, n1, n2, type = "base")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swdft3d_+3A_x">x</code></td>
<td>
<p>3D real or complex-valued array</p>
</td></tr>
<tr><td><code id="swdft3d_+3A_n0">n0</code></td>
<td>
<p>window size in dimension 0</p>
</td></tr>
<tr><td><code id="swdft3d_+3A_n1">n1</code></td>
<td>
<p>window size in dimension 1</p>
</td></tr>
<tr><td><code id="swdft3d_+3A_n2">n2</code></td>
<td>
<p>window size in dimension 2</p>
</td></tr>
<tr><td><code id="swdft3d_+3A_type">type</code></td>
<td>
<p>defaults to 'base', which is the only option</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 'swdft3d' object. See ?new_swdft for details.
</p>

<hr>
<h2 id='unwrap_phase'>Phase unwrapping</h2><span id='topic+unwrap_phase'></span>

<h3>Description</h3>

<p>Phase unwrapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap_phase(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_phase_+3A_p">p</code></td>
<td>
<p>vector of phases fit by demodulation</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
