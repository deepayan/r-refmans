<!DOCTYPE html><html><head><title>Help for package viscomplexr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {viscomplexr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blaschkeProd'><p>Calculate Blaschke products</p></a></li>
<li><a href='#jacobiTheta'><p>Jacobi theta function</p></a></li>
<li><a href='#juliaNormal'><p>Julia iteration with a given number of steps</p></a></li>
<li><a href='#mandelbrot'><p>Mandelbrot iteration with a given number of steps</p></a></li>
<li><a href='#phasePortrait'><p>Create phase portraits of complex functions</p></a></li>
<li><a href='#phasePortraitBw'><p>Create two-color phase portraits of complex functions</p></a></li>
<li><a href='#riemannMask'><p>Plot a Riemann sphere mask over a phase portrait</p></a></li>
<li><a href='#vector2String'><p>Convert a vector into a comma-separated string</p></a></li>
<li><a href='#xlimFromYlim'><p>Adjust xlim to ylim</p></a></li>
<li><a href='#ylimFromXlim'><p>Adjust ylim to xlim</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phase Portraits of Functions in the Complex Number Plane</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality for creating phase portraits of functions in the
    complex number plane. Works with R base graphics, whose full 
    functionality is available. Parallel processing is used for optimum 
    performance.</td>
</tr>
<tr>
<td>Language:</td>
<td>en_US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel (&ge; 1.0.15), grDevices, foreach, parallel, scales,
plotrix, Rdpack, Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Cairo, testthat (&ge; 2.1.0), pracma, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://peterbiber.github.io/viscomplexr/">https://peterbiber.github.io/viscomplexr/</a>,
<a href="https://github.com/PeterBiber/viscomplexr/">https://github.com/PeterBiber/viscomplexr/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-18 12:35:14 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Biber <a href="https://orcid.org/0000-0002-9700-8708"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Biber &lt;castor.fiber@gmx.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-18 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blaschkeProd'>Calculate Blaschke products</h2><span id='topic+blaschkeProd'></span>

<h3>Description</h3>

<p>This function calculates Blaschke products
(<a href="https://en.wikipedia.org/wiki/Blaschke_product">https://en.wikipedia.org/wiki/Blaschke_product</a>) for a complex number
<code>z</code> given a sequence <code>a</code> of complex numbers inside the unit disk,
which are the zeroes of the Blaschke product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blaschkeProd(z, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blaschkeProd_+3A_z">z</code></td>
<td>
<p>Complex number; the point in the complex plane to which the output
of the function is mapped</p>
</td></tr>
<tr><td><code id="blaschkeProd_+3A_a">a</code></td>
<td>
<p>Vector of complex numbers located inside the unit disk. At each
<code>a</code>, the Blaschke product will have a zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sequence of points <code>a[n]</code> located inside the unit disk satisfies the
Blaschke condition, if <code>sum[1:n] (1 - abs(a[n])) &lt; Inf</code>. For each
element <code>a != 0</code> of such a sequence, <code>B(a, z) = abs(a)/a * (a -
z)/(1 - conj(a) * z)</code> can be calculated. For <code>a = 0</code>, <code>B(a, z) =
z</code>. The Blaschke product <code>B(z)</code> results as <code>B(z) = prod[1:n]
(B(a[n], z))</code>.
</p>


<h3>Value</h3>

<p>The value of the Blaschke product at <code>z</code>.
</p>


<h3>See Also</h3>

<p>Other maths: 
<code><a href="#topic+jacobiTheta">jacobiTheta</a>()</code>,
<code><a href="#topic+juliaNormal">juliaNormal</a>()</code>,
<code><a href="#topic+mandelbrot">mandelbrot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random vector of 17 zeroes inside the unit disk
n &lt;- 17
a &lt;- complex(modulus = runif(n, 0, 1), argument = runif(n, 0, 2*pi))

# Portrait the Blaschke product
phasePortrait(blaschkeProd, moreArgs = list(a = a),
  xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
  nCores = 1) # Max. two cores on CRAN, not a limit for your use
  


</code></pre>

<hr>
<h2 id='jacobiTheta'>Jacobi theta function</h2><span id='topic+jacobiTheta'></span>

<h3>Description</h3>

<p>Approximation of &quot;the&quot; Jacobi theta function using the first <code>nn</code>
factors in its triple product version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobiTheta(z, tau, nn = 30L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobiTheta_+3A_z">z</code></td>
<td>
<p>Complex number; the point in the complex plane to which the output
of the function is mapped</p>
</td></tr>
<tr><td><code id="jacobiTheta_+3A_tau">tau</code></td>
<td>
<p>Complex number; the so-called half-period ratio, must have a
positive imaginary part</p>
</td></tr>
<tr><td><code id="jacobiTheta_+3A_nn">nn</code></td>
<td>
<p>Integer; number of factors to be used when approximating the
triple product (default = 30)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function approximates the Jacobi theta function theta(z; tau) which is
the sum of exp(pi*i*n^2*tau + 2*pi*i*n*z) for n in -Inf, Inf. It uses,
however, the function's triple product representation. See
<a href="https://en.wikipedia.org/wiki/Theta_function">https://en.wikipedia.org/wiki/Theta_function</a> for details. This function
has been implemented in C++, but it is only slightly faster than well-crafted
R versions, because the calculation can be nicely vectorized in R.
</p>


<h3>Value</h3>

<p>The value of the function for <code>z</code> and <code>tau</code>.
</p>


<h3>See Also</h3>

<p>Other maths: 
<code><a href="#topic+blaschkeProd">blaschkeProd</a>()</code>,
<code><a href="#topic+juliaNormal">juliaNormal</a>()</code>,
<code><a href="#topic+mandelbrot">mandelbrot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
phasePortrait(jacobiTheta, moreArgs = list(tau = 1i/2-1/4),
pType = "p", xlim = c(-2, 2), ylim = c(-2, 2),
nCores = 1) # Max. two cores on CRAN, not a limit for your use
  



phasePortrait(jacobiTheta, moreArgs = list(tau = 1i/2-1/2),
pType = "p", xlim = c(-2, 2), ylim = c(-2, 2),
nCores = 1)
  



phasePortrait(jacobiTheta, moreArgs = list(tau = 1i/3+1/3),
pType = "p", xlim = c(-2, 2), ylim = c(-2, 2),
nCores = 1)
  



phasePortrait(jacobiTheta, moreArgs = list(tau = 1i/4+1/2),
pType = "p", xlim = c(-2, 2), ylim = c(-2, 2),
nCores = 1)
  



</code></pre>

<hr>
<h2 id='juliaNormal'>Julia iteration with a given number of steps</h2><span id='topic+juliaNormal'></span>

<h3>Description</h3>

<p>This function is designed as the basis for visualizing normal Julia sets
with <code><a href="#topic+phasePortrait">phasePortrait</a></code>. In contrast to usual visualizations of
Julia sets, this requires coloring the actual member points of the set and
not the points outside. Therefore, for numbers that can be identified as not
being parts of the Julia set, this function returns <code>NaN+NaNi</code>. All
other numbers are mapped to the complex value obtained after a user-defined
number of iterations. This function has been implemented in C++; therefore
it is fairly fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaNormal(z, c, R_esc, itDepth = 500L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juliaNormal_+3A_z">z</code></td>
<td>
<p>Complex number; the point in the complex plane to which the output
of the function is mapped</p>
</td></tr>
<tr><td><code id="juliaNormal_+3A_c">c</code></td>
<td>
<p>Complex number; a parameter whose choice has an enormous effect on
the shape of the Julia set. For obtaining useful results with
<code><a href="#topic+phasePortrait">phasePortrait</a></code>, <code>c</code> must be an element of the Mandelbrot
set.</p>
</td></tr>
<tr><td><code id="juliaNormal_+3A_r_esc">R_esc</code></td>
<td>
<p>Real number; the espace radius. If the absolute value of a
number obtained during iteration attains or excels the value of
<code>R_esc</code>, <code>juliaNormal</code> will return <code>NaN+NaNi</code>. <code>R_esc
= 2</code> is a good choice for <code>c</code> being an element of the Mandelbrot set.
See Details for more information.</p>
</td></tr>
<tr><td><code id="juliaNormal_+3A_itdepth">itDepth</code></td>
<td>
<p>An integer which defines the depth of the iteration, i.e. the
maximum number of iteration (default: <code>itDepth =  500</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normal Julia sets are closely related to the Mandelbrot set. A normal Julia
set comprises all complex numbers <code>z</code> for which the following sequence
is bounded for all <code>n &gt; 0</code>: <code>a[n+1] = a[n]^2 + c</code>, starting with
<code>a[0] = z</code>. The parameter <code>c</code> is a complex number, and the
sequence is certainly unbounded if <code>abs(a[]) &gt;= R</code> with <code>R</code> being
an escape Radius which matches the inequality <code>R^2 - R &gt;= abs(c)</code>. As
the visualization with this package gives interesting pictures (i.e. other
than a blank screen) only for <code>c</code> which are elements of the Mandelbrot
set, <code>R = 2</code> is a good choice. For the author's taste, the Julia
visualizations become most interesting for <code>c</code> located in the border
zone of the Mandelbrot set.
</p>


<h3>Value</h3>

<p>Either <code>NaN+NaNi</code> or the complex number obtained after
<code>itDepth</code> iterations
</p>


<h3>See Also</h3>

<p>Other fractals: 
<code><a href="#topic+mandelbrot">mandelbrot</a>()</code>
</p>
<p>Other maths: 
<code><a href="#topic+blaschkeProd">blaschkeProd</a>()</code>,
<code><a href="#topic+jacobiTheta">jacobiTheta</a>()</code>,
<code><a href="#topic+mandelbrot">mandelbrot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This code visualizes a Julia set with some appeal (for the author's
# taste). Zoom in as you like by adjusting xlim and ylim.

phasePortrait(juliaNormal,
  moreArgs = list(c = -0.09 - 0.649i, R_esc = 2),
  xlim = c(-2, 2),
  ylim = c(-1.3, 1.3),
  hsvNaN = c(0, 0, 0),
  nCores = 1)          # Max. two cores on CRAN, not a limit for your use
  



</code></pre>

<hr>
<h2 id='mandelbrot'>Mandelbrot iteration with a given number of steps</h2><span id='topic+mandelbrot'></span>

<h3>Description</h3>

<p>This function is provided as a basis for visualizing the Mandelbrot set with
<code><a href="#topic+phasePortrait">phasePortrait</a></code>. While usual visualizations color the points
<em>outside</em> the Mandelbrot set dependent on the velocity of divergence,
this function produces the information required for coloring the Mandelbrot
set itself. For numbers that can be identified as not being elements of the
Mandelbrot set, we obtain a <code>NaN+NaNi</code> value; for all other numbers,
the function gives back the value after a user-defined number of iterations.
The function has been implemented in C++; it runs fairly fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mandelbrot(z, itDepth = 500L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mandelbrot_+3A_z">z</code></td>
<td>
<p>Complex number; the point in the complex plane to which the output
of the function is mapped</p>
</td></tr>
<tr><td><code id="mandelbrot_+3A_itdepth">itDepth</code></td>
<td>
<p>An integer which defines the depth of the iteration, i.e. the
maximum number of iteration (default: <code>itDepth =  500</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Mandelbrot set comprises all complex numbers <code>z</code> for which the
sequence <code>a[n+1] = a[n]^2 + z</code> starting with <code>a[0] = 0</code> remains
bounded for all <code>n &gt; 0</code>. This condition is certainly not true, if, at
any time, <code>abs(a[]) &gt;= 2</code>. The function <code>mandelbrot</code> performs the
iteration for <code>n = 0, ..., itDepth - 1</code> and permanently checks for
<code>abs(a[n+1]) &gt;= 2</code>. If this is the case, it stops the iteration and
returns <code>NaN+NaNi</code>. In all other cases, it returns <code>a[itDepth]</code>.
</p>


<h3>Value</h3>

<p>Either <code>NaN+NaNi</code> or the complex number obtained after
<code>itDepth</code> iterations
</p>


<h3>See Also</h3>

<p>Other fractals: 
<code><a href="#topic+juliaNormal">juliaNormal</a>()</code>
</p>
<p>Other maths: 
<code><a href="#topic+blaschkeProd">blaschkeProd</a>()</code>,
<code><a href="#topic+jacobiTheta">jacobiTheta</a>()</code>,
<code><a href="#topic+juliaNormal">juliaNormal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This code shows the famous Mandelbrot figure in total, just in the
# opposite way as usual: the Mandelbrot set itself is colored, while the
# points outside are uniformly black.
# Adjust xlim and ylim to zoom in wherever you like.

phasePortrait(mandelbrot,
  xlim = c(-2.3, 0.7),
  ylim = c(-1.2, 1.2),
  hsvNaN = c(0, 0, 0),
  nCores = 1)          # Max. two cores on CRAN, not a limit for your use
  


</code></pre>

<hr>
<h2 id='phasePortrait'>Create phase portraits of complex functions</h2><span id='topic+phasePortrait'></span>

<h3>Description</h3>

<p><code>phasePortrait</code> makes phase portraits of functions in the complex number
plane. It uses a technique often (but not quite correctly) called
<em>domain coloring</em> (<a href="https://en.wikipedia.org/wiki/Domain_coloring">https://en.wikipedia.org/wiki/Domain_coloring</a>).
While many varieties of this technique exist, this book relates closely to
the standards proposed by E. Wegert in his book <em>Visual Complex
Functions</em> (Wegert 2012). In a nutshell,
the argument (<code><a href="base.html#topic+Arg">Arg</a></code>) of any complex function value is displayed
as a color from the chromatic circle. The fundamental colors red, green, and
blue relate to the arguments (angles) of 0, 2/3pi, and 4/3pi (with smooth
color transitions in between), respectively. Options for displaying the
modulus (<code><a href="base.html#topic+Mod">Mod</a></code>) of the complex values and additional reference
lines for the argument are available. This function is designed for being
used inside the framework of R base graphics. It makes use of parallel
computing, and depending on the desired resolution it may create extensive
sets of large temporary files (see Details and Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phasePortrait(
  FUN,
  moreArgs = NULL,
  xlim,
  ylim,
  invertFlip = FALSE,
  res = 150,
  blockSizePx = 2250000,
  tempDir = NULL,
  nCores = max(1, parallel::detectCores() - 1),
  pType = "pma",
  pi2Div = 9,
  logBase = exp(2 * pi/pi2Div),
  argOffset = 0,
  darkestShade = 0.1,
  lambda = 7,
  gamma = 0.9,
  stdSaturation = 0.8,
  hsvNaN = c(0, 0, 0.5),
  asp = 1,
  deleteTempFiles = TRUE,
  noScreenDevice = FALSE,
  autoDereg = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phasePortrait_+3A_fun">FUN</code></td>
<td>
<p>The function to be visualized. There are two possibilities to
provide it, a quoted character string, or a function object.
</p>

<dl>
<dt>Quoted character string</dt><dd><p> A function can be provided as a quoted
character string containing an expression R can interpret as a function of
a complex number z. Examples: &quot;sin(z)&quot;, &quot;(z^2 - 1i)/(tan(z))&quot;, &quot;1/4*z^2 -
10*z/(z^4+4)&quot;. Names of functions known in your R session can be used in a
standalone way, without mentioning z, e.g. &quot;sin&quot;, &quot;tan&quot;, &quot;sqrt&quot;. Obviously,
this also works for functions you defined yourself, e.g.
&quot;myIncredibleFunction&quot; would be valid if you coded a function with this
name before. This is especially useful for functions which require
additional parameters beside the complex number they are supposed to
calculate with. Such arguments can be provided via the parameter
<code>moreArgs</code>. One-liner expressions provided as strings are also
compatible with <code>moreArgs</code> (see examples).
</p>
<p>While it is not the way we recommend for most purposes, you can even define
more complicated functions of your own as character strings. In this case,
you need to use <code><a href="base.html#topic+vapply">vapply</a></code> as a wrapper for your actual function
(see Details, and Examples). Such constructions allow to provide additional
input variables as a part of the character string by using the
<code><a href="base.html#topic+vapply">vapply</a></code>-mechanism (see Details and Examples). The helper
function <code><a href="#topic+vector2String">vector2String</a></code>) can be useful for that matter.
However, the parameter <code>moreArgs</code> is not applicable in this context.
Probably, the most useful application of the function-as-string concept is
when the user defined function, possibly including values for additional
arguments, is to be pasted together at runtime.</p>
</dd>
<dt>Function object</dt><dd><p> It is also possible
to directly provide function objects to <code>FUN</code>. This can be any
function known to R in the current session. Simply put, for functions like
sin, tan, cos, and sqrt you do not even have to quote their names when
passing them to <code>phasePortrait</code>. Same applies to functions you defined
yourself. It is also possible to hand over an anonymous function to
<code>FUN</code> when calling <code>phasePortrait</code>. In all these cases, the
parameter <code>moreArgs</code> can be used for providing additional arguments to
<code>FUN</code>. In general, providing a function as an object, and using
<code>moreArgs</code> in case additional arguments are required, is what we
recommend for user-defined functions.</p>
</dd>
</dl>

<p>When executing <code>phasePortrait</code>, <code>FUN</code> is first evaluated with
<code><a href="base.html#topic+match.fun">match.fun</a></code>. If this is not successful, an attempt to interpret
<code>FUN</code> as an expression will be made. If this fails,
<code>phasePortrait</code> terminates with an error.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_moreargs">moreArgs</code></td>
<td>
<p>A named list of other arguments to FUN. The names must match
the names of the arguments in FUN's definition.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_xlim">xlim</code></td>
<td>
<p>The x limits (x1, x2) of the plot as a two-element numeric
vector. Follows exactly the same definition as in
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>. Here, <code>xlim</code> has to be interpreted as the
plot limits on the real axis.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot (y1, y2) to be used in the same way as
<code>xlim</code>. Evidently, <code>ylim</code> indicates the plot limits on the
imaginary axis.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_invertflip">invertFlip</code></td>
<td>
<p>If <code>TRUE</code>, the function is mapped over a z plane,
which has been transformed to <code>1/z * exp(1i*pi)</code>. This is the
projection required to plot the north Riemann hemisphere in the way
proposed by Wegert (2012), p. 41.
Defaults to <code>FALSE</code>. If this option is chosen, the numbers at the
axis ticks have another meaning than in the normal case. Along the real
axis, they represent the real part of <code>1/z</code>, and along the imaginary
axis, they represent the imaginary part of <code>1/z</code>. Thus, if you want
annotation, you should choose appropriate axis labels like <code>xlab =
Re(1/z)</code>, and <code>ylab = Im(1/z)</code>.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_res">res</code></td>
<td>
<p>Desired resolution of the plot in dots per inch (dpi). Default is
150 dpi. All other things being equal, <code>res</code> has a strong influence on
computing times (double <code>res</code> means fourfold number of pixels to
compute). A good approach could be to make a plot with low resolution (e.g.
the default 150 dpi) first, adjust whatever required, and plot into a
graphics file with high resolution after that.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_blocksizepx">blockSizePx</code></td>
<td>
<p>Number of pixels and corresponding complex values to be
processed at the same time (see Details). Default is 2250000. This value
gave good performance on older systems as well as on a high-end gaming
machine, but some tweaking for your individual system might even improve
things.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_tempdir">tempDir</code></td>
<td>
<p><code>NULL</code> or a character string, specifying the name of the
directory where the temporary files written by <code>phasePortrait</code> are
stored. Default is <code>NULL</code>, which makes <code>phasePortrait</code> use the
current R session's temporary directory. Note that if you specify another
directory, it will be created if it does not exist already. Even though the
temporary files are deleted after completing a phase portrait (unless the
user specifies <code>deleteTempFiles = FALSE</code>, see below), the directory
will remain alive even if has been created by <code>phasePortrait</code>.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_ncores">nCores</code></td>
<td>
<p>Number of processor cores to be used in the parallel computing
tasks. Defaults to the maximum number of cores available minus 1. Any
number between 1 (serial computation) and the maximum number of cores
available as indicated by <code>parallel::detectCores()</code> is accepted. If
<code>nCores</code> is set to a value greater than the available number of cores,
the function will use one core less than available.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_ptype">pType</code></td>
<td>
<p>One of the four options for plotting, &quot;p&quot;, &quot;pa&quot;, &quot;pm&quot;, and &quot;pma&quot;
as a character string. Defaults to &quot;pma&quot;. Option &quot;p&quot; produces a mere phase
plot, i.e. contains only colors for the complex numbers' arguments, but no
reference lines at all. the option &quot;pa&quot; introduces shading zones that
emphasize the arguments. These zones each cover an angle defined by
<code>2*pi/pi2Div</code>, where p2Div is another parameter of this function (see
there). These zones are shaded darkest at the lowest angle (counter
clockwise). Option &quot;pm&quot; displays the modulus by indicating zones, where the
moduli at the higher edge of each zone are in a constant ratio with the
moduli at the lower edge of the zone. Default is a ratio of almost exactly
2 (see parameter <code>logBase</code>) for details. At the lower edge, color
saturation is lowest and highest at the higher edge (see parameters
<code>darkestShade</code>, and <code>stdSaturation</code>). Option &quot;pma&quot; (default)
includes both shading schemes.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_pi2div">pi2Div</code></td>
<td>
<p>Angle distance for the argument reference zones added for
<code>pType = "pma"</code> or <code>pType = "pa"</code>. The value has to be given as
an integer (reasonably) fraction of 2*pi (i.e. 360 degrees). The default is
9; thus, reference zones are delineated by default in distances of 2*pi/9,
i.e. (40 degrees), starting with 0, i.e. the color red if not defined
otherwise with the parameter <code>argOffset</code>. In contrast to the borders
delimiting the modulus zones, the borders of the reference zones for the
argument always follow the same color (by definition).</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_logbase">logBase</code></td>
<td>
<p>Modulus ratio between the edges of the modulus reference zones
in <code>pType</code> <code>"pm"</code> and <code>"pma"</code>. As recommended by
Wegert (2012), the default
setting is <code>logBase = exp(2*pi/pi2Div)</code>. This relation between the
parameters <code>logBase</code> and <code>pi2Div</code> ensures an analogue scaling of
the modulus and argument reference zones (see Details). Conveniently, for
the default <code>pi2Div = 9</code>, we obtain <code>logBase == 2.0099...</code>,
which is very close to 2. Thus, the modulus at the higher edge of a given
zone is almost exactly two times the value at the lower edge.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_argoffset">argOffset</code></td>
<td>
<p>The (complex number) argument in radians counterclockwise,
at which the argument reference zones are fixed. Default is 0, i.e. all
argument reference zones align to the center of the red area.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_darkestshade">darkestShade</code></td>
<td>
<p>Darkest possible shading of modulus and angle reference
zones for <code>pType</code> <code>"pm"</code> and <code>"pma"</code>. It corresponds to the
value &quot;v&quot; in the <code><a href="grDevices.html#topic+hsv">hsv</a></code> color model. <code>darkestShade = 0</code>
means no brightness at all, i.e. black, while <code>darkestShade = 1</code>
indicates maximum brightness. Defaults to 0.1, i.e. very dark, but hue
still discernible.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_lambda">lambda</code></td>
<td>
<p>Parameter steering the shading interpolation between the higher
and the lower edges of the the modulus and argument reference zones in
<code>pType</code> <code>"pm"</code> and <code>"pm"</code>. Should be &gt; 0, default and
reference is <code>lambda = 7</code>. Values &lt; 7 increase the contrast at the
zone borders, values &gt; 7 weaken the contrast.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_gamma">gamma</code></td>
<td>
<p>Parameter for adjusting the combined shading of modulus and
argument reference zones in <code>pType</code> <code>"pma"</code>. Should be in the
interval <code>[0, 1]</code>. Default is 0.9. The higher the value, the more the
smaller of both shading values will dominate the outcome and vice versa.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_stdsaturation">stdSaturation</code></td>
<td>
<p>Saturation value for unshaded hues which applies to the
whole plot in <code>pType</code> <code>"p"</code> and to the (almost) unshaded zones in
<code>pType</code> <code>"pm"</code> and <code>"p"</code>. This corresponds to the value &quot;s&quot;
in the <code><a href="grDevices.html#topic+hsv">hsv</a></code> color model. Must be between 0 and 1, where 1
indicates full saturation and 0 indicates a neutral grey. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_hsvnan">hsvNaN</code></td>
<td>
<p><code><a href="grDevices.html#topic+hsv">hsv</a></code> coded color for being used in areas where the
function to be plotted is not defined. Must be given as a numeric vector
with containing the values h, s, and v in this order. Defaults to
<code>c(0, 0, 0.5)</code> which is a neutral grey.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio y/x as defined in <code><a href="graphics.html#topic+plot.window">plot.window</a></code>. Default
is 1, ensuring an accurate representation of distances between points on
the screen.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_deletetempfiles">deleteTempFiles</code></td>
<td>
<p>If TRUE (default), all temporary files are deleted
after the plot is completed. Set it on FALSE only, if you know exactly what
you are doing - the temporary files can occupy large amounts of hard disk
space (see details).</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_noscreendevice">noScreenDevice</code></td>
<td>
<p>Suppresses any graphical output if TRUE. This is only
intended for test purposes and makes probably only sense together with
<code>deleteTempFiles == FALSE</code>. For dimensioning purposes,
<code>phasePortrait</code> will use a 1 x 1 inch pseudo graphics device in this
case. The default for this parameter is <code>FALSE</code>, and you should change
it only if you really know what you are doing.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_autodereg">autoDereg</code></td>
<td>
<p>if TRUE, automatically register sequential backend after the
phase portrait is completed. Default is FALSE, because registering a
parallel backend can be time consuming. Thus, if you want to make several
phase portraits in succession, you should set <code>autoDereg</code> only for the
last one, or simply type <code>foreach::registerDoSEQ</code> after you are done.
In any case, you don't want to have an unused parallel backend lying about.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), <code>phasePortrait</code> will continuously
write progress messages to the console. This is convenient for normal
purposes, as calculating larger phase portraits in higher resolution may
take several minutes. The setting <code>verbose = FALSE</code>, will suppress any
output to the console.</p>
</td></tr>
<tr><td><code id="phasePortrait_+3A_...">...</code></td>
<td>
<p>All parameters accepted by the <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be used inside the framework of R base graphics.
It plots into the active open graphics device where it will display the phase
plot of a user defined function as a raster image. If no graphics device is
open when called, the function will plot into the default graphics device.
This principle allows to utilize the full functionality of R base graphics.
All graphics parameters (<code><a href="graphics.html#topic+par">par</a></code>) can be freely set and the
function <code>phasePortrait</code> accepts all parameters that can be passed to
the <code><a href="graphics.html#topic+plot.default">plot.default</a></code> function. This allows all kinds of plots -
from scientific representations with annotated axes and auxiliary lines,
notation, etc. to poster-like artistic pictures.<br />
</p>

<dl>
<dt>Mode of operation</dt><dd><p>After being called, <code>phasePortrait</code> gets the
size in inch of the plot region of the graphics device it is plotting into.
With the parameter <code>res</code> which is the desired plot resolution in dpi,
the horizontal and vertical number of pixels is known. As <code>xlim</code> and
<code>ylim</code> are provided by the user, each pixel can be attributed a
complex number z from the complex plane. In that way a two-dimensional
array is built, where each cell represents a point of the complex plane,
containing the corresponding complex number z. This array is set up in
horizontal strips (i.e. split along the imaginary axis), each strip
containing approximately <code>blockSizePx</code> pixels. In a parallel computing
loop, the strips are constructed, saved as temporary files and immediately
deleted from the RAM in order to avoid memory overflow. After that, the
strips are sequentially loaded and subdivided into a number of chunks that
corresponds to the number of registered parallel workers (parameter
<code>nCores</code>). By parallely processing each chunk, the function
<code>f(z)</code> defined by the user in the argument <code>FUN</code> is applied to
each cell of the strip. This results in an array of function values that
has exactly the same size as the original strip. The new array is saved as
a temporary file, the RAM is cleared, and the next strip is loaded. This
continues until all strips are processed. In a similar way, all strips
containing the function values are loaded sequentially, and in a parallel
process the complex values are translated into colors which are stored in a
raster object. While the strips are deleted from the RAM after processing,
the color values obtained from each new strip are appended to the color
raster. After all strips are processed, the raster is plotted into the plot
region of the graphics device. If not explicitly defined otherwise by the
user, all temporary files are deleted after that.
</p>
</dd>
<dt>Temporary file system</dt><dd><p>By default, the above-mentioned temporary
files are deleted after use. This will not happen, if the parameter
<code>deleteTempFiles</code> is set to <code>FALSE</code> or if <code>phasePortrait</code>
does not terminate properly. In both cases, you will find the files in the
directory specified with the parameter <code>tempDir</code>. These files are
<code>.RData</code> files, each one contains a two-dimensional array of complex
numbers. The file names follow a strict convention, see the following
examples:<br /><br />
<code>0001zmat2238046385.RData</code><br />
<code>0001wmat2238046385.RData</code><br /><br />
Both names begin with '0001', indicating that the array's top line is the
first line of the whole clipping of the complex number plane where the
phase portrait relates to. The array which follows below can e.g. begin
with a number like '0470', indicating that its first line is line number
470 of the whole clipping. The number of digits for these line numbers is
not fixed. It is determined by the greatest number required. Numbers with
less digits are zero-padded. The second part of the file name is either
<code>zmat</code> or <code>wmat</code>. The former indicates an array whose cells
contain untransformed numbers of the complex number plane. The latter
contains the values obtained from applying the function of interest to the
first array. Thus, cells at the same position in both arrays exactly relate
to each other. The third part of the file names is a ten-digit integer.
This is a random number which all temporary files stemming from the same
call of <code>phasePortrait</code> have in common. This guarantees that no
temporary files will be confounded by the function, even if undeleted
temporary files from previous runs are still present.
</p>
</dd>
<dt>HSV color model</dt><dd><p>For color-coding the argument of a complex number,
<code>phasePortrait</code> uses the <code><a href="grDevices.html#topic+hsv">hsv</a></code> (hue, saturation, value)
color model. Hereby, the argument is mapped to a position on the chromatic
circle, where the fundamental colors red, green, and blue relate to the
arguments (angles) of 0, 2/3pi, and 4/3pi, respectively. This affects only
the hue component of the color model. The value component is used for
shading modulus and/or argument zones. The saturation component for all
colors can be defined with the parameter <code>stdSaturation</code>.
</p>
</dd>
<dt>Zone definitions and shading</dt><dd><p>In addition to displaying colors for
the arguments of complex numbers, zones for the modulus and/or the argument
are shaded for <code>pType</code> other than &quot;p&quot;. The modulus zones are defined
in a way that each zone covers moduli whose logarithms to the base
<code>logBase</code> have the same integer part. Thus, from the lower edge of one
modulus zone to its upper edge, the modulus multiplies with the value of
<code>logBase</code>. The shading of a modulus zone depends on the fractional
parts <code>x</code> of the above-mentioned logarithms, which cover the interval
<code>[0, 1[</code>.
This translates into the value component <code>v</code> of the <code><a href="grDevices.html#topic+hsv">hsv</a></code>
color model as follows:<br /><br />
<code>v = darkestShade + (1 - darkestShade) * x^(1/lambda)</code><br /><br />
where <code>darkestShade</code> and <code>lambda</code> are parameters that can be
defined by the user. Modifying the parameters <code>lambda</code> and
<code>darkestShade</code> is useful for adjusting contrasts in the phase
portraits. The argument zone definition is somewhat simpler: Each zone
covers an angle domain of <code>2*pi / pi2Div</code>, the &quot;zero reference&quot; for
all zones being <code>argOffset</code>. The angle domain of one zone is linearly
mapped to a value <code>x</code> from the range <code>[0, 1[</code>.
The value component of the color to be displayed is calculated as a
function of <code>x</code> with the same equation as shown above. In case the
user has chosen <code>pType = "pma"</code>, x-values <code>xMod</code> and <code>xArg</code>
are calculated separately for the modulus and the argument, respectively.
They are transformed into preliminary v-values as follows:<br /><br />
<code>vMod = xMod^(1/lambda)</code> and vArg = xArg^(1/lambda)<br /><br />
From these, the final v value results as<br /><br />
<code>v = darkestShade + (1-darkestShade) * (gamma * vMod * vArg +
  (1-gamma) * (1 - (1-vMod) * (1-vArg)))</code><br /><br />
The parameter <code>gamma</code> (range <code>[0, 1]</code>) determines they way how
vMod and vArg are combined. The closer <code>gamma</code> is to one, the more
the smaller of both values will dominate the outcome and vice versa.
</p>
</dd>
<dt>Defining more complicated functions as strings with
<code><a href="base.html#topic+vapply">vapply</a></code></dt><dd><p>You might want to write and use functions which
require more code than a single statement like <code>(z-3)^2+1i*z</code>. As
mentioned in the description of the parameter <code>FUN</code>, we recommend to
define such functions as separate objects and hand them over as such. There
might be, however, cases, where it is more convenient, to define a function
as a single long string, and pass this string to <code>FUN</code>.
In order to make this work, <code><a href="base.html#topic+vapply">vapply</a></code> should be be used for
wrapping the actual code of the function. This is probably not the use of
<code><a href="base.html#topic+vapply">vapply</a></code> intended by its developers, but it works nicely and
performs well. The character string has to have the following structure
&quot;vapply(z, function(z, <em>other arguments if required</em>) {<em>define
function code in here</em>}, <em>define other arguments here</em>, FUN.VALUE =
complex(1))&quot;. See examples.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Wegert E (2012).
<em>Visual Complex Functions. An Introduction with Phase Portraits</em>.
Springer, Basel Heidelberg New York Dordrecht London.
ISBN 978-3-0348-0179-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Map the complex plane on itself

# x11(width = 8, height = 8)   # Screen device commented out
                               # due to CRAN test requirements.
                               # Use it when trying this example
phasePortrait("z", xlim = c(-2, 2), ylim = c(-2, 2),
              xlab = "real", ylab = "imaginary",
              verbose = FALSE, # Suppress progress messages
              nCores = 2)      # Max. two cores allowed on CRAN
                               # not a limit for your own use



# A rational function

# x11(width = 10, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
phasePortrait("(2-z)^2*(-1i+z)^3*(4-3i-z)/((2+2i+z)^4)",
              xlim = c(-8, 8), ylim = c(-6.3, 4.3),
              xlab = "real", ylab = "imaginary",
              nCores = 2)     # Max. two cores allowed on CRAN
                              # not a limit for your own use
  



# Different pType options by example of the sine function.
# Note the different equivalent definitions of the sine
# function in the calls to phasePortrait

# x11(width = 9, height = 9) # Screen device commented out
                             # due to CRAN test requirements.
                             # Use it when trying this example
op &lt;- par(mfrow = c(2, 2), mar = c(2.1, 2.1, 2.1, 2.1))
phasePortrait("sin(z)", xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "p",   main = "pType = 'p'",   axes = FALSE,
              nCores = 2) # Max. two cores on CRAN, not a limit for your use
  
phasePortrait("sin(z)", xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "pm",  main = "pType = 'pm'",  axes = FALSE,
              nCores = 2)
  
phasePortrait("sin",    xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "pa",  main = "pType = 'pa'",  axes = FALSE,
              nCores = 2)
  
phasePortrait(sin,      xlim = c(-pi, pi), ylim = c(-pi, pi),
              pType = "pma", main = "pType = 'pma'", axes = FALSE,
              nCores = 2)
  
par(op)


# I called this one 'nuclear fusion'

# x11(width = 16/9*8, height = 8) # Screen device commented out
                                  # due to CRAN test requirements.
                                  # Use it when trying this example

op &lt;- par(mar = c(0, 0, 0, 0), omi = c(0.2, 0.2, 0.2, 0.2), bg = "black")
phasePortrait("cos((z + 1/z)/(1i/2 * (z-1)^10))",
              xlim = 16/9*c(-2, 2), ylim = c(-2, 2),
              axes = FALSE, xaxs = "i", yaxs = "i",
              nCores = 2) # Max. two cores allowed on CRAN
                          # not a limit for your own use
  
par(op)


# Passing function objects to phasePortrait:
# Two mathematical celebrities - Riemann's zeta function
# and the gamma function, both from the package pracma.
# R's built-in gamma is not useful, as it does not work
# with complex input values.

if(requireNamespace("pracma", quietly = TRUE)) {
# x11(width = 16, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
op &lt;- par(mfrow = c(1, 2))
phasePortrait(pracma::zeta,  xlim = c(-35, 15), ylim = c(-25, 25),
              xlab = "real", ylab = "imaginary",
              main = expression(zeta(z)), cex.main = 2,
              nCores = 2) # Max. two cores on CRAN, not a limit for your use
  
phasePortrait(pracma::gammaz, xlim = c(-10, 10), ylim = c(-10, 10),
              xlab = "real", ylab = "imaginary",
              main = expression(Gamma(z)), cex.main = 2,
              nCores = 2) # Max. two cores allowed on CRAN
                          # not a limit for your own use
  
}



# Using vapply for defining a whole function as a string.
# This is a Blaschke product with a sequence a of twenty numbers.
# See the documentation of the function vector2String for a more
# convenient space-saving definition of a.
# But note that a C++ version of the Blaschke product is available
# in this package (function blaschkeProd()).

# x11(width = 10, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
phasePortrait("vapply(z, function(z, a) {
                fct &lt;- ifelse(abs(a) != 0,
                  abs(a)/a * (a-z)/(1-Conj(a)*z), z)
                return(prod(fct))
              },
              a = c(0.12152611+0.06171533i,  0.53730315+0.32797530i,
                    0.35269601-0.53259644i, -0.57862039+0.33328986i,
                   -0.94623221+0.06869166i, -0.02392968-0.21993132i,
                    0.04060671+0.05644165i,  0.15534449-0.14559097i,
                    0.32884452-0.19524764i,  0.58631745+0.05218419i,
                    0.02562213+0.36822933i, -0.80418478+0.58621875i,
                   -0.15296208-0.94175193i, -0.02942663+0.38039250i,
                   -0.35184130-0.24438324i, -0.09048155+0.18131963i,
                    0.63791697+0.47284679i,  0.25651928-0.46341192i,
                    0.04353117-0.73472528i, -0.04606189+0.76068461i),
              FUN.VALUE = complex(1))",
              pType = "p",
              xlim = c(-4, 2), ylim = c(-2, 2),
              xlab = "real", ylab = "imaginary",
              nCores = 2) # Max. two cores allowed on CRAN
                          # not a limit for your own use
  



# Much more elegant: Define the function outside.
# Here comes a Blaschke product with 200 random points.

# define function for calculating blaschke products, even
# possible as a one-liner
blaschke &lt;- function(z, a) {
  return(prod(ifelse(abs(a) != 0, abs(a)/a * (a-z)/(1-Conj(a)*z), z)))
}
# define 200 random numbers inside the unit circle
n &lt;- 200
a &lt;- complex(modulus = runif(n), argument = runif(n)*2*pi)
# Plot it
# x11(width = 10, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
phasePortrait(blaschke,
  moreArgs = list(a = a),
  pType = "p",
  xlim = c(-2.5, 2.5), ylim = c(-1.7, 1.7),
  xlab = "real", ylab = "imaginary",
  nCores = 2) # Max. two cores allowed on CRAN
              # not a limit for your own use
  



# A hybrid solution: A one-liner expression given as a character string
# can be provided additional arguments with moreArgs

n &lt;- 73
a &lt;- complex(modulus = runif(n), argument = runif(n)*2*pi)
# x11(width = 10, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
phasePortrait("prod(ifelse(abs(a) != 0,
  abs(a)/a * (a-z)/(1-Conj(a)*z), z))",
  moreArgs = list(a = a),
  pType = "p",
  xlim = c(-2.5, 2.5), ylim = c(-1.7, 1.7),
  xlab = "real", ylab = "imaginary",
  nCores = 1) # Max. two cores allowed on CRAN
              # not a limit for your own use
  



# Note the difference in performance when using the C++ defined
# function blaschkeProd() provided in this package

n &lt;- 73
a &lt;- complex(modulus = runif(n), argument = runif(n)*2*pi)
# Plot it
# x11(width = 10, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
phasePortrait(blaschkeProd,
  moreArgs = list(a = a),
  pType = "p",
  xlim = c(-2.5, 2.5), ylim = c(-1.7, 1.7),
  xlab = "real", ylab = "imaginary",
  nCores = 1) # Max. two cores allowed on CRAN
              # not a limit for your own use
  



# Interesting reunion with Benoit Mandelbrot.
# The function mandelbrot() is part of this package (defined
# in C++ for performance)

# x11(width = 11.7, height = 9/16*11.7) # Screen device commented out
                                        # due to CRAN test requirements.
                                        # Use it when trying this example
op &lt;- par(mar = c(0, 0, 0, 0), bg = "black")
phasePortrait(mandelbrot,
              moreArgs = list(itDepth = 100),
              xlim = c(-0.847, -0.403), ylim = c(0.25, 0.50),
              axes = TRUE, pType = "pma",
              hsvNaN = c(0, 0, 0), xaxs = "i", yaxs = "i",
              nCores = 1) # Max. two cores allowed on CRAN
                          # not a limit for your own use
par(op)
  



# Here comes a Julia set.
# The function juliaNormal() is part of this package (defined
# in C++ for performance)

# x11(width = 11.7, height = 9/16*11.7) # Screen device commented out
                                        # due to CRAN test requirements.
                                        # Use it when trying this example
op &lt;- par(mar = c(0, 0, 0, 0), bg = "black")
phasePortrait(juliaNormal,
  moreArgs = list(c = -0.09 - 0.649i, R_esc = 2),
  xlim = c(-2, 2),
  ylim = c(-1.3, 1.3),
  hsvNaN = c(0, 0, 0),
  nCores = 1) # Max. two cores allowed on CRAN
              # not a limit for your own use
par(op)
  



</code></pre>

<hr>
<h2 id='phasePortraitBw'>Create two-color phase portraits of complex functions</h2><span id='topic+phasePortraitBw'></span>

<h3>Description</h3>

<p><code>phasePortraitBw</code> allows for creating two-color phase portraits of
complex functions based on a polar chessboard grid (cf.
Wegert (2012), p. 35). Compared to
the full phase portraits that can be made with <code><a href="#topic+phasePortrait">phasePortrait</a></code>,
two-color portraits omit information. Especially in combination with full
phase portraits they can be, however, very helpful tools for interpretation.
Besides, two-color phase portraits have a special aesthetic appeal which is
worth exploring for itself. In its parameters and its mode of operation,
<code>phasePortraitBw</code> is very similar to <code><a href="#topic+phasePortrait">phasePortrait</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phasePortraitBw(
  FUN,
  moreArgs = NULL,
  xlim,
  ylim,
  invertFlip = FALSE,
  res = 150,
  blockSizePx = 2250000,
  tempDir = NULL,
  nCores = max(1, parallel::detectCores() - 1),
  bwType = "ma",
  pi2Div = 18,
  logBase = exp(2 * pi/pi2Div),
  argOffset = 0,
  bwCols = c("black", "gray95", "gray"),
  asp = 1,
  deleteTempFiles = TRUE,
  noScreenDevice = FALSE,
  autoDereg = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phasePortraitBw_+3A_fun">FUN</code></td>
<td>
<p>The function to be visualized. There are two possibilities to
provide it, a quoted character string, or a function object. The quoted
character string must contain an expression that can be interpreted by R as
a function of a complex number <code>z</code> (like e.g. &quot;sin(z)&quot;, &quot;(z^2 -
1i)/(tan(z))&quot;, &quot;1/4*z^2 - 10*z/(z^4+4)&quot;). See the documentation of
<code><a href="#topic+phasePortrait">phasePortrait</a></code> for a complete presentation of all options.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_moreargs">moreArgs</code></td>
<td>
<p>A named list of other arguments to FUN. The names must match
the names of the arguments in FUN's definition.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_xlim">xlim</code></td>
<td>
<p>The x limits (x1, x2) of the plot as a two-element numeric
vector. Follows exactly the same definition as in
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>. Here, <code>xlim</code> has to be interpreted as the
plot limits on the real axis.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_ylim">ylim</code></td>
<td>
<p>The y limits of the plot (y1, y2) to be used in the same way as
<code>xlim</code>. Evidently, <code>ylim</code> indicates the plot limits on the
imaginary axis.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_invertflip">invertFlip</code></td>
<td>
<p>If <code>TRUE</code>, the function is mapped over a z plane,
which has been transformed to <code>1/z * exp(1i*pi)</code>. This is the
projection required to plot the north Riemann hemisphere in the way
proposed by Wegert (2012), p. 41.
Defaults to <code>FALSE</code>. If this option is chosen, the numbers at the axis
ticks have another meaning than in the normal case. Along the real axis,
they represent the real part of <code>1/z</code>, and along the imaginary axis,
they represent the imaginary part of <code>1/z</code>. Thus, if you want
annotation, you should choose appropriate axis labels like <code>xlab =
Re(1/z)</code>, and <code>ylab = Im(1/z)</code>.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_res">res</code></td>
<td>
<p>Desired resolution of the plot in dots per inch (dpi). Default is
150 dpi. All other things being equal, <code>res</code> has a strong influence on
computing times (double <code>res</code> means fourfold number of pixels to
compute). A good approach could be to make a plot with low resolution (e.g.
the default 150 dpi) first, adjust whatever required, and plot into a
graphics file with high resolution after that.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_blocksizepx">blockSizePx</code></td>
<td>
<p>Number of pixels and corresponding complex values to be
processed at the same time (see Details). Default is 2250000. This value
gave good performance on older systems as well as on a high-end gaming
machine, but some tweaking for your individual system might even improve
things.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_tempdir">tempDir</code></td>
<td>
<p><code>NULL</code> or a character string, specifying the name of the
directory where the temporary files written by <code>phasePortrait</code> are
stored. Default is <code>NULL</code>, which makes <code>phasePortrait</code> use the
current R session's temporary directory. Note that if you specify another
directory, it will be created if it does not exist already. Even though the
temporary files are deleted after completing a phase portrait (unless the
user specifies <code>deleteTempFiles = FALSE</code>, see below), the directory
will remain alive even if has been created by <code>phasePortrait</code>.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_ncores">nCores</code></td>
<td>
<p>Number of processor cores to be used in the parallel computing
tasks. Defaults to the maximum number of cores available minus 1. Any
number between 1 (serial computation) and the maximum number of cores
available as indicated by <code>parallel::detectCores()</code> is accepted. If
<code>nCores</code> is set to a value greater than the available number of cores,
the function will use one core less than available.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_bwtype">bwType</code></td>
<td>
<p>One of the three options for plotting, &quot;m&quot;, &quot;a&quot;, and &quot;ma&quot;, to
be provided as a character string. Defaults to &quot;ma&quot;. This parameter has a
comparable role to the parameter <code>pType</code> in
<code><a href="#topic+phasePortrait">phasePortrait</a></code>. Option &quot;m&quot; produces a plot that colors modulus
zones only. In more detail, for each input number's modulus, the logarithm
with base <code>logBase</code> (see below) is calculated and cut down to the next
lower integer value. If this is an even number, the first color given in
<code>bwCols</code> (see below) is taken. In case of an odd number, the second
color is used. Option &quot;a&quot; produces a plot that exclusively colors argument
(phase angle) zones. To that end, the full angle (2*pi) is divided into
<code>p2Div</code> (see below) zones, which are numbered from 0 to pi2Div - 1
with increasing angle. Such an integer number is attributed to the complex
number of interest according to the zone it falls into. Even and odd zone
numbers are mapped to the first and the second color in <code>bwCols</code>,
respectively. For normal purposes, the input parameter <code>pi2Div</code> should
be an even number in order to avoid the first and the last zone having the
same color. With option &quot;ma&quot;, a chessboard-like alternation of colors is
displayed over the tiles formed by the intersecting modulus and argument
zones (both determined separately as with the options &quot;m&quot; and &quot;a&quot;).</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_pi2div">pi2Div</code></td>
<td>
<p>Angle distance for the argument reference zones added for
<code>pType = "pma"</code> or <code>pType = "pa"</code>. The value has to be given as
an integer (reasonably) fraction of 2*pi (i.e. 360 degrees). Unlike with
<code><a href="#topic+phasePortrait">phasePortrait</a></code>, the default is 18; thus, reference zones are
delineated by default in distances of 2*pi/18, i.e. (20 degrees), starting
with 0 if not defined otherwise with the parameter <code>argOffset</code>. While
the default of <code>pi2Div</code> is 9 with <code><a href="#topic+phasePortrait">phasePortrait</a></code> for good
reasons (see there), setting <code>pi2Div</code> to an odd number is usually not
a good choice with two-color phase portraits, because the first and the
last phase angle zone would get the same color. However, as <code>pi2Div</code>
here defaults to double the value as with <code><a href="#topic+phasePortrait">phasePortrait</a></code>, both
plot types can be nicely compared even when using their specific defaults
of <code>pi2Div</code>.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_logbase">logBase</code></td>
<td>
<p>Modulus ratio between the edges of the modulus zones in
<code>bwType</code> <code>"m"</code> and <code>"ma"</code>. As recommended by
Wegert (2012), the default
setting is <code>logBase = exp(2*pi/pi2Div)</code>. This relation between the
parameters <code>logBase</code> and <code>pi2Div</code> ensures an analogue scaling of
the modulus and argument reference zones (see Details section in the
documentation of <code><a href="#topic+phasePortrait">phasePortrait</a></code>). Conveniently, for the
default <code>pi2Div = 18</code>, we obtain <code>logBase == 1.4177...</code>, which is
very close to the square root of 2. Thus, when crossing two modulus zones,
the modulus at the higher edge of the second zone is almost exactly two
times the value at the lower edge of the first zone.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_argoffset">argOffset</code></td>
<td>
<p>The (complex number) argument in radians counterclockwise,
at which the argument (phase angle) reference zones are fixed, i.e. the
lower angle of the first zone. Default is 0.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_bwcols">bwCols</code></td>
<td>
<p>Color definition for the plot provided as a character vector of
length 3. Each element of the vector must be either a color name R
recognizes, or a hexadecimal color string like e.g. &quot;#00FF11&quot;. The first
and the second color make the appearance of two-color phase portraits (see
<code>bwType</code> above for details), while the third color is reserved for
special cases, where the input value cannot sufficiently evaluated (NaNs,
partly Inf). Defaults to c(&quot;black&quot;, &quot;gray95&quot;, &quot;gray&quot;), which leads to an
alternation of black and very light gray zones or tiles, and uses a neutral
gray in special cases.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio y/x as defined in <code><a href="graphics.html#topic+plot.window">plot.window</a></code>. Default
is 1, ensuring an accurate representation of distances between points on
the screen.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_deletetempfiles">deleteTempFiles</code></td>
<td>
<p>If TRUE (default), all temporary files are deleted
after the plot is completed. Set it on FALSE only, if you know exactly what
you are doing - the temporary files can occupy large amounts of hard disk
space (see details).</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_noscreendevice">noScreenDevice</code></td>
<td>
<p>Suppresses any graphical output if TRUE. This is only
intended for test purposes and makes probably only sense together with
<code>deleteTempFiles == FALSE</code>. For dimensioning purposes,
<code>phasePortraitBw</code> will use a 1 x 1 inch pseudo graphics device in this
case. The default for this parameter is <code>FALSE</code>, and you should change
it only if you really know what you are doing.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_autodereg">autoDereg</code></td>
<td>
<p>if TRUE, automatically register sequential backend after the
plot is completed. Default is FALSE, because registering a parallel backend
can be time consuming. Thus, if you want to make several phase portraits in
succession, you should set <code>autoDereg</code> only for the last one, or
simply type <code>foreach::registerDoSEQ</code> after you are done. In any case,
you don't want to have an unused parallel backend lying about.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default), <code>phasePortraitBw</code> will continuously
write progress messages to the console. This is convenient for normal
purposes, as calculating larger phase portraits in higher resolution may
take several minutes. The setting <code>verbose = FALSE</code>, will suppress any
output to the console.</p>
</td></tr>
<tr><td><code id="phasePortraitBw_+3A_...">...</code></td>
<td>
<p>All parameters accepted by the <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be used inside the framework of R base graphics.
It plots into the active open graphics device where it will display the phase
plot of a user defined function as a raster image. If no graphics device is
open when called, the function will plot into the default graphics device.
This principle allows to utilize the full functionality of R base graphics.
All graphics parameters (<code><a href="graphics.html#topic+par">par</a></code>) can be freely set and the
function <code>phasePortrait</code> accepts all parameters that can be passed to
the <code><a href="graphics.html#topic+plot.default">plot.default</a></code> function. This allows all kinds of plots -
from scientific representations with annotated axes and auxiliary lines,
notation, etc. to poster-like artistic pictures. The general mode of operation,
including the usage of parallel processing is exactly the same as with
<code><a href="#topic+phasePortrait">phasePortrait</a></code>, see details section there.
</p>


<h3>References</h3>

<p>Wegert E (2012).
<em>Visual Complex Functions. An Introduction with Phase Portraits</em>.
Springer, Basel Heidelberg New York Dordrecht London.
ISBN 978-3-0348-0179-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Map the complex plane on itself

# x11(width = 8, height = 8)     # Screen device commented out
                                 # due to CRAN test requirements.
                                 # Use it when trying this example
phasePortraitBw("z", xlim = c(-2, 2), ylim = c(-2, 2),
                xlab = "real", ylab = "imaginary",
                verbose = FALSE, # Suppress progress messages
                nCores = 2)      # Max. two cores allowed on CRAN
                                 # not a limit for your own use




# Sinus with default colors and default bwType ("ma")

# x11(width = 8, height = 8)       # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
phasePortraitBw("sin(z)",
                xlim = c(-pi, pi),
                ylim = c(-pi, pi),
                verbose = FALSE,
                nCores = 2)        # Max. two cores allowed on CRAN
                                   # not a limit for your own use
  




# Sinus with custom colors and bwType "a"

# x11(width = 8, height = 8)       # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
phasePortraitBw("sin(z)",
                xlim = c(-pi, pi),
                ylim = c(-pi, pi),
                bwType = "a",
                bwCols = c("darkgreen", "green", "gray"),
                verbose = FALSE,
                nCores = 2)        # Max. two cores allowed on CRAN
                                   # not a limit for your own use
  




# Sinus with custom colors and bwType "m"

# x11(width = 8, height = 8)       # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
phasePortraitBw("sin(z)",
                xlim = c(-pi, pi),
                ylim = c(-pi, pi),
                bwType = "m",
                bwCols = c("darkblue", "skyblue", "gray"),
                verbose = FALSE,
                nCores = 2)        # Max. two cores allowed on CRAN
                                   # not a limit for your own use
  




# Map the complex plane on itself, show all bwType options

# x11(width = 8, height = 8)       # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
op &lt;- par(mfrow = c(2, 2), mar = c(4.1, 4.1, 1.1, 1.1))
for(bwType in c("ma", "a", "m")) {
  phasePortraitBw("z", xlim = c(-2, 2), ylim = c(-2, 2),
                  bwType = bwType,
                  xlab = "real", ylab = "imaginary",
                  verbose = FALSE, # Suppress progress messages
                  nCores = 2)      # Max. two cores allowed on CRAN
                                   # not a limit for your own use
}
# Add normal phase portrait for comparison
phasePortrait("z", xlim = c(-2, 2), ylim = c(-2, 2),
              xlab = "real", ylab = "imaginary",
              verbose = FALSE,
              pi2Div = 18,         # Use same angular division as default
                                   # in phasePortraitBw
              nCores = 2)
par(op)

  



# A rational function, show all bwType options

# x11(width = 8, height = 8)       # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
funString &lt;- "(z + 1.4i - 1.4)^2/(z^3 + 2)"
op &lt;- par(mfrow = c(2, 2), mar = c(4.1, 4.1, 1.1, 1.1))
for(bwType in c("ma", "a", "m")) {
  phasePortraitBw(funString, xlim = c(-2, 2), ylim = c(-2, 2),
                  bwType = bwType,
                  xlab = "real", ylab = "imaginary",
                  verbose = FALSE, # Suppress progress messages
                  nCores = 2)      # Max. two cores allowed on CRAN
                                   # not a limit for your own use
}
# Add normal phase portrait for comparison
phasePortrait(funString, xlim = c(-2, 2), ylim = c(-2, 2),
              xlab = "real", ylab = "imaginary",
              verbose = FALSE,
              pi2Div = 18,         # Use same angular division as default
                                   # in phasePortraitBw
              nCores = 2)
par(op)

  



</code></pre>

<hr>
<h2 id='riemannMask'>Plot a Riemann sphere mask over a phase portrait</h2><span id='topic+riemannMask'></span>

<h3>Description</h3>

<p>The function <code>riemannMask</code> can be used for laying a circular mask over
an existing phasePortrait (as generated with the function
<code><a href="#topic+phasePortrait">phasePortrait</a></code>). This mask shades the plot region outside the
unit circle. The unshaded area is a projection on the southern or northern
Riemann hemisphere. The standard projection used by
<code><a href="#topic+phasePortrait">phasePortrait</a></code>, i.e. <code>invertFlip = FALSE</code> hereby
corresponds to the southern Riemann hemisphere with the origin being the
south pole. If <code><a href="#topic+phasePortrait">phasePortrait</a></code> was called with <code>invertFlip =
TRUE</code>, then the unit circle contains the northern Riemann hemisphere with the
point at infinity in the center (see the vignette for more details). Options
for adding annotation, landmark points  are available
(see Wegert (2012), p. 41).
Several parameters are on hand for adjusting the mask's transparency, color,
and similar features. some details, this function behaves less nicely under
Windows than under Linux (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riemannMask(
  colMask = "white",
  alphaMask = 0.5,
  circOutline = TRUE,
  circLwd = 1,
  circleSteps = 360,
  circleCol = par("fg"),
  gridCross = FALSE,
  annotSouth = FALSE,
  annotNorth = FALSE,
  xlim = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riemannMask_+3A_colmask">colMask</code></td>
<td>
<p>Color for the shaded area outside the unit circle. Defaults to
&quot;white&quot;. Can be any kind of color definition R accepts. I recommend,
however, to use a color definition without a transparency value, because
this would be overridden by the parameter <code>alphaMask</code>.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_alphamask">alphaMask</code></td>
<td>
<p>Transparency value for the color defined with
<code>colMask</code>. Has to be a value between 0 (fully transparent) and 1
(totally opaque). Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_circoutline">circOutline</code></td>
<td>
<p>Boolean - if <code>TRUE</code>, the outline of the unit circle
is drawn. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_circlwd">circLwd</code></td>
<td>
<p>Line width of the unit circle outline. Obviously relevant
only when <code>circOutline == TRUE</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_circlesteps">circleSteps</code></td>
<td>
<p>Number of vertices to draw the circle. Defaults to 360
(one degree between two vertices).</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_circlecol">circleCol</code></td>
<td>
<p>Color of the unit circle, default is the default foreground
color (<code>par("fg")</code>).</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_gridcross">gridCross</code></td>
<td>
<p>Boolean - if <code>TRUE</code>, a horizontal and a vertical gray
line will be drawn over the plot region, intersection in the center of the
unit circle. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_annotsouth">annotSouth</code></td>
<td>
<p>Boolean - add landmark points and annotation for a
<em>southern</em> Riemann hemisphere, defaults to <code>FALSE</code>. This
annotation fits to an image that has been created with
<code><a href="#topic+phasePortrait">phasePortrait</a></code> and the option <code>invertFlip = FALSE</code>.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_annotnorth">annotNorth</code></td>
<td>
<p>Boolean - add landmark points and annotation for a
<em>northern</em> Riemann hemisphere, defaults to <code>FALSE</code>. This
annotation fits to an image that has been created with
<code><a href="#topic+phasePortrait">phasePortrait</a></code> and the option <code>invertFlip = TRUE</code>.</p>
</td></tr>
<tr><td><code id="riemannMask_+3A_xlim">xlim</code>, <code id="riemannMask_+3A_ylim">ylim</code></td>
<td>
<p>optional, if provided must by numeric vectors of length 2
defining plot limits as usual. They define the outer rectangle of the
Riemann mask. If <code>xlim</code> or <code>ylim</code> is not provided (the standard
case), the coordinates of the plot window as given by <code>par("usr")</code>
will be used for the missing component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is, unfortunately, a somewhat different behavior of this function under
Linux and Windows systems. Under Windows, the region outside the unit circle
is only shaded if the whole unit circle fits into the plot region. If only a
part of the unit circle is to be displayed, the shading is completely omitted
under Windows (annotation etc. works correctly, however), while it works
properly on Linux systems. Obviously, the function <code><a href="graphics.html#topic+polypath">polypath</a></code>,
which we are using for creating the unit circle template, is interpreted
differently on both systems.
</p>


<h3>References</h3>

<p>Wegert E (2012).
<em>Visual Complex Functions. An Introduction with Phase Portraits</em>.
Springer, Basel Heidelberg New York Dordrecht London.
ISBN 978-3-0348-0179-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tangent with fully annotated Riemann masks.
# The axis tick marks on the second diagram (Northern hemisphere)
# have to be interpreted as the real and imaginary parts of 1/z
# (see vignette). The axis labels in this example have been adapted
# accordingly.

# x11(width = 16, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
op &lt;- par(mfrow = c(1, 2), mar = c(4.7, 4.7, 3.5, 3.5))
phasePortrait("tan(z)", pType = "pma",
              main = "Southern Riemann Hemisphere",
              xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
              xlab = "real", ylab = "imaginary",
              xaxs = "i", yaxs = "i",
              nCores = 2) # Max. two cores on CRAN, not a limit for your use
  
riemannMask(annotSouth = TRUE, gridCross = TRUE)

phasePortrait("tan(z)", pType = "pma",
              main = "Northern Riemann Hemisphere",
              invertFlip = TRUE,
              xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
              xlab = "real (1/z)", ylab = "imaginary (1/z)",
              xaxs = "i", yaxs = "i",
              nCores = 2) # Max. two cores on CRAN, not a limit for your use
  
riemannMask(annotNorth = TRUE, gridCross = TRUE)
par(op)


# Rational function with Riemann masks without annotation.
# The axis tick marks on the second diagram (Northern hemisphere)
# have to be interpreted as the real and imaginary parts of 1/z
# (see vignette). The axis labels in this example have been adapted
# accordingly.

# x11(width = 16, height = 8) # Screen device commented out
                              # due to CRAN test requirements.
                              # Use it when trying this example
op &lt;- par(mfrow = c(1, 2), mar = c(4.7, 4.7, 3.5, 3.5))
phasePortrait("(-z^17 - z^15 - z^9 - z^7 - z^2 - z + 1)/(1i*z - 1)",
              pType = "pma",
              main = "Southern Riemann Hemisphere",
              xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
              xlab = "real", ylab = "imaginary",
              xaxs = "i", yaxs = "i",
              nCores = 2) # Max. two cores on CRAN, not a limit for your use
  
riemannMask(annotSouth = FALSE, gridCross = FALSE, circOutline = FALSE,
            alphaMask = 0.7)

phasePortrait("(-z^17 - z^15 - z^9 - z^7 - z^2 - z + 1)/(1i*z - 1)",
              pType = "pma",
              main = "Northern Riemann Hemisphere",
              invertFlip = TRUE,
              xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
              xlab = "real (1/z)", ylab = "imaginary (1/z)",
              xaxs = "i", yaxs = "i",
              nCores = 2) # Max. two cores on CRAN, not a limit for your use
  
riemannMask(annotNorth = FALSE, gridCross = FALSE, circOutline = FALSE,
            alphaMask = 0.7)
par(op)



</code></pre>

<hr>
<h2 id='vector2String'>Convert a vector into a comma-separated string</h2><span id='topic+vector2String'></span>

<h3>Description</h3>

<p>A simple utility function that transforms any vector into a single character
string, where the former vector elements are separated by commas. This is can
be useful, in some circumstances, for feeding a series of constant numeric
values to <code><a href="#topic+phasePortrait">phasePortrait</a></code> (see examples). For most applications
we recommend, however, to use <code><a href="#topic+phasePortrait">phasePortrait</a></code>'s parameter
<code>moreArgs</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector2String(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector2String_+3A_vec">vec</code></td>
<td>
<p>The (usually real or complex valued) vector to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string, where the former vector elements are separated by commas,
enclosed between &quot;c(&quot; and &quot;)&quot;.
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+xlimFromYlim">xlimFromYlim</a>()</code>,
<code><a href="#topic+ylimFromXlim">ylimFromXlim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a vector of 77 complex random numbers inside the unit circle
n &lt;- 77
a &lt;- complex(n, modulus = runif(n), argument = 2*pi*runif(n))
a &lt;- vector2String(a)
print(a)


# Use this for portraying a Blaschke product

# x11(width = 9.45, height = 6.30) # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
op &lt;- par(mar = c(1, 1, 1, 1), bg = "black")
n &lt;- 77
a &lt;- complex(n, modulus = runif(n), argument = 2*pi*runif(n))
a &lt;- vector2String(a)
FUN &lt;- paste("vapply(z, function(z, a){
                    return(prod(abs(a)/a * (a-z)/(1-Conj(a)*z)))
                   }, a =", a,
             ", FUN.VALUE = complex(1))", sep = "")
phasePortrait(FUN, pType = "p", axes = FALSE,
              xlim = c(-3, 3), ylim = c(-2.0, 2.0),
              nCores = 2) # Max. two cores allowed on CRAN
                          # not a limit for your own use
par(op)
  



</code></pre>

<hr>
<h2 id='xlimFromYlim'>Adjust xlim to ylim</h2><span id='topic+xlimFromYlim'></span>

<h3>Description</h3>

<p>This simple function is useful for adjusting x and y coordinate ranges
<code>xlim</code> and <code>ylim</code> in order to maintain a desired display ratio. The
latter must be given, the former will be adjusted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlimFromYlim(ylim, centerX = 0, x_to_y = 16/9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlimFromYlim_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2; the fixed lower and upper boundary
of the vertical coordinate range</p>
</td></tr>
<tr><td><code id="xlimFromYlim_+3A_centerx">centerX</code></td>
<td>
<p>The horizontal coordinate which the output range is to be
centered around (default = 0)</p>
</td></tr>
<tr><td><code id="xlimFromYlim_+3A_x_to_y">x_to_y</code></td>
<td>
<p>The desired ratio of the horizontal (x) to the vertical (y)
range. Default is 16/9, a display ratio frequently used for computer or
mobile screens</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For certain purposes, e.g. producing a graph that exactly matches a screen,
the x and y coordinates must be adjusted to match a given display ratio. If
the vertical range, <code>ylim</code>, the desired ratio, <code>x_to_y</code> and the
desired center of the x-range, <code>centerX</code>, are provided, this function
returns an adpated vertical range, that can be used as <code>ylim</code> in any
plot including <code><a href="#topic+phasePortrait">phasePortrait</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length 2; the lower and upper boundary of the
resulting vertical coordinate range
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+vector2String">vector2String</a>()</code>,
<code><a href="#topic+ylimFromXlim">ylimFromXlim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a phase portrait of a pretty function that fully covers a
# plot with a display aspect ratio of 5/4.

# 9 inch wide window with 5/4 display ratio (x/y)

# x11(width = 9, height = 9 * 4/5) # Screen device commented out
                                   # due to CRAN test requirements.
                                   # Use it when trying this example
ylim &lt;- c(-8, 7)
xlim &lt;- xlimFromYlim(ylim, centerX = 0, x_to_y = 5/4)
op &lt;- par(mar = c(0, 0, 0, 0), bg = "black") # Omit all plot margins
phasePortrait("exp(cosh(1/(z - 2i + 2)^2 * (1/2i - 1/4 + z)^3))", pType = "pm",
xlim = xlim, ylim = ylim, # Apply the coordinate ranges
xaxs = "i", yaxs = "i",   # Allow for now room between plot and axes
nCores = 2) # Max. two cores allowed on CRAN
            # not a limit for your own use
par(op)
  



</code></pre>

<hr>
<h2 id='ylimFromXlim'>Adjust ylim to xlim</h2><span id='topic+ylimFromXlim'></span>

<h3>Description</h3>

<p>This simple function is useful for adjusting x and y coordinate ranges
<code>xlim</code> and <code>ylim</code> in order to maintain a desired display ratio. The
former must be given, the latter will be adjusted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ylimFromXlim(xlim, centerY = 0, x_to_y = 16/9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ylimFromXlim_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2; the fixed lower and upper boundary
of the horizontal coordinate range</p>
</td></tr>
<tr><td><code id="ylimFromXlim_+3A_centery">centerY</code></td>
<td>
<p>The vertical coordinate which the output range is to be
centered around (default = 0)</p>
</td></tr>
<tr><td><code id="ylimFromXlim_+3A_x_to_y">x_to_y</code></td>
<td>
<p>The desired ratio of the horizontal (x) to the vertical (y)
range. Default is 16/9, a display ratio frequently used for computer or
mobile screens</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For certain purposes, e.g. producing a graph that exactly matches a screen,
the x and y coordinates must be adjusted to match a given display ratio. If
the horizontal range, <code>xlim</code>, the desired ratio, <code>x_to_y</code> and the
desired center of the y-range, <code>centerY</code> are provided, this function
returns an adapted vertical range, that can be used as <code>ylim</code> in any
plot including <code><a href="#topic+phasePortrait">phasePortrait</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length 2; the lower and upper boundary of the
resulting vertical coordinate range
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+vector2String">vector2String</a>()</code>,
<code><a href="#topic+xlimFromYlim">xlimFromYlim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a phase portrait of a Jacobi theta function that fully covers a
# plot with a display aspect ratio of 4/3.
# 10 inch wide window with 4/3 display ratio (x/y)

# x11(width = 10, height = 10 * 3/4) # Screen device commented out
                                     # due to CRAN test requirements.
                                     # Use it when trying this example
xlim &lt;- c(-3, 3)
ylim &lt;- ylimFromXlim(xlim, centerY = -0.3, x_to_y = 4/3)
op &lt;- par(mar = c(0, 0, 0, 0), bg = "black") # Omit all plot margins
phasePortrait(jacobiTheta, moreArgs = list(tau = 1i/2 - 1/3),
  xlim = xlim, ylim = ylim, # Apply the coordinate ranges
  xaxs = "i", yaxs = "i",   # Allow for now room between plot and axes
  nCores = 1) # Max. two cores allowed on CRAN
              # not a limit for your own use
par(op)
  



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
