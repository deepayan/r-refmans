<!DOCTYPE html><html><head><title>Help for package Rcpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rcpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.DollarNames-methods'><p> completion</p></a></li>
<li><a href='#C++Class-class'><p>Reflection information for an internal c++ class</p></a></li>
<li><a href='#C++Constructor-class'><p>Class &quot;C++Constructor&quot;</p></a></li>
<li><a href='#C++Field-class'><p>Class &quot;C++Field&quot;</p></a></li>
<li><a href='#C++Function-class'><p>Class &quot;C++Function&quot;</p></a></li>
<li><a href='#C++Object-class'><p>c++ internal objects</p></a></li>
<li><a href='#C++OverloadedMethods-class'><p>Class &quot;C++OverloadedMethods&quot;</p></a></li>
<li><a href='#compileAttributes'>
<p>Compile Rcpp Attributes for a Package</p></a></li>
<li><a href='#compilerCheck'><p>Check for Minimal (g++) Compiler Version</p></a></li>
<li><a href='#cppFunction'>
<p>Define an R Function with a C++ Implementation</p></a></li>
<li><a href='#demangle'>
<p>c++ type information</p></a></li>
<li><a href='#dependsAttribute'><p>Rcpp::depends Attribute</p></a></li>
<li><a href='#evalCpp'>
<p>Evaluate a C++ Expression</p></a></li>
<li><a href='#exportAttribute'><p>Rcpp::export Attribute</p></a></li>
<li><a href='#exposeClass'>
<p>Create an Rcpp Module to Expose a C++ Class in R</p></a></li>
<li><a href='#formals&lt;&ndash;methods'><p>Set the formal arguments of a C++ function</p></a></li>
<li><a href='#getRcppVersion'><p>Export the Rcpp (API) Package Version</p></a></li>
<li><a href='#interfacesAttribute'><p>Rcpp::interfaces Attribute</p></a></li>
<li><a href='#LdFlags-deprecated'><p>Deprecated Rcpp Linker Flags</p></a></li>
<li><a href='#loadModule'>
<p>Load an Rcpp Module into a Package</p></a></li>
<li><a href='#loadRcppModules-deprecated'>
<p>Loads Rcpp modules on package startup</p></a></li>
<li><a href='#Module'>
<p>Retrieves an Rcpp module</p></a></li>
<li><a href='#Module-class'><p>Rcpp modules</p></a></li>
<li><a href='#pluginsAttribute'><p>Rcpp::plugins Attribute</p></a></li>
<li><a href='#populate'>
<p>Populates a namespace or an environment with the content of a module</p></a></li>
<li><a href='#Rcpp-deprecated'><p>Deprecated Functions in the Rcpp Package</p></a></li>
<li><a href='#Rcpp-internal'><p>Rcpp internal functions</p></a></li>
<li><a href='#Rcpp-package'><p>R / C++ interface</p></a></li>
<li><a href='#Rcpp.package.skeleton'>
<p>Create a skeleton for a new package depending on Rcpp</p></a></li>
<li><a href='#Rcpp.plugin.maker'>
<p>Facilitating making package plugins</p></a></li>
<li><a href='#RcppUnitTests'><p>Rcpp : unit tests results</p></a></li>
<li><a href='#registerPlugin'>
<p>Register an inline plugin</p></a></li>
<li><a href='#setRcppClass'>
<p>Create a Class Extending a C++ Class</p></a></li>
<li><a href='#sourceCpp'>
<p>Source C++ Code from a File or String</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Seamless R and C++ Integration</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Eddelbuettel, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou,
 Nathan Russell, Inaki Ucar, Douglas Bates and John Chambers</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'Rcpp' package provides R functions as well as C++ classes which
 offer a seamless integration of R and C++. Many R data types and objects can be
 mapped back and forth to C++ equivalents which facilitates both writing of new
 code as well as easier integration of third-party libraries. Documentation
 about 'Rcpp' is provided by several vignettes included in this package, via the
 'Rcpp Gallery' site at <a href="https://gallery.rcpp.org">https://gallery.rcpp.org</a>, the paper by Eddelbuettel and
 Francois (2011, &lt;<a href="https://doi.org/10.18637%2Fjss.v040.i08">doi:10.18637/jss.v040.i08</a>&gt;), the book by Eddelbuettel (2013,
 &lt;<a href="https://doi.org/10.1007%2F978-1-4614-6868-4">doi:10.1007/978-1-4614-6868-4</a>&gt;) and the paper by Eddelbuettel and Balamuta (2018,
 &lt;<a href="https://doi.org/10.1080%2F00031305.2017.1375990">doi:10.1080/00031305.2017.1375990</a>&gt;); see 'citation("Rcpp")' for details.</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, inline, rbenchmark, pkgKitten (&ge; 0.1.2)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rcpp.org">https://www.rcpp.org</a>,
<a href="https://dirk.eddelbuettel.com/code/rcpp.html">https://dirk.eddelbuettel.com/code/rcpp.html</a>,
<a href="https://github.com/RcppCore/Rcpp">https://github.com/RcppCore/Rcpp</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RcppCore/Rcpp/issues">https://github.com/RcppCore/Rcpp/issues</a></td>
</tr>
<tr>
<td>MailingList:</td>
<td>rcpp-devel@lists.r-forge.r-project.org</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 12:50:16 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 08:20:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='.DollarNames-methods'> completion </h2><span id='topic+.DollarNames-methods'></span><span id='topic+.DollarNames+2CANY-method'></span><span id='topic+.DollarNames+2CC+2B+2BObject-method'></span><span id='topic+.DollarNames+2CModule-method'></span>

<h3>Description</h3>

<p>completion
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "C++Object")</code></dt><dd>
<p>completes fields and methods of C++ objects
</p>
</dd>
<dt><code>signature(x = "Module")</code></dt><dd>
<p>completes functions and classes of modules
</p>
</dd>
</dl>

<hr>
<h2 id='C+2B+2BClass-class'>Reflection information for an internal c++ class</h2><span id='topic+C+2B+2BClass-class'></span><span id='topic++24+2CC+2B+2BClass-method'></span><span id='topic+show+2CC+2B+2BClass-method'></span>

<h3>Description</h3>

<p>Information about an internal c++ class.
</p>


<h3>Objects from the Class</h3>

<p>Objects are usually extracted from a <a href="#topic+Module-class">Module</a>
using the dollar extractor.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>mangled name of the class</p>
</dd>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the internal infomation</p>
</dd>
<dt><code>module</code>:</dt><dd><p>external pointer to the module</p>
</dd>
<dt><code>fields</code>:</dt><dd><p>list of <a href="#topic+C+2B+2BField-class">C++Field</a> objects</p>
</dd>
<dt><code>constructors</code>:</dt><dd><p>list of <a href="#topic+C+2B+2BConstructor-class">C++Constructor</a> objects</p>
</dd>
<dt><code>methods</code>:</dt><dd><p>list of <a href="#topic+C+2B+2BOverloadedMethods-class">C++OverloadedMethods</a> objects</p>
</dd>
<dt>generator</dt><dd><p>the generator object for the class</p>
</dd>
<dt>docstring</dt><dd><p>description of the class</p>
</dd>
<dt>typeid</dt><dd><p>unmangled typeid of the class</p>
</dd>
<dt>enums</dt><dd><p>enums of the class</p>
</dd>
<dt>parents</dt><dd><p>names of the parent classes of this class</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "C++Class")</code>: prints the class. </p>
</dd>
<dt>$</dt><dd><p><code>signature(object = "C++Class")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='C+2B+2BConstructor-class'>Class &quot;C++Constructor&quot;</h2><span id='topic+C+2B+2BConstructor-class'></span>

<h3>Description</h3>

<p>Representation of a C++ constructor
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+.environment-class">.environment</a>"</code>, by class &quot;envRefClass&quot;, distance 2.
Class <code>"<a href="methods.html#topic+refClass-class">refClass</a>"</code>, by class &quot;envRefClass&quot;, distance 2.
Class <code>"<a href="methods.html#topic+environment-class">environment</a>"</code>, by class &quot;envRefClass&quot;, distance 3, with explicit coerce.
Class <code>"<a href="methods.html#topic+refObject-class">refObject</a>"</code>, by class &quot;envRefClass&quot;, distance 3.
</p>


<h3>Fields</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>pointer to the internal structure that represent the constructor</p>
</dd>
<dt><code>class_pointer</code>:</dt><dd><p>pointer to the internal structure that represent the associated C++ class</p>
</dd>
<dt><code>nargs</code>:</dt><dd><p>Number of arguments the constructor expects</p>
</dd>
<dt><code>signature</code>:</dt><dd><p>C++ signature of the constructor</p>
</dd>
<dt><code>docstring</code>:</dt><dd><p>Short description of the constructor</p>
</dd>
</dl>


<hr>
<h2 id='C+2B+2BField-class'>Class &quot;C++Field&quot;</h2><span id='topic+C+2B+2BField-class'></span>

<h3>Description</h3>

<p>Metadata associated with a field of a class exposed through Rcpp modules
</p>


<h3>Fields</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>external pointer to the internal (C++) object that represents fields</p>
</dd>
<dt><code>cpp_class</code>:</dt><dd><p>(demangled) name of the C++ class of the field</p>
</dd>
<dt><code>read_only</code>:</dt><dd><p>Is this field read only</p>
</dd>
<dt><code>class_pointer</code>:</dt><dd><p>external pointer to the class this field is from. </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;C++Field&quot; in the signature.
</p>


<h3>See Also</h3>

<p>The <code>fields</code> slot of the <code><a href="#topic+C+2B+2BClass-class">C++Class</a></code> class is a 
list of <code>C++Field</code> objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("C++Field")
</code></pre>

<hr>
<h2 id='C+2B+2BFunction-class'>Class &quot;C++Function&quot;</h2><span id='topic+C+2B+2BFunction-class'></span><span id='topic+show+2CC+2B+2BFunction-method'></span>

<h3>Description</h3>

<p>Internal C++ function
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by the <code>Rcpp::InternalFunction</code>
class from the <code>Rcpp</code> library
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>R function that calls back to the internal function</p>
</dd>
<dt><code>pointer</code>:</dt><dd><p>External pointer to a C++ object poiting to the function</p>
</dd>
<dt><code>docstring</code>:</dt><dd><p>Short documentation for the function</p>
</dd>
<dt><code>signature</code>:</dt><dd><p>C++ signature</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+function-class">function</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+OptionalFunction-class">OptionalFunction</a>"</code>, by class &quot;function&quot;, distance 2.
Class <code>"<a href="methods.html#topic+PossibleMethod-class">PossibleMethod</a>"</code>, by class &quot;function&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "C++Function")</code>: print the object </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("C++Function")
</code></pre>

<hr>
<h2 id='C+2B+2BObject-class'>c++ internal objects</h2><span id='topic+C+2B+2BObject-class'></span><span id='topic++24+2CC+2B+2BObject-method'></span><span id='topic++24+3C-+2CC+2B+2BObject-method'></span><span id='topic+show+2CC+2B+2BObject-method'></span>

<h3>Description</h3>

<p>C++ internal objects instanciated from a class exposed in an Rcpp module
</p>


<h3>Objects from the Class</h3>

<p>This is a virtual class.  Actual C++ classes are subclasses.
</p>


<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "C++Object")</code>: invokes a method on the object, or retrieves the value of a property </p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "C++Object")</code>: set the value of a property </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "C++Object")</code>: print the object </p>
</dd>
</dl>


<hr>
<h2 id='C+2B+2BOverloadedMethods-class'>Class &quot;C++OverloadedMethods&quot;</h2><span id='topic+C+2B+2BOverloadedMethods-class'></span>

<h3>Description</h3>

<p>Set of C++ methods
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+.environment-class">.environment</a>"</code>, by class &quot;envRefClass&quot;, distance 2.
Class <code>"<a href="methods.html#topic+refClass-class">refClass</a>"</code>, by class &quot;envRefClass&quot;, distance 2.
Class <code>"<a href="methods.html#topic+environment-class">environment</a>"</code>, by class &quot;envRefClass&quot;, distance 3, with explicit coerce.
Class <code>"<a href="methods.html#topic+refObject-class">refObject</a>"</code>, by class &quot;envRefClass&quot;, distance 3.
</p>


<h3>Fields</h3>


<dl>
<dt><code>pointer</code>:</dt><dd><p>Object of class <code>externalptr</code> pointer to the internal structure that represents the set of methods </p>
</dd>
<dt><code>class_pointer</code>:</dt><dd><p>Object of class <code>externalptr</code> pointer to the internal structure that models the related class </p>
</dd>
</dl>


<hr>
<h2 id='compileAttributes'>
Compile Rcpp Attributes for a Package
</h2><span id='topic+compileAttributes'></span>

<h3>Description</h3>

<p>Scan the source files within a package for attributes and generate code as required. Generates the bindings required to call C++ functions from R for functions adorned with the <code>Rcpp::export</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileAttributes(pkgdir = ".", verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compileAttributes_+3A_pkgdir">pkgdir</code></td>
<td>

<p>Directory containing the package to compile attributes for (defaults to the current working directory).
</p>
</td></tr>
<tr><td><code id="compileAttributes_+3A_verbose">verbose</code></td>
<td>

<p><code>TRUE</code> to print detailed information about generated code to the console.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The source files in the package directory given by <code>pkgdir</code> are scanned for attributes and code is generated as required based on the attributes. 
</p>
<p>For C++ functions adorned with the <code>Rcpp::export</code> attribute, the C++ and R source code required to bind to the function from R is generated and added (respectively) to <code>src/RcppExports.cpp</code> or <code>R/RcppExports.R</code>. Both of these files are automatically generated from <em>scratch</em> each time <code>compiledAttributes</code> is run.
</p>
<p>In order to access the declarations for custom <code>Rcpp::as</code> and <code>Rcpp::wrap</code> handlers the <code>compileAttributes</code> function will also call any <a href="inline.html#topic+plugins">inline plugins</a> available for packages listed in the <code>LinkingTo</code> field of the <code>DESCRIPTION</code> file.
</p>


<h3>Value</h3>

<p>Returns (invisibly) a character vector with the paths to any files that were updated as a result of the call.
</p>


<h3>Note</h3>

<p>The <code>compileAttributes</code> function deals only with exporting C++ functions to R. If you want the functions to additionally be publicly available from your package's namespace another step may be required. Specifically, if your package <code>NAMESPACE</code> file does not use a pattern to export functions then you should add an explicit entry to <code>NAMESPACE</code> for each R function you want publicly available.
</p>
<p>In addition to exporting R bindings for C++ functions, the <code>compileAttributes</code> function can also generate a direct C++ interface to the functions using the <code><a href="#topic+interfacesAttribute">Rcpp::interfaces</a></code> attribute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exportAttribute">Rcpp::export</a></code>, <code><a href="#topic+interfacesAttribute">Rcpp::interfaces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Compile attributes for package in the current working dir
compileAttributes()

## End(Not run)
</code></pre>

<hr>
<h2 id='compilerCheck'>Check for Minimal (g++) Compiler Version</h2><span id='topic+compilerCheck'></span>

<h3>Description</h3>

<p>Helper function to establish minimal compiler versions, currently limited
only to <code>g++</code> which (particularly for older RHEL/CentOS releases) is
too far behind current C++11 standards required for some packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compilerCheck(minVersion = package_version("4.6.0"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compilerCheck_+3A_minversion">minVersion</code></td>
<td>
<p>An object of type <code>package_version</code>, with a default
of version 4.6.0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks up <code>g++</code> (as well as optional values in the
<code>CXX</code> and <code>CXX1X</code> environment variables) in the <code>PATH</code>.  For
all values found, the output of <code>g++ -v</code> is analyzed for the version
string, which is then compared to the given minimal version.
</p>


<h3>Value</h3>

<p>A boolean value is returned, indicating if the minimal version is
being met
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>

<hr>
<h2 id='cppFunction'>
Define an R Function with a C++ Implementation
</h2><span id='topic+cppFunction'></span>

<h3>Description</h3>

<p>Dynamically define an R function with C++ source code. Compiles and links a shared library with bindings to the C++ function then defines an R function that uses <code>.Call</code> to invoke the library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cppFunction(code, depends = character(), plugins = character(), includes = character(),
            env = parent.frame(), rebuild = FALSE, cacheDir = getOption("rcpp.cache.dir",
            tempdir()), showOutput = verbose, verbose = getOption("verbose"), echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cppFunction_+3A_code">code</code></td>
<td>

<p>Source code for the function definition.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_depends">depends</code></td>
<td>

<p>Character vector of packages that the compilation depends on. Each package listed will first be queried for an <a href="inline.html#topic+plugins">inline plugin</a> to determine header files to include. If no plugin is defined for the package then a header file based the package's name (e.g. <code>PkgName.h</code>) will be included.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_plugins">plugins</code></td>
<td>

<p>Character vector of <a href="inline.html#topic+plugins">inline plugins</a> to use for the compilation.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_includes">includes</code></td>
<td>

<p>Character vector of user includes (inserted after the includes provided by <code>depends</code>).
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_env">env</code></td>
<td>

<p>The <a href="base.html#topic+environment">environment</a> in which to define the R function. May be <code>NULL</code> in which case the defined function can be obtained from the return value of <code>cppFunction</code>.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_rebuild">rebuild</code></td>
<td>

<p>Force a rebuild of the shared library.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_cachedir">cacheDir</code></td>
<td>

<p>Directory to use for caching shared libraries. If the underlying code passed to <code>sourceCpp</code> has not changed since the last invocation then a cached version of the shared library is used. The default value of <code>tempdir()</code> results in the cache being valid only for the current R session. Pass an alternate directory to preserve the cache across R sessions.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_showoutput">showOutput</code></td>
<td>

<p><code>TRUE</code> to print <code>R CMD SHLIB</code> output to the console.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_verbose">verbose</code></td>
<td>

<p><code>TRUE</code> to print detailed information about generated code to the console.
</p>
</td></tr>
<tr><td><code id="cppFunction_+3A_echo">echo</code></td>
<td>

<p><code>TRUE</code> to silence output from optional R evaluation if set to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions defined using <code>cppFunction</code> must have return types that are compatible with <code>Rcpp::wrap</code> and parameter types that are compatible with <code>Rcpp::as</code>.
</p>
<p>The shared library will not be rebuilt if the underlying code has not changed since the last compilation.
</p>


<h3>Value</h3>

<p>An R function that uses <code>.Call</code> to invoke the underlying C++ function.
</p>


<h3>Note</h3>

<p>You can also define R functions with C++ implementations using the <code><a href="#topic+sourceCpp">sourceCpp</a></code> function, which allows you to separate the C++ code into it's own source file. For many use cases this is an easier and more maintainable approach.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sourceCpp">sourceCpp</a></code>,  <code><a href="#topic+evalCpp">evalCpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

cppFunction(
    'int fibonacci(const int x) {
        if (x == 0) return(0);
        if (x == 1) return(1);
        return (fibonacci(x - 1)) + fibonacci(x - 2);
    }')

cppFunction(depends = "RcppArmadillo",
    'List fastLm(NumericVector yr, NumericMatrix Xr) {

        int n = Xr.nrow(), k = Xr.ncol();

        arma::mat X(Xr.begin(), n, k, false);
        arma::colvec y(yr.begin(), yr.size(), false);

        arma::colvec coef = arma::solve(X, y);
        arma::colvec resid = y - X*coef;

        double sig2 = arma::as_scalar(arma::trans(resid)*resid/(n-k) );
        arma::colvec stderrest = arma::sqrt(
            sig2 * arma::diagvec(arma::inv(arma::trans(X)*X)));

        return List::create(Named("coefficients") = coef,
            Named("stderr")       = stderrest
        );
    }')

cppFunction(plugins=c("cpp11"), '
    int useCpp11() {
        auto x = 10;
        return x;
    }')


## End(Not run)
</code></pre>

<hr>
<h2 id='demangle'>
c++ type information 
</h2><span id='topic+demangle'></span><span id='topic+sizeof'></span><span id='topic+print.bytes'></span>

<h3>Description</h3>

<p><code>demangle</code> gives the demangled type, <code>sizeof</code> its size (in bytes). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    demangle(type = "int", ...)
    sizeof(type = "int", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demangle_+3A_type">type</code></td>
<td>
<p>The type we want to demangle</p>
</td></tr>
<tr><td><code id="demangle_+3A_...">...</code></td>
<td>
<p>Further argument for <code><a href="#topic+cppFunction">cppFunction</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following function is compiled and invoked: 
</p>
<pre>
        SEXP demangle_this_type(){
            typedef 
            return wrap( DEMANGLE(type) ) ;
        }
        
        SEXP sizeof_this_type(){
            typedef 
            return wrap( sizeof(type) ) ;
        }
    </pre>    
<p><code>DEMANGLE</code> is a macro in &lsquo;<span class="samp">&#8288;Rcpp&#8288;</span>&rsquo; that does the work. 
</p>


<h3>Value</h3>

<p>The demangled type, as a string. 
</p>


<h3>Note</h3>

<p>We only know how to demangle with gcc. If you know how to demangle types
with your compiler, let us know. 
</p>


<h3>Author(s)</h3>

<p>Romain Francois &lt;romain@r-enthusiasts.com&gt;
</p>


<h3>References</h3>

<p>See this <a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html">chapter</a>
from the GNU C++ library manual. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cppFunction">cppFunction</a></code> is used to compile the function <code>demangle</code> creates. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    demangle( "int64_t" )
    demangle( "uint64_t" )

    demangle( "NumericVector" )
    demangle( "std::map&lt;std::string,double&gt;" )
    
    sizeof( "long" )
    sizeof( "long long" )
    

## End(Not run)
</code></pre>

<hr>
<h2 id='dependsAttribute'>Rcpp::depends Attribute</h2><span id='topic+dependsAttribute'></span>

<h3>Description</h3>

<p>The <code>Rcpp::depends</code> attribute is added to a C++ source file to indicate that it has a compilation dependency on one or more other packages. For example:
</p>
<pre>
// [[Rcpp::depends(RcppArmadillo)]]
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dependsAttribute_+3A_...">...</code></td>
<td>

<p>Packages which the source file depends on for compilation
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Rcpp::depends</code> attribute is used by the implementation of the <code><a href="#topic+sourceCpp">sourceCpp</a></code> function to correctly setup the build environment for <code>R CMD SHLIB</code>.
</p>
<p>The include directories of the specified packages are added to the <code>CLINK_CPPFLAGS</code> environment variable. In addition, if the referenced package provides an <a href="inline.html#topic+plugins">inline plugin</a> it is called to determine additional environment variables required to successfully build.
</p>


<h3>Note</h3>

<p>The <code>Rcpp::depends</code> attribute is specified using a syntax compatible with the new <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">generalized attributes</a> feature of the C++11 standard. Note however that since this feature is not yet broadly supported by compilers it needs to be specified within a comment (see examples below).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sourceCpp">sourceCpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

// [[Rcpp::depends(RcppArmadillo)]]

// [[Rcpp::depends(Matrix, RcppGSL)]]

## End(Not run)
</code></pre>

<hr>
<h2 id='evalCpp'>
Evaluate a C++ Expression
</h2><span id='topic+evalCpp'></span><span id='topic+areMacrosDefined'></span>

<h3>Description</h3>

<p>Evaluates a C++ expression. This creates a C++ function using 
<code><a href="#topic+cppFunction">cppFunction</a></code> and calls it to get the result. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalCpp(code, depends = character(), plugins = character(), includes = character(), 
        rebuild = FALSE, cacheDir = getOption("rcpp.cache.dir", tempdir()),
        showOutput = verbose, verbose = getOption("verbose"))

areMacrosDefined(names, depends = character(), includes = character(), 
        rebuild = FALSE, showOutput = verbose, 
        verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalCpp_+3A_code">code</code></td>
<td>

<p>C++ expression to evaluate
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_names">names</code></td>
<td>

<p>names of the macros we want to test
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_plugins">plugins</code></td>
<td>

<p>see <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_depends">depends</code></td>
<td>

<p>see <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_includes">includes</code></td>
<td>

<p>see <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_rebuild">rebuild</code></td>
<td>

<p>see <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_cachedir">cacheDir</code></td>
<td>

<p>Directory to use for caching shared libraries. If the underlying code passed to <code>sourceCpp</code> has not changed since the last invocation then a cached version of the shared library is used. The default value of <code>tempdir()</code> results in the cache being valid only for the current R session. Pass an alternate directory to preserve the cache across R sessions.
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_showoutput">showOutput</code></td>
<td>

<p>see <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
<tr><td><code id="evalCpp_+3A_verbose">verbose</code></td>
<td>

<p>see <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the evaluated C++ expression. 
</p>


<h3>Note</h3>

<p>The result type of the C++ expression must be compatible with <code>Rcpp::wrap</code>.     
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sourceCpp">sourceCpp</a></code>, <code><a href="#topic+cppFunction">cppFunction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

evalCpp( "__cplusplus" )
evalCpp( "std::numeric_limits&lt;double&gt;::max()" )
    
areMacrosDefined( c("__cplusplus", "HAS_TR1" ) )


## End(Not run)
</code></pre>

<hr>
<h2 id='exportAttribute'>Rcpp::export Attribute</h2><span id='topic+exportAttribute'></span>

<h3>Description</h3>

<p>The <code>Rcpp::export</code> attribute is added to a C++ function definition to indicate that it should be made available as an R function. The <code><a href="#topic+sourceCpp">sourceCpp</a></code> and <code><a href="#topic+compileAttributes">compileAttributes</a></code> functions process the <code>Rcpp::export</code> attribute by generating the code required to call the C++ function from R.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportAttribute_+3A_name">name</code></td>
<td>

<p>Specify an alternate name for the generated R function (optional, defaults to the name of the C++ function if not specified).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions marked with the <code>Rcpp::export</code> attribute must meet several conditions to be correctly handled:
</p>

<ol>
<li><p> Be defined in the global namespace (i.e. not within a C++ <code>namespace</code> declaration).
</p>
</li>
<li><p> Have a return type that is either void or compatible with <code>Rcpp::wrap</code> and parameter types that are compatible with <code>Rcpp::as</code> (see sections 3.1 and 3.2 of the <em>Rcpp-introduction</em> vignette for more details).
</p>
</li>
<li><p> Use fully qualified type names for the return value and all parameters. However, Rcpp types may appear without the namespace qualifier (i.e. <code>DataFrame</code> is okay as a type name but <code>std::string</code> must be specified fully).
</p>
</li></ol>

<p>If default argument values are provided in the C++ function definition then these defaults are also used for the exported R function. For example, the following C++ function:
</p>
<pre>
DataFrame readData(
    CharacterVector file,
    CharacterVector exclude = CharacterVector::create(),
    bool fill = true)
</pre>
<p>Will be exported to R as:
</p>
<pre>
function (file, exclude = character(0), fill = TRUE)
</pre>
<p>Note that C++ rules for default arguments still apply: they must occur consecutively at the end of the function signature and unlike R can't rely on the values of other arguments.
</p>


<h3>Note</h3>

<p>When a C++ function has export bindings automatically generated by the <code><a href="#topic+compileAttributes">compileAttributes</a></code> function, it can optionally also have a direct C++ interface generated using the <code><a href="#topic+interfacesAttribute">Rcpp::interfaces</a></code> attribute.
</p>
<p>o    The <code>Rcpp::export</code> attribute is specified using a syntax compatible with the new <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">generalized attributes</a> feature of the C++11 standard. Note however that since this feature is not yet broadly supported by compilers it needs to be specified within a comment (see examples below).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sourceCpp">sourceCpp</a></code> and <code><a href="#topic+compileAttributes">compileAttributes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#include &lt;Rcpp.h&gt;

using namespace Rcpp;

// [[Rcpp::export]]
int fibonacci(const int x) {

   if (x == 0) return(0);
   if (x == 1) return(1);

   return (fibonacci(x - 1)) + fibonacci(x - 2);
}

// [[Rcpp::export("convolveCpp")]]
NumericVector convolve(NumericVector a, NumericVector b) {

   int na = a.size(), nb = b.size();
   int nab = na + nb - 1;
   NumericVector xab(nab);

   for (int i = 0; i &lt; na; i++)
      for (int j = 0; j &lt; nb; j++)
         xab[i + j] += a[i] * b[j];

   return xab;
}

## End(Not run)
</code></pre>

<hr>
<h2 id='exposeClass'>
Create an Rcpp Module to Expose a C++ Class in R
</h2><span id='topic+exposeClass'></span>

<h3>Description</h3>

<p>The arguments specify a C++ class and some combination of
constructors, fields and methods to be shared with <span class="rlang"><b>R</b></span> by creating a
corresponding reference class in <span class="rlang"><b>R</b></span>.
The information needed in the call to <code>exposeClass()</code> is the
simplest possible in order to create a C++ module for the class; for
example, fields and methods in this class need only be identified by
their name.
Inherited fields and methods can also be included, but more
information is needed.
The function writes a C++ source file,
containing a module definition to expose the class to
<span class="rlang"><b>R</b></span>, plus one line of <span class="rlang"><b>R</b></span> source to create the corresponding reference
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposeClass(class, constructors = , fields = , methods = , file = ,
    header = , module = , CppClass = class, readOnly = , rename = ,
    Rfile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exposeClass_+3A_class">class</code></td>
<td>

<p>The name of the class in <span class="rlang"><b>R</b></span>.  By default, this will be the same as the
name of the class in C++, unless argument <code>CppClass</code> is supplied.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_constructors">constructors</code></td>
<td>

<p>A list of the signatures for any of the class constructors to be
called from <span class="rlang"><b>R</b></span>.  Each element of the list gives the data types in C++
for the arguments to the corresponding constructor.  See Details and
the example.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_fields">fields</code>, <code id="exposeClass_+3A_methods">methods</code></td>
<td>

<p>The vector of names for the fields and for the methods to be exposed
in <span class="rlang"><b>R</b></span>.  For inherited fields and methods, type information needs to be
supplied; see the section &ldquo;Inherited Fields and Methods&rdquo;.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_file">file</code></td>
<td>

<p>Usually, the name for the file on which to write the C++ code,  by default
<code>paste0(CppClass, "Module.cpp")</code>.
If the current working directory in <span class="rlang"><b>R</b></span> is the top-level
directory for a package, the function writes the file in the
<code>"src"</code> subdirectory.
Otherwise the file is written in the working directory.
</p>
<p>The argument may also be a connection, already open for writing.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_header">header</code></td>
<td>

<p>Whatever lines of C++ header information are needed to include the
definition of the class.  Typically this includes a file from the
package where we are writing the module definition, as in the example below.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_module">module</code></td>
<td>

<p>The name for the Rcpp module,   by default
<code>paste0("class_",CppClass)</code>.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_cppclass">CppClass</code></td>
<td>

<p>The name for the class in C++.  By default and usually, the intended
class name in <span class="rlang"><b>R</b></span>.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_readonly">readOnly</code></td>
<td>

<p>Optional vector of field names.  These fields will be created as
read-only in the interface.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_rename">rename</code></td>
<td>

<p>Optional named character vector, used to name fields or methods
differently in <span class="rlang"><b>R</b></span> from their C++ name.  The elements of the vector are
the C++ names and the corresponding elements of <code>names(rename)</code>
the desired names in <span class="rlang"><b>R</b></span>.  So <code>c(.age = "age")</code> renames the C++
field or method <code>age</code> as <code>.age</code>.
</p>
</td></tr>
<tr><td><code id="exposeClass_+3A_rfile">Rfile</code></td>
<td>

<p>Controls the writing of a one-line <span class="rlang"><b>R</b></span> command to create the reference
class corresponding to the C++ module information.  By default, this
will be a file <code>paste0(class, "Class.R")</code>.
If the working directory is an <span class="rlang"><b>R</b></span> package source
directory, the file will be written in the <code>R</code> subdirectory, otherwise in the working directory itself.
</p>
<p>Supplying a character string substitutes that file name for the
default.
</p>
<p>The argument may also be a connection  open for
writing or <code>FALSE</code> to suppress writing the <span class="rlang"><b>R</b></span> source altogether.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file created by the call to these functions only depends on the
information in the C++ class supplied.  This file is intended to be
part of the C++ source for an <span class="rlang"><b>R</b></span> package.  The file only needs to
modified when the information changes, either because the class has
changed or because you want to expose different information to <span class="rlang"><b>R</b></span>.  In
that case you can either recall <code>exposeClass()</code> or edit the C++
file created.
</p>
<p>The Rcpp Module mechanism has a number of other optional techniques,
not covered by <code>exposeClass()</code>.  These should be entered into the
C++ file created.  See the &ldquo;rcpp-modules&rdquo; vignette with the
package for current possibilities.
</p>
<p>For fields and methods specified directly in the C++ class,
the fields and method arguments to <code>exposeClass()</code> are character vectors naming the
corresponding members of the class.  For module construction, the
data types of directly specified fields and of the arguments for the methods are not
needed.
</p>
<p>For <em>inherited</em> fields or methods, data type information is
needed.  See the section &ldquo;Inherited Fields and Methods&rdquo;.
</p>
<p>For exposing class constructors, the module needs to know the
signatures of the constructors to be exposed; each signature is a
character vector of the corresponding C++ data types.
</p>


<h3>Value</h3>

<p>Nothing, called for its side effect.
</p>


<h3>Inherited Fields and Methods</h3>

<p>If the C++ class inherits from one or more other classes, the standard
Rcpp <code>Module</code> mechanism can not be used to expose inherited
fields or methods.
An indirect mechanism is used, generating free functions in C++ to
expose the inherited members in <span class="rlang"><b>R</b></span>.
</p>
<p>This mechanism requires data type information in the call to
<code>exposeClass()</code>.
This is provided by naming the corresponding element of the
<code>fields</code> or <code>methods</code> argument with the name of the member.
The actual element of the <code>fields</code> argument is then the single
data type of the field.
</p>
<p>For the <code>methods</code> argument the argument will generally need to be
a named list.
The corresponding element of the list is the vector of data types for
the return value and for the arguments, if any, to the method.
For example, if C++ method <code>foo()</code> took a single argument of type
<code>NumericVector</code> and returned a value of type <code>long</code>, the
<code>methods</code> argument would be <code>list(foo = c("long",
  "NumericVector"))</code>.
</p>
<p>See the second example below.
</p>


<h3>Author(s)</h3>

<p>John Chambers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setRcppClass">setRcppClass</a></code>, which must be called from some <span class="rlang"><b>R</b></span> source
in the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Given the following C++ class, defined in file PopBD.h,
### the call to exposeClass() shown below will write a file
### src/PopBDModule.cpp containing a corresponding module definition.
###   class PopBD {
###     public:
###       PopBD(void);
###       PopBD(NumericVector initBirth, NumericVector initDeath);
###   
###       std::vector&lt;double&gt; birth;
###       std::vector&lt;double&gt; death;
###       std::vector&lt;int&gt; lineage;
###       std::vector&lt;long&gt; size;
###       void evolve(int);
###   
###   };
### A file R/PopBDClass.R will be written containing the one line:
###   PopBD &lt;- setRcppClass("PopBD")
###
### The call below exposes the lineage and size fields, read-only,
### and the evolve() method.

exposeClass("PopBD",
      constructors =
        list("", c("NumericVector", "NumericVector")),
      fields = c("lineage", "size"),
      methods = "evolve",
      header = '#include "PopBD.h"',
      readOnly = c("lineage", "size"))

### Example with inheritance:  the class PopCount inherits from 
### the previous class, and adds a method table().  It has the same
### constructors as the previous class.
### To expose the table() method, and the inherited evolve() method and size field:

exposeClass("PopCount",
      constructors =
        list("", c("NumericVector", "NumericVector")),
      fields = c(size = "std::vector&lt;long&gt;"),
      methods = list("table", evolve = c("void", "int")),
      header = '#include "PopCount.h"',
      readOnly = "size")

## End(Not run)
</code></pre>

<hr>
<h2 id='formals+26lt+3B+26ndash+3Bmethods'>Set the formal arguments of a C++ function</h2><span id='topic+formals+3C--methods'></span><span id='topic+formals+3C-+2CC+2B+2BFunction-method'></span>

<h3>Description</h3>

<p>Set the formal arguments of a C++ function
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(fun = "C++Function")</code></dt><dd>
<p>Set the formal arguments of a C++ function
</p>
</dd>
</dl>

<hr>
<h2 id='getRcppVersion'>Export the Rcpp (API) Package Version</h2><span id='topic+getRcppVersion'></span>

<h3>Description</h3>

<p>Helper function to report the package version of the R installation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRcppVersion(devel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRcppVersion_+3A_devel">devel</code></td>
<td>
<p>An logical value indicating if the development or
release version number should be returned, default is release.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code>packageVersion(Rcpp)</code> exports the version registers in
<code>DESCRIPTION</code>, this version does get incremented more easily
during development and can therefore be higher than the released
version.  The actual <code>#define</code> long used at the C++ level
corresponds more to an &lsquo;API Version&rsquo; which is now provided
by this function, and use for example in the package skeleton
generator.
</p>


<h3>Value</h3>

<p>A <code>package_version</code> object with either the release
or development version.
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+packageVersion">packageVersion</a></code>,
<code><a href="#topic+Rcpp.package.skeleton">Rcpp.package.skeleton</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getRcppVersion()
</code></pre>

<hr>
<h2 id='interfacesAttribute'>Rcpp::interfaces Attribute</h2><span id='topic+interfacesAttribute'></span>

<h3>Description</h3>

<p>The <code>Rcpp::interfaces</code> attribute is added to a C++ source file to specify which languages to generate bindings for from exported functions. For example:
</p>
<pre>
// [[Rcpp::interfaces(r, cpp)]]
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interfacesAttribute_+3A_...">...</code></td>
<td>

<p>Interfaces to generate for exported functions within the source file. Valid values are <code>r</code> and <code>cpp</code>, and more than one interface can be specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Rcpp::interfaces</code> attribute is used to determine which bindings to generate for exported functions. The default behavior if no <code>Rcpp::interfaces</code> attribute is specified is to generate only an R interface.
</p>
<p>When <code>cpp</code> bindings are requested code is generated as follows:
</p>

<ol>
<li><p> Bindings are generated into a header file located in the <code>inst/include</code> directory of the package using the naming convention <em>PackageName_RcppExports.h</em>
</p>
</li>
<li><p> If not already present, an additional header file named <em>PackageName.h</em> is also generated which in turn includes the Rcpp exports header.
</p>
<p>In the case that you already have a <em>PackageName.h</em> header for your package then you can manually add an include of the Rcpp exports header to it to make the exported functions available to users of your package.
</p>
</li>
<li><p> The generated header file allows calling the exported C++ functions without any linking dependency on the package (this is based on using the <code>R_RegisterCCallable</code> and <code>R_GetCCallable</code> functions).
</p>
</li>
<li><p> The exported functions are defined within a C++ namespace that matches the name of the package.
</p>
</li></ol>

<p>For example, an exported C++ function <code>foo</code> could be called from package <code>MyPackage</code> as follows:
</p>
<pre>
   // [[Rcpp::depends(MyPackage)]]

   #include &lt;MyPackage.h&gt;

   void foo() {
      MyPackage::bar();
   }
</pre>
<p>The above example assumes that the <code>sourceCpp</code> function will be used to compile the code. If rather than that you are building a package then you don't need to include the <code>Rcpp::depends</code> attribute, but instead should add an entry for the referenced package in the <code>Depends</code> and <code>LinkingTo</code> fields of your package's <code>DESCRIPTION</code> file.
</p>


<h3>Note</h3>

<p>If a file by the name of <em>PackageName.h</em> that wasn't generated by <code>compileAttributes</code> already exists in in the <code>inst/include</code> directory then it will not be overwritten (rather, an error will occur).
</p>
<p>A static naming scheme for generated header files and namespaces is used to ensure consistent usage semantics for clients of exported <code>cpp</code> interfaces. Packages that wish to export more complex interfaces or additional C++ types are therefore typically better off not using this mechanism.
</p>
<p>The <code>Rcpp::interfaces</code> attribute is specified using a syntax compatible with the new <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">generalized attributes</a> feature of the C++11 standard. Note however that since this feature is not yet broadly supported by compilers it needs to be specified within a comment (see examples below).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compileAttributes">compileAttributes</a></code>, <code><a href="#topic+exportAttribute">Rcpp::export</a></code>, <code><a href="#topic+dependsAttribute">Rcpp::depends</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

// [[Rcpp::interfaces(r, cpp)]]

## End(Not run)
</code></pre>

<hr>
<h2 id='LdFlags-deprecated'>Deprecated Rcpp Linker Flags</h2><span id='topic+LdFlags'></span><span id='topic+RcppLdFlags'></span>

<h3>Description</h3>

<p>In Rcpp versions prior to release 0.10.1 of November 2013,
<code>LdFlags</code> and <code>RcppLdFlags</code> were used to return the required
flags and options for the system linker to link to the Rcpp user
library. Since we no longer build or ship a user library, these
functions now return an empty string. As of Rcpp release 0.12.19,
these functions are now deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LdFlags()
  RcppLdFlags()
</code></pre>


<h3>Value</h3>

<p>An empty string.
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel and Romain Francois</p>


<h3>References</h3>

<p>Dirk Eddelbuettel and Romain Francois (2011). <span class="pkg">Rcpp</span>: Seamless R
and C++ Integration. <em>Journal of Statistical Software</em>,
<b>40(8)</b>, 1-18, <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>. Also
available as <code>vignette("Rcpp-introduction")</code>.
</p>

<hr>
<h2 id='loadModule'>
Load an Rcpp Module into a Package
</h2><span id='topic+loadModule'></span>

<h3>Description</h3>

<p>One or more calls to <code>loadModule</code> will be included in the source
code for a package to load modules and optionally expose objects from
them.  The actual extraction of the module takes place at load time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadModule(module, what = , loadNow, env =)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadModule_+3A_module">module</code></td>
<td>

<p>The name of the C++ module to load.  The code for the module should be
in the same package as the <span class="rlang"><b>R</b></span> call to <code>loadModule</code>.
</p>
</td></tr>
<tr><td><code id="loadModule_+3A_what">what</code></td>
<td>

<p>The objects to expose in the package's namespace corresponding to
objects in the module.  By default, nothing is exposed.
</p>
<p>The special value <code>TRUE</code> says to load all the objects in the
module that have syntactically standard <span class="rlang"><b>R</b></span> names (which all objects
in a module will normally have).
</p>
<p>Otherwise, if supplied this should be a character vector, the elements being
objects defined in the module.  The vector can have a names attribute,
in which case the non-empty names will be used to rename the objects;
otherwise, the name of the object in the package namespace will be the
same as the name in the C++ module.
</p>
</td></tr>
<tr><td><code id="loadModule_+3A_loadnow">loadNow</code>, <code id="loadModule_+3A_env">env</code></td>
<td>

<p>A logical flag to say whether the load actions should happen now, and
the environment into which the objects should be inserted.  When
called from the source of a package, both of these arguments should
usually be omitted.
</p>
<p>The value of <code>loadNow</code> will be set by checking the module's
status.  At package installation time, the module cannot be started,
in which case a load action (see <code><a href="methods.html#topic+setLoadAction">setLoadAction</a></code>) is
scheduled to do the actual module load.
</p>
<p>The value of <code>env</code> will default to the package's namespace.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the purpose of loading the module is to define classes based on C++
classes, see <code><a href="#topic+setRcppClass">setRcppClass</a>()</code>, which does the necessary
module loading for you.
</p>
<p>When the module can be started (at namespace load time), the function
<code><a href="#topic+Module">Module</a>()</code> returns an environment with a description of
the module's contents. Function <code>loadModule()</code> saves this as a
metadata object in the package namespace.  Therefore multiple calls to
<code>loadModule()</code> are an efficient way to extract different objects
from the module.
</p>
<p>Requesting an object that does not exist in the module produces a
warning.
</p>
<p>Since assignments from the call cannot take place until namespace
loading time, any computations using the objects must also be
postponed until this time.  Use load actions
(<code><a href="methods.html#topic+setLoadAction">setLoadAction</a></code>) and make sure that the load action is
specified after the call to <code>loadModule()</code>.
</p>


<h3>Value</h3>

<p>If the load takes place, the module environment is returned.  Usually
however the function is called for its side effects.
</p>


<h3>Note</h3>

<p>This function requires version  2.15.0 of <span class="rlang"><b>R</b></span> or later, in order to
use load actions, introduced in that version.  See the note in the
help page for <code><a href="#topic+setRcppClass">setRcppClass</a>()</code> for details.
</p>


<h3>Author(s)</h3>

<p>John Chambers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setRcppClass">setRcppClass</a>()</code> to avoid the explicit call.
</p>
<p><code><a href="#topic+loadRcppModules">loadRcppModules</a>()</code> for a (deprecated) shotgun procedure to load all
modules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loadModule("yada", TRUE) # load all the objects from module "yada"

## End(Not run)
</code></pre>

<hr>
<h2 id='loadRcppModules-deprecated'>
Loads Rcpp modules on package startup
</h2><span id='topic+loadRcppModules'></span>

<h3>Description</h3>

<p><em>Note:</em> As of release 0.12.5, this function is deprecated;
<code><a href="#topic+loadModule">loadModule</a></code> should be used instead.
</p>
<p>Function to simplify loading Rcpp modules contained in a package.
This function must be called from the <code>.onLoad</code> function of a package.
It uses the <code>RcppModules</code> field of the package <code>DESCRIPTION</code> file
to query the names of the modules that the package should export, loads each module,
and <code><a href="#topic+populate">populate</a></code> each module into the package NAMESPACE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  loadRcppModules(direct=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadRcppModules-deprecated_+3A_direct">direct</code></td>
<td>
<p>if <code>TRUE</code> the content of the module is exposed in the
namespace. Otherwise, the module is exposed. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+populate">populate</a></code>, <code><a href="#topic+loadModule">loadModule</a></code>
</p>

<hr>
<h2 id='Module'>
Retrieves an Rcpp module
</h2><span id='topic+Module'></span>

<h3>Description</h3>

<p>Retrieves an Rcpp module from a dynamic library, usually associated with a 
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Module(module, PACKAGE = , where = , mustStart =  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Module_+3A_module">module</code></td>
<td>
<p>Name of the module, as declared in the <code>RCPP_MODULE</code> macro internally</p>
</td></tr>
<tr><td><code id="Module_+3A_package">PACKAGE</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+getNativeSymbolInfo">getNativeSymbolInfo</a></code></p>
</td></tr>
<tr><td><code id="Module_+3A_where">where</code></td>
<td>
<p>When the module is loaded, S4 classes are defined based on the 
internal classes. This argument is passed to <code><a href="methods.html#topic+setClass">setClass</a></code>
</p>
</td></tr>
<tr><td><code id="Module_+3A_muststart">mustStart</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+Module-class">Module</a> collecting functions 
and classes declared in the module. 
</p>

<hr>
<h2 id='Module-class'>Rcpp modules</h2><span id='topic+Module-class'></span><span id='topic++24+2CModule-method'></span><span id='topic+prompt+2CModule-method'></span><span id='topic+show+2CModule-method'></span><span id='topic+initialize+2CModule-method'></span>

<h3>Description</h3>

<p>Collection of internal c++ functions and classes exposed to R
</p>


<h3>Objects from the Class</h3>

<p>modules are created by the <code>link{Module}</code> function
</p>


<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "Module")</code>: extract a function or a class from the module. </p>
</dd>
<dt>prompt</dt><dd><p><code>signature(object = "Module")</code>: generates skeleton of a documentation for a Module. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Module")</code>: summary information about the module. </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "Module")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>The <code><a href="#topic+Module">Module</a></code> function
</p>

<hr>
<h2 id='pluginsAttribute'>Rcpp::plugins Attribute</h2><span id='topic+pluginsAttribute'></span>

<h3>Description</h3>

<p>The <code>Rcpp::plugins</code> attribute is added to a C++ source file to specify the
<a href="inline.html#topic+plugins">inline plugins</a> that should be used in the compilation.
</p>
<pre>
// [[Rcpp::plugins(plugin1, plugin2)]]
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluginsAttribute_+3A_...">...</code></td>
<td>

<p>Plugins to add to the compilation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plugins must be registered using the <code><a href="#topic+registerPlugin">registerPlugin</a></code>
function. 
</p>
<p>When included within a <code><a href="#topic+sourceCpp">sourceCpp</a></code> translation unit,
the configuration-related fields of the plugin (e.g. <code>env</code> and 
<code>LinkingTo</code>) are utilized, however the code-generation fields
(e.g. <code>includes</code> and <code>body</code>) are not.
</p>


<h3>Note</h3>

<p><span class="pkg">Rcpp</span> includes a built-in <code>cpp11</code> plugin that
adds the flags required to enable <code>C++11</code> features in the compiler.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerPlugin">registerPlugin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

// [[Rcpp::plugins(cpp11)]]

// [[Rcpp::export]]
int useCpp11() {
    auto x = 10;
    return x;
}

## End(Not run)
</code></pre>

<hr>
<h2 id='populate'>
Populates a namespace or an environment with the content of a module
</h2><span id='topic+populate'></span>

<h3>Description</h3>

<p>Populates a namespace or an environment with the content of a module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>populate(module, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="populate_+3A_module">module</code></td>
<td>
<p>Rcpp module</p>
</td></tr>
<tr><td><code id="populate_+3A_env">env</code></td>
<td>
<p>environment or namespace</p>
</td></tr>
</table>

<hr>
<h2 id='Rcpp-deprecated'>Deprecated Functions in the Rcpp Package</h2><span id='topic+Rcpp-deprecated'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of the
<span class="pkg">Rcpp</span> package only, and may be removed in future versions.
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+loadRcppModules">loadRcppModules</a></code> calls should now be replaced by
<code><a href="#topic+loadModule">loadModule</a></code> calls, one per Module.
</p>
</li>
<li> <p><code><a href="#topic+LdFlags">LdFlags</a></code> and <code><a href="#topic+RcppLdFlags">RcppLdFlags</a></code> are no
longer required as no library is provided (or needed) by Rcpp (as it
was up until release 0.10.1).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Dirk Eddelbuettel and Romain Francois</p>

<hr>
<h2 id='Rcpp-internal'>Rcpp internal functions</h2><span id='topic+Rcpp-internal'></span><span id='topic+cpp_object_initializer'></span><span id='topic+cpp_object_dummy'></span>

<h3>Description</h3>

<p>The <span class="pkg">Rcpp</span> utilizes several internal functions which
need to visible within its namespace, yet are not user-facing. This
page provides basic documentation for them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cpp_object_initializer(.self, .refClassDef, ..., .object_pointer)
  cpp_object_dummy(.self, .refClassDef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rcpp-internal_+3A_.self">.self</code></td>
<td>
<p>A reference to the object being modified</p>
</td></tr>
<tr><td><code id="Rcpp-internal_+3A_.refclassdef">.refClassDef</code></td>
<td>
<p>The definition of a reference class</p>
</td></tr>
<tr><td><code id="Rcpp-internal_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
<tr><td><code id="Rcpp-internal_+3A_.object_pointer">.object_pointer</code></td>
<td>
<p>Optional external pointer</p>
</td></tr>
</table>

<hr>
<h2 id='Rcpp-package'>R / C++ interface</h2><span id='topic+Rcpp-package'></span><span id='topic+Rcpp'></span>

<h3>Description</h3>

<p>The <span class="pkg">Rcpp</span> package provides C++ classes that
greatly facilitate interfacing C or C++ code in <span class="rlang"><b>R</b></span> packages using
the <code>.Call</code> interface provided by <span class="rlang"><b>R</b></span>.
</p>


<h3>Introduction</h3>

<p><span class="pkg">Rcpp</span> provides C++ classes to facilitate manipulation of a large
number of R data structures : vectors, functions, environments, ...
</p>
<p>The &ldquo;Rcpp-introduction&rdquo; vignette gives an introduction on the package
</p>


<h3>Usage for package building</h3>

<p>The &ldquo;Rcpp-package&rdquo; vignette documents how to use Rcpp in client packages.
</p>


<h3>History</h3>

<p>The initial versions of Rcpp were written by Dominick Samperi during 2005 and
2006.
</p>
<p>Dirk Eddelbuettel made some additions, and became maintainer in 2008.
</p>
<p>Dirk Eddelbuettel and Romain Francois have been extending Rcpp since 2009.
</p>


<h3>Author(s)</h3>

<p>Dirk Eddelbuettel and Romain Francois</p>


<h3>References</h3>

<p>Dirk Eddelbuettel and Romain Francois (2011). <span class="pkg">Rcpp</span>: Seamless R
and C++ Integration. <em>Journal of Statistical Software</em>,
<b>40(8)</b>, 1-18, <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>. Also
available as <code>vignette("Rcpp-introduction")</code>.
</p>
<p>Eddelbuettel, Dirk (2013) Seamless R and C++ Integration with
<span class="pkg">Rcpp</span>. Springer, New York. ISBN 978-1-4614-6867-7.
</p>


<h3>See Also</h3>

<p>Development for <span class="pkg">Rcpp</span> can be followed via the GitHub repository
at <a href="https://github.com/RcppCore/Rcpp">https://github.com/RcppCore/Rcpp</a>.
</p>
<p>Extensive examples with full documentation are available at
<a href="https://gallery.rcpp.org">https://gallery.rcpp.org</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# introduction to Rcpp
vignette("Rcpp-introduction")

# information on how to build a package that uses Rcpp
vignette("Rcpp-package")

## End(Not run)
</code></pre>

<hr>
<h2 id='Rcpp.package.skeleton'>
Create a skeleton for a new package depending on Rcpp
</h2><span id='topic+Rcpp.package.skeleton'></span>

<h3>Description</h3>

<p><code>Rcpp.package.skeleton</code> automates the creation of 
a new source package that intends to use features of Rcpp. 
</p>
<p>It is based on the <a href="utils.html#topic+package.skeleton">package.skeleton</a> function
which it executes first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rcpp.package.skeleton(name = "anRpackage", list = character(), 
	environment = .GlobalEnv, path = ".", force = FALSE, 
	code_files = character(), cpp_files = character(),
	example_code = TRUE, attributes = TRUE, module = FALSE, 
	author = "Your Name", 
	maintainer = if(missing( author)) "Your Name" else author, 
	email = "your@email.com", 
	license = "GPL (&gt;= 2)"
	)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rcpp.package.skeleton_+3A_name">name</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_list">list</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_environment">environment</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_path">path</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_force">force</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_code_files">code_files</code></td>
<td>
<p>See <a href="utils.html#topic+package.skeleton">package.skeleton</a></p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_cpp_files">cpp_files</code></td>
<td>
<p>A character vector with the paths to C++ source files to add to the package. </p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_example_code">example_code</code></td>
<td>
<p>If TRUE, example c++ code using Rcpp is added to the package. </p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_attributes">attributes</code></td>
<td>
<p>If TRUE, example code makes use of Rcpp attributes.</p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_module">module</code></td>
<td>
<p>If TRUE, an example <code><a href="#topic+Module">Module</a></code> is added to the skeleton. </p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_author">author</code></td>
<td>
<p>Author of the package.</p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_maintainer">maintainer</code></td>
<td>
<p>Maintainer of the package.</p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_email">email</code></td>
<td>
<p>Email of the package maintainer.</p>
</td></tr>
<tr><td><code id="Rcpp.package.skeleton_+3A_license">license</code></td>
<td>
<p>License of the package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to <a href="utils.html#topic+package.skeleton">package.skeleton</a> : 
</p>
<p>The &lsquo;<span class="samp">&#8288;DESCRIPTION&#8288;</span>&rsquo; file gains an Imports line requesting that 
the package depends on Rcpp and a LinkingTo line so that the package
finds Rcpp header files.
</p>
<p>The &lsquo;<span class="samp">&#8288;NAMESPACE&#8288;</span>&rsquo; gains a <code>useDynLib</code> directive as well
as an <code>importFrom(Rcpp, evalCpp</code> to ensure instantiation of Rcpp.
</p>
<p>The &lsquo;<span class="samp">&#8288;src&#8288;</span>&rsquo; directory is created if it does not exists. 
</p>
<p>If <code>cpp_files</code> are provided then they will be copied to the &lsquo;<span class="samp">&#8288;src&#8288;</span>&rsquo;
directory.
</p>
<p>If the <code>example_code</code> argument is set to <code>TRUE</code>, 
example files &lsquo;<span class="samp">&#8288;rcpp_hello_world.h&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;rcpp_hello_world.cpp&#8288;</span>&rsquo;
are also created in the &lsquo;<span class="samp">&#8288;src&#8288;</span>&rsquo;. An R file &lsquo;<span class="samp">&#8288;rcpp_hello_world.R&#8288;</span>&rsquo; is 
expanded in the &lsquo;<span class="samp">&#8288;R&#8288;</span>&rsquo; directory, the <code>rcpp_hello_world</code> function
defined in this files makes use of the C++ function &lsquo;<span class="samp">&#8288;rcpp_hello_world&#8288;</span>&rsquo;
defined in the C++ file. These files are given as an example and should 
eventually by removed from the generated package.
</p>
<p>If the <code>attributes</code> argument is <code>TRUE</code>, then rather than generate
the example files as described above, a single &lsquo;<span class="samp">&#8288;rcpp_hello_world.cpp&#8288;</span>&rsquo;
file is created in the &lsquo;<span class="samp">&#8288;src&#8288;</span>&rsquo; directory and it's attributes are 
compiled using the <code><a href="#topic+compileAttributes">compileAttributes</a></code> function. This leads to 
the files &lsquo;<span class="samp">&#8288;RcppExports.R&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;RcppExports.cpp&#8288;</span>&rsquo; being generated.
They are automatically regenerated from <em>scratch</em> each time 
<code><a href="#topic+compileAttributes">compileAttributes</a></code> is called. Therefore, one should 
<strong>not</strong> modify by hand either of the &lsquo;<span class="samp">&#8288;RcppExports&#8288;</span>&rsquo; files.
</p>
<p>If the <code>module</code> argument is <code>TRUE</code>, a sample Rcpp module will 
be generated as well. 
</p>


<h3>Value</h3>

<p>Nothing, used for its side effects
</p>


<h3>References</h3>

<p>Read the <em>Writing R Extensions</em> manual for more details.
</p>
<p>Once you have created a <em>source</em> package you need to install it:
see the <em>R Installation and Administration</em> manual,
<code><a href="utils.html#topic+INSTALL">INSTALL</a></code> and <code><a href="utils.html#topic+install.packages">install.packages</a></code>.
</p>


<h3>See Also</h3>

<p><a href="utils.html#topic+package.skeleton">package.skeleton</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simple package
Rcpp.package.skeleton( "foobar" )

# package using attributes
Rcpp.package.skeleton( "foobar", attributes = TRUE )

# package with a module
Rcpp.package.skeleton( "testmod", module = TRUE )

# the Rcpp-package vignette
vignette( "Rcpp-package" )

# the Rcpp-modules vignette for information about modules
vignette( "Rcpp-modules" )


## End(Not run)
</code></pre>

<hr>
<h2 id='Rcpp.plugin.maker'>
Facilitating making package plugins
</h2><span id='topic+Rcpp.plugin.maker'></span>

<h3>Description</h3>

<p>This function helps packages making inline plugins. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rcpp.plugin.maker(
  include.before = "", 
  include.after = "", 
  LinkingTo = unique(c(package, "Rcpp")), 
  Depends = unique(c(package, "Rcpp")), 
  Imports = unique(c(package, "Rcpp")), 
  libs = "", 
  Makevars = NULL, 
  Makevars.win = NULL, 
  package = "Rcpp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rcpp.plugin.maker_+3A_include.before">include.before</code></td>
<td>
<p>Code to be included before the &lsquo;<span class="samp">&#8288;Rcpp.h&#8288;</span>&rsquo; file</p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_include.after">include.after</code></td>
<td>
<p>Code to be included after the &lsquo;<span class="samp">&#8288;Rcpp.h&#8288;</span>&rsquo; file </p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_linkingto">LinkingTo</code></td>
<td>
<p>Packages to be added to the &lsquo;<span class="samp">&#8288;LinkingTo&#8288;</span>&rsquo; field </p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_depends">Depends</code></td>
<td>
<p>Packages to be added to the &lsquo;<span class="samp">&#8288;Depends&#8288;</span>&rsquo; field [deprecated] </p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_imports">Imports</code></td>
<td>
<p>Packages to be added to the &lsquo;<span class="samp">&#8288;Depends&#8288;</span>&rsquo; field </p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_libs">libs</code></td>
<td>
<p>library flags</p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_makevars">Makevars</code></td>
<td>
<p>content for a &lsquo;<span class="samp">&#8288;Makevars&#8288;</span>&rsquo; file, or <code>NULL</code></p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_makevars.win">Makevars.win</code></td>
<td>
<p>content for a &lsquo;<span class="samp">&#8288;Makevars.win&#8288;</span>&rsquo; file, or <code>NULL</code></p>
</td></tr>
<tr><td><code id="Rcpp.plugin.maker_+3A_package">package</code></td>
<td>
<p>The package this plugin is for. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that is suitable as a plugin. See for example the 
&lsquo;<span class="samp">&#8288;RcppArmadillo&#8288;</span>&rsquo; package that uses this to create its inline plugin. 
</p>

<hr>
<h2 id='RcppUnitTests'>Rcpp : unit tests results</h2><span id='topic+RcppUnitTests'></span>

<h3>Description</h3>

<p>Unit tests results for package Rcpp.
</p>
<p>Unit tests are run automatically at build time and reports are included in the
&lsquo;<span class="samp">&#8288;doc&#8288;</span>&rsquo; directory as html or text.
</p>


<h3>See Also</h3>

<p><a href="../doc/unitTests-results/Rcpp-unitTests.html">../doc/unitTests-results/Rcpp-unitTests.html</a>: html formatted unit test report
</p>


<h3>Examples</h3>

<pre><code class='language-R'># unit tests are in the unitTests directory of the package
list.files( system.file("unitTests", package = "Rcpp" ),
	pattern = "^runit", full = TRUE )

# trigger the unit tests preparation, follow printed instructions
# on how to run them
## Not run: 
source( system.file("unitTests", "runTests.R", package = "Rcpp" ) )

## End(Not run)
</code></pre>

<hr>
<h2 id='registerPlugin'>
Register an inline plugin
</h2><span id='topic+registerPlugin'></span>

<h3>Description</h3>

<p>Register an <a href="inline.html#topic+plugins">inline plugin</a> for use with 
<code><a href="#topic+sourceCpp">sourceCpp</a></code> or <code><a href="#topic+cppFunction">cppFunction</a></code>. Inline plugins are functions
that return a list with additional includes, environment variables, and
other compilation context. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerPlugin(name, plugin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registerPlugin_+3A_name">name</code></td>
<td>
<p>Name of the inline plugin</p>
</td></tr>
<tr><td><code id="registerPlugin_+3A_plugin">plugin</code></td>
<td>
<p>Inline plugin function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plugins can be added to <code><a href="#topic+sourceCpp">sourceCpp</a></code> compilations using the
<code><a href="#topic+pluginsAttribute">Rcpp::plugins</a></code> attribute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pluginsAttribute">Rcpp::plugins</a></code>
</p>

<hr>
<h2 id='setRcppClass'>
Create a Class Extending a C++ Class
</h2><span id='topic+setRcppClass'></span><span id='topic+loadRcppClass'></span><span id='topic+RcppClass-class'></span>

<h3>Description</h3>

<p>These routines create a class definition in <span class="rlang"><b>R</b></span> for an exposed C++
class, setting up and executing a load action to incorporate the C++
pointer information.
Neither function should normally need to be called directly; for most applications,
a call to
<code><a href="#topic+exposeClass">exposeClass</a>()</code> will create both C++ and <span class="rlang"><b>R</b></span> code files to
expose the C++ class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRcppClass(Class, CppClass = , module = , fields = list(), contains = ,
             methods = , saveAs = Class, where = , ...)
loadRcppClass(Class, CppClass = , module = , fields = character(),
              contains = character(),
              methods = , saveAs = Class, where = , ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRcppClass_+3A_class">Class</code></td>
<td>

<p>The name for the new class.
</p>
</td></tr>
<tr><td><code id="setRcppClass_+3A_cppclass">CppClass</code></td>
<td>

<p>The C++ class defined in the C++ code for the package that this class
extends. By default, the same as <code>Class</code>.
</p>
</td></tr>
<tr><td><code id="setRcppClass_+3A_module">module</code></td>
<td>

<p>The Rcpp module in which the class is defined.  The module does not
have to be loaded separately; <code>setRcppClass()</code> will arrange to
load the module. By default, <code>"class_"</code> followed by the C++ class
name.
</p>
<p>If <code><a href="#topic+exposeClass">exposeClass</a>()</code> has been called, the necessary module
code will have been written in the <code>src</code> directory of the package.
</p>
</td></tr>
<tr><td><code id="setRcppClass_+3A_fields">fields</code>, <code id="setRcppClass_+3A_contains">contains</code>, <code id="setRcppClass_+3A_methods">methods</code></td>
<td>

<p>Additional fields, superclasses and method definitions in <span class="rlang"><b>R</b></span> that
extend the C++ class.  These arguments are passed on to
<code><a href="methods.html#topic+setRefClass">setRefClass</a>()</code>.
</p>
</td></tr>
<tr><td><code id="setRcppClass_+3A_saveas">saveAs</code></td>
<td>

<p>Save a generator object for the class in the package's namespace under
this name.  By default, the generator object has the name of the
class.  To avoid saving any generator object, supply this argument as
<code>NULL</code>.
</p>
<p>(This argument is currently needed because the actual class definition
must take place at package load time, to include C++ pointer
information.
Therefore the
value returned by <code>setRcppClass()</code> when called during package
installation is not the generator object returned by
<code>setRefClass()</code>.
We may be able to hack
around this problem in the future.)
</p>
</td></tr>
<tr><td><code id="setRcppClass_+3A_where">where</code></td>
<td>

<p>The environment in which to save the class definition.  By default,
will be the namespace of the package in which the
<code>setRcppClass()</code> call is included.
</p>
</td></tr>
<tr><td><code id="setRcppClass_+3A_...">...</code></td>
<td>

<p>Arguments, if any, to pass on to <code><a href="methods.html#topic+setRefClass">setRefClass</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call to these functions normally appears in the source code for a
package; in particular, a call is written in an <span class="rlang"><b>R</b></span> source file when
<code><a href="#topic+exposeClass">exposeClass</a>()</code> is called.
</p>
<p><span class="rlang"><b>R</b></span> code for this class or (preferably) a subclass can define new fields and methods for the class.
Methods for the <span class="rlang"><b>R</b></span> class can refer to methods and fields defined in
C++ for the C++ class, if those have been exposed.
</p>
<p>The fields  and methods defined can
include overriding C++ fields or methods.
Keep in mind, however, that <span class="rlang"><b>R</b></span> methods can refer to C++ fields and
methods, but not the reverse.
If you override a C++ field or method, you essentially need to revise
all code that refers to that field or method.
Otherwise, the C++ code will continue to use the old C++ definition.
</p>


<h3>Value</h3>

<p>At load time, a generator for the new class is created and stored
according to the <code>saveAs</code> argument, typically under the name of
the class.
</p>
<p>The value returned at installation time is a dummy.  Future revisions
of the function may allow us to return a valid generator at install
time.  We recommend using the standard style of assigning the value
to the name of the class, as one would do with <code><a href="methods.html#topic+setRefClass">setRefClass</a></code>.
</p>


<h3>Note</h3>

<p>This function and function <code><a href="#topic+loadModule">loadModule</a>()</code> require
version  2.15.0 of <span class="rlang"><b>R</b></span> or later, in order to
use load actions, introduced in that version.
</p>
<p>A subtle way this can fail is by somehow loading a legitimate
binary version of your package (installed under a valid version of
<span class="rlang"><b>R</b></span>) into a session with an older <span class="rlang"><b>R</b></span>.
In this case the load actions created in the binary package will
simply not be called.  None of the modules will be loaded and none of
the classes created.
</p>
<p>If your symptom is that classes or other objects from modules don't
exist, check the <span class="rlang"><b>R</b></span> version.
</p>


<h3>Author(s)</h3>

<p>John Chambers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setRcppClass("World", 
    module = "yada", 
    fields = list(more = "character"),
    methods = list(
        test = function(what) message("Testing: ", what, "; ", more)),
    saveAs = "genWorld"
         )

## End(Not run)
</code></pre>

<hr>
<h2 id='sourceCpp'>
Source C++ Code from a File or String
</h2><span id='topic+sourceCpp'></span>

<h3>Description</h3>

<p><code>sourceCpp</code> parses the specified C++ file or source code and looks for functions marked with the <code><a href="#topic+exportAttribute">Rcpp::export</a></code> attribute
and RCPP_MODULE declarations. A shared library is then built and its exported functions and Rcpp modules are made available in the specified environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sourceCpp(file = "", code = NULL, env = globalenv(), embeddedR = TRUE, rebuild = FALSE,
          cacheDir = getOption("rcpp.cache.dir", tempdir()), cleanupCacheDir = FALSE,
          showOutput = verbose, verbose = getOption("verbose"), dryRun = FALSE,
          windowsDebugDLL = FALSE, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sourceCpp_+3A_file">file</code></td>
<td>

<p>A character string giving the path name of a file
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_code">code</code></td>
<td>

<p>A character string with source code. If supplied, the code is taken from this string instead of a file.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_env">env</code></td>
<td>

<p>Environment where the R functions and modules should be made available.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_embeddedr">embeddedR</code></td>
<td>

<p><code>TRUE</code> to run embedded R code chunks.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_rebuild">rebuild</code></td>
<td>

<p>Force a rebuild of the shared library.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_cachedir">cacheDir</code></td>
<td>

<p>Directory to use for caching shared libraries. If the underlying file or code passed to <code>sourceCpp</code> has not changed since the last invocation then a cached version of the shared library is used. The default value of <code>tempdir()</code> results in the cache being valid only for the current R session. Pass an alternate directory to preserve the cache across R sessions.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_cleanupcachedir">cleanupCacheDir</code></td>
<td>

<p>Cleanup all files in the cacheDir that were not a result of this compilation. Note that this will cleanup the cache from all other calls to sourceCpp with the same cacheDir. This option should therefore only be specified by callers that provide a unique cacheDir per scope (e.g. chunk labels in a weaved document).
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_showoutput">showOutput</code></td>
<td>

<p><code>TRUE</code> to print <code>R CMD SHLIB</code> output to the console.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_verbose">verbose</code></td>
<td>

<p><code>TRUE</code> to print detailed information about generated code to the console.
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_dryrun">dryRun</code></td>
<td>

<p><code>TRUE</code> to do a dry run (showing commands that would be used rather than
actually executing the commands).
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_windowsdebugdll">windowsDebugDLL</code></td>
<td>

<p><code>TRUE</code> to create a debug DLL on Windows (and ignored on other platforms).
</p>
</td></tr>
<tr><td><code id="sourceCpp_+3A_echo">echo</code></td>
<td>

<p><code>TRUE</code> to silence output from optional R evaluation if set to <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>code</code> parameter is provided then the <code>file</code> parameter is ignored.
</p>
<p>Functions exported using <code>sourceCpp</code> must meet several conditions,
including being defined in the global namespace and having return types
that are compatible with <code>Rcpp::wrap</code> and parameter types that are
compatible with <code>Rcpp::as</code>.
See the <code><a href="#topic+exportAttribute">Rcpp::export</a></code> documentation for more details.
</p>
<p>Content of Rcpp Modules will be automatically loaded into the specified
environment using the <code><a href="#topic+Module">Module</a></code> and
<code><a href="#topic+populate">populate</a></code> functions.
</p>
<p>If the source file has compilation dependencies on other
packages (e.g. <span class="pkg">Matrix</span>, <span class="pkg">RcppArmadillo</span>) then an
<code><a href="#topic+dependsAttribute">Rcpp::depends</a></code> attribute
should be provided naming these dependencies.
</p>
<p>It's possible to embed chunks of R code within a C++ source file by
including the R code within a block comment with the
prefix of <code>/*** R</code>. For example:
</p>
<pre>
/*** R

# Call the fibonacci function defined in C++
fibonacci(10)

*/
</pre>
<p>Multiple R code chunks can be included in a C++ file. R code is sourced after the C++ compilation is completed so all functions and modules will be available to the R code.
</p>


<h3>Value</h3>

<p>Returns (invisibly) a list with two elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
        <code>functions</code> </td><td style="text-align: left;"> Names of exported functions</td>
</tr>
<tr>
 <td style="text-align: left;">
        <code>modules</code> </td><td style="text-align: left;"> Names of Rcpp modules</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Note</h3>

<p>The <code>sourceCpp</code> function will not rebuild the shared library if the source file has not changed since the last compilation.
</p>
<p>The <code>sourceCpp</code> function is designed for compiling a standalone source file whose only dependencies are R packages. If you are compiling more than one source file or have external dependencies then you should create an R package rather than using <code>sourceCpp</code>. Note that the <code><a href="#topic+exportAttribute">Rcpp::export</a></code> attribute can also be used within packages via the <code><a href="#topic+compileAttributes">compileAttributes</a></code> function.
</p>
<p>If you are sourcing a C++ file from within the <code>src</code> directory of a package then the package's <code>LinkingTo</code> dependencies, <code>inst/include</code>, and <code>src</code> directories are automatically included in the compilation.
</p>
<p>If no <code>Rcpp::export</code> attributes or <code>RCPP_MODULE</code> declarations are found within the source file then a warning is printed to the console. You can disable this warning by setting the <code>rcpp.warnNoExports</code> option to <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exportAttribute">Rcpp::export</a></code>, <code><a href="#topic+dependsAttribute">Rcpp::depends</a></code>, <code><a href="#topic+cppFunction">cppFunction</a></code>, <code><a href="#topic+evalCpp">evalCpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

sourceCpp("fibonacci.cpp")

sourceCpp(code='
  #include &lt;Rcpp.h&gt;

  // [[Rcpp::export]]
  int fibonacci(const int x) {
    if (x == 0) return(0);
    if (x == 1) return(1);
    return (fibonacci(x - 1)) + fibonacci(x - 2);
  }'
)


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
