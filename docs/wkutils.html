<!DOCTYPE html><html><head><title>Help for package wkutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wkutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wkutils-package'><p>wkutils: Utilities for Well-Known Geometry Vectors</p></a></li>
<li><a href='#coords_point_translate_wkt'><p>Parse coordinates into well-known formats</p></a></li>
<li><a href='#wkb_coords'><p>Extract coordinates from well-known geometries</p></a></li>
<li><a href='#wkb_debug'><p>Debug well-known geometry</p></a></li>
<li><a href='#wkb_draw_points'><p>Draw well-known geometries</p></a></li>
<li><a href='#wkb_meta'><p>Extract meta information</p></a></li>
<li><a href='#wkb_ranges'><p>Extract ranges information</p></a></li>
<li><a href='#wkt_grob'><p>Generate grid geometries from well-known geometries</p></a></li>
<li><a href='#wkt_has_missing'><p>Test well-known geometries for missing and non-finite coordinates</p></a></li>
<li><a href='#wkt_plot'><p>Plot well-known geometry vectors</p></a></li>
<li><a href='#wkt_set_srid'><p>Modify well-known geometries</p></a></li>
<li><a href='#wkt_unnest'><p>Flatten nested geometry structures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities for Well-Known Geometry Vectors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides extra utilities for well-known formats in the
  'wk' package that are outside the scope of that package. Utilities
  to parse coordinates from data frames, plot well-known geometry
  vectors, extract meta information from well-known geometry vectors,
  and calculate bounding boxes are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>wk (&ge; 0.3.1), Rcpp, tibble, vctrs</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paleolimbot.github.io/wkutils/">https://paleolimbot.github.io/wkutils/</a>,
<a href="https://github.com/paleolimbot/wkutils">https://github.com/paleolimbot/wkutils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paleolimbot/wkutils/issues">https://github.com/paleolimbot/wkutils/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-17 02:48:34 UTC; deweydunnington</td>
</tr>
<tr>
<td>Author:</td>
<td>Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dewey Dunnington &lt;dewey@fishandwhistle.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-18 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wkutils-package'>wkutils: Utilities for Well-Known Geometry Vectors</h2><span id='topic+wkutils'></span><span id='topic+wkutils-package'></span>

<h3>Description</h3>

<p>Provides extra utilities for well-known formats in the 'wk' package that are outside the scope of that package. Utilities to parse coordinates from data frames, plot well-known geometry vectors, extract meta information from well-known geometry vectors, and calculate bounding boxes are provided.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dewey Dunnington <a href="mailto:dewey@fishandwhistle.net">dewey@fishandwhistle.net</a> (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://paleolimbot.github.io/wkutils/">https://paleolimbot.github.io/wkutils/</a>
</p>
</li>
<li> <p><a href="https://github.com/paleolimbot/wkutils">https://github.com/paleolimbot/wkutils</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/paleolimbot/wkutils/issues">https://github.com/paleolimbot/wkutils/issues</a>
</p>
</li></ul>


<hr>
<h2 id='coords_point_translate_wkt'>Parse coordinates into well-known formats</h2><span id='topic+coords_point_translate_wkt'></span><span id='topic+coords_point_translate_wkb'></span><span id='topic+coords_linestring_translate_wkt'></span><span id='topic+coords_linestring_translate_wkb'></span><span id='topic+coords_polygon_translate_wkt'></span><span id='topic+coords_polygon_translate_wkb'></span>

<h3>Description</h3>

<p>These functions provide the reverse function of <code><a href="#topic+wkt_coords">wkt_coords()</a></code>
and company: they parse vectors of coordinate values into well-known
formats. Polygon rings are automatically closed, as
closed rings are assumed or required by many parsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords_point_translate_wkt(x, y, z = NA, m = NA, precision = 16, trim = TRUE)

coords_point_translate_wkb(
  x,
  y,
  z = NA,
  m = NA,
  endian = wk::wk_platform_endian(),
  buffer_size = 2048
)

coords_linestring_translate_wkt(
  x,
  y,
  z = NA,
  m = NA,
  feature_id = 1L,
  precision = 16,
  trim = TRUE
)

coords_linestring_translate_wkb(
  x,
  y,
  z = NA,
  m = NA,
  feature_id = 1L,
  endian = wk::wk_platform_endian(),
  buffer_size = 2048
)

coords_polygon_translate_wkt(
  x,
  y,
  z = NA,
  m = NA,
  feature_id = 1L,
  ring_id = 1L,
  precision = 16,
  trim = TRUE
)

coords_polygon_translate_wkb(
  x,
  y,
  z = NA,
  m = NA,
  feature_id = 1L,
  ring_id = 1L,
  endian = wk::wk_platform_endian(),
  buffer_size = 2048
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_point_translate_wkt_+3A_x">x</code>, <code id="coords_point_translate_wkt_+3A_y">y</code>, <code id="coords_point_translate_wkt_+3A_z">z</code>, <code id="coords_point_translate_wkt_+3A_m">m</code></td>
<td>
<p>Vectors of coordinate values</p>
</td></tr>
<tr><td><code id="coords_point_translate_wkt_+3A_precision">precision</code></td>
<td>
<p>The rounding precision to use when writing
(number of decimal places).</p>
</td></tr>
<tr><td><code id="coords_point_translate_wkt_+3A_trim">trim</code></td>
<td>
<p>Trim unnecessary zeroes in the output?</p>
</td></tr>
<tr><td><code id="coords_point_translate_wkt_+3A_endian">endian</code></td>
<td>
<p>Force the endian of the resulting WKB.</p>
</td></tr>
<tr><td><code id="coords_point_translate_wkt_+3A_buffer_size">buffer_size</code></td>
<td>
<p>The buffer size to use when converting to WKB.</p>
</td></tr>
<tr><td><code id="coords_point_translate_wkt_+3A_feature_id">feature_id</code>, <code id="coords_point_translate_wkt_+3A_ring_id">ring_id</code></td>
<td>
<p>Vectors for which a change in
sequential values indicates a new feature or ring. Use <code><a href="base.html#topic+factor">factor()</a></code>
to convert from a character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;*_translate_wkt()&#8288;</code> returns a character vector of
well-known text; <code style="white-space: pre;">&#8288;*_translate_wkb()&#8288;</code> returns a list
of raw vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords_point_translate_wkt(1:3, 2:4)
coords_linestring_translate_wkt(1:5, 2:6, feature_id = c(1, 1, 1, 2, 2))
coords_polygon_translate_wkt(c(0, 10, 0), c(0, 0, 10))

</code></pre>

<hr>
<h2 id='wkb_coords'>Extract coordinates from well-known geometries</h2><span id='topic+wkb_coords'></span><span id='topic+wkt_coords'></span>

<h3>Description</h3>

<p>These functions are optimised for graphics output,
which in R require flat coordinate structures. See
<code><a href="graphics.html#topic+points">graphics::points()</a></code>, <code><a href="graphics.html#topic+lines">graphics::lines()</a></code>,
and  <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code> for how to send these
to a graphics device, or <code><a href="grid.html#topic+grid.points">grid::pointsGrob()</a></code>,
<code><a href="grid.html#topic+grid.lines">grid::linesGrob()</a></code>, and <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code> for how
to create graphical objects using this output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_coords(wkb, sep_na = FALSE)

wkt_coords(wkt, sep_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_coords_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkb_coords_+3A_sep_na">sep_na</code></td>
<td>
<p>Use <code>TRUE</code> to separate geometries and linear
rings with a row of <code>NA</code>s. This is useful for generating
output that can be fed directly to <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code>
or <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> without modification.</p>
</td></tr>
<tr><td><code id="wkb_coords_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns:
</p>

<ul>
<li> <p><code>feature_id</code>: The index of the top-level feature
</p>
</li>
<li> <p><code>part_id</code>: The part identifier, guaranteed to be unique for every simple geometry
(including those contained within a multi-geometry or collection)
</p>
</li>
<li> <p><code>ring_id</code>: The ring identifier, guaranteed to be unique for every ring.
</p>
</li>
<li> <p><code>x</code>, <code>y</code>, <code>z</code>, <code>m</code>: Coordinaate values (both absence and <code>nan</code> are recorded
as <code>NA</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>text &lt;- c("LINESTRING (0 1, 19 27)", "LINESTRING (-1 -1, 4 10)")
wkt_coords(text)
wkt_coords(text, sep_na = TRUE)

</code></pre>

<hr>
<h2 id='wkb_debug'>Debug well-known geometry</h2><span id='topic+wkb_debug'></span><span id='topic+wkt_debug'></span><span id='topic+wkt_streamer_debug'></span>

<h3>Description</h3>

<p>Prints the raw calls to the <code>WKBGeometryHandler()</code>. Useful for writing
custom C++ handlers and debugging read problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_debug(wkb)

wkt_debug(wkt)

wkt_streamer_debug(wkt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_debug_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkb_debug_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt_debug("MULTIPOLYGON (((0 0, 10 0, 0 10, 0 0)))")
wkt_streamer_debug("MULTIPOLYGON (((0 0, 10 0, 0 10, 0 0)))")
wkb_debug(
  wk::wkt_translate_wkb(
    "MULTIPOLYGON (((0 0, 10 0, 0 10, 0 0)))"
  )
)

</code></pre>

<hr>
<h2 id='wkb_draw_points'>Draw well-known geometries</h2><span id='topic+wkb_draw_points'></span><span id='topic+wkt_draw_points'></span><span id='topic+wkb_draw_lines'></span><span id='topic+wkt_draw_lines'></span><span id='topic+wkb_draw_polypath'></span><span id='topic+wkt_draw_polypath'></span><span id='topic+wkb_plot_new'></span><span id='topic+wkt_plot_new'></span>

<h3>Description</h3>

<p>These functions send well-known geometry vectors to a
graphics device using <code><a href="graphics.html#topic+points">graphics::points()</a></code>,
<code><a href="graphics.html#topic+lines">graphics::lines()</a></code>, and <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code>. These are
minimal wrappers aimed at developers who need to visualize
test data: they do not check geometry type and are unlikely
to work with vectorized graphical parameters in <code>...</code>. Use
the <code style="white-space: pre;">&#8288;wk*_plot_new()&#8288;</code> functions to initialize a plot using the
extent of all coordinates in the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_draw_points(wkb, ...)

wkt_draw_points(wkt, ...)

wkb_draw_lines(wkb, ...)

wkt_draw_lines(wkt, ...)

wkb_draw_polypath(wkb, ..., rule = "evenodd")

wkt_draw_polypath(wkt, ..., rule = "evenodd")

wkb_plot_new(
  wkb,
  ...,
  asp = 1,
  xlab = "",
  ylab = "",
  main = deparse(substitute(wkb))
)

wkt_plot_new(
  wkt,
  ...,
  asp = 1,
  xlab = "",
  ylab = "",
  main = deparse(substitute(wkt))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_draw_points_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkb_draw_points_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+points">graphics::points()</a></code>,
<code><a href="graphics.html#topic+lines">graphics::lines()</a></code>, or <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code></p>
</td></tr>
<tr><td><code id="wkb_draw_points_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkb_draw_points_+3A_rule">rule</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code></p>
</td></tr>
<tr><td><code id="wkb_draw_points_+3A_asp">asp</code>, <code id="wkb_draw_points_+3A_xlab">xlab</code>, <code id="wkb_draw_points_+3A_ylab">ylab</code>, <code id="wkb_draw_points_+3A_main">main</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> to
initialize a new plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))"

wkt_plot_new(x)
wkt_draw_polypath(x, col = "grey90")
wkt_draw_lines(x, col = "red")
wkt_draw_points(x)

</code></pre>

<hr>
<h2 id='wkb_meta'>Extract meta information</h2><span id='topic+wkb_meta'></span><span id='topic+wkt_meta'></span><span id='topic+wkt_streamer_meta'></span><span id='topic+wk_geometry_type'></span><span id='topic+wk_geometry_type_id'></span>

<h3>Description</h3>

<p>Extract meta information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_meta(wkb, recursive = FALSE)

wkt_meta(wkt, recursive = FALSE)

wkt_streamer_meta(wkt, recursive = FALSE)

wk_geometry_type(type_id)

wk_geometry_type_id(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_meta_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkb_meta_+3A_recursive">recursive</code></td>
<td>
<p>Pass <code>TRUE</code> to recurse into multi-geometries
and collections to extract meta of sub-geometries</p>
</td></tr>
<tr><td><code id="wkb_meta_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkb_meta_+3A_type_id">type_id</code></td>
<td>
<p>An integer version of the geometry type</p>
</td></tr>
<tr><td><code id="wkb_meta_+3A_type">type</code></td>
<td>
<p>A string version of the geometry type (e.g.,
point, linestring, polygon, multipoint, multilinestring,
multipolygon, geometrycollection)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns:
</p>

<ul>
<li> <p><code>feature_id</code>: The index of the top-level feature
</p>
</li>
<li> <p><code>nest_id</code>: The recursion level (if feature is a geometry collection)
</p>
</li>
<li> <p><code>part_id</code>: The part index (if nested within a multi-geometry or collection)
</p>
</li>
<li> <p><code>type_id</code>: The type identifier (see <code><a href="#topic+wk_geometry_type">wk_geometry_type()</a></code>)
</p>
</li>
<li> <p><code>size</code>: For points and linestrings the number of points, for polygons
the number of rings, and for mutlti-geometries and collection types,
the number of child geometries.
</p>
</li>
<li> <p><code>srid</code>: The spatial reference identifier as an integer
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>wkt_meta("POINT (30 10)")
wkt_meta("GEOMETRYCOLLECTION (POINT (30 10))", recursive = FALSE)
wkt_meta("GEOMETRYCOLLECTION (POINT (30 10))", recursive = TRUE)

</code></pre>

<hr>
<h2 id='wkb_ranges'>Extract ranges information</h2><span id='topic+wkb_ranges'></span><span id='topic+wkt_ranges'></span><span id='topic+wkb_feature_ranges'></span><span id='topic+wkt_feature_ranges'></span>

<h3>Description</h3>

<p>This is intended to behave the same as <code><a href="base.html#topic+range">range()</a></code>, returning the
minimum and maximum x, y, z, and m coordinate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkb_ranges(wkb, na.rm = FALSE, finite = FALSE)

wkt_ranges(wkt, na.rm = FALSE, finite = FALSE)

wkb_feature_ranges(wkb, na.rm = FALSE, finite = FALSE)

wkt_feature_ranges(wkt, na.rm = FALSE, finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkb_ranges_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkb_ranges_+3A_na.rm">na.rm</code></td>
<td>
<p>Pass <code>TRUE</code> to not consider missing (nan) values</p>
</td></tr>
<tr><td><code id="wkb_ranges_+3A_finite">finite</code></td>
<td>
<p>Pass <code>TRUE</code> to only consider finite
(non-missing, non-infinite) values.</p>
</td></tr>
<tr><td><code id="wkb_ranges_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns:
</p>

<ul>
<li> <p><code>xmin</code>, <code>ymin</code>, <code>zmin</code>, and <code>mmin</code>: Minimum coordinate values
</p>
</li>
<li> <p><code>xmax</code>, <code>ymax</code>, <code>zmax</code>, and <code>mmax</code>: Maximum coordinate values
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>wkt_ranges("POINT (30 10)")

</code></pre>

<hr>
<h2 id='wkt_grob'>Generate grid geometries from well-known geometries</h2><span id='topic+wkt_grob'></span><span id='topic+wkb_grob'></span>

<h3>Description</h3>

<p>Using <code><a href="#topic+wkt_meta">wkt_meta()</a></code> and <code><a href="#topic+wkt_coords">wkt_coords()</a></code>, these functions create graphical objects
using the grid package. Vectors that contain geometries of a single dimension
are efficiently packed into a <code><a href="grid.html#topic+grid.points">grid::pointsGrob()</a></code>, <code><a href="grid.html#topic+grid.lines">grid::polylineGrob()</a></code>,
or <code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code>. Vectors with mixed types and nested collections are encoded
less efficiently using a <code><a href="grid.html#topic+grid.grob">grid::gTree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_grob(
  wkt,
  ...,
  rule = "evenodd",
  default.units = "native",
  name = NULL,
  vp = NULL
)

wkb_grob(
  wkt,
  ...,
  rule = "evenodd",
  default.units = "native",
  name = NULL,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_grob_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkt_grob_+3A_...">...</code></td>
<td>
<p>Graphical parameters passed to <code><a href="grid.html#topic+gpar">grid::gpar()</a></code>. These are recycled along
the input. Dynamic dots (e.g., <code style="white-space: pre;">&#8288;!!!&#8288;</code>) are supported.</p>
</td></tr>
<tr><td><code id="wkt_grob_+3A_rule">rule</code></td>
<td>
<p>Use &quot;winding&quot; if polygon rings are correctly encoded with a winding
direction.</p>
</td></tr>
<tr><td><code id="wkt_grob_+3A_default.units">default.units</code></td>
<td>
<p>Coordinate units, which may be defined by the viewport (see
<code><a href="grid.html#topic+unit">grid::unit()</a></code>). Defaults to native.</p>
</td></tr>
<tr><td><code id="wkt_grob_+3A_name">name</code>, <code id="wkt_grob_+3A_vp">vp</code></td>
<td>
<p>Passed to <code><a href="grid.html#topic+grid.points">grid::pointsGrob()</a></code>, <code><a href="grid.html#topic+grid.lines">grid::polylineGrob()</a></code>,
<code><a href="grid.html#topic+grid.path">grid::pathGrob()</a></code>, or <code><a href="grid.html#topic+grid.grob">grid::gTree()</a></code> depending on the types of geometries
in the input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="grid.html#topic+grid.grob">graphical object</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid::grid.newpage()
grid::grid.draw(wkt_grob("POINT (0.5 0.5)", pch = 16, default.units = "npc"))

</code></pre>

<hr>
<h2 id='wkt_has_missing'>Test well-known geometries for missing and non-finite coordinates</h2><span id='topic+wkt_has_missing'></span><span id='topic+wkb_has_missing'></span><span id='topic+wkt_is_finite'></span><span id='topic+wkb_is_finite'></span>

<h3>Description</h3>

<p>Note that EMTPY geometries are considered finite and non-missing.
Use the <code>size</code> column of <code><a href="#topic+wkt_meta">wkt_meta()</a></code> to test for empty geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_has_missing(wkt)

wkb_has_missing(wkb)

wkt_is_finite(wkt)

wkb_is_finite(wkb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_has_missing_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkt_has_missing_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with the same length as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt_has_missing("POINT (0 1)")
wkt_has_missing("POINT (nan nan)")
wkt_has_missing("POINT (inf inf)")

wkt_is_finite("POINT (0 1)")
wkt_is_finite("POINT (nan nan)")
wkt_is_finite("POINT (inf inf)")

</code></pre>

<hr>
<h2 id='wkt_plot'>Plot well-known geometry vectors</h2><span id='topic+wkt_plot'></span><span id='topic+wkb_plot'></span>

<h3>Description</h3>

<p>These plot functions are intended to help debug geometry vectors,
and are not intended to be high-performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_plot(
  x,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE
)

wkb_plot(
  x,
  ...,
  asp = 1,
  bbox = NULL,
  xlab = "",
  ylab = "",
  rule = "evenodd",
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_plot_+3A_x">x</code></td>
<td>
<p>A <code><a href="wk.html#topic+wkt">wkt()</a></code> or <code><a href="wk.html#topic+wkb">wkb()</a></code> vector.</p>
</td></tr>
<tr><td><code id="wkt_plot_+3A_...">...</code></td>
<td>
<p>Passed to plotting functions for features: <code><a href="graphics.html#topic+points">graphics::points()</a></code>
for point and multipoint geometries, <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> for linestring
and multilinestring geometries, and <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code> for polygon
and multipolygon geometries.</p>
</td></tr>
<tr><td><code id="wkt_plot_+3A_asp">asp</code>, <code id="wkt_plot_+3A_xlab">xlab</code>, <code id="wkt_plot_+3A_ylab">ylab</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="wkt_plot_+3A_bbox">bbox</code></td>
<td>
<p>The limits of the plot in the form returned by <code><a href="#topic+wkt_ranges">wkt_ranges()</a></code>.</p>
</td></tr>
<tr><td><code id="wkt_plot_+3A_rule">rule</code></td>
<td>
<p>The rule to use for filling polygons (see <code><a href="graphics.html#topic+polypath">graphics::polypath()</a></code>)</p>
</td></tr>
<tr><td><code id="wkt_plot_+3A_add">add</code></td>
<td>
<p>Should a new plot be created, or should <code>x</code> be added to the
existing plot?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt_plot("POINT (30 10)")

</code></pre>

<hr>
<h2 id='wkt_set_srid'>Modify well-known geometries</h2><span id='topic+wkt_set_srid'></span><span id='topic+wkb_set_srid'></span><span id='topic+wkt_set_z'></span><span id='topic+wkb_set_z'></span><span id='topic+wkt_transform'></span><span id='topic+wkb_transform'></span>

<h3>Description</h3>

<p>Modify well-known geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_set_srid(wkt, srid, precision = 16, trim = TRUE)

wkb_set_srid(wkb, srid)

wkt_set_z(wkt, z, precision = 16, trim = TRUE)

wkb_set_z(wkb, z)

wkt_transform(wkt, trans, precision = 16, trim = TRUE)

wkb_transform(wkb, trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_set_srid_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkt_set_srid_+3A_srid">srid</code></td>
<td>
<p>An integer spatial reference identifier with a user-defined meaning.
Use <code>NA</code> to unset this value.</p>
</td></tr>
<tr><td><code id="wkt_set_srid_+3A_precision">precision</code></td>
<td>
<p>The rounding precision to use when writing
(number of decimal places).</p>
</td></tr>
<tr><td><code id="wkt_set_srid_+3A_trim">trim</code></td>
<td>
<p>Trim unnecessary zeroes in the output?</p>
</td></tr>
<tr><td><code id="wkt_set_srid_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
<tr><td><code id="wkt_set_srid_+3A_z">z</code></td>
<td>
<p>A Z value that will be assigned to every coordinate in each feature.
Use <code>NA</code> to unset this value.</p>
</td></tr>
<tr><td><code id="wkt_set_srid_+3A_trans">trans</code></td>
<td>
<p>A 3x3 transformation matrix that will be applied to all coordinates
in the input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unclassed well-known vector with the same type
as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt_set_srid("POINT (30 10)", 1234)
wkt_set_z("POINT (30 10)", 1234)
wkt_transform(
  "POINT (0 0)",
  # translation +12 +13
  matrix(c(1, 0, 0, 0, 1, 0, 12, 13, 1), ncol = 3)
)

</code></pre>

<hr>
<h2 id='wkt_unnest'>Flatten nested geometry structures</h2><span id='topic+wkt_unnest'></span><span id='topic+wkb_unnest'></span>

<h3>Description</h3>

<p>Flatten nested geometry structures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_unnest(wkt, keep_empty = FALSE, keep_multi = TRUE, max_depth = 1)

wkb_unnest(wkb, keep_empty = FALSE, keep_multi = TRUE, max_depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkt_unnest_+3A_wkt">wkt</code></td>
<td>
<p>A character vector containing well-known text.</p>
</td></tr>
<tr><td><code id="wkt_unnest_+3A_keep_empty">keep_empty</code></td>
<td>
<p>If <code>TRUE</code>, a GEOMETRYCOLLECTION EMPTY is left as-is
rather than collapsing to length 0.</p>
</td></tr>
<tr><td><code id="wkt_unnest_+3A_keep_multi">keep_multi</code></td>
<td>
<p>If <code>TRUE</code>, MULTI* geometries are not expanded to sub-features.</p>
</td></tr>
<tr><td><code id="wkt_unnest_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum recursive GEOMETRYCOLLECTION depth to unnest.</p>
</td></tr>
<tr><td><code id="wkt_unnest_+3A_wkb">wkb</code></td>
<td>
<p>A <code>list()</code> of <code><a href="base.html#topic+raw">raw()</a></code> vectors, such as that
returned by <code>sf::st_as_binary()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unclassed vector with attribute <code>lengths</code>, which is an integer vector
with the same length as the input denoting the length to which each
feature was expanded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt_unnest("GEOMETRYCOLLECTION (POINT (1 2), POINT (3 4))")
wkt_unnest("GEOMETRYCOLLECTION EMPTY")
wkt_unnest("GEOMETRYCOLLECTION EMPTY", keep_empty = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
