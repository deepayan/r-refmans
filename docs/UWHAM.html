<!DOCTYPE html><html><head><title>Help for package UWHAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UWHAM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#UWHAM-package'>
<p>A R package for the unbinned weighted histogram analysis method (UWHAM)</p></a></li>
<li><a href='#cyclooctanol'><p>A simulated tempering dataset of interaction parameters and binding energies</p></a></li>
<li><a href='#histw'><p>Weighted histogram</p></a></li>
<li><a href='#insert'>
<p>Inserting a value into a vector</p></a></li>
<li><a href='#ligand2.hard'><p>A dataset of binding energies obtained with a conventional interaction potential</p></a></li>
<li><a href='#ligand2.soft'><p>A dataset of binding energies with a soft-core interaction potential</p></a></li>
<li><a href='#obj.fcn'>
<p>The objective function for UWHAM</p></a></li>
<li><a href='#uwham'>
<p>Unbinned weighted histogram analysis method (UWHAM) for estimating free energies</p></a></li>
<li><a href='#uwham.boot'>
<p>Variance estimation for UWHAM based on block bootstrap</p></a></li>
<li><a href='#uwham.phi'>
<p>Unbinned weighted histogram analysis method (UWHAM) for estimating expectations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unbinned Weighted Histogram Analysis Method (UWHAM)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhiqiang Tan and Emilio Gallicchio</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhiqiang Tan &lt;ztan@stat.rutgers.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.rutgers.edu/~ztan">http://www.stat.rutgers.edu/~ztan</a>,
<a href="https://www.compmolbiophysbc.org">https://www.compmolbiophysbc.org</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A method for estimating log-normalizing constants (or free
        energies) and expectations from multiple distributions (such as
        multiple generalized ensembles).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.1), trust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-20 13:03:56 UTC; Ztan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-20 14:00:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='UWHAM-package'>
A R package for the unbinned weighted histogram analysis method (UWHAM)
</h2><span id='topic+UWHAM-package'></span><span id='topic+UWHAM'></span>

<h3>Description</h3>

<p>UWHAM for estimating log-normalizing constants (or free energies) and
expectations from multiple distributions (such as
multiple generalized ensembles).
</p>


<h3>Details</h3>

<p>The R package <code>UWHAM</code> &ndash; version 1.0 can be used for two main tasks:
</p>

<ul>
<li><p> to estimate log-normalizing constants (or free energies) from multiple distributions,
</p>
</li>
<li><p> to estimate expectations from multiple distributions.
</p>
</li></ul>

<p>There are 3 main functions:
</p>

<ul>
<li> <p><code>uwham()</code>: to estimate free energies and associated variances,
</p>
</li>
<li> <p><code>uwham.phi()</code>: to estimate expectations and associated variances,
</p>
</li>
<li> <p><code>uwham.boot()</code>: to estimate variances based on block bootstrap.
</p>
</li></ul>

<p>The package also provides a function, <code>histw()</code>, for plotting weighted histograms. 
</p>

<hr>
<h2 id='cyclooctanol'>A simulated tempering dataset of interaction parameters and binding energies</h2><span id='topic+cyclooctanol'></span>

<h3>Description</h3>

<p>Time series of interaction parameters and corresponding
binding energies from a Hamiltonian hopping simulation of molecular binding.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cyclooctanol)</code></pre>


<h3>Format</h3>

<p>A data frame containing 2 columns and 35000 rows.</p>


<h3>Details</h3>

 
<p>The dataset contains ligand-receptor interaction
parameters (lambda) and binding energies for the equivalent of an
Hamiltonian hopping simulation of cyclooctanol binding to
beta-cyclodextrin. (Hamiltonian hopping is the same as simulated
tempering except that potential parameters are varied rather than
temperature.) This illustrative dataset was constructed
by concatenating the output of some of the replicas of a 
Hamiltonian replica exchange simulation of the same complex (Wickstrom
et al. 2013). Harmless discontinuities may be observed at the joining points.
</p>
<p>The dataset contains 2 columns and 3500 rows. Rows correspond to
consecutive time points. The first column <code>cyclooctanol$V1</code>
contains lambda values (24 discrete values between 0 and 1) and the second column
<code>cyclooctanol$V2</code> records binding energy values in kcal/mol.
</p>


<h3>References</h3>

<p>Wickstrom, L., Gallicchio, E., He, P., and Levy, R.M. (2013)
&quot;Large scale affinity calculations of cyclodextrin host-guest complexes:
Understanding the role of reorganization in the molecular recognition
process,&quot; <em>Journal of Chemical Theory and Computation</em>, submitted for publication.
</p>

<hr>
<h2 id='histw'>Weighted histogram</h2><span id='topic+histw'></span>

<h3>Description</h3>

<p>This function plots a weighted histogram.</p>


<h3>Usage</h3>

<pre><code class='language-R'>histw(x, w, xaxis, xmin, xmax, ymax, 
          bar=TRUE, add=FALSE, col="black", dens=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histw_+3A_x">x</code></td>
<td>
<p>A data vector.</p>
</td></tr>
<tr><td><code id="histw_+3A_w">w</code></td>
<td>
<p>A weight vector, which will be rescaled to sum up to one.</p>
</td></tr>
<tr><td><code id="histw_+3A_xaxis">xaxis</code></td>
<td>
<p>A vector of cut points.</p>
</td></tr>
<tr><td><code id="histw_+3A_xmin">xmin</code></td>
<td>
<p>The minimum of <code>x</code> coordinate.</p>
</td></tr>
<tr><td><code id="histw_+3A_xmax">xmax</code></td>
<td>
<p>The maximum of <code>x</code> coordinate.</p>
</td></tr>
<tr><td><code id="histw_+3A_ymax">ymax</code></td>
<td>
<p>The maximum of <code>y</code> coordinate.</p>
</td></tr>
<tr><td><code id="histw_+3A_bar">bar</code></td>
<td>
<p>bar plot (if <code>TRUE</code>) or line plot.</p>
</td></tr>
<tr><td><code id="histw_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, the plot is added to an existing plot.</p>
</td></tr>
<tr><td><code id="histw_+3A_col">col</code></td>
<td>
<p>color of lines.</p>
</td></tr>
<tr><td><code id="histw_+3A_dens">dens</code></td>
<td>
<p>if <code>TRUE</code>, the histogram has a total area of one.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Boltzmann constant
bet &lt;- 1.0/(0.001986209*300.0)

# negative potential function 
npot.fcn &lt;- function(x, lam)
   -bet*lam*x

# read data (soft.core)
lam &lt;- c(0.0, 0.001, 0.002, 0.004, 0.006, 0.008, 0.01, 0.02, 0.06, 0.1,
         0.25, 0.5, 0.75, 0.9, 1.0)
m &lt;- length(lam)

data(ligand2.soft)
lig.data &lt;- ligand2.soft$V1

size &lt;- rep(1000, m)
N &lt;- sum(size)

# compute negative potential
neg.pot &lt;- matrix(0, N,m)

for (j in 1:length(lam))
  neg.pot[,j] &lt;- npot.fcn(x=lig.data, lam=lam[j])

# estimate free energies 
out &lt;- uwham(logQ=neg.pot, size=size, fisher=TRUE)

-out$ze/bet + 0.71

sqrt(out$ve)/bet

# the bins used to construct weighted histograms 
bins &lt;- seq(-35, 400, 2.5)
grid &lt;- c(bins, 2e+3)

W &lt;- out$W /N

par(mfrow=c(1,2))

# Plot the weighted histograms at two lambdas
histw(lig.data, w=W[,8], xaxis=grid, xmin=-35, xmax=200, ymax=.1)

histw(lig.data, w=W[,10], xaxis=grid, xmin=-35, xmax=200, ymax=.1, 
      bar=0, add=TRUE, col="red")

# plot the raw histogram and weighted histogram
histw(lig.data[ (5*1000+1):(6*1000) ], w=rep(1,1000), 
      xaxis=grid, xmin=-35, xmax=200, ymax=.04)

histw(lig.data, w=W[,6], xaxis=grid, xmin=-35, xmax=200, ymax=.04, 
      bar=0, add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='insert'>
Inserting a value into a vector
</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>This inserts a value <code>x0</code> at <code>d</code>-th position of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(x, d, x0 = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="insert_+3A_d">d</code></td>
<td>
<p>A position in <code>x</code>.</p>
</td></tr>
<tr><td><code id="insert_+3A_x0">x0</code></td>
<td>
<p>A value to be inserted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting vector.
</p>

<hr>
<h2 id='ligand2.hard'>A dataset of binding energies obtained with a conventional interaction potential</h2><span id='topic+ligand2.hard'></span>

<h3>Description</h3>

<p>A dataset for protein-ligand binding with an unmodified energy function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ligand2.hard)</code></pre>


<h3>Format</h3>

<p>A data frame containing 1 column and 18000 rows.</p>


<h3>Details</h3>

 
<p>The dataset contains binding energies (in kcal/mol) for the ligand
2/FKBP complex with an unmodified
energy function, simulated using replica exchange with 18 lambda values
(Tan et al. 2012).
</p>
<p>Suppose that the dataset is converted to a <code>1000 x 18</code> matrix as
follows.
</p>
<pre>
  data(ligand2.hard)
  lig.data &lt;- matrix(ligand2.hard$V1, nrow=1000)
</pre>
<p>The 18 columns of <code>lig.data</code>
correspond to the raw output of the 18 replicas. A replica is defined as a continuous
replica exchange molecular dynamics thread with variable lambda (exchanges are
performed by swapping lambda values rather than coordinates). The 1000
rows represent as many sequential time points during the replica
exchange trajectory. Each row contains binding energies from each
replica taken at the same simulation time (synchronous sampling).
</p>


<h3>References</h3>

<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy
estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>

<hr>
<h2 id='ligand2.soft'>A dataset of binding energies with a soft-core interaction potential</h2><span id='topic+ligand2.soft'></span>

<h3>Description</h3>

<p>A dataset for protein-ligand binding with a soft energy function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ligand2.soft)</code></pre>


<h3>Format</h3>

<p>A data frame containing 1 column and 15000 rows.</p>


<h3>Details</h3>

 
<p>The dataset contains binding energies (in kcal/mol) for the ligand
2/FKBP complex with a soft-core interaction energy function, 
simulated using replica exchange with 15 lambda values
(Tan et al. 2012).
</p>
<p>Suppose that the dataset is converted to a <code>1000 x 15</code> matrix as follows.
</p>
<pre>
data(ligand2.soft)
lig.data &lt;- matrix(ligand2.soft$V1, nrow=1000)
</pre>
<p>The 15 columns of <code>lig.data</code> correspond to the 15 lambda states
from smallest (lambda=0) to largest (lambda=1).  The data were obtained
by reordering by lambda the raw output of the molecular
dynamics replicas at each observation time. A replica is defined as a continuous
replica exchange molecular dynamics thread with variable lambda (exchanges are
performed by swapping lambda values rather than coordinates). The 1000
rows represent as many sequential time points during the replica
exchange trajectory. Each row contains binding energies from each
replica taken at the same simulation time (synchronous sampling).
</p>


<h3>References</h3>

<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy
estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>

<hr>
<h2 id='obj.fcn'>
The objective function for UWHAM
</h2><span id='topic+obj.fcn'></span>

<h3>Description</h3>

<p>This function computes the objective function, its gradient and its hessian matrix for UWHAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.fcn(ze, logQ, size, base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.fcn_+3A_ze">ze</code></td>
<td>
<p>A vector of log-normalizing constants (or free energies) for the sampled thermodynamic states.</p>
</td></tr>
<tr><td><code id="obj.fcn_+3A_logq">logQ</code></td>
<td>
<p>The matrix of log of unnormalized density ratios for the sampled thermodynamic states over the baseline.</p>
</td></tr>
<tr><td><code id="obj.fcn_+3A_size">size</code></td>
<td>
<p>A vector giving the individual sample sizes for the sampled thermodynamic states.</p>
</td></tr>
<tr><td><code id="obj.fcn_+3A_base">base</code></td>
<td>
<p>The baseline index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objective function is convex as discussed in Tan et al. (2012). See also Gill et al. (1998) for related results on biased sampling models. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>value</code></td>
<td>
<p>The value of the objective function.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>The gradient of the objective function.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The hessian matrix of objective function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gill, R., Vardi, Y., and Wellner, J. (1998) &quot;Large sample theory of empirical distributions in biased sampling models,&quot; <em>Annals of Statistics</em>, 16, 1069&ndash;1112.
</p>
<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>

<hr>
<h2 id='uwham'>
Unbinned weighted histogram analysis method (UWHAM) for estimating free energies
</h2><span id='topic+uwham'></span>

<h3>Description</h3>

<p>This function implements UWHAM for estimating log-normalizing constants
(or free energies) and expectations from multiple distributions (such as
multiple generalized ensembles) as described in Tan et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uwham(label=NULL, logQ, size=NULL, base = NULL, init = NULL, 
      fisher = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uwham_+3A_label">label</code></td>
<td>
<p>A vector of length <code>N</code> of labels between <code>1</code> to <code>M</code>
such that <code>label[i]=j</code> when <code>i</code>th observation is obtained
from <code>j</code>th thermodynamic state; 
either <code>label</code> or <code>size</code> must be provided;
if <code>fisher=FALSE</code> and if <code>label=NULL</code>, then <code>label</code> 
is set such that the first <code>size[1]</code> observations are assumed to be from state <code>1</code>, the
next <code>size[2]</code> observations from state <code>2</code>, etc.</p>
</td></tr>
<tr><td><code id="uwham_+3A_logq">logQ</code></td>
<td>
<p><code>N x M</code> matrix of log unnormalized densities (such as <code class="reqn">1/kT</code>
times negative potential energies), where
<code>N</code> is the total sample size, i.e., <code>sum(size)</code>, and
<code>M</code> is the number of thermodynamic states for which free energies are to be computed;
the <code>i</code>th row of <code>logQ</code> correspond to <code>i</code>th observations and 
the <code>j</code>th column correspond to <code>j</code>th thermodynamic state.</p>
</td></tr>
<tr><td><code id="uwham_+3A_size">size</code></td>
<td>
<p>A vector of length <code>M</code>, giving the individual sample
sizes for the <code>M</code> thermodynamic states, ordered as the columns of <code>logQ</code>;
if <code>NULL</code>, then <code>label</code> is required and used to compute <code>size</code>.</p>
</td></tr>
<tr><td><code id="uwham_+3A_base">base</code></td>
<td>
<p>The baseline index, between <code>1</code> to <code>M</code>, for the
thermodynamic state (with sample size <code>&gt;0</code>) whose free energy is set to 0; if <code>NULL</code>, 
then <code>base</code> is set to the first index <code>j</code> such that <code>size[j]&gt;0</code>.</p>
</td></tr>
<tr><td><code id="uwham_+3A_init">init</code></td>
<td>
<p>A vector of length <code>M</code>, giving the initial values of
the log-normalizing constants (or log of the partition
functions); if <code>NULL</code>, then <code>init</code> is set to the zero vector.</p>
</td></tr>
<tr><td><code id="uwham_+3A_fisher">fisher</code></td>
<td>
<p>Logical; if <code>NULL</code>, no variance estimation; if <code>TRUE</code>, variance estimation is based
on Fisher information; if <code>FALSE</code>, variance estimation is based on the Sandwich variance formula (see the details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The UWHAM method results from a number of interesting, sometimes independent, developments in physics and
statistics.
See Kong et al. (2003) for a formal statistical treatment along with earlier references, and Tan et al. (2012)
for a
more accessible account, presenting the method as a binless extension of the Weighted Histogram Analysis
Method (WHAM)
widely known in physics and chemistry (e.g., Ferrenberg and Swendsen
1989). The possibility of obtaining free energies from a binless extension of
WHAM was noticed by various authors (e.g., Kumar et al. 1992; Newman &amp; Barkema 1999). 
The binless method was later reintroduced
by Shirts &amp; Chodera (2008) to the physics literature and was called the Multi-state
Bennet Acceptance Ratio method (MBAR) because it can be interpreted as a multi-state extension of the Bennet
Acceptance Ratio (BAR) method. An implementation of MBAR in the Python language 
developed by Shirts &amp; Chodera is freely available (see
https://simtk.org/home/pymbar).
The UWHAM package, while adopting an alternative numerical approach,
provides identical point estimates compared to
the MBAR Python package. In addition, the UWHAM package provides 
variance estimation based on variance formulas without using generalized inverses or, for
correlated data, by block bootstrap.
</p>
<p>A typical application of UWHAM involves the computation of the relative
free energies of a series of thermodynamic states differing in
environmental conditions (temperature for example) and/or Hamiltonian
parameters (such as the strength of biasing potentials) from
data collected at these thermodynamic states. The
method takes as input the reduced energies (such as the inverse temperature
times the negative of the potential energy for canonical ensembles
differing in temperature) of the observations at all
thermodynamic states of interest.
In addition to the free energies, the
output includes estimates of the thermodynamic weights of the
observations for all states
to be used for thermodynamic reweighting
calculations.
</p>
<p>The UWHAM method is statistically optimal in yielding the smallest asymptotic variances, provided that the
individual samples 
are independent and the observations in each sample are also
independent (Tan 2004).
</p>
<p>To compute point estimates, the method is implemented here by minimizing
a convex objective function, as described in Tan et al. (2012).
This approach can be more effective than solving the nonlinear equations by the self-consistency or the
Newton-Raphson algorithm.
Currently, the optimization is done by using the R package <em>trust</em>. 
</p>
<p>Variance estimation provided here is based on the Fisher information or the Sandwich variance formula, 
as presented in Tan et al. (2012).  
In contrast with the Sandwich formula, the Fisher information based formula does not require labels indicating   
which thermodynamic state each observation is obtained from (see the dataset <code><a href="#topic+ligand2.hard">ligand2.hard</a></code>). 
The analytical variance formulas are consistent when the observations are considered independent.
Alternatively, variance estimation can be done by block bootstrap, implemented in <code><a href="#topic+uwham.boot">uwham.boot</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ze</code></td>
<td>
<p>The vector of estimated log-normalizing constants (or log of the partition
functions).</p>
</td></tr>
<tr><td><code>ve</code></td>
<td>
<p>The vector of estimated variances for <code>ze</code>, if <code>fisher!=NULL</code>.</p>
</td></tr>
<tr><td><code>Ve</code></td>
<td>
<p>The estimated variance-covariance matrix for <code>ze</code>, if <code>fisher!=NULL</code>.</p>
</td></tr> 
<tr><td><code>W</code></td>
<td>
<p>The <code>N x M</code> matrix of UWHAM weights for each of the
<code>N</code> observations at each of the <code>M</code> thermodynamic states.</p>
</td></tr> 
<tr><td><code>check</code></td>
<td>
<p>The column averages of <code>W[,sampled]</code>; 
the elements of <code>check</code> should be equal to <code>1</code> to indicate a valid convergence of <em>trust</em>.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>The output of <em>trust</em> used to minimize the objective function; see help(trust).</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>Same as argument <code>label</code>.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Same as argument <code>size</code>.</p>
</td></tr>
<tr><td><code>base</code></td>
<td>
<p>Same as argument <code>base</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ferrenberg, A.M. and Swendsen, R.H. (1989) &quot;Optimized Monte Carlo data analysis,&quot;
<em>Physics Review Letters</em>, 63, 1195-1198.
</p>
<p>Kong, A., McCullagh, P., Meng, X.-L., Nicolae, D., and Tan, Z. (2003) &quot;A theory of statistical models for
Monte Carlo integration&quot; (with discussion), <em>Journal of the Royal Statistical Society</em>, Ser. B, 65, 
585-618. 
</p>
<p>Kumar, S., Bouzida, D., Swendsen, R.H., Kollman, P.A. and Rosenberg, J.M. (1992) 
&quot;The Weighted Histogram Analysis Method for free-energy
calculations on biomolecules. I. The method,&quot; <em>Journal of Computational Chemistry</em>, 13, 1011-1021.
</p>
<p>Newman, M.E.J. and Barkema, G.T. (1999) <em>Monte Carlo Methods in Statistical
Physics</em>, Oxford University Press, New York.
</p>
<p>Shirts, M.R. and J. D. Chodera, J.D. (2008) &quot;Statistically optimal analysis of samples from multiple
equilibrium states,&quot;
<em>Journal of Chemical Physics</em>, 129, 124105.
</p>
<p>Tan, Z. (2004) &quot;On a likelihood approach for Monte Carlo integration,&quot; <em>Journal of the American
Statistical Association</em>, 99, 1027-1036.
</p>
<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy
estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################################
############## example 1 ##############  
#######################################

# This example illustrates the calculation of the standard free energy
# of binding of a ligand to a protein receptor by means of an alchemical
# perturbation potential of the form lambda*binding_energy(r), where
# lambda is a scaling parameter (lambda=0 corresponds to the
# protein-ligand uncoupled state, and lambda=1 corresponds to the
# coupled state) and binding_energy(r) is the (solvent averaged)
# potential energy of conformation r of the complex relative to one in
# which the receptor and the ligand are rigidly displaced at infinite
# separation. See Gallicchio et al., J. Chem. Theory Comput. 6,
# 2961-2977 (2010), and Tan et al. J. Chem. Phys., 136, 144102 (2012).

# Inverse temperature beta, in kcal/mol^-1
bet &lt;- 1.0/(0.001986209*300.0)

# negative reduced potential function -beta*lambda*binding_energy.
#  "x" is the binding energy of a structure of the complex and "lam" the
#  value of lambda at which to compute the reduced energy
npot.fcn &lt;- function(x, lam)
   -bet*lam*x

# values of lambda for the calculation with a "hard-core" potential 
lam &lt;- c(0.0, 0.000000001, 0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001,
         0.001, 0.01, 0.1, 0.15, 0.25, 0.35, 0.5, 0.6, 0.75, 0.9, 1.0)

#number of alchemical states
m &lt;- length(lam)

# load binding energies
data(ligand2.hard)
lig.data &lt;- ligand2.hard$V1

# 1000 observations at each lambda state
size &lt;- rep(1000, m)

# total sample size
N &lt;- sum(size)

# compute negative potential of each observation at each lambda state
neg.pot &lt;- matrix(0, N,m)
for (j in 1:length(lam))
  neg.pot[,j] &lt;- npot.fcn(x=lig.data, lam=lam[j])

# estimate free energies using UWHAM
out &lt;- uwham(logQ=neg.pot, size=size, fisher=TRUE)

# convergence diagnosis: the elements should be equal to 1 
out$check

# the "ze" values are dimensionless free energies, that is the
# log of the partition functions (log Z). 
# To obtain thermodynamic free energies, multiply by -kT.
# 0.71 kcal/mol is the standard state correction; see
# Lapelosa et al. J Chem Theory Comput, 8, 44-60 (2012).
-out$ze/bet + 0.71

# variances of free energies from Fisher information
sqrt(out$ve)/bet

# perform block bootstrap for free energies to take into account
# time correlations in the binding energy data
# To save time for package checking, this is not run.
#out.boot &lt;- uwham.boot(proc.type="parallel", block.size=50, boot.size=100, 
#                       logQ=neg.pot, size=size)
#
#-out.boot$ze/bet + 0.71
#sqrt(out.boot$ve)/bet

# estimation of average binding energies and variances 
# at lambda = 0.6, 0.75, 0.9, 1.0
state &lt;- 15:18
out.phi &lt;- uwham.phi(phi=lig.data, state=state, out.uwham=out, fisher=TRUE)

out.phi$phi
out.phi$phi.v 

# block bootstrap for both free energies and expectations
# To save time for package checking, this is not run.
#out.boot &lt;- uwham.boot(proc.type="parallel", block.size=50, boot.size=100, 
#                       logQ=neg.pot, size=size, 
#                       phi=lig.data, state=state)
#
#out.boot$phi
#out.boot$phi.v

################################################
## example 2 (unequal and zero sample sizes) ###
################################################

# same calculation as above but with a "soft-core" potential and
# illustrating the ability to compute free energies and expectations
# for states with unequal sample sizes including those with
# zero sample sizes (or states that have not been sampled).
# See Tan et al. J. Chem. Phys., 136, 144102 (2012).

rm(list=ls())

# inverse temperature
bet &lt;- 1.0/(0.001986209*300.0)

# negative potential function 
npot.fcn &lt;- function(x, lam)
   -bet*lam*x

# read data (soft core)
lam &lt;- c(0.0, 0.001, 0.002, 0.004, 0.006, 0.008, 0.01, 0.02, 0.06, 0.1,
         0.25, 0.5, 0.75, 0.9, 1.0)
m &lt;- length(lam)

data(ligand2.soft)
lig.data &lt;- ligand2.soft$V1

### unequal and zero sample sizes
size &lt;- c( rep(1000, 5), rep(500, 3), rep(0, 2), rep(1000,5))
subs &lt;- c(rep(TRUE, 5000), rep(c(rep(TRUE,500),rep(FALSE,500)), 3),
          rep(FALSE, 2000), rep(TRUE,5000))
lig.data &lt;- lig.data[subs]

N &lt;- sum(size)

# compute negative potential
neg.pot &lt;- matrix(0, N,m)
for (j in 1:length(lam))
  neg.pot[,j] &lt;- npot.fcn(x=lig.data, lam=lam[j])

# estimate free energies 
out &lt;- uwham(logQ=neg.pot, size=size, fisher=TRUE)

-out$ze/bet + 0.71
sqrt(out$ve)/bet

# block bootstrap for free energies, 
# pretending that the data are generated from independent chains.
# To save time for package checking, this is not run.
#out.boot &lt;- uwham.boot(proc.type="indep", 
#                       block.size=rep(50,m-2), boot.size=100, 
#                       logQ=neg.pot, size=size)
#
#-out.boot$ze/bet + 0.71
#sqrt(out.boot$ve)/bet

#######################################
## example 3 (serial tempering data) ##
#######################################

rm(list=ls())

# inverse temperature
bet &lt;- 1.0/(0.001986209*300.0)

# negative potential function 
npot.fcn &lt;- function(x, lam)
   -bet*lam*x

# lambda states
lam &lt;- c(0.0,0.001,0.002,0.004,0.005,0.006,0.008,0.01,0.02,0.04,
         0.07,0.1,0.25,0.5,0.55,0.6,0.65,0.7,0.75,0.8,
         0.85,0.9,0.95,1.0)
m &lt;- length(lam)

# loads cyclooctanol dataset
data(cyclooctanol)
lig.data &lt;- cyclooctanol$V2

# sample size
N &lt;- length(lig.data)

# state labels based on lambda values
# note that labels=1:m, not 0:(m-1)
state.labels &lt;- factor(cyclooctanol$V1, labels=1:m)

# compute negative potential
neg.pot &lt;- matrix(0, N,m)
for (j in 1:m)
  neg.pot[,j] &lt;- npot.fcn(x=lig.data, lam=lam[j])

# estimate free energies, note that size=NULL because label is given
out &lt;- uwham(label=state.labels, logQ=neg.pot, fisher=TRUE)

# free energies as a function of lambda, 0.36 kcal/mol is a standard
# state correction
-out$ze/bet + 0.36
sqrt(out$ve)/bet

# block bootstrap for free energies, note that proc.type="serial"
# for simulated tempering data.
# To save time for package checking, this is not run.
#out.boot &lt;- uwham.boot(proc.type="serial", block.size=10, boot.size=100, 
#                       label=state.labels, logQ=neg.pot)
#
#-out.boot$ze/bet + 0.36
#sqrt(out.boot$ve)/bet
</code></pre>

<hr>
<h2 id='uwham.boot'>
Variance estimation for UWHAM based on block bootstrap
</h2><span id='topic+uwham.boot'></span>

<h3>Description</h3>

<p>This function implements variance estimation based on block bootstrap for UWHAM estimates of free energies and
expectations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uwham.boot(proc.type, block.size, boot.size, seed = 0, 
           label = NULL, logQ, size=NULL, base = NULL, init = NULL, 
           phi = NULL, state = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uwham.boot_+3A_proc.type">proc.type</code></td>
<td>
<p>Type of simulation, <code>"indep"</code> for independent chains at the thermodynamic states, 
<code>"parallel"</code> for (synchronous) parallel tempering, or 
<code>"serial"</code> for (single-chain) serial tempering (see the details).</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_block.size">block.size</code></td>
<td>
<p>A vector of length <code>m=sum(size&gt;0)</code> (or recycled to be so),
giving possibly different block sizes for the <code>m</code> sampled thermodynamic states
if <code>proc.type=</code> <code>"indep"</code>, or 
a scalar (or truncated to the first element), 
giving a single block size if <code>proc.type="parallel"</code> or 
<code>"serial"</code>.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_boot.size">boot.size</code></td>
<td>
<p>The number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generation.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_label">label</code></td>
<td>
<p>A vector of length <code>N</code> of labels between <code>1</code> to <code>M</code>
such that <code>label[i]=j</code> when <code>i</code>th observation is obtained 
from <code>j</code>th thermodynamic state;
either <code>label</code> or <code>size</code> must be provided if <code>proc.type="indep"</code> or <code>"parallel"</code>;
<code>label</code> must be provided but <code>size</code> is optional if <code>proc.type="serial"</code>.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_logq">logQ</code></td>
<td>
<p><code>N x M</code> matrix of log unnormalized densities (such as <code class="reqn">1/kT</code>
times negative potential energies), where 
<code>N</code> is the total sample size, i.e., <code>sum(size)</code>, and
<code>M</code> is the number of thermodynamic states for which free energies are to be computed;
the <code>i</code>th row of <code>logQ</code> correspond to <code>i</code>th observations and 
the <code>j</code>th column correspond to <code>j</code>th thermodynamic state.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_size">size</code></td>
<td>
<p>A vector of length <code>M</code>, giving the individual sample
sizes for the <code>M</code> thermodynamic states, ordered as the columns of <code>logQ</code>;
if <code>NULL</code>, then <code>label</code> is required and used to compute <code>size</code>.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_base">base</code></td>
<td>
<p>The baseline index, between <code>1</code> to <code>M</code>, for the
thermodynamic state (with sample size <code>&gt;0</code>) whose free energy is set to 0; if <code>NULL</code>, then 
<code>base</code> is set to the first index <code>j</code> such that <code>size[j]&gt;0</code>.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_init">init</code></td>
<td>
<p>A vector of length <code>M</code>, giving the initial values of
the log-normalizing constants (or log of the partition
functions); if <code>NULL</code>, then <code>init</code> is set to the zero vector.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_phi">phi</code></td>
<td>
<p>A vector of function values on the pooled sample; if <code>NULL</code>, no expectation is estimated.</p>
</td></tr>
<tr><td><code id="uwham.boot_+3A_state">state</code></td>
<td>
<p>A vector of indices for the thermodynamic states under which expectations are to be computed;
if <code>NULL</code>, no expectation is estimated.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The use of block bootstrap requires at least two more inputs than <code><a href="#topic+uwham">uwham</a></code>: the type of simulation <code>proc.type</code> and the time ordering of the observations. 
</p>
<p>If <code>proc.type="indep"</code>, the data are assumed to be generated by (approximately) independent chains at different thermodynamic states. The observations corresponding to the rows of <code>logQ</code> are assumed to be ordered by thermodynamic state and by simulation time within each state.
To perform block bootstrap, data blocks are resampled within each thermodynamic state and then pooled to build bootstrap samples.
</p>
<p>If <code>proc.type="parallel"</code>, the data are assumed to be generated by (synchronous) parallel tempering or replica exhanges. Equal sample sizes are required. The observations corresponding to the rows of <code>logQ</code> are assumed to be ordered by simulation time and then by <em>either</em> thermodynamic state (as in the dataset <code><a href="#topic+ligand2.soft">ligand2.soft</a></code>) <em>or</em> replica (as in the dataset <code><a href="#topic+ligand2.hard">ligand2.hard</a></code>). The synchronized block bootstrap is implemented such that blocks corresponding to the same time interval are randomly selected from all the thermodynamic states (Tan et al. 2012).
</p>
<p>If <code>proc.type="serial"</code>, the data are assumed to be generated by (single-chain) serial tempering or simulated tempering. The observations corresponding to the rows of <code>logQ</code> are assumed to be ordered by time. The thermodynamic labels must then be provided in <code>label</code>. To perform block bootstrap, data blocks are resampled from the entire chain, and the number of observations at each state is re-computed for each bootstrap sample.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ze</code></td>
<td>
<p>The vector of averages of estimated free energies over the bootstrap samples, which can differ from the output <code>ze</code> in <code><a href="#topic+uwham">uwham</a></code>.</p>
</td></tr>
<tr><td><code>ve</code></td>
<td>
<p>The vector of estimated variances for the output <code>ze</code> in <code><a href="#topic+uwham">uwham</a></code>.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>The vector of averages of estimated expectations over the bootstrap samples (which can differ from the output <code>phi</code> in <code><a href="#topic+uwham.phi">uwham.phi</a></code>), if <code>phi!=NULL</code> and <code>state!=NULL</code>.</p>
</td></tr>
<tr><td><code>phi.v</code></td>
<td>
<p>The vector of estimated variances for <code>phi</code> in <code><a href="#topic+uwham.phi">uwham.phi</a></code>, if <code>phi!=NULL</code> and <code>state!=NULL</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy 
estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#See the examples for uwham().

</code></pre>

<hr>
<h2 id='uwham.phi'>
Unbinned weighted histogram analysis method (UWHAM) for estimating expectations
</h2><span id='topic+uwham.phi'></span>

<h3>Description</h3>

<p>This function implements UWHAM for estimating expectations for multiple distributions (such as
multiple generalized ensembles) as described in Tan et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uwham.phi(phi, state, out.uwham, fisher = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uwham.phi_+3A_phi">phi</code></td>
<td>
<p>A vector of function (or observable) values on the pooled sample.</p>
</td></tr>
<tr><td><code id="uwham.phi_+3A_state">state</code></td>
<td>
<p>A vector of indices between <code>1</code> to <code>M</code> for the thermodynamic states under which expectations are to be computed.</p>
</td></tr> 
<tr><td><code id="uwham.phi_+3A_out.uwham">out.uwham</code></td>
<td>
<p>The output of <code><a href="#topic+uwham">uwham</a></code>.</p>
</td></tr>
<tr><td><code id="uwham.phi_+3A_fisher">fisher</code></td>
<td>
<p>Logical; if <code>NULL</code>, no variance estimation; if <code>TRUE</code>, variance estimation is based
on Fisher information; if <code>FALSE</code> variance estimation is based on the Sandwich variance formula (see the details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is directly based on Tan et al. (2012). See the details for <code><a href="#topic+uwham">uwham</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>phi</code></td>
<td>
<p>The vector of estimated expectations.</p>
</td></tr>
<tr><td><code>phi.v</code></td>
<td>
<p>The vector of estimated variances for <code>phi</code>, if <code>fisher!=NULL</code>.</p>
</td></tr>
<tr><td><code>phi.V</code></td>
<td>
<p>The variance-covariance matrix for <code>phi</code>, if <code>fisher!=NULL</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tan, Z., Gallicchio, E., Lapelosa, M., and Levy, R.M. (2012) &quot;Theory of binless multi-state free energy estimation with applications to protein-ligand binding,&quot; <em>Journal of Chemical Physics</em>, 136, 144102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#See the examples for uwham().

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
