<!DOCTYPE html><html><head><title>Help for package frontier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frontier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.front41Output'><p>Coefficients from Frontier 4.1</p></a></li>
<li><a href='#coef.frontier'><p>coef method for class frontier</p></a></li>
<li><a href='#coef.summary.frontier'><p>coef method for class summary.frontier</p></a></li>
<li><a href='#cooks.distance.frontier'><p>Pseudo-Cook's Distance of Stochastic Frontier Models</p></a></li>
<li><a href='#efficiencies'><p>Returning Efficiency Estimates</p></a></li>
<li><a href='#efficiencies.frontier'><p>Returning Efficiency Estimates</p></a></li>
<li><a href='#elas.frontierQuad'><p>Elasticities of a Quadratic/Translog Frontier</p></a></li>
<li><a href='#fitted.frontier'><p>Fitted and Predicted (Frontier) Values</p></a></li>
<li><a href='#front41Data'><p>Data provided with Tim Coelli's Frontier 4.1</p></a></li>
<li><a href='#front41Est'><p>Estimate a Stochastic Frontier Model by Frontier 4.1</p></a></li>
<li><a href='#front41ReadOutput'><p>Read output of Frontier 4.1</p></a></li>
<li><a href='#front41WriteInput'><p>Write input files for Frontier 4.1</p></a></li>
<li><a href='#frontierQuad'><p>Quadratic or Translog Frontiers</p></a></li>
<li><a href='#frontierTranslogRay'><p>Translog Ray Frontiers</p></a></li>
<li><a href='#logLik.frontier'><p>Extract Log-Likelihood Value</p></a></li>
<li><a href='#lrtest.frontier'><p>Likelihood Ratio test for Stochastic Frontier Models</p></a></li>
<li><a href='#resettestFrontier'><p>RESET test for Stochastic Frontier Models</p></a></li>
<li><a href='#residuals.frontier'><p>Returning Residuals</p></a></li>
<li><a href='#riceProdPhil'><p>Rice Production in the Philippines</p></a></li>
<li><a href='#sfa'><p>Stochastic Frontier Analysis</p></a></li>
<li><a href='#summary.front41Output'><p>Summarizing the Estimation of Frontier 4.1</p></a></li>
<li><a href='#summary.frontier'><p>summary method for class frontier</p></a></li>
<li><a href='#telecom'><p>Telecommunications Providers</p></a></li>
<li><a href='#vcov.frontier'><p>vcov method for class frontier</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Stochastic Frontier Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Coelli, Arne Henningsen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), micEcon (&ge; 0.6-14), lmtest (&ge; 0.9-24)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MCMCpack (&ge; 1.0-8), fdrtool (&ge; 1.2.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>moments (&ge; 0.11), stats (&ge; 2.15.0), Formula (&ge; 0.2-0),
miscTools (&ge; 0.6-1), plm (&ge; 1.0-1)</td>
</tr>
<tr>
<td>Description:</td>
<td>Maximum Likelihood Estimation of
   Stochastic Frontier Production and Cost Functions.
   Two specifications are available:
   the error components specification with time-varying efficiencies
   (Battese and Coelli, 1992, &lt;<a href="https://doi.org/10.1007%2FBF00158774">doi:10.1007/BF00158774</a>&gt;)
   and a model specification in which the firm effects are directly 
   influenced by a number of variables (Battese and Coelli, 1995,
   &lt;<a href="https://doi.org/10.1007%2FBF01205442">doi:10.1007/BF01205442</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://frontier.r-forge.r-project.org/">http://frontier.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-15 07:29:45 UTC; gsl324</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-17 16:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.front41Output'>Coefficients from Frontier 4.1</h2><span id='topic+coef.front41Output'></span><span id='topic+coef.summary.front41Output'></span><span id='topic+vcov.front41Output'></span>

<h3>Description</h3>

<p>These methods return the coefficients and their covariance matrix
from a model estimated by Frontier 4.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'front41Output'
coef( object, which = "MLE", ... )

   ## S3 method for class 'summary.front41Output'
coef( object, which = "MLE", ... )

   ## S3 method for class 'front41Output'
vcov( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.front41Output_+3A_object">object</code></td>
<td>
<p>an object of class <code>front41Output</code>
or <code>summary.front41Output</code>
(read/created by <code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code>
or <code><a href="#topic+summary.front41Output">summary.front41Output</a></code>, respectively).</p>
</td></tr>
<tr><td><code id="coef.front41Output_+3A_which">which</code></td>
<td>
<p>character string indication, which coefficients should
be returned: either 'OLS' (from OLS estimation),
'GRID' (from grid search), or
'MLE' (from maximum likelihood estimation).</p>
</td></tr>
<tr><td><code id="coef.front41Output_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>coef</code> method applied to an object of class <code>front41Output</code>
returns a vector containing all
coefficients estimated by Frontier 4.1.
</p>
<p>The <code>coef</code> method applied to an object of class
<code>summary.front41Output</code> returns a matrix containing
the estimates, their standard errors, the <code class="reqn">t</code> values and <code class="reqn">P</code> values
of all coefficients estimated by Frontier 4.1.
</p>
<p>The <code>vcov</code> method returns the covariance matrix
of all coefficients estimated by Frontier 4.1.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code></p>

<hr>
<h2 id='coef.frontier'>coef method for class frontier</h2><span id='topic+coef.frontier'></span>

<h3>Description</h3>

<p>Extract the coefficients from stochastic frontier models
returned by <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
coef( object, which = "mle", extraPar = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.frontier_+3A_object">object</code></td>
<td>
<p>an object of class <code>frontier</code>
(returned by the function <code><a href="#topic+frontier">frontier</a></code>).</p>
</td></tr>
<tr><td><code id="coef.frontier_+3A_which">which</code></td>
<td>
<p>character string. Which coefficients should be returned?
('start' for starting values provided by the user,
'ols' for coefficients estimated by OLS,
'grid' for coefficients obtained by the grid search,
or 'mle' for coefficients estimated by Maximum Likelihood).</p>
</td></tr>
<tr><td><code id="coef.frontier_+3A_extrapar">extraPar</code></td>
<td>
<p>logical. If <code>TRUE</code>, additional parameters are returned:
<code>sigmaSqU</code> = <code>sigmaSq</code> * <code>gamma</code> 
(with <code class="reqn">u</code> ~ <code class="reqn">N^+</code>( <code>mu</code>, <code>sigmaSqU</code> )), 
<code>sigmaSqV</code> = <code>sigmaSq</code> * ( 1 - <code>gamma</code> )
(with <code class="reqn">v</code> ~ N( 0, <code>sigmaSqV</code> )),
<code>sigma</code> = <code>sigmaSq</code>^0.5,
<code>sigmaU</code> = <code>sigmaSqU</code>^0.5,
<code>sigmaV</code> = <code>sigmaSqV</code>^0.5,
<code>lambdaSq</code> = <code>sigmaSqU</code> / <code>sigmaSqV</code>,
and <code>lambda</code> = <code>sigmaU</code> / <code>sigmaV</code>.
Please note that <code>sigmaSqU</code> and <code>sigmaU</code> are not
the variance and standard error, respectively, of <code class="reqn">u</code>.
If the model is an error components frontier
and argument <code>timeEffect</code> is <code>FALSE</code>,
also the following additional parameters are returned:
<code>varU</code> = the variance of <code class="reqn">u</code>,
<code>sdU</code> = <code>varU</code>^0.5,
and <code>gammaVar</code> = <code>varU</code> / ( <code>varU</code> + <code>sigmaSqV</code> ).
Please note that the variance of <code class="reqn">u</code>
usually differs between observations
if the model is an error component frontier with &lsquo;time effect&rsquo;
or an efficiency effects frontier.</p>
</td></tr>
<tr><td><code id="coef.frontier_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef.frontier</code> returns a named vector of the coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.summary.frontier">coef.summary.frontier</a></code> and <code><a href="#topic+sfa">sfa</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1
   data( front41Data )

   sfaResult &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   coef( sfaResult, which = "ols" )
   coef( sfaResult, which = "grid" )
   coef( sfaResult )
</code></pre>

<hr>
<h2 id='coef.summary.frontier'>coef method for class summary.frontier</h2><span id='topic+coef.summary.frontier'></span>

<h3>Description</h3>

<p>Extract the coefficients, their standard errors, z-values or t-values,
and (asymptotic) P-values
from stochastic frontier models returned by the <code>summary</code> method
for objects of class <code>frontier</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.frontier'
coef( object, which = "mle", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.summary.frontier_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+summary.frontier">summary.frontier</a></code>
(returned by the <code>summary</code> method for objects
of class <code>frontier</code></p>
</td></tr>
<tr><td><code id="coef.summary.frontier_+3A_which">which</code></td>
<td>
<p>character string. Which coefficients should be returned?
('ols' for coefficients estimated by OLS
or 'mle' for coefficients estimated by Maximum Likelihood).</p>
</td></tr>
<tr><td><code id="coef.summary.frontier_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard errors of the estimated parameters
are taken from the direction matrix
that is used in the final iteration of the Davidon-Fletcher-Powell procedure
that is used for maximising the (log) likelihood function.
</p>
<p>If argument <code>which</code> of this method is <code>"mle"</code> (the default)
and argument <code>extraPar</code> of <code><a href="#topic+summary.frontier">summary.frontier</a></code>
is set to <code>TRUE</code>,
some additional parameters, their standard errors, z-values,
and (asymptotic) P-values are returned
(see documentation of <code><a href="#topic+summary.frontier">summary.frontier</a></code>, 
<code><a href="#topic+coef.frontier">coef.frontier</a></code>, or <code><a href="#topic+vcov.frontier">vcov.frontier</a></code>).
The standard errors of the additional parameters
are obtained by the delta method.
Please note that the delta method might provide poor approximations
of the &lsquo;true&rsquo; standard errors,
because parameter <code class="reqn">\sigma^2</code> is left-censored
and parameter <code class="reqn">\gamma</code> is both left-censored and right-censored
so that these parameters cannot be normally distributed.
</p>
<p>Please note further
that the t statistic and the z statistic are not reliable
for testing the statistical signicance of <code class="reqn">\sigma^2</code>,
<code class="reqn">\gamma</code>, and the &lsquo;additional parameters&rsquo;,
because these parameters are censored and cannot follow 
a normal distribution or a t distribution.
</p>


<h3>Value</h3>

<p>The <code>coef</code> method for objects of class <code>summary.frontier</code> 
returns a matrix,
where the four columns contain the estimated
coefficients, their standard errors, z-values or t-values,
and (asymptotic) P-values.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.frontier">coef.frontier</a></code>, <code><a href="#topic+summary.frontier">summary.frontier</a></code>,
<code><a href="#topic+vcov.frontier">vcov.frontier</a></code>, and <code><a href="#topic+sfa">sfa</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1
   data( front41Data )

   sfaResult &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   coef( summary( sfaResult ), which = "ols" )
   coef( summary( sfaResult ) )
   coef( summary( sfaResult, extraPar = TRUE ) )
</code></pre>

<hr>
<h2 id='cooks.distance.frontier'>Pseudo-Cook's Distance of Stochastic Frontier Models</h2><span id='topic+cooks.distance.frontier'></span>

<h3>Description</h3>

<p>This method returns the Pseudo-Cook's distances
from stochastic frontier models
estimated with the <span class="pkg">frontier</span> package 
(e.g., function <code><a href="#topic+sfa">sfa</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
cooks.distance( model, target = "predict",
   asInData = FALSE, progressBar = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooks.distance.frontier_+3A_model">model</code></td>
<td>
<p>a stochastic frontier model
estimated with the <span class="pkg">frontier</span> package 
(e.g. function <code><a href="#topic+sfa">sfa</a></code>).</p>
</td></tr>
<tr><td><code id="cooks.distance.frontier_+3A_target">target</code></td>
<td>
<p>character string. 
If <code>"predict"</code>, the returned values indicate 
the influence of individual observations on the predicted values;
if <code>"efficiencies"</code>, the returned values indicate 
the influence of individual observations on the efficiency estimates.</p>
</td></tr>
<tr><td><code id="cooks.distance.frontier_+3A_asindata">asInData</code></td>
<td>
<p>logical. If <code>FALSE</code>, the returned vector
only includes observations that were used in the estimation;
if <code>TRUE</code>, the length of the returned vector is equal 
to the total number of observations in the data set,
where the values in the returned vector
that correspond to observations
that were not used in the estimation
due to <code>NA</code> or infinite values
are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="cooks.distance.frontier_+3A_progressbar">progressBar</code></td>
<td>
<p>logical. Should a progress bar be displayed
while the Cook's distances are obtained?</p>
</td></tr>
<tr><td><code id="cooks.distance.frontier_+3A_...">...</code></td>
<td>
<p>additional arguments that arecurrently ignored
if argument <code>target</code> is <code>"predict"</code>
and that are passed to the <code>efficiencies()</code> method
if argument <code>target</code> is <code>"efficiencies"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the Pseudo-Cook's distances for each observation
that was used in the estimation that is provided as argument <code>model</code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>, <code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1 (cross-section data)
   data( front41Data )

   # Cobb-Douglas production frontier
   cobbDouglas &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   summary( cobbDouglas )
   
   # Pseudo-Cook's distances for predicted values
   cooks.distance( cobbDouglas )

   # Pseudo-Cook's distances for efficiency estimates
   cooks.distance( cobbDouglas, "efficiencies" )
</code></pre>

<hr>
<h2 id='efficiencies'>Returning Efficiency Estimates</h2><span id='topic+efficiencies'></span><span id='topic+efficiencies.default'></span>

<h3>Description</h3>

<p>This method returns efficiency estimates from frontier models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficiencies( object, ... )
## Default S3 method:
efficiencies( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencies_+3A_object">object</code></td>
<td>
<p>a frontier model.</p>
</td></tr>
<tr><td><code id="efficiencies_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
The default method just returns the element
<code>effic</code> from <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+efficiencies.frontier">efficiencies.frontier</a></code>.</p>

<hr>
<h2 id='efficiencies.frontier'>Returning Efficiency Estimates</h2><span id='topic+efficiencies.frontier'></span>

<h3>Description</h3>

<p>This method returns efficiency estimates from stochastic frontier models
estimated with <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
efficiencies( object, asInData = FALSE,
   logDepVar = TRUE, minusU = farrell, farrell = TRUE, 
   margEff = FALSE, newdata = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficiencies.frontier_+3A_object">object</code></td>
<td>
<p>a stochastic frontier model
returned by <code><a href="#topic+frontier">frontier</a></code>.</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_asindata">asInData</code></td>
<td>
<p>logical. If <code>TRUE</code>,
the efficiency estimates are returned in the same order
as the corresponding observations in the data set
used for the estimation
(see section &lsquo;value&rsquo; below).</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_logdepvar">logDepVar</code></td>
<td>
<p>logical. Is the dependent variable logged?</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_minusu">minusU</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), 
the efficiencies are calculated by E[exp(-u)],
i.e. Farrel-type efficiencies are returned for input-oriented models,
Shepard-type efficiencies are returned for output-oriented models,
and the returned efficiency estimates have values 
between zero and one,
where a one indicates a fully efficient firm
and a zero indicates a fully inefficient firm.
If <code>FALSE</code>, 
the efficiencies are calculated by E[exp(u)],
i.e. Shepard-type efficiencies are returned for input-oriented models,
Farrell-type efficiencies are returned for output-oriented models,
and the returned efficiency estimates have values larger than 
or equal to one,
where a one indicates a fully efficient firm
and plus infinity indicates a fully inefficient firm.</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_farrell">farrell</code></td>
<td>
<p>logical. This argument is only kept for backward compatibility
and will be removed in the future.</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_margeff">margEff</code></td>
<td>
<p>logical. If <code>TRUE</code>, the marginal effects
of the <code class="reqn">z</code> variables (of an Efficiency Effects Frontier, EEF)
on the efficiency measure are returned as an &lsquo;attribute&rsquo; 
to the returned object (i.e. the efficiency estimates).
These marginal effects are calculated by the formula derived in
Olsen and Henningsen (2011),
which was slightly adjusted for the differing model specifications.
Currently, this feature is implemented only for models 
with logged dependent variables.</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame from which the values 
of explanatory variables and the dependent variable are taken 
to calculate the efficiency estimates.
If this argument is <code>NULL</code> (the default),
the efficiency estimates are calculated for the observations
that were used in the estimation.</p>
</td></tr>
<tr><td><code id="efficiencies.frontier_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If argument <code>asInData</code> is <code>FALSE</code> (default),
a matrix of efficiency estimates is returned,
where each row corresponds to a firm (cross-section unit)
and each column corresponds to a time period
(only if efficiency estimates differ between time periods).
</p>
<p>If argument <code>asInData</code> is <code>TRUE</code>,
a vector of efficiency estimates is returned,
where the efficiency estimates are in the same order
as the corresponding observations in the data set
used for the estimation.
</p>
<p>If argument <code>margEff</code> is <code>TRUE</code>,
and the model is an Efficiency Effects Frontier (EFF) 
with <code class="reqn">z</code> variables,
and the dependent variable is logged,
the returned efficiency estimates have an attribute <code>"margEff"</code>
that contains the marginal effects of the <code class="reqn">z</code> variables
on the efficiency measure.
</p>
<p>If the dependent variable is logged, 
the marginal effect of the <code class="reqn">k</code>th <code class="reqn">z</code> variable on the efficiency is
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial E[ \exp( - \kappa \, u ) ]}{\partial z_{kit}}
   = \frac{  \delta_{k} ( 1 - \gamma ) 
      \exp \left( - \kappa \, \bar{\mu}_{it} 
         + \frac{1}{2} \bar{\sigma}^{2} \right) }{ 
            \Phi \left( \frac{\bar{\mu}_{it}}{ \bar{\sigma} } \right) }</code>
</p>

<p style="text-align: center;"><code class="reqn"> \cdot \left( \frac{ \phi \left( -\kappa \, \bar{\sigma} 
         + \frac{ \bar{\mu}_{it} }{ \bar{\sigma} } \right) }{ \bar{\sigma} }
      - \frac{ \Phi \left( -\kappa \, \bar{\sigma} 
               + \frac{ \bar{\mu}_{it} }{ \bar{\sigma} } \right) \,
            \phi \left( \frac{ \bar{\mu}_{it} }{ \bar{\sigma} } \right)}{ 
         \bar{\sigma} \, 
            \Phi \left( \frac{ \bar{\mu}_{it} }{ \bar{\sigma}}\right) }
            - \kappa \, \Phi \left( -\kappa \, \bar{\sigma} 
               + \frac{ \bar{\mu}_{it} }{ \bar{\sigma} } \right) \right), </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn"> \bar{\mu}_{it} 
      = ( 1 - \gamma ) \, z_{it} ' \delta 
         - \tau \, \gamma \, \epsilon_{it},</code>
</p>

<p style="text-align: center;"><code class="reqn"> \bar{\sigma}^{2}
      = \gamma \, ( 1 - \gamma ) \, \sigma^{2},</code>
</p>

<p><code class="reqn">\kappa = 1</code> in case of Farrell efficiencies
(i.e. efficiencies have values between between 0 and 1),
whereas <code class="reqn">\kappa = -1</code> otherwise 
(i.e. efficiencies have values larger than 1),
and <code class="reqn">\tau = 1</code> if inefficiency decreases the dependent variable,
whereas <code class="reqn">\tau = -1</code> otherwise
(see Olsen and Henningsen 2011).
</p>
<p>If argument <code>asInData</code> is <code>FALSE</code>,
this attribute is a 3-dimensional array,
where the first dimension represents the individual firm,
the second deminsion represents the time period,
and the third dimension represents the <code class="reqn">z</code> variables.
In contrast, if argument <code>asInData</code> is <code>TRUE</code>,
this attribute is a matrix,
where the rows represent the observations
and the columns represent the <code class="reqn">z</code> variables.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Olsen, Jakob Vesterlund and Arne Henningsen (2011): 
Investment utilization and farm efficiency in Danish agriculture. 
FOI working paper 2011/13, Institute of Food and Resource Economics, 
University of Copenhagen, 
<a href="http://EconPapers.repec.org/RePEc:foi:wpaper:2011_13">http://EconPapers.repec.org/RePEc:foi:wpaper:2011_13</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>, <code><a href="#topic+summary.frontier">summary.frontier</a></code>,
and <code><a href="#topic+efficiencies">efficiencies</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # rice producers in the Philippines (panel data)
   data( "riceProdPhil" )
   library( "plm" )
   riceProdPhil &lt;- pdata.frame( riceProdPhil, c( "FMERCODE", "YEARDUM" ) )

   # Error Components Frontier (Battese &amp; Coelli 1992), no time effect
   rice &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil )
   efficiencies( rice )
   riceProdPhil$efficiencies &lt;- efficiencies( rice, asInData = TRUE )

   # efficiency of an 'average' farm
   efficiencies( rice, 
      newdata = data.frame( t( colMeans( riceProdPhil[ , -c(1,2) ] ) ) ) )

   # Error Components Frontier (Battese &amp; Coelli 1992), with time effect
   riceTime &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil, timeEffect = TRUE )
   efficiencies( riceTime )
   riceProdPhil$efficienciesTime &lt;- efficiencies( riceTime, asInData = TRUE )
   
   # Technical Efficiency Effects Frontier (Battese &amp; Coelli 1995)
   rice2 &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ) |
      EDYRS + BANRAT - 1, data = riceProdPhil )
   eff &lt;- efficiencies( rice2, margEff = TRUE )
   attr( eff, "margEff" )   # marginal effects
</code></pre>

<hr>
<h2 id='elas.frontierQuad'>Elasticities of a Quadratic/Translog Frontier</h2><span id='topic+elas.frontierQuad'></span>

<h3>Description</h3>

<p>Calculate the elasticities of a quadratic or translog frontier function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontierQuad'
elas( object, data = NULL, dataLogged = TRUE,
   yObs = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elas.frontierQuad_+3A_object">object</code></td>
<td>
<p>object of class <code>frontierQuad</code>
(returned by <code><a href="#topic+frontierQuad">frontierQuad</a></code>).</p>
</td></tr>
<tr><td><code id="elas.frontierQuad_+3A_data">data</code></td>
<td>
<p>dataframe containing the data;
if it is not specified,
the data frame that was used for the frontier estimation
is used for calculating elasticities.</p>
</td></tr>
<tr><td><code id="elas.frontierQuad_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the variables
(specified in arguments <code>yName</code> and <code>xNames</code>
and available in argument <code>data</code>)
already logged?
(If argument <code>dataLogged</code> is <code>TRUE</code>,
the frontier function is of the translog form;
if argument <code>dataLogged</code> is <code>FALSE</code>,
the frontier function is quadratic).</p>
</td></tr>
<tr><td><code id="elas.frontierQuad_+3A_yobs">yObs</code></td>
<td>
<p>logical. Use observed values of the endogenous variable.
If <code>FALSE</code> (default) predicted values calculated by
<code><a href="micEcon.html#topic+quadFuncCalc">quadFuncCalc</a></code> are used
(ignored if argument <code>dataLogged</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="elas.frontierQuad_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method internally calls the functions
<code><a href="micEcon.html#topic+translogEla">translogEla</a></code> and
<code><a href="micEcon.html#topic+quadFuncEla">quadFuncEla</a></code>.
</p>


<h3>Value</h3>

<p>See documentation of <code><a href="micEcon.html#topic+translogEla">translogEla</a></code> and
<code><a href="micEcon.html#topic+quadFuncEla">quadFuncEla</a></code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+frontierQuad">frontierQuad</a></code>, <code><a href="micEcon.html#topic+translogEla">translogEla</a></code>,
and <code><a href="micEcon.html#topic+quadFuncEla">quadFuncEla</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1 (cross-section data)
   data( front41Data )
   front41Data$logOutput  &lt;- log( front41Data$output )
   front41Data$logCapital &lt;- log( front41Data$capital )
   front41Data$logLabour  &lt;- log( front41Data$labour )

   translog &lt;- frontierQuad( yName = "logOutput",
      xNames = c( "logCapital", "logLabour" ),
      data = front41Data )
   elas( translog )
</code></pre>

<hr>
<h2 id='fitted.frontier'>Fitted and Predicted (Frontier) Values</h2><span id='topic+fitted.frontier'></span><span id='topic+predict.frontier'></span>

<h3>Description</h3>

<p>This method returns the fitted and predicted &ldquo;frontier&rdquo; values
from stochastic frontier models
estimated with the <span class="pkg">frontier</span> package 
(e.g. function <code><a href="#topic+sfa">sfa</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
fitted( object, asInData = FALSE, ... )

## S3 method for class 'frontier'
predict( object, newdata = NULL, asInData = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.frontier_+3A_object">object</code></td>
<td>
<p>a stochastic frontier model
estimated with the <span class="pkg">frontier</span> package 
(e.g. function <code><a href="#topic+sfa">sfa</a></code>).</p>
</td></tr>
<tr><td><code id="fitted.frontier_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame from which the explanatory variables
are used to calculate the predicted &ldquo;frontier&rdquo; values.
If this argument is <code>NULL</code>,
the fitted values are returned.</p>
</td></tr>
<tr><td><code id="fitted.frontier_+3A_asindata">asInData</code></td>
<td>
<p>logical. If <code>TRUE</code>,
the fitted values are returned in the same order
as the corresponding observations in the data set
used for the estimation
(see section &lsquo;value&rsquo; below).</p>
</td></tr>
<tr><td><code id="fitted.frontier_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If argument <code>asInData</code> is <code>FALSE</code>,
a matrix of the fitted or predicted values is returned,
where each row corresponds to a firm (cross-section unit)
and each column corresponds to a time period.
</p>
<p>If argument <code>asInData</code> is <code>TRUE</code>,
a vector of fitted or predicted values is returned,
where the fitted values are in the same order
as the corresponding observations in the data set
used for the estimation
or the data set specified by argument <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # rice producers in the Philippines (panel data)
   data( "riceProdPhil" )
   library( "plm" )
   riceProdPhil &lt;- pdata.frame( riceProdPhil, c( "FMERCODE", "YEARDUM" ) )

   # Error Components Frontier (Battese &amp; Coelli 1992), no time effect
   rice &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil )
   fitted( rice )
   riceProdPhil$fitted &lt;- fitted( rice, asInData = TRUE )

   # Error Components Frontier (Battese &amp; Coelli 1992), with time effect
   riceTime &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil, timeEffect = TRUE )
   fitted( riceTime )
   riceProdPhil$fittedTime &lt;- fitted( riceTime, asInData = TRUE )
</code></pre>

<hr>
<h2 id='front41Data'>Data provided with Tim Coelli's Frontier 4.1</h2><span id='topic+front41Data'></span>

<h3>Description</h3>

<p>The <code>front41Data</code> data frame contains cross-sectional data of 60 firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(front41Data)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>firm</dt><dd><p>firm ID.</p>
</dd>
<dt>output</dt><dd><p>output quantity (value added).</p>
</dd>
<dt>capital</dt><dd><p>capital input quantity (quantity index).</p>
</dd>
<dt>labour</dt><dd><p>labour input quantity (quantity index).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coelli, T. (1996) A Guide to FRONTIER Version 4.1: A Computer
Program for Stochastic Frontier Production and Cost Function
Estimation, CEPA Working Paper 96/08,
<a href="http://www.uq.edu.au/economics/cepa/frontier.php">http://www.uq.edu.au/economics/cepa/frontier.php</a>,
University of New England.
</p>

<hr>
<h2 id='front41Est'>Estimate a Stochastic Frontier Model by Frontier 4.1</h2><span id='topic+front41Est'></span>

<h3>Description</h3>

<p>Estimate a stochastic frontier model with a modified version
of Tim Coelli's program Frontier 4.1
(NOTE: this program has to be installed separately!).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   front41Est( command = ifelse( .Platform$OS.type == "windows",
      "front41.exe", "front41.bin" ), ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="front41Est_+3A_command">command</code></td>
<td>
<p>command to call the modified version of FRONTIER 4.1
(see details).</p>
</td></tr>
<tr><td><code id="front41Est_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+front41WriteInput">front41WriteInput</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the command <code>front41Est</code> requires the installation
of a modified version of Tim Coelli's FRONTIER 4.1.
It is available on
<a href="http://frontier.r-forge.r-project.org/front41.html">http://frontier.r-forge.r-project.org/front41.html</a>.
as (FORTRAN) source code
and (executable) binaries for GNU/Linux and MS-Windows.
</p>


<h3>Value</h3>

<p><code>front41Est</code> returns a list of class <code>front41Output</code>
that is returned by <code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code>
with two additional elements:
</p>
<table>
<tr><td><code>input</code></td>
<td>
<p>object returned by <code><a href="#topic+front41WriteInput">front41WriteInput</a></code>.</p>
</td></tr>
<tr><td><code>messages</code></td>
<td>
<p>messages returned by FRONTIER 4.1.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Battese, G.E. and T. Coelli (1992), Frontier production functions,
technical efficiency and panel data: with application to paddy
farmers in India. <em>Journal of Productivity Analysis</em>, 3, 153-169.
</p>
<p>Battese, G.E. and T. Coelli (1995), A model for technical inefficiency effects
in a stochastic frontier production function for panel data.
<em>Empirical Economics</em>, 20, 325-332.
</p>
<p>Coelli, T. (1996) A Guide to FRONTIER Version 4.1: A Computer
Program for Stochastic Frontier Production and Cost Function
Estimation, CEPA Working Paper 96/08,
<a href="http://www.uq.edu.au/economics/cepa/frontier.php">http://www.uq.edu.au/economics/cepa/frontier.php</a>,
University of New England.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+front41WriteInput">front41WriteInput</a></code>, <code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( front41Data )
   front41Data$logOutput  &lt;- log( front41Data$output )
   front41Data$logCapital &lt;- log( front41Data$capital )
   front41Data$logLabour  &lt;- log( front41Data$labour )

   ## Not run: 
   front41Est( data = front41Data, crossSectionName = "firm",
      yName = "logOutput", xNames = c( "logCapital", "logLabour" ) )
   
## End(Not run)
</code></pre>

<hr>
<h2 id='front41ReadOutput'>Read output of Frontier 4.1</h2><span id='topic+front41ReadOutput'></span><span id='topic+print.front41Output'></span>

<h3>Description</h3>

<p>Read the output file of Tim Coelli's program Frontier 4.1 that
performs stochastic frontier analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   front41ReadOutput( file = "front41.out" )

   ## S3 method for class 'front41Output'
print( x, efficiencies = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="front41ReadOutput_+3A_file">file</code></td>
<td>
<p>character variable with the name of the file to read.</p>
</td></tr>
<tr><td><code id="front41ReadOutput_+3A_x">x</code></td>
<td>
<p>object of class <code>front41Output</code>
(returned by <code>front41ReadOutput</code>.</p>
</td></tr>
<tr><td><code id="front41ReadOutput_+3A_efficiencies">efficiencies</code></td>
<td>
<p>logical. Print all efficiency estimates?
(If <code>FALSE</code>, only the mean efficiency is printed.)</p>
</td></tr>
<tr><td><code id="front41ReadOutput_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A modified version of Tim Coelli's FRONTIER 4.1
that can be used non-interactively is available on
<a href="http://frontier.r-forge.r-project.org/front41.html">http://frontier.r-forge.r-project.org/front41.html</a>.
It can be called from within R using the <code>system</code> command
(see example).
This version is is available as (FORTRAN) source code
and (executable) binaries for GNU/Linux and MS-Windows.
</p>


<h3>Value</h3>

<p>a list of class <code>front41Output</code> containing following objects:
</p>
<table>
<tr><td><code>version</code></td>
<td>
<p>the version of Frontier 4.1 that produced the output.</p>
</td></tr>
<tr><td><code>insFile</code></td>
<td>
<p>name of the instruction file used by Frontier 4.1.</p>
</td></tr>
<tr><td><code>dtaFile</code></td>
<td>
<p>name of the data file used by Frontier 4.1.</p>
</td></tr>
<tr><td><code>modelType</code></td>
<td>
<p>model type: either 1 for 'Error Components Frontier' or
2 for 'Tech. Eff. Effects Frontier'.</p>
</td></tr>
<tr><td><code>modelTypeName</code></td>
<td>
<p>model type: 'Error Components Frontier' or 'Tech. Eff.
Effects Frontier'.</p>
</td></tr>
<tr><td><code>functionType</code></td>
<td>
<p>function type: either 1 for 'production function' or
2 for 'cost function'.</p>
</td></tr>
<tr><td><code>functionTypeName</code></td>
<td>
<p>function type: 'production function' or
'cost function'.</p>
</td></tr>
<tr><td><code>logDepVar</code></td>
<td>
<p>logical. Is the dependent variable logged.</p>
</td></tr>
<tr><td><code>olsResults</code></td>
<td>
<p>results of the OLS estimation.</p>
</td></tr>
<tr><td><code>nXvars</code></td>
<td>
<p>number X variables (exogenous variables of the production
or cost function.</p>
</td></tr>
<tr><td><code>olsLogl</code></td>
<td>
<p>log likelihood value of the OLS estimation.</p>
</td></tr>
<tr><td><code>gridResults</code></td>
<td>
<p>results of the grid search.</p>
</td></tr>
<tr><td><code>mleResults</code></td>
<td>
<p>results of the maximum likelihood estimation.</p>
</td></tr>
<tr><td><code>mleLogl</code></td>
<td>
<p>log likelihood value of the maximum likelihood estimation.</p>
</td></tr>
<tr><td><code>mleCov</code></td>
<td>
<p>coefficient covariance matrix of the maximum likelihood
estimation.</p>
</td></tr>
<tr><td><code>lrTest</code></td>
<td>
<p>LR test of the one-sided error.</p>
</td></tr>
<tr><td><code>lrTestRestrict</code></td>
<td>
<p>number of restrictions of the LR test.</p>
</td></tr>
<tr><td><code>nIter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code>maxIter</code></td>
<td>
<p>maximum number of iterations set.</p>
</td></tr>
<tr><td><code>nCross</code></td>
<td>
<p>number of cross-sections.</p>
</td></tr>
<tr><td><code>nPeriods</code></td>
<td>
<p>umber of time periods.</p>
</td></tr>
<tr><td><code>nObs</code></td>
<td>
<p>total number of observations.</p>
</td></tr>
<tr><td><code>nObsMissing</code></td>
<td>
<p>number of observations that are not in the panel.</p>
</td></tr>
<tr><td><code>efficiency</code></td>
<td>
<p>technical efficiency estimates.</p>
</td></tr>
<tr><td><code>meanEfficiency</code></td>
<td>
<p>mean efficiency.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Battese, G.E. and T. Coelli (1992), Frontier production functions,
technical efficiency and panel data: with application to paddy
farmers in India. <em>Journal of Productivity Analysis</em>, 3, 153-169.
</p>
<p>Battese, G.E. and T. Coelli (1995), A model for technical inefficiency effects
in a stochastic frontier production function for panel data.
<em>Empirical Economics</em>, 20, 325-332.
</p>
<p>Coelli, T. (1996) A Guide to FRONTIER Version 4.1: A Computer
Program for Stochastic Frontier Production and Cost Function
Estimation, CEPA Working Paper 96/08,
<a href="http://www.uq.edu.au/economics/cepa/frontier.php">http://www.uq.edu.au/economics/cepa/frontier.php</a>,
University of New England.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+front41WriteInput">front41WriteInput</a></code>, <code><a href="#topic+front41Est">front41Est</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   # read the output file that is provided with Frontier 4.1
   outFile &lt;- system.file( "front41/EG1.OUT", package = "frontier" )
   sfa &lt;- front41ReadOutput( outFile )
   print( sfa, efficiencies = TRUE )

   # perform an SFA and read the output
   data( front41Data )
   front41Data$logOutput  &lt;- log( front41Data$output )
   front41Data$logCapital &lt;- log( front41Data$capital )
   front41Data$logLabour  &lt;- log( front41Data$labour )

   front41WriteInput( front41Data, "firm", yName = "logOutput",
      xNames = c( "logCapital", "logLabour" ), 
      path = tempdir(), insFile = "coelli.ins" )

   ## Not run: 
   system( paste0( "cd ", tempdir(), "; front41.bin coelli.ins" ) )
   sfa &lt;- front41ReadOutput( file.path( tempdir(), "coelli.out" ) )
   summary( sfa )
   
## End(Not run)
</code></pre>

<hr>
<h2 id='front41WriteInput'>Write input files for Frontier 4.1</h2><span id='topic+front41WriteInput'></span>

<h3>Description</h3>

<p>Write an instruction file, a data file, and a start-up file
for Tim Coelli's program Frontier 4.1
that performs stochastic frontier analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>front41WriteInput( data, crossSectionName, timePeriodName = NULL,
   yName, xNames = NULL, qxNames = NULL, zNames = NULL, quadHalf = TRUE,
   modelType = ifelse( is.null( zNames ), 1, 2 ), functionType = 1,
   logDepVar = TRUE, mu = FALSE, eta = FALSE, path = ".",
   insFile = "front41.ins", dtaFile = sub( "\\.ins$", ".dta", insFile ),
   outFile = sub( "\\.ins$", ".out", insFile ), startUpFile = "front41.000",
   iprint = 5, indic = 1, tol = 0.00001, tol2 = 0.001, bignum = 1.0E+16,
   step1 = 0.00001, igrid2 = 1, gridno = 0.1, maxit = 100, ite = 1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="front41WriteInput_+3A_data">data</code></td>
<td>
<p>data frame that contains the data.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_crosssectionname">crossSectionName</code></td>
<td>
<p>string: name of the cross section identifier.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_timeperiodname">timePeriodName</code></td>
<td>
<p>string: name of the time period identifier
or <code>NULL</code> in case of cross-section data.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_yname">yName</code></td>
<td>
<p>string: name of the endogenous variable.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the X variables
(exogenous variables of the production or cost function).</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_qxnames">qxNames</code></td>
<td>
<p>a vector of strings containing the names of the variables
to construct quadratic and interaction terms.
As a shortcut, this argument can be set to <code>"all"</code>
for using all variables specified in argument <code>xNames</code>
to get a full quadratic or translog model.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_znames">zNames</code></td>
<td>
<p>a vector of strings containing the names of the Z variables
(variables explaining the efficiency level).</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_quadhalf">quadHalf</code></td>
<td>
<p>logical. Multiply the quadratic terms by one half?</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_modeltype">modelType</code></td>
<td>
<p>model type: either 1 for an 'Error Components Frontier'
or 2 for an 'Efficiency Effects Frontier'.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_functiontype">functionType</code></td>
<td>
<p>function type: either 1 for 'production function' or
2 for 'cost function'.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_logdepvar">logDepVar</code></td>
<td>
<p>logical. Is the dependent variable logged.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_mu">mu</code></td>
<td>
<p>logical. Should a 'mu' (in case of an 'Error Components Frontier',
i.e. modelType = 1)
or a delta0 (in case of an 'Efficiency Effects Frontier',
i.e. modelType = 2)
be included in the estimation.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_eta">eta</code></td>
<td>
<p>logical. Should an 'eta' be included in the estimation
(only in case of an 'Error Components Frontier', i.e. modelType = 1).</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_path">path</code></td>
<td>
<p>path in which the instruction file, the data file,
and the start-up file should be written.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_insfile">insFile</code></td>
<td>
<p>name of the instruction file.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_dtafile">dtaFile</code></td>
<td>
<p>name of the data file.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_outfile">outFile</code></td>
<td>
<p>name of the output file.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_startupfile">startUpFile</code></td>
<td>
<p>name of the start-up file. If this argument is NULL,
no start-up file is written.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_iprint">iprint</code></td>
<td>
<p>numeric. Print info every <code>iprint</code> iterations;
if this argument is 0, do not print.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_indic">indic</code></td>
<td>
<p>numeric. Use in unidimensional search procedure:
indic = 2 says do not scale step length in unidimensional search;
indic = 1 says scale (to length of last step) only if last step was smaller;
indic = any other number says scale (to length of last step).</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_tol">tol</code></td>
<td>
<p>numeric. Convergence tolerance (proportiona).</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_tol2">tol2</code></td>
<td>
<p>numeric. Tolerance used in uni-dimensional search procedure.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_bignum">bignum</code></td>
<td>
<p>numeric. Used to set bounds on densities and distributions.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_step1">step1</code></td>
<td>
<p>numeric. Size of 1st step in search procedure.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_igrid2">igrid2</code></td>
<td>
<p>numeric. 1 = double accuracy, 0 = single accuracy.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_gridno">gridno</code></td>
<td>
<p>numeric. Steps taken in single accuracy grid search on gamma.</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_maxit">maxit</code></td>
<td>
<p>numeric. Maximum number of iterations permitted</p>
</td></tr>
<tr><td><code id="front41WriteInput_+3A_ite">ite</code></td>
<td>
<p>numeric. 1 = print all efficiency estimates;
0 = print only the mean efficiency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A modified version of Tim Coelli's FRONTIER 4.1
that can be used non-interactively is available on
<a href="http://frontier.r-forge.r-project.org/front41.html">http://frontier.r-forge.r-project.org/front41.html</a>.
It can be called from within R using the <code>system</code> command
(see example).
This version is is available as (FORTRAN) source code
and (executable) binaries for GNU/Linux and MS-Windows.
</p>


<h3>Value</h3>

<p><code>front41WriteInput</code> writes an instruction file, a data file,
and a start-up file for Frontier 4.1 to disk
and it invisibly returns a list of class <code>front41WriteInput</code>.
This list contains mainly the arguments with which <code>front41WriteInput</code>
was called.
An exception is element <code>data</code>, which is <em>not</em>
the argument <code>data</code> but the data matrix
that was written into the data file.
Furthermore, in case of an Efficiency Effects Model,
the element <code>eta</code> contains the number of Z variables.
Additionally, the returned list contains following elements:
</p>
<table>
<tr><td><code>nCrossSection</code></td>
<td>
<p>number of cross section units.</p>
</td></tr>
<tr><td><code>nTimePeriods</code></td>
<td>
<p>number of time periods.</p>
</td></tr>
<tr><td><code>nTotalObs</code></td>
<td>
<p>total number of observations.</p>
</td></tr>
<tr><td><code>nXtotal</code></td>
<td>
<p>total number of X variables
(including quadratic and interaction terms).</p>
</td></tr>
<tr><td><code>nZvars</code></td>
<td>
<p>number of Z variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Battese, G.E. and T. Coelli (1992), Frontier production functions,
technical efficiency and panel data: with application to paddy
farmers in India. <em>Journal of Productivity Analysis</em>, 3, 153-169.
</p>
<p>Battese, G.E. and T. Coelli (1995), A model for technical inefficiency effects
in a stochastic frontier production function for panel data.
<em>Empirical Economics</em>, 20, 325-332.
</p>
<p>Coelli, T. (1996) A Guide to FRONTIER Version 4.1: A Computer
Program for Stochastic Frontier Production and Cost Function
Estimation, CEPA Working Paper 96/08,
<a href="http://www.uq.edu.au/economics/cepa/frontier.php">http://www.uq.edu.au/economics/cepa/frontier.php</a>,
University of New England.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code>, <code><a href="#topic+front41Est">front41Est</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( front41Data )
   front41Data$logOutput  &lt;- log( front41Data$output )
   front41Data$logCapital &lt;- log( front41Data$capital )
   front41Data$logLabour  &lt;- log( front41Data$labour )

   front41WriteInput( front41Data, "firm", yName = "logOutput",
      xNames = c( "logCapital", "logLabour" ), 
      path = tempdir(), insFile = "coelli.ins" )

   ## Not run: 
   system( paste0( "cd ", tempdir(), "; front41.bin coelli.ins" ) )
   sfa &lt;- front41ReadOutput( file.path( tempdir(), "coelli.out" ) )
   summary( sfa )
   
## End(Not run)
</code></pre>

<hr>
<h2 id='frontierQuad'>Quadratic or Translog Frontiers</h2><span id='topic+frontierQuad'></span>

<h3>Description</h3>

<p>This is a convenient interface for estimating
quadratic or translog stochastic frontier functions
using <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frontierQuad( yName, xNames, shifterNames = NULL, zNames = NULL,
   data, lrTests = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frontierQuad_+3A_yname">yName</code></td>
<td>
<p>string: name of the endogenous variable.</p>
</td></tr>
<tr><td><code id="frontierQuad_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the X variables
(exogenous variables of the production or cost function)
that should be included as linear, quadratic, and interaction terms.</p>
</td></tr>
<tr><td><code id="frontierQuad_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names of the
X variables that should be included as shifters
only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="frontierQuad_+3A_znames">zNames</code></td>
<td>
<p>a vector of strings containing the names of the Z variables
(variables explaining the efficiency level).</p>
</td></tr>
<tr><td><code id="frontierQuad_+3A_data">data</code></td>
<td>
<p>a (panel) data frame that contains the data;
if <code>data</code> is a usual data.frame,
it is assumed that these are cross-section data;
if <code>data</code> is a panel data frame
(created with <code><a href="plm.html#topic+pdata.frame">pdata.frame</a></code>),
it is assumed that these are panel data.</p>
</td></tr>
<tr><td><code id="frontierQuad_+3A_lrtests">lrTests</code></td>
<td>
<p>logical. If <code>TRUE</code>, likelihood ratio tests are conducted
to test the statistical significance of each X variable.</p>
</td></tr>
<tr><td><code id="frontierQuad_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+frontier">frontier</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>frontierQuad</code> returns a list of class <code>frontierQuad</code>
(and <code>frontier</code>)
containing the same elements as returned by <code><a href="#topic+frontier">frontier</a></code>.
If argument <code>lrTest</code> is set to <code>TRUE</code>,
the returned object has a component <code>lrTests</code>
that contains the results of likelihood-ratio tests
of the statistical significance of each X variable.   
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+frontier">frontier</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1 (cross-section data)
   data( front41Data )
   front41Data$logOutput  &lt;- log( front41Data$output )
   front41Data$logCapital &lt;- log( front41Data$capital )
   front41Data$logLabour  &lt;- log( front41Data$labour )

   # estimate the translog function
   translog &lt;- frontierQuad( yName = "logOutput",
      xNames = c( "logCapital", "logLabour" ),
      data = front41Data )
   translog

   # estimate the same model using sfa()
   translog2 &lt;- sfa( logOutput ~ logCapital + logLabour
      + I( 0.5 * logCapital^2 ) + I( logCapital * logLabour )
      + I( 0.5 * logLabour^2 ), data = front41Data )
   translog2
   all.equal( coef( translog ), coef( translog2 ),
      check.attributes = FALSE )
</code></pre>

<hr>
<h2 id='frontierTranslogRay'>Translog Ray Frontiers</h2><span id='topic+frontierTranslogRay'></span>

<h3>Description</h3>

<p>This is a convenient interface for estimating
translog stochastic ray frontier models
using <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frontierTranslogRay( yNames, xNames, shifterNames = NULL,
   zNames = NULL, data, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frontierTranslogRay_+3A_ynames">yNames</code></td>
<td>
<p>a vector of two or more character strings containing
the names of the output variables.</p>
</td></tr>
<tr><td><code id="frontierTranslogRay_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the input variables
that should be included as linear, quadratic, and interaction terms.</p>
</td></tr>
<tr><td><code id="frontierTranslogRay_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names of the
explanatory variables that should be included as shifters
only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="frontierTranslogRay_+3A_znames">zNames</code></td>
<td>
<p>a vector of strings containing the names of the Z variables
(variables explaining the efficiency level).</p>
</td></tr>
<tr><td><code id="frontierTranslogRay_+3A_data">data</code></td>
<td>
<p>a (panel) data frame that contains the data
(see documentation of <code><a href="#topic+frontier">frontier</a></code>)
NOTE: the variables defined by arguments <code>yNames</code> and <code>xNames</code>
must be in natural units;
the variables defined by argument <code>xNames</code> are logarithmized 
internally;
the variables defined by arguments <code>shifterNames</code> and <code>zNames</code>
are NOT logarithmized internally and hence must be specified
as they should be used in the model.</p>
</td></tr>
<tr><td><code id="frontierTranslogRay_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+frontierQuad">frontierQuad</a></code>
and possibly further to <code><a href="#topic+frontier">frontier</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>frontierTranslogRay</code> returns a list of class <code>frontierTranslogRay</code>
(as well as <code>frontierQuad</code> and <code>frontier</code>)
containing almost the same elements as returned by <code><a href="#topic+frontier">frontier</a></code>.
Additionally, it includes following objects:
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>the &ldquo;distance&rdquo; from the origin (zero)
to the point of the dependent variables.</p>
</td></tr>
<tr><td><code>theta_i</code></td>
<td>
<p>the &ldquo;direction&rdquo; from the origin (zero)
to the point of the dependent variables
(with <code>i</code> = <code class="reqn">1, ..., N-1</code> 
and <code class="reqn">N</code> is the number of outputs).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen and Geraldine Henningsen</p>


<h3>References</h3>

<p>LÃ¶thgren, M. (1997)
Generalized stochastic frontier production models,
<em>Economics Letters</em>, 57, 255-259.
</p>
<p>LÃ¶thgren, M. (1997)
<em>A Multiple Output Stochastic Ray Frontier Production Model</em>,
Working Paper Series in Economics and Finance, No. 158,
Stockholm School of Economics.
</p>
<p>LÃ¶thgren, M. (2000)
Specification and estimation of stochastic multiple-output production
and technical inefficiency
<em>Applied Economics</em>, 32, 1533-1540.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frontier">frontier</a></code>, <code><a href="#topic+frontierQuad">frontierQuad</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## preparing data
data( germanFarms )
# quantity of crop outputs
germanFarms$qCrop &lt;- germanFarms$vCrop / germanFarms$pOutput
# quantity of animal outputs
germanFarms$qAnimal &lt;- germanFarms$vAnimal / germanFarms$pOutput
# quantity of variable inputs
germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput

# estimate a translog ray production function
estResultRay &lt;- frontierTranslogRay( yNames = c( "qCrop", "qAnimal" ),
   xNames = c( "qLabor", "land", "qVarInput" ),
   data = germanFarms )
summary( estResultRay )
</code></pre>

<hr>
<h2 id='logLik.frontier'>Extract Log-Likelihood Value</h2><span id='topic+logLik.frontier'></span>

<h3>Description</h3>

<p>Extract the log-likelihood value(s) from stochastic frontier models
returned by <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
logLik( object, which = "mle", newParam = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.frontier_+3A_object">object</code></td>
<td>
<p>an object of class <code>frontier</code>
(returned by the function <code><a href="#topic+frontier">frontier</a></code>).</p>
</td></tr>
<tr><td><code id="logLik.frontier_+3A_which">which</code></td>
<td>
<p>character string. Which log-likelihood value
should be returned?
'ols' for the log-likelihood value of the parameters estimated by OLS,
'grid' for the log-likelihood value of the parameters obtained
by the grid search (only if no starting values were provided),
'start' for the log-likelihood value of the starting values
of the parameters specified by the user
(only if starting values were provided),
or 'mle' for the log-likelihood values of the parameters estimated
by Maximum Likelihood.</p>
</td></tr>
<tr><td><code id="logLik.frontier_+3A_newparam">newParam</code></td>
<td>
<p>optional vector of parameters.
If this argument is provided by the user, the log-likelihood value
of the model <code>object</code> is calculated with these (new) parameters.</p>
</td></tr>
<tr><td><code id="logLik.frontier_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logLik.frontier</code> returns an object of class <code>logLik</code>,
which is a numeric scalar (the log-likelihood value) with 2 attributes:
<code>nobs</code> (total number of observations in all equations) and
<code>df</code> (number of free parameters, i.e. length of the coefficient vector).
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+frontier">frontier</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1
   data( front41Data )

   # SFA estimation with starting values obtained from a grid search
   sfaResult &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   logLik( sfaResult, which = "ols" )
   logLik( sfaResult, which = "grid" )
   logLik( sfaResult )

   # SFA estimation with starting values provided by the user
   sfaResult2 &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data, startVal = 0.9 * coef( sfaResult ) )
   logLik( sfaResult2, which = "ols" )
   logLik( sfaResult2, which = "start" )
   logLik( sfaResult2 )

   # evaluate log likelihood function for a user-provided parameter vector
   logLik( sfaResult, newParam = 0.9 * coef( sfaResult ) )
      # equal to  logLik( sfaResult2, which = "start" )

   # log likelihood function for different values of gamma
   plot( t( sapply( seq( 0.05, 0.95, 0.05 ), function(x) c( x,
      logLik( sfaResult, newParam = c( coef( sfaResult )[1:4], x ) ) ) ) ) )
</code></pre>

<hr>
<h2 id='lrtest.frontier'>Likelihood Ratio test for Stochastic Frontier Models</h2><span id='topic+lrtest.frontier'></span>

<h3>Description</h3>

<p>Testing parameter restrictions in stochastic frontier models
by a Likelihood Ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'frontier'
lrtest( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrtest.frontier_+3A_object">object</code></td>
<td>
<p>a fitted model object of class <code>frontier</code>.</p>
</td></tr>
<tr><td><code id="lrtest.frontier_+3A_...">...</code></td>
<td>
<p>further fitted model objects of class <code>frontier</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lrtest.frontier</code> is called with only one argument/object
(i.e. argument <code>...</code> is not used),
it compares the fitted model to a corresponding model
without inefficiency (i.e. estimated by OLS).
</p>
<p>If <code>lrtest.frontier</code> is called with more than one argument/object
(i.e. argument <code>...</code> is used),
it consecutively compares
the fitted model object <code>object</code>
with the models passed in <code>...</code>.
</p>
<p>The test statistic is
<code>2 * ( logLik( mu ) - logLik( mr ) )</code>,
where <code>mu</code> is the unrestricted model
and <code>mr</code> is the restricted model.
</p>
<p>If a Frontier model (estimated by ML) is compared to
a model without inefficiency (estimated by OLS),
the test statistic asymptotically has a mixed <code class="reqn">\chi^2</code> distribution
under the null hypothesis (see Coelli, 1995).
</p>
<p>If two Frontier models (estimated by ML) are compared,
the test statistic asymptotically has a <code class="reqn">\chi^2</code>
distribution with <code class="reqn">j</code> degrees of freedom
under the null hypothesis,
where <code class="reqn">j</code> is the number of restrictions.
</p>


<h3>Value</h3>

<p>An object of class <code>anova</code>,
which contains the log-likelihood value,
degrees of freedom, the difference in degrees of freedom,
likelihood ratio Chi-squared statistic and corresponding p value.
See documentation of <code><a href="lmtest.html#topic+lrtest">lrtest</a></code>
in package &quot;lmtest&quot;.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Coelli, T.J. (1995), Estimators and Hypothesis Tests for a Stochastic:
A Monte Carlo Analysis, <em>Journal of Productivity Analysis</em>,
6, 247-268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>, <code><a href="lmtest.html#topic+lrtest">lrtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># rice producers in the Philippines (panel data)
data( "riceProdPhil" )
library( "plm" )
riceProdPhil &lt;- pdata.frame( riceProdPhil, c( "FMERCODE", "YEARDUM" ) )

# Error Components Frontier with truncated normal distribution
# and time effects (unrestricted model)
mu &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
   truncNorm = TRUE, timeEffect = TRUE, data = riceProdPhil )

# Error Components Frontier with half-normal distribution
# without time effects (restricted model)
mr &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
   data = riceProdPhil )

## compare the two models by an LR-test
lrtest( mu, mr )

## compare each of the models to a corresponding model without inefficiency
lrtest( mu )
lrtest( mr )
</code></pre>

<hr>
<h2 id='resettestFrontier'>RESET test for Stochastic Frontier Models</h2><span id='topic+resettestFrontier'></span>

<h3>Description</h3>

<p>Generalized Ramsey's RESET test (REgression Specification Error Test)
for misspecification of the functional form
based on a Likelihood Ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   resettestFrontier( object, power = 2:3 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resettestFrontier_+3A_object">object</code></td>
<td>
<p>a fitted model object of class <code>frontier</code>.</p>
</td></tr>
<tr><td><code id="resettestFrontier_+3A_power">power</code></td>
<td>
<p>a vector indicating the powers of the fitted variables
that should be included as additional explanatory variables.
By default, the test is for quadratic or cubic influence
of the fitted response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>anova</code>
as returned by <code><a href="#topic+lrtest.frontier">lrtest.frontier</a></code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Ramsey, J.B. (1969), Tests for Specification Error
in Classical Linear Least Squares Regression Analysis.
<em>Journal of the Royal Statistical Society, Series B</em> 31, 350-371.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>,  <code><a href="lmtest.html#topic+resettest">resettest</a></code>, and
<code><a href="#topic+lrtest.frontier">lrtest.frontier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load data set
   data( front41Data )

   # estimate a Cobb-Douglas production frontier
   cobbDouglas &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   
   # conduct the RESET test
   resettestFrontier( cobbDouglas )
</code></pre>

<hr>
<h2 id='residuals.frontier'>Returning Residuals</h2><span id='topic+residuals.frontier'></span>

<h3>Description</h3>

<p>This method returns the residuals from stochastic frontier models
estimated with the <span class="pkg">frontier</span> package 
(e.g. function <code><a href="#topic+sfa">sfa</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
residuals( object, asInData = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.frontier_+3A_object">object</code></td>
<td>
<p>a stochastic frontier model
estimated with the <span class="pkg">frontier</span> package 
(e.g. function <code><a href="#topic+sfa">sfa</a></code>).</p>
</td></tr>
<tr><td><code id="residuals.frontier_+3A_asindata">asInData</code></td>
<td>
<p>logical. If <code>TRUE</code>,
the residuals are returned in the same order
as the corresponding observations in the data set
used for the estimation
(see section &lsquo;value&rsquo; below).</p>
</td></tr>
<tr><td><code id="residuals.frontier_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If argument <code>asInData</code> is <code>FALSE</code> (default),
a matrix of the residuals is returned,
where each row corresponds to a firm (cross-section unit)
and each column corresponds to a time period.
</p>
<p>If argument <code>asInData</code> is <code>TRUE</code>,
a vector of residuals is returned,
where the residuals are in the same order
as the corresponding observations in the data set
used for the estimation.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # rice producers in the Philippines (panel data)
   data( "riceProdPhil" )
   library( "plm" )
   riceProdPhil &lt;- pdata.frame( riceProdPhil, c( "FMERCODE", "YEARDUM" ) )

   # Error Components Frontier (Battese &amp; Coelli 1992), no time effect
   rice &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil )
   residuals( rice )
   riceProdPhil$residuals &lt;- residuals( rice, asInData = TRUE )

   # Error Components Frontier (Battese &amp; Coelli 1992), with time effect
   riceTime &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil, timeEffect = TRUE )
   residuals( riceTime )
   riceProdPhil$residualsTime &lt;- residuals( riceTime, asInData = TRUE )
</code></pre>

<hr>
<h2 id='riceProdPhil'>Rice Production in the Philippines</h2><span id='topic+riceProdPhil'></span>

<h3>Description</h3>

<p>The <code>riceProdPhil</code> data frame contains annual data collected from
43 smallholder rice producers in the Tarlac region of the Philippines
between 1990 and 1997.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data( riceProdPhil )</code></pre>


<h3>Format</h3>

<p>This data frame contains the following variables (columns):
</p>

<dl>
<dt>YEARDUM</dt><dd><p>Time period (1= 1990, ..., 8 = 1997).</p>
</dd>
<dt>FMERCODE</dt><dd><p>Farmer code (1, ..., 43).</p>
</dd>
<dt>PROD</dt><dd><p>Output (tonnes of freshly threshed rice).</p>
</dd>
<dt>AREA</dt><dd><p>Area planted (hectares).</p>
</dd>
<dt>LABOR</dt><dd><p>Labour used (man-days of family and hired labour).</p>
</dd>
<dt>NPK</dt><dd><p>Fertiliser used (kg of active ingredients).</p>
</dd>
<dt>OTHER</dt><dd><p>Other inputs used (Laspeyres index = 100 for Firm 17 in 1991).</p>
</dd>
<dt>PRICE</dt><dd><p>Output price (pesos per kg).</p>
</dd>
<dt>AREAP</dt><dd><p>Rental price of land (pesos per hectare).</p>
</dd>
<dt>LABORP</dt><dd><p>Labour price (pesos per hired man-day.</p>
</dd>
<dt>NPKP</dt><dd><p>Fertiliser price (pesos per kg of active ingredient).</p>
</dd>
<dt>OTHERP</dt><dd><p>Price of other inputs (implicit price index).</p>
</dd>
<dt>AGE</dt><dd><p>Age of the household head (years).</p>
</dd>
<dt>EDYRS</dt><dd><p>Education of the household head (years).</p>
</dd>
<dt>HHSIZE</dt><dd><p>Household size.</p>
</dd>
<dt>NADULT</dt><dd><p>Number of adults in the household.</p>
</dd>
<dt>BANRAT</dt><dd><p>Percentage of area classified as bantog (upland) fields.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is published as supplement to Coelli et al. (2005).
While most variables of this data set were supplied
by the International Rice Research Institute (IRRI),
some were calculated by Coelli et al. (2005, see p. 325&ndash;326).
The survey is described in Pandey et al. (1999).
</p>


<h3>Source</h3>

<p>Supplementary files for Coelli et al. (2005),
<a href="http://www.uq.edu.au/economics/cepa/crob2005/software/CROB2005.zip">http://www.uq.edu.au/economics/cepa/crob2005/software/CROB2005.zip</a>
</p>


<h3>References</h3>

<p>Coelli, T. J., Rao, D. S. P., O'Donnell, C. J., and Battese, G. E. (2005)
<em>An Introduction to Efficiency and Productivity Analysis</em>,
Springer, New York.
</p>
<p>Pandey, S., Masciat, P., Velasco, L, and Villano, R. (1999)
Risk analysis of a rainfed rice production system system in Tarlac,
Central Luzon, Philippines,
<em>Experimental Agriculture</em>, <b>35</b>, 225-237.
</p>

<hr>
<h2 id='sfa'>Stochastic Frontier Analysis</h2><span id='topic+sfa'></span><span id='topic+frontier'></span><span id='topic+print.frontier'></span>

<h3>Description</h3>

<p> Maximum Likelihood Estimation of
Stochastic Frontier Production and Cost Functions.
Two specifications are available:
the error components specification with time-varying efficiencies
(Battese and Coelli 1992)
and a model specification in which the firm effects are directly 
influenced by a number of variables (Battese and Coelli 1995).
This R package uses the Fortran source code of Frontier 4.1
(Coelli 1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfa( formula, data = sys.frame( sys.parent() ),
   ineffDecrease = TRUE, truncNorm = FALSE,
   timeEffect = FALSE, startVal = NULL,
   tol = 0.00001, maxit = 1000, muBound = 2, bignum = 1.0E+16,
   searchStep = 0.00001, searchTol = 0.001, searchScale = NA,
   gridSize = 0.1, gridDouble = TRUE,
   restartMax = 10, restartFactor = 0.999, printIter = 0 )

frontier( yName, xNames = NULL, zNames = NULL, data,
   zIntercept = FALSE, ... )

## S3 method for class 'frontier'
print( x, digits = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfa_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be estimated;
it can be either a (usual) one-part or a two-part formula
(see section &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="sfa_+3A_data">data</code></td>
<td>
<p>a (panel) data frame that contains the data;
if <code>data</code> is a usual data.frame,
it is assumed that these are cross-section data;
if <code>data</code> is a panel data frame
(created with <code><a href="plm.html#topic+pdata.frame">pdata.frame</a></code>),
it is assumed that these are panel data.</p>
</td></tr>
<tr><td><code id="sfa_+3A_ineffdecrease">ineffDecrease</code></td>
<td>
<p>logical. If <code>TRUE</code>,
inefficiency decreases the endogenous variable
(e.g. for estimating a production function);
if <code>FALSE</code>,
inefficiency increases the endogenous variable
(e.g. for estimating a cost function).</p>
</td></tr>
<tr><td><code id="sfa_+3A_truncnorm">truncNorm</code></td>
<td>
<p>logical. If <code>TRUE</code>,
the inefficiencies are assumed to have a truncated normal distribution
(i.e. parameter <code class="reqn">\mu</code> is added);
if <code>FALSE</code>,
they are assumed to have a half-normal distribution
(only relevant for the &lsquo;Error Components Frontier&rsquo;).</p>
</td></tr>
<tr><td><code id="sfa_+3A_timeeffect">timeEffect</code></td>
<td>
<p>logical. If <code>FALSE</code> (default),
the efficiency estimates of an &lsquo;Error Components Frontier&rsquo;
are time invariant;
if <code>TRUE</code>, time is allowed to have an effect on efficiency
(this argument is ignored in case of an
&lsquo;Efficiency Effects Frontier&rsquo;).</p>
</td></tr>
<tr><td><code id="sfa_+3A_startval">startVal</code></td>
<td>
<p>numeric vector. Optional starting values for the ML
estimation.</p>
</td></tr>
<tr><td><code id="sfa_+3A_tol">tol</code></td>
<td>
<p>numeric. Convergence tolerance (proportional).</p>
</td></tr>
<tr><td><code id="sfa_+3A_maxit">maxit</code></td>
<td>
<p>numeric. Maximum number of iterations permitted.</p>
</td></tr>
<tr><td><code id="sfa_+3A_mubound">muBound</code></td>
<td>
<p>numeric. Bounds on the parameter <code class="reqn">\mu</code>
(see &lsquo;details&rsquo; section).</p>
</td></tr>
<tr><td><code id="sfa_+3A_bignum">bignum</code></td>
<td>
<p>numeric. Used to set bounds on densities and distributions.</p>
</td></tr>
<tr><td><code id="sfa_+3A_searchstep">searchStep</code></td>
<td>
<p>numeric. Size of the first step in the Coggin
uni-dimensional search procedure done each iteration
to determine the optimal step length for the next iteration
(see Himmelblau 1972).</p>
</td></tr>
<tr><td><code id="sfa_+3A_searchtol">searchTol</code></td>
<td>
<p>numeric. Tolerance used in the Coggin
uni-dimensional search procedure done each iteration
to determine the optimal step length for the next iteration
(see Himmelblau 1972).</p>
</td></tr>
<tr><td><code id="sfa_+3A_searchscale">searchScale</code></td>
<td>
<p>logical or <code>NA</code>. Scaling in the Coggin
uni-dimensional search procedure done each iteration
to determine the optimal step length for the next iteration
(see Himmelblau 1972):
if <code>TRUE</code>, the step length is scaled to the length of the last step;
if <code>FALSE</code>, the step length is not scaled;
if <code>NA</code>, the step length is scaled (to the length of last step)
only if the last step was smaller.</p>
</td></tr>
<tr><td><code id="sfa_+3A_gridsize">gridSize</code></td>
<td>
<p>numeric. The size of the increment
in the first phase grid search on <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code id="sfa_+3A_griddouble">gridDouble</code></td>
<td>
<p>logical. If <code>TRUE</code>,
a second phase grid search on <code class="reqn">\gamma</code> is conducted
around the &ldquo;best&rdquo; value obtained in the first phase
with an increment of <code>gridSize/10</code>.</p>
</td></tr>
<tr><td><code id="sfa_+3A_restartmax">restartMax</code></td>
<td>
<p>integer: maximum number of restarts of the search procedure
when it cannot find a parameter vector
that results in a log-likelihood value
larger than the log-likelihood value of the initial parameters.</p>
</td></tr>
<tr><td><code id="sfa_+3A_restartfactor">restartFactor</code></td>
<td>
<p>numeric scalar: if the search procedure
cannot find a parameter vector that results in a log-likelihood value
larger than the log-likelihood value of the initial parameters,
the initial values
(provided by argument <code>startVal</code> or obtained by the grid serach)
are multiplied by this number before the search procedure
is restarted.</p>
</td></tr>
<tr><td><code id="sfa_+3A_printiter">printIter</code></td>
<td>
<p>numeric. Print info every <code>printIter</code> iterations;
if this argument is 0, do not print.</p>
</td></tr>
<tr><td><code id="sfa_+3A_yname">yName</code></td>
<td>
<p>string: name of the endogenous variable.</p>
</td></tr>
<tr><td><code id="sfa_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the X variables
(exogenous variables of the production or cost function).</p>
</td></tr>
<tr><td><code id="sfa_+3A_znames">zNames</code></td>
<td>
<p>a vector of strings containing the names of the Z variables
(variables explaining the efficiency level).</p>
</td></tr>
<tr><td><code id="sfa_+3A_zintercept">zIntercept</code></td>
<td>
<p>logical. If <code>TRUE</code>,
an intercept (with parameter <code class="reqn">\delta_0</code>)
is added to the Z variables
(only relevant for the &lsquo;Efficiency Effects Frontier&rsquo;).</p>
</td></tr>
<tr><td><code id="sfa_+3A_x">x</code></td>
<td>
<p>an object of class <code>frontier</code>
(returned by the function <code>frontier</code>).</p>
</td></tr>
<tr><td><code id="sfa_+3A_digits">digits</code></td>
<td>
<p>a non-null value for &lsquo;digits&rsquo; specifies
the minimum number of significant digits to be printed in values.
The default, <code>NULL</code>, uses
<code>max(3,getOption("digits")-3)</code>.
Non-integer values will be rounded down, and only values greater
than or equal to 1 and no greater than 22 are accepted.</p>
</td></tr>
<tr><td><code id="sfa_+3A_...">...</code></td>
<td>
<p>additional arguments of <code>frontier</code>
are passed to <code>sfa</code>;
additional arguments of the <code>print</code> method
are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>frontier</code> is a wrapper function
that calls <code>sfa</code> for the estimation.
The two functions differ only in the user interface;
function <code>frontier</code> has the &ldquo;old&rdquo; user interface
and is kept to maintain compatibility with older versions
of the <code>frontier</code> package.
</p>
<p>One can use functions <code>sfa</code> and <code>frontier</code>
to calculate the log likelihood value for a given model,
a given data set, and given parameters
by using the argument <code>startVal</code> to specify the parameters
and using the other arguments to specify the model and the data.
The log likelihood value can then be retrieved by
the <code><a href="#topic+logLik.frontier">logLik</a></code> method
with argument <code>which</code> set to <code>"start"</code>.
Setting argument <code>maxit</code> to <code>0</code> avoids the
(eventually time-consuming) ML estimation and allows
to retrieve the log likelihood value
with the <code><a href="#topic+logLik.frontier">logLik</a></code> method
without further arguments.
</p>
<p>The <code>frontier</code> function uses the Fortran source code of
Tim Coelli's software FRONTIER 4.1
(<a href="http://www.uq.edu.au/economics/cepa/frontier.htm">http://www.uq.edu.au/economics/cepa/frontier.htm</a>)
and hence, provides the same features as FRONTIER 4.1.
A comprehensive documentation of FRONTIER 4.1 is available
in the file <code>Front41.pdf</code>
that is included in the archive <code>FRONT41-xp1.zip</code>,
which is available at
<a href="http://www.uq.edu.au/economics/cepa/frontier.htm">http://www.uq.edu.au/economics/cepa/frontier.htm</a>.
It is recommended to read this documentation, 
because the <code>frontier</code> function is based on the FRONTIER 4.1 software.
</p>
<p>If argument <code>formula</code> of <code>sfa</code> is a (usual) one-part formula
(or argument <code>zNames</code> of <code>frontier</code> is <code>NULL</code>),
an &lsquo;Error Components Frontier&rsquo; (ECF, see Battese and Coelli 1992)
is estimated.
If argument <code>formula</code> is a two-part formula
(or <code>zNames</code> is not <code>NULL</code>),
an &lsquo;Efficiency Effects Frontier&rsquo; (EEF, see Battese and Coelli 1995)
is estimated.
In this case, the first part of the formula
(i.e. the part before the &ldquo;|&rdquo; symbol)
is used to explain the endogenous variable directly (X variables),
while the second part of the formula
(i.e. the part after the &ldquo;|&rdquo; symbol)
is used to explain the efficiency levels (Z variables).
Generally, there should be no reason for estimating an EEF
without Z variables,
but this can done by setting the second part of argument <code>formula</code>
to <code>1</code> (with Z intercept) or <code>- 1</code> (without Z intercept)
(or by setting argument <code>zNames</code>) to <code>NA</code>).
</p>
<p>In case of an Error Components Frontier (ECF)
with the inefficiency terms <code class="reqn">u</code> following a
truncated normal distribution with mean <code class="reqn">\mu</code>,
argument <code>muBound</code> can be used to restrict <code class="reqn">\mu</code>
to be in the interval <code class="reqn">\pm</code><code>muBound</code> * <code class="reqn">\sigma_u</code>,
where <code class="reqn">\sigma_u</code> is the standard deviation of <code class="reqn">u</code>.
If <code>muBound</code> is infinity, zero, or negative,
no bounds on <code class="reqn">\mu</code> are imposed.
</p>


<h3>Value</h3>

<p><code>sfa</code> and <code>frontier</code> return a list of class <code>frontier</code>
containing following elements:
</p>
<table>
<tr><td><code>modelType</code></td>
<td>
<p>integer.
A &lsquo;1&rsquo; denotes an &lsquo;Error Components Frontier&rsquo; (ECF);
a &lsquo;2&rsquo; denotes an &lsquo;Efficiency Effects Frontier&rsquo; (EFF).</p>
</td></tr>
<tr><td><code>ineffDecrease</code></td>
<td>
<p>logical. Argument <code>ineffDecrease</code> (see above).</p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>number of cross-sections.</p>
</td></tr>
<tr><td><code>nt</code></td>
<td>
<p>number of time periods.</p>
</td></tr>
<tr><td><code>nob</code></td>
<td>
<p>number of observations in total.</p>
</td></tr>
<tr><td><code>nb</code></td>
<td>
<p>number of regressor variables (Xs).</p>
</td></tr>
<tr><td><code>truncNorm</code></td>
<td>
<p>logical. Argument <code>truncNorm</code>.</p>
</td></tr>
<tr><td><code>zIntercept</code></td>
<td>
<p>logical. Argument <code>zIntercept</code>.</p>
</td></tr>
<tr><td><code>timeEffect</code></td>
<td>
<p>logical. Argument <code>timeEffect</code>.</p>
</td></tr>
<tr><td><code>printIter</code></td>
<td>
<p>numeric. Argument <code>printIter</code> (see above).</p>
</td></tr>
<tr><td><code>searchScale</code></td>
<td>
<p>numeric. Argument <code>searchScale</code> (see above).</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>numeric. Argument <code>tol</code> (see above).</p>
</td></tr>
<tr><td><code>searchTol</code></td>
<td>
<p>numeric. Argument <code>searchTol</code> (see above).</p>
</td></tr>
<tr><td><code>bignum</code></td>
<td>
<p>numeric. Argument <code>bignum</code> (see above).</p>
</td></tr>
<tr><td><code>searchStep</code></td>
<td>
<p>numeric. Argument <code>searchStep</code> (see above).</p>
</td></tr>
<tr><td><code>gridDouble</code></td>
<td>
<p>logical. Argument <code>gridDouble</code> (see above).</p>
</td></tr>
<tr><td><code>gridSize</code></td>
<td>
<p>numeric. Argument <code>gridSize</code> (see above).</p>
</td></tr>
<tr><td><code>maxit</code></td>
<td>
<p>numeric.  Argument <code>maxit</code> (see above).</p>
</td></tr>
<tr><td><code>muBound</code></td>
<td>
<p>numeric.  Argument <code>muBound</code> (see above).</p>
</td></tr>
<tr><td><code>restartMax</code></td>
<td>
<p>numeric.  Argument <code>restartMax</code> (see above).</p>
</td></tr>
<tr><td><code>restartFactor</code></td>
<td>
<p>numeric.  Argument <code>restartFactor</code> (see above).</p>
</td></tr>
<tr><td><code>nRestart</code></td>
<td>
<p>numeric.  Number of restarts of the search procedure
when it cannot find a parameter vector
that results in a log-likelihood value
larger than the log-likelihood value of the initial parameters.</p>
</td></tr>
<tr><td><code>startVal</code></td>
<td>
<p>numeric vector. Argument <code>startVal</code>
(only if specified by user).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>dataTable</code></td>
<td>
<p>matrix. Data matrix sent to Frontier 4.1.</p>
</td></tr>
<tr><td><code>olsParam</code></td>
<td>
<p>numeric vector. OLS estimates.</p>
</td></tr>
<tr><td><code>olsStdEr</code></td>
<td>
<p>numeric vector. Standard errors of OLS estimates.</p>
</td></tr>
<tr><td><code>olsLogl</code></td>
<td>
<p>numeric. Log likelihood value of OLS estimation.</p>
</td></tr>
<tr><td><code>olsResid</code></td>
<td>
<p>numeric vector. Residuals of the OLS estimation.</p>
</td></tr>
<tr><td><code>olsSkewness</code></td>
<td>
<p>numeric. Skewness of the residuals of the OLS estimation.</p>
</td></tr>
<tr><td><code>olsSkewnessOkay</code></td>
<td>
<p>logical. Indicating if the residuals
of the OLS estimation have the expected skewness.</p>
</td></tr>
<tr><td><code>gridParam</code></td>
<td>
<p>numeric vector. Parameters obtained from the grid search
(if no starting values were specified).</p>
</td></tr>
<tr><td><code>gridLogl</code></td>
<td>
<p>numeric. Log likelihood value of the parameters
obtained from the grid search
(only if no starting values were specified).</p>
</td></tr>
<tr><td><code>startLogl</code></td>
<td>
<p>numeric. Log likelihood value of the starting values
for the parameters
(only if starting values were specified).</p>
</td></tr>
<tr><td><code>mleParam</code></td>
<td>
<p>numeric vector. Parameters obtained from ML estimation.</p>
</td></tr>
<tr><td><code>mleCov</code></td>
<td>
<p>matrix. Covariance matrix of the parameters obtained
from the OLS estimation.</p>
</td></tr>
<tr><td><code>mleLogl</code></td>
<td>
<p>numeric. Log likelihood value of the ML estimation.</p>
</td></tr>
<tr><td><code>nIter</code></td>
<td>
<p>numeric. Number of iterations of the ML estimation.</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>integer indication the reason for determination:
<code>1</code> = log likelihood values and parameters
of two successive iterations are within the tolerance limits;
<code>5</code> = cannot find a parameter vector that results
in a log-likelihood value larger than
the log-likelihood value obtained in the previous step;
<code>6</code> = search failed on gradient step;
<code>10</code> = maximum number of iterations reached.</p>
</td></tr>
<tr><td><code>nFuncEval</code></td>
<td>
<p>Number of evaluations of the log likelihood function
during the grid search and the iterative ML estimation.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>matrix. Fitted &ldquo;frontier&rdquo; values
of the dependent variable:
each row corresponds to a cross-section;
each column corresponds to a time period.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>matrix. Residuals:
each row corresponds to a cross-section;
each column corresponds to a time period.</p>
</td></tr>
<tr><td><code>validObs</code></td>
<td>
<p>vector of logical values indicating which observations
of the provided data were used for the estimation,
i.e. do not have values that are not available (<code>NA</code>, <code>NaN</code>)
or infinite (<code>Inf</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tim Coelli and Arne Henningsen</p>


<h3>References</h3>

<p>Battese, G.E. and T. Coelli (1992), Frontier production functions,
technical efficiency and panel data: with application to paddy
farmers in India. <em>Journal of Productivity Analysis</em>, 3, 153-169.
</p>
<p>Battese, G.E. and T. Coelli (1995), A model for technical inefficiency effects
in a stochastic frontier production function for panel data.
<em>Empirical Economics</em>, 20, 325-332.
</p>
<p>Coelli, T. (1996) A Guide to FRONTIER Version 4.1: A Computer
Program for Stochastic Frontier Production and Cost Function
Estimation, CEPA Working Paper 96/08,
<a href="http://www.uq.edu.au/economics/cepa/frontier.php">http://www.uq.edu.au/economics/cepa/frontier.php</a>,
University of New England.
</p>
<p>Himmelblau, D.M. (1972), <em>Applied Non-Linear Programming</em>,
McGraw-Hill, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+frontierQuad">frontierQuad</a></code> for quadratic/translog frontiers,
<code><a href="#topic+summary.frontier">summary.frontier</a></code> for creating and printing summary results,
<code><a href="#topic+efficiencies.frontier">efficiencies.frontier</a></code> for calculating efficiency estimates,
<code><a href="#topic+lrtest.frontier">lrtest.frontier</a></code> for comparing models by LR tests,
<code><a href="#topic+fitted.frontier">fitted.frontier</a></code> for obtaining the fitted &ldquo;frontier&rdquo; values,
ang <code><a href="#topic+residuals.frontier">residuals.frontier</a></code> for obtaining the residuals.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1 (cross-section data)
   data( front41Data )

   # Cobb-Douglas production frontier
   cobbDouglas &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   summary( cobbDouglas )

   # load data about rice producers in the Philippines (panel data)
   data( riceProdPhil )

   # Error Components Frontier (Battese &amp; Coelli 1992)
   # with observation-specific efficiencies (ignoring the panel structure)
   rice &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil )
   summary( rice )

   # Error Components Frontier (Battese &amp; Coelli 1992)
   # with "true" fixed individual effects and observation-specific efficiencies
   riceTrue &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ) + 
      factor( FMERCODE ),  data = riceProdPhil )
   summary( riceTrue )

   # add data set with information about its panel structure
   library( "plm" )
   ricePanel &lt;- pdata.frame( riceProdPhil, c( "FMERCODE", "YEARDUM" ) )

   # Error Components Frontier (Battese &amp; Coelli 1992)
   # with time-invariant efficiencies
   riceTimeInv &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = ricePanel )
   summary( riceTimeInv )

   # Error Components Frontier (Battese &amp; Coelli 1992)
   # with time-variant efficiencies
   riceTimeVar &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = ricePanel, timeEffect = TRUE )
   summary( riceTimeVar )

   # Technical Efficiency Effects Frontier (Battese &amp; Coelli 1995)
   # (efficiency effects model with intercept)
   riceZ &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ) |
      EDYRS + BANRAT, data = riceProdPhil )
   summary( riceZ )

   # Technical Efficiency Effects Frontier (Battese &amp; Coelli 1995)
   # (efficiency effects model without intercept)
   riceZ2 &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ) |
      EDYRS + BANRAT - 1, data = riceProdPhil )
   summary( riceZ2 )

   # Cost Frontier (with land as quasi-fixed input)
   riceProdPhil$cost &lt;- riceProdPhil$LABOR * riceProdPhil$LABORP +
      riceProdPhil$NPK * riceProdPhil$NPKP
   riceCost &lt;- sfa( log( cost ) ~ log( PROD ) + log( AREA ) + log( LABORP )
      + log( NPKP ), data = riceProdPhil, ineffDecrease = FALSE )
   summary( riceCost )
</code></pre>

<hr>
<h2 id='summary.front41Output'>Summarizing the Estimation of Frontier 4.1</h2><span id='topic+summary.front41Output'></span><span id='topic+print.summary.front41Output'></span>

<h3>Description</h3>

<p><code>summary.front41Output</code> summarizes the estimation results
of a model estimated by Frontier 4.1..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'front41Output'
summary( object, ... )

## S3 method for class 'summary.front41Output'
print( x, efficiencies = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.front41Output_+3A_object">object</code></td>
<td>
<p>an object of class <code>front41Output</code>
(read/created by <code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code>.</p>
</td></tr>
<tr><td><code id="summary.front41Output_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.front41Output</code>
(returned by the <code>summary</code> method for objects of class
<code>front41ReadOutput</code>).</p>
</td></tr>
<tr><td><code id="summary.front41Output_+3A_efficiencies">efficiencies</code></td>
<td>
<p>logical. Print all efficiency estimates?
(If <code>FALSE</code>, only the mean efficiency is printed.)</p>
</td></tr>
<tr><td><code id="summary.front41Output_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> method returns a list of class
<code>summary.front41Output</code>
with the same elements as object returned by <code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code>.
However, the elements <code>olsResults</code>, <code>gridResults</code>, and
<code>mleResults</code> have an additional culumn with marginal significance
levels (P values).
The <code class="reqn">P</code> values of the OLS estimates are calculated using
the <code class="reqn">t</code> distribution,
while the (asymptotic) <code class="reqn">P</code> values of the ML estimates
are calculated based on the assumption
that their <code class="reqn">t</code> values follow an (asymptotic) standard normal
distribution.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+front41ReadOutput">front41ReadOutput</a></code>, <code><a href="#topic+front41WriteInput">front41WriteInput</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # read the output file that is provided with Frontier 4.1
   outFile &lt;- system.file( "front41/EG1.OUT", package = "frontier" )
   sfa &lt;- front41ReadOutput( outFile )
   summary( sfa )
</code></pre>

<hr>
<h2 id='summary.frontier'>summary method for class frontier</h2><span id='topic+summary.frontier'></span><span id='topic+print.summary.frontier'></span>

<h3>Description</h3>

<p>Create and print summary results of a stochastic frontier analysis
returned by <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
summary( object, extraPar = FALSE, effic = FALSE,
   logDepVar = TRUE, effMinusU = farrell, farrell = TRUE, ... )
## S3 method for class 'summary.frontier'
print( x, effic = x$printEffic, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.frontier_+3A_object">object</code></td>
<td>
<p>an object of class <code>frontier</code>
(returned by the function <code><a href="#topic+frontier">frontier</a></code>).</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.frontier</code> 
(returned by the function <code>summary.frontier</code>).</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_extrapar">extraPar</code></td>
<td>
<p>logical. If <code>TRUE</code>, some additional parameters,
their standard errors, z-values, and P values are returned:
<code>sigmaSqU</code> = <code>sigmaSq</code> * <code>gamma</code> 
(with <code class="reqn">u</code> ~ <code class="reqn">N^+</code>( <code>mu</code>, <code>sigmaSqU</code> )),
<code>sigmaSqV</code> = <code>sigmaSq</code> * ( 1 - <code>gamma</code> )
(with <code class="reqn">v</code> ~ N( 0, <code>sigmaSqV</code> )),
<code>sigma</code> = <code>sigmaSq</code>^0.5,
<code>sigmaU</code> = <code>sigmaSqU</code>^0.5,
<code>sigmaV</code> = <code>sigmaSqV</code>^0.5,
<code>lambdaSq</code> = <code>sigmaSqU</code> / <code>sigmaSqV</code>,
and <code>lambda</code> = <code>sigmaU</code> / <code>sigmaV</code>.
Please note that <code>sigmaSqU</code> and <code>sigmaU</code> are not
the variance and standard error, respectively, of <code class="reqn">u</code>.
If the model is an error components frontier,
also the following additional parameters are returned:
<code>varU</code> = the variance of <code class="reqn">u</code>,
<code>sdU</code> = <code>varU</code>^0.5,
and <code>gammaVar</code> = <code>varU</code> / ( <code>varU</code> + <code>sigmaSqV</code> ).
Please note that the variance of <code class="reqn">u</code>
usually differs between observations
if the model is an error component frontier with &lsquo;time effect&rsquo;
or an efficiency effects frontier.</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_effic">effic</code></td>
<td>
<p>logical. Print the individual efficiency estimates?</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_logdepvar">logDepVar</code></td>
<td>
<p>logical. Is the dependent variable logged?</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_effminusu">effMinusU</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), 
the efficiencies are calculated by E[exp(-u)].
If <code>FALSE</code>, 
the efficiencies are calculated by E[exp(u)].
For details, see documentation of argument <code>minusU</code> 
of <code><a href="#topic+efficiencies.frontier">efficiencies.frontier</a></code>.</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_farrell">farrell</code></td>
<td>
<p>logical. This argument is only kept for backward compatibility
and will be removed in the future.</p>
</td></tr>
<tr><td><code id="summary.frontier_+3A_...">...</code></td>
<td>
<p>further arguments to the <code>summary</code> method 
are currently ignored;
further arguments to the <code>print</code> method
are forwarded to <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard errors of the estimated parameters
are taken from the direction matrix
that is used in the final iteration of the Davidon-Fletcher-Powell procedure
that is used for maximising the (log) likelihood function.
</p>
<p>If argument <code>extraPar</code> is <code>TRUE</code>,
the standard errors of the additional parameters
are obtained by the delta method.
Please note that the delta method might provide poor approximations
of the &lsquo;true&rsquo; standard errors,
because parameter <code class="reqn">\sigma^2</code> is left-censored
and parameter <code class="reqn">\gamma</code> is both left-censored and right-censored
so that these parameters cannot be normally distributed.
</p>
<p>Please note further
that the t statistic and the z statistic are not reliable
for testing the statistical signicance of <code class="reqn">\sigma^2</code>,
<code class="reqn">\gamma</code>, and the &lsquo;additional parameters&rsquo;,
because these parameters are censored and cannot follow 
a normal distribution or a t distribution.
</p>


<h3>Value</h3>

<p><code>summary.frontier</code> returns a list of class <code>summary.frontier</code>
that is identical to an object returned by <code><a href="#topic+frontier">frontier</a></code>
with two modifications and (up to) four additional elements:
</p>
<table>
<tr><td><code>olsParam</code></td>
<td>
<p>matrix of OLS estimates, their standard errors,
t-values, and P-values.</p>
</td></tr>
<tr><td><code>mleParam</code></td>
<td>
<p>matrix of ML estimates, their standard errors,
z-values, and asymptotic P-values.</p>
</td></tr>
<tr><td><code>logDepVar</code></td>
<td>
<p>logical. Argument <code>logDepVar</code> (see above).</p>
</td></tr>
<tr><td><code>printEffic</code></td>
<td>
<p>argument <code>effic</code>.</p>
</td></tr>
<tr><td><code>effic</code></td>
<td>
<p>matrix. Efficiency estimates:
each row corresponds to a cross-section;
each column corresponds to a time period.</p>
</td></tr>
<tr><td><code>efficMean</code></td>
<td>
<p>numeric scalar. Mean efficiency.</p>
</td></tr>
<tr><td><code>efficYearMeans</code></td>
<td>
<p>numeric vector.
Mean efficiency for each year in the sample
(only for panel data but not for the Error Components Frontier
without time effects).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+sfa">sfa</a></code>, <code><a href="#topic+efficiencies.frontier">efficiencies.frontier</a></code>, 
<code><a href="#topic+vcov.frontier">vcov.frontier</a></code>, and <code><a href="#topic+lrtest.frontier">lrtest.frontier</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1 (cross-section data)
   data( front41Data )

   sfaResult &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   summary( sfaResult )

   # rice producers in the Phillipines (panel data)
   data( "riceProdPhil" )
   library( "plm" )
   riceProdPhil &lt;- pdata.frame( riceProdPhil, c( "FMERCODE", "YEARDUM" ) )

   # Error Components Frontier
   rice &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ),
      data = riceProdPhil )
   summary( rice )

   # Efficiency Effects Frontier
   rice2 &lt;- sfa( log( PROD ) ~ log( AREA ) + log( LABOR ) + log( NPK ) |
      EDYRS + BANRAT, data = riceProdPhil )
   summary( rice2 )
</code></pre>

<hr>
<h2 id='telecom'>Telecommunications Providers</h2><span id='topic+telecom'></span>

<h3>Description</h3>

<p>The <code>telecom</code> data frame contains data
on telecommunications providers in 21 countries in 1990.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data( telecom )</code></pre>


<h3>Format</h3>

<p>This data frame contains the following variables (columns):
</p>

<dl>
<dt>country</dt><dd><p>The name of the country.</p>
</dd>
<dt>output</dt><dd><p>Output (index).</p>
</dd>
<dt>mainlines</dt><dd><p>Mainlines (M km).</p>
</dd>
<dt>employees</dt><dd><p>Number of employees (10,000 persons).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Supplementary files for Coelli et al. (1998), p. 193.
</p>


<h3>References</h3>

<p>Coelli, T. J., Rao, D. S. P., and Battese, G. E. (1998)
<em>An Introduction to Efficiency and Productivity Analysis</em>,
Springer, New York.
</p>

<hr>
<h2 id='vcov.frontier'>vcov method for class frontier</h2><span id='topic+vcov.frontier'></span>

<h3>Description</h3>

<p>Extract the covariance matrix of the maximum likelihood coefficients
of a stochastic frontier model returned by <code><a href="#topic+frontier">frontier</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'frontier'
vcov( object, extraPar = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.frontier_+3A_object">object</code></td>
<td>
<p>an object of class <code>frontier</code>
(returned by the function <code><a href="#topic+frontier">frontier</a></code>).</p>
</td></tr>
<tr><td><code id="vcov.frontier_+3A_extrapar">extraPar</code></td>
<td>
<p>logical. If <code>TRUE</code>, the variances and covariances
of additional parameters are returned:
<code>sigmaSqU</code> = <code>sigmaSq</code> * <code>gamma</code> 
(with <code class="reqn">u</code> ~ <code class="reqn">N^+</code>( <code>mu</code>, <code>sigmaSqU</code> )),
<code>sigmaSqV</code> = <code>sigmaSq</code> * ( 1 - <code>gamma</code> )
(with <code class="reqn">v</code> ~ N( 0, <code>sigmaSqV</code> )),
<code>sigma</code> = <code>sigmaSq</code>^0.5,
<code>sigmaU</code> = <code>sigmaSqU</code>^0.5,
<code>sigmaV</code> = <code>sigmaSqV</code>^0.5,
<code>lambdaSq</code> = <code>sigmaSqU</code> / <code>sigmaSqV</code>,
and <code>lambda</code> = <code>sigmaU</code> / <code>sigmaV</code>.
Please note that <code>sigmaSqU</code> and <code>sigmaU</code> are not
the variance and standard error, respectively, of <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="vcov.frontier_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix of the estimated parameters
is taken from the direction matrix
that is used in the final iteration of the Davidon-Fletcher-Powell procedure
that is used for maximising the (log) likelihood function.
</p>
<p>If argument <code>extraPar</code> is <code>TRUE</code>,
the variances and covariances of the additional parameters
are obtained by the delta method.
Please note that the delta method might provide poor approximations
of the &lsquo;true&rsquo; variances and covariances,
because parameter <code class="reqn">\sigma^2</code> is left-censored
and parameter <code class="reqn">\gamma</code> is both left-censored and right-censored
so that these parameters cannot be normally distributed.
</p>
<p>Please note further
that it might not be appropriate to use standard statistical tests
(e.g. t-tests or other Wald tests)
that are based on the variances and covariances of <code class="reqn">\sigma^2</code>,
<code class="reqn">\gamma</code>, and the &lsquo;additional parameters&rsquo;,
because these parameters are censored and cannot follow normal distributions.
</p>


<h3>Value</h3>

<p><code>vcov.frontier</code> returns the covariance matrix 
of the maximum likelihood coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.frontier">coef.frontier</a></code>, <code><a href="#topic+coef.summary.frontier">coef.summary.frontier</a></code>,
<code><a href="#topic+summary.frontier">summary.frontier</a></code>, and <code><a href="#topic+sfa">sfa</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # example included in FRONTIER 4.1
   data( front41Data )

   sfaResult &lt;- sfa( log( output ) ~ log( capital ) + log( labour ),
      data = front41Data )
   vcov( sfaResult )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
