<!DOCTYPE html><html><head><title>Help for package SSM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SSM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comb'><p>Generate all desired exponent vectors of a given degree.</p></a></li>
<li><a href='#compute.covariance'><p>Compute the unscaled covariance matrix.</p></a></li>
<li><a href='#compute.covariance.from.distance'><p>Compute unscaled covariance matrix from a supplied distance matrix and length</p>
parameter.</a></li>
<li><a href='#compute.interactions'><p>Compute Total interaction indices and Sobol indices for higher order</p>
interactions.</a></li>
<li><a href='#compute.main.effects'><p>Compute main effects</p></a></li>
<li><a href='#compute.residuals'><p>Compute the Leave-One-Out error at all design points.</p></a></li>
<li><a href='#compute.specific.interaction'><p>Compute the Sobol index for a given interaction.</p></a></li>
<li><a href='#compute.specific.total.interaction'><p>Compute Total interaction variance</p></a></li>
<li><a href='#compute.total.effects'><p>Compute Total effects</p></a></li>
<li><a href='#concentrated.likelihood'><p>Compute the concentrated likelihood of a covariance matrix.</p></a></li>
<li><a href='#construct.dmm'><p>Construct the design model matrix</p></a></li>
<li><a href='#construct.K'><p>Construct the K matrix for a given multivariate basis.</p></a></li>
<li><a href='#construct.K.1d'><p>Construct the K matrix for a given univariate basis.</p></a></li>
<li><a href='#construct.P'><p>Construct the change of basis matrix from multivariate monomials to Legendre</p>
polynomials.</a></li>
<li><a href='#construct.P.1d'><p>Construct the change of basis matrix from univariate monomials to Legendre</p>
polynomials.</a></li>
<li><a href='#degl'><p>Construct matrix of exponent vectors.</p></a></li>
<li><a href='#estimate.GP'><p>Estimate the parameters of the metamodel error estimating GP.</p></a></li>
<li><a href='#find.theta'><p>Compute the SSM vector of parameters.</p></a></li>
<li><a href='#fit.ssm'><p>Fit a smooth supersaturated model</p></a></li>
<li><a href='#get.K.element'><p>Compute entry of K matrix.</p></a></li>
<li><a href='#identify.main.effect.terms'><p>Identify main effect terms</p></a></li>
<li><a href='#identify.total.effect.terms'><p>Identify total effect terms</p></a></li>
<li><a href='#likelihood.plot'><p>Plot the concentrated likelihood of an SSM.</p></a></li>
<li><a href='#lineij'><p>Average the values in a vector between two cutoff points specified by a</p>
separate vector.</a></li>
<li><a href='#new.distance'><p>Compute the distance matrix of an SSM design.</p></a></li>
<li><a href='#optimize.by.interval.maximum'><p>Optimize concentrated likelihood.</p></a></li>
<li><a href='#partial.deriv.ssm'><p>Compute second partial derivative of a smooth supersaturated model at all</p>
design points.</a></li>
<li><a href='#plot.SSM'><p>Plot smooth supersaturated model main effects</p></a></li>
<li><a href='#predict.SSM'><p>Point prediction of smooth supersaturated models.</p></a></li>
<li><a href='#sensitivity.plot'><p>Plot the sensitivity indices of a smooth supersaturated model.</p></a></li>
<li><a href='#show,SSM-method'><p>Summarise SSM class object</p></a></li>
<li><a href='#smoothness.over.design'><p>Compute the smoothness of an SSM at all design points.</p></a></li>
<li><a href='#SSM'><p>SSM: A package for fitting smooth supersaturated models (SSM).</p></a></li>
<li><a href='#SSM-class'><p>An S4 class to represent a smooth supersaturated model</p></a></li>
<li><a href='#transform11'><p>Transform a design to [-1, 1]^d</p></a></li>
<li><a href='#update.sensitivity'><p>Update an SSM object with the term variances and Sobol indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit and Analyze Smooth Supersaturated Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates an S4 class "SSM" and defines functions for fitting smooth
    supersaturated models, a polynomial model with spline-like behaviour.
    Functions are defined for the computation of Sobol indices for sensitivity
    analysis and plotting the main effects using FANOVA methods. It also
    implements the estimation of the SSM metamodel error using a GP model with
    a variety of defined correlation functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/peterrobertcurtis/SSM">https://github.com/peterrobertcurtis/SSM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/peterrobertcurtis/SSM/issues">http://github.com/peterrobertcurtis/SSM/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-04 10:46:45 UTC; horse</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Curtis [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Curtis &lt;peterrobertcurtis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-04 13:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='comb'>Generate all desired exponent vectors of a given degree.</h2><span id='topic+comb'></span>

<h3>Description</h3>

<p><code>comb</code> recursively generates all the desired exponent vectors of a given
degree and is called by <code><a href="#topic+degl">degl</a></code> to generate the matrix put into
the <code>basis</code> slot of the SSM object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb(d, deg, N = choose(d + deg - 1, deg), vec, start = TRUE, parent,
  exclude = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_+3A_d">d</code></td>
<td>
<p>A number. Controls the number of recursions before stopping.</p>
</td></tr>
<tr><td><code id="comb_+3A_deg">deg</code></td>
<td>
<p>A number. The desired degree of resulting exponent vectors.</p>
</td></tr>
<tr><td><code id="comb_+3A_n">N</code></td>
<td>
<p>(optional) A number. Sets the number of exponent vectors that will
be generated.  If not supplied, all candidate vectors will be generated.</p>
</td></tr>
<tr><td><code id="comb_+3A_vec">vec</code></td>
<td>
<p>A vector.  Stores the current state of the generated vector during
recursion.</p>
</td></tr>
<tr><td><code id="comb_+3A_start">start</code></td>
<td>
<p>(optional) Logical. A flag used to identify the initial call environment.</p>
</td></tr>
<tr><td><code id="comb_+3A_parent">parent</code></td>
<td>
<p>(optional) An environment. Stores the environment name of the initializing
function call.</p>
</td></tr>
<tr><td><code id="comb_+3A_exclude">exclude</code></td>
<td>
<p>(optional) A list of integer vectors which is used to exclude the
generation of undesired exponent vectors.  <em>e.g.</em> If 1 is a vector in
the list then any generated vector which is non-zero in the first column
and zero everywhere else will be thrown away.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code><a href="#topic+degl">degl</a></code> during the process of
constructing the objects related to the basis of a smooth supersaturated
model.  It constructs the first <code>N</code> exponent vectors of degree <code>d</code>,
excluding those which are non-zero only in the columns specified by vectors
listed in <code>exclude</code>.  It operates recursively.
</p>


<h3>Value</h3>

<p>A matrix of exponent vectors
</p>

<hr>
<h2 id='compute.covariance'>Compute the unscaled covariance matrix.</h2><span id='topic+compute.covariance'></span>

<h3>Description</h3>

<p>Computes the unscaled covariance matrix for an SSM object for a given
length parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.covariance(ssm, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.covariance_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
<tr><td><code id="compute.covariance_+3A_r">r</code></td>
<td>
<p>A number. The length parameter used by the correlation function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix uses the correlation function specified by the SSM slot
<code>type</code>.  <code>"matern32"</code> uses a Matern 3/2 correlation while
<code>"exp"</code> uses a squared exponential.
</p>


<h3>Value</h3>

<p>The unscaled covariance matrix.
</p>

<hr>
<h2 id='compute.covariance.from.distance'>Compute unscaled covariance matrix from a supplied distance matrix and length
parameter.</h2><span id='topic+compute.covariance.from.distance'></span>

<h3>Description</h3>

<p>This is a legacy function and is not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.covariance.from.distance(distance, r, type = "exp", ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.covariance.from.distance_+3A_distance">distance</code></td>
<td>
<p>A matrix. A symmetric matrix of distances between design
points.</p>
</td></tr>
<tr><td><code id="compute.covariance.from.distance_+3A_r">r</code></td>
<td>
<p>A number. The length parameter for the correlation function</p>
</td></tr>
<tr><td><code id="compute.covariance.from.distance_+3A_type">type</code></td>
<td>
<p>(optional) Character. Specifies the correlation function. Default
behaviour is to use <code>"exp"</code> for a squared exponential correlation.
<code>"Matern32"</code> uses a Matern 3/2 correlation.</p>
</td></tr>
<tr><td><code id="compute.covariance.from.distance_+3A_ssm">ssm</code></td>
<td>
<p>(obsolete) An SSM object. Used for the removed
<code>"ssm"</code> correlation function which tried to use the local smoothness
of the SSM to measure distances.</p>
</td></tr>
</table>

<hr>
<h2 id='compute.interactions'>Compute Total interaction indices and Sobol indices for higher order
interactions.</h2><span id='topic+compute.interactions'></span>

<h3>Description</h3>

<p>This function computes the Total interaction indices of all second order
interactions present in the model.  If <code class="reqn">d &lt; 11</code> then it also computes the
Sobol indices of all interactions (second order and higher) in the model. It
identifies the relevant rows of the SSM <code>basis</code> slot for each
interaction and sums the term variances. Called by
<code><a href="#topic+update.sensitivity">update.sensitivity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.interactions(ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.interactions_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SSM object.  This is the <code>ssm</code> input with the
relevant slots updated.
</p>

<hr>
<h2 id='compute.main.effects'>Compute main effects</h2><span id='topic+compute.main.effects'></span>

<h3>Description</h3>

<p>This function computes the Sobol indices of the model variables, also known
as the main effects.  It identifies the relevant rows of the SSM <code>basis</code>
slot and sums the term variances. Called by <code><a href="#topic+update.sensitivity">update.sensitivity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.main.effects(ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.main.effects_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SSM object.  This is the <code>ssm</code> input with the
relevant slots updated.
</p>

<hr>
<h2 id='compute.residuals'>Compute the Leave-One-Out error at all design points.</h2><span id='topic+compute.residuals'></span>

<h3>Description</h3>

<p>This function repeatedly fits the SSM to all but one held out point in turn
and computes the prediction error at the held out point.  These errors are
collated into a vector indicating the Leave-One-Out error at each design
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.residuals(ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.residuals_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object that has valid entries for the slots
<code>response</code>, <code>K</code>, and <code>design_model_matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Leave-One_Out errors.
</p>

<hr>
<h2 id='compute.specific.interaction'>Compute the Sobol index for a given interaction.</h2><span id='topic+compute.specific.interaction'></span>

<h3>Description</h3>

<p>This computes the Sobol index for a given interaction. The
relevant term variances are identified and summed and the resulting
variance normalized and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.specific.interaction(factors, ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.specific.interaction_+3A_factors">factors</code></td>
<td>
<p>A vector of numbers of length at least two, identifying the
interaction of interest. <em>e.g.</em> The input <code class="reqn">(1, 3, 4)</code> indicates
that the interaction between the first, third and fourth factors is the one
of interest.</p>
</td></tr>
<tr><td><code id="compute.specific.interaction_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number. The Sobol index of the requested interaction.
</p>

<hr>
<h2 id='compute.specific.total.interaction'>Compute Total interaction variance</h2><span id='topic+compute.specific.total.interaction'></span>

<h3>Description</h3>

<p>This computes the Total interaction index for a given interaction. The
relevant term variances are identified and summed and the resulting
variance normalized and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.specific.total.interaction(factors, ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.specific.total.interaction_+3A_factors">factors</code></td>
<td>
<p>A vector of numbers identifying the interaction of interest.
<em>e.g.</em> The input <code class="reqn">(1, 3, 4)</code> indicates that the interaction
between the first, third and fourth factors is the one of interest.</p>
</td></tr>
<tr><td><code id="compute.specific.total.interaction_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number.  The Total interaction index of the requested interaction.
</p>

<hr>
<h2 id='compute.total.effects'>Compute Total effects</h2><span id='topic+compute.total.effects'></span>

<h3>Description</h3>

<p>This function computes the Total indices of the model variables.  It
identifies the relevant rows of the SSM <code>basis</code> slot and sums the term
variances. Called by <code><a href="#topic+update.sensitivity">update.sensitivity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.total.effects(ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.total.effects_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An SSM object.  This is the <code>ssm</code> input with the
relevant slots updated.
</p>

<hr>
<h2 id='concentrated.likelihood'>Compute the concentrated likelihood of a covariance matrix.</h2><span id='topic+concentrated.likelihood'></span>

<h3>Description</h3>

<p>Computes the concentrated likelihood of the covariance matrix of an SSM
object, given a length parameter and the SSM Leave-One-Out errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concentrated.likelihood(r, ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concentrated.likelihood_+3A_r">r</code></td>
<td>
<p>A number. The length parameter of the correlation function.</p>
</td></tr>
<tr><td><code id="concentrated.likelihood_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number. The concentrated likelihood.
</p>

<hr>
<h2 id='construct.dmm'>Construct the design model matrix</h2><span id='topic+construct.dmm'></span>

<h3>Description</h3>

<p>Constructs the design model matrix corresponding to the given design and
basis. Used by <code>fit.ssm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.dmm(basis, design, P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.dmm_+3A_basis">basis</code></td>
<td>
<p>An <code class="reqn">N x d</code> matrix where each row is an exponent
vector.</p>
</td></tr>
<tr><td><code id="construct.dmm_+3A_design">design</code></td>
<td>
<p>An <code class="reqn">n x d</code> matrix where each row is a design point.</p>
</td></tr>
<tr><td><code id="construct.dmm_+3A_p">P</code></td>
<td>
<p>An <code class="reqn">N x N</code> change of basis matrix from a monomial basis to
a polynomial basis.  Note that each column corresponds to a polynomial term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>basis</code> defines a monomial basis and the change of basis
matrix <code>P</code> is used to convert this to a polynomial basis.  The function
returns the design model matrix corresponding to this polynomial basis and
the design given by <code>design</code>.  Note that if <code>P</code> is the
appropriately sized identity matrix then the model basis a monomial one.
</p>


<h3>Value</h3>

<p>The <code class="reqn">n x N</code> design model matrix.
</p>

<hr>
<h2 id='construct.K'>Construct the K matrix for a given multivariate basis.</h2><span id='topic+construct.K'></span>

<h3>Description</h3>

<p>This function constructs the K matrix for a given multivariate basis assuming
the basis is a Legendre polynomial basis and the smoothing criterion is the
Frobenius norm of the Hessian integrated over <code class="reqn">[-1, 1]^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.K(basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.K_+3A_basis">basis</code></td>
<td>
<p>A matrix.  Rows of the matrix are taken as the exponent vectors
of the leading terms of a Legendre polynomial basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each entry is <code class="reqn">&lt;f, g&gt;</code> with </p>
<p style="text-align: center;"><code class="reqn">&lt;f, g&gt; = \int_X
 \sum_{i,j}\frac{d^2f}{dx_idx_j}\frac{d^2g}{dx_idx_j} dx,</code>
</p>
<p> with <code class="reqn">f, g</code>
being the Legendre polynomials described by the appropriate exponent vectors.
</p>

<hr>
<h2 id='construct.K.1d'>Construct the K matrix for a given univariate basis.</h2><span id='topic+construct.K.1d'></span>

<h3>Description</h3>

<p>This function constructs the K matrix for a given multivariate basis assuming
the basis is a Legendre polynomial basis and the smoothing criterion is the
Frobenius norm of the Hessian integrated over <code class="reqn">[-1, 1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.K.1d(basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.K.1d_+3A_basis">basis</code></td>
<td>
<p>A matrix.  Rows of the matrix are taken as the degree of the
Legendre polynomial.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each entry is <code class="reqn">&lt;f, g&gt;</code> with </p>
<p style="text-align: center;"><code class="reqn">&lt;f, g&gt; = \int_X
 \frac{d^2f}{dx^2}\frac{d^2g}{dx^2} dx,</code>
</p>
<p> with <code class="reqn">f, g</code> being the
Legendre polynomials described by the appropriate exponent vectors.
</p>

<hr>
<h2 id='construct.P'>Construct the change of basis matrix from multivariate monomials to Legendre
polynomials.</h2><span id='topic+construct.P'></span>

<h3>Description</h3>

<p>Let <code class="reqn">f(x)</code> be the vector of monomials implied by the matrix <code>basis</code>.
Let <code class="reqn">P</code> be the matrix generated by <code>Legendre_P</code>.  Then
<code class="reqn">g(x)=P^Tf(x)</code> is the vector of Legendre polynomials with leading terms
corresponding to <code>basis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.P(basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.P_+3A_basis">basis</code></td>
<td>
<p>A matrix. Rows are taken as the degree of the associated
monomial.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which functions as a change of basis from monomials to
Legendre.
</p>

<hr>
<h2 id='construct.P.1d'>Construct the change of basis matrix from univariate monomials to Legendre
polynomials.</h2><span id='topic+construct.P.1d'></span>

<h3>Description</h3>

<p>Let <code class="reqn">f(x)</code> be the vector of monomials implied by the matrix <code>basis</code>.
Let <code class="reqn">P</code> be the matrix generated by <code>Legendre_P_1d</code>.  Then
<code class="reqn">g(x)=P^Tf(x)</code> is the vector of Legendre polynomials with leading terms
corresponding to <code>basis</code>. <em>e.g.</em> the matrix <code class="reqn">(0 1 2)^T</code> implies
<code class="reqn">f(x)^T = (1 x x^2)</code>. Then <code class="reqn">g(x)^T = (L_0, L_1, L_2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.P.1d(basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.P.1d_+3A_basis">basis</code></td>
<td>
<p>A matrix. Rows are taken as the degree of the associated
monomial.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which functions as a change of basis from monomials to
Legendre.
</p>

<hr>
<h2 id='degl'>Construct matrix of exponent vectors.</h2><span id='topic+degl'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+fit.ssm">fit.ssm</a></code> when it needs to construct
the matrix of exponent vectors stored in the <code>basis</code> slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degl(d, N, exclude = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degl_+3A_d">d</code></td>
<td>
<p>A number. This determines the number of columns in the
output matrix</p>
</td></tr>
<tr><td><code id="degl_+3A_n">N</code></td>
<td>
<p>A number. This determines the number of rows in the output matrix.</p>
</td></tr>
<tr><td><code id="degl_+3A_exclude">exclude</code></td>
<td>
<p>(optional) A list of integer vectors.  If this argument is
provided, the generated matrix will not contain any rows which are only
non-zero in the columns specified by any of the vectors in the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works by repeated calls to <code><a href="#topic+comb">comb</a></code> to generate all
possible exponent vectors of a given degree until <code>N</code> vectors have been
generated.  Any generated vector is checked to make sure that it's non-zero
entries do not match a vector provided in <code>exclude</code> before being added
to the output matrix.
</p>

<hr>
<h2 id='estimate.GP'>Estimate the parameters of the metamodel error estimating GP.</h2><span id='topic+estimate.GP'></span>

<h3>Description</h3>

<p>This function estimates the parameters of the metamodel error estimating
Gaussian process using maximum likelihood methods to identify the length
parameter <code>r</code> of the given correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.GP(ssm, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.GP_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
<tr><td><code id="estimate.GP_+3A_type">type</code></td>
<td>
<p>Character. Specifies the correlation function to use. Either
<code>"exp"</code> for squared exponential or <code>"Matern32"</code> for Matern 3/2.
Anything else will result in the use of a squared exponential correlation
function.#'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the concentrated likelihood function is often flat, this function calls
<code>optimize</code> several times using different search intervals to avoid cases
when the <code>optimize</code> algorithm misses maxima when the interval is too
large.
</p>
<p>The scaling parameter <code>sigma</code> is found analytically once <code>r</code>
has been determined.
</p>


<h3>Value</h3>

<p>An SSM object that is the same as the input except with
estimates for <code>r</code> and <code>sigma</code> in the appropriate slots.
</p>

<hr>
<h2 id='find.theta'>Compute the SSM vector of parameters.</h2><span id='topic+find.theta'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+fit.ssm">fit.ssm</a></code> to compute the coefficient
vector that interpolates the data and minimises the smoothness of the
resulting model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.theta(response, K, design_model, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.theta_+3A_response">response</code></td>
<td>
<p>An length <code class="reqn">n</code> vector. The observed responses.</p>
</td></tr>
<tr><td><code id="find.theta_+3A_k">K</code></td>
<td>
<p>A semi-positive definite <code class="reqn">N x N</code> matrix that defines the smoothing
criterion.</p>
</td></tr>
<tr><td><code id="find.theta_+3A_design_model">design_model</code></td>
<td>
<p>The <code class="reqn">n x N</code> design model matrix.</p>
</td></tr>
<tr><td><code id="find.theta_+3A_tol">tol</code></td>
<td>
<p>(optional) The model fitting requires the inversion of a large
matrix and if the model basis is too large there can be numerical issues.
This argument is passed on to <code><a href="Matrix.html#topic+solve">solve</a></code> so models can be fit
despite these issues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of parameters of length <code class="reqn">N</code> if the model is fit
successfully. <code>NA</code> is returned should <code><a href="Matrix.html#topic+solve">solve</a></code> not invert
the required matrix.
</p>

<hr>
<h2 id='fit.ssm'>Fit a smooth supersaturated model</h2><span id='topic+fit.ssm'></span>

<h3>Description</h3>

<p><code>fit.ssm</code> fits a smooth supersaturated model to given data.  By default
the model smooths over <code class="reqn">[-1, 1]^d</code> and uses a basis of Legendre
polynomials. Many model parameters such as basis size and smoothing
criterion can be user-defined. Optionally, sensitivity indices and a
metamodel error estimating Gaussian process can be computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.ssm(design, response, ssm, basis, basis_size, K, P, design_model_matrix,
  SA = FALSE, GP = FALSE, type = "exp", validation = FALSE,
  exclude = list(), distance_type = "distance")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.ssm_+3A_design">design</code></td>
<td>
<p>A matrix containing the design.  Each design point is a row in
the matrix. Accepts a vector for a design in one variable.  If the default
options for <code>P</code> and <code>K</code> are used then it is recommended that the
design is transformed to lay within <code class="reqn">[-1, 1]^d</code>.  The function
<code><a href="#topic+transform11">transform11</a></code> is useful in this regard.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_response">response</code></td>
<td>
<p>A vector containing the responses at design points.  The
length must correspond with the number of rows in <code>design</code>.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_ssm">ssm</code></td>
<td>
<p>(optional) A pre-existing SSM class object.  If this argument is
supplied then <code>basis</code>, <code>basis_size</code>, <code>K</code>, and <code>P</code> will
be carried over rather than re-computed.  This is useful for simulation
studies where the model structure remains the same and only the design and
responses change.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_basis">basis</code></td>
<td>
<p>(optional) A matrix where each row is an exponent vector of a
monomial.  This is used in conjunction with <code>P</code> to construct the model
basis.  If not supplied, a hierarchical basis will be used.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_basis_size">basis_size</code></td>
<td>
<p>(optional) A number.  Specifies the desired number of
polynomials in the model basis.  If not supplied, <code>basis_size</code> is set
to <code class="reqn">20 * d + n</code>.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_k">K</code></td>
<td>
<p>(optional) A semi-positive definite matrix specifying the weighting
criterion of basis terms.  If not supplied, default behaviour is to use the
Frobenius norm of the term Hessian integrated over <code class="reqn">[-1, 1]^d</code> with
respect to a basis of Legendre polynomials.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_p">P</code></td>
<td>
<p>(optional) A matrix defining the polynomials used to construct the
model basis.  Each column corresponds to one polynomial. If not supplied, a
Legendre polynomial basis is used.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_design_model_matrix">design_model_matrix</code></td>
<td>
<p>(optional) Specify a design model matrix.  If
provided the new model will be fit to the basis and design implied by the
design model matrix regardless of the values of <code>basis</code>, <code>P</code> and
<code>design</code>.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_sa">SA</code></td>
<td>
<p>(optional) Logical. If TRUE then Sobol indices, Total indices and
Total interaction indices will be computed.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_gp">GP</code></td>
<td>
<p>(optional) Logical. If TRUE then a GP metamodel error estimate will
be computed.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_type">type</code></td>
<td>
<p>(optional) Character. One of &quot;exp&quot; or &quot;matern32&quot;.  Specifies the
correlation function used to compute the GP covariance matrix.  Irrelevant
if <code>GP</code> is FALSE. For further details see
<code><a href="#topic+compute.covariance">compute.covariance</a></code>.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_validation">validation</code></td>
<td>
<p>(optional) Logical.  If TRUE then the Leave-One-Out errors
are computed for each design point and the standardised root mean square
error calculated.  The rmse is standardised against the variance of the
ybar estimator. If <code>GP</code> is TRUE then these will be calculated
regardless of the value of <code>validation</code>.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_exclude">exclude</code></td>
<td>
<p>(optional) A list of vectors of integers. These indicate terms
in the listed variables should be omitted from the model. <em>e.g.</em>
<code>exclude = list(1)</code> removes all terms dependent on the first variable
only. <code>exclude = list(1, c(1, 2))</code> removes terms in the first variable
only and interactions between the first and second variables only. To
remove a variable and all of its higher order interactions, it is better to
remove the appropriate column from the design otherwise the algorithm will
generate a lot of basis vectors that will be excluded, wasting computation.</p>
</td></tr>
<tr><td><code id="fit.ssm_+3A_distance_type">distance_type</code></td>
<td>
<p>(optional) Character. Selects the distance function used
for the GP metamodel error estimate correlation function. One of
&quot;distance&quot;, &quot;line&quot;, &quot;product&quot;, &quot;area&quot;, &quot;proddiff&quot;, or &quot;smoothdiff&quot;.  Uses
&quot;distance&quot;, the standard Euclidean distance between points by default.  For
further details see <code><a href="#topic+new.distance">new.distance</a></code>.  Not needed if <code>GP</code> is
FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an SSM object containing the fitted smooth
supersaturated model.  Minimal arguments required are <code>design</code> and
<code>response</code>.  This will result in a model using Legendre polynomials
and smoothing over <code class="reqn">[-1, 1]^d</code>. All other arguments will be assigned
automatically if not specified.
</p>
<p>If the model is unable to be fit due to numerical instability a warning will
be given and the returned SSM object will have a zero vector of appropriate
length in the <code>theta</code> slot.  The <code>basis_size</code> parameter is often
useful in this situation.  Try reducing the basis_size until a model fit is
successful.  Ideally the basis size should be as large as possible without
causing instability in the predictions (see the example below).
</p>
<p>If <code>SA</code> is TRUE then sensitivty analysis will be performed on the model.
Sobol indices for main effects, Total indices, and Total interaction indices
for second order interactions will be computed and held in the slots
<code>main_sobol</code>, <code>total_sobol</code> and <code>total_int</code> respectively. If
the number of factors is &lt; 11 then Sobol indices will be computed for all
order interactions and stored in <code>int_sobol</code>.  Default behaviour is to
assume each input is uniformly distributed over <code class="reqn">[-1, 1]</code>.  If <code>P</code>
has been used-defined then the polynomials defined by <code>P</code> are assumed to
be an orthonormal system with respect to some measure on the reals.  See
<code><a href="#topic+update.sensitivity">update.sensitivity</a></code> for more details.
</p>
<p>If <code>GP</code> is TRUE (default behaviour is false due to computational cost)
then a the metamodel error is estimated using a zero-mean Gaussian process
with a constant trend.  Scaling and length parameters are estimated using
maximum likelihood methods using the Leave-One-Out model errors and stored
in the <code>sigma</code> and <code>r</code> slots respectively.  Model predictions
using <code><a href="#topic+predict.SSM">predict.SSM</a></code> will then include credible intervals. The
distance between points is defined by the <code>distance_type</code> argument and
is set to the standard Euclidean distance by default.  See
<code><a href="#topic+new.distance">new.distance</a></code> for other options although they are experimental
and subject to erratic behaviour. The default correlation function used is
the square exponential although this can be changed to a Matern 3/2
function by setting the <code>type</code> argument to <code>"matern32"</code>.
</p>
<p>If <code>validation</code> is TRUE then the Leave-One_Out error at each design
point will be computed and stored in the <code>residuals</code> slot, and the LOO
RMSE computed and stored in the <code>LOO_RMSE</code> slot.  Note that if
<code>GP</code> is TRUE then these values will be computed regardless of the
value of <code>validation</code> as they are required to fit the metamodel error
estimate GP.
</p>


<h3>Value</h3>

<p>An SSM object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.SSM">predict.SSM</a></code> for model predictions for SSM, and
<code><a href="#topic+plot.SSM">plot.SSM</a></code> for plotting main effects of SSM.
<code><a href="#topic+transform11">transform11</a></code> is useful for transforming data to
<code class="reqn">[-1, 1]^d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple one factor example
X &lt;- seq(-1,1,0.5) # design
Y &lt;- c(0,1,0,0.5,0) # response
s &lt;- fit.ssm(X,Y)
s
plot(s)
predict(s,0.3)

# used defined basis sizes

# A model that is too large to fit
## Not run: 
s &lt;- fit.ssm(X, Y, basis_size=80)

## End(Not run)
# A large model that can be fit but is unstable
s &lt;- fit.ssm(X, Y, basis_size=70)
plot(s)
# A model larger than default that is not unstable
s &lt;- fit.ssm(X, Y, basis_size=40)
plot(s)

# with metamodel error estimate

s &lt;- fit.ssm(X, Y, GP=TRUE)
plot(s)
predict(s,0.3)

# Sensitivity analysis and main effect plotting

# A design of 20 points over [-1, 1]^d
X &lt;- matrix(runif(20, -1, 1), ncol = 2)
Y &lt;- runif(10)
s &lt;- fit.ssm(X, Y, SA = TRUE)
s
sensitivity.plot(s)
plot(s)
</code></pre>

<hr>
<h2 id='get.K.element'>Compute entry of K matrix.</h2><span id='topic+get.K.element'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+construct.K">construct.K</a></code> to compute entries of the K matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.K.element(n, m, basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.K.element_+3A_n">n</code></td>
<td>
<p>A number. Identifies the first basis element in the inner product.</p>
</td></tr>
<tr><td><code id="get.K.element_+3A_m">m</code></td>
<td>
<p>A number. Identifies the second basis element in the inner product.</p>
</td></tr>
<tr><td><code id="get.K.element_+3A_basis">basis</code></td>
<td>
<p>A matrix. Rows are taken as exponent vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inner product of the <code class="reqn">n, m</code>-th basis elements as defined for
<code><a href="#topic+construct.K">construct.K</a></code>.
</p>

<hr>
<h2 id='identify.main.effect.terms'>Identify main effect terms</h2><span id='topic+identify.main.effect.terms'></span>

<h3>Description</h3>

<p>This is used by the sensitivity computation functions to identify which basis
terms are associated with each main effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'main.effect.terms'
identify(i, basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.main.effect.terms_+3A_i">i</code></td>
<td>
<p>A number indicating the main effect of interest.</p>
</td></tr>
<tr><td><code id="identify.main.effect.terms_+3A_basis">basis</code></td>
<td>
<p>A matrix.  A matrix where each row is an exponent vector of a
monomial basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.  Each term corresponds with the associated row of
<code>basis</code>.
</p>

<hr>
<h2 id='identify.total.effect.terms'>Identify total effect terms</h2><span id='topic+identify.total.effect.terms'></span>

<h3>Description</h3>

<p>This is used by the sensitivity computation functions to identify which basis
terms are associated with each total effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'total.effect.terms'
identify(i, basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.total.effect.terms_+3A_i">i</code></td>
<td>
<p>A number indicating the total effect of interest.</p>
</td></tr>
<tr><td><code id="identify.total.effect.terms_+3A_basis">basis</code></td>
<td>
<p>A matrix.  A matrix where each row is an exponent vector of a
monomial basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.  Each term corresponds with the associated row of
<code>basis</code>.
</p>

<hr>
<h2 id='likelihood.plot'>Plot the concentrated likelihood of an SSM.</h2><span id='topic+likelihood.plot'></span>

<h3>Description</h3>

<p>Plot the concentrated likelihood used to estimate the parameters of the
metamodel error estimating Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood.plot(ssm, xrange = c(0, 1000), grid = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood.plot_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
<tr><td><code id="likelihood.plot_+3A_xrange">xrange</code></td>
<td>
<p>(optional) The range of the x axis. Set to <code>c(0, 1000)</code>
by default.</p>
</td></tr>
<tr><td><code id="likelihood.plot_+3A_grid">grid</code></td>
<td>
<p>(optional) A number. The number of points used to plot the curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a diagnostic it can be helpful to look at the concentrated likelihood
function of the correlation function used to estimate the metamodel error.
Flat likelihood functions make it difficult to pick a suitable <code>r</code>
length parameter. Note that <code>r</code> and <code>sigma</code> can be set manually.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(attitude)
X &lt;- transform11(attitude[ 2:7])
Y &lt;- attitude[ , 1]
s &lt;- fit.ssm(X, Y, GP = TRUE)
likelihood.plot(s)
likelihood.plot(s, xrange = c(0, 20))
</code></pre>

<hr>
<h2 id='lineij'>Average the values in a vector between two cutoff points specified by a
separate vector.</h2><span id='topic+lineij'></span>

<h3>Description</h3>

<p>The values of <code>smoothnessdesign</code> that are in the interval specifed by
<code>x</code> are identified and the associated values in <code>smoothness</code> are
averaged. This is used in the computation of line integrals of smoothness
used by a particular distance measure when computing metamodel error
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineij(x, smoothness, smoothnessdesign)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineij_+3A_x">x</code></td>
<td>
<p>A vector of length two. Specifies the endpoints of the desired
interval of integration.</p>
</td></tr>
<tr><td><code id="lineij_+3A_smoothness">smoothness</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="lineij_+3A_smoothnessdesign">smoothnessdesign</code></td>
<td>
<p>A numeric vector of the same length as
<code>smoothness</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number.
</p>

<hr>
<h2 id='new.distance'>Compute the distance matrix of an SSM design.</h2><span id='topic+new.distance'></span>

<h3>Description</h3>

<p>Computes the distance matrix associated with the design held in the
<code>design</code> slot of an SSM object. Used in the construction of the
metamodel error estimating Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.distance(type = "distance", ssm, line.grid = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new.distance_+3A_type">type</code></td>
<td>
<p>(optional) Character. Specifies the distance measure used.
Acceptable values are &quot;distance&quot;, &quot;line&quot;, &quot;product&quot;, &quot;area&quot;, &quot;proddiff&quot;,
&quot;smoothdiff&quot;.</p>
</td></tr>
<tr><td><code id="new.distance_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
<tr><td><code id="new.distance_+3A_line.grid">line.grid</code></td>
<td>
<p>(optional). An integer. Specifies the number of points used
in the computation of the distance matrix when <code>type = "line"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented types of distance measure are:
</p>

<ul>
<li><p><code>"distance"</code> Standard Euclidean distance.
</p>
</li>
<li><p><code>"line"</code> The line integral of the smoothness between design
points. This is not implemented for data where <code>d</code> &gt; 1.
</p>
</li>
<li><p><code>"product"</code> The product of the Euclidean distance and the
local smoothness at both points.
</p>
</li>
<li><p><code>"area"</code> The sum of the local smoothness at the points
multiplied by the Euclidean distance.
</p>
</li>
<li><p><code>"proddiff"</code> Multiplies the difference in local smoothness
between points by the Euclidean distance.
</p>
</li>
<li><p><code>"smoothdiff"</code> The difference between the local smoothness of
points.
</p>
</li></ul>

<p>All measures other than <code>"distance"</code> are experimental and should be
used with caution.
</p>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='optimize.by.interval.maximum'>Optimize concentrated likelihood.</h2><span id='topic+optimize.by.interval.maximum'></span>

<h3>Description</h3>

<p>Wrapper for optimizing <code>concentrated.likelihood</code>. Used by
<code><a href="#topic+estimate.GP">estimate.GP</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize.by.interval.maximum(int, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize.by.interval.maximum_+3A_int">int</code></td>
<td>
<p>The maximum endpoint of the interval of optimization.</p>
</td></tr>
<tr><td><code id="optimize.by.interval.maximum_+3A_...">...</code></td>
<td>
<p>arguments to pass to the optimize call.</p>
</td></tr>
</table>

<hr>
<h2 id='partial.deriv.ssm'>Compute second partial derivative of a smooth supersaturated model at all
design points.</h2><span id='topic+partial.deriv.ssm'></span>

<h3>Description</h3>

<p>Computes a second partial derivative of a smooth supersaturated model at a
design point. Used in the computation of distance measures based on local
smoothness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.deriv.ssm(indices, ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.deriv.ssm_+3A_indices">indices</code></td>
<td>
<p>A vector of integers specifying the two variables by which we
take the partial derivatives with respect to.</p>
</td></tr>
<tr><td><code id="partial.deriv.ssm_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single column vector containing the second partial derivatives with
respect to the requested variables, evaluated at all design points.
</p>

<hr>
<h2 id='plot.SSM'>Plot smooth supersaturated model main effects</h2><span id='topic+plot.SSM'></span>

<h3>Description</h3>

<p><code>plot.SSM</code> is a plot method for SSM objects. It plots the main effects
of the SSM only, that is the subset of basis terms that are dependent on a
single variable only.  For single variable data this is a plot of the
complete model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SSM'
plot(x, ..., grid = 200, yrange = "full", GP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SSM_+3A_x">x</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
<tr><td><code id="plot.SSM_+3A_...">...</code></td>
<td>
<p>(optional) arguments to pass to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="plot.SSM_+3A_grid">grid</code></td>
<td>
<p>(optional) A number. This specifies the resolution of the plot,
<em>i.e.</em> how many model evaluations are used to construct the curve.</p>
</td></tr>
<tr><td><code id="plot.SSM_+3A_yrange">yrange</code></td>
<td>
<p>(optional) Character. Only &quot;full&quot; will have an effect.</p>
</td></tr>
<tr><td><code id="plot.SSM_+3A_gp">GP</code></td>
<td>
<p>(optional) Logical. For single variable data, the credible interval
of the metamodel error estimator will be plotted if TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each variable, the effect is plotted over <code class="reqn">[-1, 1]</code> by default
although passing an alternate range to the <code>xlim</code> argument will override
this.
</p>
<p>The <code>yrange</code> argument is designed to automatically compute the relevant
plot range for each effect. By default a <code>ylim</code> value is passed to
<code>plot</code> that covers the range of responses. &quot;full&quot; results in a
<code>ylim</code> value that covers the range of predictions or, if appropriate,
the range of the metamodel error credible interval.
</p>
<p>For single variable data, setting <code>GP</code> to TRUE will plot a credible
interval for the metamodel error estimating Gaussian process if this has been
computed for the SSM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single variable example
X &lt;- seq(-1, 1, 0.25)
Y &lt;- sapply(X, "^", 3)
s &lt;- fit.ssm(X, Y, GP = TRUE)
plot(s)

# A six variable example
data(attitude)
X &lt;- transform11(attitude[ 2:7])
Y &lt;- attitude[ , 1]
s &lt;- fit.ssm(X, Y)
plot(s)
</code></pre>

<hr>
<h2 id='predict.SSM'>Point prediction of smooth supersaturated models.</h2><span id='topic+predict.SSM'></span>

<h3>Description</h3>

<p>This method gives the prediction of an SSM object at a point. If the
SSM has a metamodel error estimate then a <code class="reqn">(1 - \alpha)</code> credible
interval is also output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SSM'
predict(object, x, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SSM_+3A_object">object</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
<tr><td><code id="predict.SSM_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">d</code> length vector identifying the prediction point.</p>
</td></tr>
<tr><td><code id="predict.SSM_+3A_alpha">alpha</code></td>
<td>
<p>(optional) A number in <code class="reqn">[0, 1]</code> for the <code class="reqn">(1 - \alpha)</code>
metamodel error estimate credible interval. Set to <code>0.05</code> by default.</p>
</td></tr>
<tr><td><code id="predict.SSM_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a number if the SSM has no metamodel error estimating Gaussian
process, or three numbers giving the model prediction (<code>$model</code>), and
the lower and upper bounds of the credible interval (<code>$lower</code> and
<code>$upper</code>) respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(attitude)
X &lt;- transform11(attitude[ 2:7])
Y &lt;- attitude[ , 1]
# with no metamodel error estimating GP.
s &lt;- fit.ssm(X, Y)
predict(s, rep(1,6))

# with metamodel error estimating GP.
s &lt;- fit.ssm(X, Y, GP = TRUE)
predict(s, rep(1,6))
</code></pre>

<hr>
<h2 id='sensitivity.plot'>Plot the sensitivity indices of a smooth supersaturated model.</h2><span id='topic+sensitivity.plot'></span>

<h3>Description</h3>

<p><code>sensitivity.plot</code> visualises the sensitivity indices of a given smooth
supersaturated model using <code>barplot</code>.  If the <code>SA</code> flag was not set
to TRUE when <code><a href="#topic+fit.ssm">fit.ssm</a></code> was run to fit the model, then
<code><a href="#topic+update.sensitivity">update.sensitivity</a></code> should be used to compute the model
variances.  If not, this function will return an error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity.plot(ssm, type = "main_total", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity.plot_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.  Must have relevant sensitivity indices
in the appropriate slots, either from setting <code>SA = TRUE</code> in
<code><a href="#topic+fit.ssm">fit.ssm</a></code> or by using <code><a href="#topic+update.sensitivity">update.sensitivity</a></code>.</p>
</td></tr>
<tr><td><code id="sensitivity.plot_+3A_type">type</code></td>
<td>
<p>(optional) Character. Determines the type of barplot. One of
<code>"sobol"</code>, <code>"main_sobol"</code>, <code>"main_total"</code>, or
<code>"total"</code>. Default behaviour is <code>"main_total"</code>.</p>
</td></tr>
<tr><td><code id="sensitivity.plot_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code>barplot</code> function call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four classes of plot available:
</p>

<ul>
<li><p><code>"sobol"</code> Produces a barplot of all Sobol indices. If there
are more than 10 factors then Sobol indices will not have been computed for
interactions and only the Sobol indices for main effects will be plotted.
Main effects are in red, interactions are in grey.
</p>
</li>
<li><p><code>"main_sobol"</code> Produces a barplot of Sobol indices for main
effects only.
</p>
</li>
<li><p><code>"main_total"</code> Produces a barplot of Total indices for main
effects only. This is the default behaviour.
</p>
</li>
<li><p><code>"total"</code> Produces a barplot of Total indices for main effects
and all second order interactions. Main effects are in red, interactions
are in grey.
</p>
</li></ul>

<p>Note that variables and interactions are not labelled in the plots since
there can be too many bars to label clearly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A 20 point design in four variables
X &lt;- matrix(runif(80, -1, 1), ncol = 4)
Y &lt;- runif(20)
s &lt;- fit.ssm(X, Y, SA = TRUE)
sensitivity.plot(s)

# In the next plots, the grey bars indicate interactions.
sensitivity.plot(s, "sobol")
sensitivity.plot(s, "total")
# Identifying particular indices is best done using the information held in
# the SSM object.  The following orders s@total_int_factors so the
# interaction indicated by the top row is the most important.
ind &lt;- order(s@total_int, decreasing = TRUE)
s@total_int_factors[ind, ]
</code></pre>

<hr>
<h2 id='show+2CSSM-method'>Summarise SSM class object</h2><span id='topic+show+2CSSM-method'></span>

<h3>Description</h3>

<p>Printing an SSM will summarise the parameters d, N, and n.  If no model has
been fit then this will be noted, otherwise The smoothness of the SSM will be
shown.  If sensitivity analysis has been performed, the Sobol indices and
Total indices for main effects are displayed and if cross-validation has been
performed the Standardised LOO RMSE is also shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SSM'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CSSM-method_+3A_object">object</code></td>
<td>
<p>An SSM object</p>
</td></tr>
</table>

<hr>
<h2 id='smoothness.over.design'>Compute the smoothness of an SSM at all design points.</h2><span id='topic+smoothness.over.design'></span>

<h3>Description</h3>

<p>This function evaluates the Frobenius norm of the Hessian matrix at all
design points. Used in the compuation of distance measures based on local
smoothness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothness.over.design(ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothness.over.design_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers containing the smoothness at each design point.
</p>

<hr>
<h2 id='SSM'>SSM: A package for fitting smooth supersaturated models (SSM).</h2><span id='topic+SSM-package'></span>

<h3>Description</h3>

<p>The SSM package provides an S4 class to represent smooth supersaturated
models, along with functions for fitting SSM to data, computing Sobol indices
for the SSM and estimating metamodel error with a Gaussian process.
</p>


<h3>SSM functions</h3>

<p>There are three important functions in the package.
</p>
<p><code>fit.ssm</code> returns an SSM object that fits an SSM to the data and, by
default, computes the Sobol indices, and Total interaction indices of the
model.  Optionally, the metamodel error can be estimated using a Gaussian
process.  The fitted SSM smooths over <code class="reqn">[-1, 1]^d</code> and uses a hierarchical
basis of 20*d+n Legendre polynomials by default but the function is highly
customisable.
</p>
<p><code>predict.SSM</code> returns the model prediction at a point, including a
credible interval if a metamodel error GP has been fit.
</p>
<p><code>plot.SSM</code> plots the main effects of the SSM.
</p>

<hr>
<h2 id='SSM-class'>An S4 class to represent a smooth supersaturated model</h2><span id='topic+SSM'></span><span id='topic+SSM-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a smooth supersaturated model
</p>


<h3>Slots</h3>


<dl>
<dt><code>dimension</code></dt><dd><p>A number indicating the number of variables in the design.</p>
</dd>
<dt><code>design</code></dt><dd><p>A matrix with rows indicating the design point and columns
indicating the variable.</p>
</dd>
<dt><code>design_size</code></dt><dd><p>A number indicating the number of design points.</p>
</dd>
<dt><code>response</code></dt><dd><p>A <code>design_size</code> length vector of responses.</p>
</dd>
<dt><code>theta</code></dt><dd><p>A vector containing the fitted model coefficients.</p>
</dd>
<dt><code>basis</code></dt><dd><p>A matrix with each row being the exponent vector of a polynomial
term.</p>
</dd>
<dt><code>basis_size</code></dt><dd><p>A number indicating the number of basis terms used in the
model.  This may be different from <code>nrow(basis)</code> if terms are excluded.</p>
</dd>
<dt><code>include</code></dt><dd><p>A vector containing the row numbers of the basis polynomials
used in the model.  This is used when interactions or variables are being
excluded from the model.</p>
</dd>
<dt><code>K</code></dt><dd><p>A semi-positive definite matrix that defines the smoothing criteria.</p>
</dd>
<dt><code>P</code></dt><dd><p>A matrix that defines the polynomial basis in terms of a monomial
basis.</p>
</dd>
<dt><code>design_model_matrix</code></dt><dd><p>A matrix.</p>
</dd>
<dt><code>variances</code></dt><dd><p>A vector of length <code>basis_size</code> containing the term
variances.</p>
</dd>
<dt><code>total_variance</code></dt><dd><p>A length one vector containing the total variance.</p>
</dd>
<dt><code>main_sobol</code></dt><dd><p>A <code>dimension</code> length vector containing the Sobol
index for each variable.</p>
</dd>
<dt><code>main_ind</code></dt><dd><p>A logical matrix indicating whether each term is included
in the main effect corresponding to the column.</p>
</dd>
<dt><code>total_sobol</code></dt><dd><p>A <code>dimension</code> length vector containing the Total
sensitivity index for each variable.</p>
</dd>
<dt><code>total_ind</code></dt><dd><p>A logical matrix indicating whether each term is included in
the Total sensitivity index corresponding to the column.</p>
</dd>
<dt><code>int_sobol</code></dt><dd><p>A vector containing the Sobol index for interactions.</p>
</dd>
<dt><code>int_factors</code></dt><dd><p>A list of length the same as <code>int_sobol</code> indicating
which interaction corresponds with each entry in <code>int_sobol</code>.</p>
</dd>
<dt><code>total_int</code></dt><dd><p>A vector containing the Total interaction indices of all
second order interactions.</p>
</dd>
<dt><code>total_int_factors</code></dt><dd><p>A matrix where each row indicates the variables
associated with the corresponding interaction in <code>total_int</code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>A matrix containing the distances used for computing the
covariance matrix of the GP metamodel error estimate.</p>
</dd>
<dt><code>distance_type</code></dt><dd><p>A character defining the distance type used for computing
<code>distance</code>.  Can be one of &quot;distance&quot;, &quot;line&quot;, &quot;product&quot;, &quot;area&quot;,
&quot;proddiff&quot;, or &quot;smoothdiff&quot;.</p>
</dd>
<dt><code>type</code></dt><dd><p>A character, either &quot;exp&quot;, &quot;matern32&quot;, that selects the
correlation function used for the GP metamodel error estimate.</p>
</dd>
<dt><code>covariance</code></dt><dd><p>A positive definite matrix.  The covariance matrix of the GP
metamodel error estimate prior to scaling by <code>sigma</code>.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>A <code>design_size</code> length vector containing the
Leave-One-Out errors of the model at each design point.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>A number indicating the scaling factor for <code>covariance</code>.</p>
</dd>
<dt><code>r</code></dt><dd><p>A number indicating the length factor for the correlation function.</p>
</dd>
<dt><code>local_smoothness</code></dt><dd><p>A <code>design_size</code> length vector containing the
model smoothness at each design point.</p>
</dd>
<dt><code>LOO_RMSE</code></dt><dd><p>A number. The Leave-One-Out root mean square error.</p>
</dd>
<dt><code>legendre</code></dt><dd><p>logical. Indicates whether the default Legendre polynomial
basis is being used.</p>
</dd>
<dt><code>fail</code></dt><dd><p>logical. Indicates whether the model fit was successful.</p>
</dd>
</dl>

<hr>
<h2 id='transform11'>Transform a design to [-1, 1]^d</h2><span id='topic+transform11'></span>

<h3>Description</h3>

<p>This function transforms a design (supplied as a matrix) into the space
[-1, 1]^d.  This has numerical and computational advantages when using smooth
supersaturated models and is assumed by the default <code><a href="#topic+fit.ssm">fit.ssm</a></code>
behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform11(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform11_+3A_design">design</code></td>
<td>
<p>A matrix where each row is a design point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column contains values in <code class="reqn">[-1, 1]^d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- transform11(quakes[, 1:4])
apply(X, 2, range)
</code></pre>

<hr>
<h2 id='update.sensitivity'>Update an SSM object with the term variances and Sobol indices</h2><span id='topic+update.sensitivity'></span>

<h3>Description</h3>

<p>This function computes the term variances, Sobol indices, Total indices and
Total interaction indices of a given SSM class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sensitivity'
update(ssm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.sensitivity_+3A_ssm">ssm</code></td>
<td>
<p>An SSM object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has two modes.  If the <code>legendre</code> slot in the SSM object
is TRUE (<em>i.e.</em> the default <code>P</code> matrix has been used to fit the
SSM) then all the sensitivity indices are computed assuming inputs are
uniformly distributed over <code class="reqn">[-1, 1]^d</code>.  If <code>legendre</code> is FALSE
(<em>i.e.</em> a user-defined <code>P</code> has been supplied) then the polynomials
defined by <code>P</code> are orthonormal with respect to some probability measure
and the sensitivity indices are computed assuming that measure defines the
distribution of the inputs.
</p>
<p>The returned SSM object has term variances held in the <code>variances</code> slot,
ordered to match the exponent vectors in the <code>basis</code> slot.  The Sobol
indices are placed in <code>main_sobol</code> and the Total indices in
<code>total_sobol</code>.  The Total interaction indices are placed in the
<code>total_int</code> slot with identifying labels stored in
<code>total_int_factors</code>.  If there are less than eleven variables then
interaction indices are computed for all order interactions and stored in
<code>int_sobol</code> with identifying labels in <code>int_factors</code>.
</p>


<h3>Value</h3>

<p>An SSM object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
