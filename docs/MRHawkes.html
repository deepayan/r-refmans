<!DOCTYPE html><html><head><title>Help for package MRHawkes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MRHawkes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fivaqks'>
<p>Fiji and Vanuatu Earthquake Data</p></a></li>
<li><a href='#mllMRH'>
<p>Minus loglikelihood of an (bivariate) MRHawkes model</p></a></li>
<li><a href='#mllMRH1'>
<p>Minus loglikelihood of an (bivariate) MRHawkes model with most recent</p>
immigrant probabilities</a></li>
<li><a href='#mllMRH2'>
<p>Minus loglikelihood of an (bivariate) MRHawkes model with Rosenblatt</p>
residuals</a></li>
<li><a href='#MRHawkes-package'>
<p>Multivariate Renewal Hawkes Process</p></a></li>
<li><a href='#predDen'>
<p>MRHawkes (bivariate) predictive density function</p></a></li>
<li><a href='#simMRHawkes'>
<p>Simulate an (bivariate) renewal Hawkes (MRHawkes) process</p></a></li>
<li><a href='#simNSMHP'>
<p>Simulate a (bivariate) non-stationary multivariate Hawkes process (NSMHP)</p></a></li>
<li><a href='#simpred'>
<p>Simulate a fitted (bivariate) MRHawkes process model</p></a></li>
<li><a href='#TmllMRH'>
<p>Minus loglikelihood of an (bivariate) MRHawkes model with truncated most</p>
recent immigrant probabilities</a></li>
<li><a href='#typeRes'>
<p>Minus loglikelihood of an (bivariate) MRHawkes model with Universal</p>
residuals</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Renewal Hawkes Process</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Tom Stindl and Feng Chen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate a (bivariate) multivariate renewal Hawkes (MRHawkes) 
    self-exciting process, with given immigrant hazard rate functions and 
    offspring density function. Calculate the likelihood of a MRHawkes process 
    with given hazard rate functions and offspring density function for an 
    (increasing) sequence of event times. Calculate the Rosenblatt residuals of the 
    event times. Predict future event times based on observed event times up to a 
    given time. For details see Stindl and Chen (2018) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2018.01.021">doi:10.1016/j.csda.2018.01.021</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>IHSEP, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-20 01:02:54 UTC; tomstindl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-20 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fivaqks'>
Fiji and Vanuatu Earthquake Data
</h2><span id='topic+fivaqks'></span>

<h3>Description</h3>

<p>Times and magnitudes (Richter scale) of earthquakes in the regions
of Fiji and Vanuatu, for the period 1990-2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fivaqks)</code></pre>


<h3>Format</h3>

<p>A data set containing 22 variables for earthquakes around Fiji 
and Vanuatu from 1991 to 2015.
</p>

<dl>
<dt>time</dt><dd><p>Time of quake</p>
</dd>
<dt>latitude</dt><dd><p>Latitude of the quake</p>
</dd>
<dt>longitude</dt><dd><p>Longitude of the quake</p>
</dd>
<dt>mag</dt><dd><p>Magnitude of the quake</p>
</dd>
</dl>



<h3>Source</h3>

<p>United States Geological Survey (USGS)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(fivaqks)
</code></pre>

<hr>
<h2 id='mllMRH'>
Minus loglikelihood of an (bivariate) MRHawkes model
</h2><span id='topic+mllMRH'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an (bivariate) MRHawkes model with 
given immigration hazard functions <code class="reqn">\mu</code>, offspring density functions 
<code class="reqn">h</code> and bracnhing ratios <code class="reqn">\eta</code> for the event times and types 
<code>data</code> on the interval <code class="reqn">[0,cens]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllMRH(data, cens, par,
       h1.fn = function(x, p) 1 / p * exp( - x / p),
       h2.fn = function(x, p) 1 / p * exp( - x / p),
       mu1.fn = function(x, p){ 
              exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                  pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                  log.p = TRUE))
       },
       mu2.fn = function(x, p){
             exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                 pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                 log.p = TRUE))
       },
       H1.fn = function(x, p) pexp(x, rate = 1 / p),
       H2.fn = function(x, p) pexp(x, rate = 1 / p),
       Mu1.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                   log.p = TRUE)
       },
       Mu2.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                    log.p = TRUE)
       })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mllMRH_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the ten parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two renewal distributions, 
the two offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_mu1.fn">mu1.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type
one. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_mu2.fn">mu2.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type 
two. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_h1.fn">H1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_h2.fn">H2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_mu1.fn">Mu1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="mllMRH_+3A_mu2.fn">Mu2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Magnitude 5.5 or greater earthquakes over the 25 year period from 
  ## 01/01/1991 to 31/12/2015.
  data(fivaqks); 
  near.fiji &lt;- grep("Fiji", fivaqks$place)
  near.vanuatu &lt;- grep("Vanuatu", fivaqks$place)
  t.beg &lt;- strptime("1991-01-01 00:00:00", "%Y-%m-%d %H:%M:%S", tz = "UTC")
  t.end &lt;- strptime("2015-12-31 23:59:59", "%Y-%m-%d %H:%M:%S", tz = "UTC")
  t0 &lt;- 0
  t1 &lt;- as.numeric(t.end - t.beg)
  tms &lt;- strptime(fivaqks$time, "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
  ts &lt;- as.numeric(tms[-1] - t.beg)
  ts &lt;- c(as.numeric(tms[1] - t.beg)/24, ts)
  ts.fi &lt;- ts[near.fiji]; ts.fi &lt;- ts.fi[ts.fi &gt;= 0 &amp; ts.fi &lt;= t1]
  ts.va &lt;- ts[near.vanuatu]; ts.va &lt;- ts.va[ts.va &gt;=0 &amp; ts.va &lt;= t1]
  ts.c &lt;- c(ts.fi, ts.va)
  z.c &lt;- c(rep(1, times = length(ts.fi)), rep(2, times = length(ts.va)))
  o &lt;- order(ts.c)
  data &lt;- cbind(ts.c[o], z.c[o])
  
  ## calculate the minus loglikelihood of an (bivariate) MRHawkes with some 
  ## parameters the default hazard functions and density functions are Weibull 
  ## and exponential respectivley
  mllMRH(data, cens = t1, par = c(0.488, 20.10, 0.347, 9.53, 461, 720,
                                  0.472, 0.293, 0.399, -0.0774))
                                  
  ## calculate the MLE for the parameter assuming known parametric forms
  ## of the immigrant hazard function and offspring density functions.  
  
    system.time(est &lt;- optim(c(0.488, 20.10, 0.347, 9.53, 461, 720,
                                  0.472, 0.293, 0.399, -0.0774), 
                             mllMRH, data = data, cens = t1,
                             control = list(maxit = 5000, trace = TRUE),
                             hessian = TRUE)
    )
    ## point estimate by MLE
    est$par
    ## standard error estimates:
    diag(solve(est$hessian))^0.5
  
</code></pre>

<hr>
<h2 id='mllMRH1'>
Minus loglikelihood of an (bivariate) MRHawkes model with most recent 
immigrant probabilities
</h2><span id='topic+mllMRH1'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an (bivariate) RHawkes model 
with given immigration hazard functions <code class="reqn">\mu</code>, common offspring 
density functions <code class="reqn">h</code> and bracnhing ratios <code class="reqn">\eta</code> for event times 
and event types <code>data</code> on interval <code class="reqn">[0,cens]</code>. The same as 
<code>mllMRH</code> although this version also returns the most recent 
immigrant probabilities at the censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllMRH1(data, cens, par,
       h1.fn = function(x, p) 1 / p * exp( - x / p),
       h2.fn = function(x, p) 1 / p * exp( - x / p),
       mu1.fn = function(x, p){ 
              exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                  pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                  log.p = TRUE))
       },
       mu2.fn = function(x, p){
             exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                 pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                 log.p = TRUE))
       },
       H1.fn = function(x, p) pexp(x, rate = 1 / p),
       H2.fn = function(x, p) pexp(x, rate = 1 / p),
       Mu1.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                   log.p = TRUE)
       },
       Mu2.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                    log.p = TRUE)
       })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mllMRH1_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the ten parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two renewal distributions, 
the two offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_mu1.fn">mu1.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type
one. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_mu2.fn">mu2.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type 
two. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_h1.fn">H1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_h2.fn">H2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_mu1.fn">Mu1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="mllMRH1_+3A_mu2.fn">Mu2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mll</code></td>
<td>
<p>minus log-likelihood</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>most recent immigrant probabilities at the censoring time</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of events</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mllMRH</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data &lt;- cbind(sort(runif(1000,0,1000)), 
                sample(1:2, size = 1000, replace = TRUE))
  tmp &lt;- mllMRH1(data = data, cens = 1001, 
                 par = c(3,1.2,1/3,0.2,1,1,0.5,0.2,0.2,0.3))
  ## last immigrant probabilities
  lip &lt;- tmp$p
  ## sample last immigrant at censoring time for component one and 
  ## component two respectively
  c(sample(0:1000, 1, replace = TRUE, prob = rowSums(lip)), 
  sample(0:1000, 1, replace = TRUE, prob = colSums(lip)))
  
</code></pre>

<hr>
<h2 id='mllMRH2'>
Minus loglikelihood of an (bivariate) MRHawkes model with Rosenblatt 
residuals
</h2><span id='topic+mllMRH2'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an (bivariate) RHawkes model with 
given immigration hazard functions <code class="reqn">\mu</code>, common offspring density 
functions <code class="reqn">h</code> and bracnhing ratios <code class="reqn">\eta</code> for event times and 
event types <code>data</code> on interval <code class="reqn">[0,cens]</code>. The same as 
<code>mllMRH</code> although this version also returns the Rosenblatt residuals 
for goodness-of-fit assessment of the event times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllMRH2(data, cens, par,
       h1.fn = function(x, p) 1 / p * exp( - x / p),
       h2.fn = function(x, p) 1 / p * exp( - x / p),
       mu1.fn = function(x, p){ 
              exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                  pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                  log.p = TRUE))
       },
       mu2.fn = function(x, p){
             exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                 pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                 log.p = TRUE))
       },
       H1.fn = function(x, p) pexp(x, rate = 1 / p),
       H2.fn = function(x, p) pexp(x, rate = 1 / p),
       Mu1.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                   log.p = TRUE)
       },
       Mu2.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                    log.p = TRUE)
       })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mllMRH2_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the ten parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two renewal distributions, 
the two offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_mu1.fn">mu1.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type
one. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_mu2.fn">mu2.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type 
two. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_h1.fn">H1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_h2.fn">H2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_mu1.fn">Mu1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="mllMRH2_+3A_mu2.fn">Mu2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the MRHawkes point process Rosenblatt residuals
</p>


<h3>Value</h3>

<table>
<tr><td><code>mll</code></td>
<td>
<p>minus log-likelihood</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Rosenblatt residuals of observed event times</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mllMRH</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  n &lt;- 1000
  data &lt;- cbind(sort(runif(n,0,1000)), 
                sample(1:2, size = n, replace = TRUE))
  tmp &lt;- mllMRH2(data = data, cens = 1001, 
                 par = c(1,1,1,1,1,1,0.5,0.2,0.2,0.3))              
  pp &lt;- ppoints(n)
  par(mfrow=c(1,2))
  plot(quantile(tmp$W,prob=pp),pp,type="l",
       main="Uniform QQ plot",
       xlab="Sample quantiles",ylab="Theoretical quantiles")
  abline(a = 0, b = 1, col = 2)
  a &lt;- acf(tmp$W, main = "ACF Plot")
  ks.test(tmp$W,"punif")
  Box.test(tmp$W,lag=tail(a$lag,1))
  
</code></pre>

<hr>
<h2 id='MRHawkes-package'>
Multivariate Renewal Hawkes Process
</h2><span id='topic+MRHawkes'></span>

<h3>Description</h3>

<p>Simulate the (bivariate) multivariate renewal Hawkes (MRHawkes) process with 
a given distribution for the two waiting times between immigrants, given
offspring density functions, and also the branching ratios. Calculation of the
likelihood of a MRHawkes process model with a given sequence of
(distinct) event times and labels up to a censoring time. Calculate the
Rosenblatt residuals of fitting an MRHawkes process model to a sequence
of event times and labels. Calculate the (filtering) distribution of the 
index of the most recent immigrant. Predict the time of the next event 
since the censoring time. Predict event times from the censoring time to a
future time point. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MRHawkes</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Multivariate Renewal Hawkes Process</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-08-15</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Tom Stindl and Feng Chen</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Tom Stindl &lt;t.stindl@unsw.edu.au&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Simulate a (bivariate) multivariate renewal Hawkes (MRHawkes) 
    self-exciting process, with given immigrant hazard rate functions and 
    offspring density function. Calculate the likelihood of a MRHawkes process 
    with given hazard rate functions and offspring density function for an 
    (increasing) sequence of event times. Calculate the Rosenblatt residuals of the 
    event times. Predict future event times based on observed event times up to a 
    given time. For details see Stindl and Chen (2018) &lt;doi:10.1016/j.csda.2018.01.021&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> IHSEP, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2016-11-04 12:35:53 UTC; z3376311</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
MRHawkes                Multivariate Renewal Hawkes Process
TmllMRH                 Minus loglikelihood of an (bivariate) MRHawkes
                        model with truncated most recent immigrant
                        probabilities
fivaqks                 Fiji and Vanuatu Earthquake Data
mllMRH                  Minus loglikelihood of an (bivariate) MRHawkes
                        model
mllMRH1                 Minus loglikelihood of an (bivariate) MRHawkes
                        model with most recent immigrant probabilities
mllMRH2                 Minus loglikelihood of an (bivariate) MRHawkes
                        model with Rosenblatt residuals
predDen                 MRHawkes (bivariate) predictive density
                        function
simMRHawkes             Simulate an (bivariate) renewal Hawkes
                        (MRHawkes) process
simNSMHP                Simulate a (bivariate) non-stationary
                        multivariate Hawkes process (NSMHP)
simpred                 Simulate a fitted (bivariate) MRHawkes process
                        model
typeRes                 Minus loglikelihood of an (bivariate) MRHawkes
                        model with Universal residuals
</pre>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>References</h3>

<p>Chen, F. and Stindl, T. (2017). Direct Likelihood Evaluation for the Renewal
Hawkes Process. Journal of Computational and Graphical Statistics.
</p>
<p>Stindl, T. &amp; Chen, F. (2018). Likelihood based inference for the multivariate 
renewal Hawkes process. Computational Statistics and Data Analysis.
</p>
<p>Wheatley, S., Filimonov, V., and Sornette, D. (2016) The Hawkes process
with renewal immigration &amp; its  estimation with an EM
algorithm. Computational Statistics and Data Analysis. 94: 120-135.
</p>

<hr>
<h2 id='predDen'>
MRHawkes (bivariate) predictive density function
</h2><span id='topic+predDen'></span>

<h3>Description</h3>

<p>Calculates the predictive density of the next event time after the 
censoring time <code>cens</code> based on the observations over the interval 
<code>[0,cens]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predDen(x, data, cens, par, 
        h1.fn = function(x, p) 1 / p * exp( - x / p),
        h2.fn = function(x, p) 1 / p * exp( - x / p),
        mu1.fn = function(x, p){
          exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
               pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                        log.p = TRUE))
        },
        mu2.fn = function(x, p){
         exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
               pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                        log.p = TRUE))
        },
        H1.fn = function(x, p) pexp(x, rate = 1 / p),
        H2.fn = function(x, p) pexp(x, rate = 1 / p),
        Mu1.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                    log.p = TRUE)
        },
        Mu2.fn = function(x, p){
         - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                    log.p = TRUE)
        })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predDen_+3A_x">x</code></td>
<td>

<p>A scalar. The amount of time after the censoring tine <code>cens</code>.
</p>
</td></tr>
<tr><td><code id="predDen_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="predDen_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="predDen_+3A_par">par</code></td>
<td>

<p>A numeric vector containing the twelve parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two component distributions, 
the four offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="predDen_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_mu1.fn">mu1.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type
one. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_mu2.fn">mu2.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type 
two. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_h1.fn">H1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_h2.fn">H2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_mu1.fn">Mu1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="predDen_+3A_mu2.fn">Mu2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predictive density of the next event time evaluated at x.
</p>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Magnitude 5.5 or greater earthquakes over the 25 year period from 
  ## 01/01/1991 to 31/12/2015.  
  data(fivaqks); 
  near.fiji &lt;- grep("Fiji", fivaqks$place)
  near.vanuatu &lt;- grep("Vanuatu", fivaqks$place)
  t.beg &lt;- strptime("1991-01-01 00:00:00", "%Y-%m-%d %H:%M:%S", tz = "UTC")
  t.end &lt;- strptime("2015-12-31 23:59:59", "%Y-%m-%d %H:%M:%S", tz = "UTC")
  t0 &lt;- 0
  t1 &lt;- as.numeric(t.end - t.beg)
  tms &lt;- strptime(fivaqks$time, "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
  ts &lt;- as.numeric(tms[-1] - t.beg)
  ts &lt;- c(as.numeric(tms[1] - t.beg)/24, ts)
  ts.fi &lt;- ts[near.fiji]; ts.fi &lt;- ts.fi[ts.fi &gt;= 0 &amp; ts.fi &lt;= t1]
  ts.va &lt;- ts[near.vanuatu]; ts.va &lt;- ts.va[ts.va &gt;=0 &amp; ts.va &lt;= t1]
  ts.c &lt;- c(ts.fi, ts.va)
  z.c &lt;- c(rep(1, times = length(ts.fi)), rep(2, times = length(ts.va)))
  o &lt;- order(ts.c)
  data &lt;- cbind(ts.c[o], z.c[o])
  curve(predDen(x, data = data, cens = t1, 
                 par = c(0.488, 20.10, 0.347, 9.53, 461, 720, 
                         0.472, 0.293, 0.399, -0.0774)) 
        ,0 ,200, col = "red", lwd = 2, ylab = "Density")
  
</code></pre>

<hr>
<h2 id='simMRHawkes'>
Simulate an (bivariate) renewal Hawkes (MRHawkes) process
</h2><span id='topic+simMRHawkes'></span>

<h3>Description</h3>

<p>Simulate an (bivairate) renewal Hawkes (MRHawkes) process with given renewal 
immigration distribution functions <code class="reqn">\mu</code>, offspring density functions 
<code class="reqn">h</code> and branching ratios <code class="reqn">\eta</code> using the cascading structure of the 
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMRHawkes(re.dist1 = rweibull, par.redist1 = list(shape = 3, scale = 1.2), 
            re.dist2 = rweibull, par.redist2 = list(shape = 1/3, scale = 0.2), 
            h1.fn = function(x, p.h1) 1/p.h1 * exp(-x/p.h1), 
            h2.fn = function(x, p.h2) 1/p.h2 * exp(-x/p.h2), 
            p.h1 = 1, p.h2 = 1, 
            eta11 = 0.3, eta12 = 0.1, eta21 = 0.1, eta22 = 0.3, cens = 100, 
            B = 10, B0 = 50, 
            max.h1 = max(optimize(h1.fn, c(0, cens), maximum = TRUE, p = p.h1)$obj, 
                         h1.fn(0, p.h1), h1.fn(cens, p.h1)) * 1.1, 
            max.h2 = max(optimize(h2.fn, c(0, cens), maximum = TRUE, p = p.h2)$obj, 
                         h2.fn(0, p.h2), h2.fn(cens, p.h2)) * 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMRHawkes_+3A_re.dist1">re.dist1</code></td>
<td>

<p>The renewal distribution for type one events.
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_re.dist2">re.dist2</code></td>
<td>

<p>The renewal distribution for type two events.
</p>
</td></tr>  
<tr><td><code id="simMRHawkes_+3A_par.redist1">par.redist1</code></td>
<td>

<p>A numeric list. The parameters of the renewal distribution for type one 
events.
</p>
</td></tr> 
<tr><td><code id="simMRHawkes_+3A_par.redist2">par.redist2</code></td>
<td>

<p>A numeric list. The parameters of the renewal distribution for type two 
events.
</p>
</td></tr>   
<tr><td><code id="simMRHawkes_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events.    
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events.
</p>
</td></tr>   
<tr><td><code id="simMRHawkes_+3A_p.h1">p.h1</code></td>
<td>

<p>A numeric vector. The paramters of the offspring density for type one 
events.
</p>
</td></tr>  
<tr><td><code id="simMRHawkes_+3A_p.h2">p.h2</code></td>
<td>

<p>A numeric vector. The paramters of the offspring density for type two 
events.
</p>
</td></tr>    
<tr><td><code id="simMRHawkes_+3A_eta11">eta11</code></td>
<td>

<p>A numeric scalar. The self-exciting branching ratio for type one events.
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_eta12">eta12</code></td>
<td>

<p>A numeric scalar. The cross-exciting branching ratio for type one events due 
to the effects of a type two event.
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_eta21">eta21</code></td>
<td>

<p>A numeric scalar. The cross-exciting branching ratio for type two events due 
to the effects of a type one event.
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_eta22">eta22</code></td>
<td>

<p>A numeric scalar. The self-exciting branching ratio for type two events.
</p>
</td></tr>    
<tr><td><code id="simMRHawkes_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time. 
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_b">B</code></td>
<td>

<p>A numeric scalar. Tuning parameter
</p>
</td></tr>
<tr><td><code id="simMRHawkes_+3A_b0">B0</code></td>
<td>

<p>A numeric scalar. Tuning parameter
</p>
</td></tr> 
<tr><td><code id="simMRHawkes_+3A_max.h1">max.h1</code></td>
<td>

<p>A numeric scalar. The maximum value of the offspring density for 
type one events.
</p>
</td></tr>  
<tr><td><code id="simMRHawkes_+3A_max.h2">max.h2</code></td>
<td>

<p>A numeric scalar. The maximum value of the offspring density for 
type two events.
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>The function works by simulating the arrival times of immigrants
accoridng to the respective renewal immigration distribution for each event 
type. The birth times ofoffspring from each immigrant are then simulated 
according to an non-stationary multivariate Hawkes Process (NSMHP) with 
appropriate baseline and excitation functions.
</p>


<h3>Value</h3>

<p>A numeric matrix. The row coloumn contains the event times in ascending 
order while the second coloumn contains the corresponding event type.
</p>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- 10; i &lt;- 0;
  data &lt;- replicate(B, 
                    {cat(i&lt;&lt;-i+1,'\n'); 
                    simMRHawkes(re.dist1 = rweibull, 
                                par.redist1 = list(shape = 3, scale = 1.2),
                                re.dist2 = rweibull, 
                                par.redist2 = list(shape = 1 / 3, scale = 0.2),
                                p.h1 = 1, p.h2 = 1,
                                eta11 = 0.3, eta12 = 0.1, 
                                eta21 = 0.1, eta22 = 0.3,
                                cens = 100)
                    })
</code></pre>

<hr>
<h2 id='simNSMHP'>
Simulate a (bivariate) non-stationary multivariate Hawkes process (NSMHP)
</h2><span id='topic+simNSMHP'></span>

<h3>Description</h3>

<p>Simulate a bivariate non-stationary multivariate Hawkes process (NSMHP) with 
given given baseline intensity functions and self-excitation functions using 
the cascading structure of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNSMHP(TT = 100,
        nu1 = function(t) 0.6*exp(-t),
        nu2 = function(t) 0.2*exp(-t),
        g11 = function(t) 0.6*exp(-t),
        g12 = function(t) 0.2*exp(-t),
        g21 = function(t) 0.1*exp(-t),
        g22 = function(t) 0.5*exp(-t))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simNSMHP_+3A_tt">TT</code></td>
<td>

<p>A scalar. The censoring time. 
</p>
</td></tr>
<tr><td><code id="simNSMHP_+3A_nu1">nu1</code></td>
<td>

<p>Basline intensity function for type one events.
</p>
</td></tr>
<tr><td><code id="simNSMHP_+3A_nu2">nu2</code></td>
<td>

<p>Basline intensity function for type two events.
</p>
</td></tr>
<tr><td><code id="simNSMHP_+3A_g11">g11</code></td>
<td>

<p>Self-exciting function for type one events given the parent is a type two 
event.
</p>
</td></tr>
<tr><td><code id="simNSMHP_+3A_g12">g12</code></td>
<td>

<p>Cross-exciting function for type one events given the parent is a type two
event.
</p>
</td></tr>
<tr><td><code id="simNSMHP_+3A_g21">g21</code></td>
<td>

<p>Cross-exciting function for type two events given the parent is a type one
event.
</p>
</td></tr>
<tr><td><code id="simNSMHP_+3A_g22">g22</code></td>
<td>

<p>Self-exciting function for type two events given the parent is a type two
event.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by simulating generation 0 events according to independent
Poisson processes with the baseline intensity functions; then keep simulating 
future generation events as long as the number of the previous generation 
events of any type is non-zero. For each event type, we simulate these events
according to M independent Poisson processes with the appropriate excitation 
intensity. When this recursive process stops, return events of all generations 
with their respective type labels as the events of the NSMHP on the interval 
(0,T].
</p>


<h3>Value</h3>

<table>
<tr><td><code>offspr1</code></td>
<td>
<p>All offspring events of type one</p>
</td></tr>
<tr><td><code>offspr2</code></td>
<td>
<p>All offspring events of type two</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- 10; i &lt;- 0;
  data &lt;- replicate(B, 
                    {cat(i&lt;&lt;-i+1,'\n'); 
                    simNSMHP(TT = 100)
                    })
</code></pre>

<hr>
<h2 id='simpred'>
Simulate a fitted (bivariate) MRHawkes process model
</h2><span id='topic+simpred'></span>

<h3>Description</h3>

<p>Simulate a fitted bivariate MRHawkes process model after the censoring time 
<code>cens</code> to a future time point <code>cens.tilde</code> using the cascading 
structure of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  simpred(data, par, cens, cens.tilde, 
          re.dist1 = rweibull, 
          par.redist1 = list(shape = par[1], scale = par[2]),
          re.dist2 = rweibull, 
          par.redist2 = list(shape = par[3], scale = par[4]),
          h1.fn = function(x, p.h1) 1 / p.h1 * exp( - x / p.h1),
          h2.fn = function(x, p.h2) 1 / p.h2 * exp( - x / p.h2),
          p.h1 = par[5], p.h2 = par[6],
          eta11 = par[7], eta12 = par[8], eta21 = par[9], eta22 = par[10],
          B = 10, B0 = 50, pnp1 = NULL,
          max.h1 = max(optimize(h1.fn, c(0, cens.tilde - cens), maximum = TRUE,
                               p = p.h1)$obj, h1.fn(0, p.h1), 
                      h1.fn(cens.tilde - cens, p.h1)) * 1.1,
          max.h2 = max(optimize(h2.fn, c(0, cens.tilde - cens), maximum = TRUE,
                               p = p.h2)$obj, h2.fn(0, p.h2), 
                      h2.fn(cens.tilde - cens, p.h2)) * 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpred_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the ten parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two renewal distributions, 
the two offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_cens.tilde">cens.tilde</code></td>
<td>

<p>A scalar. The time that the simulation run uptil. 
</p>
</td></tr>
<tr><td><code id="simpred_+3A_re.dist1">re.dist1</code></td>
<td>

<p>The renewal distribution for type one events.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_re.dist2">re.dist2</code></td>
<td>

<p>The renewal distribution for type two events.
</p>
</td></tr>  
<tr><td><code id="simpred_+3A_par.redist1">par.redist1</code></td>
<td>

<p>A numeric list. The parameters of the renewal distribution for type one 
events.
</p>
</td></tr> 
<tr><td><code id="simpred_+3A_par.redist2">par.redist2</code></td>
<td>

<p>A numeric list. The parameters of the renewal distribution for type two 
events.
</p>
</td></tr>   
<tr><td><code id="simpred_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="simpred_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="simpred_+3A_p.h1">p.h1</code></td>
<td>

<p>A numeric vector. The paramters of the offspring density for type one 
events.
</p>
</td></tr>  
<tr><td><code id="simpred_+3A_p.h2">p.h2</code></td>
<td>

<p>A numeric vector. The paramters of the offspring density for type two 
events.
</p>
</td></tr>   
<tr><td><code id="simpred_+3A_eta11">eta11</code></td>
<td>

<p>A numeric scalar. The self-exciting branching ratio for type one events.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_eta12">eta12</code></td>
<td>

<p>A numeric scalar. The cross-exciting branching ratio for type one events due 
to the effects of a type two event.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_eta21">eta21</code></td>
<td>

<p>A numeric scalar. The cross-exciting branching ratio for type two events due 
to the effects of a type one event.
</p>
</td></tr>
<tr><td><code id="simpred_+3A_eta22">eta22</code></td>
<td>

<p>A numeric scalar. The self-exciting branching ratio for type two events.
</p>
</td></tr>    
<tr><td><code id="simpred_+3A_b">B</code></td>
<td>

<p>A numeric scalar. Tuning parameter
</p>
</td></tr>
<tr><td><code id="simpred_+3A_b0">B0</code></td>
<td>

<p>A numeric scalar. Tuning parameter
</p>
</td></tr>
<tr><td><code id="simpred_+3A_pnp1">pnp1</code></td>
<td>

<p>A numeric square matrix. The joint last immigrant probabilities. 
</p>
</td></tr>
<tr><td><code id="simpred_+3A_max.h1">max.h1</code></td>
<td>

<p>A numeric scalar. The maximum value of the offspring density for 
type one events.
</p>
</td></tr>  
<tr><td><code id="simpred_+3A_max.h2">max.h2</code></td>
<td>

<p>A numeric scalar. The maximum value of the offspring density for 
for type two events.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A numeric matrix that contains the simulated event times from censoring time 
<code>cens</code> up until <code>cens.tilde</code> and the corresponding event types.
</p>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
    ## Magnitude 5.5 or greater earthquakes over the 25 year period from 
    ## 01/01/1991 to 31/12/2015.
    data(fivaqks); 
    near.fiji &lt;- grep("Fiji", fivaqks$place)
    near.vanuatu &lt;- grep("Vanuatu", fivaqks$place)
    t.beg &lt;- strptime("1991-01-01 00:00:00", "%Y-%m-%d %H:%M:%S", tz = "UTC")
    t.end &lt;- strptime("2015-12-31 23:59:59", "%Y-%m-%d %H:%M:%S", tz = "UTC")
    t0 &lt;- 0
    t1 &lt;- as.numeric(t.end - t.beg)
    tms &lt;- strptime(fivaqks$time, "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
    ts &lt;- as.numeric(tms[-1] - t.beg)
    ts &lt;- c(as.numeric(tms[1] - t.beg)/24, ts)
    ts.fi &lt;- ts[near.fiji]; ts.fi &lt;- ts.fi[ts.fi &gt;= 0 &amp; ts.fi &lt;= t1]
    ts.va &lt;- ts[near.vanuatu]; ts.va &lt;- ts.va[ts.va &gt;=0 &amp; ts.va &lt;= t1]
    ts.c &lt;- c(ts.fi, ts.va)
    z.c &lt;- c(rep(1, times = length(ts.fi)), rep(2, times = length(ts.va)))
    o &lt;- order(ts.c)
    data &lt;- cbind(ts.c[o], z.c[o])
    # simulate future event time based on MLE fitted Rhawkes model
    N &lt;- 100; i &lt;- 0;
    data.pred &lt;- replicate(N, 
                          {cat(i&lt;&lt;-i+1,'\n'); 
                          simpred(data = data,
                                    par = c(0.488, 20.10, 0.347, 9.53, 
                                            461, 720,
                                            0.472, 0.293, 0.399, -0.0774), 
                                            cens = t1, cens.tilde = t1 + 1000)
                                            })
  
</code></pre>

<hr>
<h2 id='TmllMRH'>
Minus loglikelihood of an (bivariate) MRHawkes model with truncated most 
recent immigrant probabilities
</h2><span id='topic+TmllMRH'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an (bivariate) MRHawkes model with 
given immigration hazard functions <code class="reqn">\mu</code>, offspring density functions 
<code class="reqn">h</code> and bracnhing ratios <code class="reqn">\eta</code> for event times and event types 
<code>data</code> on interval <code class="reqn">[0,cens]</code> with truncated most recent immigrant 
probabilities looking back at only the previous <code>B</code> event times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TmllMRH(data, cens, par, B = 25,
        h1.fn = function(x, p) 1 / p * exp( - x / p),
        h2.fn = function(x, p) 1 / p * exp( - x / p),
        mu1.fn = function(x, p){ 
               exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                   pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                   log.p = TRUE))
        },
        mu2.fn = function(x, p){
              exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                  pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                  log.p = TRUE))
        },
        H1.fn = function(x, p) pexp(x, rate = 1 / p),
        H2.fn = function(x, p) pexp(x, rate = 1 / p),
        Mu1.fn = function(x, p){
          - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                    log.p = TRUE)
        },
        Mu2.fn = function(x, p){
          - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                     log.p = TRUE)
        })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TmllMRH_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the ten parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two renewal distributions, 
the two offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_b">B</code></td>
<td>

<p>A scalar. The number of previous events that are considered to be possible
last immigrant arrivals.
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_mu1.fn">mu1.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type
one. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_mu2.fn">mu2.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type 
two. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_h1.fn">H1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_h2.fn">H2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_mu1.fn">Mu1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="TmllMRH_+3A_mu2.fn">Mu2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the negative log-liklihood. 
</p>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Magnitude 5.5 or greater earthquakes over the 25 year period from 
  ## 01/01/1991 to 31/12/2015.
  data(fivaqks); 
  near.fiji &lt;- grep("Fiji", fivaqks$place)
  near.vanuatu &lt;- grep("Vanuatu", fivaqks$place)
  t.beg &lt;- strptime("1991-01-01 00:00:00", "%Y-%m-%d %H:%M:%S", tz = "UTC")
  t.end &lt;- strptime("2015-12-31 23:59:59", "%Y-%m-%d %H:%M:%S", tz = "UTC")
  t0 &lt;- 0
  t1 &lt;- as.numeric(t.end - t.beg)
  tms &lt;- strptime(fivaqks$time, "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
  ts &lt;- as.numeric(tms[-1] - t.beg)
  ts &lt;- c(as.numeric(tms[1] - t.beg)/24, ts)
  ts.fi &lt;- ts[near.fiji]; ts.fi &lt;- ts.fi[ts.fi &gt;= 0 &amp; ts.fi &lt;= t1]
  ts.va &lt;- ts[near.vanuatu]; ts.va &lt;- ts.va[ts.va &gt;=0 &amp; ts.va &lt;= t1]
  ts.c &lt;- c(ts.fi, ts.va)
  z.c &lt;- c(rep(1, times = length(ts.fi)), rep(2, times = length(ts.va)))
  o &lt;- order(ts.c)
  data &lt;- cbind(ts.c[o], z.c[o])
  
  ## calculate the minus loglikelihood of an (bivariate) MRHawkes with some 
  ## parameters the default hazard functions and density functions are Weibull 
  ## and exponential respectivley
  TmllMRH(data, cens = t1, par = c(0.488, 20.10, 0.347, 9.53, 461, 720,
                                  0.472, 0.293, 0.399, -0.0774), B = 200)
                                  
  ## calculate the MLE for the parameter assuming known parametric forms
  ## of the immigrant hazard function and offspring density functions.  
  
    system.time(est &lt;- optim(c(0.488, 20.10, 0.347, 9.53, 461, 720,
                                  0.472, 0.293, 0.399, -0.0774), 
                             TmllMRH, data = data, cens = t1, B = 200,
                             control = list(maxit = 5000, trace = TRUE),
                             hessian = TRUE)
    )
    ## point estimate by MLE
    est$par
    ## standard error estimates:
    diag(solve(est$hessian))^0.5
  
</code></pre>

<hr>
<h2 id='typeRes'>
Minus loglikelihood of an (bivariate) MRHawkes model with Universal 
residuals
</h2><span id='topic+typeRes'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of an (bivariate) RHawkes model with 
given immigration hazard functions <code class="reqn">\mu</code>, common offspring density 
functions <code class="reqn">h</code> and bracnhing ratios <code class="reqn">\eta</code> for event times and 
event types <code>data</code> on interval <code class="reqn">[0,cens]</code>. The same as 
<code>mllMRH</code> although this version also returns the Universal residuals 
for goodness-of-fit assessment of the event types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  typeRes(data, cens, par, U = runif(length(data[,1])),
          h1.fn = function(x, p) 1 / p * exp( - x / p),
          h2.fn = function(x, p) 1 / p * exp( - x / p),
          mu1.fn = function(x, p){ 
            exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                  pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                           log.p = TRUE))
          },
          mu2.fn = function(x, p){
            exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
                  pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                           log.p = TRUE))
          },
          H1.fn = function(x, p) pexp(x, rate = 1 / p),
          H2.fn = function(x, p) pexp(x, rate = 1 / p),
          Mu1.fn = function(x, p){
            - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                       log.p = TRUE)
          },
          Mu2.fn = function(x, p){
            - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, 
                       log.p = TRUE)
          })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typeRes_+3A_data">data</code></td>
<td>

<p>A two column matrix. The first column contains the event times sorted in 
ascending order. The second column contains the corresponding event type
with the label one or two.
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the ten parameters of the model, in order of 
the immigration parameters <code class="reqn">\mu(.)</code> for the two renewal distributions, 
the two offspring parameters <code class="reqn">h(.)</code> and lastly the four branching 
ratios <code class="reqn">\eta</code>.
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_u">U</code></td>
<td>

<p>A numeric vector. Contains auxillary uniform random varables on the unit 
interval.
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_h1.fn">h1.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type one 
events. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_h2.fn">h2.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function for type two 
events. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_mu1.fn">mu1.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type
one. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_mu2.fn">mu2.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function for events of type 
two. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_h1.fn">H1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_h2.fn">H2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_mu1.fn">Mu1.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type one events. 
</p>
</td></tr>
<tr><td><code id="typeRes_+3A_mu2.fn">Mu2.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code> for type two events. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the MRHawkes point process Universal residuals
</p>


<h3>Value</h3>

<table>
<tr><td><code>mll</code></td>
<td>
<p>minus log-likelihood</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>Universal residuals of observed event types</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code>mllMRH</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  n &lt;- 1000
  data &lt;- cbind(sort(runif(n,0,1000)), 
                sample(1:2, size = n, replace = TRUE))
  tmp &lt;- typeRes(data = data, cens = 1001, 
                 par = c(1,1,1,1,1,1,0.5,0.2,0.2,0.3))              
  pp &lt;- ppoints(n)
  par(mfrow=c(1,2))
  plot(quantile(tmp$V,prob=pp),pp,type="l",
       main="Uniform QQ plot",
       xlab="Sample quantiles",ylab="Theoretical quantiles")
  abline(a = 0, b = 1, col = 2)
  a &lt;- acf(tmp$V, main = "ACF Plot")
  ks.test(tmp$V,"punif")
  Box.test(tmp$V,lag=tail(a$lag,1))
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
