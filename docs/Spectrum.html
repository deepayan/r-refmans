<!DOCTYPE html><html><head><title>Help for package Spectrum</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Spectrum}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blobs'><p>8 blob like structures</p></a></li>
<li><a href='#brain'><p>A brain cancer dataset</p></a></li>
<li><a href='#circles'><p>Three concentric circles</p></a></li>
<li><a href='#cluster_similarity'><p>cluster_similarity: cluster a similarity matrix using the Ng method</p></a></li>
<li><a href='#CNN_kernel'><p>CNN_kernel: fast adaptive density-aware kernel</p></a></li>
<li><a href='#estimate_k'><p>estimate_k: estimate K using the eigengap or multimodality gap heuristics</p></a></li>
<li><a href='#harmonise_ids'><p>harmonise_ids: works on a list of similarity matrices to add entries of NA where</p>
there are missing observations between views</a></li>
<li><a href='#integrate_similarity_matrices'><p>integrate_similarity_matrices: integrate similarity matrices using a tensor product graph</p>
linear combination and diffusion technique</a></li>
<li><a href='#kernel_pca'><p>kernel_pca: A kernel pca function</p></a></li>
<li><a href='#mean_imputation'><p>mean_imputation: mean imputation function for multi-view spectral clustering</p>
with missing data</a></li>
<li><a href='#missl'><p>A list of the blob data as similarity matrices with</p>
a missing entry in one</a></li>
<li><a href='#misslfilled'><p>A list of the blob data as similarity matrices with</p>
a missing entry in one filled with NAs</a></li>
<li><a href='#ng_kernel'><p>ng_kernel: Kernel from the Ng spectral clustering algorithm</p></a></li>
<li><a href='#pca'><p>pca: A pca function</p></a></li>
<li><a href='#rbfkernel_b'><p>rbfkernel_b: fast self-tuning kernel</p></a></li>
<li><a href='#sigma_finder'><p>sigma_finder: heuristic to find sigma for the Ng kernel</p></a></li>
<li><a href='#Spectrum'><p>Spectrum: Fast Adaptive Spectral Clustering for Single and Multi-view Data</p></a></li>
<li><a href='#spirals'><p>Two spirals wrapped around one another</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Adaptive Spectral Clustering for Single and Multi-View Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher R John, David Watson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher R John &lt;chris.r.john86@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A self-tuning spectral clustering method for single or multi-view data. 'Spectrum' uses a new type of adaptive density aware kernel that strengthens connections in the graph based on common nearest neighbours. It uses a tensor product graph data integration and diffusion procedure to integrate different data sources and reduce noise. 'Spectrum' uses either the eigengap or multimodality gap heuristics to determine the number of clusters. The method is sufficiently flexible so that a wide range of Gaussian and non-Gaussian structures can be clustered with automatic selection of K.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, ClusterR, Rfast, diptest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-10 08:16:36 UTC; christopher</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-10 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blobs'>8 blob like structures</h2><span id='topic+blobs'></span>

<h3>Description</h3>

<p>A simulated dataset of 8 Gaussian blobs. Simulated using 
the 'clusterlab' CRAN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blobs
</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and 800 variables</p>

<hr>
<h2 id='brain'>A brain cancer dataset</h2><span id='topic+brain'></span>

<h3>Description</h3>

<p>A dataset containing The Cancer Genome Atlas expression
data. From this publication https://tcga-data.nci.nih.gov/docs/publications/lgggbm_2016/.
The first data frame is a 5133X150 RNA-seq data matrix, the second is a 262X150
miRNA-seq data matrix, the third is 45X150 protein array data matrix. The data was
all pre-normalised then subject to log transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brain
</code></pre>


<h3>Format</h3>

<p>A list of data frames</p>


<h3>Source</h3>

<p><a href="https://gdac.broadinstitute.org/">https://gdac.broadinstitute.org/</a>
</p>

<hr>
<h2 id='circles'>Three concentric circles</h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>Simulated data using the 'clusterSim' CRAN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 rows and 540 variables</p>

<hr>
<h2 id='cluster_similarity'>cluster_similarity: cluster a similarity matrix using the Ng method</h2><span id='topic+cluster_similarity'></span>

<h3>Description</h3>

<p>This function performs clustering of a similarity matrix following the method
of Ng or of Melia. We recommend using the Ng method with GMM to cluster the 
eigenvectors instead of k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_similarity(A2, k = k, clusteralg = "GMM", specalg = "Ng")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_similarity_+3A_a2">A2</code></td>
<td>
<p>Data frame or matrix: a similarity matrix</p>
</td></tr>
<tr><td><code id="cluster_similarity_+3A_k">k</code></td>
<td>
<p>Numerical value: the number of clusters</p>
</td></tr>
<tr><td><code id="cluster_similarity_+3A_clusteralg">clusteralg</code></td>
<td>
<p>Character value: GMM or km clustering algorithm (suggested=GMM)</p>
</td></tr>
<tr><td><code id="cluster_similarity_+3A_specalg">specalg</code></td>
<td>
<p>Character value: Ng or Melia variant of spectral clustering (default=Ng)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of cluster assignments
</p>


<h3>References</h3>

<p>Ng, Andrew Y., Michael I. Jordan, and Yair Weiss. &quot;On spectral clustering: 
Analysis and an algorithm.&quot; Advances in neural information processing systems. 2002.
</p>
<p>Meila, Marina, et al. &quot;Spectral Clustering: a Tutorial for the 2010â€™s.&quot; Handbook 
of Cluster Analysis. CRC Press, 2016. 1-23.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ng_similarity &lt;- cluster_similarity(missl[[1]],k=8)
</code></pre>

<hr>
<h2 id='CNN_kernel'>CNN_kernel: fast adaptive density-aware kernel</h2><span id='topic+CNN_kernel'></span>

<h3>Description</h3>

<p>CNN_kernel: fast adaptive density-aware kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CNN_kernel(mat, NN = 3, NN2 = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CNN_kernel_+3A_mat">mat</code></td>
<td>
<p>Matrix: matrix should have samples as columns and rows as features</p>
</td></tr>
<tr><td><code id="CNN_kernel_+3A_nn">NN</code></td>
<td>
<p>Numerical value: the number of nearest neighbours to use when calculating local sigma</p>
</td></tr>
<tr><td><code id="CNN_kernel_+3A_nn2">NN2</code></td>
<td>
<p>Numerical value: the number of nearest neighbours to use when calculating common nearest neighbours</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kernel matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CNN_kern &lt;- CNN_kernel(blobs[,1:50])
</code></pre>

<hr>
<h2 id='estimate_k'>estimate_k: estimate K using the eigengap or multimodality gap heuristics</h2><span id='topic+estimate_k'></span>

<h3>Description</h3>

<p>This function will try to estimate K given a similarity matrix. Generally the
maximum eigengap is preferred, but on some data examining the distribution
of the eigenvectors as in the multimodality gap heuristic may be beneficial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_k(A2, maxk = 10, showplots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_k_+3A_a2">A2</code></td>
<td>
<p>Data frame or matrix: a similarity matrix</p>
</td></tr>
<tr><td><code id="estimate_k_+3A_maxk">maxk</code></td>
<td>
<p>Numerical value: maximum number of K to be considered</p>
</td></tr>
<tr><td><code id="estimate_k_+3A_showplots">showplots</code></td>
<td>
<p>Character value: whether to show the plot on the screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the eigenvalues and dip-test statistics of the 
eigenvectors of the graph Laplacian
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k_test &lt;- estimate_k(missl[[1]])
</code></pre>

<hr>
<h2 id='harmonise_ids'>harmonise_ids: works on a list of similarity matrices to add entries of NA where
there are missing observations between views</h2><span id='topic+harmonise_ids'></span>

<h3>Description</h3>

<p>Simply adds a column and row of NA with the missing ID for data imputation. The
similarity matrix requires row and column IDs present for this to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonise_ids(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonise_ids_+3A_l">l</code></td>
<td>
<p>A list of similarity matrices: those to be harmonised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of harmonised similarity matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h_test &lt;- harmonise_ids(missl) 
</code></pre>

<hr>
<h2 id='integrate_similarity_matrices'>integrate_similarity_matrices: integrate similarity matrices using a tensor product graph
linear combination and diffusion technique</h2><span id='topic+integrate_similarity_matrices'></span>

<h3>Description</h3>

<p>Given a list of similarity matrices this function will integrate them running
the Shu algorithm, also can reduce noise if the input is a list consisting of
a single matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_similarity_matrices(kernellist, KNNs_p = 10,
  diffusion_iters = 4, method = "TPG")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_similarity_matrices_+3A_kernellist">kernellist</code></td>
<td>
<p>A list of similarity matrices: those to be integrated</p>
</td></tr>
<tr><td><code id="integrate_similarity_matrices_+3A_knns_p">KNNs_p</code></td>
<td>
<p>Numerical value: number of nearest neighbours for KNN graph (default=10, suggested=10-20)</p>
</td></tr>
<tr><td><code id="integrate_similarity_matrices_+3A_diffusion_iters">diffusion_iters</code></td>
<td>
<p>Numerical value: number of iterations for graph diffusion (default=4, suggested=2-6)</p>
</td></tr>
<tr><td><code id="integrate_similarity_matrices_+3A_method">method</code></td>
<td>
<p>Character: either TPG (see reference below) or mean (default=TPG)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integrated similarity matrix
</p>


<h3>References</h3>

<p>Shu, Le, and Longin Jan Latecki. &quot;Integration of single-view graphs with 
diffusion of tensor product graphs for multi-view spectral clustering.&quot; Asian Conference 
on Machine Learning. 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i_test &lt;- integrate_similarity_matrices(misslfilled,method='mean')
</code></pre>

<hr>
<h2 id='kernel_pca'>kernel_pca: A kernel pca function</h2><span id='topic+kernel_pca'></span>

<h3>Description</h3>

<p>kernel_pca: A kernel pca function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_pca(datam, labels = FALSE, axistextsize = 18,
  legendtextsize = 18, dotsize = 3, similarity = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_pca_+3A_datam">datam</code></td>
<td>
<p>Dataframe or matrix: a data frame with samples as columns, rows as features, or a kernel matrix</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_labels">labels</code></td>
<td>
<p>Factor: to label the plot with colours</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_axistextsize">axistextsize</code></td>
<td>
<p>Numerical value: axis text size</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_legendtextsize">legendtextsize</code></td>
<td>
<p>Numerical value: legend text size</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_dotsize">dotsize</code></td>
<td>
<p>Numerical value: dot size</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_similarity">similarity</code></td>
<td>
<p>Logical flag: whether the input is a similarity matrix or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kernel PCA plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex_kernel_pca &lt;- kernel_pca(blobs[,1:50], similarity=FALSE)
</code></pre>

<hr>
<h2 id='mean_imputation'>mean_imputation: mean imputation function for multi-view spectral clustering
with missing data</h2><span id='topic+mean_imputation'></span>

<h3>Description</h3>

<p>Works on a list of similarity matrices to impute missing values using the mean 
from the other views.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_imputation(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_imputation_+3A_l">l</code></td>
<td>
<p>A list of data frames: all those to be included in the imputation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of completed data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m_test &lt;- mean_imputation(misslfilled)
</code></pre>

<hr>
<h2 id='missl'>A list of the blob data as similarity matrices with
a missing entry in one</h2><span id='topic+missl'></span>

<h3>Description</h3>

<p>Two copies of a simulated dataset of 8 Gaussian blobs in a 
list converted to a similarity matrix, but one has a 
missing observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missl
</code></pre>


<h3>Format</h3>

<p>A list of two data frames</p>

<hr>
<h2 id='misslfilled'>A list of the blob data as similarity matrices with
a missing entry in one filled with NAs</h2><span id='topic+misslfilled'></span>

<h3>Description</h3>

<p>Two copies of a simulated dataset of 8 Gaussian blobs in a 
list converted to a similarity matrix, but one has a 
missing observation filled with NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>misslfilled
</code></pre>


<h3>Format</h3>

<p>A list of two data frames</p>

<hr>
<h2 id='ng_kernel'>ng_kernel: Kernel from the Ng spectral clustering algorithm</h2><span id='topic+ng_kernel'></span>

<h3>Description</h3>

<p>This is the kernel from the Ng spectral clustering algorithm. It takes a global
sigma which requires tuning for new datasets in most cases. It is possible to use
the sigma_finder function to find a sigma for a dataset. Sigma is assumed to be
squared already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ng_kernel(data, sigma = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ng_kernel_+3A_data">data</code></td>
<td>
<p>Data frame or matrix: with points as columns, features as rows</p>
</td></tr>
<tr><td><code id="ng_kernel_+3A_sigma">sigma</code></td>
<td>
<p>Numerical value: a global sigma that controls the drop off in affinity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A similarity matrix of the input data
</p>


<h3>References</h3>

<p>Ng, Andrew Y., Michael I. Jordan, and Yair Weiss. &quot;On spectral clustering: 
Analysis and an algorithm.&quot; Advances in neural information processing systems. 2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ng_similarity &lt;- ng_kernel(brain[[1]])
</code></pre>

<hr>
<h2 id='pca'>pca: A pca function</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>pca: A pca function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(mydata, labels = FALSE, dotsize = 3, axistextsize = 18,
  legendtextsize = 18)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_mydata">mydata</code></td>
<td>
<p>Data frame or matrix: matrix or data frame with samples as columns, features as rows</p>
</td></tr>
<tr><td><code id="pca_+3A_labels">labels</code></td>
<td>
<p>Factor: to label the plot with colours</p>
</td></tr>
<tr><td><code id="pca_+3A_dotsize">dotsize</code></td>
<td>
<p>Numerical value: dot size</p>
</td></tr>
<tr><td><code id="pca_+3A_axistextsize">axistextsize</code></td>
<td>
<p>Numerical value: axis text size</p>
</td></tr>
<tr><td><code id="pca_+3A_legendtextsize">legendtextsize</code></td>
<td>
<p>Numerical value: legend text size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pca plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex_pca &lt;- pca(blobs[,1:50])
</code></pre>

<hr>
<h2 id='rbfkernel_b'>rbfkernel_b: fast self-tuning kernel</h2><span id='topic+rbfkernel_b'></span>

<h3>Description</h3>

<p>rbfkernel_b: fast self-tuning kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbfkernel_b(mat, K = 3, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbfkernel_b_+3A_mat">mat</code></td>
<td>
<p>Matrix: matrix should have samples as columns and rows as features</p>
</td></tr>
<tr><td><code id="rbfkernel_b_+3A_k">K</code></td>
<td>
<p>Numerical value: the number of nearest neighbours to use when calculating local sigma</p>
</td></tr>
<tr><td><code id="rbfkernel_b_+3A_sigma">sigma</code></td>
<td>
<p>Numerical value: a global sigma, usually left to 1 which has no effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kernel matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stsc_kern &lt;- rbfkernel_b(blobs[,1:50])
</code></pre>

<hr>
<h2 id='sigma_finder'>sigma_finder: heuristic to find sigma for the Ng kernel</h2><span id='topic+sigma_finder'></span>

<h3>Description</h3>

<p>This is a heuristic to find the sigma for the kernel from the Ng spectral clustering algorithm. 
It returns a global sigma. It uses the mean K nearest neighbour distances of all samples to
determine sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_finder(mat, NN = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma_finder_+3A_mat">mat</code></td>
<td>
<p>Data frame or matrix: with points as columns, features as rows</p>
</td></tr>
<tr><td><code id="sigma_finder_+3A_nn">NN</code></td>
<td>
<p>Numerical value: the number of nearest neighbours to use (default=3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A global sigma
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sig &lt;- sigma_finder(blobs)
</code></pre>

<hr>
<h2 id='Spectrum'>Spectrum: Fast Adaptive Spectral Clustering for Single and Multi-view Data</h2><span id='topic+Spectrum'></span>

<h3>Description</h3>

<p>Spectrum is a self-tuning spectral clustering method for single or multi-view data. Spectrum uses a new type of adaptive
density-aware kernel that strengthens connections between points that share common nearest neighbours in the graph. 
For integrating multi-view data and reducing noise a tensor product graph data integration and diffusion procedure is used. 
Spectrum analyses eigenvector variance or distribution to determine the number of clusters. Spectrum is well suited for a wide 
range of data, including both Gaussian and non-Gaussian structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spectrum(data, method = 1, silent = FALSE, showres = TRUE,
  diffusion = TRUE, kerneltype = c("density", "stsc"), maxk = 10,
  NN = 3, NN2 = 7, showpca = FALSE, frac = 2, thresh = 7,
  fontsize = 18, dotsize = 3, tunekernel = FALSE,
  clusteralg = "GMM", FASP = FALSE, FASPk = NULL, fixk = NULL,
  krangemax = 10, runrange = FALSE, diffusion_iters = 4,
  KNNs_p = 10, missing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spectrum_+3A_data">data</code></td>
<td>
<p>Data frame or list of data frames: contains the data with points to cluster as columns and rows as features. For multi-view data a list of dataframes is to be supplied with the samples in the same order.</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_method">method</code></td>
<td>
<p>Numerical value: 1 = default eigengap method (Gaussian clusters), 2 = multimodality gap method (Gaussian/ non-Gaussian clusters), 3 = no automatic method (see fixk param)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_silent">silent</code></td>
<td>
<p>Logical flag: whether to turn off messages</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_showres">showres</code></td>
<td>
<p>Logical flag: whether to show the results on the screen</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_diffusion">diffusion</code></td>
<td>
<p>Logical flag: whether to perform graph diffusion to reduce noise (default=TRUE)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_kerneltype">kerneltype</code></td>
<td>
<p>Character string: 'density' (default) = adaptive density aware kernel, 'stsc' = Zelnik-Manor self-tuning kernel</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_maxk">maxk</code></td>
<td>
<p>Numerical value: the maximum number of expected clusters (default=10). This is data dependent, do not set excessively high.</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_nn">NN</code></td>
<td>
<p>Numerical value: kernel param, the number of nearest neighbours to use sigma parameters (default=3)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_nn2">NN2</code></td>
<td>
<p>Numerical value: kernel param, the number of nearest neighbours to use for the common nearest neigbours (default = 7)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_showpca">showpca</code></td>
<td>
<p>Logical flag: whether to show pca when running on one view</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_frac">frac</code></td>
<td>
<p>Numerical value: optk search param, fraction to find the last substantial drop (multimodality gap method param)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_thresh">thresh</code></td>
<td>
<p>Numerical value: optk search param, how many points ahead to keep searching (multimodality gap method param)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_fontsize">fontsize</code></td>
<td>
<p>Numerical value: controls font size of the ggplot2 plots</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_dotsize">dotsize</code></td>
<td>
<p>Numerical value: controls the dot size of the ggplot2 plots</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_tunekernel">tunekernel</code></td>
<td>
<p>Logical flag: whether to tune the kernel, only applies for method 2 (default=FALSE)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_clusteralg">clusteralg</code></td>
<td>
<p>Character string: clustering algorithm for eigenvector matrix (GMM or km)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_fasp">FASP</code></td>
<td>
<p>Logical flag: whether to use Fast Approximate Spectral Clustering (for v. high sample numbers)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_faspk">FASPk</code></td>
<td>
<p>Numerical value: the number of centroids to compute when doing FASP</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_fixk">fixk</code></td>
<td>
<p>Numerical value: if we are just performing spectral clustering without automatic selection of K, set this parameter and method to 3</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_krangemax">krangemax</code></td>
<td>
<p>Numerical value: the maximum K value to iterate towards when running a range of K</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_runrange">runrange</code></td>
<td>
<p>Logical flag: whether to run a range of K or not (default=FALSE), puts Kth results into Kth element of list</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_diffusion_iters">diffusion_iters</code></td>
<td>
<p>Numerical value: number of diffusion iterations for the graph (default=4)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_knns_p">KNNs_p</code></td>
<td>
<p>Numerical value: number of KNNs when making KNN graph (default=10, suggested=10-20)</p>
</td></tr>
<tr><td><code id="Spectrum_+3A_missing">missing</code></td>
<td>
<p>Logical flag: whether to impute missing data in multi-view analysis (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing: 
1) cluster assignments, in the same order as input data columns 
2) eigenvector analysis results (either eigenvalues or dip test statistics)
3) optimal K
4) final similarity matrix
5) eigenvectors and eigenvalues of graph Laplacian
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- Spectrum(brain[[1]][,1:50])
</code></pre>

<hr>
<h2 id='spirals'>Two spirals wrapped around one another</h2><span id='topic+spirals'></span>

<h3>Description</h3>

<p>Simulated data using the 'mlbench' CRAN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spirals
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 rows and 180 variables</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
