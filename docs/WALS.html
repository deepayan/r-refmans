<!DOCTYPE html><html><head><title>Help for package WALS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WALS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkSingularitySVD'><p>Internal function: Check singularity of SVDed matrix</p></a></li>
<li><a href='#computeGamma1'><p>Internal function: Compute model-averaged estimator of focus regressors in walsNB</p></a></li>
<li><a href='#computeGamma1r'><p>Internal function: Computes fully restricted one-step ML estimator for</p>
transformed regressors in walsNB</a></li>
<li><a href='#computeGammaUnSVD'><p>Internal function: Computes unrestricted one-step ML estimator for transformed</p>
regressors in walsNB</a></li>
<li><a href='#computePosterior'><p>Internal function: Compute posterior mean and variance of normal location problem</p></a></li>
<li><a href='#computeX2M1X2'><p>Internal function: Computes X2M1X2 for walsNB when SVD is applied to Z1</p></a></li>
<li><a href='#controlGLM'><p>Control function for initial GLM fit</p></a></li>
<li><a href='#controlNB'><p>Control function for initial NB fit</p></a></li>
<li><a href='#ddweibull'><p>Internal function: double (reflected) Weibull density</p></a></li>
<li><a href='#dlaplace'><p>Internal function: Laplace density</p></a></li>
<li><a href='#dsubbotin'><p>Internal function: Subbotin density</p></a></li>
<li><a href='#familyPrior'><p>Family Objects for Prior Distributions in WALS</p></a></li>
<li><a href='#familyWALS'><p>Extended Family Objects for Models</p></a></li>
<li><a href='#fitNB2'><p>Internal function: Fits a NB2 regression via maximum likelihood with log-link</p>
for mean and dispersion parameter.</a></li>
<li><a href='#gammaToBeta'><p>Internal function: Transform gammas back to betas</p></a></li>
<li><a href='#GrowthMP'><p>Determinants of Economic Growth</p></a></li>
<li><a href='#GrowthMPP'><p>Determinants of Economic Growth</p></a></li>
<li><a href='#negativeBinomial'><p>Negative binomial family</p></a></li>
<li><a href='#predict.wals'><p>Methods for wals and walsMatrix Objects</p></a></li>
<li><a href='#predict.walsGLM'><p>Methods for walsGLM, walsGLMmatrix, walsNB and walsNBmatrix Objects</p></a></li>
<li><a href='#predictCounts'><p>Internal methods: Predict probability for counts</p></a></li>
<li><a href='#semiorthogonalize'><p>Internal function: Semiorthogonal-type transformation of X2 to Z2</p></a></li>
<li><a href='#snbinom'><p>Internal function: first derivatives of NB2 PMF</p></a></li>
<li><a href='#svdLSplus'><p>Internal function: Uses SVD components to compute final estimate via</p>
Sherman-Morrison-Woodbury formula.</a></li>
<li><a href='#vcov.walsNB'><p>Calculate Variance-Covariance Matrix for a <code>"walsNB"</code> object</p></a></li>
<li><a href='#wals'><p>Weighted-Average Least Squares for linear regression models</p></a></li>
<li><a href='#walsFit'><p>Fitter function for Weighted Average Least Squares estimation</p></a></li>
<li><a href='#walsGLM'><p>Weighted Average Least Squares for Generalized Linear Models</p></a></li>
<li><a href='#walsGLMfit'><p>Fitter function for Weighted Average Least Squares estimation of GLMs</p></a></li>
<li><a href='#walsGLMfitIterate'><p>Iteratively fitting walsGLM, internal function for walsGLM.formula and</p>
walsGLM.matrix.</a></li>
<li><a href='#walsNB'><p>Weighted-Average Least Squares for Negative Binomial Regression</p></a></li>
<li><a href='#walsNBfit'><p>Fitter function for Weighted Average Least Squares estimation of NB2 regression model</p></a></li>
<li><a href='#walsNBfitIterate'><p>Iteratively fitting walsNB, internal function for walsNB.formula and</p>
walsNB.matrix.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted-Average Least Squares Model Averaging</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula (&ge; 1.2-3), MASS (&ge; 7.3-51.6), methods, Rdpack(&ge;
2.1.3), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, BayesVarSel, BMS, testthat (&ge; 3.1.10)</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Weighted-Average Least Squares model averaging
    for negative binomial regression models of Huynh (2023) (mimeo),
    generalized linear models of De Luca, Magnus, Peracchi (2018) 
    &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>&gt; and linear regression models of 
    Magnus, Powell, Pruefer (2010) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2009.07.004">doi:10.1016/j.jeconom.2009.07.004</a>&gt;, see also 
    Magnus, De Luca (2016) &lt;<a href="https://doi.org/10.1111%2Fjoes.12094">doi:10.1111/joes.12094</a>&gt;. Weighted-Average Least Squares
    for the linear regression model is based on the original 'MATLAB' code by 
    Magnus and De Luca <a href="https://www.janmagnus.nl/items/WALS.pdf">https://www.janmagnus.nl/items/WALS.pdf</a>, see also 
    Kumar, Magnus (2013) &lt;<a href="https://doi.org/10.1007%2Fs13571-013-0060-9">doi:10.1007/s13571-013-0060-9</a>&gt; and 
    De Luca, Magnus (2011) &lt;<a href="https://doi.org/10.1177%2F1536867X1201100402">doi:10.1177/1536867X1201100402</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kevhuy/WALS">https://github.com/kevhuy/WALS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kevhuy/WALS/issues">https://github.com/kevhuy/WALS/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 22:09:03 UTC; kevin</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Huynh <a href="https://orcid.org/0000-0002-4621-2274"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Huynh &lt;Kevin.Huynh@unibas.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-03 07:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkSingularitySVD'>Internal function: Check singularity of SVDed matrix</h2><span id='topic+checkSingularitySVD'></span>

<h3>Description</h3>

<p>Checks whether matrix is singular based on singular values of SVD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSingularitySVD(singularValues, tol, rtol, digits = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSingularitySVD_+3A_singularvalues">singularValues</code></td>
<td>
<p>Vector of singular values.</p>
</td></tr>
<tr><td><code id="checkSingularitySVD_+3A_tol">tol</code></td>
<td>
<p>Absolute tolerance, singular if <code>min(singularValues) &lt; tol</code></p>
</td></tr>
<tr><td><code id="checkSingularitySVD_+3A_rtol">rtol</code></td>
<td>
<p>Relative tolerance, singular if
<code>min(singularValues) / max(singularValues) &lt; rtol</code></p>
</td></tr>
<tr><td><code id="checkSingularitySVD_+3A_digits">digits</code></td>
<td>
<p>The number significant digits to show in case a
warning is triggered by singularity.</p>
</td></tr>
</table>

<hr>
<h2 id='computeGamma1'>Internal function: Compute model-averaged estimator of focus regressors in walsNB</h2><span id='topic+computeGamma1'></span>

<h3>Description</h3>

<p>Exploits the SVD of the design matrix of the focus regressors <code class="reqn">\bar{Z}_1</code>,
the model-averaged estimator for the auxiliary regressors
<code class="reqn">\hat{\gamma}_{2}</code> and the Sherman-Morrison-Woodbury
formula for computing the model-averaged estimator of the focus regressors
in walsNB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGamma1(
  gamma2,
  Z2start,
  Z2,
  U,
  V,
  singularVals,
  ellStart,
  gStart,
  epsilonStart,
  qStart,
  y0Start,
  tStart,
  psiStart
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGamma1_+3A_gamma2">gamma2</code></td>
<td>
<p>Model-averaged estimate for auxiliary regressors
from <code><a href="#topic+computePosterior">computePosterior</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_z2start">Z2start</code></td>
<td>
<p>Transformed design matrix of auxiliary regressors <code class="reqn">\bar{Z}_2</code>.
See details.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_z2">Z2</code></td>
<td>
<p>Another transformed design matrix of auxiliary regressors <code class="reqn">Z_2</code>.
See details.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_u">U</code></td>
<td>
<p>Left singular vectors of <code class="reqn">\bar{Z}_1</code> from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_v">V</code></td>
<td>
<p>Right singular vectors of <code class="reqn">\bar{Z}_1</code> from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_singularvals">singularVals</code></td>
<td>
<p>Singular values of <code class="reqn">\bar{Z}_1</code> from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_ellstart">ellStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{\ell}</code> see details.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_gstart">gStart</code></td>
<td>
<p>Derivative of dispersion parameter <code class="reqn">\rho</code> of NB2 with
respect to <code class="reqn">\alpha = \log(\rho)</code> evaluated at starting values of
one-step ML. <code>gStart</code> is a scalar.
See section &quot;ML estimation&quot; of  Huynh (2023a).</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_epsilonstart">epsilonStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{\epsilon}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_qstart">qStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{q}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_y0start">y0Start</code></td>
<td>
<p>Vector <code class="reqn">\bar{y}_0</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_tstart">tStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{t}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1_+3A_psistart">psiStart</code></td>
<td>
<p>Diagonal matrix <code class="reqn">\bar{\Psi}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See section &quot;Simplification for computing <code class="reqn">\hat{\gamma}_{1}</code>&quot;
in the appendix of Huynh (2023b) for details of the
implementation and for the definitions of argument <code>ellStart</code>.
</p>
<p>All parameters that contain &quot;start&quot; feature the starting values for the
one-step ML estimation of submodels. See section &quot;One-step ML estimator&quot; of
Huynh (2023a) for details.
</p>
<p>The argument <code>Z2start</code> is defined as (Huynh 2023a)
</p>
<p style="text-align: center;"><code class="reqn">
\bar{Z}_{2} := \bar{X}_{2} \bar{\Delta}_{2} \bar{\Xi}^{-1/2},
</code>
</p>

<p>and <code>Z2</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
Z_{2} := X_{2} \bar{\Delta}_{2} \bar{\Xi}^{-1/2}.
</code>
</p>

<p>Uses <code><a href="#topic+svdLSplus">svdLSplus</a></code> under-the-hood.
</p>


<h3>References</h3>

<p>Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.
</p>

<hr>
<h2 id='computeGamma1r'>Internal function: Computes fully restricted one-step ML estimator for
transformed regressors in walsNB</h2><span id='topic+computeGamma1r'></span>

<h3>Description</h3>

<p>Computes one-step ML estimator of fully restricted model
(coefs of transformed regressors of <code class="reqn">\bar{Z}_1</code>)
in walsNB by using SVD on transformed design matrix of the focus regressors
<code class="reqn">\bar{Z}_1</code>. The matrix <code class="reqn">\bar{Z_1}</code> should have full column rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGamma1r(
  U,
  V,
  singularVals,
  ellStart,
  gStart,
  epsilonStart,
  qStart,
  y0Start,
  tStart,
  psiStart
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGamma1r_+3A_u">U</code></td>
<td>
<p>Left singular vectors of <code class="reqn">\bar{Z}_1</code> from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_v">V</code></td>
<td>
<p>Right singular vectors of <code class="reqn">\bar{Z}_1</code> from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_singularvals">singularVals</code></td>
<td>
<p>Singular values of <code class="reqn">\bar{Z}_1</code> from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_ellstart">ellStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{\ell}</code> see details.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_gstart">gStart</code></td>
<td>
<p>Derivative of dispersion parameter <code class="reqn">\rho</code> of NB2 with
respect to <code class="reqn">\alpha = \log(\rho)</code> evaluated at starting values of
one-step ML. <code>gStart</code> is a scalar.
See section &quot;ML estimation&quot; of  Huynh (2023a).</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_epsilonstart">epsilonStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{\epsilon}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_qstart">qStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{q}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_y0start">y0Start</code></td>
<td>
<p>Vector <code class="reqn">\bar{y}_0</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_tstart">tStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{t}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGamma1r_+3A_psistart">psiStart</code></td>
<td>
<p>Diagonal matrix <code class="reqn">\bar{\Psi}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See section &quot;Simplification for computing <code class="reqn">\tilde{\gamma}_{1r}</code>&quot;
in the appendix of Huynh (2023b) for details of the
implementation and for the definitions of argument <code>ellStart</code>.
</p>
<p>All parameters that contain &quot;start&quot; feature the starting values for the
one-step ML estimation of submodels. See section &quot;One-step ML estimator&quot; of
Huynh (2023a) for details.
</p>
<p>Uses <code><a href="#topic+svdLSplus">svdLSplus</a></code> under-the-hood.
</p>


<h3>References</h3>

<p>Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.
</p>

<hr>
<h2 id='computeGammaUnSVD'>Internal function: Computes unrestricted one-step ML estimator for transformed
regressors in walsNB</h2><span id='topic+computeGammaUnSVD'></span>

<h3>Description</h3>

<p>Computes one-step ML estimator for the unrestricted model in walsNB
(coefs of transformed regressors <code class="reqn">\bar{Z}</code>)
by using SVD on entire transformed design matrix <code class="reqn">\bar{Z}</code>.
The matrix <code class="reqn">\bar{Z}</code> should have full column rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGammaUnSVD(
  U,
  V,
  singularVals,
  ellStart,
  gStart,
  epsilonStart,
  qStart,
  y0Start,
  tStart,
  psiStart
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGammaUnSVD_+3A_u">U</code></td>
<td>
<p>Left singular vectors of <code class="reqn">\bar{Z}</code> or <code class="reqn">\bar{Z}_{1}</code>
from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_v">V</code></td>
<td>
<p>Right singular vectors of <code class="reqn">\bar{Z}</code> or <code class="reqn">\bar{Z}_{1}</code>
from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_singularvals">singularVals</code></td>
<td>
<p>Singular values of <code class="reqn">\bar{Z}</code> or <code class="reqn">\bar{Z}_{1}</code>
from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_ellstart">ellStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{\ell}</code> see details.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_gstart">gStart</code></td>
<td>
<p>Derivative of dispersion parameter <code class="reqn">\rho</code> of NB2 with
respect to <code class="reqn">\alpha = \log(\rho)</code> evaluated at starting values of
one-step ML. <code>gStart</code> is a scalar.
See section &quot;ML estimation&quot; of  Huynh (2023a).</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_epsilonstart">epsilonStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{\epsilon}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_qstart">qStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{q}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_y0start">y0Start</code></td>
<td>
<p>Vector <code class="reqn">\bar{y}_0</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_tstart">tStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{t}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeGammaUnSVD_+3A_psistart">psiStart</code></td>
<td>
<p>Diagonal matrix <code class="reqn">\bar{\Psi}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See section &quot;Simplification for computing <code class="reqn">\tilde{\gamma}_{u}</code>&quot;
in the appendix of Huynh (2023b) for details of the
implementation and for the definitions of argument <code>ellStart</code>.
</p>
<p>All parameters that contain &quot;start&quot; feature the starting values for the
one-step ML estimation of submodels. See section &quot;One-step ML estimator&quot; of
Huynh (2023a) for details.
</p>
<p>Uses <code><a href="#topic+svdLSplus">svdLSplus</a></code> under-the-hood.
</p>


<h3>References</h3>

<p>Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.
</p>

<hr>
<h2 id='computePosterior'>Internal function: Compute posterior mean and variance of normal location problem</h2><span id='topic+computePosterior'></span><span id='topic+computePosterior.familyPrior'></span><span id='topic+computePosterior.familyPrior_laplace'></span>

<h3>Description</h3>

<p>Computes the posterior mean and variance of the normal location problem with
fixed variance to 1, i.e. <code class="reqn">x | \gamma \sim N(\gamma, 1)</code>.
The priors for <code class="reqn">\gamma</code> are either <code><a href="#topic+weibull">weibull</a></code>,
<code><a href="#topic+subbotin">subbotin</a></code> or <code><a href="#topic+laplace">laplace</a></code>. Their properties
are briefly discussed in Magnus and De Luca (2016).
Default method of computePosterior uses numerical integration. This is used
for the <code><a href="#topic+weibull">weibull</a></code> and <code><a href="#topic+subbotin">subbotin</a></code> priors.
For the <code><a href="#topic+laplace">laplace</a></code> prior closed form expressions exist for the integrals.
In the original MATLAB code, the Gauss-Kronrod quadrature was used for
numerical integration. Here we use the default <code><a href="stats.html#topic+integrate">integrate</a></code> which
combines Gauss-Kronrod with Wynn's Epsilon algorithm for extrapolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePosterior(object, ...)

## S3 method for class 'familyPrior'
computePosterior(object, x, ...)

## S3 method for class 'familyPrior_laplace'
computePosterior(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePosterior_+3A_object">object</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>, e.g. from
<code><a href="#topic+weibull">weibull</a></code>, should contain all necessary parameters needed
for the posterior.</p>
</td></tr>
<tr><td><code id="computePosterior_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="computePosterior_+3A_x">x</code></td>
<td>
<p>vector. Observed values, i.e. in WALS these are the regression
coefficients of the transformed regressor Z2 standardized by the standard
deviation: <code class="reqn">\gamma_{2u} / s</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See section &quot;Numerical integration in Bayesian estimation step&quot;
in the appendix of Huynh (2023b) for details.
</p>
<p><code>computePosterior.familyPrior_laplace()</code> is the specialized method for the
S3 class <code>"<a href="#topic+familyPrior_laplace">familyPrior_laplace</a>"</code> and computes the posterior
first and second moments of the normal location problem with a Laplace prior
using the analytical formula (without numerical integration).
For more details, see De Luca et al. (2020) and the
original code of Magnus and De Luca.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2020).
&ldquo;Posterior moments and quantiles for the normal location model with Laplace prior.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>0</b>(0), 1-11.
<a href="https://doi.org/10.1080/03610926.2019.1710756">doi:10.1080/03610926.2019.1710756</a>.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>
<p>Original MATLAB code on Jan Magnus' website.
<a href="https://www.janmagnus.nl/items/WALS.pdf">https://www.janmagnus.nl/items/WALS.pdf</a>
</p>

<hr>
<h2 id='computeX2M1X2'>Internal function: Computes X2M1X2 for walsNB when SVD is applied to Z1</h2><span id='topic+computeX2M1X2'></span>

<h3>Description</h3>

<p>Exploits the SVD of <code class="reqn">\bar{Z}_1</code> to compute
<code class="reqn">\bar{X}_{2}^{\top} \bar{M}_{1} \bar{X}_{2}</code> to avoid directly inverting
<code class="reqn">\bar{Z}_{1}^{\top} \bar{Z}_{1}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeX2M1X2(
  X2,
  X2start,
  qStart,
  U,
  UellStart,
  ellStart,
  psiStart,
  gStart,
  epsilonStart,
  geB
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeX2M1X2_+3A_x2">X2</code></td>
<td>
<p>Design matrix for auxiliary regressors</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_x2start">X2start</code></td>
<td>
<p>Transformed design matrix for auxiliary regressors. Refers to
<code class="reqn">\bar{X}_{2} = \bar{\Psi}^{1/2} X_{2}</code>.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_qstart">qStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{q}</code>, see section &quot;One-step ML estimator&quot; of
Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_u">U</code></td>
<td>
<p><code class="reqn">U</code> of SVD of <code class="reqn">Z_1</code>. See details.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_uellstart">UellStart</code></td>
<td>
<p>Vector <code class="reqn">U \bar{\ell}</code>, see details.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_ellstart">ellStart</code></td>
<td>
<p>Vector <code class="reqn">\bar{\ell}</code> see details.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_psistart">psiStart</code></td>
<td>
<p>Diagonal matrix <code class="reqn">\bar{\Psi}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_gstart">gStart</code></td>
<td>
<p>Derivative of dispersion parameter <code class="reqn">\rho</code> of NB2 with
respect to <code class="reqn">\alpha = \log(\rho)</code> evaluated at starting values of
one-step ML. <code>gStart</code> is a scalar.
See section &quot;ML estimation&quot; of  Huynh (2023a).</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_epsilonstart">epsilonStart</code></td>
<td>
<p>Scalar <code class="reqn">\bar{\epsilon}</code>, see section
&quot;One-step ML estimator&quot; of Huynh (2023a) for definition.</p>
</td></tr>
<tr><td><code id="computeX2M1X2_+3A_geb">geB</code></td>
<td>
<p><code class="reqn">\bar{g} \bar{\epsilon} / (1 + B)</code>. In code
<code>gStart*epsilonStart / (1+B)</code>. See details for definition of <code class="reqn">B</code>.
<code>gStart</code> is <code class="reqn">\bar{g}</code> and <code>epsilonStart</code> is <code class="reqn">\bar{\epsilon}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See section
&quot;Simplification for computing <code class="reqn">\bar{X}_{2}^{\top} \bar{M}_{1} \bar{X}_{2}</code>&quot;
in the appendix of Huynh (2023b) for details of the
implementation and for the definitions of arguments <code>Uellstart</code>,
<code>ellStart</code>, and <code>geB</code>.
</p>
<p>All parameters that contain &quot;start&quot; feature the starting values for the
one-step ML estimation of submodels. See section &quot;One-step ML estimator&quot; of
Huynh (2023a) for details.
</p>


<h3>References</h3>

<p>Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.
</p>

<hr>
<h2 id='controlGLM'>Control function for initial GLM fit</h2><span id='topic+controlGLM'></span>

<h3>Description</h3>

<p>Defines controllable parameters of initial GLM fit in <code><a href="#topic+walsGLM">walsGLM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlGLM(restricted = FALSE, controlGLMfit = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlGLM_+3A_restricted">restricted</code></td>
<td>
<p>If <code>TRUE</code>, then initial fit in <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>
only considers the focus regressors. By default <code>FALSE</code>, then the unrestricted
model is estimated in <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> (i.e. all regressors).</p>
</td></tr>
<tr><td><code id="controlGLM_+3A_controlglmfit">controlGLMfit</code></td>
<td>
<p>List. Arguments to be passed to <code>control</code> argument
of <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>. See also <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the parameters specified in the arguments
to be used in <code><a href="#topic+walsGLM">walsGLM</a></code> (and <code><a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a></code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+walsGLM">walsGLM</a>, <a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a>, <a href="stats.html#topic+glm.fit">glm.fit</a>, <a href="stats.html#topic+glm.control">glm.control</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HMDA", package = "AER")
fitBinomial &lt;- walsGLM(deny ~ pirat + hirat + lvrat + chist + mhist + phist |
                       selfemp + afam, data = HMDA,
                       family = binomialWALS(),
                       prior = weibull(),
                       controlInitGLM = controlGLM(restricted = TRUE,
                                                   controlGLMfit = list(trace = TRUE)))

</code></pre>

<hr>
<h2 id='controlNB'>Control function for initial NB fit</h2><span id='topic+controlNB'></span>

<h3>Description</h3>

<p>Defines controllable parameters of initial NB fit in <code><a href="#topic+walsNB">walsNB</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>controlNB(
  start = list(mu = NULL, logTheta = NULL),
  method = "BFGS",
  controlOptim = list(maxit = 100),
  initThetaMASS = FALSE,
  initMASS = TRUE,
  restricted = FALSE,
  eps = .Machine$double.eps^0.25,
  epsilonMASS = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="controlNB_+3A_start">start</code></td>
<td>
<p>Optional starting values for <code><a href="#topic+fitNB2">fitNB2</a></code>. Only used if
<code>initMASS = FALSE</code>.</p>
</td></tr>
<tr><td><code id="controlNB_+3A_method">method</code></td>
<td>
<p>Optimization method used in <code><a href="stats.html#topic+optim">optim</a></code>. Only used if
<code>initMASS = FALSE</code>.</p>
</td></tr>
<tr><td><code id="controlNB_+3A_controloptim">controlOptim</code></td>
<td>
<p>List with parameters controlling optimization process of
<code><a href="stats.html#topic+optim">optim</a></code>. Only used if <code>initMASS = FALSE</code>.</p>
</td></tr>
<tr><td><code id="controlNB_+3A_initthetamass">initThetaMASS</code></td>
<td>
<p>If TRUE, then initial <code class="reqn">\log{\theta}</code> of
<code><a href="#topic+fitNB2">fitNB2</a></code> is estimated using <code><a href="MASS.html#topic+theta.ml">theta.ml</a></code>
(ML-estimation over 1 variable) based on regression coefficients from
Poisson regression. If <code>FALSE</code>, then initial <code class="reqn">\log{\theta}</code> = 0 is used.</p>
</td></tr>
<tr><td><code id="controlNB_+3A_initmass">initMASS</code></td>
<td>
<p>If <code>TRUE</code> (default), then initial fit in <code><a href="#topic+fitNB2">fitNB2</a></code>
is estimated via <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> and <code>initThetaMASS</code> is ignored.
If <code>FALSE</code>, then the initial fit is estimated by minimizing the
log-likelihood using <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="controlNB_+3A_restricted">restricted</code></td>
<td>
<p>If <code>TRUE</code>, then initial fit in <code><a href="#topic+fitNB2">fitNB2</a></code>
only considers the focus regressors. By default <code>FALSE</code>, then the unrestricted
model is estimated in <code><a href="#topic+fitNB2">fitNB2</a></code> (i.e. all regressors).</p>
</td></tr>
<tr><td><code id="controlNB_+3A_eps">eps</code></td>
<td>
<p>Controls argument <code>eps</code> in <code><a href="#topic+fitNB2">fitNB2</a></code> for generating
starting value for <code>logTheta</code> (<code class="reqn">\log{\theta}</code>) via <code><a href="MASS.html#topic+theta.ml">theta.ml</a></code>.</p>
</td></tr>
<tr><td><code id="controlNB_+3A_epsilonmass">epsilonMASS</code></td>
<td>
<p>Sets epsilon in control argument of <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the parameters specified in the arguments
to be used in <code><a href="#topic+walsNB">walsNB</a></code> (and <code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+walsNB">walsNB</a>, <a href="#topic+walsNBfitIterate">walsNBfitIterate</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NMES1988", package = "AER")
walsNB(visits ~ health + chronic + age + gender | I((age^2)/10) +
       married + region, data = NMES1988, prior = weibull(),
       controlInitNB = controlNB(initMASS = FALSE, restricted = TRUE))

</code></pre>

<hr>
<h2 id='ddweibull'>Internal function: double (reflected) Weibull density</h2><span id='topic+ddweibull'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="stats.html#topic+dweibull">dweibull</a></code> to use the parametrization on
pp. 131 of Magnus and De Luca (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddweibull(x, q, b, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddweibull_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ddweibull_+3A_q">q</code></td>
<td>
<p><code class="reqn">q</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="ddweibull_+3A_b">b</code></td>
<td>
<p><code class="reqn">c</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="ddweibull_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density function is
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \frac{q c}{2} |x|^{q - 1} \exp(-c |x|^{q}).</code>
</p>



<h3>Value</h3>

<p>Gives the (log-)density.
</p>


<h3>References</h3>

<p>Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+weibull">weibull</a>, <a href="stats.html#topic+dweibull">dweibull</a>.
</p>

<hr>
<h2 id='dlaplace'>Internal function: Laplace density</h2><span id='topic+dlaplace'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="#topic+dsubbotin">dsubbotin</a></code> with fixed <code>q = 1</code>. Uses
the parametrization on pp. 131 of Magnus and De Luca (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlaplace(x, b, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlaplace_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dlaplace_+3A_b">b</code></td>
<td>
<p><code class="reqn">c</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="dlaplace_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density function is
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \frac{c}{2} \exp(-c |x|).</code>
</p>



<h3>Value</h3>

<p>Gives the (log-)density.
</p>


<h3>References</h3>

<p>Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+laplace">laplace</a>, <a href="#topic+dsubbotin">dsubbotin</a>.
</p>

<hr>
<h2 id='dsubbotin'>Internal function: Subbotin density</h2><span id='topic+dsubbotin'></span>

<h3>Description</h3>

<p>Subbotin density, uses the parametrization on pp. 131 of
Magnus and De Luca (2016). Also called generalized normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsubbotin(x, q, b, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsubbotin_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dsubbotin_+3A_q">q</code></td>
<td>
<p><code class="reqn">q</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="dsubbotin_+3A_b">b</code></td>
<td>
<p><code class="reqn">c</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="dsubbotin_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density function is
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \frac{q c^{1/q}}{2 \Gamma(1/q)} \exp(-c |x|^{q}).</code>
</p>



<h3>Value</h3>

<p>Gives the (log-)density.
</p>


<h3>References</h3>

<p>Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+subbotin">subbotin</a>.
</p>

<hr>
<h2 id='familyPrior'>Family Objects for Prior Distributions in WALS</h2><span id='topic+familyPrior'></span><span id='topic+weibull'></span><span id='topic+subbotin'></span><span id='topic+laplace'></span><span id='topic+familyPrior_laplace'></span><span id='topic+print.familyPrior'></span><span id='topic+familyPrior.wals'></span>

<h3>Description</h3>

<p><code>"familyPrior"</code> objects provide a convenient way to specify the prior
distribution used for the Bayesian posterior mean estimation of the WALS
estimators in <code><a href="#topic+wals">wals</a></code>, <code><a href="#topic+walsGLM">walsGLM</a></code> and
<code><a href="#topic+walsNB">walsNB</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>familyPrior(object, ...)

weibull(q = 0.887630085544086, b = log(2))

subbotin(q = 0.799512530172489, b = 0.937673273794677)

laplace(b = log(2))

## S3 method for class 'familyPrior'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'wals'
familyPrior(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="familyPrior_+3A_object">object</code>, <code id="familyPrior_+3A_x">x</code></td>
<td>
<p>Object of of class <code>"familyPrior"</code> or <code>"<a href="#topic+wals">wals</a>"</code>.
The function <code>familyPrior()</code> accesses the <code>"familyPrior"</code> objects
that are stored in objects of class <code>"<a href="#topic+wals">wals</a>"</code>.</p>
</td></tr>
<tr><td><code id="familyPrior_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="familyPrior_+3A_q">q</code></td>
<td>
<p><code class="reqn">q</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="familyPrior_+3A_b">b</code></td>
<td>
<p><code class="reqn">c</code> in Magnus and De Luca (2016).
Parameter of reflected generalized gamma distribution. See below for details.</p>
</td></tr>
<tr><td><code id="familyPrior_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>familyPrior()</code> is a generic function that extracts the family used in
<code>"<a href="#topic+wals">wals</a>"</code> objects.
</p>
<p>The density function of the reflected generalized gamma distribution is
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \frac{q c^{(1 - \alpha)/q}}{2 \Gamma((1 - \alpha)/q)}
               |x|^{-\alpha} \exp(-c |x|^{q}).</code>
</p>

<p>The double (reflected) Weibull, Subbotin and Laplace distributions are all
special cases of the reflected generalized gamma distribution. The Laplace
distribution is also a special case of the double Weibull and of the Subbotin
distribution.
</p>
<p>The double (reflected) Weibull density sets <code class="reqn">q = 1 - \alpha</code>, the Subbotin
density sets <code class="reqn">\alpha = 0</code> and the Laplace density sets <code class="reqn">\alpha = 0</code>
and <code class="reqn">q = 1</code>.
</p>
<p>The default values for the parameters <code>q</code> and <code>b</code> are minimax regret
solutions for the corresponding priors. The double (reflected) Weibull and
Subbotin prior are both neutral and robust. In contrast, the Laplace prior
is only neutral but not robust. See section 9 &quot;Enter Bayes: Neutrality and
Robustness&quot; of Magnus and De Luca (2016) for details and
Table 1 for the optimal parameter values.
</p>


<h3>Value</h3>

<p>An object of class <code>"familyPrior"</code> to be used in
<code><a href="#topic+wals">wals</a></code>, <code><a href="#topic+walsGLM">walsGLM</a></code> and <code><a href="#topic+walsNB">walsNB</a></code>.
This is a list with the elements
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>Parameter <code class="reqn">q</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Parameter <code class="reqn">\alpha</code> (of the reflected generalized gamma
distribution).</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter <code class="reqn">c</code>.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Parameter <code class="reqn">\delta = (1 - \alpha)/q</code>.</p>
</td></tr>
<tr><td><code>printPars</code></td>
<td>
<p>vector. Contains the parameters that are shown in printing
functions, e.g. <code>print.familyPrior()</code>.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>String with the name of the prior distribution.</p>
</td></tr>
</table>
<p><code>laplace()</code> returns an object of the specialized class
<code>"familyPrior_laplace"</code> that inherits from <code>"familyPrior"</code>.
This allows separate processing of the Laplace prior in the estimation
functions as closed-form formulas exists for its posterior mean and variance.
The list elements are the same as for objects of class <code>"familyPrior"</code>.
</p>


<h3>References</h3>

<p>Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+wals">wals</a>, <a href="#topic+walsGLM">walsGLM</a>, <a href="#topic+walsNB">walsNB</a>, <a href="#topic+computePosterior">computePosterior</a>, <a href="#topic+ddweibull">ddweibull</a>,
<a href="#topic+dsubbotin">dsubbotin</a>, <a href="#topic+dlaplace">dlaplace</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use in wals():
fit &lt;- wals(gdpgrowth ~ lgdp60 + equipinv + school60 + life60 + popgrowth |
            law + tropics + avelf + confucian, data = GrowthMPP,
            prior = weibull(q = 0.8, b = log(1.8)))
summary(fit)

</code></pre>

<hr>
<h2 id='familyWALS'>Extended Family Objects for Models</h2><span id='topic+familyWALS'></span><span id='topic+familyWALScount'></span><span id='topic+poissonWALS'></span><span id='topic+binomialWALS'></span><span id='topic+negbinFixedWALS'></span><span id='topic+negbinWALS'></span><span id='topic+familyNBWALS'></span><span id='topic+familyWALS.walsGLM'></span>

<h3>Description</h3>

<p>Objects of class <code>"familyWALS"</code> inherit from <code>"<a href="stats.html#topic+family">family</a>"</code>
and extend those with (transformation) functions required for
<code><a href="#topic+walsGLM">walsGLM</a></code> and <code><a href="#topic+walsNB">walsNB</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>familyWALS(object, ...)

poissonWALS(link = "log")

binomialWALS(link = "logit")

negbinFixedWALS(scale, link)

negbinWALS(scale, link)

## S3 method for class 'walsGLM'
familyWALS(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="familyWALS_+3A_object">object</code></td>
<td>
<p>The function <code>familyWALS()</code> extracts the family objects stored
in <code>"walsGLM"</code> objects.</p>
</td></tr>
<tr><td><code id="familyWALS_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.
</p>
<p>The <code>negbinWALS()</code> family currently only accepts <code>"log"</code>, while
<code>negbinFixedWALS()</code> supports both <code>"log"</code> and <code>"canonical"</code>.</p>
</td></tr>
<tr><td><code id="familyWALS_+3A_link">link</code></td>
<td>
<p>Specifies the model link function. Typically a character string
or an object of class <code>"link-glm"</code> generated by
<code><a href="stats.html#topic+make.link">make.link</a></code>. See <code><a href="stats.html#topic+family">family</a></code> for more details.
Currently, only a limited number of links are supported. See below for more
details.</p>
</td></tr>
<tr><td><code id="familyWALS_+3A_scale">scale</code></td>
<td>
<p>dispersion parameter of NB2 to be used, always larger than 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>familyWALS()</code> is a generic function that extracts the family used in
<code>"walsGLM"</code> objects.
</p>
<p><code>negbinFixedWALS()</code> creates the <code>"familyWALS"</code> object for negative
binomial distribution type 2 (NB2) with fixed dispersion parameter. It extends
<code><a href="#topic+negativeBinomial">negativeBinomial</a></code>.
</p>
<p><code>negbinWALS()</code> creates objects of the specialized class <code>"familyNBWALS"</code>
which inherits from <code>"familyWALS"</code> and <code>"family"</code>. It constructs the
<code>"familyNBWALS"</code> object for the negative binomial distribution type 2 (NB2)
with variable dispersion parameter by extending <code><a href="#topic+negativeBinomial">negativeBinomial</a></code>
and <code>negbinFixedWALS</code> with functions required in <code><a href="#topic+walsNB">walsNB</a>.</code>
<strong><code>negbinWALS</code> should only be used in <code><a href="#topic+walsNBfit">walsNBfit</a></code> and
not in <code><a href="#topic+walsGLM">walsGLM</a></code> because the NB2 with variable dispersion
parameter is not a GLM!</strong>
</p>


<h4>Supported links</h4>

<p>Currently, <code>binomialWALS()</code> and <code>poissonWALS()</code> only support their
canonical links, i.e. <code>"logit"</code> and <code>"log"</code>, respectively.
<code>negbinFixedWALS()</code> supports both, the <code>"canonical"</code> link and
the <code>"log"</code> link, however, the first is not recommended due to numerical
difficulties in the fitting process. In contrast, <code>negbinWALS()</code> only
supports the <code>"log"</code> link.
</p>



<h3>Value</h3>

<p>An object of class <code>"familyWALS"</code> to be used in
<code><a href="#topic+walsGLM">walsGLM</a></code> that inherits from <code>"<a href="stats.html#topic+family">family</a>"</code>.
This is a list that contains elements returned from the corresponding family
function that it extends. Additionally, the following elements are available:
</p>
<table>
<tr><td><code>theta.eta</code></td>
<td>
<p>function. Derivative of the canonical parameter <code class="reqn">\theta</code>
with respect to the linear link <code class="reqn">\eta</code>, i.e. <code class="reqn">d \theta / d \eta</code>.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>function. <code class="reqn">\psi</code> defined on p. 3 of (De Luca et al. 2018).</p>
</td></tr>
<tr><td><code>initializeY</code></td>
<td>
<p>function. Preprocesses the response, e.g. in
<code>binomialWALS()</code> it transforms factors to numeric 0s and 1s.</p>
</td></tr>
<tr><td><code>transformY</code></td>
<td>
<p>function. Transforms the response to <code class="reqn">\bar{y}</code>.
See eq. (5) in (De Luca et al. 2018) for GLMs and
(Huynh 2023a) for <code>negbinWALS()</code> used in
<code><a href="#topic+walsNB">walsNB</a></code>.</p>
</td></tr>
<tr><td><code>transformX</code></td>
<td>
<p>function. Transforms the regressors to <code class="reqn">\bar{X}_1</code> and
<code class="reqn">\bar{X}_2</code>, respectively. See eq. (5) in (De Luca et al. 2018)
for GLMs and (Huynh 2023a) for <code>negbinWALS()</code> used in
<code><a href="#topic+walsNB">walsNB</a></code>.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>function. The probability density/mass function of the family.</p>
</td></tr>
</table>
<p><code>poissonWALS()</code> and <code>negbinFixedWALS()</code> return objects of class
<code>"familyWALScount"</code> that inherit from <code>"familyWALS"</code> and
<code>"family"</code>. These are lists that contain the same elements as
<code>"familyWALS"</code> objects described above.
</p>
<p><code>negbinWALS()</code> creates an object of class <code>"familyNBWALS"</code>
(only used internally in <code><a href="#topic+walsNB">walsNB</a></code>) that inherits from
<code>"familyWALScount"</code>, <code>"familyWALS"</code> and <code>"<a href="stats.html#topic+family">family</a>"</code>.
This is a list that contains all elements returned from <code>negbinFixed</code>
and the elements described above for objects of class <code>"familyWALS"</code>.
Additionally contains the following elements with functions required in
<code><a href="#topic+walsNB">walsNB</a></code> that are described in
(Huynh 2023a):
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{q}</code>.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{g}</code>.</p>
</td></tr>
<tr><td><code>transformY0</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{y}_0</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{t}</code>.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{\epsilon}</code>.</p>
</td></tr>
<tr><td><code>epsiloninv</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{\epsilon}^{-1}</code>.</p>
</td></tr>
<tr><td><code>kappaSum</code></td>
<td>
<p>function. Computes <code class="reqn">\bar{\kappa}^{\top} \mathbf{1}</code>.</p>
</td></tr>
<tr><td><code>computeAlpha</code></td>
<td>
<p>function. Computes the log-dispersion parameter
<code class="reqn">\log(\rho)</code> given (model-averaged) estimates of the regression
coefficients of the transformed regressors <code class="reqn">\gamma_{1}</code> and <code class="reqn">\gamma_{2}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+family">family</a>, <a href="#topic+walsGLM">walsGLM</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use in walsGLM():
data("NMES1988", package = "AER")
NMES1988 &lt;- na.omit(NMES1988)
fitPoisson &lt;- walsGLM(emergency ~ health + chronic + age + gender |
                       I((age^2)/10) + married + region, family = poissonWALS(),
                      data = NMES1988, prior = laplace())
summary(fitPoisson)

## Plot derivatives of binomialWALS() with default 'logit' link:
bi &lt;- binomialWALS()
plot(bi$mu.eta, from = -10, to = 10)
plot(bi$theta.eta, from = -10, to = 10) # constant. logit is canonical link

</code></pre>

<hr>
<h2 id='fitNB2'>Internal function: Fits a NB2 regression via maximum likelihood with log-link
for mean and dispersion parameter.</h2><span id='topic+fitNB2'></span>

<h3>Description</h3>

<p>Internal fitting function for NB2 regression models. Used for fitting the
starting values of the one-step ML estimators in <code><a href="#topic+walsNB">walsNB</a></code>. Only
works with log-link so far, no other links tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitNB2(X, Y, family, control = controlNB())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitNB2_+3A_x">X</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="fitNB2_+3A_y">Y</code></td>
<td>
<p>Count response vector.</p>
</td></tr>
<tr><td><code id="fitNB2_+3A_family">family</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyNBWALS">familyNBWALS</a>"</code> generated by
<code><a href="#topic+negbinWALS">negbinWALS</a></code>.</p>
</td></tr>
<tr><td><code id="fitNB2_+3A_control">control</code></td>
<td>
<p>List of parameters for controlling the optimization process.
Use <code><a href="#topic+controlNB">controlNB</a></code> to generate the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available parameters for controlling the optimization are documented in
<code><a href="#topic+controlNB">controlNB</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following elements
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>fitted coefficients from NB2 regression</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>fitted dispersion parameter from NB2 regression</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>0 indicates successful completion. All error codes except
for <code>99</code> are generated by <code><a href="stats.html#topic+optim">optim</a></code>. Possible error
codes are
</p>

<dl>
<dt><code>1</code></dt><dd><p>indicates that the iteration limit <code>maxit</code> had been reached.</p>
</dd>
<dt><code>10</code></dt><dd><p>degeneracy of the Nelder-Mead simplex.</p>
</dd>
<dt><code>51</code></dt><dd><p>warning from &quot;L-BFGS-B&quot; method; see component <code>message</code>
for further details.</p>
</dd>
<dt><code>52</code></dt><dd><p>error from &quot;L-BFGS-B&quot; method; see component <code>message</code>
for further details.</p>
</dd>
<dt><code>99</code></dt><dd><p>(only possible if <code>controlNB(initMASS = TRUE)</code>) indicates
convergence issues in <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>log-likelihood of fitted NB2 regression model</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>If <code>controlNB(initMASS = FALSE)</code>, character string
giving any additional information returned by the optimizer, else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>If <code>controlNB(initMASS = FALSE)</code>, contains a vector with the
starting values used for <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+controlNB">controlNB</a>, <a href="#topic+negbinWALS">negbinWALS</a>, <a href="MASS.html#topic+glm.nb">glm.nb</a>, <a href="stats.html#topic+optim">optim</a>.
</p>

<hr>
<h2 id='gammaToBeta'>Internal function: Transform gammas back to betas</h2><span id='topic+gammaToBeta'></span>

<h3>Description</h3>

<p>Transforms posterior means <code class="reqn">\hat{\gamma}_2</code> and variances corresponding
to transformed auxiliary regressors <code class="reqn">Z_2</code> back to regression coefficients
<code class="reqn">\hat{\beta}</code> of original regressors <code class="reqn">X_1</code> and <code class="reqn">X_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaToBeta(
  posterior,
  y,
  Z1,
  Z2,
  Delta1,
  D2,
  sigma,
  Z1inv,
  method = "original",
  svdZ1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaToBeta_+3A_posterior">posterior</code></td>
<td>
<p>Object returned from <code><a href="#topic+computePosterior">computePosterior</a></code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_y">y</code></td>
<td>
<p>Response <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_z1">Z1</code></td>
<td>
<p>Transformed focus regressors <code class="reqn">Z_1</code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_z2">Z2</code></td>
<td>
<p>Transformed auxiliary regressors <code class="reqn">Z_1</code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_delta1">Delta1</code></td>
<td>
<p><code class="reqn">\Delta_1</code> or <code class="reqn">\bar{\Delta}_1</code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_d2">D2</code></td>
<td>
<p>From <code><a href="#topic+semiorthogonalize">semiorthogonalize</a></code>, if <code>postmult = FALSE</code>
was used, then D2 = <code class="reqn">\Delta_2 T \Lambda^{-1/2}</code>, where <code class="reqn">T</code> are the
eigenvectors of <code class="reqn">\Xi</code> and <code class="reqn">\Lambda</code> the diagonal matrix containing
the corresponding eigenvalues. If <code>postmult = TRUE</code> was used, then
D2 = <code class="reqn">\Delta_2 T \Lambda^{-1/2} T^{\top} = \Delta_2 \Xi^{-1/2}</code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_sigma">sigma</code></td>
<td>
<p>Prespecified or estimated standard deviation of the error term.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_z1inv">Z1inv</code></td>
<td>
<p><code class="reqn">(Z_{1}^{\top} Z_{1})^{-1}</code>.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_method">method</code></td>
<td>
<p>Character. <code class="reqn">\hat{\gamma}_1</code> is obtained from a linear
regression of <code class="reqn">Z_1</code> on pseudo-responses <code class="reqn">y - Z_2 \hat{\gamma}_2</code>.
If <code>method = original</code>, then we use <code><a href="stats.html#topic+lm.fit">lm.fit</a></code> to perform
the linear regression, if <code>method = "svd"</code>, then reuse the SVD of
<code class="reqn">Z_1</code> in <code>svdZ1</code> to perform the regression.</p>
</td></tr>
<tr><td><code id="gammaToBeta_+3A_svdz1">svdZ1</code></td>
<td>
<p>Optional, only needed if <code>method = "svd"</code>. SVD of <code class="reqn">Z_1</code>
computed using <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same transformations also work for GLMs, where we replace <code class="reqn">X_1</code>,
<code class="reqn">X_2</code>, <code class="reqn">Z_1</code> and <code class="reqn">Z_2</code> with <code class="reqn">\bar{X}_1</code>, <code class="reqn">\bar{X}_2</code>,
<code class="reqn">\bar{Z}_1</code> and <code class="reqn">\bar{Z}_2</code>, respectively. Generally, we need to
replace all variables with their corresponding &quot;bar&quot; version. Further,
for GLMs <code>sigma</code> is always 1.
</p>
<p>See Magnus and De Luca (2016), De Luca et al. (2018)
and Huynh (2023b) for the definitions of the variables.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>

<hr>
<h2 id='GrowthMP'>Determinants of Economic Growth</h2><span id='topic+GrowthMP'></span>

<h3>Description</h3>

<p>Growth regression data used in Masanjala and Papageorgiou (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrowthMP
</code></pre>


<h3>Format</h3>

<p>A data frame with 37 observations on 25 variables:
</p>

<dl>
<dt>gdpgrowth</dt><dd><p>Average growth rate of GDP per capita from 1960 - 1992 at
purchasing power parity.</p>
</dd>
<dt>lgdp60</dt><dd><p>Logarithm of GDP per capita in 1960.</p>
</dd>
<dt>yrsopen</dt><dd><p>Fraction of years economy open from 1960 - 1990.</p>
</dd>
<dt>mining</dt><dd><p>Fraction of GDP in mining.</p>
</dd>
<dt>primexp70</dt><dd><p>Share of exports of primary products in GDP in 1970.</p>
</dd>
<dt>invest</dt><dd><p>Ratio of real domestic investment (public and private) to real GDP.</p>
</dd>
<dt>rerd</dt><dd><p>Real exchange rate distortion.</p>
</dd>
<dt>school60</dt><dd><p>Average years of primary schooling for population over 25
years of age in 1960.</p>
</dd>
<dt>life60</dt><dd><p>Life expectancy at age 0 in 1960.</p>
</dd>
<dt>popgrowth</dt><dd><p>Average growth rate of population from 1960 - 1990.</p>
</dd>
<dt>war</dt><dd><p>factor. <code>"yes"</code> if country participates in at least one external
war from 1960 to 1985. <code>"no"</code> else.</p>
</dd>
<dt>revcoup</dt><dd><p>Average number of revolutions and coups per year from 1960 - 1990.</p>
</dd>
<dt>rights</dt><dd><p>Index of political rights ranging from 1 (most restrictive)
to 7 (most freedom)</p>
</dd>
<dt>civil</dt><dd><p>Index of civil liberties ranging from 1 (most restrictive)
to 7 (most freedom)</p>
</dd>
<dt>out</dt><dd><p>Index of outward orientation.</p>
</dd>
<dt>capitalism</dt><dd><p>Degree of capitalism.</p>
</dd>
<dt>colony</dt><dd><p>factor. Shows if the country used to be <code>"british"</code> or
<code>"french"</code> colony. If neither of them applies, then <code>"none"</code>.</p>
</dd>
<dt>english</dt><dd><p>Fraction of English speakers.</p>
</dd>
<dt>foreign</dt><dd><p>Fraction speaking foreign language.</p>
</dd>
<dt>frac</dt><dd><p>Probability that two random people are from different
ethnolinguistic groups.</p>
</dd>
<dt>protestant</dt><dd><p>Fraction of population Protestant.</p>
</dd>
<dt>catholic</dt><dd><p>Fraction of population Catholic.</p>
</dd>
<dt>muslim</dt><dd><p>Fraction of population Muslim.</p>
</dd>
<dt>area</dt><dd><p>Size of country in millions of square kilometers.</p>
</dd>
<dt>abslat</dt><dd><p>Distance from the equator.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset of Masanjala and Papageorgiou (2008) is a subset of
sub-Sahara African countries from the data used in
Sala-I-Martin (1997). See Table A2. in
Masanjala and Papageorgiou (2008) for the original sources of the
variables. This dataset is also used for replication purposes in
Amini and Parmeter (2012).
</p>
<p>To replicate the WALS estimates in Amini and Parmeter (2012),
use all variables except for a constant as auxiliary regressors and divide all
regressors by their in-sample maximum before running
<code>wals(..., prescale = FALSE)</code> (<b>NOTE: It is not recommended to use
<code>prescale = FALSE</code> as this runs an old version of the WALS estimator,
<code>prescale = FALSE</code> should only be used for replication purposes</b>).
The resulting coefficients and standard errors have to be divided by the maximum
of the regressors again to get the values presented in Table I of the paper.
</p>


<h3>Source</h3>

<p>Journal of Applied Econometrics Data Archive.
The data was taken from the archive entry of
Amini and Parmeter (2012) for replication purposes but
they can also be found in the archive entry of
Masanjala and Papageorgiou (2008).
</p>
<p><a href="https://journaldata.zbw.eu/dataset/comparison-of-model-averaging-techniques-assessing-growth-determinants">https://journaldata.zbw.eu/dataset/comparison-of-model-averaging-techniques-assessing-growth-determinants</a>
</p>


<h3>References</h3>

<p>Amini SM, Parmeter CF (2012).
&ldquo;Comparison of model averaging techniques: assessing growth determinants.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>27</b>(5), 870-876.
<a href="https://doi.org/10.1002/jae.2288">doi:10.1002/jae.2288</a>.<br /><br /> Masanjala WH, Papageorgiou C (2008).
&ldquo;Rough and lonely road to prosperity: a reexamination of the sources of growth in Africa using Bayesian model averaging.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>23</b>(5), 671-682.
<a href="https://doi.org/10.1002/jae.1020">doi:10.1002/jae.1020</a>.<br /><br /> Sala-I-Martin X (1997).
&ldquo;I Just Ran Two Million Regressions.&rdquo;
<em>The American Economic Review</em>, <b>87</b>(2), 178&ndash;183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replicate second panel of Table I in Amini &amp; Parmeter (2012)
## NOTE: Authors manually scale data, then rescale the resulting coefs and se.
X &lt;- model.matrix(gdpgrowth ~ ., data = GrowthMP)
scaleVector &lt;- apply(X, MARGIN = 2, max)
Xscaled &lt;- apply(X, MARGIN = 2, function(x) x/max(x))
Xscaled &lt;- Xscaled[,-1]
datscaled &lt;- as.data.frame(cbind(gdpgrowth = GrowthMP$gdpgrowth, Xscaled))

fitMP &lt;- wals(gdpgrowth ~ 1 | ., data = datscaled, prescale = FALSE,
              prior = laplace(), eigenSVD = FALSE)
tableMP &lt;- cbind("coef" = coef(fitMP)/scaleVector,
                 "se" = sqrt(diag(vcov(fitMP)))/scaleVector)
printVars &lt;- c("(Intercept)", "lgdp60", "yrsopen", "mining", "primexp70",
               "invest")
print(round(tableMP[printVars,], 4))

</code></pre>

<hr>
<h2 id='GrowthMPP'>Determinants of Economic Growth</h2><span id='topic+GrowthMPP'></span>

<h3>Description</h3>

<p>Growth regression data used in Magnus et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrowthMPP
</code></pre>


<h3>Format</h3>

<p>A data frame with 72 observations on 11 variables:
</p>

<dl>
<dt>country</dt><dd><p>factor. Name of the country.</p>
</dd>
<dt>gdpgrowth</dt><dd><p>Average growth rate of GDP per capita from 1960 - 1996 at
purchasing power parity.</p>
</dd>
<dt>lgdp60</dt><dd><p>Logarithm of GDP per capita in 1960.</p>
</dd>
<dt>equipinv</dt><dd><p>Average real equipment investment share of GDP from
1960 - 1985 comprising investments in electrical and nonelectrical machinery
(in relative prices constant across countries).</p>
</dd>
<dt>school60</dt><dd><p>Enrollment rate for primary education in 1960.</p>
</dd>
<dt>life60</dt><dd><p>Life expectancy at age 0 in 1960.</p>
</dd>
<dt>popgrowth</dt><dd><p>Average growth rate of population from 1960 - 1996.</p>
</dd>
<dt>law</dt><dd><p>Index for the overall maintenance of the rule of law ('law and
order tradition').</p>
</dd>
<dt>tropics</dt><dd><p>Proportion of country's land area within geographical tropics.</p>
</dd>
<dt>avelf</dt><dd><p>Average of five different indices of ethnolinguistic
fragmentation which is measured as the probability of two random people
in a country not sharing the same language.</p>
</dd>
<dt>confucian</dt><dd><p>Fraction of Confucian population in 1970 and 1980.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset is used in Magnus et al. (2010)
to illustrate the WALS model averaging approach and combines the data used in
Sala-I-Martin et al. (2004) and Sala-I-Martin (1997).
See the references for more detailed descriptions and original sources of the
variables.
</p>


<h3>Source</h3>

<p>WALS package for MATLAB (and Stata) provided on Jan Magnus' personal
website.
<a href="https://www.janmagnus.nl/items/WALS.pdf">https://www.janmagnus.nl/items/WALS.pdf</a>.
</p>


<h3>References</h3>

<p>Magnus JR, Powell O, Prfer P (2010).
&ldquo;A comparison of two model averaging techniques with an application to growth empirics.&rdquo;
<em>Journal of Econometrics</em>, <b>154</b>(2), 139-153.
<a href="https://doi.org/10.1016/j.jeconom.2009.07.004">doi:10.1016/j.jeconom.2009.07.004</a>.<br /><br /> Sala-I-Martin X (1997).
&ldquo;I Just Ran Two Million Regressions.&rdquo;
<em>The American Economic Review</em>, <b>87</b>(2), 178&ndash;183.<br /><br /> Sala-I-Martin X, Doppelhofer G, Miller RI (2004).
&ldquo;Determinants of Long-Term Growth: A Bayesian Averaging of Classical Estimates (BACE) Approach.&rdquo;
<em>American Economic Review</em>, <b>94</b>(4), 813-835.
<a href="https://doi.org/10.1257/0002828042002570">doi:10.1257/0002828042002570</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replicate Table 2 in Magnus et al. (2010)
# NOTE: prescale = FALSE, still used old version of WALS in Magnus et al. (2010).
# Not recommended anymore!
fitMPP &lt;- wals(gdpgrowth ~ lgdp60 + equipinv + school60 + life60 + popgrowth |
                  law + tropics + avelf + confucian, data = GrowthMPP,
                prior = laplace(), prescale = FALSE)
tableMPP &lt;- cbind("coef" = coef(fitMPP), "se" = sqrt(diag(vcov(fitMPP))))
print(round(tableMPP, 4))

</code></pre>

<hr>
<h2 id='negativeBinomial'>Negative binomial family</h2><span id='topic+negativeBinomial'></span>

<h3>Description</h3>

<p>Reconstruct family object for negative binomial type 2 (NB2) with fixed
scale parameter theta. Analogous to <code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code> in
<code>MASS</code> (Venables and Ripley 2002) but <code>MASS</code> uses non-canonical link.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negativeBinomial(theta, link = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negativeBinomial_+3A_theta">theta</code></td>
<td>
<p>dispersion parameter of NB2, always larger than 0.</p>
</td></tr>
<tr><td><code id="negativeBinomial_+3A_link">link</code></td>
<td>
<p>specifies link function, currently only &quot;log&quot; and &quot;canonical&quot;
are supported.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Venables WN, Ripley BD (2002).
<em>Modern Applied Statistics with S</em>,  Statistics and Computing, 4th edition.
Springer-Verlag, New York.
<a href="https://doi.org/10.1007/978-0-387-21706-2">doi:10.1007/978-0-387-21706-2</a>, <a href="https://www.stats.ox.ac.uk/pub/MASS4/">https://www.stats.ox.ac.uk/pub/MASS4/</a>.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+family">family</a>, <a href="#topic+familyWALS">familyWALS</a>, <a href="#topic+negbinWALS">negbinWALS</a>, <a href="#topic+negbinFixedWALS">negbinFixedWALS</a>.
</p>

<hr>
<h2 id='predict.wals'>Methods for wals and walsMatrix Objects</h2><span id='topic+predict.wals'></span><span id='topic+predict.walsMatrix'></span><span id='topic+fitted.wals'></span><span id='topic+residuals.wals'></span><span id='topic+print.wals'></span><span id='topic+summary.wals'></span><span id='topic+print.summary.wals'></span><span id='topic+coef.wals'></span><span id='topic+vcov.wals'></span><span id='topic+nobs.wals'></span><span id='topic+terms.wals'></span><span id='topic+model.matrix.wals'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted model-averaging objects of
classes <code>"wals"</code> and <code>"walsMatrix"</code>. <code>"walsMatrix"</code> objects
inherit from <code>"wals"</code>, so the methods for <code>"wals"</code> also work for
objects of class <code>"walsMatrix"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wals'
predict(object, newdata, na.action = na.pass, ...)

## S3 method for class 'walsMatrix'
predict(object, newX1, newX2, ...)

## S3 method for class 'wals'
fitted(object, ...)

## S3 method for class 'wals'
residuals(object, ...)

## S3 method for class 'wals'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'wals'
summary(object, ...)

## S3 method for class 'summary.wals'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'wals'
coef(object, type = c("all", "focus", "aux"), transformed = FALSE, ...)

## S3 method for class 'wals'
vcov(object, type = c("all", "focus", "aux"), transformed = FALSE, ...)

## S3 method for class 'wals'
nobs(object, ...)

## S3 method for class 'wals'
terms(x, type = c("focus", "aux"), ...)

## S3 method for class 'wals'
model.matrix(object, type = c("focus", "aux"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.wals_+3A_object">object</code>, <code id="predict.wals_+3A_x">x</code></td>
<td>
<p>An object of class <code>"wals"</code>, <code>"walsMatrix"</code> or
<code>"summary.wals"</code>.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_na.action">na.action</code></td>
<td>
<p>Function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_newx1">newX1</code></td>
<td>
<p>Focus regressors matrix to be used for the prediction.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_newx2">newX2</code></td>
<td>
<p>Auxiliary regressors matrix to be used for the prediction.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to display.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_type">type</code></td>
<td>
<p>Character specifying the part of the model that should be returned.
For details see below.</p>
</td></tr>
<tr><td><code id="predict.wals_+3A_transformed">transformed</code></td>
<td>
<p>Logical specifying whether the coefficients/covariance
matrix of original regressors (<code>FALSE</code>, default) or the transformed
regressors (<code>TRUE</code>) should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects is available
for objects of class <code>"wals"</code> and <code>"walsMatrix"</code>, including methods to
the generic functions <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>
which print the model-averaged estimation of the coefficients along with some
further information. As usual, the <code>summary</code> method returns an object of
class <code>"summary.wals"</code> containing the relevant summary statistics which
can then be printed using the associated <code>print</code> method.
Inspired by De Luca and Magnus (2011), the summary statistics
also show <code>Kappa</code> which is an indicator for the numerical stability of
the method, i.e. it shows the square root of the condition number of the
matrix <code class="reqn">\Xi = \Delta_{2} X_{2}^{\top} M_{1} X_{2} \Delta_{2}</code>.
The summary further provides information on the prior used along with its
parameters. The <code>summary()</code>, <code>print.summary()</code>,
<code>print()</code> and <code>logLik()</code> methods are also inspired by the corresponding
methods for objects of class <code>"lm"</code> in <code><a href="stats.html#topic+stats">stats</a></code> version
4.3.1 (2023-06-16) (R Core Team 2023), see e.g. <code><a href="stats.html#topic+print.summary.lm">print.summary.lm</a></code>.
</p>
<p>The <code><a href="stats.html#topic+residuals">residuals</a></code> method computes raw residuals
(observed - fitted).
</p>
<p>For <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code>, the <code>type</code>
argument, either <code>"all"</code>, <code>"focus"</code> or <code>"aux"</code>, specifies which
part of the coefficient vector/covariance matrix of the estimates should be
returned. Additionally, the <code>transformed</code> argument specifies whether to
return the estimated  coefficients/covariance matrix for the original
regressors <code class="reqn">X</code> or of the transformed regressors <code class="reqn">Z</code>.
</p>
<p>The extractors <code><a href="stats.html#topic+terms">terms</a></code> and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
behave similarly to <code>coef</code>, but they only allow <code>type = "focus"</code>
and <code>type = "aux"</code>. They extract the corresponding component of the model.
This is similar to the implementation of these extractors in <code>countreg</code>
version 0.2-1 (2023-06-13) (Zeileis and Kleiber 2023; Zeileis et al. 2008), see e.g.
<code>terms.hurdle()</code>.
</p>


<h3>Value</h3>

<p><code>predict.wals()</code> and <code>predict.walsMatrix()</code> return a vector
containing the predicted means.
</p>
<p><code>fitted.wals()</code> returns a vector containing the fitted means
for the data used in fitting.
</p>
<p><code>residuals.wals()</code> returns the raw residuals of the fitted
model, i.e. response - fitted mean.
</p>
<p><code>print.wals()</code> invisibly returns its input argument <code>x</code>,
i.e. an object of object of class <code>"wals"</code>.
</p>
<p><code>summary.wals</code> returns an object of class <code>"summary.wals"</code>
which contains the necessary fields for printing the summary in
<code>print.summary.wals()</code>.
</p>
<p><code>print.summary.wals()</code> invisibly returns its input argument
<code>x</code>, i.e. an object of object of class <code>"summary.wals"</code>.
</p>
<p><code>coef.wals()</code> returns a vector containing the fitted coefficients.
If <code>type = "focus"</code>, only the coefficients of the focus regressors are
returned and if <code>type = "aux"</code>, only the coefficients of auxiliary
regressors are returned. Else if <code>type = "all"</code>, the coefficients
of both focus and auxiliary regressors are returned. Additionally if
<code>transformed = FALSE</code>, <code>coef.wals()</code> returns the estimated
coefficients for the original regressors <code class="reqn">X</code> (<code class="reqn">\beta</code> coefficients)
and else if <code>transformed = TRUE</code> the coefficients of the transformed
regressors <code class="reqn">Z</code> (<code class="reqn">\gamma</code> coefficients).
</p>
<p><code>vcov.wals()</code> returns a matrix containing the estimated
(co-)variances of the fitted regression coefficients. If <code>type = "focus"</code>,
only the submatrix belonging to the focus regressors is returned and if
<code>type = "aux"</code>, only the submatrix corresponding to the auxiliary
regressors is returned. Else if <code>type = "all"</code>, the complete covariance
matrix is returned. Additionally if <code>transformed = FALSE</code>,
<code>vcov.wals()</code> returns the estimated covariance matrix for the original
regressors <code class="reqn">X</code> (<code class="reqn">\beta</code> coefficients) and else if
<code>transformed = TRUE</code> the covariance matrix of the transformed regressors
<code class="reqn">Z</code> (<code class="reqn">\gamma</code> coefficients).
</p>
<p><code>nobs.wals()</code> returns the number of observations used for
fitting the model.
</p>
<p><code>terms.wals()</code> returns the <em>terms</em> representation of the fitted
model. It is of class <code>c("terms", "formula")</code>, see <code><a href="stats.html#topic+terms">terms</a></code>
and <code><a href="stats.html#topic+terms.object">terms.object</a></code> for more details. If <code>type = "focus"</code>,
then returns the terms for the focus regressors, else if <code>type = "aux"</code>
returns the terms for the auxiliary regressors.
</p>
<p><code>model.matrix.wals()</code> either returns the design matrix of the
focus regressors (<code>type = "focus"</code>) or of the auxiliary regressors
(<code>type = "aux"</code>). See <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for more details.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR (2011).
&ldquo;Bayesian model averaging and weighted-average least squares: Equivariance, stability, and numerical issues.&rdquo;
<em>The Stata Journal</em>, <b>11</b>(4), 518&ndash;544.
<a href="https://doi.org/10.1177/1536867X1201100402">doi:10.1177/1536867X1201100402</a>.<br /><br /> R Core Team (2023).
<em>R: A Language and Environment for Statistical Computing</em>.
R Foundation for Statistical Computing, Vienna, Austria.
<a href="https://www.R-project.org/">https://www.R-project.org/</a>.<br /><br /> Zeileis A, Kleiber C (2023).
<em>countreg: Count Data Regression</em>.
R package version 0.2-1, <a href="https://r-forge.r-project.org/projects/countreg/">https://r-forge.r-project.org/projects/countreg/</a>.<br /><br /> Zeileis A, Kleiber C, Jackman S (2008).
&ldquo;Regression Models for Count Data in R.&rdquo;
<em>Journal of Statistical Software</em>, <b>27</b>(8), 1&ndash;25.
<a href="https://doi.org/10.18637/jss.v027.i08">doi:10.18637/jss.v027.i08</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+wals">wals</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for wals objects
fitGrowth &lt;- wals(gdpgrowth ~ lgdp60 + equipinv + school60 + life60 + popgrowth |
                law + tropics + avelf + confucian, data = GrowthMPP,
                prior = laplace())
summary(fitGrowth)
fitted(fitGrowth)
vcov(fitGrowth, type = "aux")
familyPrior(fitGrowth)
nobs(fitGrowth)

## Example for walsMatrix objects
X1 &lt;- model.matrix(fitGrowth, type = "focus")
X2 &lt;- model.matrix(fitGrowth, type = "aux")
y &lt;- GrowthMPP$gdpgrowth
fitGrowthMatrix &lt;- wals(X1, X2, y, prior = laplace())
coef(fitGrowthMatrix)

</code></pre>

<hr>
<h2 id='predict.walsGLM'>Methods for walsGLM, walsGLMmatrix, walsNB and walsNBmatrix Objects</h2><span id='topic+predict.walsGLM'></span><span id='topic+predict.walsGLMmatrix'></span><span id='topic+residuals.walsGLM'></span><span id='topic+print.walsGLM'></span><span id='topic+summary.walsGLM'></span><span id='topic+print.summary.walsGLM'></span><span id='topic+logLik.walsGLM'></span><span id='topic+summary.walsNB'></span><span id='topic+print.summary.walsNB'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted model-averaging objects of
classes <code>"walsGLM"</code>, <code>"walsGLMmatrix"</code>, <code>"walsNB"</code> and
<code>"walsNBmatrix"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walsGLM'
predict(
  object,
  newdata,
  type = c("response", "link", "variance", "prob", "density", "logDens"),
  at = NULL,
  na.action = na.pass,
  log = FALSE,
  ...
)

## S3 method for class 'walsGLMmatrix'
predict(
  object,
  newX1,
  newX2,
  newY = NULL,
  type = c("response", "link", "variance", "prob", "density", "logDens"),
  at = NULL,
  log = FALSE,
  ...
)

## S3 method for class 'walsGLM'
residuals(object, type = c("deviance", "pearson", "response"), ...)

## S3 method for class 'walsGLM'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'walsGLM'
summary(object, ...)

## S3 method for class 'summary.walsGLM'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'walsGLM'
logLik(object, ...)

## S3 method for class 'walsNB'
summary(object, ...)

## S3 method for class 'summary.walsNB'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.walsGLM_+3A_object">object</code>, <code id="predict.walsGLM_+3A_x">x</code></td>
<td>
<p>An object of class <code>"walsGLM"</code>, <code>"walsGLMmatrix"</code>,
<code>"walsNB"</code>, <code>"walsNBmatrix"</code>, <code>"summary.walsGLM"</code> or
<code>"summary.walsNB"</code>.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_type">type</code></td>
<td>
<p>Character specifying the type of prediction, residual or model
part to be returned. For details see below.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_at">at</code></td>
<td>
<p>Optional. Only available if a family of class <code>"<a href="#topic+familyWALScount">familyWALScount</a>"</code>
was used for fitting. If <code>type = "prob"</code>, a numeric vector at which
the probabilities are evaluated. By default <code>0:max(y)</code> is used
where <code>y</code> is the original observed response.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_na.action">na.action</code></td>
<td>
<p>Function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_log">log</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then returns the log-density. If
<code>FALSE</code> (default), then returns density. Only relevant if
<code>type = "density"</code>.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_newx1">newX1</code></td>
<td>
<p>Focus regressors matrix to be used for the prediction.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_newx2">newX2</code></td>
<td>
<p>Auxiliary regressors matrix to be used for the prediction.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_newy">newY</code></td>
<td>
<p>Response vector to be used in predictions. Only relevant when
<code>type = "prob"</code>, <code>type = "density"</code> or <code>type = "logDens"</code>.</p>
</td></tr>
<tr><td><code id="predict.walsGLM_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the <code>"-matrix"</code> classes <code>"walsGLMmatrix"</code> and <code>"walsNBmatrix"</code>
inherit from the &quot;non-matrix&quot; classes, i.e. <code>"walsGLM"</code> and <code>"walsNB"</code>,
respectively, the following text will treat them as equivalent because
they inherit all methods but <code>predict</code> from their &quot;non-matrix&quot; versions.
Thus, when <code>"walsGLM"</code> or <code>"walsNB"</code> are mentioned, we also refer to
their <code>"-matrix"</code> versions, except when explicitly stated. Moreover,
note that <code>"walsNB"</code> and <code>"walsNBmatrix"</code> inherit most methods from
<code>"walsGLM"</code> and <code>"walsGLMmatrix"</code>.
</p>
<p>A set of standard extractor functions for fitted model objects is available
for objects of class <code>"walsGLM"</code> and <code>"walsNB"</code>, including methods to
the generic functions <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>
which print the model-averaged estimation of the coefficients along with some
further information.
</p>
<p>The <code><a href="base.html#topic+summary">summary</a></code> methods returns an object of
class <code>"summary.walsGLM"</code> for objects of class <code>"walsGLM"</code> and an
object of class <code>"summary.walsNB"</code> for objects of class <code>"walsNB"</code>.
They contain the relevant summary statistics which can then be printed using
the associated <code>print()</code> methods.
Inspired by De Luca and Magnus (2011), the summary statistics
also show <code>Kappa</code> which is an indicator for the numerical stability of
the method, i.e. it shows the square root of the condition number of the
matrix <code class="reqn">\bar{\Xi} = \bar{\Delta}_{2} \bar{X}_{2}^{\top} \bar{M}_{1}
\bar{X}_{2} \bar{\Delta}_{2}</code>. The summary further shows the deviance and
provides information on the prior and family used.
</p>
<p>A <code><a href="stats.html#topic+logLik">logLik</a></code> method is provided that returns the log-likelihood
given the family used and the model-averaged estimates of the coefficients.
</p>
<p><code>"walsGLM"</code> inherits from <code>"wals"</code>, while <code>"walsNB"</code> inherits from
both, <code>"walsGLM"</code> and <code>"wals"</code>. Thus, see <code><a href="#topic+predict.wals">predict.wals</a></code>
for more methods.
</p>
<p>The <code><a href="stats.html#topic+predict">predict</a></code> and <code><a href="stats.html#topic+residuals">residuals</a></code> methods,
especially the different types of predictions/residuals controlled by
<code>type</code>, are inspired by the corresponding methods in <code>countreg</code>
version 0.2-1 (2023-06-13) (Zeileis and Kleiber 2023; Zeileis et al. 2008), see
e.g. <code>predict.hurdle()</code> from <code>countreg</code>, and <code><a href="stats.html#topic+stats">stats</a></code>
version 4.3.1 (2023-06-16) (R Core Team 2023), see e.g.
<code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>. The <code>summary()</code>, <code>print.summary()</code>,
<code>print()</code> and <code>logLik()</code> methods are also inspired by the corresponding
methods for objects of class <code>"glm"</code> in <code><a href="stats.html#topic+stats">stats</a></code>, see
e.g. <code><a href="stats.html#topic+print.summary.glm">print.summary.glm</a></code>.
</p>
<p><code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code> are inherited from
<code>"wals"</code> (see <code><a href="#topic+predict.wals">predict.wals</a></code> for more), except for
objects of class <code>"walsNB"</code> (see <code><a href="#topic+vcov.walsNB">vcov.walsNB</a></code>).
The <code>type</code> argument specifies which part of the coefficient
vector/covariance matrix of the estimates should be returned.
For <code>type = "all"</code>, they return the complete vector/matrix.
For <code>type = "focus"</code> and <code>type = "aux"</code> they return only the part
corresponding to the focus and auxiliary regressors, respectively.
Additionally, the user can choose whether to return the
estimated coefficients/covariance matrix for the original regressors <code class="reqn">X</code>
(<code class="reqn">\beta</code> coefficients) or of the transformed regressors <code class="reqn">Z</code>
(<code class="reqn">\gamma</code> coefficients).
</p>
<p>The extractors <code><a href="stats.html#topic+terms">terms</a></code> and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
are also inherited from <code>"wals"</code>. They only allow <code>type = "focus"</code>
and <code>type = "aux"</code> and extract the corresponding component of the model.
</p>


<h3>Value</h3>

<p><code>predict.walsGLM()</code> and <code>predict.walsGLMmatrix()</code> return
different types of predictions depending on the argument <code>type</code>:
</p>

<ul>
<li> <p><code>type = "response"</code>: vector. Predicted mean
</p>
</li>
<li> <p><code>type = "link"</code>: vector. Predicted linear link
</p>
</li>
<li> <p><code>type = "variance"</code>: vector. Predicted variance
</p>
</li>
<li> <p><code>type = "prob"</code>: matrix. Only available if a family of class
<code>"<a href="#topic+familyWALScount">familyWALScount</a>"</code> was used for fitting or for objects of
class <code>"walsNB"</code> or <code>"walsNBmatrix"</code>. Returns the probability at
counts specified by <code>at</code>.
</p>
</li>
<li> <p><code>type = "density"</code>: vector. Predicted density
</p>
</li>
<li> <p><code>type = "logDens"</code>: vector. For convenience, returns predicted log-density.
Equivalent to setting <code>type = "density"</code> and <code>log = TRUE</code>.
</p>
</li></ul>

<p>If <code>type = "prob"</code>, <code>type = "density"</code> or <code>type = "logDens"</code>,
then <code>newdata</code> must contain the response or <code>newY</code> must be
specified depending on the class of the object.
</p>
<p><code>residuals.walsGLM()</code> returns different types of residuals
depending on the argument <code>type</code>:
</p>

<ul>
<li> <p><code>type = "deviance"</code>: deviance residuals
</p>
</li>
<li> <p><code>type = "pearson"</code>: Pearson residuals (raw residuals scaled by
square root of variance function)
</p>
</li>
<li> <p><code>type = "response"</code>: raw residuals (observed - fitted)
</p>
</li></ul>

<p><code>print.walsGLM()</code> invisibly returns its input argument <code>x</code>,
i.e. an object of object of class <code>"walsGLM"</code>.
</p>
<p><code>summary.walsGLM()</code> returns an object of class
<code>"summary.walsGLM"</code> which contains the necessary fields for printing the
summary in <code>print.summary.walsGLM()</code>.
</p>
<p><code>print.summary.walsGLM()</code> invisibly returns its input argument
<code>x</code>, i.e. an object of object of class <code>"summary.walsGLM"</code>.
</p>
<p><code>logLik.walsGLM()</code> returns the log-likelihood of the fitted
model.
</p>
<p><code>summary.walsNB()</code> returns an object of class
<code>"summary.walsNB"</code> which contains the necessary fields for printing the
summary in <code>print.summary.walsNB()</code>.
</p>
<p><code>print.summary.walsNB()</code> invisibly returns its input argument
<code>x</code>, i.e. an object of object of class <code>"summary.walsNB"</code>.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR (2011).
&ldquo;Bayesian model averaging and weighted-average least squares: Equivariance, stability, and numerical issues.&rdquo;
<em>The Stata Journal</em>, <b>11</b>(4), 518&ndash;544.
<a href="https://doi.org/10.1177/1536867X1201100402">doi:10.1177/1536867X1201100402</a>.<br /><br /> R Core Team (2023).
<em>R: A Language and Environment for Statistical Computing</em>.
R Foundation for Statistical Computing, Vienna, Austria.
<a href="https://www.R-project.org/">https://www.R-project.org/</a>.<br /><br /> Zeileis A, Kleiber C (2023).
<em>countreg: Count Data Regression</em>.
R package version 0.2-1, <a href="https://r-forge.r-project.org/projects/countreg/">https://r-forge.r-project.org/projects/countreg/</a>.<br /><br /> Zeileis A, Kleiber C, Jackman S (2008).
&ldquo;Regression Models for Count Data in R.&rdquo;
<em>Journal of Statistical Software</em>, <b>27</b>(8), 1&ndash;25.
<a href="https://doi.org/10.18637/jss.v027.i08">doi:10.18637/jss.v027.i08</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+walsGLM">walsGLM</a>, <a href="#topic+walsNB">walsNB</a>, <a href="#topic+predict.wals">predict.wals</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for walsGLM objects
data("HMDA", package = "AER")
fitBinomial &lt;- walsGLM(deny ~ pirat + hirat + lvrat + chist + mhist + phist |
                        selfemp + afam, family = binomialWALS(), data = HMDA,
                       prior = weibull())
summary(fitBinomial)
vcov(fitBinomial, type = "focus")
logLik(fitBinomial)
predict(fitBinomial, newdata = HMDA[1:10,], type = "response")
familyWALS(fitBinomial)

## Example for walsNB objects
data("NMES1988", package = "AER")

fWals &lt;- (visits ~ chronic + age + I((age^2)/10) + insurance + medicaid |
           adl + gender + married + income + school + afam + employed)
fitNB &lt;- walsNB(fWals, data = NMES1988, link = "log", prior = weibull(),
                method = "fullSVD")
summary(fitNB)
coef(fitNB, type = "aux")
residuals(fitNB, type = "pearson")
predict(fitNB, newdata = NMES1988[1:10,], type = "prob")
terms(fitNB, type = "aux")

</code></pre>

<hr>
<h2 id='predictCounts'>Internal methods: Predict probability for counts</h2><span id='topic+predictCounts'></span><span id='topic+predictCounts.familyWALScount'></span>

<h3>Description</h3>

<p>Predicts the probability of counts given a family object of class
<code>"<a href="#topic+familyWALScount">familyWALScount</a>"</code>. Only works for count data models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictCounts(x, ...)

## S3 method for class 'familyWALScount'
predictCounts(x, yUnique, rowNames, eta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictCounts_+3A_x">x</code></td>
<td>
<p>object of class <code>"<a href="#topic+familyWALScount">familyWALScount</a>"</code>.</p>
</td></tr>
<tr><td><code id="predictCounts_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>density()</code> function in
<code>family</code>.</p>
</td></tr>
<tr><td><code id="predictCounts_+3A_yunique">yUnique</code></td>
<td>
<p>vector. The counts (larger or equal to zero) which to predict
probabilities for.</p>
</td></tr>
<tr><td><code id="predictCounts_+3A_rownames">rowNames</code></td>
<td>
<p>vector. The names of the observations.</p>
</td></tr>
<tr><td><code id="predictCounts_+3A_eta">eta</code></td>
<td>
<p>vector. The fitted linear link <code class="reqn">\hat{\eta}</code> of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"<a href="#topic+familyWALScount">familyWALScount</a>"</code> objects are used in the fitting methods
<code><a href="#topic+walsNB">walsNB</a></code>, <code><a href="#topic+walsNBmatrix">walsNBmatrix</a></code>,
<code><a href="#topic+walsGLM">walsGLM</a></code> or <code><a href="#topic+walsGLMmatrix">walsGLMmatrix</a></code>. For the
latter two, only the family <code><a href="#topic+poissonWALS">poissonWALS</a></code> is currently
supported.
</p>
<p><code>predictCounts()</code> is not available for objects of any class except for
<code>"<a href="#topic+familyWALScount">familyWALScount</a>"</code>.
</p>
<p>The <code>predictCounts.familyWALScount()</code> method is a modified version of the
<code>predict.hurdle()</code> method from the <code>countreg</code> package
version 0.2-1 (2023-06-13) (Zeileis and Kleiber 2023; Zeileis et al. 2008) using the argument
<code>type = "prob"</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of dimension <code>length(eta)</code> times
<code>length{yUnique}</code> with the predicted probabilities of the counts given
in <code>yUnique</code> for every observation in <code>eta</code>.
</p>


<h3>References</h3>

<p>Zeileis A, Kleiber C (2023).
<em>countreg: Count Data Regression</em>.
R package version 0.2-1, <a href="https://r-forge.r-project.org/projects/countreg/">https://r-forge.r-project.org/projects/countreg/</a>.<br /><br /> Zeileis A, Kleiber C, Jackman S (2008).
&ldquo;Regression Models for Count Data in R.&rdquo;
<em>Journal of Statistical Software</em>, <b>27</b>(8), 1&ndash;25.
<a href="https://doi.org/10.18637/jss.v027.i08">doi:10.18637/jss.v027.i08</a>.
</p>

<hr>
<h2 id='semiorthogonalize'>Internal function: Semiorthogonal-type transformation of X2 to Z2</h2><span id='topic+semiorthogonalize'></span>

<h3>Description</h3>

<p>Uses the matrix Z2s (called <code class="reqn">\bar{\Xi}</code> in eq. (9) of
De Luca et al. (2018)) to transform <code class="reqn">\bar{X}_2</code> to
<code class="reqn">\bar{Z}_2</code>, i.e. to perform <code class="reqn">\bar{Z}_2 = \bar{X}_2 \bar{\Delta}_2 \bar{\Xi}^{-1/2}</code>.
For WALS in the linear regression model, the variables do not have a &quot;bar&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semiorthogonalize(Z2s, X2, Delta2, SVD = TRUE, postmult = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semiorthogonalize_+3A_z2s">Z2s</code></td>
<td>
<p>Matrix for which we take negative square root in
<code class="reqn">X2 * Delta2 * Z2s^{1/2}</code>.</p>
</td></tr>
<tr><td><code id="semiorthogonalize_+3A_x2">X2</code></td>
<td>
<p>Design matrix of auxiliary regressors to be transformed to Z2</p>
</td></tr>
<tr><td><code id="semiorthogonalize_+3A_delta2">Delta2</code></td>
<td>
<p>Scaling matrix such that diagonal of
<code class="reqn">\bar{\Delta}_2 \bar{X}_2^{\top} \bar{M}_1 \bar{X}_2 \Delta_{2}</code> is one
(ignored scaling by <code class="reqn">n</code> because not needed in code).
See De Luca et al. (2018)</p>
</td></tr>
<tr><td><code id="semiorthogonalize_+3A_svd">SVD</code></td>
<td>
<p>If <code>TRUE</code>, uses <code><a href="base.html#topic+svd">svd</a></code> to compute eigendecomposition
of <code>Z2s</code>, otherwise uses <code><a href="base.html#topic+eigen">eigen</a></code>.</p>
</td></tr>
<tr><td><code id="semiorthogonalize_+3A_postmult">postmult</code></td>
<td>
<p>If <code>TRUE</code>, then it uses
<code class="reqn">Z2s^{-1/2} = T \Lambda^{-1/2} T^{\top}</code>, where <code class="reqn">T</code> contains
the eigenvectors of <code class="reqn">Z2s</code> in its columns and <code class="reqn">\Lambda</code> the corresponding
eigenvalues. If <code>FALSE</code> it uses <code class="reqn">Z2s^{-1/2} = T \Lambda^{-1/2}</code>.</p>
</td></tr>
</table>


<h3>On the &quot;semiorthogonal-type&quot; transformation</h3>

<p>For WALS GLM (and WALS in the linear regression model),
the transformation is semiorthogonal (ignored scaling by <code class="reqn">n</code> for clarity
and because it is not needed in the code)
in the sense that <code class="reqn">\bar{M}_{1} \bar{Z}_{2}</code> is semiorthogonal since
</p>
<p style="text-align: center;"><code class="reqn">\bar{Z}_{2}^{\top} \bar{M}_1 \bar{Z}_{2} =
(\bar{Z}_{2}^{\top} \bar{M}_1) (\bar{M}_{1} \bar{Z}_{2}) = I_{k_2},</code>
</p>

<p>where <code class="reqn">\bar{M}_1</code> is an idempotent matrix.
</p>
<p>For WALS in the NB2 regression model, <code class="reqn">\bar{M}_{1} \bar{Z}_{2}</code> is not
semiorthogonal anymore due to the rank-1 perturbation in <code class="reqn">\bar{M}_1</code> which
causes <code class="reqn">\bar{M}_1</code> to not be idempotent anymore, see
the section &quot;Transformed model&quot; in Huynh (2023a).
</p>


<h3>On the use of <code>postmult = TRUE</code></h3>

<p>The transformation of the auxiliary regressors <code class="reqn">Z_2</code> for linear WALS in
eq. (12) of Magnus and De Luca (2016) differs from the
transformation for WALS GLM (and WALS NB) in eq. (9) of
De Luca et al. (2018):
</p>
<p>In Magnus and De Luca (2016) the transformed auxiliary
regressors are
</p>
<p style="text-align: center;"><code class="reqn">Z_{2} = X_2 \Delta_2 T \Lambda^{-1/2},</code>
</p>

<p>where <code class="reqn">T</code> contains the eigenvectors of
<code class="reqn">\Xi = \Delta_2 X_{2}^{\top} M_{1} X_{2} \Delta_2</code> in the columns and
<code class="reqn">\Lambda</code> the respective eigenvalues. This definition is used when
<code>postmult = FALSE</code>.
</p>
<p>In contrast, De Luca et al. (2018) defines
</p>
<p style="text-align: center;"><code class="reqn">Z_2 = X_2 \Delta_2 T \Lambda^{-1/2} T^{\top},</code>
</p>

<p>where we ignored scaling by <code class="reqn">n</code> and the notation with &quot;bar&quot; for easier
comparison. This definition is used when <code>postmult = TRUE</code> and is
strongly preferred for <code><a href="#topic+walsGLM">walsGLM</a></code> and <code><a href="#topic+walsNB">walsNB</a></code>.
</p>
<p>See Huynh (2023b) for more details.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>

<hr>
<h2 id='snbinom'>Internal function: first derivatives of NB2 PMF</h2><span id='topic+snbinom'></span>

<h3>Description</h3>

<p>First derivatives of NB2 PMF used in <code><a href="#topic+fitNB2">fitNB2</a></code>. Code is
taken from the function <code>snbinom()</code> in the <code>countreg</code> package
version 0.2-1 (2023-06-13) (Zeileis and Kleiber 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snbinom(x, mu, size, parameter = c("mu", "size"), drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snbinom_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="snbinom_+3A_mu">mu</code></td>
<td>
<p>Vector of means.</p>
</td></tr>
<tr><td><code id="snbinom_+3A_size">size</code></td>
<td>
<p>Vector of dispersion parameter. If a scalar is given, the value
is recycled.</p>
</td></tr>
<tr><td><code id="snbinom_+3A_parameter">parameter</code></td>
<td>
<p>Specifies which parameter the derivative is taken for.
<code>parameter = c("mu", "size")</code> returns a matrix with derivatives
for both parameters.</p>
</td></tr>
<tr><td><code id="snbinom_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code>, drops empty dimensions of return using
<code><a href="base.html#topic+drop">drop</a></code>. If <code>FALSE</code> does not apply <code><a href="base.html#topic+drop">drop</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix containing the first derivatives.
</p>


<h3>References</h3>

<p>Zeileis A, Kleiber C (2023).
<em>countreg: Count Data Regression</em>.
R package version 0.2-1, <a href="https://r-forge.r-project.org/projects/countreg/">https://r-forge.r-project.org/projects/countreg/</a>.
</p>

<hr>
<h2 id='svdLSplus'>Internal function: Uses SVD components to compute final estimate via
Sherman-Morrison-Woodbury formula.</h2><span id='topic+svdLSplus'></span>

<h3>Description</h3>

<p>Solves the equation system in walsNB via Sherman-Morrison-Woodbury formula
for the unrestricted estimator <code class="reqn">\hat{\gamma}_{u}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdLSplus(U, V, singularVals, y, ell, geB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svdLSplus_+3A_u">U</code></td>
<td>
<p>Left singular vectors of <code class="reqn">\bar{Z}</code> or <code class="reqn">\bar{Z}_{1}</code>
from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="svdLSplus_+3A_v">V</code></td>
<td>
<p>Right singular vectors of <code class="reqn">\bar{Z}</code> or <code class="reqn">\bar{Z}_{1}</code>
from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="svdLSplus_+3A_singularvals">singularVals</code></td>
<td>
<p>Singular values of <code class="reqn">\bar{Z}</code> or <code class="reqn">\bar{Z}_{1}</code>
from <code><a href="base.html#topic+svd">svd</a></code>.</p>
</td></tr>
<tr><td><code id="svdLSplus_+3A_y">y</code></td>
<td>
<p>&quot;Pseudo&quot;-response, see details.</p>
</td></tr>
<tr><td><code id="svdLSplus_+3A_ell">ell</code></td>
<td>
<p>Vector <code class="reqn">\bar{\ell}</code> from section
&quot;Simplification for computing <code class="reqn">\tilde{\gamma}_{u}</code>&quot;
Huynh (2023b)</p>
</td></tr>
<tr><td><code id="svdLSplus_+3A_geb">geB</code></td>
<td>
<p>Scalar <code class="reqn">\bar{g} \bar{\epsilon} / (1 + B)</code>. See section
&quot;Simplification for computing <code class="reqn">\tilde{\gamma}_{u}</code>&quot;
Huynh (2023b) for definition of
<code class="reqn">\bar{g}</code>, <code class="reqn">\bar{\epsilon}</code> and <code class="reqn">B</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be reused for the computation of the fully restricted
estimator <code class="reqn">\tilde{\gamma}_{1r}</code> and the model averaged estimator
<code class="reqn">\hat{\gamma}_{1}</code>.
</p>
<p>For <code class="reqn">\tilde{\gamma}_{1r}</code> and <code class="reqn">\hat{\gamma}_{1}</code> use
<code>U</code>, <code>V</code> and <code>singularVals</code> from SVD of <code class="reqn">\bar{Z}_{1}</code>.
</p>
<p>For <code class="reqn">\hat{\gamma}_{u}</code> and <code class="reqn">\tilde{\gamma}_{1r}</code> use same
pseudo-response <code class="reqn">\bar{y_{0}} - \bar{t} \bar{\epsilon} \bar{\Psi}^{-1/2} \bar{q}</code>
in argument <code>y</code>.
</p>
<p>For <code class="reqn">\hat{\gamma}_{1}</code> use pseudo-response
<code class="reqn">\bar{y_{0}} - \bar{t} \bar{\epsilon} \bar{\Psi}^{-1/2} \bar{q} -
(\bar{Z}_{2} + \bar{g} \bar{\epsilon} \bar{\Psi}^{-1/2} \bar{q} \bar{q}^{\top}
Z_{2}) \hat{\gamma}_{2}</code>.
</p>
<p>See section &quot;Note on function svdLSplus from WALS&quot;
in Huynh (2023b).
</p>


<h3>References</h3>

<p>Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.
</p>

<hr>
<h2 id='vcov.walsNB'>Calculate Variance-Covariance Matrix for a <code>"walsNB"</code> object</h2><span id='topic+vcov.walsNB'></span>

<h3>Description</h3>

<p>This method always raises an error because the covariance matrix of the
walsNB estimator has not been derived yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walsNB'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.walsNB_+3A_object">object</code></td>
<td>
<p>An object of class <code>"walsNB"</code>.</p>
</td></tr>
<tr><td><code id="vcov.walsNB_+3A_...">...</code></td>
<td>
<p>For expansion in the future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only raises error because no covariance matrix
estimator exists yet.
</p>

<hr>
<h2 id='wals'>Weighted-Average Least Squares for linear regression models</h2><span id='topic+wals'></span><span id='topic+wals.formula'></span><span id='topic+wals.matrix'></span><span id='topic+wals.default'></span>

<h3>Description</h3>

<p>Performs model averaging for linear regression models using the
Weighted-Average Least Squares method by
Magnus et al. (2010). See also
De Luca and Magnus (2011),
Kumar and Magnus (2013) and
Magnus and De Luca (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wals(x, ...)

## S3 method for class 'formula'
wals(
  formula,
  data,
  subset = NULL,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  model = TRUE,
  keepY = TRUE,
  keepX = FALSE,
  sigma = NULL,
  ...
)

## S3 method for class 'matrix'
wals(
  x,
  x2,
  y,
  subset = NULL,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  keepY = TRUE,
  keepX = FALSE,
  sigma = NULL,
  ...
)

## Default S3 method:
wals(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wals_+3A_x">x</code></td>
<td>
<p>Design matrix of focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="wals_+3A_...">...</code></td>
<td>
<p>Arguments for workhorse <code><a href="#topic+walsFit">walsFit</a></code>.</p>
</td></tr>
<tr><td><code id="wals_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="Formula.html#topic+Formula">Formula</a>"</code>
(or one that can be coerced to that class, e.g. <code>"<a href="stats.html#topic+formula">formula</a>"</code>):
a symbolic description of the model to be fitted.
The details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="wals_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment
(or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model. If not found in <code>data</code>, the variables
are taken from <code>environment(formula)</code>, typically the environment which
the function is called from.</p>
</td></tr>
<tr><td><code id="wals_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="wals_+3A_na.action">na.action</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="wals_+3A_weights">weights</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="wals_+3A_offset">offset</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="wals_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="wals_+3A_model">model</code></td>
<td>
<p>if <code>TRUE</code> (default), then the model.frame is stored in
the return.</p>
</td></tr>
<tr><td><code id="wals_+3A_keepy">keepY</code></td>
<td>
<p>if <code>TRUE</code> (default), then the response is stored in
the return.</p>
</td></tr>
<tr><td><code id="wals_+3A_keepx">keepX</code></td>
<td>
<p>if <code>TRUE</code>, then the model matrices are stored in the return.
the return.</p>
</td></tr>
<tr><td><code id="wals_+3A_sigma">sigma</code></td>
<td>
<p>if NULL (default), then the variance of the error term is
estimated. See <code><a href="#topic+walsFit">walsFit</a></code> for more details.</p>
</td></tr>
<tr><td><code id="wals_+3A_x2">x2</code></td>
<td>
<p>Design matrix of auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="wals_+3A_y">y</code></td>
<td>
<p>Response as vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R port of MATLAB code wals.m (version 2.0, revision 18 December 2013)
by J.R. Magnus and G. De Luca, available from
<a href="https://www.janmagnus.nl/items/WALS.pdf">https://www.janmagnus.nl/items/WALS.pdf</a>.
Calculates WALS estimates when focus regressors (X1) are present in all
submodels and model averaging takes place over the auxiliary regressors (X2).
</p>
<p>Formulas should always contain two parts, i.e. they should be of the form
&quot;<code>y ~ X11 + X12 | X21 + X22</code>&quot;, where the variables before &quot;<code>|</code>&quot; are
the focus regressors (includes a constant by default) and the ones after
&quot;<code>|</code>&quot; are the auxiliary regressors.
</p>
<p><strong>WARNING:</strong> Interactions in formula do not work properly yet.
It is recommended to manually create the interactions beforehand and then
to insert them as 'linear terms' in the formula.
</p>
<p><code>wals.default()</code> raises an error if <code>x</code> is not an object of class
<code>"matrix"</code> or a class that extends <code>"matrix"</code>. Otherwise it calls
<code>wals.matrix()</code>. It is a modified version of <code>glmboost.default</code>
from the <code>mboost</code> package version 2.9-8 (2023-09-06) (Hofner et al. 2014).
</p>


<h3>Value</h3>

<p><code>wals.formula()</code> returns an object of class
<code>"wals"</code>. This is a list that contains all elements returned from
<code><a href="#topic+walsFit">walsFit</a></code> and additionally
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>If <code>keepY = TRUE</code>, contains the response vector.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>list. If <code>keepX = TRUE</code>, then it is a list with elements
<code>x1</code> and <code>x2</code> containing the design matrices of the focus and
auxiliary regressors, respectively.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>returns the argument <code>weights</code>.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>returns the argument <code>offset</code>.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>Call of the function.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p><code>formula</code> used.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>List containing the model terms of the focus and auxiliary
regressors separately, as well as for the full model.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>List containing the levels of the focus and auxiliary
regressors separately, as well as for the full model.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>List containing the contrasts of the design matrices of
focus and auxiliary regressors.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>If <code>model = TRUE</code>, contains the model frame.</p>
</td></tr>
</table>
<p>See returns of <code><a href="#topic+walsFit">walsFit</a></code> for more details.
</p>
<p><code>wals.matrix()</code> returns an object of class <code>"walsMatrix"</code>,
which inherits from <code>"wals"</code>. This is a list that contains all elements
returned from <code><a href="#topic+walsFit">walsFit</a></code> and additionally the response <code>y</code>,
the list <code>x</code> with model matrices <code>x1</code> and <code>x2</code>, the call
<code>cl</code>, <code>offset</code> and <code>weights</code>.
</p>
<p><code>wals.default()</code> raises an error if <code>x</code> is not an object
of class <code>"matrix"</code> or a class that extends <code>"matrix"</code>. Otherwise
returns an object of class <code>"walsMatrix"</code>. See above for more details.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR (2011).
&ldquo;Bayesian model averaging and weighted-average least squares: Equivariance, stability, and numerical issues.&rdquo;
<em>The Stata Journal</em>, <b>11</b>(4), 518&ndash;544.
<a href="https://doi.org/10.1177/1536867X1201100402">doi:10.1177/1536867X1201100402</a>.<br /><br /> Hofner B, Mayr A, Robinzonov N, Schmid M (2014).
&ldquo;Model-based Boosting in R: A Hands-on Tutorial Using the R Package mboost.&rdquo;
<em>Computational Statistics</em>, <b>29</b>, 3&ndash;35.<br /><br /> Kumar K, Magnus JR (2013).
&ldquo;A characterization of Bayesian robustness for a normal location parameter.&rdquo;
<em>Sankhya B</em>, <b>75</b>(2), 216&ndash;237.
<a href="https://doi.org/10.1007/s13571-013-0060-9">doi:10.1007/s13571-013-0060-9</a>.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.<br /><br /> Magnus JR, Powell O, Prfer P (2010).
&ldquo;A comparison of two model averaging techniques with an application to growth empirics.&rdquo;
<em>Journal of Econometrics</em>, <b>154</b>(2), 139-153.
<a href="https://doi.org/10.1016/j.jeconom.2009.07.004">doi:10.1016/j.jeconom.2009.07.004</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Replicate table on p. 534 of De Luca &amp; Magnus (2011)
fitDM &lt;- wals(gdpgrowth ~ lgdp60 + equipinv + school60 + life60 + popgrowth |
                  law + tropics + avelf + confucian, data = GrowthMPP,
                prior = laplace())
tableDM &lt;- cbind("coef" = coef(fitDM), "se" = sqrt(diag(vcov(fitDM))))
print(round(tableDM, 7))


## Replicate first panel of Table I in Amini &amp; Parmeter (2012)
data("datafls", package = "BMS")

# NOTE: Authors manually scale data, then rescale the resulting coefs and se.
X &lt;- model.matrix(y ~ ., data = datafls)
Xscaled &lt;- apply(X, MARGIN = 2, function(x) x/max(x))
Xscaled &lt;- Xscaled[,-1]
scaleVector &lt;- apply(X, MARGIN = 2, function(x) max(x))
flsScaled &lt;- as.data.frame(cbind(y = datafls$y, Xscaled))

# NOTE: prescale = FALSE, still used old version of WALS in Magnus et al. (2010).
# Not recommended anymore!
fitFLS &lt;- wals(y ~ 1 | ., data = flsScaled, prescale = FALSE, eigenSVD = FALSE,
               prior = laplace())
tableFLS &lt;- cbind('coef' = coef(fitFLS)/scaleVector,
                  'se' = sqrt(diag(vcov(fitFLS)))/scaleVector)
printVars &lt;- c("(Intercept)", "GDP60", "Confucian", "LifeExp", "EquipInv",
               "SubSahara", "Muslim", "RuleofLaw")
print(round(tableFLS[printVars,], 4))


## Replicate third panel of Table I in Amini &amp; Parmeter (2012)
data("SDM", package = "BayesVarSel")

# rescale response
SDM$y &lt;- SDM$y / 100

# NOTE: Authors manually scale data, then rescale the resulting coefs and se.
X &lt;- model.matrix(y ~ ., data = SDM)
Xscaled &lt;- apply(X, MARGIN = 2, function(x) x/max(x))
Xscaled &lt;- Xscaled[,-1]
scaleVector &lt;- apply(X, MARGIN = 2, function(x) max(x))
SDMscaled &lt;- as.data.frame(cbind(y = SDM$y, Xscaled))

# NOTE: prescale = FALSE, still used old version of WALS in Magnus et al. (2010).
# Not recommended anymore!
fitDW &lt;- wals(y ~ 1 | ., data = SDMscaled, prescale = FALSE, eigenSVD = FALSE,
              prior = laplace())
tableDW &lt;- cbind(coef(fitDW)/scaleVector, sqrt(diag(vcov(fitDW)))/scaleVector)
printVars &lt;- c("(Intercept)", "EAST", "P60", "IPRICE1", "GDPCH60L", "TROPICAR")
print(round(tableDW[printVars,], 5))

## Example for wals.matrix()
X &lt;- model.matrix(mpg ~ disp + hp + wt + vs + am + carb, data = mtcars)
X1 &lt;- X[,c("(Intercept)", "disp", "hp", "wt")] # focus
X2 &lt;- X[,c("vs", "am", "carb")] # auxiliary
y &lt;- mtcars$mpg

wals(X1, X2, y, prior = weibull())

</code></pre>

<hr>
<h2 id='walsFit'>Fitter function for Weighted Average Least Squares estimation</h2><span id='topic+walsFit'></span>

<h3>Description</h3>

<p>Workhorse function behind <code><a href="#topic+wals">wals</a></code> and <code><a href="#topic+walsGLM">walsGLM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsFit(
  X1,
  X2,
  y,
  sigma = NULL,
  prior = weibull(),
  method = "original",
  svdTol = .Machine$double.eps,
  svdRtol = 1e-06,
  keepUn = FALSE,
  eigenSVD = TRUE,
  prescale = TRUE,
  postmult = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsFit_+3A_x1">X1</code></td>
<td>
<p>Design matrix for focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_x2">X2</code></td>
<td>
<p>Design matrix for auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_y">y</code></td>
<td>
<p>Response as vector.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_sigma">sigma</code></td>
<td>
<p>if NULL (default), then the variance of the error term is estimated,
see p.136 of Magnus and De Luca (2016). If sigma is specified,
then the unrestricted estimator is divided by sigma before performing the
Bayesian posterior mean estimation.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_method">method</code></td>
<td>
<p>Specifies method used. Available methods are
<code>"original"</code> (default) or <code>"svd"</code>.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_svdtol">svdTol</code></td>
<td>
<p>Tolerance for rank of matrix <code class="reqn">\bar{Z}_{1}</code>
Only used if <code>method = "svd"</code>.
Checks if smallest eigenvalue in SVD of <code class="reqn">\bar{Z}_1</code> and <code class="reqn">\bar{Z}</code>
is larger than <code>svdTol</code>, otherwise reports a rank deficiency.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_svdrtol">svdRtol</code></td>
<td>
<p>Relative tolerance for rank of matrix <code class="reqn">\bar{Z}_{1}</code>.
Only used if <code>method = "svd"</code>. Checks if ratio of largest to smallest
eigenvalue in SVD of <code class="reqn">\bar{Z}_1</code> is larger than  <code>svdRtol</code>,
otherwise reports a rank deficiency.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_keepun">keepUn</code></td>
<td>
<p>If <code>TRUE</code>, keeps the estimators of the unrestricted model,
i.e. <code class="reqn">\tilde{\gamma}_{u}</code>.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_eigensvd">eigenSVD</code></td>
<td>
<p>If <code>TRUE</code>, then <code><a href="#topic+semiorthogonalize">semiorthogonalize</a></code>
uses <code><a href="base.html#topic+svd">svd</a></code> to compute the eigendecomposition of
<code class="reqn">\bar{\Xi}</code> instead of <code><a href="base.html#topic+eigen">eigen</a></code>. In this case, the
tolerances of <code>svdTol</code> and <code>svdRtol</code> are used to
determine whether <code class="reqn">\bar{\Xi}</code> is of full rank (need it for <code class="reqn">\bar{\Xi}^{-1/2}</code>).</p>
</td></tr>
<tr><td><code id="walsFit_+3A_prescale">prescale</code></td>
<td>
<p>If <code>TRUE</code> (default), prescales the regressors X1 and X2 with
<code class="reqn">\Delta_1</code> and <code class="reqn">\Delta_2</code>, respectively, to improve numerical stability
and make the coefficients of the auxiliary regressors scale equivariant.
See De Luca and Magnus (2011) for more details.
<strong>WARNING: It is not recommended to set <code>prescale = FALSE</code>.</strong>
The option <code>prescale = FALSE</code> only exists for historical reasons.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_postmult">postmult</code></td>
<td>
<p>If <code>TRUE</code>, then it computes
</p>
<p style="text-align: center;"><code class="reqn">Z_{2} = X_{2} \Delta_{2} T \Lambda^{-1/2} T^{\top},</code>
</p>

<p>where <code class="reqn">T</code> contains the eigenvectors and <code class="reqn">\Lambda</code> the eigenvalues
from the eigenvalue decomposition
</p>
<p style="text-align: center;"><code class="reqn">\Xi = \Delta_2 X_{2}^{\top} M_{1} X_{2} \Delta_2 = T \Lambda T^{\top},</code>
</p>

<p>instead of
</p>
<p style="text-align: center;"><code class="reqn">Z_{2} = X_{2} \Delta_{2} T \Lambda^{-1/2}.</code>
</p>

<p>See Huynh (2023b) for more details. The latter is used
in the original MATLAB code for WALS in the linear regression model
(Magnus et al. 2010; De Luca and Magnus 2011; Kumar and Magnus 2013; Magnus and De Luca 2016),
see eq. (12) of Magnus and De Luca (2016).
The first form is required in eq. (9) of De Luca et al. (2018).
It is not recommended to set <code>postmult = FALSE</code> when using <code><a href="#topic+walsGLM">walsGLM</a></code>
and <code><a href="#topic+walsNB">walsNB</a></code>.</p>
</td></tr>
<tr><td><code id="walsFit_+3A_...">...</code></td>
<td>
<p>Arguments for internal function <code><a href="#topic+computePosterior">computePosterior</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>Model averaged estimates of all coefficients.</p>
</td></tr>
<tr><td><code>beta1</code></td>
<td>
<p>Model averaged estimates of the coefficients of the focus regressors.</p>
</td></tr>
<tr><td><code>beta2</code></td>
<td>
<p>Model averaged estimates of the coefficients of the auxiliary regressors.</p>
</td></tr>
<tr><td><code>gamma1</code></td>
<td>
<p>Model averaged estimates of the coefficients of the transformed
focus regressors.</p>
</td></tr>
<tr><td><code>gamma2</code></td>
<td>
<p>Model averaged estimates of the coefficients of the transformed
auxiliary regressors.</p>
</td></tr>
<tr><td><code>vcovBeta</code></td>
<td>
<p>Estimated covariance matrix of the regression coefficients.</p>
</td></tr>
<tr><td><code>vcovGamma</code></td>
<td>
<p>Estimated covariance matrix of the coefficients of the
transformed regressors.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated or prespecified standard deviation of the error term.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p><code>familyPrior</code>. The <code>prior</code> specified in the arguments.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Stores <code>method</code> used from the arguments.</p>
</td></tr>
<tr><td><code>betaUn1</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted
estimators of the coefficients of the focus regressors.</p>
</td></tr>
<tr><td><code>betaUn2</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted
estimators of the coefficients of the auxiliary regressors.</p>
</td></tr>
<tr><td><code>gammaUn1</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted
estimators of the coefficients of the transformed focus regressors.</p>
</td></tr>
<tr><td><code>gammaUn2</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted
estimators of the coefficients of the transformed auxiliary regressors.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Estimated conditional means of the data.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals, i.e. response - fitted mean.</p>
</td></tr>
<tr><td><code>X1names</code></td>
<td>
<p>Names of the focus regressors.</p>
</td></tr>
<tr><td><code>X2names</code></td>
<td>
<p>Names of the auxiliary regressors.</p>
</td></tr>
<tr><td><code>k1</code></td>
<td>
<p>Number of focus regressors.</p>
</td></tr>
<tr><td><code>k2</code></td>
<td>
<p>Number of auxiliary regressors.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>
<p>Condition number of the matrix
<code class="reqn">\Xi = \Delta_{2} X_{2}^{\top} M_{1} X_{2} \Delta_{2}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>De Luca G, Magnus JR (2011).
&ldquo;Bayesian model averaging and weighted-average least squares: Equivariance, stability, and numerical issues.&rdquo;
<em>The Stata Journal</em>, <b>11</b>(4), 518&ndash;544.
<a href="https://doi.org/10.1177/1536867X1201100402">doi:10.1177/1536867X1201100402</a>.<br /><br /> De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.<br /><br /> Kumar K, Magnus JR (2013).
&ldquo;A characterization of Bayesian robustness for a normal location parameter.&rdquo;
<em>Sankhya B</em>, <b>75</b>(2), 216&ndash;237.
<a href="https://doi.org/10.1007/s13571-013-0060-9">doi:10.1007/s13571-013-0060-9</a>.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.<br /><br /> Magnus JR, Powell O, Prfer P (2010).
&ldquo;A comparison of two model averaging techniques with an application to growth empirics.&rdquo;
<em>Journal of Econometrics</em>, <b>154</b>(2), 139-153.
<a href="https://doi.org/10.1016/j.jeconom.2009.07.004">doi:10.1016/j.jeconom.2009.07.004</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+wals">wals</a>, <a href="#topic+walsGLM">walsGLM</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- model.matrix(gdpgrowth ~ lgdp60 + equipinv + school60 + life60 + popgrowth
                  + law + tropics + avelf + confucian, data = GrowthMPP)
X1 &lt;- X[, c("(Intercept)", "lgdp60", "equipinv", "school60", "life60", "popgrowth")]
X2 &lt;- X[, c("law", "tropics", "avelf", "confucian")]
y &lt;- GrowthMPP$gdpgrowth

walsFit(X1, X2, y, prior = weibull(), method = "svd")

</code></pre>

<hr>
<h2 id='walsGLM'>Weighted Average Least Squares for Generalized Linear Models</h2><span id='topic+walsGLM'></span><span id='topic+walsGLM.formula'></span><span id='topic+walsGLM.matrix'></span><span id='topic+walsGLMmatrix'></span><span id='topic+walsGLM.default'></span>

<h3>Description</h3>

<p>Performs model averaging of generalized linear models (GLMs) using the
Weighted-Average Least Squares method described in De Luca et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsGLM(x, ...)

## S3 method for class 'formula'
walsGLM(
  formula,
  family,
  data,
  subset = NULL,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  controlInitGLM = controlGLM(),
  model = TRUE,
  keepY = TRUE,
  keepX = FALSE,
  iterate = FALSE,
  tol = 1e-06,
  maxIt = 50,
  nIt = NULL,
  verbose = FALSE,
  ...
)

## S3 method for class 'matrix'
walsGLM(
  x,
  x2,
  y,
  family,
  subset = NULL,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  controlInitGLM = controlGLM(),
  keepY = TRUE,
  keepX = FALSE,
  iterate = FALSE,
  tol = 1e-06,
  maxIt = 50,
  nIt = NULL,
  verbose = FALSE,
  ...
)

## Default S3 method:
walsGLM(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsGLM_+3A_x">x</code></td>
<td>
<p>Design matrix of focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_...">...</code></td>
<td>
<p>Arguments for workhorse <code><a href="#topic+walsGLMfit">walsGLMfit</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="Formula.html#topic+Formula">Formula</a>"</code>
(or one that can be coerced to that class, e.g. <code>"<a href="stats.html#topic+formula">formula</a>"</code>):
a symbolic description of the model to be fitted.
The details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_family">family</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyWALS">familyWALS</a>"</code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment
(or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model. If not found in <code>data</code>, the variables
are taken from <code>environment(formula)</code>, typically the environment which
the function is called from.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_na.action">na.action</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="walsGLM_+3A_weights">weights</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="walsGLM_+3A_offset">offset</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="walsGLM_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_controlinitglm">controlInitGLM</code></td>
<td>
<p>Controls estimation of starting values for one-step ML,
see <code><a href="#topic+controlGLM">controlGLM</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_model">model</code></td>
<td>
<p>if <code>TRUE</code> (default), then the model.frame is stored in
the return.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_keepy">keepY</code></td>
<td>
<p>if <code>TRUE</code> (default), then the response is stored in
the return.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_keepx">keepX</code></td>
<td>
<p>if <code>TRUE</code>, then the model matrices are stored in the return.
the return.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_iterate">iterate</code></td>
<td>
<p>if <code>TRUE</code> then the WALS algorithm is iterated using the previous
estimates as starting values.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_tol">tol</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>.
If the Euclidean distance between the previous and current coefficient vector
divided by the square root of the length of the vector falls below <code>tol</code>,
then the algorithm stops. See <code><a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a></code> for more details.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_maxit">maxIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>. Aborts
iterative fitting when number of iterations exceed <code>maxIt</code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_nit">nIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code>. If this is specified, then
<code>tol</code> is ignored and the algorithm iterates <code>nIt</code> times. This option
should not be used unless the user has a specific reason to run the algorithm
<code>nIt</code> times, e.g. for replication purposes.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, then it prints the iteration process
(only relevant if <code>iterate = TRUE</code>).</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_x2">x2</code></td>
<td>
<p>Design matrix of auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLM_+3A_y">y</code></td>
<td>
<p>Response as vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes WALS estimates when focus regressors (X1) are present in all
submodels and model averaging takes place over the auxiliary regressors (X2).
</p>
<p>Formulas should always contain two parts, i.e. they should be of the form
&quot;<code>y ~ X11 + X12 | X21 + X22</code>&quot;, where the variables before &quot;<code>|</code>&quot; are
the focus regressors (includes a constant by default) and the ones after
&quot;<code>|</code>&quot; are the auxiliary regressors.
</p>
<p><strong>WARNING:</strong> Interactions in formula do work work properly yet.
It is recommended to manually create the interactions beforehand and then
to insert them as 'linear terms' in the formula.
</p>
<p><code>walsGLM.default()</code> raises an error if <code>x</code> is not an object of class
<code>"matrix"</code> or a class that extends <code>"matrix"</code>. Otherwise it calls
<code>walsGLM.matrix()</code>. It is a modified version of <code>glmboost.default</code>
from the <code>mboost</code> package version 2.9-8 (2023-09-06) (Hofner et al. 2014).
</p>


<h3>Value</h3>

<p><code>walsGLM.formula()</code> returns an object of class <code>"walsGLM"</code>
which inherits from <code>"<a href="#topic+wals">wals</a>"</code>. This is a list that contains
all elements returned from <code><a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a></code> and additionally
</p>
<table>
<tr><td><code>cl</code></td>
<td>
<p>Call of the function.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p><code>formula</code> used.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>List containing the model terms of the focus and auxiliary
regressors separately, as well as for the full model.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>List containing the levels of the focus and auxiliary
regressors separately, as well as for the full model.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>List containing the contrasts of the design matrices of
focus and auxiliary regressors.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>If <code>model = TRUE</code>, contains the model frame.</p>
</td></tr>
</table>
<p>See returns of <code><a href="#topic+walsGLMfit">walsGLMfit</a></code> and <code><a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a></code>
for more details.
</p>
<p><code>walsGLM.matrix()</code> returns an object of class
<code>"walsGLMmatrix"</code>, which inherits from <code>"walsGLM"</code>, <code>"walsMatrix"</code>
and <code>"wals"</code>. This is a list that contains all elements returned from
<code><a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a></code> and additionally the call in <code>cl</code>.
</p>
<p><code>walsGLM.default()</code> raises an error if <code>x</code> is not an object
of class <code>"matrix"</code> or a class that extends <code>"matrix"</code>. Otherwise
returns an object of class <code>"walsGLMmatrix"</code>. See above for more details.
</p>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Hofner B, Mayr A, Robinzonov N, Schmid M (2014).
&ldquo;Model-based Boosting in R: A Hands-on Tutorial Using the R Package mboost.&rdquo;
<em>Computational Statistics</em>, <b>29</b>, 3&ndash;35.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HMDA", package = "AER")
fitBinomial &lt;- walsGLM(deny ~ pirat + hirat + lvrat + chist + mhist + phist |
                       selfemp + afam, data = HMDA, family = binomialWALS(),
                       prior = weibull())
summary(fitBinomial)

data("NMES1988", package = "AER")
fitPoisson &lt;- walsGLM(emergency ~ health + chronic + age + gender |
                      I((age^2)/10) + married + region, data = NMES1988,
                      family = poissonWALS(), prior = laplace())
summary(fitPoisson)

## Example for walsGLM.matrix()
data("HMDA", package = "AER")
X &lt;- model.matrix(deny ~ pirat + hirat + lvrat + chist + mhist + phist + selfemp + afam,
                  data = HMDA)
X1 &lt;- X[,c("(Intercept)", "pirat", "hirat", "lvrat", "chist2", "chist3",
        "chist4", "chist5", "chist6", "mhist2", "mhist3", "mhist4", "phistyes")]
X2 &lt;- X[,c("selfempyes", "afamyes")]
y &lt;- HMDA$deny
fit &lt;- walsGLM(X1, X2, y, family = binomialWALS(), prior = weibull())
summary(fit)

</code></pre>

<hr>
<h2 id='walsGLMfit'>Fitter function for Weighted Average Least Squares estimation of GLMs</h2><span id='topic+walsGLMfit'></span>

<h3>Description</h3>

<p>Workhorse function behind <code><a href="#topic+walsGLM">walsGLM</a></code> and used internally in
<code><a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsGLMfit(
  X1,
  X2,
  y,
  betaStart1,
  betaStart2,
  family,
  prior = weibull(),
  postmult = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsGLMfit_+3A_x1">X1</code></td>
<td>
<p>Design matrix for focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_x2">X2</code></td>
<td>
<p>Design matrix for auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_y">y</code></td>
<td>
<p>Response as vector.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_betastart1">betaStart1</code></td>
<td>
<p>Starting values for coefficients of focus regressors X1.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_betastart2">betaStart2</code></td>
<td>
<p>Starting values for coefficients of auxiliary regressors X2.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_family">family</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyWALS">familyWALS</a>"</code>.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_postmult">postmult</code></td>
<td>
<p>If <code>TRUE</code> (default), then it computes
</p>
<p style="text-align: center;"><code class="reqn">\bar{Z}_{2} = \bar{X}_{2} \bar{\Delta}_{2} \bar{T} \bar{\Lambda}^{-1/2} \bar{T}^{\top},</code>
</p>

<p>where <code class="reqn">\bar{T}</code> contains the eigenvectors and <code class="reqn">\bar{\Lambda}</code> the
eigenvalues from the eigenvalue decomposition
</p>
<p style="text-align: center;"><code class="reqn">\bar{\Xi} = \bar{T} \bar{\Lambda} \bar{T}^{\top},</code>
</p>

<p>instead of
</p>
<p style="text-align: center;"><code class="reqn">\bar{Z}_{2} = \bar{X}_{2} \bar{\Delta}_{2} \bar{T} \bar{\Lambda}^{-1/2}.</code>
</p>

<p>See Huynh (2023b) for more details. The latter is used
in the original MATLAB code for WALS in the linear regression model,
see eq. (12) of Magnus and De Luca (2016).
The first form is required in eq. (9) of De Luca et al. (2018).
<strong>Thus, it is not recommended to set <code>postmult = FALSE</code>.</strong></p>
</td></tr>
<tr><td><code id="walsGLMfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+walsFit">walsFit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+walsFit">walsFit</a></code> under the hood after transforming the regressors
<code>X1</code> and <code>X2</code> and the response <code>y</code>. For more details, see
(Huynh 2023b) and De Luca et al. (2018).
</p>


<h3>Value</h3>

<p>A list containing all elements returned by <code><a href="#topic+walsFit">walsFit</a></code>,
except for <code>residuals</code>, and additionally (some fields are replaced)
</p>
<table>
<tr><td><code>condition</code></td>
<td>
<p>Condition number of the matrix
<code class="reqn">\bar{\Xi} = \bar{\Delta}_{2} \bar{X}_{2}^{\top} \bar{M}_{1} \bar{X}_{2} \bar{\Delta}_{2}</code>.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyWALS">familyWALS</a>"</code>. The family used.</p>
</td></tr>
<tr><td><code>betaStart</code></td>
<td>
<p>Starting values of the regression coefficients for the
one-step ML estimators.</p>
</td></tr>
<tr><td><code>fitted.link</code></td>
<td>
<p>Linear link fitted to the data.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Estimated conditional mean for the data. Lives on the
scale of the response.</p>
</td></tr>
</table>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+walsGLM">walsGLM</a>, <a href="#topic+walsGLMfitIterate">walsGLMfitIterate</a>, <a href="#topic+walsFit">walsFit</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HMDA", package = "AER")
X &lt;- model.matrix(deny ~ pirat + hirat + lvrat + chist + mhist + phist + selfemp + afam,
                  data = HMDA)
X1 &lt;- X[,c("(Intercept)", "pirat", "hirat", "lvrat", "chist2", "chist3",
        "chist4", "chist5", "chist6", "mhist2", "mhist3", "mhist4", "phistyes")]
X2 &lt;- X[,c("selfempyes", "afamyes")]
y &lt;- HMDA$deny

# starting values from glm.fit()
betaStart &lt;- glm.fit(X, y, family = binomialWALS())$coefficients
k1 &lt;- ncol(X1)
k2 &lt;- ncol(X2)

str(walsGLMfit(X1, X2, y,
               betaStart1 = betaStart[1:k1],
               betaStart2 = betaStart[(k1 + 1):(k1 + k2)],
               family = binomialWALS(), prior = weibull()))


</code></pre>

<hr>
<h2 id='walsGLMfitIterate'>Iteratively fitting walsGLM, internal function for walsGLM.formula and
walsGLM.matrix.</h2><span id='topic+walsGLMfitIterate'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="#topic+walsGLMfit">walsGLMfit</a></code> that allows iteratively
(re-)fitting <code><a href="#topic+walsGLM">walsGLM</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsGLMfitIterate(
  y,
  X1,
  X2,
  family,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  controlInitGLM = controlGLM(),
  keepY = TRUE,
  keepX = FALSE,
  iterate = FALSE,
  tol = 1e-06,
  maxIt = 50,
  nIt = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsGLMfitIterate_+3A_y">y</code></td>
<td>
<p>Response as vector.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_x1">X1</code></td>
<td>
<p>Design matrix for focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_x2">X2</code></td>
<td>
<p>Design matrix for auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_family">family</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyWALS">familyWALS</a>"</code>.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_na.action">na.action</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_weights">weights</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_controlinitglm">controlInitGLM</code></td>
<td>
<p>Controls estimation of starting values for one-step ML,
see <code><a href="#topic+controlGLM">controlGLM</a></code>.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_keepy">keepY</code></td>
<td>
<p>If <code>TRUE</code>, then output keeps response.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_keepx">keepX</code></td>
<td>
<p>If <code>TRUE</code>, then output keeps the design matrices.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_iterate">iterate</code></td>
<td>
<p>if <code>TRUE</code> then the WALS algorithm is iterated using the previous
estimates as starting values.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_tol">tol</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>.
If the Euclidean distance between the previous and current coefficient vector
divided by the square root of the length of the vector falls below <code>tol</code>,
then the algorithm stops. See below for more details.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_maxit">maxIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>. Aborts
iterative fitting when number of iterations exceed <code>maxIt</code>.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_nit">nIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code>. If this is specified, then
<code>tol</code> is ignored and the algorithm iterates <code>nIt</code> times.</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, then it prints the iteration process
(only relevant if <code>iterate = TRUE</code>).</p>
</td></tr>
<tr><td><code id="walsGLMfitIterate_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the workhorse function <code><a href="#topic+walsGLMfit">walsGLMfit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>tol</code> is used to control the convergence of the iterative
fitting algorithm. Let <code class="reqn">i</code> be the current iteration step for the
coefficient vector <code class="reqn">\beta_{i} = (\beta_{i,1}, \ldots, \beta_{i,k})', k &gt; 0</code>.
If
</p>
<p style="text-align: center;"><code class="reqn">\frac{||\beta_{i} - \beta_{i-1}||_{2}}{\sqrt{k}}
= \sqrt{\frac{\sum_{j = 1}^{k} (\beta_{i,j} - \beta_{i-1,j})^{2}}{k}} &lt; \texttt{tol},</code>
</p>

<p>then the fitting process is assumed to have converged and stops.
</p>


<h3>Value</h3>

<p>A list containing all elements returned from <code><a href="#topic+walsGLMfit">walsGLMfit</a></code>
and additionally the following elements:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>If <code>keepY = TRUE</code>, contains the response vector.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>list. If <code>keepX = TRUE</code>, then it is a list with elements
<code>x1</code> and <code>x2</code> containing the design matrices of the focus and
auxiliary regressors, respectively.</p>
</td></tr>
<tr><td><code>initialFit</code></td>
<td>
<p>List containing information (e.g. convergence) on the
estimation of the starting values for <code><a href="#topic+walsGLMfit">walsGLMfit</a></code>.
See <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> for more information.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>returns the argument <code>weights</code>.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>returns the argument <code>offset</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical. Only relevant if <code>iterate = TRUE</code>. Equals
<code>TRUE</code> if iterative fitting converged, else <code>FALSE</code>. Is <code>NULL</code>
if <code>iterate = FALSE</code>.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Number of iterations run in the iterative fitting algorithm.
<code>NULL</code> if <code>iterate = FALSE</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the fitted regression model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Raw residuals, i.e. response - fitted mean.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+walsGLM">walsGLM</a>, <a href="#topic+walsGLMfit">walsGLMfit</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HMDA", package = "AER")
X &lt;- model.matrix(deny ~ pirat + hirat + lvrat + chist + mhist + phist + selfemp + afam,
                  data = HMDA)
X1 &lt;- X[,c("(Intercept)", "pirat", "hirat", "lvrat", "chist2", "chist3",
        "chist4", "chist5", "chist6", "mhist2", "mhist3", "mhist4", "phistyes")]
X2 &lt;- X[,c("selfempyes", "afamyes")]
y &lt;- HMDA$deny

str(walsGLMfitIterate(y, X1, X2, family = binomialWALS(), prior = weibull(),
                      iterate = TRUE))

</code></pre>

<hr>
<h2 id='walsNB'>Weighted-Average Least Squares for Negative Binomial Regression</h2><span id='topic+walsNB'></span><span id='topic+walsNB.formula'></span><span id='topic+walsNB.matrix'></span><span id='topic+walsNBmatrix'></span><span id='topic+walsNB.default'></span>

<h3>Description</h3>

<p>Performs model averaging for NB2 regression models using the Weighted-Average
Least Squares method of Huynh (2023a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsNB(x, ...)

## S3 method for class 'formula'
walsNB(
  formula,
  data,
  subset = NULL,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  link = "log",
  prior = weibull(),
  controlInitNB = controlNB(),
  model = TRUE,
  keepY = TRUE,
  keepX = FALSE,
  iterate = FALSE,
  tol = 1e-06,
  maxIt = 50,
  nIt = NULL,
  verbose = FALSE,
  ...
)

## S3 method for class 'matrix'
walsNB(
  x,
  x2,
  y,
  link = "log",
  subset = NULL,
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  controlInitNB = controlNB(),
  model = TRUE,
  keepY = TRUE,
  keepX = FALSE,
  iterate = FALSE,
  tol = 1e-06,
  maxIt = 50,
  nIt = NULL,
  verbose = FALSE,
  ...
)

## Default S3 method:
walsNB(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsNB_+3A_x">x</code></td>
<td>
<p>Design matrix of focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_...">...</code></td>
<td>
<p>Arguments for workhorse <code><a href="#topic+walsNBfit">walsNBfit</a></code>.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="Formula.html#topic+Formula">Formula</a>"</code>
(or one that can be coerced to that class, e.g. <code>"<a href="stats.html#topic+formula">formula</a>"</code>):
a symbolic description of the model to be fitted.
The details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment
(or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model. If not found in <code>data</code>, the variables
are taken from <code>environment(formula)</code>, typically the environment which
the function is called from.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_na.action">na.action</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="walsNB_+3A_weights">weights</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="walsNB_+3A_offset">offset</code></td>
<td>
<p><strong>not implemented yet.</strong></p>
</td></tr>
<tr><td><code id="walsNB_+3A_link">link</code></td>
<td>
<p>specifies the link function, currently only <code>"log"</code> is supported.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_controlinitnb">controlInitNB</code></td>
<td>
<p>Controls estimation of starting values for one-step ML,
see <code><a href="#topic+controlNB">controlNB</a></code>.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_model">model</code></td>
<td>
<p>if <code>TRUE</code> (default), then the model.frame is stored in
the return.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_keepy">keepY</code></td>
<td>
<p>if <code>TRUE</code> (default), then the response is stored in
the return.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_keepx">keepX</code></td>
<td>
<p>if <code>TRUE</code>, then the model matrices are stored in the return.
the return.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_iterate">iterate</code></td>
<td>
<p>if <code>TRUE</code> then the WALS algorithm is iterated using the previous
estimates as starting values.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_tol">tol</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>. If the
Euclidean distance between the previous and current coefficient vector divided
by the square root of the length of the vector falls below <code>tol</code> and the
absolute difference between the previous and current dispersion parameter
falls below <code>tol</code>, then the algorithm stops.
See <code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code> for more details.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_maxit">maxIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>. Aborts
iterative fitting when number of iterations exceed <code>maxIt</code>.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_nit">nIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code>. If this is specified, then
<code>tol</code> is ignored and the algorithm iterates <code>nIt</code> times. This option
should not be used unless the user has a specific reason to run the algorithm
<code>nIt</code> times, e.g. for replication purposes.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, then it prints the iteration process
of internal function <code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code>
(only relevant if <code>iterate = TRUE</code>).</p>
</td></tr>
<tr><td><code id="walsNB_+3A_x2">x2</code></td>
<td>
<p>Design matrix of auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsNB_+3A_y">y</code></td>
<td>
<p>Count response as vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes WALS estimates when focus regressors (X1) are present in all
submodels and model averaging takes place over the auxiliary regressors (X2).
</p>
<p>Formulas should always contain two parts, i.e. they should be of the form
&quot;<code>y ~ X11 + X12 | X21 + X22</code>&quot;, where the variables before &quot;<code>|</code>&quot; are
the focus regressors (includes a constant by default) and the ones after
&quot;<code>|</code>&quot; are the auxiliary regressors.
</p>
<p><strong>WARNING:</strong> Interactions in formula do not work properly yet.
It is recommended to manually create the interactions beforehand and then
to insert them as 'linear terms' in the formula.
</p>
<p>See <code><a href="#topic+predict.walsGLM">predict.walsGLM</a></code> and <code><a href="#topic+predict.wals">predict.wals</a></code>
for some class methods that the fitted objects inherit from
<code>"<a href="#topic+walsGLM">walsGLM</a>"</code> and <code>"<a href="#topic+wals">wals</a>"</code>, respectively.
</p>
<p><code>walsNB.default()</code> raises an error if <code>x</code> is not an object of class
<code>"matrix"</code> or a class that extends <code>"matrix"</code>. Otherwise
it calls <code>walsNB.matrix()</code>. It is a modified version of <code>glmboost.default</code>
from the <code>mboost</code> package version 2.9-8 (2023-09-06) (Hofner et al. 2014).
</p>


<h3>Value</h3>

<p><code>walsNB.formula()</code> returns an object of class <code>"walsNB"</code>
which inherits from <code>"walsGLM"</code> and <code>"wals"</code>. This is a list that
contains all elements returned from <code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code> and
additionally
</p>
<table>
<tr><td><code>cl</code></td>
<td>
<p>Call of the function.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p><code>formula</code> used.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>List containing the model terms of the focus and auxiliary
regressors separately, as well as for the full model.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>List containing the levels of the focus and auxiliary
regressors separately, as well as for the full model.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>List containing the contrasts of the design matrices of
focus and auxiliary regressors.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>If <code>model = TRUE</code>, contains the model frame.</p>
</td></tr>
</table>
<p>See returns of <code><a href="#topic+walsNBfit">walsNBfit</a></code> and <code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code>
for more details.
</p>
<p><code>walsNB.matrix()</code> returns an object of class <code>"walsNBmatrix"</code>,
which inherits from <code>"walsNB"</code>, <code>"walsGLMmatrix"</code>, <code>"walsGLM"</code>
and <code>"wals"</code>. This is a list that contains all elements returned from
<code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code> and additionally the call in <code>cl</code>.
</p>
<p><code>walsNB.default()</code> raises an error if <code>x</code> is not an object
of class <code>"matrix"</code> or a class that extends <code>"matrix"</code>. Otherwise
returns an object of class <code>"walsNBmatrix"</code>. See above for more details.
</p>


<h3>References</h3>

<p>Hofner B, Mayr A, Robinzonov N, Schmid M (2014).
&ldquo;Model-based Boosting in R: A Hands-on Tutorial Using the R Package mboost.&rdquo;
<em>Computational Statistics</em>, <b>29</b>, 3&ndash;35.<br /><br /> Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for walsNB.formula()
data("NMES1988", package = "AER")

fitWeibull &lt;- walsNB(visits ~ health + chronic + age + gender | I((age^2)/10) +
                     married + region, data = NMES1988, prior = weibull())
summary(fitWeibull)

fitLaplace &lt;- walsNB(visits ~ health + chronic + age + gender | I((age^2)/10) +
                     married + region, data = NMES1988, prior = laplace())
summary(fitLaplace)

## Example for walsNB.matrix()
data("NMES1988", package = "AER")
X &lt;- model.matrix(visits ~ health + chronic + age + gender + married + region,
                  data = NMES1988)
X1 &lt;- X[, c("(Intercept)", "healthpoor", "healthexcellent", "chronic",
        "age", "gendermale")]
X2 &lt;- X[, c("marriedyes", "regionnortheast", "regionmidwest", "regionwest")]
y &lt;- NMES1988$visits
fit &lt;- walsNB(X1, X2, y, prior = weibull())
summary(fit)

</code></pre>

<hr>
<h2 id='walsNBfit'>Fitter function for Weighted Average Least Squares estimation of NB2 regression model</h2><span id='topic+walsNBfit'></span>

<h3>Description</h3>

<p>Workhorse function behind <code><a href="#topic+walsNB">walsNB</a></code> and used internally in
<code><a href="#topic+walsNBfitIterate">walsNBfitIterate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsNBfit(
  X1,
  X2,
  y,
  betaStart1,
  betaStart2,
  rhoStart,
  family,
  prior,
  method = c("fullSVD", "original"),
  svdTol = .Machine$double.eps,
  svdRtol = 1e-06,
  keepUn = FALSE,
  keepR = FALSE,
  eigenSVD = TRUE,
  postmult = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsNBfit_+3A_x1">X1</code></td>
<td>
<p>Design matrix for focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_x2">X2</code></td>
<td>
<p>Design matrix for auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_y">y</code></td>
<td>
<p>Count response as vector.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_betastart1">betaStart1</code></td>
<td>
<p>Starting values for coefficients of focus regressors X1.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_betastart2">betaStart2</code></td>
<td>
<p>Starting values for coefficients of auxiliary regressors X2.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_rhostart">rhoStart</code></td>
<td>
<p>Starting value for log-dispersion parameter of NB2</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_family">family</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyNBWALS">familyNBWALS</a>"</code>. Currently only supports
<code><a href="#topic+negbinWALS">negbinWALS</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_method">method</code></td>
<td>
<p>Specifies method used. Available methods are <code>"fullSVD"</code>
(default) or <code>"original"</code>. See details.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_svdtol">svdTol</code></td>
<td>
<p>Tolerance for rank of matrix <code class="reqn">\bar{Z}_{1}</code> and <code class="reqn">\bar{Z}</code>.
Only used if <code>method = "fullSVD"</code>.
Checks if smallest eigenvalue in SVD of <code class="reqn">\bar{Z}_1</code> and <code class="reqn">\bar{Z}</code>
is larger than <code>svdTol</code>, otherwise reports a rank deficiency.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_svdrtol">svdRtol</code></td>
<td>
<p>Relative tolerance for rank of matrix <code class="reqn">\bar{Z}_{1}</code> and <code class="reqn">\bar{Z}</code>.
Only used if <code>method = "fullSVD"</code>. Checks if ratio of largest to smallest
eigenvalue in SVD of <code class="reqn">\bar{Z}_1</code> and <code class="reqn">\bar{Z}</code> is larger than
<code>svdRtol</code>, otherwise reports a rank deficiency.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_keepun">keepUn</code></td>
<td>
<p>If <code>TRUE</code>, keeps the one-step ML estimators of the
unrestricted model, i.e. <code class="reqn">\tilde{\gamma}_{u}</code> and <code class="reqn">\tilde{\beta}_{u}</code>.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_keepr">keepR</code></td>
<td>
<p>If <code>TRUE</code>, keeps the one-step ML estimators of the fully
restricted model, i.e. <code class="reqn">\tilde{\gamma}_{r}</code> and <code class="reqn">\tilde{\beta}_{r}</code>.</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_eigensvd">eigenSVD</code></td>
<td>
<p>If <code>TRUE</code>, then <code>semiorthogonalize()</code> uses <code>svd()</code>
to compute the eigendecomposition of <code class="reqn">\bar{\Xi}</code> instead of <code>eigen()</code>.
In this case, the tolerances of <code>svdTol</code> and <code>svdRtol</code> are used to
determine whether <code class="reqn">\bar{\Xi}</code> is of full rank (need it for <code class="reqn">\bar{\Xi}^{-1/2}</code>).</p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_postmult">postmult</code></td>
<td>
<p>If <code>TRUE</code> (default), then it computes
</p>
<p style="text-align: center;"><code class="reqn">\bar{Z}_{2} = \bar{X}_{2} \bar{\Delta}_{2} \bar{T} \bar{\Lambda}^{-1/2} \bar{T}^{\top},</code>
</p>

<p>where <code class="reqn">\bar{T}</code> contains the eigenvectors and <code class="reqn">\bar{\Lambda}</code> the
eigenvalues from the eigenvalue decomposition
</p>
<p style="text-align: center;"><code class="reqn">\bar{\Xi} = \bar{T} \bar{\Lambda} \bar{T}^{\top},</code>
</p>

<p>instead of
</p>
<p style="text-align: center;"><code class="reqn">\bar{Z}_{2} = \bar{X}_{2} \bar{\Delta}_{2} \bar{T} \bar{\Lambda}^{-1/2}.</code>
</p>

<p>See Huynh (2023b) for more details. The latter is used
in the original MATLAB code for WALS in the linear regression model,
see eq. (12) of Magnus and De Luca (2016).
The first form is required in eq. (9) of De Luca et al. (2018).
<strong>Thus, it is not recommended to set <code>postmult = FALSE</code>.</strong></p>
</td></tr>
<tr><td><code id="walsNBfit_+3A_...">...</code></td>
<td>
<p>Arguments for internal function <code><a href="#topic+computePosterior">computePosterior</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method to be specified in <code>method</code> mainly differ in the way
they compute the fully restricted and unrestricted estimators for the
transformed regressors <code class="reqn">Z</code>, i.e. <code class="reqn">\tilde{\gamma}_{1r}</code>,
and <code class="reqn">\tilde{\gamma}_{u}</code>.
</p>

<dl>
<dt>&quot;fullSVD&quot;</dt><dd><p>Recommended approach. First applies an SVD to <code class="reqn">\bar{Z}_{1}</code>
to compute <code class="reqn">\bar{X}_{2}^{\top} \bar{M}_{1} \bar{X}_{2}</code>:
It is used for computing the inverse of
</p>
<p style="text-align: center;"><code class="reqn">\bar{X}_{1}^{\top}\bar{X}_{1}
 + \bar{g} \bar{\epsilon} X_{1}^{\top}\bar{q} \bar{q}^{\top} X_{1},</code>
</p>

<p>when using the Sherman-Morrison-Woodbury formula. We further leverage the
SVD of <code class="reqn">\bar{Z}_1</code> and additionally <code class="reqn">\bar{Z}</code> to compute the
unrestricted estimator <code class="reqn">\tilde{\gamma}_{u}</code> and the fully restricted
estimator <code class="reqn">\tilde{\gamma}_{r}</code>. For <code class="reqn">\tilde{\gamma}_{u}</code>, we simply
use the SVD of <code class="reqn">\bar{Z}</code> to solve the full equation system derived from
the one-step ML problem for more details. The SVD of <code class="reqn">\bar{Z}_1</code> is further
used in computing the model averaged estimator for the focus regressors
<code class="reqn">\hat{\gamma}_1</code>.
</p>
<p>Described in more detail in the appendix of Huynh (2023b).</p>
</dd>
<dt>&quot;original&quot;</dt><dd><p>Computes all inverses directly using <code><a href="base.html#topic+solve">solve</a></code>
and does not make use of the Sherman-Morrison-Woodbury formula for certain
inverses. Specifically, it directly inverts the matrix
<code class="reqn">\bar{Z}_{1}^{\top} \bar{Z}_{1}</code> using <code><a href="base.html#topic+solve">solve</a></code>
in order to compute <code class="reqn">\bar{M}_1</code>. Moreover, it computes the fully
unrestricted estimators of the focus regressors
<code class="reqn">\tilde{\gamma}_{1u}</code> and of the auxiliary regressors
<code class="reqn">\tilde{\gamma}_{2u}</code> and the fully restricted estimator
<code class="reqn">\tilde{\gamma}_{1r}</code> by directly implementing the formulas derived
in Huynh (2023a).
This method should only be used as reference and for easier
debugging.</p>
</dd>
</dl>

<p>All variables in the code that contain &quot;start&quot; in their name are computed
using the starting values of the one-step ML estimators. See section
&quot;One-step ML estimator&quot; of (Huynh 2023a) for details.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>Model averaged estimates of all coefficients.</p>
</td></tr>
<tr><td><code>beta1</code></td>
<td>
<p>Model averaged estimates of the coefficients of the focus regressors.</p>
</td></tr>
<tr><td><code>beta2</code></td>
<td>
<p>Model averaged estimates of the coefficients of the auxiliary regressors.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Model averaged estimate of the log-dispersion parameter of the
NB2 distribution.</p>
</td></tr>
<tr><td><code>gamma1</code></td>
<td>
<p>Model averaged estimates of the coefficients of the transformed
focus regressors.</p>
</td></tr>
<tr><td><code>gamma2</code></td>
<td>
<p>Model averaged estimates of the coefficients of the transformed
auxiliary regressors.</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>
<p>Condition number of the matrix
<code class="reqn">\bar{\Xi} = \bar{\Delta}_{2} \bar{X}_{2}^{\top} \bar{M}_{1} \bar{X}_{2} \bar{\Delta}_{2}</code>.</p>
</td></tr>
<tr><td><code>vcovBeta</code></td>
<td>
<p><code>NULL</code>, not implemented yet, placeholder for estimated
covariance matrix of the regression coefficients.</p>
</td></tr>
<tr><td><code>vcovGamma</code></td>
<td>
<p><code>NULL</code>, not implemented yet, placeholder for estimated
covariance matrix of the coefficients of the transformed regressors.</p>
</td></tr>
<tr><td><code>betaStart</code></td>
<td>
<p>Starting values of the regression coefficients for the
one-step ML estimators.</p>
</td></tr>
<tr><td><code>rhoStart</code></td>
<td>
<p>Starting values of the dispersion parameter for the
one-step ML estimators.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Stores <code>method</code> used from the arguments.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p><code>familyPrior</code>. The <code>prior</code> specified in the arguments.</p>
</td></tr>
<tr><td><code>betaUn1</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted one-step ML
estimators of the coefficients of the focus regressors. Else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>betaUn2</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted one-step ML
estimators of the coefficients of the auxiliary regressors. Else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>gammaUn1</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted one-step ML
estimators of the coefficients of the transformed focus regressors. Else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>gammaUn2</code></td>
<td>
<p>If <code>keepUn = TRUE</code>, contains the unrestricted one-step ML
estimators of the coefficients of the transformed auxiliary regressors. Else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>gamma1r</code></td>
<td>
<p>If <code>keepR = TRUE</code>, contains the fully restricted one-step
ML estimator for the transformed regressors (only focus regressors).
Else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>k1</code></td>
<td>
<p>Number of focus regressors.</p>
</td></tr>
<tr><td><code>k2</code></td>
<td>
<p>Number of auxiliary regressors.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>X1names</code></td>
<td>
<p>Names of the focus regressors.</p>
</td></tr>
<tr><td><code>X2names</code></td>
<td>
<p>Names of the auxiliary regressors.</p>
</td></tr>
<tr><td><code>familyStart</code></td>
<td>
<p>The family object of class <code>"<a href="#topic+familyNBWALS">familyNBWALS</a>"</code> used for the
estimation of the starting values.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family object of class <code>"<a href="#topic+familyNBWALS">familyNBWALS</a>"</code> used later for predictions.</p>
</td></tr>
<tr><td><code>fitted.link</code></td>
<td>
<p>Linear link fitted to the data.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Estimated conditional mean for the data. Lives on the
scale of the response.</p>
</td></tr>
</table>


<h3>References</h3>

<p>De Luca G, Magnus JR, Peracchi F (2018).
&ldquo;Weighted-average least squares estimation of generalized linear models.&rdquo;
<em>Journal of Econometrics</em>, <b>204</b>(1), 1&ndash;17.
<a href="https://doi.org/10.1016/j.jeconom.2017.12.007">doi:10.1016/j.jeconom.2017.12.007</a>.<br /><br /> Huynh K (2023a).
&ldquo;Weighted-Average Least Squares for Negative Binomial Regression.&rdquo;
University of Basel.
Mimeo.<br /><br /> Huynh K (2023b).
&ldquo;WALS: Weighted-Average Least Squares Model Averaging in R.&rdquo;
University of Basel.
Mimeo.<br /><br /> Magnus JR, De Luca G (2016).
&ldquo;Weighted-average least squares (WALS): A survey.&rdquo;
<em>Journal of Economic Surveys</em>, <b>30</b>(1), 117-148.
<a href="https://doi.org/10.1111/joes.12094">doi:10.1111/joes.12094</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+walsNB">walsNB</a>, <a href="#topic+walsNBfitIterate">walsNBfitIterate</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NMES1988", package = "AER")
NMES1988 &lt;- na.omit(NMES1988)
form &lt;- (visits ~ health + chronic + age + insurance + adl + region + gender
         + married + income + school + employed)
X &lt;- model.matrix(form, data = NMES1988)
focus &lt;- c("(Intercept)", "healthpoor", "healthexcellent", "chronic", "age",
        "insuranceyes")
aux &lt;- c("adllimited", "regionnortheast", "regionmidwest", "regionwest",
         "gendermale", "marriedyes", "income", "school", "employedyes")
X1 &lt;- X[, focus]
X2 &lt;- X[, aux]
y &lt;- NMES1988$visits

# starting values from glm.nb() from MASS
startFit &lt;- MASS::glm.nb(y ~ X[,-1])
betaStart &lt;- coef(startFit)
rhoStart &lt;- startFit$theta
k1 &lt;- ncol(X1)
k2 &lt;- ncol(X2)

str(walsNBfit(X1, X2, y, rhoStart, family = negbinWALS(scale = rhoStart, link = "log"),
              betaStart1 = betaStart[1:k1],
              betaStart2 = betaStart[(k1 + 1):(k1 + k2)],
              prior = weibull(), method = "fullSVD"))

</code></pre>

<hr>
<h2 id='walsNBfitIterate'>Iteratively fitting walsNB, internal function for walsNB.formula and
walsNB.matrix.</h2><span id='topic+walsNBfitIterate'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="#topic+walsNBfit">walsNBfit</a></code> that allows iteratively
(re-)fitting <code><a href="#topic+walsNB">walsNB</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walsNBfitIterate(
  y,
  X1,
  X2,
  link = "log",
  na.action = NULL,
  weights = NULL,
  offset = NULL,
  prior = weibull(),
  controlInitNB = controlNB(),
  keepY = TRUE,
  keepX = FALSE,
  iterate = FALSE,
  tol = 1e-06,
  maxIt = 50,
  nIt = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walsNBfitIterate_+3A_y">y</code></td>
<td>
<p>Count response as vector.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_x1">X1</code></td>
<td>
<p>Design matrix for focus regressors. Usually includes a constant
(column full of 1s) and can be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_x2">X2</code></td>
<td>
<p>Design matrix for auxiliary regressors. Usually does not include
a constant column and can also be generated using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_link">link</code></td>
<td>
<p>specifies the link function, currently only &quot;log&quot; is supported.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_na.action">na.action</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_weights">weights</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_offset">offset</code></td>
<td>
<p>Not implemented yet.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_prior">prior</code></td>
<td>
<p>Object of class <code>"<a href="#topic+familyPrior">familyPrior</a>"</code>. For example
<code><a href="#topic+weibull">weibull</a></code> or <code><a href="#topic+laplace">laplace</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_controlinitnb">controlInitNB</code></td>
<td>
<p>Controls estimation of starting values for one-step ML,
see <code><a href="#topic+controlNB">controlNB</a></code>.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_keepy">keepY</code></td>
<td>
<p>If <code>TRUE</code>, then output keeps response.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_keepx">keepX</code></td>
<td>
<p>If <code>TRUE</code>, then output keeps the design matrices.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_iterate">iterate</code></td>
<td>
<p>if <code>TRUE</code> then the WALS algorithm is iterated using the previous
estimates as starting values.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_tol">tol</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>. If the
Euclidean distance between the previous and current coefficient vector divided
by the square root of the length of the vector falls below <code>tol</code> and the
absolute difference between the previous and current dispersion parameter
falls below <code>tol</code>, then the algorithm stops. See below for more details.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_maxit">maxIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code> and <code>nIt = NULL</code>. Aborts
iterative fitting when number of iterations exceed <code>maxIt</code>.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_nit">nIt</code></td>
<td>
<p>Only used if <code>iterate = TRUE</code>. If this is specified, then
<code>tol</code> is ignored and the algorithm iterates <code>nIt</code> times.</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, then it prints the iteration process
(only relevant if <code>iterate = TRUE</code>).</p>
</td></tr>
<tr><td><code id="walsNBfitIterate_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the workhorse function <code><a href="#topic+walsNBfit">walsNBfit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>tol</code> is used to control the convergence of the iterative
fitting algorithm. Let <code class="reqn">i</code> be the current iteration step for the
coefficient vector <code class="reqn">\beta_{i} = (\beta_{i,1}, \ldots, \beta_{i,k})'</code>,
<code class="reqn">k &gt; 0</code>, and dispersion parameter <code class="reqn">\rho_{i}</code>. If
</p>
<p style="text-align: center;"><code class="reqn">\frac{||\beta_{i} - \beta_{i-1}||_{2}}{\sqrt{k}}
= \sqrt{\frac{\sum_{j = 1}^{k} (\beta_{i,j} - \beta_{i-1,j})^{2}}{k}} &lt; \texttt{tol},</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">|\rho_{i} - \rho_{i-1}| &lt; \texttt{tol},</code>
</p>

<p>then the fitting process is assumed to have converged and stops.
</p>


<h3>Value</h3>

<p>A list containing all elements returned from <code><a href="#topic+walsNBfit">walsNBfit</a></code>
and additionally the following elements:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>If <code>keepY = TRUE</code>, contains the response vector.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>list. If <code>keepX = TRUE</code>, then it is a list with elements
<code>x1</code> and <code>x2</code> containing the design matrices of the focus and
auxiliary regressors, respectively.</p>
</td></tr>
<tr><td><code>initialFit</code></td>
<td>
<p>List containing information (e.g. convergence) on the
estimation of the starting values for <code><a href="#topic+walsNBfit">walsNBfit</a></code>.
See return of <code><a href="#topic+fitNB2">fitNB2</a></code> for more information.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>returns the argument <code>weights</code>.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>returns the argument <code>offset</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical. Only relevant if <code>iterate = TRUE</code>. Equals
<code>TRUE</code> if iterative fitting converged, else <code>FALSE</code>. Is <code>NULL</code>
if <code>iterate = FALSE</code>.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Number of iterations run in the iterative fitting algorithm.
<code>NULL</code> if <code>iterate = FALSE</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the fitted (conditional) NB2 regression model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Raw residuals, i.e. response - fitted mean.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+walsNB">walsNB</a>, <a href="#topic+walsNBfit">walsNBfit</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NMES1988", package = "AER")
NMES1988 &lt;- na.omit(NMES1988)
form &lt;- (visits ~ health + chronic + age + insurance + adl + region + gender
         + married + income + school + employed)
X &lt;- model.matrix(form, data = NMES1988)
focus &lt;- c("(Intercept)", "healthpoor", "healthexcellent", "chronic", "age",
        "insuranceyes")
aux &lt;- c("adllimited", "regionnortheast", "regionmidwest", "regionwest",
         "gendermale", "marriedyes", "income", "school", "employedyes")
X1 &lt;- X[, focus]
X2 &lt;- X[, aux]
y &lt;- NMES1988$visits

str(walsNBfitIterate(y, X1, X2, prior = weibull(), link = "log",
                     method = "fullSVD", iterate = TRUE))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
