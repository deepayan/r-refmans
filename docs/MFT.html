<!DOCTYPE html><html lang="en"><head><title>Help for package MFT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MFT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MFT.filterdata'><p>MFT.filterdata</p></a></li>
<li><a href='#MFT.m_est'><p>MFT.m_est</p></a></li>
<li><a href='#MFT.mean'><p>MFT.mean</p></a></li>
<li><a href='#MFT.peaks'><p>MFT.peaks</p></a></li>
<li><a href='#MFT.rate'><p>MFT.rate</p></a></li>
<li><a href='#MFT.variance'><p>MFT.variance</p></a></li>
<li><a href='#plot.MFT'><p>plot.MFT</p></a></li>
<li><a href='#summary.MFT'><p>summary.MFT</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Multiple Filter Test for Change Point Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-03-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Messer, Stefan Albert, Solveig Plomer, Gaby Schneider</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Messer &lt;messer@math.uni-frankfurt.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical tests and algorithms for the detection of change points in time series and point processes - particularly for changes in the mean in time series and for changes in the rate and in the variance in point processes. References - Michael Messer, Marietta Kirchner, Julia Schiemann, Jochen Roeper, Ralph Neininger and Gaby Schneider (2014), A multiple filter test for the detection of rate changes in renewal processes with varying variance &lt;<a href="https://doi.org/10.1214%2F14-AOAS782">doi:10.1214/14-AOAS782</a>&gt;. Stefan Albert, Michael Messer, Julia Schiemann, Jochen Roeper, Gaby Schneider (2017), Multi-scale detection of variance changes in renewal processes in the presence of rate change points &lt;<a href="https://doi.org/10.1111%2Fjtsa.12254">doi:10.1111/jtsa.12254</a>&gt;. Michael Messer, Kaue M. Costa, Jochen Roeper and Gaby Schneider (2017), Multi-scale detection of rate changes in spike trains with weak dependencies &lt;<a href="https://doi.org/10.1007%2Fs10827-016-0635-3">doi:10.1007/s10827-016-0635-3</a>&gt;. Michael Messer, Stefan Albert and Gaby Schneider (2018), The multiple filter test for change point detection in time series &lt;<a href="https://doi.org/10.1007%2Fs00184-018-0672-1">doi:10.1007/s00184-018-0672-1</a>&gt;. Michael Messer, Hendrik Backhaus, Albrecht Stroh and Gaby Schneider (2019+) Peak detection in time series.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-11 18:08:51 UTC; messer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-11 20:42:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='MFT.filterdata'>MFT.filterdata</h2><span id='topic+MFT.filterdata'></span>

<h3>Description</h3>

<p>Naive routine to remove trend from the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFT.filterdata(x, filterwidth = NULL, filtersigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFT.filterdata_+3A_x">x</code></td>
<td>
<p>numeric vector, input sequence of random variables.</p>
</td></tr>
<tr><td><code id="MFT.filterdata_+3A_filterwidth">filterwidth</code></td>
<td>
<p>postive interger, &lt; length(x)/2, number of data points left and right of the current value that are taken into account for Gaussian smoothing.</p>
</td></tr>
<tr><td><code id="MFT.filterdata_+3A_filtersigma">filtersigma</code></td>
<td>
<p>numeric, &gt; 0, standard deviation of Gassian kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible
</p>
<table role = "presentation">
<tr><td><code>xfiltered</code></td>
<td>
<p>filtered data (for filtering the first and last (filterwidth many) data points of the original series cannot be evaluated and are omited)</p>
</td></tr>
<tr><td><code>xraw</code></td>
<td>
<p>orignal data, but the first and last (filterwidth many) data point are omitted</p>
</td></tr>
<tr><td><code>xtrend</code></td>
<td>
<p>trend that is removed by filtering. That is xfiltered = xraw - xtrend</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>orignal data</p>
</td></tr>
<tr><td><code>filterwidth</code></td>
<td>
<p>number of data points left and right of the current value that are taken into account for Gaussian smoothing</p>
</td></tr>
<tr><td><code>filtersigma</code></td>
<td>
<p>standard deviation of the Gaussian kernel</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Hendrik Backhaus, Albrecht Stroh and Gaby Schneider (2019+). Peak detection in times series
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.peaks">MFT.peaks</a>, <a href="#topic+plot.MFT">plot.MFT</a>, <a href="#topic+summary.MFT">summary.MFT</a>, <a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+MFT.variance">MFT.variance</a>, <a href="#topic+MFT.mean">MFT.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
# Normally distributed sequence with negative trend
x &lt;- rnorm(1000,mean=seq(5,0,length.out=1000))
MFT.filterdata(x)
MFT.filterdata(x,filterwidth=200,filtersigma=200)

</code></pre>

<hr>
<h2 id='MFT.m_est'>MFT.m_est</h2><span id='topic+MFT.m_est'></span>

<h3>Description</h3>

<p>Naive routine for the estimation of the order of serial correlation (m-dependence) in point processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFT.m_est(Phi, n = 200, maxlag = 10, alpha = 0.05, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFT.m_est_+3A_phi">Phi</code></td>
<td>
<p>point process, vector of time stamps</p>
</td></tr>
<tr><td><code id="MFT.m_est_+3A_n">n</code></td>
<td>
<p>positive integer, number of life times used in segments for estimation of serial correlation</p>
</td></tr>
<tr><td><code id="MFT.m_est_+3A_maxlag">maxlag</code></td>
<td>
<p>non-negative integer, maximal lag up to which serial correlations are calculated</p>
</td></tr>
<tr><td><code id="MFT.m_est_+3A_alpha">alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td></tr>
<tr><td><code id="MFT.m_est_+3A_plot">plot</code></td>
<td>
<p>logical, if TRUE, estimation procedure is plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>m_est</code></td>
<td>
<p>non-negative integer, estimated order of serial correlation (m-dependence)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Kaue M. Costa, Jochen Roeper and Gaby Schneider (2017).
Multi-scale detection of rate changes in spike trains with weak dependencies. Journal of Computational Neuroscience, 42 (2), 187-201.
&lt;doi:10.1007/s10827-016-0635-3&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+plot.MFT">plot.MFT</a>, <a href="#topic+summary.MFT">summary.MFT</a>, <a href="#topic+MFT.variance">MFT.variance</a>, <a href="#topic+MFT.mean">MFT.mean</a>, <a href="#topic+MFT.peaks">MFT.peaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Independent life times (m=0)
set.seed(117)
n &lt;- 5000
Phi1 &lt;- cumsum(rexp(n,3.5))
Phi2 &lt;- cumsum(rexp(n,5))
Phi3 &lt;- cumsum(rexp(n,2))
Phi  &lt;- c(Phi1[Phi1&lt;=200],Phi2[Phi2&gt;200 &amp; Phi2&lt;400],Phi3[Phi3&gt;400 &amp; Phi3&lt;700])
MFT.m_est(Phi)

# 2. Point process simulated according to model
# X_i = a_0 X_i + a_1 X_{i-1} + ... a_m X_{i-m}
# with life times X_i gamma-distributed, 2 change points and true m = 3.
set.seed(210)
Tt &lt;- 3000
m &lt;- 3
a &lt;- c(1,0.5,0.25,0.125)
mu &lt;- c(0.5,1,2)/(sum(a))
sigmaX &lt;- sqrt(0.225/(sum(a^2)))
shape &lt;- mu^2/sigmaX^2; rate &lt;- mu/sigmaX^2
len &lt;- 10000
# build auxiliary processes
X1 &lt;- rgamma(len,rate=rate[1],shape=shape[1]); M1 &lt;- embed(X1,m+1)
v1 &lt;- cumsum(as.vector(M1 %*% a)); v1 &lt;- v1[v1&lt;Tt]
X2 &lt;- rgamma(len,rate=rate[2],shape=shape[2]); M2 &lt;- embed(X2,m+1)
v2 &lt;- cumsum(as.vector(M2 %*% a)); v2 &lt;- v2[v2&lt;Tt]
X3 &lt;- rgamma(len,rate=rate[3],shape=shape[3]); M3 &lt;- embed(X3,m+1)
v3 &lt;- cumsum(as.vector(M3 %*% a)); v3 &lt;- v3[v3&lt;Tt]
# build final point process with cps at 100 and 200
Phi &lt;- c(v1[v1&lt;Tt/3],v2[v2&gt;Tt/3 &amp; v2&lt;(2/3)*Tt],v3[v3&gt;(2/3)*Tt])
# estimate m
MFT.m_est(Phi)

</code></pre>

<hr>
<h2 id='MFT.mean'>MFT.mean</h2><span id='topic+MFT.mean'></span>

<h3>Description</h3>

<p>The multiple filter test for mean change detection in time series or sequences of random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFT.mean(X, autoset.H = TRUE, S = NULL, E = NULL, H = NULL,
  alpha = 0.05, method = "asymptotic", sim = 10000,
  rescale = FALSE, Q = NA, perform.CPD = TRUE, print.output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFT.mean_+3A_x">X</code></td>
<td>
<p>numeric vector, input sequence of random variables</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_autoset.h">autoset.H</code></td>
<td>
<p>logical, automatic choice of window size H</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_s">S</code></td>
<td>
<p>numeric, start of time interval, default: NULL, if NULL then 1 is chosen</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_e">E</code></td>
<td>
<p>numeric, end of time interval, default: NULL, if NULL then length(X) is chosen, needs E &gt; S.</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_h">H</code></td>
<td>
<p>vector, window set H, all elements must be increasing, the largest element must be =&lt; (T/2). H is automatically set if autoset.H = TRUE</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_alpha">alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_method">method</code></td>
<td>
<p>either &quot;asymptotic&quot; or &quot;fixed&quot;, defines how threshold Q is derived, default: &quot;asymptotic&quot;, If &quot;asymptotic&quot;: Q is derived by simulation of limit process L (Brownian motion); possible set number of simulations (sim), If &quot;fixed&quot;: Q may be set manually (Q)</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_sim">sim</code></td>
<td>
<p>integer, &gt; 0, No of simulations of limit process (for approximation of Q), default = 10000</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_rescale">rescale</code></td>
<td>
<p>logical, if TRUE statistic G is rescaled to statistic R, default = FALSE</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_q">Q</code></td>
<td>
<p>numeric, rejection threshold, default: Q is simulated according to sim and alpha.</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_perform.cpd">perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm is performed</p>
</td></tr>
<tr><td><code id="MFT.mean_+3A_print.output">print.output</code></td>
<td>
<p>logical, if TRUE results are printed to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>rejection threshold</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>how threshold Q was derived, see 'Arguments' for detailed description</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>number of simulations of the limit process (approximation of Q)</p>
</td></tr>
<tr><td><code>rescale</code></td>
<td>
<p>states whether statistic G is rescaled to R</p>
</td></tr>
<tr><td><code>CP</code></td>
<td>
<p>set of change points estmated by the multiple filter algorithm, increasingly ordered in time</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>estimated mean values between adjacent change points</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>start of time interval</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>end of time interval</p>
</td></tr>
<tr><td><code>Tt</code></td>
<td>
<p>length of time interval</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>window set</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code>perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm was performed</p>
</td></tr>
<tr><td><code>tech.var</code></td>
<td>
<p>list of technical variables with processes X and G_ht or R_ht</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of MFT which was performed: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Stefan Albert and Gaby Schneider (2018). The multiple filter test for change point detection in time
series. Metrika &lt;doi:10.1007/s00184-018-0672-1&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.MFT">plot.MFT</a>, <a href="#topic+summary.MFT">summary.MFT</a>, <a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+MFT.variance">MFT.variance</a>, <a href="#topic+MFT.peaks">MFT.peaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal distributed sequence with 3 change points of the mean (at n=100, 155, 350)
set.seed(50)
X1   &lt;- rnorm(400,0,1); X2 &lt;- rnorm(400,3,1); X3 &lt;- rnorm(400,5,1); X4 &lt;- rnorm(600,4.6,1)
X    &lt;- c(X1[1:100],X2[101:155],X3[156:350],X4[351:600])
mft  &lt;- MFT.mean(X)
plot(mft)
# Set additional parameters (window set)
mft2 &lt;- MFT.mean(X,autoset.H=FALSE,H=c(80,160,240))
plot(mft2)


</code></pre>

<hr>
<h2 id='MFT.peaks'>MFT.peaks</h2><span id='topic+MFT.peaks'></span>

<h3>Description</h3>

<p>The multiple filter test for peak detection in time series or sequences of random variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFT.peaks(x, autoset.H = TRUE, S = NULL, E = NULL, H = NULL,
  alpha = 0.05, method = "asymptotic", sim = 10000, Q = NA,
  blocksize = NA, two.sided = FALSE, perform.CPD = TRUE,
  print.output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFT.peaks_+3A_x">x</code></td>
<td>
<p>numeric vector, input sequence of random variables</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_autoset.h">autoset.H</code></td>
<td>
<p>logical, automatic choice of window size H</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_s">S</code></td>
<td>
<p>numeric, start of time interval, default: NULL, if NULL then 1 is chosen</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_e">E</code></td>
<td>
<p>numeric, end of time interval, default: NULL, if NULL then length(X) is chosen, needs E &gt; S</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_h">H</code></td>
<td>
<p>vector, window set H, the smallest element must &gt;= 3 be and the largest =&lt; (T/2). H is automatically set if autoset.H = TRUE</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_alpha">alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_method">method</code></td>
<td>
<p>either &quot;asymptotic&quot;, &quot;bootstrap&quot; or &quot;fixed&quot;, defines how threshold Q is derived, default: &quot;asymptotic&quot;, If &quot;asymptotic&quot;: Q is derived by simulation of limit process L (Gaussian process); possible set number of simulations (sim), If &quot;bootstrap&quot;: Q is derived by (Block)-Bootstrapping; possibly set number of simulations (sim) and blocksize (blocksize), If &quot;fixed&quot;: Q may be set manually (Q)</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_sim">sim</code></td>
<td>
<p>integer, &gt; 0, No of simulations of limit process (for approximation of Q), default = 10000</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_q">Q</code></td>
<td>
<p>numeric, rejection threshold, default: Q is simulated according to sim and alpha</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_blocksize">blocksize</code></td>
<td>
<p>NA or integer &gt;= 1, if method == 'bootstrap', blocksize determines the size of blocks (number of life times) for bootstrapping</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_two.sided">two.sided</code></td>
<td>
<p>logical, if TRUE a two sided test is performed and also negative peaks are considered in peak detection</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_perform.cpd">perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm is performed</p>
</td></tr>
<tr><td><code id="MFT.peaks_+3A_print.output">print.output</code></td>
<td>
<p>logical, if TRUE results are printed to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>rejection threshold</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>how threshold Q was derived, see 'Arguments' for detailed description</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>number of simulations of the limit process (approximation of Q)</p>
</td></tr>
<tr><td><code>blocksize</code></td>
<td>
<p>size of blocks (number of life times) for bootstrapping (approximation of Q)</p>
</td></tr>
<tr><td><code>CP</code></td>
<td>
<p>set of change points estmated by the multiple filter algorithm, increasingly ordered in time</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>start of time interval</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>end of time interval</p>
</td></tr>
<tr><td><code>Tt</code></td>
<td>
<p>length of time interval</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>window set</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code>two.sided</code></td>
<td>
<p>logigal, if TRUE also negative peaks are considered</p>
</td></tr>
<tr><td><code>perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm was performed</p>
</td></tr>
<tr><td><code>tech.var</code></td>
<td>
<p>list of technical variables with processes x and D_ht</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of MFT which was performed: &quot;peaks&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Hendrik Backhaus, Albrecht Stroh and Gaby Schneider (2019+). Peak detection in times series
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.filterdata">MFT.filterdata</a>, <a href="#topic+plot.MFT">plot.MFT</a>, <a href="#topic+summary.MFT">summary.MFT</a>, <a href="#topic+MFT.mean">MFT.mean</a>, <a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+MFT.variance">MFT.variance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal distributed sequence with 2 peaks
set.seed(12)
m &lt;- c(rep(0,30),seq(0,3,length.out = 100),seq(3,0,length.out = 80),rep(0,10),
       seq(0,6,length.out = 50),seq(6,0,length.out = 50),rep(0,30))
x &lt;- rnorm(length(m),m)
mft &lt;- MFT.peaks(x)
plot(mft)
# Set additional parameters (window set)
mft &lt;- MFT.peaks(x,autoset.H = FALSE, H =c(30,60,90))
plot(mft)

</code></pre>

<hr>
<h2 id='MFT.rate'>MFT.rate</h2><span id='topic+MFT.rate'></span>

<h3>Description</h3>

<p>The multiple filter test for rate change detection in point processes on the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFT.rate(Phi, m = 0, cutout = TRUE, autoset.d_H = TRUE, S = NULL,
  E = NULL, d = NULL, H = NULL, alpha = 0.05,
  method = "asymptotic", sim = 10000, rescale = FALSE, Q = NA,
  blocksize = NA, perform.CPD = TRUE, print.output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFT.rate_+3A_phi">Phi</code></td>
<td>
<p>numeric vector of increasing events, input point process</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_m">m</code></td>
<td>
<p>non-negative integer, dependence parameter: serial corellation rho up to order m estimated</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_cutout">cutout</code></td>
<td>
<p>logical, if TRUE for every point, for which the estimated rho becomes negative, the h-neighborhood of G (resp. R) is set to zero. This might only occur, if m &gt; 0</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_autoset.d_h">autoset.d_H</code></td>
<td>
<p>logical, automatic choice of window size H and step size d</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_s">S</code></td>
<td>
<p>numeric, start of time interval, default: Smallest multiple of d that lies beyond min(Phi)</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_e">E</code></td>
<td>
<p>numeric, end of time interval, default: Smallest multiple of d that lies beyond max(Phi), needs E &gt; S.</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_d">d</code></td>
<td>
<p>numeric, &gt; 0, step size delta at which processes are evaluated. d is automatically set if autoset.d_H = TRUE</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_h">H</code></td>
<td>
<p>vector, window set H, all elements must be increasing ordered multiples of d, the smallest element must be &gt;= d and the largest =&lt; (T/2). H is automatically set if autoset.d_H = TRUE</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_alpha">alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_method">method</code></td>
<td>
<p>either &quot;asymptotic&quot;, &quot;bootstrap&quot; or &quot;fixed&quot;, defines how threshold Q is derived, default: &quot;asymptotic&quot;, If &quot;asymptotic&quot;: Q is derived by simulation of limit process L (Brownian motion); possible set number of simulations (sim), If &quot;bootstrap&quot;: Q is derived by (Block)-Bootstrapping; possibly set number of simulations (sim) and blocksize (blocksize), If &quot;fixed&quot;: Q may be set manually (Q)</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_sim">sim</code></td>
<td>
<p>integer, &gt; 0, No of simulations of limit process (for approximation of Q), default = 10000</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_rescale">rescale</code></td>
<td>
<p>logical, if TRUE statistic G is rescaled to statistic R, default = FALSE</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_q">Q</code></td>
<td>
<p>numeric, rejection threshold, default: Q is simulated according to sim and alpha.</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_blocksize">blocksize</code></td>
<td>
<p>NA or integer &gt;= 1, if method == 'bootstrap', blocksize determines the size of blocks (number of life times) for bootstrapping</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_perform.cpd">perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm is performed</p>
</td></tr>
<tr><td><code id="MFT.rate_+3A_print.output">print.output</code></td>
<td>
<p>logical, if TRUE results are printed to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>rejection threshold</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>how threshold Q was derived, see 'Arguments' for detailed description</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>number of simulations of the limit process (approximation of Q)</p>
</td></tr>
<tr><td><code>blocksize</code></td>
<td>
<p>size of blocks (number of life times) for bootstrapping (approximation of Q)</p>
</td></tr>
<tr><td><code>rescale</code></td>
<td>
<p>states whether statistic G is rescaled to R</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>order of respected serial correlation (m-dependence)</p>
</td></tr>
<tr><td><code>CP</code></td>
<td>
<p>set of change points estmated by the multiple filter algorithm, increasingly ordered in time</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>
<p>estimated mean rates between adjacent change points</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>start of time interval</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>end of time interval</p>
</td></tr>
<tr><td><code>Tt</code></td>
<td>
<p>length of time interval</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>window set</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>step size delta at which processes were evaluated</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code>cutout</code></td>
<td>
<p>states whether cutout was used (see 'Arguments')</p>
</td></tr>
<tr><td><code>perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm was performed</p>
</td></tr>
<tr><td><code>tech.var</code></td>
<td>
<p>list of technical variables with processes Phi and G_ht or R_ht</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of MFT which was performed: &quot;rate&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Marietta Kirchner, Julia Schiemann, Jochen Roeper, Ralph Neininger and Gaby Schneider (2014).
A multiple filter test for the detection of rate changes in renewal processes with varying variance. The Annals of Applied Statistics 8(4): 2027-67
&lt;doi:10.1214/14-AOAS782&gt;
</p>
<p>Michael Messer, Kaue M. Costa, Jochen Roeper and Gaby Schneider (2017).
Multi-scale detection of rate changes in spike trains with weak dependencies. Journal of Computational Neuroscience, 42 (2), 187-201.
&lt;doi:10.1007/s10827-016-0635-3&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.variance">MFT.variance</a>, <a href="#topic+MFT.m_est">MFT.m_est</a>, <a href="#topic+plot.MFT">plot.MFT</a>, <a href="#topic+summary.MFT">summary.MFT</a>, <a href="#topic+MFT.mean">MFT.mean</a>, <a href="#topic+MFT.peaks">MFT.peaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rate change detection in Poisson process 
# with three change points (at t = 250, 600 and 680)
set.seed(0)
Phi1 &lt;- runif(rpois(1,lambda=390),0,250)
Phi2 &lt;- runif(rpois(1,lambda=380),250,600)
Phi3 &lt;- runif(rpois(1,lambda=200),600,680)
Phi4 &lt;- runif(rpois(1,lambda=400),680,1000)
Phi  &lt;- sort(c(Phi1,Phi2,Phi3,Phi4)) 
mft  &lt;- MFT.rate(Phi)
plot(mft)


</code></pre>

<hr>
<h2 id='MFT.variance'>MFT.variance</h2><span id='topic+MFT.variance'></span>

<h3>Description</h3>

<p>The multiple filter test for variance change detection in point processes on the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFT.variance(Phi, rcp = NULL, autoset.d_H = TRUE, S = NULL,
  E = NULL, d = NULL, H = NULL, alpha = 0.05,
  method = "asymptotic", sim = 10000, Q = NA, perform.CPD = TRUE,
  print.output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFT.variance_+3A_phi">Phi</code></td>
<td>
<p>numeric vector of increasing events, input point process</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_rcp">rcp</code></td>
<td>
<p>vector, rate CPs of Phi (if MFT for the rates is used: as CP[,1]), default: constant rate</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_autoset.d_h">autoset.d_H</code></td>
<td>
<p>logical, automatic choice of window size H and step size d</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_s">S</code></td>
<td>
<p>numeric, start of time interval, default: Smallest multiple of d that lies beyond min(Phi)</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_e">E</code></td>
<td>
<p>numeric, end of time interval, default: Smallest multiple of d that lies beyond max(Phi), needs E &gt; S</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_d">d</code></td>
<td>
<p>numeric, &gt; 0, step size delta at which processes are evaluated. d is automatically set if autoset.d_H = TRUE</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_h">H</code></td>
<td>
<p>vector, window set H, all elements must be increasing ordered multiples of d, the smallest element must be &gt;= d and the largest =&lt; (T/2). H is automatically set if autoset.d_H = TRUE</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_alpha">alpha</code></td>
<td>
<p>numeric, in (0,1), significance level</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_method">method</code></td>
<td>
<p>either &quot;asymptotic&quot;, or &quot;fixed&quot;, defines how threshold Q is derived, default: &quot;asymptotic&quot;. If &quot;asymptotic&quot;: Q is derived by simulation of limit process L (Brownian motion); possible set number of simulations (sim). If &quot;fixed&quot;: Q may be set manually (Q)</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_sim">sim</code></td>
<td>
<p>integer, &gt; 0, No of simulations of limit process (for approximation of Q), default = 10000</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_q">Q</code></td>
<td>
<p>numeric, rejection threshold, default: Q is simulated according to sim and alpha</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_perform.cpd">perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm is performed</p>
</td></tr>
<tr><td><code id="MFT.variance_+3A_print.output">print.output</code></td>
<td>
<p>logical, if TRUE results are printed to the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>varQ</code></td>
<td>
<p>rejection threshold</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>how threshold Q was derived, see 'Arguments' for detailed description</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>number of simulations of the limit process (approximation of Q)</p>
</td></tr>
<tr><td><code>CP</code></td>
<td>
<p>set of change points estmated by the multiple filter algorithm, increasingly ordered in time</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>estimated variances between adjacent change points</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>start of time interval</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>end of time interval</p>
</td></tr>
<tr><td><code>Tt</code></td>
<td>
<p>length of time interval</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>window set</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>step size delta at which processes were evaluated</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code>perform.CPD</code></td>
<td>
<p>logical, if TRUE change point detection algorithm was performed</p>
</td></tr>
<tr><td><code>tech.var</code></td>
<td>
<p>list of technical variables with processes Phi and G_ht</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>type of MFT which was performed: &quot;variance&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Stefan Albert, Michael Messer, Julia Schiemann, Jochen Roeper and Gaby Schneider (2017) 
Multi-scale detection of variance changes in renewal processes in the presence of rate change points.
Journal of Time Series Analysis, &lt;doi:10.1111/jtsa.12254&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+plot.MFT">plot.MFT</a>, <a href="#topic+summary.MFT">summary.MFT</a>, <a href="#topic+MFT.mean">MFT.mean</a>, <a href="#topic+MFT.peaks">MFT.peaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rate and variance change detection in Gamma process 
# (rate CPs at t=30 and 37.5, variance CPs at t=37.5 and 52.5) 
set.seed(51)
mu &lt;- 0.03; sigma &lt;- 0.01
p1 &lt;- mu^2/sigma^2; lambda1 &lt;- mu/sigma^2
p2 &lt;- (mu*0.5)^2/sigma^2; lambda2 &lt;- (mu*0.5)/sigma^2
p3 &lt;- mu^2/(sigma*1.5)^2; lambda3 &lt;- mu/(sigma*1.5)^2
p4 &lt;- mu^2/(sigma*0.5)^2; lambda4 &lt;- mu/(sigma*0.5)^2
Phi &lt;- cumsum(c(rgamma(1000,p1,lambda1),rgamma(500,p2,lambda2),
rgamma(500,p3,lambda3),rgamma(300,p4,lambda4)))
# rcp  &lt;- MFT.rate(Phi)$CP[,1] # MFT for the rates
rcp &lt;- c(30,37.5) # but here we assume known rate CPs
mft &lt;- MFT.variance(Phi,rcp=rcp) # MFT for the variances
plot(mft)

</code></pre>

<hr>
<h2 id='plot.MFT'>plot.MFT</h2><span id='topic+plot.MFT'></span>

<h3>Description</h3>

<p>Plot method for class 'mft'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFT'
plot(x, col = NULL, ylab1 = NULL, ylab2 = NULL,
  cex.legend = 1.2, cex.diamonds = 1.4, main = TRUE, plot.Q = TRUE,
  plot.M = TRUE, plot.h = TRUE, breaks = NULL, wid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MFT_+3A_x">x</code></td>
<td>
<p>object of class MFT</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_col">col</code></td>
<td>
<p>&quot;gray&quot; or vector of colors of length(H). Colors for (G_ht) plot, default: NULL -&gt; rainbow colors from blue to red</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_ylab1">ylab1</code></td>
<td>
<p>character, ylab for 1. graphic</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_ylab2">ylab2</code></td>
<td>
<p>character, ylab for 2. graphic</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_cex.legend">cex.legend</code></td>
<td>
<p>numeric, size of annotations in plot</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_cex.diamonds">cex.diamonds</code></td>
<td>
<p>numeric, size of diamonds that indicate change points</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_main">main</code></td>
<td>
<p>logical, indicates if title and subtitle are plotted</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_plot.q">plot.Q</code></td>
<td>
<p>logical, indicates if rejection threshold Q is plotted</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_plot.m">plot.M</code></td>
<td>
<p>logical, indicates if test statistic M is plotted</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_plot.h">plot.h</code></td>
<td>
<p>logical, indicates if a legend for the window set H is plotted</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_breaks">breaks</code></td>
<td>
<p>integer, &gt;0, number of breaks in rate histogram</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_wid">wid</code></td>
<td>
<p>integer, &gt;0, width of bars in variance histogram</p>
</td></tr>
<tr><td><code id="plot.MFT_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Marietta Kirchner, Julia Schiemann, Jochen Roeper, Ralph Neininger and Gaby Schneider (2014).
A multiple filter test for the detection of rate changes in renewal processes with varying variance. The Annals of Applied Statistics 8(4): 2027-67
&lt;doi:10.1214/14-AOAS782&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+MFT.variance">MFT.variance</a>, <a href="#topic+MFT.mean">MFT.mean</a>, <a href="#topic+MFT.peaks">MFT.peaks</a>, <a href="#topic+summary.MFT">summary.MFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rate change detection in Poisson process 
# with three change points (at t = 250, 600 and 680)
set.seed(0)
Phi1 &lt;- runif(rpois(1,lambda=390),0,250)
Phi2 &lt;- runif(rpois(1,lambda=380),250,600)
Phi3 &lt;- runif(rpois(1,lambda=200),600,680)
Phi4 &lt;- runif(rpois(1,lambda=400),680,1000)
Phi  &lt;- sort(c(Phi1,Phi2,Phi3,Phi4)) 
mft  &lt;- MFT.rate(Phi)
plot(mft)


</code></pre>

<hr>
<h2 id='summary.MFT'>summary.MFT</h2><span id='topic+summary.MFT'></span>

<h3>Description</h3>

<p>Summary method for class 'mft'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MFT'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.MFT_+3A_object">object</code></td>
<td>
<p>object of class MFT</p>
</td></tr>
<tr><td><code id="summary.MFT_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Messer, Stefan Albert, Solveig Plomer and Gaby Schneider
</p>


<h3>References</h3>

<p>Michael Messer, Marietta Kirchner, Julia Schiemann, Jochen Roeper, Ralph Neininger and Gaby Schneider (2014).
A multiple filter test for the detection of rate changes in renewal processes with varying variance. The Annals of Applied Statistics 8(4): 2027-67
&lt;doi:10.1214/14-AOAS782&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFT.rate">MFT.rate</a>, <a href="#topic+MFT.variance">MFT.variance</a>, <a href="#topic+MFT.mean">MFT.mean</a>, <a href="#topic+MFT.peaks">MFT.peaks</a>, <a href="#topic+plot.MFT">plot.MFT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rate change detection in Poisson process 
# with three change points (at t = 250, 600 and 680)
set.seed(0)
Phi1 &lt;- runif(rpois(1,lambda=390),0,250)
Phi2 &lt;- runif(rpois(1,lambda=380),250,600)
Phi3 &lt;- runif(rpois(1,lambda=200),600,680)
Phi4 &lt;- runif(rpois(1,lambda=400),680,1000)
Phi  &lt;- sort(c(Phi1,Phi2,Phi3,Phi4)) 
mft  &lt;- MFT.rate(Phi)
summary(mft)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
