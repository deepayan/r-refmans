<!DOCTYPE html><html><head><title>Help for package pcmabc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcmabc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pcmabc-package'>
<p>Approximate Bayesian Computations for Phylogenetic Comparative Methods</p></a></li>
<li><a href='#draw_phylproc'>
<p>Plots the trajectory of the stochastic process that evolved</p>
on the phylogeny.</a></li>
<li><a href='#get_phylogenetic_sample'>
<p>Retrieve contemporary sample</p></a></li>
<li><a href='#PCM_ABC'>
<p>ABC estimation for PCMs</p></a></li>
<li><a href='#simulate_phenotype_on_tree'>
<p>Simulate a stochastic process on top of a phylogeny.</p></a></li>
<li><a href='#simulate_phylproc'>
<p>Simultaneously simulate a phylogeny and a trait evolving on it.</p></a></li>
<li><a href='#simulate_sde_on_branch'>
<p>Simulate a stochastic differential equation on a branch. using</p>
the <span class="pkg">yuima</span></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate Bayesian Computations for Phylogenetic Comparative
Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Krzysztof Bartoszek &lt;krzbar@protonmail.ch&gt;, Pietro Lio'</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krzysztof Bartoszek &lt;krzbar@protonmail.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits by ABC, the parameters of a stochastic process modelling the phylogeny and evolution of a suite of traits following the tree. The user may define an arbitrary Markov process for the trait and phylogeny. Importantly, trait-dependent speciation models are handled and fitted to data. See K. Bartoszek, P. Lio' (2019) &lt;<a href="https://doi.org/10.5506%2FAPhysPolBSupp.12.25">doi:10.5506/APhysPolBSupp.12.25</a>&gt;. The suggested geiger package can be obtained from CRAN's archive <a href="https://cran.r-project.org/src/contrib/Archive/geiger/">https://cran.r-project.org/src/contrib/Archive/geiger/</a>, suggested to take latest version. Otherwise its required code is present in the pcmabc package. The suggested distory package can be obtained from CRAN's archive <a href="https://cran.r-project.org/src/contrib/Archive/distory/">https://cran.r-project.org/src/contrib/Archive/distory/</a>, suggested to take latest version. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.9.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 3.0.6), graphics, methods, mvSLOUCH, phangorn, stats,
utils, yuima</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geiger, distory</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2) | file LICENCE]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>ABCdist.R ABCmessage.R ABC.R ABCupdate.R draw.R
from_geiger_2_0_6_2_diversification.R getTipSample.R rates.R
simsde.R simtree.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-06 11:13:48 UTC; kbart</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-09 08:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='pcmabc-package'>
Approximate Bayesian Computations for Phylogenetic Comparative Methods
</h2><span id='topic+pcmabc-package'></span><span id='topic+pcmabc'></span>

<h3>Description</h3>

<p>The package allows for Approximate Bayesian Computations (ABC) inference and simulation 
of stochastic processes evolving on top of a phylogenetic tree. The user is allowed
to define their own stochastic process for the trait(s), be they univariate, multivariate
continuous or discrete. The traits are allowed to influence the speciation
and extinction rates generating the phylogeny. The user provides their own function
that calculates these rates and one of the functions parameters is the current
state of the phenotype. Two functionalities that are missing at the moment
is for the speciation and extinction rates to be time-inhomogenous and 
that speciation events can influence the phenotypic evolution. It is planned to
add this functionality. However, cladogenetic dynamics are possible at the start of the lineage, 
i.e. when a new lineage is separated from the main lineage. Hence, cladogenetic change can only be 
included as an event connected with a lineage (subpopulation) breaking off.
</p>
<p>This software comes AS IS in the hope that it will be useful WITHOUT ANY WARRANTY, 
NOT even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
Please understand that there may still be bugs and errors. Use it at your own risk. 
We take no responsibility for any errors or omissions in this package or for any misfortune 
that may befall you or others as a result of its use. Please send comments and report 
bugs to Krzysztof Bartoszek at krzbar@protonmail.ch .
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> pcmabc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-05-06</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package allows for Approximate Bayesian Computations (ABC) inference and simulation 
of stochastic processes evolving on top of a phylogenetic tree. The <code>PCM_ABC()</code>
function is responsible for the inference procedure. The user has to provide their
own functions to simulate the phenotype and tree. The package provides simulation
of the trait under stochastic differential equation (SDE) models by calling <span class="pkg">yuima</span>.
In this case the user has to provide their own wrapper that creates an object
<span class="pkg">yuima</span> will be able to handle (see Example). The user also has to provide
a function to calculate the instantaneous birth and death rates (or state that the 
tree is independent of the trait). The package supports some simple birth rate 
functions, see description of <code>PCM_ABC()</code>.
</p>
<p>One is allowed to simulate a trait process and tree process jointly (with the
trait influencing the tree's dynamics). This is done by the function
<code>simulate_phylproc()</code>. The function <br /> <code>simulate_phenotype_on_tree()</code>
simulates a trait process on top of a provided phylogeny. Finally,
the function <code>simulate_sde_on_branch()</code> allows one to simulate an SDE
model along a time interval using <span class="pkg">yuima</span>. 
The trajectory of the trait(s) can be visualized using <code>draw_phylproc()</code>.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek, Pietro Lio'
Maintainer: &lt;krzbar@protonmail.ch&gt;
</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>
<p>Kutsukake N., Innan H. (2014) Detecting Phenotypic Selection by Approximate Bayesian 
Computation in Phylogenetic Comparative Methods. In: Garamszegi L. (eds) 
Modern Phylogenetic Comparative Methods and Their Application in Evolutionary Biology. 
Springer, Berlin, Heidelberg
</p>
<p>Sheldon R. M. (2006). Simulation. Elsevier Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate 3d OUBM model
## This example requires the R package ape
## (to generate the tree in phylo format).
set.seed(12345)

phyltree&lt;-ape::rphylo(n=5,birth=1,death=0)

simulate_mvsl_sde&lt;-function(time,params,X0,step){
    A &lt;- c(paste("(-",params$a11,")*(x1-(",params$psi1,"))
    -(",params$a12,")*(x2-(",params$psi2,"))-(",params$b11,")*x3",sep=""),
    paste("(-",params$a21,")*(x1-(",params$psi1,"))
    -(",params$a22,")*(x2-(",params$psi2,"))-(",params$b21,")*x3",sep=""),0)
    S &lt;- matrix( c( params$s11, params$s12, 0, 0, params$s22 
    , 0, 0, 0, params$s33), 3, 3,byrow=TRUE)
    yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
    state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
    simulate_sde_on_branch(time,yuima.3d,X0,step)
}

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=-2.4590422,psi2=-0.6197838)
X0&lt;-c(5.723548,4.103157,3.834698)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
          ## in reality should be much smaller e.g. step&lt;-0.001          
            
simres&lt;-simulate_phenotype_on_tree(phyltree, simulate_mvsl_sde, sde.params, X0, step)

## visualize the simulation
draw_phylproc(simres)

## extract the measurements at the tips
phenotypedata&lt;-get_phylogenetic_sample(simres)

birth.params&lt;-list(scale=1,maxval=2,abcstepsd=0.1,positivevars=c(TRUE,TRUE),
fixed=c(FALSE,TRUE))

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=-2.4590422,psi2=-0.6197838,
positivevars=c(TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,FALSE),
abcstepsd=rep(0.1,12))

par0&lt;-list(phenotype.model.params=sde.params,birth.params=birth.params)
fbirth&lt;-"rate_id" ## should be rate_const but used here as an example 
## for birth.params
fdeath&lt;-NULL
X0&lt;-c(5.723548,4.103157,3.834698)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
          ## in reality should be much smaller e.g. step&lt;-0.001          
abcsteps&lt;-2 ## for keeping example's running time short &lt;5s as CRAN policy, 
            ## in reality should be much larger e.g. abcsteps&lt;-500
eps&lt;-1 ## for toy example's output to be useful, 
       ## in reality should be much smaller e.g. eps&lt;-0.25
                                
## estimate parameters
ABCres&lt;-PCM_ABC(phyltree=phyltree,phenotypedata=phenotypedata,
par0=par0,phenotype.model=simulate_mvsl_sde,fbirth=fbirth,fdeath=fdeath,X0=X0,
step=step,abcsteps=abcsteps,eps=eps)
</code></pre>

<hr>
<h2 id='draw_phylproc'>
Plots the trajectory of the stochastic process that evolved
on the phylogeny.
</h2><span id='topic+draw_phylproc'></span>

<h3>Description</h3>

<p>The function plots the trajectory of a stochastic process
that evolved on top of a phylogeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_phylproc(simulobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_phylproc_+3A_simulobj">simulobj</code></td>
<td>

<p>The simulate data as generated by <code>simulate_phyloproc</code>
<br /> or <code>simulate_phenotype_on_tree</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is essentially a wrapper around <code>mvSLOUCH::drawPhylProc()</code>.
It transforms the <code>simulobj</code> into a matrix understandable by 
<code>mvSLOUCH::drawPhylProc()</code> and then calls <br /> <code>mvSLOUCH::drawPhylProc()</code>.
</p>


<h3>Value</h3>

<p>Returns a meaningless NA value.</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>
<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)

simulate_mvsl_sde&lt;-function(time,params,X0,step){
    A &lt;- c(paste("(-",params$a11,")*(x1-(",params$psi1,"))
    -(",params$a12,")*(x2-(",params$psi2,"))-(",params$b11,")*x3",sep=""),
    paste("(-",params$a21,")*(x1-(",params$psi1,"))
    -(",params$a22,")*(x2-(",params$psi2,"))-(",params$b21,")*x3",sep=""),0)
    S &lt;- matrix( c( params$s11, params$s12, 0, 0, params$s22 
    , 0, 0, 0, params$s33), 3, 3,byrow=TRUE)
    yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
    state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
    simulate_sde_on_branch(time,yuima.3d,X0,step)
}
birth.params&lt;-list(scale=1,maxval=2)
sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=-2.4590422,psi2=-0.6197838)
X0&lt;-c(5.723548,4.103157,3.834698)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
	  ## in reality should be much smaller e.g. step&lt;-0.001
simres&lt;-simulate_phylproc(3.5, sde.params, X0, fbirth="rate_id", fdeath=NULL, 
fbirth.params=NULL, fdeath.params=NULL, fsimulphenotype=simulate_mvsl_sde, 
n.contemporary=5, n.tips.total=-1, step=step)
draw_phylproc(simres)
</code></pre>

<hr>
<h2 id='get_phylogenetic_sample'>
Retrieve contemporary sample
</h2><span id='topic+get_phylogenetic_sample'></span>

<h3>Description</h3>

<p>The function retrieved the contemporary sample from an object
simulated by <span class="pkg">pcmabc</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_phylogenetic_sample(pcmabc_simulobj, bOnlyContemporary=FALSE, 
tol=.Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_phylogenetic_sample_+3A_pcmabc_simulobj">pcmabc_simulobj</code></td>
<td>

<p>The output simulated object by <code>simulate_phylproc()</code>
<br /> or <code>simulate_phenotype_on_tree()</code>.
</p>
</td></tr>
<tr><td><code id="get_phylogenetic_sample_+3A_bonlycontemporary">bOnlyContemporary</code></td>
<td>

<p>Logical, should all tip measurements be extracted (<code>FALSE</code>)
or only those corresponding to non-extinct tips (<code>TRUE</code>).
In the latter case be careful with the output (see Value).
</p>
</td></tr>
<tr><td><code id="get_phylogenetic_sample_+3A_tol">tol</code></td>
<td>

<p>The tolerance to check if the tip is contemporary, i.e.
the tip is distant from the root by tree.height +/- <code>tol</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a matrix with rows corresponding to tips.
If there are extinct species, but <code>bOnlyContemporary</code> was
set to <code>TRUE</code>, then the extinct lineages have to be removed
from the tree before any further analysis. Also after removing
extinct lineages one has to make sure that the order of the 
contemporary nodes did not change in the tree. Otherwise, 
the rows of the output matrix will not correspond to the
indices of the tree's tips.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate 3d OUBM model
## This example requires the R package ape
## (to generate the tree in phylo format).
set.seed(12345)

phyltree&lt;-ape::rphylo(n=5,birth=1,death=0)
simulate_mvsl_sde&lt;-function(time,params,X0,step){
    A &lt;- c(paste("(-",params$a11,")*(x1-(",params$psi1,"))
    -(",params$a12,")*(x2-(",params$psi2,"))-(",params$b11,")*x3",sep=""),
    paste("(-",params$a21,")*(x1-(",params$psi1,"))
    -(",params$a22,")*(x2-(",params$psi2,"))-(",params$b21,")*x3",sep=""),0)
    S &lt;- matrix( c( params$s11, params$s12, 0, 0, params$s22 
    , 0, 0, 0, params$s33), 3, 3,byrow=TRUE)
    yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
    state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
    simulate_sde_on_branch(time,yuima.3d,X0,step)
}
phenotype.model&lt;-simulate_mvsl_sde

birth.params&lt;-list(scale=1,maxval=10000,abcstepsd=1,positivevars=c(TRUE),
fixed=c(FALSE,TRUE,TRUE,TRUE,TRUE))

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=-2.4590422,psi2=-0.6197838)
X0&lt;-c(5.723548,4.103157,3.834698)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
          ## in reality should be much smaller e.g. step&lt;-0.001          
simres&lt;-simulate_phenotype_on_tree(phyltree, simulate_mvsl_sde, sde.params, X0, step)
mPhylSamp&lt;-get_phylogenetic_sample(simres)
</code></pre>

<hr>
<h2 id='PCM_ABC'>
ABC estimation for PCMs
</h2><span id='topic+PCM_ABC'></span>

<h3>Description</h3>

<p>The function does parameter estimation through Approximate Bayesian Computations
(ABC) for user defined models of trait and phylogeny evolution. In particular 
the phenotype may influence the branching dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCM_ABC(phyltree, phenotypedata, par0, phenotype.model, fbirth, fdeath = NULL, 
X0 = NULL, step = NULL, abcsteps = 200, eps = 0.25, fupdate = "standard", 
typeprintprogress = "dist", tree.fixed=FALSE, 
dist_method=c("variancemean","wRFnorm.dist"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCM_ABC_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_phenotypedata">phenotypedata</code></td>
<td>

<p>A matrix with the rows corresponding to the tip species while the columns correspond to the traits.
The rows should be in the same as the order in which the 
species are in the phylogeny (i.e. correspond to the node indices <code>1:n</code>, 
where <code class="reqn">n</code> is the number of tips). 
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_par0">par0</code></td>
<td>

<p>The starting parameters for the estimation procedure. This is a list of 1, 2 or 3 lists.
The lists have to be named as <br /> <code>phenotype.model.params</code>, <code>birth.params</code> 
(optional if <code>tree.fixed</code> is <code>TRUE</code> and <code>death.params</code> (optional). 
The <code>phenotype.model.params</code> list corresponds to parameters governing the 
trait evolution process, the <code>birth.params</code> to the birth rate of the branching process
and the <code>death.params</code> to the extinction rate. The last element is optional
as one can have just a pure birth tree. The entries of all the lists should 
be named. Each of the three lists can have three special fields <code>fixed</code>,
<code>abcstepsd</code>, <code>positivevars</code>. The field <code>fixed</code> is a logical
vector of length equalling the number of parameters. If an entry is <code>TRUE</code>,
then that parameter is not optimized over but kept at its initial value
throughout the whole ABC procedure. The field <code>abcstepsd</code> is a numeric
vector equalling the number of parameters. It is the standard deviation
of the random update of the parameter, i.e. providing control
on how much one wants to jump in each parameter dimension. The field
<code>positivevars</code> is a logical vector of length equalling the number
of parameters and indicating if the given parameter is to be positive
<code>TRUE</code> or arbitrary <code>FALSE</code>. Notice that even if <code>fixed</code>
has true entries, then corresponding entries have to be present
in <code>abcstepsd</code> and <code>positivevars</code> (but their values do not matter).
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_phenotype.model">phenotype.model</code></td>
<td>

<p>The name of a function to simulate the phenotype over a period of time. 
The function has to have four parameters (in the following order not by name):
<code>time</code>, <code>params</code>, <code>X0</code> and <code>step</code>.
The parameter <code>time</code> is the duration of the simulation, i.e. the length
of the branch. The parameter <code>params</code> is a list of
the parameters governing the simulation, what will be passed here
is the list <br /> <code>phenotype.model.params</code>, without the fields
<code>fixed</code>, <code>abstepsd</code> and <br /> <code>positivevars</code>. It is up
to the function in <code>phenotype.model</code> to interpret the 
provided parameters. <code>X0</code> stands for the value at the start of the branch
and <code>step</code> is a control parameter governing the time 
step size of the simulation. The <span class="pkg">pcmabc</span> package has inbuilt support for 
simulating the trait as as stochastic differential equation by the <span class="pkg">yuima</span> 
package with the function <code>simulate_sde_on_branch()</code>. However,
the user needs to write the <code>phenotype.model</code> function that translates
the vector of parameters into an object that is understandable by <span class="pkg">yuima</span>
and then call <code>simulate_sde_on_branch()</code>, see the Example.
</p>
<p>The phenotype is simulated prior to the simulation of the speciation/extinction
events on a lineage (see Details). Hence, it is not possible (at the moment) 
to include some special event (e.g. a cladogenetic jump) at branching. Such
dynamics are only possible at the start of the lineage, i.e. when the new lineage 
is separated from the main lineage. Hence, cladogenetic change can only be 
included as an event connected with a lineage (subpopulation) breaking off.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_fbirth">fbirth</code></td>
<td>

<p>A function that returns the birth rate at a given moment.
The fist parameter of the function has to correspond to the value of the
phenotype (it is a vector first element is time and the others the values of the trait(s)) 
and the second to the list of birth parameters <code>birth.params</code>,
see <code>par0</code>. The time entry of the phenotype vector is at the moment relative to 
an unspecified (from <code>fbirth</code>'s perspective) speciation event on the phylogeny.
Hence, it cannot be used as for writing a time-inhomogenous speciation
function. The speciation process is assumed to be time homogeneous in the 
current implementation. The package has support for two inbuilt rate functions.
The can be indicated by passing a string in <code>fbirth</code>: either <code>"rate_id"</code>
or <code>"rate_const"</code>. The string <code>"rate_const"</code> corresponds to a 
constant rate and has to have the rate's value in field called <code>$rate</code>.
However, a switching of rates is allowed. If the value of the first trait
exceeds a certain threshold (provided in field <code>$switch</code> of 
birth parameters), then the rate is changed to the value in <code>$rate2</code>,
see body of hidden function <code>.f_rate_const()</code>, in file <code>rates.R</code>.
The string <code>"rate_id"</code> corresponds to the <code>.f_rate_id()</code> function, 
in file <code>rates.R</code>. If the birth parameters are <code>NULL</code>, then the
rate equals the value of the first phenotype. However, a number 
of linear, threshold and power transformations of the rate are
possible. The field <code>varnum</code> indicates the index of the variable
to take as the one influencing the rate (remember to add 1 for the time entry).
Then, if <code class="reqn">x</code> stands for the trait influencing the branching rate it is 
transformed into a rate by the following fields in the following order. 
Set <code>rate&lt;-x</code> and let <code>params</code> correspond to the list containing
the branching parameters.
</p>

<ul>
<li><p><code>substractbase</code>rate&lt;-max(0,params$rate-substractbase)
<code>rate&lt;-abs(rate)</code>
</p>
</li>
<li><p><code>p</code> and if <code>is.null(params$raise.at.end) || !params$raise.at.end</code>
rate&lt;-rate^params$p
</p>
</li>
<li><p><code>base</code> and <code>!is.null(params$const)</code> <br /> <code>if (res&lt;params$base){rate&lt;-params$const}</code>
</p>
</li>
<li><p><code>base</code> and <code>is.null(params$const)</code> <br /> <code>if (res&lt;params$base){rate&lt;-0}</code>
</p>
</li>
<li><p><code>invbase</code> and <code>!is.null(params$const)</code> <br /> <code>if (res&gt;params$invbase){rate&lt;-params$const}</code>
</p>
</li>
<li><p><code>invbase</code> and <code>is.null(params$const)</code> <br /> <code>if (res&gt;params$invbase){rate&lt;-0}</code>
</p>
</li>
<li><p><code>scale</code>rate&lt;-rate/params$scale
</p>
</li>
<li><p><code>p</code> and if <code>params$raise.at.end</code>rate&lt;-rate^params$p
<code>res&lt;-abs(res)</code>
</p>
</li>
<li><p><code>maxval</code><code>if(rate&gt;params$maxval){rate&lt;-params$maxval}</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="PCM_ABC_+3A_fdeath">fdeath</code></td>
<td>

<p>A function that returns the birth rate at a given moment. Its structure
is the same as <code>fbirth</code>. The current version of the  package does 
not provide any support for any inbuilt function.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_x0">X0</code></td>
<td>

<p>The value of the ancestral state at the start of the tree. If <code>NULL</code>, 
then the mean of the contemporary observations is used.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_step">step</code></td>
<td>

<p>The time step size for simulating the phenotype. If not provided,
then calculated as <code>min(0.001,tree.height/1000)</code>.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_abcsteps">abcsteps</code></td>
<td>

<p>The number of steps of the ABC search procedure.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_eps">eps</code></td>
<td>

<p>The acceptance tolerance of the ABC algorithm.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_fupdate">fupdate</code></td>
<td>

<p>How should the parameters be updated at each step of the ABC search
algorithm. The user may provide their own function that has to 
handle the following call
<code>fupdate(par,par0,baccept,ABCdist,phenotypedata,phyltree)</code>,
where <code>par</code> is the current proposal for the parameter,
<code>baccept</code> a logical variable indicating if <code>par</code>
were accepted or rejected and <code>ABCdist</code> the distance
between the observed and simulated under <code>par</code> data.
The three other parameters <code>par0</code>, <code>phenotypedata</code>
and <code>phyltree</code> are those that were provided in the call
to <code>ABCdist</code>. The user may write <code>"standard"</code> in
place of providing a function and then the internal function
<code>.f_standard_update()</code>. This function makes mean 0 normal jitters
(with standard deviation provided through <code>abcstepsd</code> from
<code>par0</code>) for accepted parameters or if they were not accepted
draws new parameters from a uniform on [-10,10] distribution.
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_typeprintprogress">typeprintprogress</code></td>
<td>

<p>What should be printed out at each step of the ABC search algorithm.
If <code>NULL</code>, then nothing, otherwise the package offers one possibility,
<code>"dist"</code>-the iteration number and distance of the simulated dataset from.
The user is free to write their own function here. The first parameter of the
function has to be an integer(the iteration number), the second a real value
(the distance) and the third a list (the proposed model parameters, see <code>par0</code>
format).
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_tree.fixed">tree.fixed</code></td>
<td>

<p>Does the trait value process influence the branching dynamics (<code>FALSE</code>)
or the branching structure is independent of the trait (<code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="PCM_ABC_+3A_dist_method">dist_method</code></td>
<td>

<p>A vector with two entries, the first is the method for calculating   
the distance between the simulated and observed trait data.
The second is is the method for calculating   
the distance between the simulated and observed phylogeny.
Possible values for the phenotype distance are
<code>"variance"</code>, <code>"variancemean"</code>, <code>"order"</code>
and for the distance between phylogenies are
<code>"bdcoeffs"</code>, <code>"node_heights"</code>, <code>"logweighted_node_heights"</code>,
<code>"RF.dist"</code>, <code>"wRF.dist"</code>, <code>"wRFnorm.dist"</code>, <code>"KF.dist"</code>,
<code>"path.dist"</code>, <code>"path.dist.weights"</code>, <code>"dist.topo.KF1994"</code>,
<br /> <code>"treeDist"</code>, <code>"BHV"</code> and <code>"BHVedge"</code>.
The <code>"BHV"</code> and <code>"BHVedge"</code> methods will only work if 
the <code>distory</code> package is installed. If it is not, then
they will be replaced by <code>"wRFnorm.dist"</code> and <code>"RF.dist"</code>
respectively. The <code>distory</code> package is orphaned at the moment on CRAN.
See Details for description of the methods. The choice of which distance
calculation method is better seems to depend on the model of evolution,
number of <code>abcsteps</code> and value of <code>eps</code>. Some experimentation
is recommended. If the tree is assumed to be fixed, then the tree 
distance method is ignored. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some details of the function might change. In a future release it should
be possible for the user to provide their own custom distance function,
time-inhomogenous branching and trait simulation. The fields
<code>sum.dists.from.data</code> and <code>sum.inv.dists.from.data</code> will 
probably be removed from the output object. 
</p>
<p>At the moment the distance function is calculated as
(tree.distance+trait.distance)/2 or only with trait.distance if the tree is assumed 
fixed. The possible distance functions between simulates and observed
phenotypes are
</p>

<ul>
<li><p><code>"variance"</code>calculates the Euclidean distance between covariance matrices
estimated from simulated and original data. The differences between entries
are weighted by the sum of their absolute values so that the distance is in [0,1],
</p>
</li>
<li><p><code>"variancemean"</code>calculates the Euclidean distance between mean vectors and 
covariance matrices estimated from simulated and original data. The differences between entries
are weighted by the sum of their absolute values so that the distance is in [0,1].
The difference between the means and covariances are weighted equally.
</p>
</li>
<li><p><code>"order"</code>calculates the 
mean squared difference between ordered (by absolute value) tip measurements
(scaled by maximum observed trait in each dimension so that distance is in [0,1]
and then the difference between each pair of traits is scaled by the sum of 
their absolute values to remove effects of scale).
</p>
</li></ul>

<p>The possible distance functions between simulates and observed
phenotypes are
</p>

<ul>
<li><p><code>"bdcoeffs"</code>first using <code>geiger::bd.km()</code> 
estimates the net diversification rate for both trees and then calculates the distance 
between the trees as the total variation distance between two exponential distributions
with rates equalling the estimated net diversification rates. 
</p>
</li>
<li><p><code>"node_heights"</code>calculates the root mean square
distance between node heights (scaled by tree height so that distance is in [0,1]
and then the difference between each node height is scaled by the sum of the two heights
to remove effects of scale)
</p>
</li>
<li><p><code>"logweighted_node_heights"</code>similarly as <code>"node_heights"</code> but additionally
divides the <br /> squared scaled difference is divided by the logarithm of the inverse order (i.e. 
the highest is 1) statistic, to reduce the role of smaller heights. 
</p>
</li>
<li><p><code>"RF.dist"</code>calls <code>phangorn::RF.dist()</code>
</p>
</li>
<li><p><code>"wRF.dist"</code>calls <code>phangorn::wRF.dist()</code> with <code>normalize=FALSE</code> 
</p>
</li>
<li><p><code>"wRFnorm.dist"</code>calls <code>phangorn::wRF.dist()</code> with <code>normalize=TRUE</code>
</p>
</li>
<li><p><code>"KF.dist"</code>calls <code>phangorn::KF.dist()</code>
</p>
</li>
<li><p><code>"path.dist"</code>calls <code>phangorn::path.dist()</code> with <code>use.weight=FALSE</code>
</p>
</li>
<li><p><code>"path.dist.weights"</code>calls <code>phangorn::path.dist()</code> with <code>use.weight=TRUE</code>
</p>
</li>
<li><p><code>"dist.topo.KF1994"</code>calls <code>ape::dist.topo()</code> with <code>method="score"</code>
</p>
</li>
<li><p><code>"BHV"</code>calls <code>distory::dist.multiPhylo()</code> with <code>method="geodesic"</code>
</p>
</li>
<li><p><code>"BHVedge"</code>calls <code>distory::dist.multiPhylo()</code> with <code>method="edgeset"</code>
</p>
</li></ul>

<p>The tree is simulated by means of a Cox process (i.e. Poisson process
with random rate). First the trait is simulated along the spine of a 
tree, i.e. a lineage of duration <code>tree.height</code>. Then, along this
spine the birth and death rates are calculated (they may depend 
on the value of the phenotype). The maximum for each rate is calculated
and a homogeneous Poisson process with the maximum rate is simulated.
Then, these events are thinned. Each event is retained with probability
equalling true rate divided by maximum of rate (p. 32, Sheldon 2006). 
All speciation events are retained until the first death event.
</p>


<h3>Value</h3>

<table>
<tr><td><code>param.estimate</code></td>
<td>
<p>A list, in the form of <code>par0</code>, with a point
estimate of the parameters. This point estimate is calculated 
from all the accepted points by using inverse distance weighting.
The distances for the weighting are the 
</p>
</td></tr>
<tr><td><code>all.accepted</code></td>
<td>
<p>A list with all the accepted parameters during the 
ABC search. This will allow for the presentation of the posterior
distribution of the parameters.</p>
</td></tr>
<tr><td><code>sum.dists.from.data</code></td>
<td>
<p>The sum of all the distances between the observed 
data and the simulated data under the accepted parameter sets in the ABC 
search procedure.</p>
</td></tr>
<tr><td><code>sum.inv.dists.from.data</code></td>
<td>
<p>The sum of all the inverses of the distances 
between the observed data and the simulated data under the accepted parameter 
sets in the ABC search procedure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>
<p>Sheldon R. M. (2006). Simulation. Elsevier Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_sde_on_branch">simulate_sde_on_branch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate 3d OUBM model
## This example requires the R package ape
## (to generate the tree in phylo format).
set.seed(12345)

phyltree&lt;-ape::rphylo(n=15,birth=1,death=0)

simulate_mvsl_sde&lt;-function(time,params,X0,step){
    A &lt;- c(paste("(-",params$a11,")*(x1-(",params$psi1,"))
    -(",params$a12,")*(x2-(",params$psi2,"))-(",params$b11,")*x3",sep=""),
    paste("(-",params$a21,")*(x1-(",params$psi1,"))
    -(",params$a22,")*(x2-(",params$psi2,"))-(",params$b21,")*x3",sep=""),0)
    S &lt;- matrix( c( params$s11, params$s12, 0, 0, params$s22 
    , 0, 0, 0, params$s33), 3, 3,byrow=TRUE)
    yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
    state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
    simulate_sde_on_branch(time,yuima.3d,X0,step)
}

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=10,psi2=-10)
X0&lt;-c(10,4.103157,3.834698)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
            ## in reality should be much smaller e.g. step&lt;-0.001          
simres&lt;-simulate_phenotype_on_tree(phyltree, simulate_mvsl_sde, sde.params, X0, step)

## extract the measurements at the tips
phenotypedata&lt;-get_phylogenetic_sample(simres)

birth.params&lt;-list(rate=10,maxval=10,abcstepsd=0.01,positivevars=c(TRUE,TRUE),
fixed=c(FALSE,TRUE))

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=10,psi2=-10,
positivevars=c(TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,FALSE,FALSE),
abcstepsd=rep(0.1,12))

par0&lt;-list(phenotype.model.params=sde.params,birth.params=birth.params)
fbirth&lt;-"rate_const" 
fdeath&lt;-NULL
X0&lt;-c(10,4.103157,3.834698)
step&lt;-0.05 ## for keeping example's running time short &lt;5s as CRAN policy, 
            ## in reality should be much smaller e.g. step&lt;-0.001          
abcsteps&lt;-2 ## for keeping example's running time short &lt;5s as CRAN policy, 
          ## in reality should be much larger e.g. abcsteps&lt;-500
eps&lt;-1 ## for toy example's output to be useful, 
          ## in reality should be much smaller e.g. eps&lt;-0.25
## estimate parameters
ABCres&lt;-PCM_ABC(phyltree=phyltree,phenotypedata=phenotypedata,
par0=par0,phenotype.model=simulate_mvsl_sde,fbirth=fbirth,fdeath=fdeath,X0=X0,
step=step,abcsteps=abcsteps,eps=eps)
</code></pre>

<hr>
<h2 id='simulate_phenotype_on_tree'>
Simulate a stochastic process on top of a phylogeny.
</h2><span id='topic+simulate_phenotype_on_tree'></span>

<h3>Description</h3>

<p>The function simulates phenotypic dataset under user defined models trait 
evolution. The phenotype evolves on top of a fixed phylogeny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_phenotype_on_tree(phyltree, fsimulphenotype, simul.params, X0, step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_phenotype_on_tree_+3A_phyltree">phyltree</code></td>
<td>

<p>The phylogeny in <code>phylo</code> format. The tree can be obtained from e.g. a <code>nexus</code> file 
by the <code>read.nexus()</code> function from the <span class="pkg">ape</span> package. The &quot;standard&quot; <span class="pkg">ape</span> node
indexing is assumed: for a tree with <code class="reqn">n</code> tips, the tips should have indices <code>1:n</code> 
and the root index <code>n+1</code>.
</p>
</td></tr>
<tr><td><code id="simulate_phenotype_on_tree_+3A_fsimulphenotype">fsimulphenotype</code></td>
<td>

<p>The name of a function to simulate the phenotype over a period of time. 
The function has to have four parameters (in the following order not by name):
<code>time</code>, <code>params</code>, <code>X0</code> and <code>step</code>.
The parameter <code>time</code> is the duration of the simulation, i.e. the length
of the branch. The parameter <code>params</code> is a list of
the parameters governing the simulation, what will be passed here
is the list <br /> <code>phenotype.model.params</code>, without the fields
<code>fixed</code>, <code>abstepsd</code> and <br /> <code>positivevars</code>. It is up
to the function in <code>phenotype.model</code> to interpret the 
provided parameters. <code>X0</code> stands for the value at the start of the branch
and <code>step</code> is a control parameter governing the time 
step size of the simulation. The <span class="pkg">pcmabc</span> package has inbuilt support for 
simulating the trait as as stochastic differential equation by the <span class="pkg">yuima</span> 
package with the function <code>simulate_sde_on_branch()</code>. However
the user needs to write the <code>phenotype.model</code> function that translates
the vector of parameters into an object that is understandable by <span class="pkg">yuima</span>
and then call <code>simulate_sde_on_branch()</code>, see the Example.
</p>
<p>The phenotype is simulated prior to the simulation of the speciation/extinction
events on a lineage. Hence, it is not possible (at the moment) 
to include some special event (e.g. a cladogenetic jump) at branching. Such
dynamics are only possible at the start of the lineage, i.e. when the new lineage
is separated from the main lineage. Hence, cladogenetic change can only be 
included as an event connected with a lineage (subpopulation) breaking off.
</p>
</td></tr>
<tr><td><code id="simulate_phenotype_on_tree_+3A_simul.params">simul.params</code></td>
<td>

<p>The parameters of the stochastic model to simulate the phenotype. 
They should be passed as a named list.
</p>
</td></tr>
<tr><td><code id="simulate_phenotype_on_tree_+3A_x0">X0</code></td>
<td>

<p>The value of the ancestral state at the start of the tree.
</p>
</td></tr>
<tr><td><code id="simulate_phenotype_on_tree_+3A_step">step</code></td>
<td>

<p>The time step size for simulating the phenotype. If not provided,
then calculated as <code>min(0.001,tree.height/1000)</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>tree</code></td>
<td>
<p>The simulated tree in <code>phylo</code> format.</p>
</td></tr>
<tr><td><code>phenotype</code></td>
<td>
<p>A list of the trajectory of the simulated phenotype. 
Each entry corresponds to a lineage that started at some point of the tree.
Each entry is a matrix with first row equalling time (relative to start of 
the lineage, hence if absolute time since tree's origin is needed it
needs to be recalculated, see <code>draw_phylproc()</code>'s code) and the next 
rows correspond to the trait value(s).</p>
</td></tr>
<tr><td><code>root.branch.phenotype</code></td>
<td>
<p>The simulation on the root branch.
A matrix with first row being time and next rows the simulated trait(s).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_phylproc">simulate_phylproc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate 3d OUBM model
## This example requires the R package ape
## (to generate the tree in phylo format).
set.seed(12345)

phyltree&lt;-ape::rphylo(n=5,birth=1,death=0)
simulate_mvsl_sde&lt;-function(time,params,X0,step){
    A &lt;- c(paste("(-",params$a11,")*(x1-(",params$psi1,"))
    -(",params$a12,")*(x2-(",params$psi2,"))-(",params$b11,")*x3",sep=""),
    paste("(-",params$a21,")*(x1-(",params$psi1,"))
    -(",params$a22,")*(x2-(",params$psi2,"))-(",params$b21,")*x3",sep=""),0)
    S &lt;- matrix( c( params$s11, params$s12, 0, 0, params$s22 
    , 0, 0, 0, params$s33), 3, 3,byrow=TRUE)
    yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
    state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
    simulate_sde_on_branch(time,yuima.3d,X0,step)
}

birth.params&lt;-list(scale=1,maxval=10000)

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=-2.4590422,psi2=-0.6197838)
X0&lt;-c(5.723548,4.103157,3.834698)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
          ## in reality should be much smaller e.g. step&lt;-0.001                      
simres&lt;-simulate_phenotype_on_tree(phyltree, simulate_mvsl_sde, sde.params, X0, step)
</code></pre>

<hr>
<h2 id='simulate_phylproc'>
Simultaneously simulate a phylogeny and a trait evolving on it.
</h2><span id='topic+simulate_phylproc'></span>

<h3>Description</h3>

<p>The function does simulates a phylogeny and phenotypic dataset under 
user defined models of trait and phylogeny evolution. In particular 
the phenotype may influence the branching dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_phylproc(tree.height, simul.params, X0, fbirth, fdeath=NULL, 
fbirth.params=NULL, fdeath.params=NULL, fsimulphenotype="sde.yuima", 
n.contemporary=-1, n.tips.total=1000, step=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_phylproc_+3A_tree.height">tree.height</code></td>
<td>

<p>The height of the desired output tree. The simulated tree 
is conditioned to be of a certain height. 
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_simul.params">simul.params</code></td>
<td>

<p>The parameters of the stochastic model to simulate the phenotype. 
They should be passed as a named list. 
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_x0">X0</code></td>
<td>

<p>The value of the ancestral state at the start of the tree.
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_fbirth">fbirth</code></td>
<td>

<p>A function that returns the birth rate at a given moment.
The fist parameter of the function has to correspond to the value of the
phenotype (it is a vector first element is time and the others the values of the trait(s)) 
and the second to the list of birth parameters <code>birth.params</code>,
see <code>par0</code>. The time entry of the phenotype vector is at the moment relative to 
an unspecified (from <code>fbirth</code>'s perspective) speciation event on the phylogeny.
Hence, it cannot be used as for writing a time-inhomogenous speciation
function. The speciation process is assumed to be time homogeneous in the 
current implementation. The package has support for two inbuilt rate functions.
The can be indicated by passing a string in <code>fbirth</code>: either <code>"rate_id"</code>
or <code>"rate_const"</code>. The string <code>"rate_const"</code> corresponds to a 
constant rate and has to have the rate's value in field called <code>$rate</code>.
However, a switching of rates is allowed. If the value of the first trait
exceeds a certain threshold (provided in field <code>$switch</code> of 
birth parameters), then the rate is changed to the value in <code>$rate2</code>,
see body of hidden function <code>.f_rate_const()</code>, in file <code>rates.R</code>.
The string <code>"rate_id"</code> corresponds to the <code>.f_rate_id()</code> function, 
in file <code>rates.R</code>. If the birth parameters are <code>NULL</code>, then the
rate equals the value of the first phenotype. However, a number 
of linear, threshold and power transformations of the rate are
possible.The field <code>varnum</code> indicates the index of the variable
to take as the one influencing the rate (remember to add 1 for the time entry).
Then, if <code class="reqn">x</code> stands for the trait influencing the branching rate it is 
transformed into a rate by the following fields in the following order. 
Set <code>rate&lt;-x</code> and let <code>params</code> correspond to the list containing
the branching parameters.
</p>

<ul>
<li><p><code>substractbase</code>rate&lt;-max(0,params$rate-substractbase)
<code>rate&lt;-abs(rate)</code>
</p>
</li>
<li><p><code>p</code> and if <code>is.null(params$raise.at.end) || !params$raise.at.end</code>
rate&lt;-rate^params$p
</p>
</li>
<li><p><code>base</code> and <code>!is.null(params$const)</code> <br /> <code>if (res&lt;params$base){rate&lt;-params$const}</code>
</p>
</li>
<li><p><code>base</code> and <code>is.null(params$const)</code> <br /> <code>if (res&lt;params$base){rate&lt;-0}</code>
</p>
</li>
<li><p><code>invbase</code> and <code>!is.null(params$const)</code> <br /> <code>if (res&gt;params$invbase){rate&lt;-params$const}</code>
</p>
</li>
<li><p><code>invbase</code> and <code>is.null(params$const)</code> <br /> <code>if (res&gt;params$invbase){rate&lt;-0}</code>
</p>
</li>
<li><p><code>scale</code>rate&lt;-rate/params$scale
</p>
</li>
<li><p><code>p</code> and if <code>params$raise.at.end</code>rate&lt;-rate^params$p
<code>res&lt;-abs(res)</code>
</p>
</li>
<li><p><code>maxval</code><code>if(rate&gt;params$maxval){rate&lt;-params$maxval}</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="simulate_phylproc_+3A_fdeath">fdeath</code></td>
<td>

<p>A function that returns the birth rate at a given moment. Its structure
is the same as <code>fbirth</code>. The current version of the  package does 
not provide any support for any inbuilt function.
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_fbirth.params">fbirth.params</code></td>
<td>

<p>The parameters of the birth rate, to be provided to <code>fbirth</code>.
They have to be a named list. 
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_fdeath.params">fdeath.params</code></td>
<td>

<p>The parameters of the death rate, to be provided to <code>fdeath</code>.
They have to be a named list. 
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_fsimulphenotype">fsimulphenotype</code></td>
<td>

<p>The name of a function to simulate the phenotype over a period of time. 
The function has to have four parameters (in the following order not by name):
<code>time</code>, <code>params</code>, <code>X0</code> and <code>step</code>.
The parameter <code>time</code> is the duration of the simulation, i.e. the length
of the branch. The parameter <code>params</code> is a list of
the parameters governing the simulation, what will be passed here
is the list <br /> <code>phenotype.model.params</code>, without the fields
<code>fixed</code>, <code>abstepsd</code> and <br /> <code>positivevars</code>. It is up
to the function in <code>phenotype.model</code> to interpret the 
provided parameters. <code>X0</code> stands for the value at the start of the branch
and <code>step</code> is a control parameter governing the time 
step size of the simulation. The <span class="pkg">pcmabc</span> package has inbuilt support for 
simulating the trait as as stochastic differential equation by the <span class="pkg">yuima</span> 
package with the function <code>simulate_sde_on_branch()</code>. However
the user needs to write the <code>phenotype.model</code> function that translates
the vector of parameters into an object that is understandable by <span class="pkg">yuima</span>
and then call <code>simulate_sde_on_branch()</code>, see the Example.
</p>
<p>The phenotype is simulated prior to the simulation of the speciation/extinction
events on a lineage (see Details). Hence, it is not possible (at the moment) 
to include some special event (e.g. a cladogenetic jump) at branching. Such
dynamics are only possible at the start of the lineage, i.e. when the new lineage
separated from the main lineage. Hence, cladogenetic change can only be 
included as an event connected with a lineage (subpopulation) breaking off.
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_n.contemporary">n.contemporary</code></td>
<td>

<p>The number of contemporary species to generate. If equals -1, then ignored.
Otherwise when the tree reaches <code>n.contemporary</code> tips at height
<code>tree.height</code> the simulation is stopped. However, there is no
conditioning on this value, it is just an upper bound. It may
just happen that due to the birth and death rate functions the
process stops before reaching the target number of tips.
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_n.tips.total">n.tips.total</code></td>
<td>

<p>The total (contemporary and extinct) number of tips to generate.
If equals -1, then ignored. Otherwise when the tree reaches 
<code>n.tips.total</code> tips the simulation is stopped. However, there is 
no conditioning on this value, it is just an upper bound. It may
just happen that due to the birth and death rate functions the
process stops before reaching the target number of tips.
</p>
</td></tr>
<tr><td><code id="simulate_phylproc_+3A_step">step</code></td>
<td>

<p>The time step size for simulating the phenotype. If not provided,
then calculated as <code>min(0.001,tree.height/1000)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tree is simulate by means of a Cox process (i.e. Poisson process
with random rate). First the trait is simulated along the spine of a 
tree, i.e. a lineage of duration <code>tree.height</code>. Then, along this
spine the birth and death rates are calculated (they may depend 
on the value of the phenotype). The maximum for each rate is calculated
and a homogeneous Poisson process with the maximum rate is simulated.
Then, these events are thinned. Each event is retained with probability
equalling true rate divided by maximum of rate (p. 32, Sheldon 2006). 
All speciation events are retained until the first death event.
</p>


<h3>Value</h3>

<table>
<tr><td><code>tree</code></td>
<td>
<p>The simulated tree in <code>phylo</code> format.</p>
</td></tr>
<tr><td><code>phenotype</code></td>
<td>
<p>A list of the trajectory of the simulated phenotype. 
The i-th entry of the list corresponds to the trait's evolution on
the i-th edge (as in i-th row of <code>phyltree$edge</code>) of the tree.
Each entry is a matrix with first row equalling time (relative to the 
start of the branch) and the next rows correspond to the trait value(s).</p>
</td></tr>
<tr><td><code>root.branch.phenotype</code></td>
<td>
<p>The simulation on the root branch.
A matrix with first row being time and next rows the simulated trait(s).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>
<p>Sheldon R. M. (2006). Simulation. Elsevier Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCM_ABC">PCM_ABC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate 3d OUBM model with id branching rate
set.seed(12345)

simulate_mvsl_sde&lt;-function(time,params,X0,step){
    A &lt;- c(paste("(-",params$a11,")*(x1-(",params$psi1,"))
    -(",params$a12,")*(x2-(",params$psi2,"))-(",params$b11,")*x3",sep=""),
    paste("(-",params$a21,")*(x1-(",params$psi1,"))
    -(",params$a22,")*(x2-(",params$psi2,"))-(",params$b21,")*x3",sep=""),0)
    S &lt;- matrix( c( params$s11, params$s12, 0, 0, params$s22 
    , 0, 0, 0, params$s33), 3, 3,byrow=TRUE)
    yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
    state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
    simulate_sde_on_branch(time,yuima.3d,X0,step)
}

birth.params&lt;-list(scale=1,maxval=2)

sde.params&lt;-list(a11=2.569531,a12=0,a21=0,a22=28.2608,b11=-5.482939,
b21=-34.806936,s11=0.5513215,s12=1.059831,s22=1.247302,s33=1.181376,
psi1=-2.4590422,psi2=-0.6197838)
X0&lt;-c(5.723548,4.103157,3.834698)
step&lt;-0.25 ## for keeping example's running time short &lt;5s as CRAN policy, 
            ## in reality should be much smaller e.g. step&lt;-0.001          
            
simres&lt;-simulate_phylproc(3.5, sde.params, X0, fbirth="rate_id", fdeath=NULL, 
fbirth.params=NULL, fdeath.params=NULL, fsimulphenotype=simulate_mvsl_sde, 
n.contemporary=5, n.tips.total=-1, step=step)
</code></pre>

<hr>
<h2 id='simulate_sde_on_branch'>
Simulate a stochastic differential equation on a branch. using
the <span class="pkg">yuima</span> 
</h2><span id='topic+simulate_sde_on_branch'></span>

<h3>Description</h3>

<p>The function simulates a stochastic differential equation on a branch using
the <span class="pkg">yuima</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sde_on_branch(branch.length, model.yuima, X0, step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_sde_on_branch_+3A_branch.length">branch.length</code></td>
<td>

<p>The length of the branch.
</p>
</td></tr>
<tr><td><code id="simulate_sde_on_branch_+3A_model.yuima">model.yuima</code></td>
<td>

<p>A object that <span class="pkg">yuima</span> can understand in order to simulate
a stochastic differential equation, see Example.
</p>
</td></tr>
<tr><td><code id="simulate_sde_on_branch_+3A_x0">X0</code></td>
<td>

<p>The value at the start of the branch.
</p>
</td></tr>
<tr><td><code id="simulate_sde_on_branch_+3A_step">step</code></td>
<td>

<p>The simulation step size that is provided to <span class="pkg">yuima</span>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for calling <code>yuima::simulate()</code>.
</p>


<h3>Value</h3>

<p>It returns a matrix whose first row are the time points on the 
branch and the remaining rows the values of the trait(s).
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Lio', P (2019). 
Modelling trait dependent speciation with Approximate Bayesian Computation.
Acta Physica Polonica B Proceedings Supplement 12(1):25-47.
</p>
<p>Brouste A., Fukasawa M., Hino H., Iacus S. M., Kamatani K., Koike Y., 
Masuda H., Nomura R., Ogihara T., Shimuzu Y., Uchida M., Yoshida N. (2014). 
The YUIMA Project: A Computational Framework for Simulation and Inference of 
Stochastic Differential Equations. Journal of Statistical Software, 57(4): 1-51. 
</p>
<p>Iacus S. M., Mercuri L., Rroji E. (2017). 
COGARCH(p,q): Simulation and Inference with the yuima Package. 
Journal of Statistical Software, 80(4): 1-49.
</p>


<h3>See Also</h3>

<p><code><a href="yuima.html#topic+setModel">setModel</a></code>, <code><a href="yuima.html#topic+setSampling">setSampling</a></code>, 
<code><a href="yuima.html#topic+simulate">simulate</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a 3D OUBM process on a branch
set.seed(12345)

A &lt;-c("-(x1-1)-2*x3","-(x2+1)+2*x3",0)
S &lt;- matrix( c( 1, 2, 0, 0, 1 , 0, 0, 0, 
2), 3, 3,byrow=TRUE)
yuima.3d &lt;- yuima::setModel(drift = A, diffusion = S,
state.variable=c("x1","x2","x3"),solve.variable=c("x1","x2","x3") )
X0&lt;-c(0,0,0)
step&lt;-0.5 ## for keeping example's running time short &lt;5s as CRAN policy, 
          ## in reality should be much smaller e.g. step&lt;-0.001          
            
time&lt;-1
simulate_sde_on_branch(time,yuima.3d,X0,step)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
