<!DOCTYPE html><html><head><title>Help for package dm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dm-package'><p>dm: Relational Data Models</p></a></li>
<li><a href='#check_key'><p>Check if column(s) can be used as keys</p></a></li>
<li><a href='#check_set_equality'><p>Check column values for set equality</p></a></li>
<li><a href='#check_subset'><p>Check column values for subset</p></a></li>
<li><a href='#copy_dm_to'><p>Copy data model to data source</p></a></li>
<li><a href='#db_schema_create'><p>Create a schema on a database</p></a></li>
<li><a href='#db_schema_drop'><p>Remove a schema from a database</p></a></li>
<li><a href='#db_schema_exists'><p>Check for existence of a schema on a database</p></a></li>
<li><a href='#db_schema_list'><p>List schemas on a database</p></a></li>
<li><a href='#decompose_table'><p>Decompose a table into two linked tables</p></a></li>
<li><a href='#deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#dm'><p>Data model class</p></a></li>
<li><a href='#dm_add_fk'><p>Add foreign keys</p></a></li>
<li><a href='#dm_add_pk'><p>Add a primary key</p></a></li>
<li><a href='#dm_add_uk'><p>Add a unique key</p></a></li>
<li><a href='#dm_deconstruct'><p>Create code to deconstruct a dm object</p></a></li>
<li><a href='#dm_disambiguate_cols'><p>Resolve column name ambiguities</p></a></li>
<li><a href='#dm_draw'><p>Draw a diagram of the data model</p></a></li>
<li><a href='#dm_enum_fk_candidates'><p>Foreign key candidates</p></a></li>
<li><a href='#dm_examine_cardinalities'><p>Learn about your data model</p></a></li>
<li><a href='#dm_examine_constraints'><p>Validate your data model</p></a></li>
<li><a href='#dm_filter'><p>Filtering</p></a></li>
<li><a href='#dm_financial'><p>Creates a dm object for the Financial data</p></a></li>
<li><a href='#dm_flatten_to_tbl'><p>Flatten a part of a <code>dm</code> into a wide table</p></a></li>
<li><a href='#dm_from_con'><p>Load a dm from a remote data source</p></a></li>
<li><a href='#dm_from_src'><p>Load a dm from a remote data source</p></a></li>
<li><a href='#dm_get_all_fks'><p>Get foreign key constraints</p></a></li>
<li><a href='#dm_get_all_pks'><p>Get all primary keys of a <code>dm</code> object</p></a></li>
<li><a href='#dm_get_all_uks'><p>Get all unique keys of a <code>dm</code> object</p></a></li>
<li><a href='#dm_get_con'><p>Get connection</p></a></li>
<li><a href='#dm_get_pk'><p>Primary key column names</p></a></li>
<li><a href='#dm_get_tables'><p>Get tables</p></a></li>
<li><a href='#dm_gui'><p>Shiny app for defining dm objects</p></a></li>
<li><a href='#dm_has_fk'><p>Check if foreign keys exists</p></a></li>
<li><a href='#dm_has_pk'><p>Check for primary key</p></a></li>
<li><a href='#dm_mutate_tbl'><p>Update tables in a <code>dm</code></p></a></li>
<li><a href='#dm_nest_tbl'><p>Nest a table inside its dm</p></a></li>
<li><a href='#dm_nrow'><p>Number of rows</p></a></li>
<li><a href='#dm_nycflights13'><p>Creates a dm object for the <span class="pkg">nycflights13</span> data</p></a></li>
<li><a href='#dm_pack_tbl'><p>dm_pack_tbl()</p></a></li>
<li><a href='#dm_paste'><p>Create R code for a dm object</p></a></li>
<li><a href='#dm_pixarfilms'><p>Creates a dm object for the <span class="pkg">pixarfilms</span> data</p></a></li>
<li><a href='#dm_ptype'><p>Prototype for a dm object</p></a></li>
<li><a href='#dm_rename'><p>Rename columns</p></a></li>
<li><a href='#dm_rm_fk'><p>Remove foreign keys</p></a></li>
<li><a href='#dm_rm_pk'><p>Remove a primary key</p></a></li>
<li><a href='#dm_rm_uk'><p>Remove a unique key</p></a></li>
<li><a href='#dm_select'><p>Select columns</p></a></li>
<li><a href='#dm_select_tbl'><p>Select and rename tables</p></a></li>
<li><a href='#dm_set_colors'><p>Color in database diagrams</p></a></li>
<li><a href='#dm_set_table_description'><p>Add info about a dm's tables</p></a></li>
<li><a href='#dm_sql'><p>Create <em>DDL</em> and <em>DML</em> scripts for a <code>dm</code> a and database connection</p></a></li>
<li><a href='#dm_unnest_tbl'><p>Unnest columns from a wrapped table</p></a></li>
<li><a href='#dm_unpack_tbl'><p>Unpack columns from a wrapped table</p></a></li>
<li><a href='#dm_unwrap_tbl'><p>Unwrap a single table dm</p></a></li>
<li><a href='#dm_validate'><p>Validator</p></a></li>
<li><a href='#dm_wrap_tbl'><p>Wrap dm into a single tibble dm</p></a></li>
<li><a href='#dm_zoom_to'><p>Mark table for manipulation</p></a></li>
<li><a href='#dplyr_join'><p><span class="pkg">dplyr</span> join methods for zoomed dm objects</p></a></li>
<li><a href='#dplyr_src'><p>dm as data source</p></a></li>
<li><a href='#dplyr_table_manipulation'><p><span class="pkg">dplyr</span> table manipulation methods for zoomed dm objects</p></a></li>
<li><a href='#enum_pk_candidates'><p>Primary key candidate</p></a></li>
<li><a href='#examine_cardinality'><p>Check table relations</p></a></li>
<li><a href='#glimpse.dm'><p>Get a glimpse of your <code>dm</code> object</p></a></li>
<li><a href='#head.dm_zoomed'><p><span class="pkg">utils</span> table manipulation methods for <code>dm_zoomed</code> objects</p></a></li>
<li><a href='#json_nest'><p>JSON nest</p></a></li>
<li><a href='#json_nest_join'><p>JSON nest join</p></a></li>
<li><a href='#json_pack'><p>JSON pack</p></a></li>
<li><a href='#json_pack_join'><p>JSON pack join</p></a></li>
<li><a href='#json_unnest'><p>Unnest a JSON column</p></a></li>
<li><a href='#json_unpack'><p>Unpack a JSON column</p></a></li>
<li><a href='#materialize'><p>Materialize</p></a></li>
<li><a href='#pack_join'><p>Pack Join</p></a></li>
<li><a href='#pull_tbl'><p>Retrieve a table</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reunite_parent_child'><p>Merge two tables that are linked by a foreign key relation</p></a></li>
<li><a href='#rows-dm'><p>Modifying rows for multiple tables</p></a></li>
<li><a href='#tidyr_table_manipulation'><p><span class="pkg">tidyr</span> table manipulation methods for zoomed dm objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Relational Data Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for working with multiple related
    tables, stored as data frames or in a relational database.  Multiple
    tables (data and metadata) are stored in a compound object, which can
    then be manipulated with a pipe-friendly syntax.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dm.cynkra.com/">https://dm.cynkra.com/</a>, <a href="https://github.com/cynkra/dm">https://github.com/cynkra/dm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cynkra/dm/issues">https://github.com/cynkra/dm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports, cli (&ge; 2.2.0), dplyr (&ge; 1.1.0), glue, igraph,
lifecycle (&ge; 1.0.3), memoise, methods, purrr (&ge; 1.0.0), rlang
(&ge; 1.0.2), tibble (&ge; 3.0.0), tidyr (&ge; 1.0.0), tidyselect (&ge;
1.2.0), vctrs (&ge; 0.3.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brio, colourpicker, covr, crayon, DBI (&ge; 1.2.0), dbplyr (&ge;
2.3.4), DiagrammeR, DiagrammeRsvg, digest, duckdb (&ge; 0.4.0),
fansi, forcats, htmltools, htmlwidgets, jsonlite, keyring,
knitr, labelled (&ge; 2.12.0), magrittr, mockr, nycflights13,
odbc, pillar, pixarfilms, pool, progress, reactable, RMariaDB
(&ge; 1.3.0), rmarkdown, RPostgres, RSQLite (&ge; 2.2.8),
rstudioapi, shiny, shinyAce, shinydashboard, testthat (&ge;
3.1.2), waldo, withr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>brio, bslib, cynkra/cynkratemplate, htmltools,
pagedown, purrr, rmarkdown, whisker, xml2</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>anthonynorth/roxyglobals</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/autostyle/scope:</td>
<td>line_breaks</td>
</tr>
<tr>
<td>Config/autostyle/strict:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>zzx-deprecated, flatten, dplyr, filter-dm,
draw-dm, bind, rows-dm, learn</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 10:45:53 UTC; kirill</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Schieferdecker [aut],
  Kirill MÃ¼ller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Antoine Fabri [ctb],
  Darko Bergant [aut],
  Katharina Brunner [ctb],
  James Wondrasek [ctb],
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  MaÃ«lle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  energie360Â° AG [fnd],
  cynkra GmbH [fnd, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kirill MÃ¼ller &lt;kirill@cynkra.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 16:32:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='dm-package'>dm: Relational Data Models</h2><span id='topic+dm-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides tools for working with multiple related tables, stored as data frames or in a relational database. Multiple tables (data and metadata) are stored in a compound object, which can then be manipulated with a pipe-friendly syntax.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kirill MÃ¼ller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Tobias Schieferdecker <a href="mailto:tobias@cynkra.com">tobias@cynkra.com</a>
</p>
</li>
<li><p> Darko Bergant <a href="mailto:darko.bergant@gmail.com">darko.bergant@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Antoine Fabri [contributor]
</p>
</li>
<li><p> Katharina Brunner [contributor]
</p>
</li>
<li><p> James Wondrasek [contributor]
</p>
</li>
<li><p> Indrajeet Patil (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) [contributor]
</p>
</li>
<li><p> MaÃ«lle Salmon (<a href="https://orcid.org/0000-0002-2815-0399">ORCID</a>) [contributor]
</p>
</li>
<li><p> energie360Â° AG <a href="mailto:info@energie360.ch">info@energie360.ch</a> [funder]
</p>
</li>
<li><p> cynkra GmbH <a href="mailto:mail@cynkra.com">mail@cynkra.com</a> [funder, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dm.cynkra.com/">https://dm.cynkra.com/</a>
</p>
</li>
<li> <p><a href="https://github.com/cynkra/dm">https://github.com/cynkra/dm</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cynkra/dm/issues">https://github.com/cynkra/dm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_key'>Check if column(s) can be used as keys</h2><span id='topic+check_key'></span>

<h3>Description</h3>

<p><code>check_key()</code> accepts a data frame and, optionally, columns.
It throws an error
if the specified columns are NOT a unique key of the data frame.
If the columns given in the ellipsis ARE a key, the data frame itself is returned silently, so that it can be used for piping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_key(x, ..., .data = deprecated())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_key_+3A_x">x</code></td>
<td>
<p>The data frame whose columns should be tested for key properties.</p>
</td></tr>
<tr><td><code id="check_key_+3A_...">...</code></td>
<td>
<p>The names of the columns to be checked, processed with
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. If omitted, all columns will be checked.</p>
</td></tr>
<tr><td><code id="check_key_+3A_.data">.data</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code>, invisibly, if the check is passed.
Otherwise an error is thrown and the reason for it is explained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble::tibble(a = c(1, 2, 1), b = c(1, 4, 1), c = c(5, 6, 7))
# this is failing:
try(check_key(data, a, b))

# this is passing:
check_key(data, a, c)
check_key(data)
</code></pre>

<hr>
<h2 id='check_set_equality'>Check column values for set equality</h2><span id='topic+check_set_equality'></span>

<h3>Description</h3>

<p><code>check_set_equality()</code> is a wrapper of <code><a href="#topic+check_subset">check_subset()</a></code>.
</p>
<p>It tests if one table is a subset of another and vice versa, i.e., if both sets are the same.
If not, it throws an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_set_equality(
  x,
  y,
  ...,
  x_select = NULL,
  y_select = NULL,
  by_position = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_set_equality_+3A_x">x</code>, <code id="check_set_equality_+3A_y">y</code></td>
<td>
<p>A data frame or lazy table.</p>
</td></tr>
<tr><td><code id="check_set_equality_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="check_set_equality_+3A_x_select">x_select</code>, <code id="check_set_equality_+3A_y_select">y_select</code></td>
<td>
<p>Key columns to restrict the check, processed with
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.</p>
</td></tr>
<tr><td><code id="check_set_equality_+3A_by_position">by_position</code></td>
<td>
<p>Set to <code>TRUE</code> to ignore column names and match
by position instead.
The default means matching by name, use <code>x_select</code> and/or <code>y_select</code>
to align the names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code>, invisibly, if the check is passed.
Otherwise an error is thrown and the reason for it is explained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_1 &lt;- tibble::tibble(a = c(1, 2, 1), b = c(1, 4, 1), c = c(5, 6, 7))
data_2 &lt;- tibble::tibble(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
# this is failing:
try(check_set_equality(data_1, data_2, x_select = a, y_select = a))

data_3 &lt;- tibble::tibble(a = c(2, 1, 2), b = c(4, 5, 6), c = c(7, 8, 9))
# this is passing:
check_set_equality(data_1, data_3, x_select = a, y_select = a)
# this is still failing:
try(check_set_equality(data_2, data_3))
</code></pre>

<hr>
<h2 id='check_subset'>Check column values for subset</h2><span id='topic+check_subset'></span>

<h3>Description</h3>

<p><code>check_subset()</code> tests if <code>x</code> is a subset of <code>y</code>.
For convenience, the <code>x_select</code> and <code>y_select</code> arguments allow restricting the check
to a set of key columns without affecting the return value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_subset(x, y, ..., x_select = NULL, y_select = NULL, by_position = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_subset_+3A_x">x</code>, <code id="check_subset_+3A_y">y</code></td>
<td>
<p>A data frame or lazy table.</p>
</td></tr>
<tr><td><code id="check_subset_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="check_subset_+3A_x_select">x_select</code>, <code id="check_subset_+3A_y_select">y_select</code></td>
<td>
<p>Key columns to restrict the check, processed with
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.</p>
</td></tr>
<tr><td><code id="check_subset_+3A_by_position">by_position</code></td>
<td>
<p>Set to <code>TRUE</code> to ignore column names and match
by position instead.
The default means matching by name, use <code>x_select</code> and/or <code>y_select</code>
to align the names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code>, invisibly, if the check is passed.
Otherwise an error is thrown and the reason for it is explained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_1 &lt;- tibble::tibble(a = c(1, 2, 1), b = c(1, 4, 1), c = c(5, 6, 7))
data_2 &lt;- tibble::tibble(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
# this is passing:
check_subset(data_1, data_2, x_select = a, y_select = a)

# this is failing:
try(check_subset(data_2, data_1))
</code></pre>

<hr>
<h2 id='copy_dm_to'>Copy data model to data source</h2><span id='topic+copy_dm_to'></span>

<h3>Description</h3>

<p><code>copy_dm_to()</code> takes a <a href="dplyr.html#topic+src_dbi">dplyr::src_dbi</a> object or a <code><a href="DBI.html#topic+DBIConnection-class">DBI::DBIConnection</a></code> object as its first argument
and a <code><a href="#topic+dm">dm</a></code> object as its second argument.
The latter is copied to the former.
The default is to create temporary tables, set <code>temporary = FALSE</code> to create permanent tables.
Unless <code>set_key_constraints</code> is <code>FALSE</code>, primary key constraints are set on all databases,
and in addition foreign key constraints are set on MSSQL and Postgres databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_dm_to(
  dest,
  dm,
  ...,
  set_key_constraints = TRUE,
  table_names = NULL,
  temporary = TRUE,
  schema = NULL,
  progress = NA,
  unique_table_names = NULL,
  copy_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_dm_to_+3A_dest">dest</code></td>
<td>
<p>An object of class <code>"src"</code> or <code>"DBIConnection"</code>.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_set_key_constraints">set_key_constraints</code></td>
<td>
<p>If <code>TRUE</code> will mirror <code>dm</code> primary and foreign key constraints on a database
and create indexes for foreign key constraints.
Set to <code>FALSE</code> if your data model currently does not satisfy primary or foreign key constraints.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_table_names">table_names</code></td>
<td>
<p>Desired names for the tables on <code>dest</code>; the names within the <code>dm</code> remain unchanged.
Can be <code>NULL</code>, a named character vector, or a vector of <a href="DBI.html#topic+Id">DBI::Id</a> objects.
</p>
<p>If left <code>NULL</code> (default), the names will be determined automatically depending on the <code>temporary</code> argument:
</p>

<ol>
<li> <p><code>temporary = TRUE</code> (default): unique table names based on the names of the tables in the <code>dm</code> are created.
</p>
</li>
<li> <p><code>temporary = FALSE</code>: the table names in the <code>dm</code> are used as names for the tables on <code>dest</code>.
</p>
</li></ol>

<p>If a function or one-sided formula, <code>table_names</code> is converted to a function
using <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
This function is called with the unquoted table names of the <code>dm</code> object
as the only argument.
The output of this function is processed by <code><a href="DBI.html#topic+dbQuoteIdentifier">DBI::dbQuoteIdentifier()</a></code>,
that result should be a vector of identifiers of the same length
as the original table names.
</p>
<p>Use a variant of
<code>table_names = ~ DBI::SQL(paste0("schema_name", ".", .x))</code>
to specify the same schema for all tables.
Use <code>table_names = identity</code> with <code>temporary = TRUE</code>
to avoid giving temporary tables unique names.
</p>
<p>If a named character vector,
the names of this vector need to correspond to the table names in the <code>dm</code>,
and its values are the desired names on <code>dest</code>.
The value is processed by <code><a href="DBI.html#topic+dbQuoteIdentifier">DBI::dbQuoteIdentifier()</a></code>,
that result should be a vector of identifiers of the same length
as the original table names.
</p>
<p>Use qualified names corresponding to your database's syntax
to specify e.g. database and schema for your tables.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_temporary">temporary</code></td>
<td>
<p>If <code>TRUE</code>, only temporary tables will be created.
These tables will vanish when disconnecting from the database.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_schema">schema</code></td>
<td>
<p>Name of schema to copy the <code>dm</code> to.
If <code>schema</code> is provided, an error will be thrown if <code>temporary = FALSE</code> or
<code>table_names</code> is not <code>NULL</code>.
</p>
<p>Not all DBMS are supported.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_progress">progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
<tr><td><code id="copy_dm_to_+3A_unique_table_names">unique_table_names</code>, <code id="copy_dm_to_+3A_copy_to">copy_to</code></td>
<td>
<p>Must be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dm</code> object on the given <code>src</code> with the same table names
as the input <code>dm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- DBI::dbConnect(RSQLite::SQLite())

# Copy to temporary tables, unique table names by default:
temp_dm &lt;- copy_dm_to(
  con,
  dm_nycflights13(),
  set_key_constraints = FALSE
)

# Persist, explicitly specify table names:
persistent_dm &lt;- copy_dm_to(
  con,
  dm_nycflights13(),
  temporary = FALSE,
  table_names = ~ paste0("flights_", .x)
)
dbplyr::remote_name(persistent_dm$planes)

DBI::dbDisconnect(con)

</code></pre>

<hr>
<h2 id='db_schema_create'>Create a schema on a database</h2><span id='topic+db_schema_create'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>db_schema_create()</code> creates a schema on the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_schema_create(con, schema, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_schema_create_+3A_con">con</code></td>
<td>
<p>An object of class <code>"src"</code> or <code>"DBIConnection"</code>.</p>
</td></tr>
<tr><td><code id="db_schema_create_+3A_schema">schema</code></td>
<td>
<p>Class <code>character</code> or <code>SQL</code> (cf. Details), name of the schema</p>
</td></tr>
<tr><td><code id="db_schema_create_+3A_...">...</code></td>
<td>
<p>Passed on to the individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are not available for all DBMS.
</p>
<p>An error is thrown if a schema of that name already exists.
</p>
<p>The argument <code>schema</code> (and <code>dbname</code> for MSSQL) can be provided as <code>SQL</code> objects.
Keep in mind, that in this case it is assumed that they are already correctly quoted as identifiers
using <code><a href="DBI.html#topic+dbQuoteIdentifier">DBI::dbQuoteIdentifier()</a></code>.
</p>
<p>Additional arguments are:
</p>

<ul>
<li> <p><code>dbname</code>: supported for MSSQL. Create a schema in a different
database on the connected MSSQL-server; default: database addressed by <code>con</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>NULL</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other schema handling functions: 
<code><a href="#topic+db_schema_drop">db_schema_drop</a>()</code>,
<code><a href="#topic+db_schema_exists">db_schema_exists</a>()</code>,
<code><a href="#topic+db_schema_list">db_schema_list</a>()</code>
</p>

<hr>
<h2 id='db_schema_drop'>Remove a schema from a database</h2><span id='topic+db_schema_drop'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>db_schema_drop()</code> deletes a schema from the database.
For certain DBMS it is possible to force the removal of a non-empty schema, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_schema_drop(con, schema, force = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_schema_drop_+3A_con">con</code></td>
<td>
<p>An object of class <code>"src"</code> or <code>"DBIConnection"</code>.</p>
</td></tr>
<tr><td><code id="db_schema_drop_+3A_schema">schema</code></td>
<td>
<p>Class <code>character</code> or <code>SQL</code> (cf. Details), name of the schema</p>
</td></tr>
<tr><td><code id="db_schema_drop_+3A_force">force</code></td>
<td>
<p>Boolean, default <code>FALSE</code>. Set to <code>TRUE</code> to drop a schema and
all objects it contains at once. Currently only supported for Postgres.</p>
</td></tr>
<tr><td><code id="db_schema_drop_+3A_...">...</code></td>
<td>
<p>Passed on to the individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are not available for all DBMS.
</p>
<p>An error is thrown if no schema of that name exists.
</p>
<p>The argument <code>schema</code> (and <code>dbname</code> for MSSQL) can be provided as <code>SQL</code> objects.
Keep in mind, that in this case it is assumed that they are already correctly quoted as identifiers.
</p>
<p>Additional arguments are:
</p>

<ul>
<li> <p><code>dbname</code>: supported for MSSQL. Remove a schema from a different
database on the connected MSSQL-server; default: database addressed by <code>con</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>NULL</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other schema handling functions: 
<code><a href="#topic+db_schema_create">db_schema_create</a>()</code>,
<code><a href="#topic+db_schema_exists">db_schema_exists</a>()</code>,
<code><a href="#topic+db_schema_list">db_schema_list</a>()</code>
</p>

<hr>
<h2 id='db_schema_exists'>Check for existence of a schema on a database</h2><span id='topic+db_schema_exists'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>db_schema_exists()</code> checks, if a schema exists on the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_schema_exists(con, schema, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_schema_exists_+3A_con">con</code></td>
<td>
<p>An object of class <code>"src"</code> or <code>"DBIConnection"</code>.</p>
</td></tr>
<tr><td><code id="db_schema_exists_+3A_schema">schema</code></td>
<td>
<p>Class <code>character</code> or <code>SQL</code>, name of the schema</p>
</td></tr>
<tr><td><code id="db_schema_exists_+3A_...">...</code></td>
<td>
<p>Passed on to the individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are not available for all DBMS.
</p>
<p>Additional arguments are:
</p>

<ul>
<li> <p><code>dbname</code>: supported for MSSQL. Check if a schema exists on a different
database on the connected MSSQL-server; default: database addressed by <code>con</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A boolean: <code>TRUE</code> if schema exists, <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p>Other schema handling functions: 
<code><a href="#topic+db_schema_create">db_schema_create</a>()</code>,
<code><a href="#topic+db_schema_drop">db_schema_drop</a>()</code>,
<code><a href="#topic+db_schema_list">db_schema_list</a>()</code>
</p>

<hr>
<h2 id='db_schema_list'>List schemas on a database</h2><span id='topic+db_schema_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>db_schema_list()</code> lists the available schemas on the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_schema_list(con, include_default = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_schema_list_+3A_con">con</code></td>
<td>
<p>An object of class <code>"src"</code> or <code>"DBIConnection"</code>.</p>
</td></tr>
<tr><td><code id="db_schema_list_+3A_include_default">include_default</code></td>
<td>
<p>Boolean, if <code>TRUE</code> (default), also the default schema
on the database is included in the result</p>
</td></tr>
<tr><td><code id="db_schema_list_+3A_...">...</code></td>
<td>
<p>Passed on to the individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods are not available for all DBMS.
</p>
<p>Additional arguments are:
</p>

<ul>
<li> <p><code>dbname</code>: supported for MSSQL. List schemas on a different database on the connected MSSQL-server;
default: database addressed by <code>con</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>schema_name</code></dt><dd><p>the names of the schemas,</p>
</dd>
<dt><code>schema_owner</code></dt><dd><p>the schema owner names.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other schema handling functions: 
<code><a href="#topic+db_schema_create">db_schema_create</a>()</code>,
<code><a href="#topic+db_schema_drop">db_schema_drop</a>()</code>,
<code><a href="#topic+db_schema_exists">db_schema_exists</a>()</code>
</p>

<hr>
<h2 id='decompose_table'>Decompose a table into two linked tables</h2><span id='topic+decompose_table'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Perform table surgery by extracting a 'parent table' from a table, linking the original table and the new table by a key, and returning both tables.
</p>
<p><code>decompose_table()</code> accepts a data frame, a name for the 'ID column' that will be newly created, and the names
of the columns that will be extracted into the new data frame.
</p>
<p>It creates a 'parent table', which consists of the columns specified in the ellipsis, and a new 'ID column'.
Then it removes those
columns from the original table, which is now called the 'child table, and adds the 'ID column'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompose_table(.data, new_id_column, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decompose_table_+3A_.data">.data</code></td>
<td>
<p>Data frame from which columns <code>...</code> are to be extracted.</p>
</td></tr>
<tr><td><code id="decompose_table_+3A_new_id_column">new_id_column</code></td>
<td>
<p>Name of the identifier column (primary key column) for the parent table.
A column of this name is also added in 'child table'.</p>
</td></tr>
<tr><td><code id="decompose_table_+3A_...">...</code></td>
<td>
<p>The columns to be extracted from the <code>.data</code>.
</p>
<p>One or more unquoted expressions separated by commas.
You can treat variable names as if they were positions, so you
can use expressions like x:y to select ranges of variables.
</p>
<p>The arguments in ... are automatically quoted and evaluated in a context where column names represent column positions.
They also support
unquoting and splicing.
See vignette(&quot;programming&quot;) for an introduction to those concepts.
</p>
<p>See select helpers for more details, and the examples about tidyselect helpers, such as starts_with(), everything(), ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of length two:
</p>

<ul>
<li><p> entry &quot;child_table&quot;: the child table with column <code>new_id_column</code> referring to the same column in <code>parent_table</code>,
</p>
</li>
<li><p> entry &quot;parent_table&quot;: the &quot;lookup table&quot; for <code>child_table</code>.
</p>
</li></ul>



<h3>Life cycle</h3>

<p>This function is marked &quot;experimental&quot; because it seems more useful
when applied to a table in a dm object.
Changing the interface later seems harmless because these functions are
most likely used interactively.
</p>


<h3>See Also</h3>

<p>Other table surgery functions: 
<code><a href="#topic+reunite_parent_child">reunite_parent_child</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomposed_table &lt;- decompose_table(mtcars, new_id, am, gear, carb)
decomposed_table$child_table
decomposed_table$parent_table
</code></pre>

<hr>
<h2 id='deprecated'>Deprecated functions</h2><span id='topic+deprecated'></span><span id='topic+sql_schema_create'></span><span id='topic+sql_schema_drop'></span><span id='topic+sql_schema_exists'></span><span id='topic+sql_schema_list'></span><span id='topic+dm_apply_filters'></span><span id='topic+dm_apply_filters_to_tbl'></span><span id='topic+dm_get_filters'></span><span id='topic+dm_join_to_tbl'></span><span id='topic+dm_is_referenced'></span><span id='topic+dm_get_referencing_tables'></span><span id='topic+validate_dm'></span><span id='topic+check_if_subset'></span><span id='topic+check_cardinality'></span><span id='topic+cdm_get_src'></span><span id='topic+cdm_get_con'></span><span id='topic+cdm_get_tables'></span><span id='topic+cdm_get_filter'></span><span id='topic+cdm_add_tbl'></span><span id='topic+cdm_rm_tbl'></span><span id='topic+cdm_copy_to'></span><span id='topic+cdm_disambiguate_cols'></span><span id='topic+cdm_draw'></span><span id='topic+cdm_set_colors'></span><span id='topic+cdm_get_colors'></span><span id='topic+cdm_get_available_colors'></span><span id='topic+cdm_filter'></span><span id='topic+cdm_nrow'></span><span id='topic+cdm_flatten_to_tbl'></span><span id='topic+cdm_squash_to_tbl'></span><span id='topic+cdm_join_to_tbl'></span><span id='topic+cdm_apply_filters'></span><span id='topic+cdm_apply_filters_to_tbl'></span><span id='topic+cdm_add_pk'></span><span id='topic+cdm_add_fk'></span><span id='topic+cdm_has_fk'></span><span id='topic+cdm_get_fk'></span><span id='topic+cdm_get_all_fks'></span><span id='topic+cdm_rm_fk'></span><span id='topic+cdm_enum_fk_candidates'></span><span id='topic+cdm_is_referenced'></span><span id='topic+cdm_get_referencing_tables'></span><span id='topic+cdm_learn_from_db'></span><span id='topic+cdm_check_constraints'></span><span id='topic+cdm_nycflights13'></span><span id='topic+cdm_paste'></span><span id='topic+cdm_has_pk'></span><span id='topic+cdm_get_pk'></span><span id='topic+cdm_get_all_pks'></span><span id='topic+cdm_rm_pk'></span><span id='topic+cdm_enum_pk_candidates'></span><span id='topic+cdm_select_tbl'></span><span id='topic+cdm_rename_tbl'></span><span id='topic+cdm_select'></span><span id='topic+cdm_rename'></span><span id='topic+cdm_zoom_to_tbl'></span><span id='topic+cdm_insert_zoomed_tbl'></span><span id='topic+cdm_update_zoomed_tbl'></span><span id='topic+cdm_zoom_out'></span><span id='topic+dm_rm_tbl'></span><span id='topic+dm_add_tbl'></span><span id='topic+dm_bind'></span><span id='topic+dm_squash_to_tbl'></span><span id='topic+rows_truncate'></span><span id='topic+sql_rows_truncate'></span><span id='topic+dm_rows_truncate'></span>

<h3>Description</h3>

<p>These functions are deprecated in favor of better alternatives.
Most functions with the <code>cdm_</code> prefix have an identical alternative
with a <code>dm_</code> prefix.
</p>
<p><code style="white-space: pre;">&#8288;sql_schema_*()&#8288;</code> functions have been replaced with the corresponding
<code style="white-space: pre;">&#8288;db_schema_*()&#8288;</code> functions.
</p>
<p><code>dm_join_to_tbl()</code> is deprecated in favor of <code><a href="#topic+dm_flatten_to_tbl">dm_flatten_to_tbl()</a></code>.
</p>
<p><code>dm_is_referenced()</code> is soft-deprecated, use the information returned from
<code><a href="#topic+dm_get_all_fks">dm_get_all_fks()</a></code> instead.
</p>
<p><code>dm_get_referencing_tables()</code> is soft-deprecated, use the information
returned from <code><a href="#topic+dm_get_all_fks">dm_get_all_fks()</a></code> instead.
</p>
<p><code>validate_dm()</code> has been replaced by <code>dm_validate()</code> for consistency.
</p>
<p><code>dm_add_tbl</code> is deprecated as of dm 1.0.0, because the same functionality
is offered by <code><a href="#topic+dm">dm()</a></code> with <code>.name_repair = "unique"</code>.
</p>
<p><code>dm_bind()</code>  is deprecated as of dm 1.0.0, because the same functionality
is offered by <code><a href="#topic+dm">dm()</a></code>.
</p>
<p><code>dm_squash_to_tbl()</code>  is deprecated as of dm 1.0.0, because the same functionality
is offered by <code><a href="#topic+dm_flatten_to_tbl">dm_flatten_to_tbl()</a></code> with <code>recursive = TRUE</code>.
</p>
<p><code>rows_truncate()</code> is deprecated as of dm 1.0.0, because it's a DDL operation
and requires different permissions than the <code style="white-space: pre;">&#8288;dplyr::rows_*()&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sql_schema_create(dest, schema, ...)

sql_schema_drop(dest, schema, force = FALSE, ...)

sql_schema_exists(dest, schema, ...)

sql_schema_list(dest, include_default = TRUE, ...)

dm_apply_filters(dm)

dm_apply_filters_to_tbl(dm, table)

dm_get_filters(dm)

dm_join_to_tbl(dm, table_1, table_2, join = left_join)

dm_is_referenced(dm, table)

dm_get_referencing_tables(dm, table)

validate_dm(x)

check_if_subset(t1, c1, t2, c2)

check_cardinality(parent_table, pk_column, child_table, fk_column)

cdm_get_src(x)

cdm_get_con(x)

cdm_get_tables(x)

cdm_get_filter(x)

cdm_add_tbl(dm, ..., repair = "unique", quiet = FALSE)

cdm_rm_tbl(dm, ...)

cdm_copy_to(
  dest,
  dm,
  ...,
  types = NULL,
  overwrite = NULL,
  indexes = NULL,
  unique_indexes = NULL,
  set_key_constraints = TRUE,
  unique_table_names = FALSE,
  table_names = NULL,
  temporary = TRUE
)

cdm_disambiguate_cols(dm, sep = ".", quiet = FALSE)

cdm_draw(
  dm,
  rankdir = "LR",
  col_attr = "column",
  view_type = "keys_only",
  columnArrows = TRUE,
  graph_attrs = "",
  node_attrs = "",
  edge_attrs = "",
  focus = NULL,
  graph_name = "Data Model"
)

cdm_set_colors(dm, ...)

cdm_get_colors(dm)

cdm_get_available_colors()

cdm_filter(dm, table, ...)

cdm_nrow(dm)

cdm_flatten_to_tbl(dm, start, ..., join = left_join)

cdm_squash_to_tbl(dm, start, ..., join = left_join)

cdm_join_to_tbl(dm, table_1, table_2, join = left_join)

cdm_apply_filters(dm)

cdm_apply_filters_to_tbl(dm, table)

cdm_add_pk(dm, table, column, check = FALSE, force = FALSE)

cdm_add_fk(dm, table, column, ref_table, check = FALSE)

cdm_has_fk(dm, table, ref_table)

cdm_get_fk(dm, table, ref_table)

cdm_get_all_fks(dm)

cdm_rm_fk(dm, table, columns, ref_table)

cdm_enum_fk_candidates(dm, table, ref_table)

cdm_is_referenced(dm, table)

cdm_get_referencing_tables(dm, table)

cdm_learn_from_db(dest)

cdm_check_constraints(dm)

cdm_nycflights13(cycle = FALSE, color = TRUE, subset = TRUE)

cdm_paste(dm, select = FALSE, tab_width = 2)

cdm_has_pk(dm, table)

cdm_get_pk(dm, table)

cdm_get_all_pks(dm)

cdm_rm_pk(dm, table, rm_referencing_fks = FALSE)

cdm_enum_pk_candidates(dm, table)

cdm_select_tbl(dm, ...)

cdm_rename_tbl(dm, ...)

cdm_select(dm, table, ...)

cdm_rename(dm, table, ...)

cdm_zoom_to_tbl(dm, table)

cdm_insert_zoomed_tbl(
  dm,
  new_tbl_name = NULL,
  repair = "unique",
  quiet = FALSE
)

cdm_update_zoomed_tbl(dm)

cdm_zoom_out(dm)

dm_rm_tbl(dm, ...)

dm_add_tbl(dm, ..., repair = "unique", quiet = FALSE)

dm_bind(..., repair = "check_unique", quiet = FALSE)

dm_squash_to_tbl(dm, start, ..., join = left_join)

rows_truncate(x, ..., in_place = FALSE)

sql_rows_truncate(x, ...)

dm_rows_truncate(x, y, ..., in_place = NULL, progress = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_force">force</code></td>
<td>
<p>Boolean, if <code>FALSE</code> (default), an error will be thrown if there is already a primary key
set for this table.
If <code>TRUE</code>, a potential old <code>pk</code> is deleted before setting a new one.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_table_1">table_1</code></td>
<td>
<p>One of the tables involved in the join.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_table_2">table_2</code></td>
<td>
<p>The second table of the join.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_join">join</code></td>
<td>
<p>The type of join to be performed, see <code><a href="dplyr.html#topic+mutate-joins">dplyr::join()</a></code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_check">check</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, a check is made if the combination of columns is a unique key of the table.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_columns">columns</code></td>
<td>
<p>Table columns, unquoted.
To define a compound key, use <code>c(col1, col2)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='dm'>Data model class</h2><span id='topic+dm'></span><span id='topic+new_dm'></span><span id='topic+is_dm'></span><span id='topic+as_dm'></span>

<h3>Description</h3>

<p>The <code>dm</code> class holds a list of tables and their relationships.
It is inspired by <a href="https://github.com/bergant/datamodelr">datamodelr</a>,
and extends the idea by offering operations to access the data in the tables.
</p>
<p><code>dm()</code> creates a <code>dm</code> object from <a href="#topic+tbl">tbl</a> objects
(tibbles or lazy data objects).
</p>
<p><code>new_dm()</code> is a low-level constructor that creates a new <code>dm</code> object.
</p>

<ul>
<li><p> If called without arguments, it will create an empty <code>dm</code>.
</p>
</li>
<li><p> If called with arguments, no validation checks will be made to ascertain that
the inputs are of the expected class and internally consistent;
use <code><a href="#topic+dm_validate">dm_validate()</a></code> to double-check the returned object.
</p>
</li></ul>

<p><code>is_dm()</code> returns <code>TRUE</code> if the input is of class <code>dm</code>.
</p>
<p><code>as_dm()</code> coerces objects to the <code>dm</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm(
  ...,
  .name_repair = c("check_unique", "unique", "universal", "minimal"),
  .quiet = FALSE
)

new_dm(tables = list())

is_dm(x)

as_dm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_+3A_...">...</code></td>
<td>
<p>Tables or existing <code>dm</code> objects to add to the <code>dm</code> object.
Unnamed tables are auto-named, <code>dm</code> objects must not be named.</p>
</td></tr>
<tr><td><code id="dm_+3A_.name_repair">.name_repair</code>, <code id="dm_+3A_.quiet">.quiet</code></td>
<td>
<p>Options for name repair.
Forwarded as <code>repair</code> and <code>quiet</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.</p>
</td></tr>
<tr><td><code id="dm_+3A_tables">tables</code></td>
<td>
<p>A named list of the tables (tibble-objects, not names),
to be included in the <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>dm()</code>, <code>new_dm()</code>, <code>as_dm()</code>: A <code>dm</code> object.
</p>
<p>For <code>is_dm()</code>: A scalar logical, <code>TRUE</code> if is this object is a <code>dm</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+dm_from_con">dm_from_con()</a></code> for connecting to all tables in a database
and importing the primary and foreign keys
</p>
</li>
<li> <p><code><a href="#topic+dm_get_tables">dm_get_tables()</a></code> for returning a list of tables
</p>
</li>
<li> <p><code><a href="#topic+dm_add_pk">dm_add_pk()</a></code> and <code><a href="#topic+dm_add_fk">dm_add_fk()</a></code> for adding primary and foreign keys
</p>
</li>
<li> <p><code><a href="#topic+copy_dm_to">copy_dm_to()</a></code> for DB interaction
</p>
</li>
<li> <p><code><a href="#topic+dm_draw">dm_draw()</a></code> for visualization
</p>
</li>
<li> <p><code><a href="#topic+dm_flatten_to_tbl">dm_flatten_to_tbl()</a></code> for flattening
</p>
</li>
<li> <p><code><a href="#topic+dm_filter">dm_filter()</a></code> for filtering
</p>
</li>
<li> <p><code><a href="#topic+dm_select_tbl">dm_select_tbl()</a></code> for creating a <code>dm</code> with only a subset of the tables
</p>
</li>
<li> <p><code><a href="#topic+dm_nycflights13">dm_nycflights13()</a></code>  for creating an example <code>dm</code> object
</p>
</li>
<li> <p><code><a href="#topic+decompose_table">decompose_table()</a></code> for table surgery
</p>
</li>
<li> <p><code><a href="#topic+check_key">check_key()</a></code> and <code><a href="#topic+check_subset">check_subset()</a></code> for checking for key properties
</p>
</li>
<li> <p><code><a href="#topic+examine_cardinality">examine_cardinality()</a></code> for checking the cardinality of the relation between two tables
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dm(trees, mtcars)

new_dm(list(trees = trees, mtcars = mtcars))

as_dm(list(trees = trees, mtcars = mtcars))


is_dm(dm_nycflights13())

dm_nycflights13()$airports

dm_nycflights13()["airports"]

dm_nycflights13()[["airports"]]

dm_nycflights13() %&gt;% names()


library(dm)
library(nycflights13)

# using `data.frame` objects
new_dm(tibble::lst(weather, airports))

# using `dm_keyed_tbl` objects
dm &lt;- dm_nycflights13()
y1 &lt;- dm$planes %&gt;%
  mutate() %&gt;%
  select(everything())
y2 &lt;- dm$flights %&gt;%
  left_join(dm$airlines, by = "carrier")

new_dm(list("tbl1" = y1, "tbl2" = y2))

</code></pre>

<hr>
<h2 id='dm_add_fk'>Add foreign keys</h2><span id='topic+dm_add_fk'></span>

<h3>Description</h3>

<p><code>dm_add_fk()</code> marks the specified <code>columns</code> as the foreign key of table <code>table</code> with
respect to a key of table <code>ref_table</code>.
Usually the referenced columns are a primary key in <code>ref_table</code>.
However, it is also possible to specify other columns via the <code>ref_columns</code> argument.
If <code>check == TRUE</code>, then it will first check if the values in <code>columns</code> are a subset
of the values of the key in table <code>ref_table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_add_fk(
  dm,
  table,
  columns,
  ref_table,
  ref_columns = NULL,
  ...,
  check = FALSE,
  on_delete = c("no_action", "cascade")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_add_fk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_columns">columns</code></td>
<td>
<p>The columns of <code>table</code> which are to become the foreign key columns that
reference <code>ref_table</code>.
To define a compound key, use <code>c(col1, col2)</code>.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_ref_table">ref_table</code></td>
<td>
<p>The table which <code>table</code> will be referencing.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_ref_columns">ref_columns</code></td>
<td>
<p>The column(s) of <code>table</code> which are to become the referenced column(s) in <code>ref_table</code>.
By default, the primary key is used.
To define a compound key, use <code>c(col1, col2)</code>.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_check">check</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, a check will be performed to determine if the values of
<code>columns</code> are a subset of the values of the key column(s) of <code>ref_table</code>.</p>
</td></tr>
<tr><td><code id="dm_add_fk_+3A_on_delete">on_delete</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Defines behavior if a row in the parent table is deleted.
- <code>"no_action"</code>, the default, means that no action is taken
and the operation is aborted if child rows exist
- <code>"cascade"</code> means that the child row is also deleted
This setting is picked up by <code><a href="#topic+copy_dm_to">copy_dm_to()</a></code> with <code>set_key_constraints = TRUE</code>,
and by <code><a href="#topic+dm_sql">dm_sql()</a></code>,
and might be considered by <code><a href="#topic+dm_rows_delete">dm_rows_delete()</a></code> in a future version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible that a foreign key (FK) is pointing to columns that are neither primary (PK) nor
explicit unique keys (UK).
This can happen
</p>

<ol>
<li><p> when a FK is added without a corresponding PK or UK being present in the parent table
</p>
</li>
<li><p> when the PK or UK is removed (<code><a href="#topic+dm_rm_pk">dm_rm_pk()</a></code>/<code><a href="#topic+dm_rm_uk">dm_rm_uk()</a></code>) without first removing the associated FKs.
</p>
</li></ol>

<p>These columns are then a so-called &quot;implicit unique key&quot; of the referenced table and can be listed via <code><a href="#topic+dm_get_all_uks">dm_get_all_uks()</a></code>.
</p>


<h3>Value</h3>

<p>An updated <code>dm</code> with an additional foreign key relation.
</p>


<h3>See Also</h3>

<p>Other foreign key functions: 
<code><a href="#topic+dm_enum_fk_candidates">dm_enum_fk_candidates</a>()</code>,
<code><a href="#topic+dm_get_all_fks">dm_get_all_fks</a>()</code>,
<code><a href="#topic+dm_rm_fk">dm_rm_fk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nycflights_dm &lt;- dm(
  planes = nycflights13::planes,
  flights = nycflights13::flights,
  weather = nycflights13::weather
)

nycflights_dm %&gt;%
  dm_draw()

# Create foreign keys:
nycflights_dm %&gt;%
  dm_add_pk(planes, tailnum) %&gt;%
  dm_add_fk(flights, tailnum, planes) %&gt;%
  dm_add_pk(weather, c(origin, time_hour)) %&gt;%
  dm_add_fk(flights, c(origin, time_hour), weather) %&gt;%
  dm_draw()

# Keys can be checked during creation:
try(
  nycflights_dm %&gt;%
    dm_add_pk(planes, tailnum) %&gt;%
    dm_add_fk(flights, tailnum, planes, check = TRUE)
)

</code></pre>

<hr>
<h2 id='dm_add_pk'>Add a primary key</h2><span id='topic+dm_add_pk'></span>

<h3>Description</h3>

<p><code>dm_add_pk()</code> marks the specified columns as the primary key of the specified table.
If <code>check == TRUE</code>, then it will first check if
the given combination of columns is a unique key of the table.
If <code>force == TRUE</code>, the function will replace an already
set key, without altering foreign keys previously pointing to that primary key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_add_pk(
  dm,
  table,
  columns,
  ...,
  autoincrement = FALSE,
  check = FALSE,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_add_pk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_add_pk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_add_pk_+3A_columns">columns</code></td>
<td>
<p>Table columns, unquoted.
To define a compound key, use <code>c(col1, col2)</code>.</p>
</td></tr>
<tr><td><code id="dm_add_pk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_add_pk_+3A_autoincrement">autoincrement</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If <code>TRUE</code>, the  column specified in <code>columns</code> will be populated
automatically with a sequence of integers.</p>
</td></tr>
<tr><td><code id="dm_add_pk_+3A_check">check</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, a check is made if the combination of columns is a unique key of the table.</p>
</td></tr>
<tr><td><code id="dm_add_pk_+3A_force">force</code></td>
<td>
<p>Boolean, if <code>FALSE</code> (default), an error will be thrown if there is already a primary key
set for this table.
If <code>TRUE</code>, a potential old <code>pk</code> is deleted before setting a new one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There can be only one primary key per table in a <code><a href="#topic+dm">dm</a></code>.
It's possible though to set an unlimited number of unique keys using <code><a href="#topic+dm_add_uk">dm_add_uk()</a></code>
or adding foreign keys pointing to columns other than the primary key columns with <code><a href="#topic+dm_add_fk">dm_add_fk()</a></code>.
</p>


<h3>Value</h3>

<p>An updated <code>dm</code> with an additional primary key.
</p>


<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nycflights_dm &lt;- dm(
  planes = nycflights13::planes,
  airports = nycflights13::airports,
  weather = nycflights13::weather
)

nycflights_dm %&gt;%
  dm_draw()

# Create primary keys:
nycflights_dm %&gt;%
  dm_add_pk(planes, tailnum) %&gt;%
  dm_add_pk(airports, faa, check = TRUE) %&gt;%
  dm_add_pk(weather, c(origin, time_hour)) %&gt;%
  dm_draw()

# Keys can be checked during creation:
try(
  nycflights_dm %&gt;%
    dm_add_pk(planes, manufacturer, check = TRUE)
)

</code></pre>

<hr>
<h2 id='dm_add_uk'>Add a unique key</h2><span id='topic+dm_add_uk'></span>

<h3>Description</h3>

<p><code>dm_add_uk()</code> marks the specified columns as a unique key of the specified table.
If <code>check == TRUE</code>, then it will first check if
the given combination of columns is a unique key of the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_add_uk(dm, table, columns, ..., check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_add_uk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_add_uk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_add_uk_+3A_columns">columns</code></td>
<td>
<p>Table columns, unquoted.
To define a compound key, use <code>c(col1, col2)</code>.</p>
</td></tr>
<tr><td><code id="dm_add_uk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_add_uk_+3A_check">check</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, a check is made if the combination of columns is a unique key of the table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between a primary key (PK) and a unique key (UK) consists in the following:
</p>

<ul>
<li><p> When a local <code>dm</code> is copied to a database (DB) with <code>copy_dm_to()</code>, a PK will be set on the DB by default, whereas a UK is being ignored.
</p>
</li>
<li><p> A PK can be set as an <code>autoincrement</code> key (also implemented on certain DBMS when the <code>dm</code> is transferred to the DB)
</p>
</li>
<li><p> There can be only one PK for each table, whereas there can be unlimited UKs
</p>
</li>
<li><p> A UK will be used, if the same table has an autoincrement PK in addition, to ensure that during delta load processes
on the DB (cf. <code><a href="#topic+dm_rows_append">dm_rows_append()</a></code>) the foreign keys are updated accordingly.
If no UK is available, the insertion is done row-wise, which also ensures a correct matching, but can be much slower.
</p>
</li>
<li><p> A UK can generally enhance the data model by adding additional information
</p>
</li>
<li><p> There can also be implicit UKs, when the columns addressed by a foreign key are neither a PK nor a UK.
These implicit UKs are also listed by <code><a href="#topic+dm_get_all_uks">dm_get_all_uks()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>An updated <code>dm</code> with an additional unqiue key.
</p>


<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

nycflights_dm &lt;- dm(
  planes = nycflights13::planes,
  airports = nycflights13::airports,
  weather = nycflights13::weather
)

# Create unique keys:
nycflights_dm %&gt;%
  dm_add_uk(planes, tailnum) %&gt;%
  dm_add_uk(airports, faa, check = TRUE) %&gt;%
  dm_add_uk(weather, c(origin, time_hour)) %&gt;%
  dm_get_all_uks()

# Keys can be checked during creation:
try(
  nycflights_dm %&gt;%
    dm_add_uk(planes, manufacturer, check = TRUE)
)

</code></pre>

<hr>
<h2 id='dm_deconstruct'>Create code to deconstruct a dm object</h2><span id='topic+dm_deconstruct'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Emits code that assigns each table in the dm to a variable,
using <code><a href="#topic+pull_tbl">pull_tbl()</a></code> with <code>keyed = TRUE</code>.
These tables retain information about primary and foreign keys,
even after data transformations,
and can be converted back to a dm object with <code><a href="#topic+dm">dm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_deconstruct(dm, dm_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_deconstruct_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_deconstruct_+3A_dm_name">dm_name</code></td>
<td>
<p>The code to use to access the dm object,
by default the expression passed to this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effect of printing
generated code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm &lt;- dm_nycflights13()
dm_deconstruct(dm)
airlines &lt;- pull_tbl(dm, "airlines", keyed = TRUE)
airports &lt;- pull_tbl(dm, "airports", keyed = TRUE)
flights &lt;- pull_tbl(dm, "flights", keyed = TRUE)
planes &lt;- pull_tbl(dm, "planes", keyed = TRUE)
weather &lt;- pull_tbl(dm, "weather", keyed = TRUE)
by_origin &lt;-
  flights %&gt;%
  group_by(origin) %&gt;%
  summarize(mean_arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;%
  ungroup()

by_origin
dm(airlines, airports, flights, planes, weather, by_origin) %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_disambiguate_cols'>Resolve column name ambiguities</h2><span id='topic+dm_disambiguate_cols'></span>

<h3>Description</h3>

<p>This function ensures that all columns in a <code>dm</code> have unique names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_disambiguate_cols(
  dm,
  .sep = ".",
  ...,
  .quiet = FALSE,
  .position = c("suffix", "prefix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_disambiguate_cols_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_disambiguate_cols_+3A_.sep">.sep</code></td>
<td>
<p>The character variable that separates the names of the table and the names of the ambiguous columns.</p>
</td></tr>
<tr><td><code id="dm_disambiguate_cols_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_disambiguate_cols_+3A_.quiet">.quiet</code></td>
<td>
<p>Boolean.
By default, this function lists the renamed columns in a message, pass <code>TRUE</code> to suppress this message.</p>
</td></tr>
<tr><td><code id="dm_disambiguate_cols_+3A_.position">.position</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
By default, table names are appended to the column names to resolve conflicts.
Prepending table names was the default for versions before 1.0.0,
use <code>"prefix"</code> to achieve this behavior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks if there are any column names that are not unique.
If there are, those columns will be assigned new, unique, names by prefixing their existing name
with the name of their table and a separator.
Columns that act as primary or foreign keys will not be renamed
because only the foreign key column will remain when two tables are joined,
making that column name &quot;unique&quot; as well.
</p>


<h3>Value</h3>

<p>A <code>dm</code> whose column names are unambiguous.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_disambiguate_cols()

</code></pre>

<hr>
<h2 id='dm_draw'>Draw a diagram of the data model</h2><span id='topic+dm_draw'></span>

<h3>Description</h3>

<p><code>dm_draw()</code> draws a diagram, a visual representation of the data model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_draw(
  dm,
  rankdir = "LR",
  ...,
  col_attr = NULL,
  view_type = c("keys_only", "all", "title_only"),
  columnArrows = TRUE,
  graph_attrs = "",
  node_attrs = "",
  edge_attrs = "",
  focus = NULL,
  graph_name = "Data Model",
  column_types = NULL,
  backend = "DiagrammeR",
  font_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_draw_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_rankdir">rankdir</code></td>
<td>
<p>Graph attribute for direction (e.g., 'BT' = bottom &ndash;&gt; top).</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_col_attr">col_attr</code></td>
<td>
<p>Deprecated, use <code>colummn_types</code> instead.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_view_type">view_type</code></td>
<td>
<p>Can be &quot;keys_only&quot; (default), &quot;all&quot; or &quot;title_only&quot;.
It defines the level of details for rendering tables
(only primary and foreign keys, all columns, or no columns).</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_columnarrows">columnArrows</code></td>
<td>
<p>Edges from columns to columns (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_graph_attrs">graph_attrs</code></td>
<td>
<p>Additional graph attributes.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_node_attrs">node_attrs</code></td>
<td>
<p>Additional node attributes.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_edge_attrs">edge_attrs</code></td>
<td>
<p>Additional edge attributes.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_focus">focus</code></td>
<td>
<p>A list of parameters for rendering (table filter).</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_graph_name">graph_name</code></td>
<td>
<p>The name of the graph.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_column_types">column_types</code></td>
<td>
<p>Set to <code>TRUE</code> to show column types.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_backend">backend</code></td>
<td>
<p>Currently, only the default <code>"DiagrammeR"</code> is accepted.
Pass this value explicitly if your code not only uses this function
to display a data model but relies on the type of the return value.</p>
</td></tr>
<tr><td><code id="dm_draw_+3A_font_size">font_size</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Font size for:
</p>

<ul>
<li> <p><code>header</code>, defaults to <code>16</code>
</p>
</li>
<li> <p><code>column</code>, defaults to <code>16</code>
</p>
</li>
<li> <p><code>table_description</code>, defaults to <code>8</code>
</p>
</li></ul>

<p>Can be set as a named integer vector, e.g. <code>c(table_headers = 18L, table_description = 6L)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <span class="pkg">dm</span> uses <span class="pkg">DiagrammeR</span> to draw diagrams.
Use <code><a href="DiagrammeRsvg.html#topic+export_svg">DiagrammeRsvg::export_svg()</a></code> to convert the diagram to an SVG file.
</p>
<p>The backend for drawing the diagrams might change in the future.
If you rely on DiagrammeR, pass an explicit value for the <code>backend</code> argument.
</p>


<h3>Value</h3>

<p>An object with a <code><a href="base.html#topic+print">print()</a></code> method, which,
when printed, produces the output seen in the viewer as a side effect.
Currently, this is an object of class <code>grViz</code> (see also
<code><a href="DiagrammeR.html#topic+grViz">DiagrammeR::grViz()</a></code>), but this is subject to change.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm_set_colors">dm_set_colors()</a></code> for defining the table colors.
</p>
<p><code><a href="#topic+dm_set_table_description">dm_set_table_description()</a></code> for adding details to one or more tables in the diagram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_draw()

dm_nycflights13(cycle = TRUE) %&gt;%
  dm_draw(view_type = "title_only")

head(dm_get_available_colors())
length(dm_get_available_colors())

dm_nycflights13() %&gt;%
  dm_get_colors()

</code></pre>

<hr>
<h2 id='dm_enum_fk_candidates'>Foreign key candidates</h2><span id='topic+dm_enum_fk_candidates'></span><span id='topic+enum_fk_candidates'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Determine which columns would be good candidates to be used as foreign keys of a table,
to reference the primary key column of another table of the <code><a href="#topic+dm">dm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_enum_fk_candidates(dm, table, ref_table, ...)

enum_fk_candidates(dm_zoomed, ref_table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_enum_fk_candidates_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_enum_fk_candidates_+3A_table">table</code></td>
<td>
<p>The table whose columns should be tested for suitability as foreign keys.</p>
</td></tr>
<tr><td><code id="dm_enum_fk_candidates_+3A_ref_table">ref_table</code></td>
<td>
<p>A table with a primary key.</p>
</td></tr>
<tr><td><code id="dm_enum_fk_candidates_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_enum_fk_candidates_+3A_dm_zoomed">dm_zoomed</code></td>
<td>
<p>A <code>dm</code> with a zoomed table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dm_enum_fk_candidates()</code> first checks if <code>ref_table</code> has a primary key set,
if not, an error is thrown.
</p>
<p>If <code>ref_table</code> does have a primary key, then a join operation will be tried using
that key as the <code>by</code> argument of join() to match it to each column of <code>table</code>.
Attempting to join incompatible columns triggers an error.
</p>
<p>The outcome of the join operation determines the value of the <code>why</code> column in the result:
</p>

<ul>
<li><p> an empty value for a column of <code>table</code> that is a suitable foreign key candidate
</p>
</li>
<li><p> the count and percentage of missing matches for a column that is not suitable
</p>
</li>
<li><p> the error message triggered for unsuitable candidates that may include the types of mismatched columns
</p>
</li></ul>

<p><code>enum_fk_candidates()</code> works like <code>dm_enum_fk_candidates()</code> with the zoomed table as <code>table</code>.
</p>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>columns</code></dt><dd><p>columns of <code>table</code>,</p>
</dd>
<dt><code>candidate</code></dt><dd><p>boolean: are these columns a candidate for a foreign key,</p>
</dd>
<dt><code>why</code></dt><dd><p>if not a candidate for a foreign key, explanation for for this.</p>
</dd>
</dl>



<h3>Life cycle</h3>

<p>These functions are marked &quot;experimental&quot; because we are not yet sure about
the interface, in particular if we need both <code>dm_enum...()</code> and <code>enum...()</code>
variants.
Changing the interface later seems harmless because these functions are
most likely used interactively.
</p>


<h3>See Also</h3>

<p>Other foreign key functions: 
<code><a href="#topic+dm_add_fk">dm_add_fk</a>()</code>,
<code><a href="#topic+dm_get_all_fks">dm_get_all_fks</a>()</code>,
<code><a href="#topic+dm_rm_fk">dm_rm_fk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_enum_fk_candidates(flights, airports)

dm_nycflights13() %&gt;%
  dm_zoom_to(flights) %&gt;%
  enum_fk_candidates(airports)

</code></pre>

<hr>
<h2 id='dm_examine_cardinalities'>Learn about your data model</h2><span id='topic+dm_examine_cardinalities'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function returns a tibble with information about
the cardinality of the FK constraints.
The printing for this object is special, use <code><a href="dplyr.html#topic+as_tibble">as_tibble()</a></code>
to print as a regular tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_examine_cardinalities(
  .dm,
  ...,
  .progress = NA,
  dm = deprecated(),
  progress = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_examine_cardinalities_+3A_.dm">.dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_examine_cardinalities_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_examine_cardinalities_+3A_.progress">.progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
<tr><td><code id="dm_examine_cardinalities_+3A_dm">dm</code>, <code id="dm_examine_cardinalities_+3A_progress">progress</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+examine_cardinality">examine_cardinality()</a></code> on each foreign key that is defined in the <code><a href="#topic+dm">dm</a></code>.
</p>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>child_table</code></dt><dd><p>child table,</p>
</dd>
<dt><code>child_fk_cols</code></dt><dd><p>foreign key column(s) in child table as list of character vectors,</p>
</dd>
<dt><code>parent_table</code></dt><dd><p>parent table,</p>
</dd>
<dt><code>parent_key_cols</code></dt><dd><p>key column(s) in parent table as list of character vectors,</p>
</dd>
<dt><code>cardinality</code></dt><dd><p>the nature of cardinality along the foreign key.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other cardinality functions: 
<code><a href="#topic+examine_cardinality">examine_cardinality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_examine_cardinalities()

</code></pre>

<hr>
<h2 id='dm_examine_constraints'>Validate your data model</h2><span id='topic+dm_examine_constraints'></span>

<h3>Description</h3>

<p>This function returns a tibble with information about
which key constraints are met (<code>is_key = TRUE</code>) or violated (<code>FALSE</code>).
The printing for this object is special, use <code><a href="dplyr.html#topic+as_tibble">as_tibble()</a></code>
to print as a regular tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_examine_constraints(
  .dm,
  ...,
  .progress = NA,
  dm = deprecated(),
  progress = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_examine_constraints_+3A_.dm">.dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_examine_constraints_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_examine_constraints_+3A_.progress">.progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
<tr><td><code id="dm_examine_constraints_+3A_dm">dm</code>, <code id="dm_examine_constraints_+3A_progress">progress</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the primary key constraints, it is tested if the values in the respective columns are all unique.
For the foreign key constraints, the tests check if for each foreign key constraint, the values of the foreign key column
form a subset of the values of the referenced column.
</p>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>table</code></dt><dd><p>the table in the <code>dm</code>,</p>
</dd>
<dt><code>kind</code></dt><dd><p>&quot;PK&quot; or &quot;FK&quot;,</p>
</dd>
<dt><code>columns</code></dt><dd><p>the table columns that define the key,</p>
</dd>
<dt><code>ref_table</code></dt><dd><p>for foreign keys, the referenced table,</p>
</dd>
<dt><code>is_key</code></dt><dd><p>logical,</p>
</dd>
<dt><code>problem</code></dt><dd><p>if <code>is_key = FALSE</code>, the reason for that.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_examine_constraints()

</code></pre>

<hr>
<h2 id='dm_filter'>Filtering</h2><span id='topic+dm_filter'></span>

<h3>Description</h3>

<p>Filtering a table of a <code><a href="#topic+dm">dm</a></code> object may affect other tables that are connected to it
directly or indirectly via foreign key relations.
</p>
<p><code>dm_filter()</code> can be used to define filter conditions for tables using syntax that is similar to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
The filters work across related tables:
The resulting <code>dm</code> object only contains rows that are related
(directly or indirectly) to rows that remain after applying the filters
on all tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_filter(.dm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_filter_+3A_.dm">.dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_filter_+3A_...">...</code></td>
<td>
<p>Named logical predicates.
The names correspond to tables in the <code>dm</code> object.
The predicates are defined in terms of the variables in the corresponding table,
they are passed on to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>
<p>Multiple conditions are combined with <code>&amp;</code>.
Only the rows where the condition evaluates
to <code>TRUE</code> are kept.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of dm 1.0.0, these conditions are no longer stored in the <code>dm</code> object,
instead they are applied to all tables during the call to <code>dm_filter()</code>.
Calling <code>dm_apply_filters()</code> or <code>dm_apply_filters_to_tbl()</code> is no longer necessary.
</p>
<p>Use <code><a href="#topic+dm_zoom_to">dm_zoom_to()</a></code> and <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> to filter rows without affecting related tables.
</p>


<h3>Value</h3>

<p>An updated <code>dm</code> object with filters executed across all tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nyc &lt;- dm_nycflights13()
dm_nyc %&gt;%
  dm_nrow()

dm_nyc_filtered &lt;-
  dm_nycflights13() %&gt;%
  dm_filter(airports = (name == "John F Kennedy Intl"))

dm_nyc_filtered %&gt;%
  dm_nrow()

# If you want to keep only those rows in the parent tables
# whose primary key values appear as foreign key values in
# `flights`, you can set a `TRUE` filter in `flights`:
dm_nyc %&gt;%
  dm_filter(flights = (1 == 1)) %&gt;%
  dm_nrow()
# note that in this example, the only affected table is
# `airports` because the departure airports in `flights` are
# only the three New York airports.

</code></pre>

<hr>
<h2 id='dm_financial'>Creates a dm object for the Financial data</h2><span id='topic+dm_financial'></span><span id='topic+dm_financial_sqlite'></span>

<h3>Description</h3>

<p><code>dm_financial()</code> creates an example <code><a href="#topic+dm">dm</a></code> object from the tables at
https://relational.fit.cvut.cz/dataset/Financial.
The connection is established once per session,
subsequent calls return the same connection.
</p>
<p><code>dm_financial_sqlite()</code> copies the data to a temporary SQLite database.
The data is downloaded once per session, subsequent calls return the same database.
The <code>trans</code> table is excluded due to its size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_financial()

dm_financial_sqlite()
</code></pre>


<h3>Value</h3>

<p>A <code>dm</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_financial() %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_flatten_to_tbl'>Flatten a part of a <code>dm</code> into a wide table</h2><span id='topic+dm_flatten_to_tbl'></span>

<h3>Description</h3>

<p><code>dm_flatten_to_tbl()</code> gathers all information of interest in one place in a wide table.
It performs a disambiguation of column names and a cascade of joins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_flatten_to_tbl(dm, .start, ..., .recursive = FALSE, .join = left_join)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_flatten_to_tbl_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="dm_flatten_to_tbl_+3A_.start">.start</code></td>
<td>
<p>The table from which all outgoing foreign key relations are considered
when establishing a processing order for the joins.
An interesting choice could be
for example a fact table in a star schema.</p>
</td></tr>
<tr><td><code id="dm_flatten_to_tbl_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Unquoted names of the tables to be included in addition to the <code>.start</code> table.
The order of the tables here determines the order of the joins.
If the argument is empty, all tables that can be reached will be included.
<code>tidyselect</code> is supported, see <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> for details on the semantics.</p>
</td></tr>
<tr><td><code id="dm_flatten_to_tbl_+3A_.recursive">.recursive</code></td>
<td>
<p>Logical, defaults to <code>FALSE</code>. Should not only parent tables be joined to <code>.start</code>, but also their ancestors?</p>
</td></tr>
<tr><td><code id="dm_flatten_to_tbl_+3A_.join">.join</code></td>
<td>
<p>The type of join to be performed, see <code><a href="dplyr.html#topic+mutate-joins">dplyr::join()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>...</code> left empty, this function will join together all the tables of your <code><a href="#topic+dm">dm</a></code>
object that can be reached from the <code>.start</code> table, in the direction of the foreign key relations
(pointing from the child tables to the parent tables), using the foreign key relations to
determine the argument <code>by</code> for the necessary joins.
The result is one table with unique column names.
Use the <code>...</code> argument if you would like to control which tables should be joined to the <code>.start</code> table.
</p>
<p>Mind that calling <code>dm_flatten_to_tbl()</code> with <code>.join = right_join</code> and no table order determined in the <code>...</code> argument
will not lead to a well-defined result if two or more foreign tables are to be joined to <code>.start</code>.
The resulting
table would depend on the order the tables that are listed in the <code>dm</code>.
Therefore, trying this will result in a warning.
</p>
<p>Since <code>.join = nest_join</code> does not make sense in this direction (LHS = child table, RHS = parent table: for valid key constraints
each nested column entry would be a tibble of one row), an error will be thrown if this method is chosen.
</p>
<p>The difference between <code>.recursive = FALSE</code> and <code>.recursive = TRUE</code> is
the following (see the examples):
</p>

<ul>
<li> <p><code>.recursive = FALSE</code> allows only one level of hierarchy
(i.e., direct neighbors to table <code>.start</code>), while
</p>
</li>
<li> <p><code>.recursive = TRUE</code> will go through all levels of hierarchy while joining.
</p>
</li></ul>

<p>Additionally, these functions differ from <code>dm_wrap_tbl()</code>, which always
returns a <code>dm</code> object.
</p>


<h3>Value</h3>

<p>A single table that results from consecutively joining all affected tables to the <code>.start</code> table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dm_financial() %&gt;%
  dm_select_tbl(-loans) %&gt;%
  dm_flatten_to_tbl(.start = cards)

dm_financial() %&gt;%
  dm_select_tbl(-loans) %&gt;%
  dm_flatten_to_tbl(.start = cards, .recursive = TRUE)

</code></pre>

<hr>
<h2 id='dm_from_con'>Load a dm from a remote data source</h2><span id='topic+dm_from_con'></span>

<h3>Description</h3>

<p><code>dm_from_con()</code> creates a <a href="#topic+dm">dm</a> from some or all tables in a <a href="dplyr.html#topic+src">src</a>
(a database or an environment) or which are accessible via a DBI-Connection.
For Postgres and SQL Server databases, primary and foreign keys
are imported from the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_from_con(
  con = NULL,
  table_names = NULL,
  learn_keys = NULL,
  .names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_from_con_+3A_con">con</code></td>
<td>
<p>A <code><a href="DBI.html#topic+DBIConnection-class">DBI::DBIConnection</a></code> or a <code>Pool</code> object.</p>
</td></tr>
<tr><td><code id="dm_from_con_+3A_table_names">table_names</code></td>
<td>
<p>A character vector of the names of the tables to include.</p>
</td></tr>
<tr><td><code id="dm_from_con_+3A_learn_keys">learn_keys</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Set to <code>TRUE</code> to query the definition of primary and
foreign keys from the database.
Currently works only for Postgres and SQL Server databases.
The default attempts to query and issues an informative message.</p>
</td></tr>
<tr><td><code id="dm_from_con_+3A_.names">.names</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>A glue specification that describes how to name the tables
within the output, currently only for MSSQL, Postgres and MySQL/MariaDB.
This can use <code>{.table}</code> to stand for the table name, and
<code>{.schema}</code> to stand for the name of the schema which the table lives
within. The default (<code>NULL</code>) is equivalent to <code>"{.table}"</code> when a single
schema is specified in <code>schema</code>, and <code>"{.schema}.{.table}"</code> for the case
where multiple schemas are given, and may change in future versions.</p>
</td></tr>
<tr><td><code id="dm_from_con_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Additional parameters for the schema learning query.
</p>

<ul>
<li> <p><code>schema</code>: supported for MSSQL (default: <code>"dbo"</code>), Postgres (default: <code>"public"</code>), and MariaDB/MySQL
(default: current database). Learn the tables in a specific schema (or database for MariaDB/MySQL).
</p>
</li>
<li> <p><code>dbname</code>: supported for MSSQL. Access different databases on the connected MSSQL-server;
default: active database.
</p>
</li>
<li> <p><code>table_type</code>: supported for Postgres (default: <code>"BASE TABLE"</code>). Specify the table type. Options are:
</p>

<ol>
<li> <p><code>"BASE TABLE"</code> for a persistent table (normal table type)
</p>
</li>
<li> <p><code>"VIEW"</code> for a view
</p>
</li>
<li> <p><code>"FOREIGN TABLE"</code> for a foreign table
</p>
</li>
<li> <p><code>"LOCAL TEMPORARY"</code> for a temporary table
</p>
</li></ol>

</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dm</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- dm_get_con(dm_financial())

# Avoid DBI::dbDisconnect() here, because we don't own the connection

</code></pre>

<hr>
<h2 id='dm_from_src'>Load a dm from a remote data source</h2><span id='topic+dm_from_src'></span>

<h3>Description</h3>

<p>Deprecated  in dm 0.3.0 in favor of <code><a href="#topic+dm_from_con">dm_from_con()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_from_src(src = NULL, table_names = NULL, learn_keys = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_from_src_+3A_src">src</code></td>
<td>
<p>A dbplyr source, DBI connection object or a Pool object.</p>
</td></tr>
<tr><td><code id="dm_from_src_+3A_table_names">table_names</code></td>
<td>
<p>A character vector of the names of the tables to include.</p>
</td></tr>
<tr><td><code id="dm_from_src_+3A_learn_keys">learn_keys</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Set to <code>TRUE</code> to query the definition of primary and
foreign keys from the database.
Currently works only for Postgres and SQL Server databases.
The default attempts to query and issues an informative message.</p>
</td></tr>
<tr><td><code id="dm_from_src_+3A_...">...</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Additional parameters for the schema learning query.
</p>

<ul>
<li> <p><code>schema</code>: supported for MSSQL (default: <code>"dbo"</code>), Postgres (default: <code>"public"</code>), and MariaDB/MySQL
(default: current database). Learn the tables in a specific schema (or database for MariaDB/MySQL).
</p>
</li>
<li> <p><code>dbname</code>: supported for MSSQL. Access different databases on the connected MSSQL-server;
default: active database.
</p>
</li>
<li> <p><code>table_type</code>: supported for Postgres (default: <code>"BASE TABLE"</code>). Specify the table type. Options are:
</p>

<ol>
<li> <p><code>"BASE TABLE"</code> for a persistent table (normal table type)
</p>
</li>
<li> <p><code>"VIEW"</code> for a view
</p>
</li>
<li> <p><code>"FOREIGN TABLE"</code> for a foreign table
</p>
</li>
<li> <p><code>"LOCAL TEMPORARY"</code> for a temporary table
</p>
</li></ol>

</li></ul>
</td></tr>
</table>

<hr>
<h2 id='dm_get_all_fks'>Get foreign key constraints</h2><span id='topic+dm_get_all_fks'></span>

<h3>Description</h3>

<p>Get a summary of all foreign key relations in a <code><a href="#topic+dm">dm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_all_fks(dm, parent_table = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_get_all_fks_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_get_all_fks_+3A_parent_table">parent_table</code></td>
<td>
<p>One or more table names, unquoted,
to return foreign key information for.
If given, foreign keys are returned in that order.
The default <code>NULL</code> returns information for all tables.</p>
</td></tr>
<tr><td><code id="dm_get_all_fks_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>child_table</code></dt><dd><p>child table,</p>
</dd>
<dt><code>child_fk_cols</code></dt><dd><p>foreign key column(s) in child table as list of character vectors,</p>
</dd>
<dt><code>parent_table</code></dt><dd><p>parent table,</p>
</dd>
<dt><code>parent_key_cols</code></dt><dd><p>key column(s) in parent table as list of character vectors.</p>
</dd>
<dt><code>on_delete</code></dt><dd><p>behavior on deletion of rows in the parent table.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other foreign key functions: 
<code><a href="#topic+dm_add_fk">dm_add_fk</a>()</code>,
<code><a href="#topic+dm_enum_fk_candidates">dm_enum_fk_candidates</a>()</code>,
<code><a href="#topic+dm_rm_fk">dm_rm_fk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_get_all_fks()

</code></pre>

<hr>
<h2 id='dm_get_all_pks'>Get all primary keys of a <code><a href="#topic+dm">dm</a></code> object</h2><span id='topic+dm_get_all_pks'></span>

<h3>Description</h3>

<p><code>dm_get_all_pks()</code> checks the <code>dm</code> object for primary keys and
returns the tables and the respective primary key columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_all_pks(dm, table = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_get_all_pks_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_get_all_pks_+3A_table">table</code></td>
<td>
<p>One or more table names, unquoted,
to return primary key information for.
If given, primary keys are returned in that order.
The default <code>NULL</code> returns information for all tables.</p>
</td></tr>
<tr><td><code id="dm_get_all_pks_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>table</code></dt><dd><p>table name,</p>
</dd>
<dt><code>pk_col</code></dt><dd><p>column name(s) of primary key, as list of character vectors.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_get_all_pks()

</code></pre>

<hr>
<h2 id='dm_get_all_uks'>Get all unique keys of a <code><a href="#topic+dm">dm</a></code> object</h2><span id='topic+dm_get_all_uks'></span>

<h3>Description</h3>

<p><code>dm_get_all_uks()</code> checks the <code>dm</code> object for unique keys
(primary keys, explicit and implicit unique keys) and returns the tables and
the respective unique key columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_all_uks(dm, table = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_get_all_uks_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_get_all_uks_+3A_table">table</code></td>
<td>
<p>One or more table names, unquoted,
to return unique key information for.
The default <code>NULL</code> returns information for all tables.</p>
</td></tr>
<tr><td><code id="dm_get_all_uks_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 3 kinds of unique keys:
</p>

<ul>
<li> <p><code>PK</code>: Primary key, set by <code><a href="#topic+dm_add_pk">dm_add_pk()</a></code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;explicit UK&#8288;</code>: Unique key, set by <code><a href="#topic+dm_add_uk">dm_add_uk()</a></code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;implicit UK&#8288;</code>: Unique key, not explicitly set, but referenced by a foreign key.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>table</code></dt><dd><p>table name,</p>
</dd>
<dt><code>uk_col</code></dt><dd><p>column name(s) of primary key, as list of character vectors,</p>
</dd>
<dt><code>kind</code></dt><dd><p>kind of unique key, see details.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_get_all_uks()

</code></pre>

<hr>
<h2 id='dm_get_con'>Get connection</h2><span id='topic+dm_get_con'></span>

<h3>Description</h3>

<p><code>dm_get_con()</code> returns the DBI connection for a <code>dm</code> object.
This works only if the tables are stored on a database, otherwise an error
is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_con(dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_get_con_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All lazy tables in a dm object must be stored on the same database server
and accessed through the same connection, because a large part
of the package's functionality relies on efficient joins.
</p>


<h3>Value</h3>

<p>The <code><a href="DBI.html#topic+DBIConnection-class">DBI::DBIConnection</a></code> object for a <code>dm</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_financial() %&gt;%
  dm_get_con()

</code></pre>

<hr>
<h2 id='dm_get_pk'>Primary key column names</h2><span id='topic+dm_get_pk'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is deprecated because of its limited use
and its unintuitive return value.
Use <code><a href="#topic+dm_get_all_pks">dm_get_all_pks()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_pk(dm, table, ...)
</code></pre>

<hr>
<h2 id='dm_get_tables'>Get tables</h2><span id='topic+dm_get_tables'></span>

<h3>Description</h3>

<p><code>dm_get_tables()</code> returns a named list of <span class="pkg">dplyr</span> <a href="#topic+tbl">tbl</a> objects
of a <code>dm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_tables(x, ..., keyed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_get_tables_+3A_x">x</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_get_tables_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_get_tables_+3A_keyed">keyed</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Set to <code>TRUE</code> to return objects of the internal class <code>"dm_keyed_tbl"</code>
that will contain information on primary and foreign keys
in the individual table objects.
This allows using dplyr workflows on those tables and later reconstruct them
into a <code>dm</code> object.
See <code><a href="#topic+dm_deconstruct">dm_deconstruct()</a></code> for a function that generates corresponding code
for an existing dm object, and <code>vignette("tech-dm-keyed")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the tables (data frames or lazy tables)
constituting the <code>dm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm">dm()</a></code> and <code><a href="#topic+new_dm">new_dm()</a></code> for constructing a <code>dm</code> object from tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm_nycflights13() %&gt;%
  dm_get_tables()

dm_nycflights13() %&gt;%
  dm_get_tables(keyed = TRUE)

dm_nycflights13() %&gt;%
  dm_get_tables(keyed = TRUE) %&gt;%
  new_dm()
</code></pre>

<hr>
<h2 id='dm_gui'>Shiny app for defining dm objects</h2><span id='topic+dm_gui'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function starts a Shiny application that allows to define <code>dm</code> objects
from a database or from local data frames.
The application generates R code that can be inserted or copy-pasted
into an R script or function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_gui(..., dm = NULL, select_tables = TRUE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_gui_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_gui_+3A_dm">dm</code></td>
<td>
<p>An initial dm object, currently required.</p>
</td></tr>
<tr><td><code id="dm_gui_+3A_select_tables">select_tables</code></td>
<td>
<p>Show selectize input to select tables?</p>
</td></tr>
<tr><td><code id="dm_gui_+3A_debug">debug</code></td>
<td>
<p>Set to <code>TRUE</code> to simplify debugging of the app.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a future release, the app will also allow composing <code>dm</code> objects directly
from database connections or data frames.
</p>
<p>The signature of this function is subject to change without notice.
This should not pose too many problems, because it will usually be run
interactively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dm &lt;- dm_nycflights13(cycle = TRUE)
dm_gui(dm = dm)

## End(Not run)
</code></pre>

<hr>
<h2 id='dm_has_fk'>Check if foreign keys exists</h2><span id='topic+dm_has_fk'></span><span id='topic+dm_get_fk'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions are deprecated because of their limited use
since the introduction of foreign keys to arbitrary columns in dm 0.2.1.
Use <code><a href="#topic+dm_get_all_fks">dm_get_all_fks()</a></code> with table manipulation functions instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_has_fk(dm, table, ref_table, ...)

dm_get_fk(dm, table, ref_table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_has_fk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_has_fk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_has_fk_+3A_ref_table">ref_table</code></td>
<td>
<p>The table which <code>table</code> will be referencing.</p>
</td></tr>
<tr><td><code id="dm_has_fk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>

<hr>
<h2 id='dm_has_pk'>Check for primary key</h2><span id='topic+dm_has_pk'></span>

<h3>Description</h3>

<p><code>dm_has_pk()</code> checks if a given table has columns marked as its primary key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_has_pk(dm, table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_has_pk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_has_pk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_has_pk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value: <code>TRUE</code> if the given table has a primary key, <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_has_pk(flights)
dm_nycflights13() %&gt;%
  dm_has_pk(planes)

</code></pre>

<hr>
<h2 id='dm_mutate_tbl'>Update tables in a <code><a href="#topic+dm">dm</a></code></h2><span id='topic+dm_mutate_tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Updates one or more existing tables in a <code><a href="#topic+dm">dm</a></code>.
For now, the column names must be identical.
This restriction may be levied optionally in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_mutate_tbl(dm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_mutate_tbl_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="dm_mutate_tbl_+3A_...">...</code></td>
<td>
<p>One or more tables to update in the <code>dm</code>.
Must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dm">dm()</a></code>, <code><a href="#topic+dm_select_tbl">dm_select_tbl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_mutate_tbl(flights = nycflights13::flights[1:3, ])

</code></pre>

<hr>
<h2 id='dm_nest_tbl'>Nest a table inside its dm</h2><span id='topic+dm_nest_tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>dm_nest_tbl()</code> converts a child table to a nested column in its parent
table.
The child table should not have children itself (i.e. it needs to be a
<em>terminal child table</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_nest_tbl(dm, child_table, into = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_nest_tbl_+3A_dm">dm</code></td>
<td>
<p>A dm.</p>
</td></tr>
<tr><td><code id="dm_nest_tbl_+3A_child_table">child_table</code></td>
<td>
<p>A terminal table with one parent table.</p>
</td></tr>
<tr><td><code id="dm_nest_tbl_+3A_into">into</code></td>
<td>
<p>The table to nest <code>child_tables</code> into, optional as it can be guessed
from the foreign keys unambiguously but useful to be explicit.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dm_wrap_tbl">dm_wrap_tbl()</a></code>, <code><a href="#topic+dm_unwrap_tbl">dm_unwrap_tbl()</a></code>, <code><a href="#topic+dm_pack_tbl">dm_pack_tbl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nested_dm &lt;-
  dm_nycflights13() %&gt;%
  dm_select_tbl(airlines, flights) %&gt;%
  dm_nest_tbl(flights)

nested_dm

nested_dm$airlines
</code></pre>

<hr>
<h2 id='dm_nrow'>Number of rows</h2><span id='topic+dm_nrow'></span>

<h3>Description</h3>

<p>Returns a named vector with the number of rows for each table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_nrow(dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_nrow_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the number of rows for each table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_filter(airports = (faa %in% c("EWR", "LGA"))) %&gt;%
  dm_nrow()

</code></pre>

<hr>
<h2 id='dm_nycflights13'>Creates a dm object for the <span class="pkg">nycflights13</span> data</h2><span id='topic+dm_nycflights13'></span>

<h3>Description</h3>

<p>Creates an example <code><a href="#topic+dm">dm</a></code> object from the tables in <span class="pkg">nycflights13</span>,
along with the references.
See <code><a href="nycflights13.html#topic+flights">nycflights13::flights</a></code> for a description of the data.
As described in <code><a href="nycflights13.html#topic+planes">nycflights13::planes</a></code>, the relationship
between the <code>flights</code> table and the <code>planes</code> tables is &quot;weak&quot;, it does not satisfy
data integrity constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_nycflights13(
  ...,
  cycle = FALSE,
  color = TRUE,
  subset = TRUE,
  compound = TRUE,
  table_description = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_nycflights13_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_nycflights13_+3A_cycle">cycle</code></td>
<td>
<p>Boolean.
If <code>FALSE</code> (default), only one foreign key relation
(from <code>flights$origin</code> to <code>airports$faa</code>) between the <code>flights</code> table and the <code>airports</code> table is
established.
If <code>TRUE</code>, a <code>dm</code> object with a double reference
between those tables will be produced.</p>
</td></tr>
<tr><td><code id="dm_nycflights13_+3A_color">color</code></td>
<td>
<p>Boolean, if <code>TRUE</code> (default), the resulting <code>dm</code> object will have
colors assigned to different tables for visualization with <code>dm_draw()</code>.</p>
</td></tr>
<tr><td><code id="dm_nycflights13_+3A_subset">subset</code></td>
<td>
<p>Boolean, if <code>TRUE</code> (default), the <code>flights</code> table is reduced to flights with column <code>day</code> equal to 10.</p>
</td></tr>
<tr><td><code id="dm_nycflights13_+3A_compound">compound</code></td>
<td>
<p>Boolean, if <code>FALSE</code>, no link will be established between tables <code>flights</code> and <code>weather</code>,
because this requires compound keys.</p>
</td></tr>
<tr><td><code id="dm_nycflights13_+3A_table_description">table_description</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, a description will be added for each table that will be displayed
when drawing the table with <code><a href="#topic+dm_draw">dm_draw()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dm</code> object consisting of <span class="pkg">nycflights13</span> tables, complete with primary and foreign keys and optionally colored.
</p>


<h3>See Also</h3>

<p><code>vignette("howto-dm-df")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_pack_tbl'>dm_pack_tbl()</h2><span id='topic+dm_pack_tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>dm_pack_tbl()</code> converts a parent table to a packed column in its child
table.
The parent table should not have parent tables itself (i.e. it needs to be a
<em>terminal parent table</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_pack_tbl(dm, parent_table, into = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_pack_tbl_+3A_dm">dm</code></td>
<td>
<p>A dm.</p>
</td></tr>
<tr><td><code id="dm_pack_tbl_+3A_parent_table">parent_table</code></td>
<td>
<p>A terminal table with one child table.</p>
</td></tr>
<tr><td><code id="dm_pack_tbl_+3A_into">into</code></td>
<td>
<p>The table to pack <code>parent_tables</code> into, optional as it can be guessed
from the foreign keys unambiguously but useful to be explicit.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dm_wrap_tbl">dm_wrap_tbl()</a></code>, <code><a href="#topic+dm_unwrap_tbl">dm_unwrap_tbl()</a></code>, <code><a href="#topic+dm_nest_tbl">dm_nest_tbl()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm_packed &lt;-
  dm_nycflights13() %&gt;%
  dm_pack_tbl(planes)

dm_packed

dm_packed$flights

dm_packed$flights$planes
</code></pre>

<hr>
<h2 id='dm_paste'>Create R code for a dm object</h2><span id='topic+dm_paste'></span>

<h3>Description</h3>

<p><code>dm_paste()</code> takes an existing <code>dm</code> and emits the code necessary for its creation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_paste(dm, select = NULL, ..., tab_width = 2, options = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_paste_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_paste_+3A_select">select</code></td>
<td>
<p>Deprecated, see <code>"select"</code> in the <code>options</code> argument.</p>
</td></tr>
<tr><td><code id="dm_paste_+3A_...">...</code></td>
<td>
<p>Must be empty.</p>
</td></tr>
<tr><td><code id="dm_paste_+3A_tab_width">tab_width</code></td>
<td>
<p>Indentation width for code from the second line onwards</p>
</td></tr>
<tr><td><code id="dm_paste_+3A_options">options</code></td>
<td>
<p>Formatting options. A character vector containing some of:
</p>

<ul>
<li> <p><code>"tables"</code>: <code><a href="#topic+tibble">tibble()</a></code> calls for empty table definitions
derived from <code><a href="#topic+dm_ptype">dm_ptype()</a></code>, overrides <code>"select"</code>.
</p>
</li>
<li> <p><code>"select"</code>: <code><a href="#topic+dm_select">dm_select()</a></code> statements for columns that are part
of the dm.
</p>
</li>
<li> <p><code>"keys"</code>: <code><a href="#topic+dm_add_pk">dm_add_pk()</a></code>, <code><a href="#topic+dm_add_fk">dm_add_fk()</a></code> and <code><a href="#topic+dm_add_uk">dm_add_uk()</a></code> statements for adding keys.
</p>
</li>
<li> <p><code>"color"</code>: <code><a href="#topic+dm_set_colors">dm_set_colors()</a></code> statements to set color.
</p>
</li>
<li> <p><code>"all"</code>: All options above except <code>"select"</code>
</p>
</li></ul>

<p>Default <code>NULL</code> is equivalent to <code>c("keys", "color")</code></p>
</td></tr>
<tr><td><code id="dm_paste_+3A_path">path</code></td>
<td>
<p>Output file, if <code>NULL</code> the code is printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code emitted by the function reproduces the structure of the <code>dm</code> object.
The <code>options</code> argument controls the level of detail: keys, colors,
table definitions.
Data in the tables is never included, see <code><a href="#topic+dm_ptype">dm_ptype()</a></code> for the underlying logic.
</p>


<h3>Value</h3>

<p>Code for producing the prototype of the given <code>dm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm() %&gt;%
  dm_paste()


dm_nycflights13() %&gt;%
  dm_paste()

dm_nycflights13() %&gt;%
  dm_paste(options = "select")

</code></pre>

<hr>
<h2 id='dm_pixarfilms'>Creates a dm object for the <span class="pkg">pixarfilms</span> data</h2><span id='topic+dm_pixarfilms'></span>

<h3>Description</h3>

<p>Creates an example <code><a href="#topic+dm">dm</a></code> object from the tables in
<span class="pkg">pixarfilms</span>, along with the references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_pixarfilms(..., color = TRUE, consistent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_pixarfilms_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_pixarfilms_+3A_color">color</code></td>
<td>
<p>Boolean, if <code>TRUE</code> (default), the resulting <code>dm</code> object will
have colors assigned to different tables for visualization with
<code>dm_draw()</code>.</p>
</td></tr>
<tr><td><code id="dm_pixarfilms_+3A_consistent">consistent</code></td>
<td>
<p>Boolean, In the original <code>dm</code>  the  <code>film</code> column in
<code>pixar_films</code> contains missing values so cannot be made a proper primary key.
Set to <code>TRUE</code> to remove those records.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dm</code> object consisting of <span class="pkg">pixarfilms</span> tables, complete with
primary and foreign keys and optionally colored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_pixarfilms()
dm_pixarfilms() %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_ptype'>Prototype for a dm object</h2><span id='topic+dm_ptype'></span>

<h3>Description</h3>

<p>The prototype contains all tables, all primary and foreign keys,
but no data.
All tables are truncated and converted to zero-row tibbles,
also for remote data models.
Columns retain their type.
This is useful for performing creation and population of a database
in separate steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_ptype(dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_ptype_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_financial() %&gt;%
  dm_ptype()

dm_financial() %&gt;%
  dm_ptype() %&gt;%
  dm_nrow()

</code></pre>

<hr>
<h2 id='dm_rename'>Rename columns</h2><span id='topic+dm_rename'></span>

<h3>Description</h3>

<p>Rename the columns of your <code><a href="#topic+dm">dm</a></code> using syntax that is similar to <code>dplyr::rename()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_rename(dm, table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_rename_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_rename_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_rename_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas.
You can treat
variable names as if they were positions, and use expressions like x:y
to select the ranges of variables.
</p>
<p>Use named arguments, e.g. new_name = old_name, to rename the selected variables.
</p>
<p>The arguments in ... are automatically quoted and evaluated in a context where
column names represent column positions.
They also support unquoting and splicing.
See <code>vignette("programming", package = "dplyr")</code> for an introduction to those concepts.
</p>
<p>See select helpers for more details, and the examples about tidyselect helpers, such as starts_with(), everything(), ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If key columns are renamed, then the meta-information of the <code>dm</code> is updated accordingly.
</p>


<h3>Value</h3>

<p>An updated <code>dm</code> with the columns of <code>table</code> renamed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_rename(airports, code = faa, altitude = alt)

</code></pre>

<hr>
<h2 id='dm_rm_fk'>Remove foreign keys</h2><span id='topic+dm_rm_fk'></span>

<h3>Description</h3>

<p><code>dm_rm_fk()</code> can remove either one reference between two tables, or multiple references at once (with a message).
An error is thrown if no matching foreign key is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_rm_fk(
  dm,
  table = NULL,
  columns = NULL,
  ref_table = NULL,
  ref_columns = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_rm_fk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_rm_fk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.
Pass <code>NULL</code> to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_fk_+3A_columns">columns</code></td>
<td>
<p>Table columns, unquoted.
To refer to a compound key, use <code>c(col1, col2)</code>.
Pass <code>NULL</code> (the default) to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_fk_+3A_ref_table">ref_table</code></td>
<td>
<p>The table referenced by the <code>table</code> argument.
Pass <code>NULL</code> to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_fk_+3A_ref_columns">ref_columns</code></td>
<td>
<p>The columns of <code>table</code> that should no longer be referencing the primary key of <code>ref_table</code>.
To refer to a compound key, use <code>c(col1, col2)</code>.</p>
</td></tr>
<tr><td><code id="dm_rm_fk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code>dm</code> without the matching foreign key relation(s).
</p>


<h3>See Also</h3>

<p>Other foreign key functions: 
<code><a href="#topic+dm_add_fk">dm_add_fk</a>()</code>,
<code><a href="#topic+dm_enum_fk_candidates">dm_enum_fk_candidates</a>()</code>,
<code><a href="#topic+dm_get_all_fks">dm_get_all_fks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13(cycle = TRUE) %&gt;%
  dm_rm_fk(flights, dest, airports) %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_rm_pk'>Remove a primary key</h2><span id='topic+dm_rm_pk'></span>

<h3>Description</h3>

<p>If a table name is provided, <code>dm_rm_pk()</code> removes the primary key from this table and leaves the <code><a href="#topic+dm">dm</a></code> object otherwise unaltered.
If no table is given, the <code>dm</code> is stripped of all primary keys at once.
An error is thrown if no primary key matches the selection criteria.
If the selection criteria are ambiguous, a message with unambiguous replacement code is shown.
Foreign keys are never removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_rm_pk(dm, table = NULL, columns = NULL, ..., fail_fk = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_rm_pk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_rm_pk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.
Pass <code>NULL</code> to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_pk_+3A_columns">columns</code></td>
<td>
<p>Table columns, unquoted.
To refer to a compound key, use <code>c(col1, col2)</code>.
Pass <code>NULL</code> (the default) to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_pk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_rm_pk_+3A_fail_fk">fail_fk</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code>dm</code> without the indicated primary key(s).
</p>


<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_rm_pk(airports) %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_rm_uk'>Remove a unique key</h2><span id='topic+dm_rm_uk'></span>

<h3>Description</h3>

<p><code>dm_rm_uk()</code> removes one or more unique keys from a table and leaves the <code><a href="#topic+dm">dm</a></code> object otherwise unaltered.
An error is thrown if no unique key matches the selection criteria.
If the selection criteria are ambiguous, a message with unambiguous replacement code is shown.
Foreign keys are never removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_rm_uk(dm, table = NULL, columns = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_rm_uk_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_rm_uk_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.
Pass <code>NULL</code> to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_uk_+3A_columns">columns</code></td>
<td>
<p>Table columns, unquoted.
To refer to a compound key, use <code>c(col1, col2)</code>.
Pass <code>NULL</code> (the default) to remove all matching keys.</p>
</td></tr>
<tr><td><code id="dm_rm_uk_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code>dm</code> without the indicated unique key(s).
</p>


<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+enum_pk_candidates">enum_pk_candidates</a>()</code>
</p>

<hr>
<h2 id='dm_select'>Select columns</h2><span id='topic+dm_select'></span>

<h3>Description</h3>

<p>Select columns of your <code><a href="#topic+dm">dm</a></code> using syntax that is similar to <code>dplyr::select()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_select(dm, table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_select_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_select_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_select_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas.
You can treat
variable names as if they were positions, and use expressions like x:y
to select the ranges of variables.
</p>
<p>Use named arguments, e.g. new_name = old_name, to rename the selected variables.
</p>
<p>The arguments in ... are automatically quoted and evaluated in a context where
column names represent column positions.
They also support unquoting and splicing.
See <code>vignette("programming", package = "dplyr")</code> for an introduction to those concepts.
</p>
<p>See select helpers for more details, and the examples about tidyselect helpers, such as starts_with(), everything(), ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If key columns are renamed, then the meta-information of the <code>dm</code> is updated accordingly.
If key columns are removed, then all related relations are dropped as well.
</p>


<h3>Value</h3>

<p>An updated <code>dm</code> with the columns of <code>table</code> reduced and/or renamed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_select(airports, code = faa, altitude = alt)

</code></pre>

<hr>
<h2 id='dm_select_tbl'>Select and rename tables</h2><span id='topic+dm_select_tbl'></span><span id='topic+dm_rename_tbl'></span>

<h3>Description</h3>

<p><code>dm_select_tbl()</code> keeps the selected tables and their relationships,
optionally renaming them.
</p>
<p><code>dm_rename_tbl()</code> renames tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_select_tbl(dm, ...)

dm_rename_tbl(dm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_select_tbl_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="dm_select_tbl_+3A_...">...</code></td>
<td>
<p>One or more table names of the tables of the <code><a href="#topic+dm">dm</a></code> object.
<code>tidyselect</code> is supported, see <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> for details on the semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>dm</code> with tables renamed or removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;%
  dm_select_tbl(airports, fl = flights)


dm_nycflights13() %&gt;%
  dm_rename_tbl(ap = airports, fl = flights)

</code></pre>

<hr>
<h2 id='dm_set_colors'>Color in database diagrams</h2><span id='topic+dm_set_colors'></span><span id='topic+dm_get_colors'></span><span id='topic+dm_get_available_colors'></span>

<h3>Description</h3>

<p><code>dm_set_colors()</code> allows to define the colors that will be used to display the tables of the data model with <code><a href="#topic+dm_draw">dm_draw()</a></code>.
The colors can either be either specified with hex color codes or using the names of the built-in R colors.
An overview of the colors corresponding to the standard color names can be found at
the bottom of
<a href="https://rpubs.com/krlmlr/colors">https://rpubs.com/krlmlr/colors</a>.
</p>
<p><code>dm_get_colors()</code> returns the colors defined for a data model.
</p>
<p><code>dm_get_available_colors()</code> returns an overview of the names of the available colors
These are the standard colors also returned by <code><a href="grDevices.html#topic+colors">grDevices::colors()</a></code> plus a default
table color with the name &quot;default&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_set_colors(dm, ...)

dm_get_colors(dm)

dm_get_available_colors()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_set_colors_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="dm_set_colors_+3A_...">...</code></td>
<td>
<p>Colors to set in the form <code>color = table</code>.
Allowed colors are all hex coded colors (quoted) and the color names from <code>dm_get_available_colors()</code>.
<code>tidyselect</code> is supported, see <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> for details on the semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>dm_set_colors()</code>: the updated data model.
</p>
<p>For <code>dm_get_colors()</code>, a named character vector of table names
with the colors in the names.
This allows calling <code>dm_set_colors(!!!dm_get_colors(...))</code>.
Use <code><a href="tibble.html#topic+enframe">tibble::enframe()</a></code> to convert this to a tibble.
</p>
<p>For <code>dm_get_available_colors()</code>, a vector with the available colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13(color = FALSE) %&gt;%
  dm_set_colors(
    darkblue = starts_with("air"),
    "#5986C4" = flights
  ) %&gt;%
  dm_draw()

# Splicing is supported:
nyc_cols &lt;-
  dm_nycflights13() %&gt;%
  dm_get_colors()
nyc_cols

dm_nycflights13(color = FALSE) %&gt;%
  dm_set_colors(!!!nyc_cols) %&gt;%
  dm_draw()

</code></pre>

<hr>
<h2 id='dm_set_table_description'>Add info about a dm's tables</h2><span id='topic+dm_set_table_description'></span><span id='topic+dm_get_table_description'></span><span id='topic+dm_reset_table_description'></span>

<h3>Description</h3>

<p>When creating a diagram from a <code>dm</code> using <code><a href="#topic+dm_draw">dm_draw()</a></code> the table descriptions set with <code>dm_set_table_description()</code> will be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_set_table_description(dm, ...)

dm_get_table_description(dm, table = NULL, ...)

dm_reset_table_description(dm, table = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_set_table_description_+3A_dm">dm</code></td>
<td>
<p>A <code><a href="#topic+dm">dm</a></code> object.</p>
</td></tr>
<tr><td><code id="dm_set_table_description_+3A_...">...</code></td>
<td>
<p>For <code>dm_set_table_description()</code>: Descriptions for tables to set in the form <code>description = table</code>.
<code>tidyselect</code> is supported, see <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> for details on the semantics.
</p>
<p>For <code>dm_get_table_description()</code> and <code>dm_reset_table_description()</code>: These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="dm_set_table_description_+3A_table">table</code></td>
<td>
<p>One or more table names, unquoted, for which to
</p>

<ol>
<li><p> get information about the current description(s) with <code><a href="#topic+dm_get_table_description">dm_get_table_description()</a></code>.
</p>
</li>
<li><p> remove descriptions with <code><a href="#topic+dm_reset_table_description">dm_reset_table_description()</a></code>.
</p>
</li></ol>

<p>In both cases the default applies to all tables in the <code>dm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multi-line descriptions can be achieved using the newline symbol <code style="white-space: pre;">&#8288;\n&#8288;</code>.
Descriptions are set with <code>dm_set_table_description()</code>.
The currently set descriptions can be checked using <code>dm_get_table_description()</code>.
Descriptions can be removed using <code>dm_reset_table_description()</code>.
</p>


<h3>Value</h3>

<p>For <code>dm_set_table_description()</code>: A <code>dm</code> object containing descriptions for specified tables.
</p>
<p>For <code>dm_get_table_description</code>: A named vector of tables, with the descriptions in the names.
</p>
<p>For <code>dm_reset_table_description()</code>: A <code>dm</code> object without descriptions for specified tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
desc_flights &lt;- rlang::set_names(
  "flights",
  paste(
    "On-time data for all flights",
    "that departed NYC (i.e. JFK, LGA or EWR) in 2013.",
    sep = "\n"
  )
)
nyc_desc &lt;- dm_nycflights13() %&gt;%
  dm_set_table_description(
    !!desc_flights,
    "Weather at the airport of\norigin at time of departure" = weather
  )
nyc_desc %&gt;%
  dm_draw()

dm_get_table_description(nyc_desc)
dm_reset_table_description(nyc_desc, flights) %&gt;%
  dm_draw(font_size = c(header = 18L, table_description = 9L, column = 15L))

pull_tbl(nyc_desc, flights) %&gt;%
  labelled::label_attribute()

</code></pre>

<hr>
<h2 id='dm_sql'>Create <em>DDL</em> and <em>DML</em> scripts for a <code>dm</code> a and database connection</h2><span id='topic+dm_sql'></span><span id='topic+dm_ddl_pre'></span><span id='topic+dm_dml_load'></span><span id='topic+dm_ddl_post'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Generate SQL scripts to create tables, load data and set constraints, keys and indices.
This function powers <code><a href="#topic+copy_dm_to">copy_dm_to()</a></code> and is useful if you need more control
over the process of copying a <code>dm</code> to a database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_sql(dm, dest, table_names = NULL, temporary = TRUE)

dm_ddl_pre(dm, dest, table_names = NULL, temporary = TRUE)

dm_dml_load(dm, dest, table_names = NULL, temporary = TRUE)

dm_ddl_post(dm, dest, table_names = NULL, temporary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_sql_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_sql_+3A_dest">dest</code></td>
<td>
<p>Connection to database.</p>
</td></tr>
<tr><td><code id="dm_sql_+3A_table_names">table_names</code></td>
<td>
<p>A named character vector or named vector of <a href="DBI.html#topic+Id">DBI::Id</a>,
<a href="DBI.html#topic+SQL">DBI::SQL</a> or dbplyr objects created with <code><a href="dbplyr.html#topic+ident">dbplyr::ident()</a></code>, <code><a href="dbplyr.html#topic+in_schema">dbplyr::in_schema()</a></code>
or <code><a href="dbplyr.html#topic+in_schema">dbplyr::in_catalog()</a></code>,
with one unique element for each table in <code>dm</code>.
The default, <code>NULL</code>, means to use the original table names.</p>
</td></tr>
<tr><td><code id="dm_sql_+3A_temporary">temporary</code></td>
<td>
<p>Should the tables be marked as <em>temporary</em>? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>dm_ddl_pre()</code> generates <code style="white-space: pre;">&#8288;CREATE TABLE&#8288;</code> statements (including <code style="white-space: pre;">&#8288;PRIMARY KEY&#8288;</code> definition). 
</p>
</li>
<li> <p><code>dm_dml_load()</code> generates <code style="white-space: pre;">&#8288;INSERT INTO&#8288;</code> statements. 
</p>
</li>
<li> <p><code>dm_ddl_post()</code> generates scripts for <code style="white-space: pre;">&#8288;FOREIGN KEY&#8288;</code>, <code style="white-space: pre;">&#8288;UNIQUE KEY&#8288;</code> and <code>INDEX</code>. 
</p>
</li>
<li> <p><code>dm_sql()</code> calls all three above and returns a complete set of scripts. 
</p>
</li></ul>



<h3>Value</h3>

<p>Nested list of SQL statements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
con &lt;- DBI::dbConnect(RSQLite::SQLite())
dm &lt;- dm_nycflights13()
s &lt;- dm_sql(dm, con)
s
DBI::dbDisconnect(con)

</code></pre>

<hr>
<h2 id='dm_unnest_tbl'>Unnest columns from a wrapped table</h2><span id='topic+dm_unnest_tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>dm_unnest_tbl()</code> target a specific column to unnest
from the given table in a given dm.
A ptype or a set of keys should be given, not both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_unnest_tbl(dm, parent_table, col, ptype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_unnest_tbl_+3A_dm">dm</code></td>
<td>
<p>A dm.</p>
</td></tr>
<tr><td><code id="dm_unnest_tbl_+3A_parent_table">parent_table</code></td>
<td>
<p>A table in the dm with nested columns.</p>
</td></tr>
<tr><td><code id="dm_unnest_tbl_+3A_col">col</code></td>
<td>
<p>The column to unnest (unquoted).</p>
</td></tr>
<tr><td><code id="dm_unnest_tbl_+3A_ptype">ptype</code></td>
<td>
<p>A dm, only used to query names of primary and foreign keys.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+dm_nest_tbl">dm_nest_tbl()</a></code> is an inverse operation to <code>dm_unnest_tbl()</code>
if differences in row and column order are ignored.
The opposite is true if referential constraints between both tables
are satisfied.
</p>


<h3>Value</h3>

<p>A dm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm_unwrap_tbl">dm_unwrap_tbl()</a></code>, <code><a href="#topic+dm_unpack_tbl">dm_unpack_tbl()</a></code>,
<code><a href="#topic+dm_nest_tbl">dm_nest_tbl()</a></code>, <code><a href="#topic+dm_pack_tbl">dm_pack_tbl()</a></code>, <code><a href="#topic+dm_wrap_tbl">dm_wrap_tbl()</a></code>,
<code><a href="#topic+dm_examine_constraints">dm_examine_constraints()</a></code>, <code><a href="#topic+dm_examine_cardinalities">dm_examine_cardinalities()</a></code>,
<code><a href="#topic+dm_ptype">dm_ptype()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>airlines_wrapped &lt;-
  dm_nycflights13() %&gt;%
  dm_wrap_tbl(airlines)

# The ptype is required for reconstruction.
# It can be an empty dm, only primary and foreign keys are considered.
ptype &lt;- dm_ptype(dm_nycflights13())

airlines_wrapped %&gt;%
  dm_unnest_tbl(airlines, flights, ptype)
</code></pre>

<hr>
<h2 id='dm_unpack_tbl'>Unpack columns from a wrapped table</h2><span id='topic+dm_unpack_tbl'></span>

<h3>Description</h3>

<p>#' @description
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_unpack_tbl(dm, child_table, col, ptype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_unpack_tbl_+3A_dm">dm</code></td>
<td>
<p>A dm.</p>
</td></tr>
<tr><td><code id="dm_unpack_tbl_+3A_child_table">child_table</code></td>
<td>
<p>A table in the dm with packed columns.</p>
</td></tr>
<tr><td><code id="dm_unpack_tbl_+3A_col">col</code></td>
<td>
<p>The column to unpack (unquoted).</p>
</td></tr>
<tr><td><code id="dm_unpack_tbl_+3A_ptype">ptype</code></td>
<td>
<p>A dm, only used to query names of primary and foreign keys.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dm_unpack_tbl()</code> targets a specific column to unpack
from the given table in a given dm.
A ptype or a set of keys should be given,
not both.
</p>
<p><code><a href="#topic+dm_pack_tbl">dm_pack_tbl()</a></code> is an inverse operation to <code>dm_unpack_tbl()</code>
if differences in row and column order are ignored.
The opposite is true if referential constraints between both tables
are satisfied
and if all rows in the parent table have at least one child row,
i.e. if the relationship is of cardinality 1:n or 1:1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm_unwrap_tbl">dm_unwrap_tbl()</a></code>, <code><a href="#topic+dm_unnest_tbl">dm_unnest_tbl()</a></code>,
<code><a href="#topic+dm_nest_tbl">dm_nest_tbl()</a></code>, <code><a href="#topic+dm_pack_tbl">dm_pack_tbl()</a></code>, <code><a href="#topic+dm_wrap_tbl">dm_wrap_tbl()</a></code>,
<code><a href="#topic+dm_examine_constraints">dm_examine_constraints()</a></code>, <code><a href="#topic+dm_examine_cardinalities">dm_examine_cardinalities()</a></code>,
<code><a href="#topic+dm_ptype">dm_ptype()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flights_wrapped &lt;-
  dm_nycflights13() %&gt;%
  dm_wrap_tbl(flights)

# The ptype is required for reconstruction.
# It can be an empty dm, only primary and foreign keys are considered.
ptype &lt;- dm_ptype(dm_nycflights13())

flights_wrapped %&gt;%
  dm_unpack_tbl(flights, airlines, ptype)
</code></pre>

<hr>
<h2 id='dm_unwrap_tbl'>Unwrap a single table dm</h2><span id='topic+dm_unwrap_tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>dm_unwrap_tbl()</code> unwraps all tables in a dm object so that the resulting dm
matches a given ptype dm.
It runs a sequence of <code><a href="#topic+dm_unnest_tbl">dm_unnest_tbl()</a></code> and <code><a href="#topic+dm_unpack_tbl">dm_unpack_tbl()</a></code> operations
on the dm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_unwrap_tbl(dm, ptype, progress = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_unwrap_tbl_+3A_dm">dm</code></td>
<td>
<p>A dm.</p>
</td></tr>
<tr><td><code id="dm_unwrap_tbl_+3A_ptype">ptype</code></td>
<td>
<p>A dm, only used to query names of primary and foreign keys.</p>
</td></tr>
<tr><td><code id="dm_unwrap_tbl_+3A_progress">progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dm.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm_wrap_tbl">dm_wrap_tbl()</a></code>, <code><a href="#topic+dm_unnest_tbl">dm_unnest_tbl()</a></code>,
<code><a href="#topic+dm_examine_constraints">dm_examine_constraints()</a></code>,
<code><a href="#topic+dm_examine_cardinalities">dm_examine_cardinalities()</a></code>,
<code><a href="#topic+dm_ptype">dm_ptype()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
roundtrip &lt;-
  dm_nycflights13() %&gt;%
  dm_wrap_tbl(root = flights) %&gt;%
  dm_unwrap_tbl(ptype = dm_ptype(dm_nycflights13()))
roundtrip

# The roundtrip has the same structure but fewer rows:
dm_nrow(dm_nycflights13())
dm_nrow(roundtrip)
</code></pre>

<hr>
<h2 id='dm_validate'>Validator</h2><span id='topic+dm_validate'></span>

<h3>Description</h3>

<p><code>dm_validate()</code> checks the internal consistency of a <code>dm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_validate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_validate_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In theory, with the exception of <code><a href="#topic+new_dm">new_dm()</a></code>, all <code>dm</code> objects
created or modified by functions in this package should be valid,
and this function should not be needed.
Please file an issue if any dm operation creates an invalid object.
</p>


<h3>Value</h3>

<p>Returns the <code>dm</code>, invisibly, after finishing all checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm_validate(dm())

bad_dm &lt;- structure(list(bad = "dm"), class = "dm")
try(dm_validate(bad_dm))
</code></pre>

<hr>
<h2 id='dm_wrap_tbl'>Wrap dm into a single tibble dm</h2><span id='topic+dm_wrap_tbl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>dm_wrap_tbl()</code> creates a single tibble dm containing the <code>root</code> table
enhanced with all the data related to it
through the relationships stored in the dm.
It runs a sequence of <code><a href="#topic+dm_nest_tbl">dm_nest_tbl()</a></code> and <code><a href="#topic+dm_pack_tbl">dm_pack_tbl()</a></code> operations
on the dm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_wrap_tbl(dm, root, strict = TRUE, progress = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_wrap_tbl_+3A_dm">dm</code></td>
<td>
<p>A cycle free dm object.</p>
</td></tr>
<tr><td><code id="dm_wrap_tbl_+3A_root">root</code></td>
<td>
<p>Table to wrap the dm into (unquoted).</p>
</td></tr>
<tr><td><code id="dm_wrap_tbl_+3A_strict">strict</code></td>
<td>
<p>Whether to fail for cyclic dms that cannot be wrapped into a
single table, if <code>FALSE</code> a partially wrapped dm will be returned.</p>
</td></tr>
<tr><td><code id="dm_wrap_tbl_+3A_progress">progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dm_wrap_tbl()</code> is an inverse to <code>dm_unwrap_tbl()</code>,
i.e., wrapping after unwrapping returns the same information
(disregarding row and column order).
The opposite is not generally true:
since <code>dm_wrap_tbl()</code> keeps only rows related directly or indirectly to
rows in the <code>root</code> table.
Even if all referential constraints are satisfied,
unwrapping after wrapping loses rows in parent tables
that don't have a corresponding row in the child table.
</p>
<p>This function differs from <code>dm_flatten_to_tbl()</code> and <code>dm_squash_to_tbl()</code> ,
which always return a single table, and not a <code>dm</code> object.
</p>


<h3>Value</h3>

<p>A <code>dm</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm_unwrap_tbl">dm_unwrap_tbl()</a></code>, <code><a href="#topic+dm_nest_tbl">dm_nest_tbl()</a></code>,
<code><a href="#topic+dm_examine_constraints">dm_examine_constraints()</a></code>,
<code><a href="#topic+dm_examine_cardinalities">dm_examine_cardinalities()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm_nycflights13() %&gt;%
  dm_wrap_tbl(root = airlines)
</code></pre>

<hr>
<h2 id='dm_zoom_to'>Mark table for manipulation</h2><span id='topic+dm_zoom_to'></span><span id='topic+zoomed_df'></span><span id='topic+dm_zoomed_df'></span><span id='topic+dm_insert_zoomed'></span><span id='topic+dm_update_zoomed'></span><span id='topic+dm_discard_zoomed'></span>

<h3>Description</h3>

<p>Zooming to a table of a <code><a href="#topic+dm">dm</a></code> allows for the use of many <code>dplyr</code>-verbs directly on this table, while retaining the
context of the <code>dm</code> object.
</p>
<p><code>dm_zoom_to()</code> zooms to the given table.
</p>
<p><code>dm_update_zoomed()</code> overwrites the originally zoomed table with the manipulated table.
The filter conditions for the zoomed table are added to the original filter conditions.
</p>
<p><code>dm_insert_zoomed()</code> adds a new table to the <code>dm</code>.
</p>
<p><code>dm_discard_zoomed()</code> discards the zoomed table and returns the <code>dm</code> as it was before zooming.
</p>
<p>Please refer to <code>vignette("tech-db-zoom", package = "dm")</code>
for a more detailed introduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_zoom_to(dm, table)

dm_insert_zoomed(dm, new_tbl_name = NULL, repair = "unique", quiet = FALSE)

dm_update_zoomed(dm)

dm_discard_zoomed(dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dm_zoom_to_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dm_zoom_to_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dm_zoom_to_+3A_new_tbl_name">new_tbl_name</code></td>
<td>
<p>Name of the new table.</p>
</td></tr>
<tr><td><code id="dm_zoom_to_+3A_repair">repair</code></td>
<td>
<p>Either a string or a function. If a string, it must be one of
<code>"check_unique"</code>, <code>"minimal"</code>, <code>"unique"</code>, <code>"universal"</code>, <code>"unique_quiet"</code>,
or <code>"universal_quiet"</code>. If a function, it is invoked with a vector of
minimal names and must return minimal names, otherwise an error is thrown.
</p>

<ul>
<li><p> Minimal names are never <code>NULL</code> or <code>NA</code>. When an element doesn't
have a name, its minimal name is an empty string.
</p>
</li>
<li><p> Unique names are unique. A suffix is appended to duplicate
names to make them unique.
</p>
</li>
<li><p> Universal names are unique and syntactic, meaning that you can
safely use the names as variables without causing a syntax
error.
</p>
</li></ul>

<p>The <code>"check_unique"</code> option doesn't perform any name repair.
Instead, an error is raised if the names don't suit the
<code>"unique"</code> criteria.
</p>
<p>The options <code>"unique_quiet"</code> and <code>"universal_quiet"</code> are here to help the
user who calls this function indirectly, via another function which exposes
<code>repair</code> but not <code>quiet</code>. Specifying <code>repair = "unique_quiet"</code> is like
specifying <code style="white-space: pre;">&#8288;repair = "unique", quiet = TRUE&#8288;</code>. When the <code>"*_quiet"</code> options
are used, any setting of <code>quiet</code> is silently overridden.</p>
</td></tr>
<tr><td><code id="dm_zoom_to_+3A_quiet">quiet</code></td>
<td>
<p>By default, the user is informed of any renaming
caused by repairing the names. This only concerns unique and
universal repairing. Set <code>quiet</code> to <code>TRUE</code> to silence the
messages.
</p>
<p>Users can silence the name repair messages by setting the
<code>"rlib_name_repair_verbosity"</code> global option to <code>"quiet"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever possible, the key relations of the original table are transferred to the resulting table
when using <code>dm_insert_zoomed()</code> or <code>dm_update_zoomed()</code>.
</p>
<p>Functions from <code>dplyr</code> that are supported for a <code>dm_zoomed</code>: <code><a href="#topic+group_by">group_by()</a></code>, <code><a href="#topic+summarise">summarise()</a></code>, <code><a href="#topic+mutate">mutate()</a></code>,
<code><a href="#topic+transmute">transmute()</a></code>, <code><a href="#topic+filter">filter()</a></code>, <code><a href="#topic+select">select()</a></code>, <code><a href="#topic+rename">rename()</a></code> and <code><a href="#topic+ungroup">ungroup()</a></code>.
You can use these functions just like you would
with a normal table.
</p>
<p>Calling <code><a href="#topic+filter">filter()</a></code> on a zoomed <code>dm</code> is different from calling <code><a href="#topic+dm_filter">dm_filter()</a></code>:
only with the latter, the filter expression is added to the list of table filters stored in the dm.
</p>
<p>Furthermore, different <code>join()</code>-variants from <span class="pkg">dplyr</span> are also supported,
e.g. <code><a href="#topic+left_join">left_join()</a></code> and <code><a href="#topic+semi_join">semi_join()</a></code>.
(Support for <code><a href="dplyr.html#topic+nest_join">nest_join()</a></code> is planned.)
The join-methods for <code>dm_zoomed</code> infer the columns to join by from the primary and foreign keys,
and have an extra argument <code>select</code> that allows choosing the columns of the RHS table.
</p>
<p>And &ndash; last but not least &ndash; also the <span class="pkg">tidyr</span>-functions <code><a href="#topic+unite">unite()</a></code> and <code><a href="#topic+separate">separate()</a></code> are supported for <code>dm_zoomed</code>.
</p>


<h3>Value</h3>

<p>For <code>dm_zoom_to()</code>: A <code>dm_zoomed</code> object.
</p>
<p>For <code>dm_insert_zoomed()</code>, <code>dm_update_zoomed()</code> and <code>dm_discard_zoomed()</code>: A <code>dm</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
flights_zoomed &lt;- dm_zoom_to(dm_nycflights13(), flights)

flights_zoomed

flights_zoomed_transformed &lt;-
  flights_zoomed %&gt;%
  mutate(am_pm_dep = ifelse(dep_time &lt; 1200, "am", "pm")) %&gt;%
  # `by`-argument of `left_join()` can be explicitly given
  # otherwise the key-relation is used
  left_join(airports) %&gt;%
  select(year:dep_time, am_pm_dep, everything())

flights_zoomed_transformed

# replace table `flights` with the zoomed table
flights_zoomed_transformed %&gt;%
  dm_update_zoomed()

# insert the zoomed table as a new table
flights_zoomed_transformed %&gt;%
  dm_insert_zoomed("extended_flights") %&gt;%
  dm_draw()

# discard the zoomed table
flights_zoomed_transformed %&gt;%
  dm_discard_zoomed()

</code></pre>

<hr>
<h2 id='dplyr_join'><span class="pkg">dplyr</span> join methods for zoomed dm objects</h2><span id='topic+dplyr_join'></span><span id='topic+left_join.dm_zoomed'></span><span id='topic+left_join.dm_keyed_tbl'></span><span id='topic+inner_join.dm_zoomed'></span><span id='topic+inner_join.dm_keyed_tbl'></span><span id='topic+full_join.dm_zoomed'></span><span id='topic+full_join.dm_keyed_tbl'></span><span id='topic+right_join.dm_zoomed'></span><span id='topic+right_join.dm_keyed_tbl'></span><span id='topic+semi_join.dm_zoomed'></span><span id='topic+semi_join.dm_keyed_tbl'></span><span id='topic+anti_join.dm_zoomed'></span><span id='topic+anti_join.dm_keyed_tbl'></span><span id='topic+nest_join.dm_zoomed'></span>

<h3>Description</h3>

<p>Use these methods without the '.dm_zoomed' suffix (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dm_zoomed'
left_join(x, y, by = NULL, copy = NULL, suffix = NULL, select = NULL, ...)

## S3 method for class 'dm_keyed_tbl'
left_join(x, y, by = NULL, copy = NULL, suffix = NULL, ..., keep = FALSE)

## S3 method for class 'dm_zoomed'
inner_join(x, y, by = NULL, copy = NULL, suffix = NULL, select = NULL, ...)

## S3 method for class 'dm_keyed_tbl'
inner_join(x, y, by = NULL, copy = NULL, suffix = NULL, ..., keep = FALSE)

## S3 method for class 'dm_zoomed'
full_join(x, y, by = NULL, copy = NULL, suffix = NULL, select = NULL, ...)

## S3 method for class 'dm_keyed_tbl'
full_join(x, y, by = NULL, copy = NULL, suffix = NULL, ..., keep = FALSE)

## S3 method for class 'dm_zoomed'
right_join(x, y, by = NULL, copy = NULL, suffix = NULL, select = NULL, ...)

## S3 method for class 'dm_keyed_tbl'
right_join(x, y, by = NULL, copy = NULL, suffix = NULL, ..., keep = FALSE)

## S3 method for class 'dm_zoomed'
semi_join(x, y, by = NULL, copy = NULL, suffix = NULL, select = NULL, ...)

## S3 method for class 'dm_keyed_tbl'
semi_join(x, y, by = NULL, copy = NULL, ...)

## S3 method for class 'dm_zoomed'
anti_join(x, y, by = NULL, copy = NULL, suffix = NULL, select = NULL, ...)

## S3 method for class 'dm_keyed_tbl'
anti_join(x, y, by = NULL, copy = NULL, ...)

## S3 method for class 'dm_zoomed'
nest_join(x, y, by = NULL, copy = FALSE, keep = FALSE, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_join_+3A_x">x</code>, <code id="dplyr_join_+3A_y">y</code></td>
<td>
<p>tbls to join. <code>x</code> is the <code>dm_zoomed</code> and <code>y</code> is another table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_by">by</code></td>
<td>
<p>If left <code>NULL</code> (default), the join will be performed by via the foreign key relation that exists between the originally zoomed table (now <code>x</code>)
and the other table (<code>y</code>).
If you provide a value (for the syntax see <code><a href="dplyr.html#topic+mutate-joins">dplyr::join</a></code>), you can also join tables that are not connected in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_copy">copy</code></td>
<td>
<p>Disabled, since all tables in a <code>dm</code> are by definition on the same <code>src</code>.</p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_suffix">suffix</code></td>
<td>
<p>Disabled, since columns are disambiguated automatically if necessary, changing the column names to <code>table_name.column_name</code>.</p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_select">select</code></td>
<td>
<p>Select a subset of the <strong>RHS-table</strong>'s columns, the syntax being <code>select = c(col_1, col_2, col_3)</code> (unquoted or quoted).
This argument is specific for the <code>join</code>-methods for <code>dm_zoomed</code>.
The table's <code>by</code> column(s) are automatically added if missing in the selection.</p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_...">...</code></td>
<td>
<p>see <code><a href="dplyr.html#topic+mutate-joins">dplyr::join</a></code></p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_keep">keep</code></td>
<td>
<p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</td></tr>
<tr><td><code id="dplyr_join_+3A_name">name</code></td>
<td>
<p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
flights_dm &lt;- dm_nycflights13()
dm_zoom_to(flights_dm, flights) %&gt;%
  left_join(airports, select = c(faa, name))

# this should illustrate that tables don't necessarily need to be connected
dm_zoom_to(flights_dm, airports) %&gt;%
  semi_join(airlines, by = "name")

</code></pre>

<hr>
<h2 id='dplyr_src'>dm as data source</h2><span id='topic+dplyr_src'></span><span id='topic+dm_get_src'></span><span id='topic+tbl.dm'></span><span id='topic+src_tbls.dm'></span><span id='topic+copy_to.dm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These methods are deprecated because of their limited use,
and because the notion of a &quot;source&quot; seems to be getting phased out from dplyr.
Use other ways to access the tables in a <code>dm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_get_src(x)

## S3 method for class 'dm'
tbl(src, from, ...)

## S3 method for class 'dm'
src_tbls(x, ...)

## S3 method for class 'dm'
copy_to(
  dest,
  df,
  name = deparse(substitute(df)),
  overwrite = FALSE,
  temporary = TRUE,
  repair = "unique",
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_src_+3A_src">src</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_from">from</code></td>
<td>
<p>A length one character variable containing the name of the requested table</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_...">...</code></td>
<td>
<p>See original function documentation</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_dest">dest</code></td>
<td>
<p>For <code>copy_to.dm()</code>: The <code>dm</code> object to which a table should be copied.</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_df">df</code></td>
<td>
<p>For <code>copy_to.dm()</code>: A table (can be on a different <code>src</code>)</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_name">name</code></td>
<td>
<p>For <code>copy_to.dm()</code>: See <code><a href="dplyr.html#topic+copy_to">dplyr::copy_to()</a></code></p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_overwrite">overwrite</code></td>
<td>
<p>For <code>copy_to.dm()</code>: See <code><a href="dplyr.html#topic+copy_to">dplyr::copy_to()</a></code>; <code>TRUE</code> leads to an error</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_temporary">temporary</code></td>
<td>
<p>For <code>copy_to.dm()</code>: If the <code>dm</code> is on a DB, the copied version of <code>df</code> will only be written temporarily to the DB.
After the connection is reset it will no longer be available.</p>
</td></tr>
<tr><td><code id="dplyr_src_+3A_repair">repair</code>, <code id="dplyr_src_+3A_quiet">quiet</code></td>
<td>
<p>Name repair options; cf. <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code><a href="#topic+dm_get_con">dm_get_con()</a></code> instead of <code>dm_get_src()</code> to get the DBI connetion for a
<code>dm</code> object
</p>
<p>Use <code><a href="base.html#topic+Extract">[[</a></code> instead of <code>tbl()</code> to access individual tables in a <code>dm</code> object.
</p>
<p>Get the names from <code><a href="#topic+dm_get_tables">dm_get_tables()</a></code> instead of calling <code>dm_get_src()</code>
to list the table names in a <code>dm</code> object.
</p>
<p>Use <code><a href="#topic+copy_to">copy_to()</a></code> on a table and then <code><a href="#topic+dm">dm()</a></code> instead of <code>copy_to()</code>
on a <code>dm</code> object.
</p>

<hr>
<h2 id='dplyr_table_manipulation'><span class="pkg">dplyr</span> table manipulation methods for zoomed dm objects</h2><span id='topic+dplyr_table_manipulation'></span><span id='topic+filter.dm_zoomed'></span><span id='topic+mutate.dm_zoomed'></span><span id='topic+transmute.dm_zoomed'></span><span id='topic+select.dm_zoomed'></span><span id='topic+relocate.dm_zoomed'></span><span id='topic+rename.dm_zoomed'></span><span id='topic+distinct.dm_zoomed'></span><span id='topic+arrange.dm_zoomed'></span><span id='topic+slice.dm_zoomed'></span><span id='topic+group_by.dm_zoomed'></span><span id='topic+group_by.dm_keyed_tbl'></span><span id='topic+ungroup.dm_zoomed'></span><span id='topic+summarise.dm_zoomed'></span><span id='topic+summarise.dm_keyed_tbl'></span><span id='topic+count.dm_zoomed'></span><span id='topic+tally.dm_zoomed'></span><span id='topic+pull.dm_zoomed'></span><span id='topic+compute.dm_zoomed'></span>

<h3>Description</h3>

<p>Use these methods without the '.dm_zoomed' suffix (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dm_zoomed'
filter(.data, ...)

## S3 method for class 'dm_zoomed'
mutate(.data, ...)

## S3 method for class 'dm_zoomed'
transmute(.data, ...)

## S3 method for class 'dm_zoomed'
select(.data, ...)

## S3 method for class 'dm_zoomed'
relocate(.data, ..., .before = NULL, .after = NULL)

## S3 method for class 'dm_zoomed'
rename(.data, ...)

## S3 method for class 'dm_zoomed'
distinct(.data, ..., .keep_all = FALSE)

## S3 method for class 'dm_zoomed'
arrange(.data, ...)

## S3 method for class 'dm_zoomed'
slice(.data, ..., .keep_pk = NULL)

## S3 method for class 'dm_zoomed'
group_by(.data, ...)

## S3 method for class 'dm_keyed_tbl'
group_by(.data, ...)

## S3 method for class 'dm_zoomed'
ungroup(x, ...)

## S3 method for class 'dm_zoomed'
summarise(.data, ...)

## S3 method for class 'dm_keyed_tbl'
summarise(.data, ...)

## S3 method for class 'dm_zoomed'
count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x)
)

## S3 method for class 'dm_zoomed'
tally(x, ...)

## S3 method for class 'dm_zoomed'
pull(.data, var = -1, ...)

## S3 method for class 'dm_zoomed'
compute(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_table_manipulation_+3A_.data">.data</code></td>
<td>
<p>object of class <code>dm_zoomed</code></p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_...">...</code></td>
<td>
<p>see corresponding function in package <span class="pkg">dplyr</span> or <span class="pkg">tidyr</span></p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_.before">.before</code>, <code id="dplyr_table_manipulation_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_.keep_all">.keep_all</code></td>
<td>
<p>For <code>distinct.dm_zoomed()</code>: see <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code></p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_.keep_pk">.keep_pk</code></td>
<td>
<p>For <code>slice.dm_zoomed</code>: Logical, if <code>TRUE</code>, the primary key will be retained during this transformation. If <code>FALSE</code>, it will be dropped.
By default, the value is <code>NULL</code>, which causes the function to issue a message in case a primary key is available for the zoomed table.
This argument is specific for the <code>slice.dm_zoomed()</code> method.</p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_x">x</code></td>
<td>
<p>For <code>ungroup.dm_zoomed</code>: object of class <code>dm_zoomed</code></p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_.drop">.drop</code></td>
<td>
<p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</td></tr>
<tr><td><code id="dplyr_table_manipulation_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the
column you've created most recently).
</p>
<p>This argument is taken by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names and column locations).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
zoomed &lt;- dm_nycflights13() %&gt;%
  dm_zoom_to(flights) %&gt;%
  group_by(month) %&gt;%
  arrange(desc(day)) %&gt;%
  summarize(avg_air_time = mean(air_time, na.rm = TRUE))
zoomed
dm_insert_zoomed(zoomed, new_tbl_name = "avg_air_time_per_month")

</code></pre>

<hr>
<h2 id='enum_pk_candidates'>Primary key candidate</h2><span id='topic+enum_pk_candidates'></span><span id='topic+dm_enum_pk_candidates'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>enum_pk_candidates()</code> checks for each column of a
table if the column contains only unique values, and is thus
a suitable candidate for a primary key of the table.
</p>
<p><code>dm_enum_pk_candidates()</code> performs these checks
for a table in a <a href="#topic+dm">dm</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enum_pk_candidates(table, ...)

dm_enum_pk_candidates(dm, table, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enum_pk_candidates_+3A_table">table</code></td>
<td>
<p>A table in the <code>dm</code>.</p>
</td></tr>
<tr><td><code id="enum_pk_candidates_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="enum_pk_candidates_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the following columns:
</p>

<dl>
<dt><code>columns</code></dt><dd><p>columns of <code>table</code>,</p>
</dd>
<dt><code>candidate</code></dt><dd><p>boolean: are these columns a candidate for a primary key,</p>
</dd>
<dt><code>why</code></dt><dd><p>if not a candidate for a primary key column, explanation for this.</p>
</dd>
</dl>



<h3>Life cycle</h3>

<p>These functions are marked &quot;experimental&quot; because we are not yet sure about
the interface, in particular if we need both <code>dm_enum...()</code> and <code>enum...()</code>
variants.
Changing the interface later seems harmless because these functions are
most likely used interactively.
</p>


<h3>See Also</h3>

<p>Other primary key functions: 
<code><a href="#topic+dm_add_pk">dm_add_pk</a>()</code>,
<code><a href="#topic+dm_add_uk">dm_add_uk</a>()</code>,
<code><a href="#topic+dm_get_all_pks">dm_get_all_pks</a>()</code>,
<code><a href="#topic+dm_get_all_uks">dm_get_all_uks</a>()</code>,
<code><a href="#topic+dm_has_pk">dm_has_pk</a>()</code>,
<code><a href="#topic+dm_rm_pk">dm_rm_pk</a>()</code>,
<code><a href="#topic+dm_rm_uk">dm_rm_uk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nycflights13::flights %&gt;%
  enum_pk_candidates()



dm_nycflights13() %&gt;%
  dm_enum_pk_candidates(airports)

</code></pre>

<hr>
<h2 id='examine_cardinality'>Check table relations</h2><span id='topic+examine_cardinality'></span><span id='topic+check_cardinality_0_n'></span><span id='topic+check_cardinality_...'></span><span id='topic+check_cardinality_1_n'></span><span id='topic+check_cardinality_1_1'></span><span id='topic+check_cardinality_0_1'></span>

<h3>Description</h3>

<p>All <code>check_cardinality_...()</code> functions test the following conditions:
</p>

<ol>
<li><p> Are all rows in <code>x</code> unique?
</p>
</li>
<li><p> Are the rows in <code>y</code> a subset of the rows in <code>x</code>?
</p>
</li>
<li><p> Does the relation between <code>x</code> and <code>y</code> meet the cardinality requirements?
One row from <code>x</code> must correspond to the requested number of rows in <code>y</code>,
e.g. <code style="white-space: pre;">&#8288;_0_1&#8288;</code> means that there must be zero or one rows in <code>y</code> for each
row in <code>x</code>.
</p>
</li></ol>

<p><code>examine_cardinality()</code> also checks the first two points and subsequently determines the type of cardinality.
</p>
<p>For convenience, the <code>x_select</code> and <code>y_select</code> arguments allow restricting the check
to a set of key columns without affecting the return value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cardinality_0_n(
  x,
  y,
  ...,
  x_select = NULL,
  y_select = NULL,
  by_position = NULL
)

check_cardinality_1_n(
  x,
  y,
  ...,
  x_select = NULL,
  y_select = NULL,
  by_position = NULL
)

check_cardinality_1_1(
  x,
  y,
  ...,
  x_select = NULL,
  y_select = NULL,
  by_position = NULL
)

check_cardinality_0_1(
  x,
  y,
  ...,
  x_select = NULL,
  y_select = NULL,
  by_position = NULL
)

examine_cardinality(
  x,
  y,
  ...,
  x_select = NULL,
  y_select = NULL,
  by_position = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="examine_cardinality_+3A_x">x</code></td>
<td>
<p>Parent table, data frame or lazy table.</p>
</td></tr>
<tr><td><code id="examine_cardinality_+3A_y">y</code></td>
<td>
<p>Child table, data frame or lazy table.</p>
</td></tr>
<tr><td><code id="examine_cardinality_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="examine_cardinality_+3A_x_select">x_select</code>, <code id="examine_cardinality_+3A_y_select">y_select</code></td>
<td>
<p>Key columns to restrict the check, processed with
<code><a href="dplyr.html#topic+select">dplyr::select()</a></code>.</p>
</td></tr>
<tr><td><code id="examine_cardinality_+3A_by_position">by_position</code></td>
<td>
<p>Set to <code>TRUE</code> to ignore column names and match
by position instead.
The default means matching by name, use <code>x_select</code> and/or <code>y_select</code>
to align the names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All cardinality functions accept a parent and a child table (<code>x</code> and <code>y</code>).
All rows in <code>x</code> must be unique, and all rows in <code>y</code> must be a subset of the
rows in <code>x</code>.
The <code>x_select</code> and <code>y_select</code> arguments allow restricting the check
to a set of key columns without affecting the return value.
If given, both arguments must refer to the same number of key columns.
</p>
<p>The cardinality specifications &quot;0_n&quot;, &quot;1_n&quot;, &quot;0_1&quot;, &quot;1_1&quot; refer to the expected relation that the child table has with the parent table.
&quot;0&quot;, &quot;1&quot; and &quot;n&quot; refer to the occurrences of value combinations
in <code>y</code> that correspond to each combination in the
columns of the parent table.
&quot;n&quot; means &quot;more than one&quot; in this context, with no upper limit.
</p>
<p><strong>&quot;0_n&quot;</strong>: no restrictions, each row in <code>x</code> has at least 0 and at most
n corresponding occurrences in <code>y</code>.
</p>
<p><strong>&quot;1_n&quot;</strong>: each row in <code>x</code> has at least 1 and at most
n corresponding occurrences in <code>y</code>.
This means that there is a &quot;surjective&quot; mapping from the child table
to the parent table, i.e. each parent table row exists at least once in the
child table.
</p>
<p><strong>&quot;0_1&quot;</strong>: each row in <code>x</code> has at least 0 and at most
1 corresponding occurrence in <code>y</code>.
This means that there is a &quot;injective&quot; mapping from the child table
to the parent table, i.e. no combination of values in the
parent table columns is addressed multiple times.
But not all parent table rows have to be referred to.
</p>
<p><strong>&quot;1_1&quot;</strong>: each row in <code>x</code> occurs exactly once in <code>y</code>.
This means that there is a &quot;bijective&quot; (&quot;injective&quot; AND &quot;surjective&quot;) mapping
between the child table and the parent table, i.e. the
sets of rows are identical.
</p>
<p>Finally, <code>examine_cardinality()</code> tests for and returns the nature of the relationship
(injective, surjective, bijective, or none of these)
between the two given sets of columns.
If either <code>x</code> is not unique or there are rows in <code>y</code> that are missing from <code>x</code>,
the requirements for a cardinality test is not fulfilled.
No error will be thrown, but
the result will contain the information which prerequisite was violated.
</p>


<h3>Value</h3>

<p><code>check_cardinality_...()</code> return <code>x</code>, invisibly,
if the check is passed, to support pipes.
Otherwise an error is thrown and the reason for it is explained.
</p>
<p><code>examine_cardinality()</code> returns a character variable specifying the type of relationship between the two columns.
</p>


<h3>See Also</h3>

<p>Other cardinality functions: 
<code><a href="#topic+dm_examine_cardinalities">dm_examine_cardinalities</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- tibble::tibble(a = 1:5)
d2 &lt;- tibble::tibble(a = c(1:4, 4L))
d3 &lt;- tibble::tibble(c = c(1:5, 5L), d = 0)
# This does not pass, `a` is not unique key of d2:
try(check_cardinality_0_n(d2, d1))

# Columns are matched by name by default:
try(check_cardinality_0_n(d1, d3))

# This passes, multiple values in d3$c are allowed:
check_cardinality_0_n(d1, d2)

# This does not pass, injectivity is violated:
try(check_cardinality_1_1(d1, d3, y_select = c(a = c)))
try(check_cardinality_0_1(d1, d3, x_select = c(c = a)))

# What kind of cardinality is it?
examine_cardinality(d1, d3, x_select = c(c = a))
examine_cardinality(d1, d2)
</code></pre>

<hr>
<h2 id='glimpse.dm'>Get a glimpse of your <code>dm</code> object</h2><span id='topic+glimpse.dm'></span><span id='topic+glimpse.dm_zoomed'></span>

<h3>Description</h3>

<p><code>glimpse()</code> provides an overview (dimensions, column data types, primary
keys, etc.) of all tables included in the <code>dm</code> object. It will additionally
print details about outgoing foreign keys for the child table.
</p>
<p><code>glimpse()</code> is provided by the pillar package, and re-exported by <span class="pkg">dm</span>.
See <code><a href="pillar.html#topic+glimpse">pillar::glimpse()</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dm'
glimpse(x, width = NULL, ...)

## S3 method for class 'dm_zoomed'
glimpse(x, width = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glimpse.dm_+3A_x">x</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="glimpse.dm_+3A_width">width</code></td>
<td>
<p>Controls the maximum number of columns on a line used in
printing. If <code>NULL</code>, <code>getOption("width")</code> will be consulted.</p>
</td></tr>
<tr><td><code id="glimpse.dm_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="pillar.html#topic+glimpse">pillar::glimpse()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dm_nycflights13() %&gt;% glimpse()

dm_nycflights13() %&gt;%
  dm_zoom_to(flights) %&gt;%
  glimpse()

</code></pre>

<hr>
<h2 id='head.dm_zoomed'><span class="pkg">utils</span> table manipulation methods for <code>dm_zoomed</code> objects</h2><span id='topic+head.dm_zoomed'></span><span id='topic+tail.dm_zoomed'></span>

<h3>Description</h3>

<p>Extract the first or last rows from a table.
Use these methods without the '.dm_zoomed' suffix (see examples).
The methods for regular <code>dm</code> objects extract the first or last tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dm_zoomed'
head(x, n = 6L, ...)

## S3 method for class 'dm_zoomed'
tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.dm_zoomed_+3A_x">x</code></td>
<td>
<p>object of class <code>dm_zoomed</code></p>
</td></tr>
<tr><td><code id="head.dm_zoomed_+3A_n">n</code></td>
<td>
<p>an integer vector of length up to <code>dim(x)</code> (or 1,
for non-dimensioned objects).  A <code>logical</code> is silently coerced to
integer.  Values specify the indices to be
selected in the corresponding dimension (or along the length) of the
object. A positive value of <code>n[i]</code> includes the first/last
<code>n[i]</code> indices in that dimension, while a negative value
excludes the last/first <code>abs(n[i])</code>, including all remaining
indices. <code>NA</code> or non-specified values (when <code>length(n) &lt;
      length(dim(x))</code>) select all indices in that dimension. Must
contain at least one non-missing value.</p>
</td></tr>
<tr><td><code id="head.dm_zoomed_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see manual for the corresponding functions in <span class="pkg">utils</span>.
</p>


<h3>Value</h3>

<p>A <code>dm_zoomed</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zoomed &lt;- dm_nycflights13() %&gt;%
  dm_zoom_to(flights) %&gt;%
  head(4)
zoomed
dm_insert_zoomed(zoomed, new_tbl_name = "head_flights")

</code></pre>

<hr>
<h2 id='json_nest'>JSON nest</h2><span id='topic+json_nest'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>A wrapper around <code><a href="tidyr.html#topic+nest">tidyr::nest()</a></code> which stores the nested data into JSON columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_nest(.data, ..., .names_sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_nest_+3A_.data">.data</code></td>
<td>
<p>A data frame, a data frame extension (e.g. a tibble), or  a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="json_nest_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pack, specified
using name-variable pairs of the form <code>new_col = c(col1, col2, col3)</code>.
The right hand side can be any valid tidy select expression.</p>
</td></tr>
<tr><td><code id="json_nest_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left as is.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+nest">tidyr::nest()</a></code>, <code><a href="#topic+json_nest_join">json_nest_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
nested &lt;- json_nest(df, data = c(y, z))
nested
</code></pre>

<hr>
<h2 id='json_nest_join'>JSON nest join</h2><span id='topic+json_nest_join'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>A wrapper around <code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code> which stores the joined data into a JSON column.
<code>json_nest_join()</code> returns all rows and columns in <code>x</code> with a new JSON columns that contains all nested matches from <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_nest_join(x, y, by = NULL, ..., copy = FALSE, keep = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_nest_join_+3A_x">x</code>, <code id="json_nest_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="json_nest_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="json_nest_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="json_nest_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="json_nest_join_+3A_keep">keep</code></td>
<td>
<p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</td></tr>
<tr><td><code id="json_nest_join_+3A_name">name</code></td>
<td>
<p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code>, <code><a href="#topic+json_pack_join">json_pack_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble::tibble(x = 1:3)
df2 &lt;- tibble::tibble(x = c(1, 1, 2), y = c("first", "second", "third"))
df3 &lt;- json_nest_join(df1, df2)
df3
df3$df2
</code></pre>

<hr>
<h2 id='json_pack'>JSON pack</h2><span id='topic+json_pack'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>A wrapper around <code><a href="tidyr.html#topic+pack">tidyr::pack()</a></code> which stores the packed data into JSON columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_pack(.data, ..., .names_sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_pack_+3A_.data">.data</code></td>
<td>
<p>A data frame, a data frame extension (e.g. a tibble), or  a lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="json_pack_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pack, specified
using name-variable pairs of the form <code>new_col = c(col1, col2, col3)</code>.
The right hand side can be any valid tidy select expression.</p>
</td></tr>
<tr><td><code id="json_pack_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left as is.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+pack">tidyr::pack()</a></code>, <code><a href="#topic+json_pack_join">json_pack_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(x1 = 1:3, x2 = 4:6, x3 = 7:9, y = 1:3)
packed &lt;- json_pack(df, x = c(x1, x2, x3), y = y)
packed
</code></pre>

<hr>
<h2 id='json_pack_join'>JSON pack join</h2><span id='topic+json_pack_join'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>A wrapper around <code><a href="#topic+pack_join">pack_join()</a></code> which stores the joined data into a JSON column.
<code>json_pack_join()</code> returns all rows and columns in <code>x</code> with a new JSON columns that contains all packed matches from <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_pack_join(x, y, by = NULL, ..., copy = FALSE, keep = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_pack_join_+3A_x">x</code>, <code id="json_pack_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="json_pack_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="json_pack_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="json_pack_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="json_pack_join_+3A_keep">keep</code></td>
<td>
<p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</td></tr>
<tr><td><code id="json_pack_join_+3A_name">name</code></td>
<td>
<p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pack_join">pack_join()</a></code>, <code><a href="#topic+json_nest_join">json_nest_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble::tibble(x = 1:3)
df2 &lt;- tibble::tibble(x = c(1, 1, 2), y = c("first", "second", "third"))
df3 &lt;- json_pack_join(df1, df2)
df3
df3$df2
</code></pre>

<hr>
<h2 id='json_unnest'>Unnest a JSON column</h2><span id='topic+json_unnest'></span>

<h3>Description</h3>

<p>A wrapper around <code><a href="tidyr.html#topic+unnest">tidyr::unnest()</a></code> that extracts its data from a JSON column.
The inverse of <code><a href="#topic+json_nest">json_nest()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_unnest(data, cols, ..., names_sep = NULL, names_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_unnest_+3A_data">data</code></td>
<td>
<p>A data frame, a data frame extension (e.g. a tibble), or  a lazy
data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="json_unnest_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; List-columns to unnest.
</p>
<p>When selecting multiple columns, values from the same row will be recycled
to their common size.</p>
</td></tr>
<tr><td><code id="json_unnest_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="json_unnest_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the outer names will come from the
inner names. If a string, the outer names will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>.</p>
</td></tr>
<tr><td><code id="json_unnest_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tibble(a = 1, b = '[{ "c": 2 }, { "c": 3 }]') %&gt;%
  json_unnest(b)
</code></pre>

<hr>
<h2 id='json_unpack'>Unpack a JSON column</h2><span id='topic+json_unpack'></span>

<h3>Description</h3>

<p>A wrapper around <code><a href="tidyr.html#topic+pack">tidyr::unpack()</a></code> that extracts its data from a JSON column.
The inverse of <code><a href="#topic+json_pack">json_pack()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_unpack(data, cols, ..., names_sep = NULL, names_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_unpack_+3A_data">data</code></td>
<td>
<p>A data frame, a data frame extension (e.g. a tibble), or  a lazy
data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="json_unpack_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unpack.</p>
</td></tr>
<tr><td><code id="json_unpack_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="json_unpack_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left
as is. In <code>pack()</code>, inner names will come from the former outer names;
in <code>unpack()</code>, the new outer names will come from the inner names.
</p>
<p>If a string, the inner and outer names will be used together. In
<code>unpack()</code>, the names of the new outer columns will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>. In
<code>pack()</code>, the new inner names will have the outer names + <code>names_sep</code>
automatically stripped. This makes <code>names_sep</code> roughly symmetric between
packing and unpacking.</p>
</td></tr>
<tr><td><code id="json_unpack_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;"minimal&#8288;</code>&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"unique&#8288;</code>&quot;: make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"check_unique&#8288;</code>&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal&#8288;</code>&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tibble(a = 1, b = '{ "c": 2, "d": 3 }') %&gt;%
  json_unpack(b)
</code></pre>

<hr>
<h2 id='materialize'>Materialize</h2><span id='topic+materialize'></span><span id='topic+compute.dm'></span><span id='topic+collect.dm'></span>

<h3>Description</h3>

<p><code>compute()</code> materializes all tables in a <code>dm</code> to new temporary
tables on the database.
</p>
<p><code>collect()</code> downloads the tables in a <code>dm</code> object as local <a href="#topic+tibble">tibble</a>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dm'
compute(x, ..., temporary = TRUE)

## S3 method for class 'dm'
collect(x, ..., progress = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materialize_+3A_x">x</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="materialize_+3A_...">...</code></td>
<td>
<p>Passed on to <code><a href="#topic+compute">compute()</a></code>.</p>
</td></tr>
<tr><td><code id="materialize_+3A_temporary">temporary</code></td>
<td>
<p>Must remain <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="materialize_+3A_progress">progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called on a <code>dm</code> object, these methods create a copy of all tables in the <code>dm</code>.
Depending on the size of your data this may take a long time.
</p>
<p>To create permament tables, first create the database schema using <code><a href="#topic+copy_dm_to">copy_dm_to()</a></code>
or <code><a href="#topic+dm_sql">dm_sql()</a></code>, and then use <code><a href="#topic+dm_rows_append">dm_rows_append()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>dm</code> object of the same structure as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
financial &lt;- dm_financial_sqlite()

financial %&gt;%
  pull_tbl(districts) %&gt;%
  dbplyr::remote_name()

# compute() copies the data to new tables:
financial %&gt;%
  compute() %&gt;%
  pull_tbl(districts) %&gt;%
  dbplyr::remote_name()

# collect() returns a local dm:
financial %&gt;%
  collect() %&gt;%
  pull_tbl(districts) %&gt;%
  class()

</code></pre>

<hr>
<h2 id='pack_join'>Pack Join</h2><span id='topic+pack_join'></span><span id='topic+pack_join.dm_zoomed'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>pack_join()</code> returns all rows and columns in <code>x</code> with a new packed column
that contains all matches from <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack_join(x, y, by = NULL, ..., copy = FALSE, keep = FALSE, name = NULL)

## S3 method for class 'dm_zoomed'
pack_join(x, y, by = NULL, ..., copy = FALSE, keep = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_join_+3A_x">x</code>, <code id="pack_join_+3A_y">y</code></td>
<td>
<p>A pair of data frames or data frame extensions (e.g. a tibble).</p>
</td></tr>
<tr><td><code id="pack_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="pack_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="pack_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="pack_join_+3A_keep">keep</code></td>
<td>
<p>Should the new list-column contain join keys? The default
will preserve the join keys for inequality joins.</p>
</td></tr>
<tr><td><code id="pack_join_+3A_name">name</code></td>
<td>
<p>The name of the list-column created by the join. If <code>NULL</code>,
the default, the name of <code>y</code> is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code>, <code><a href="tidyr.html#topic+pack">tidyr::pack()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tibble::tibble(x = 1:3)
df2 &lt;- tibble::tibble(x = c(1, 1, 2), y = c("first", "second", "third"))
pack_join(df1, df2)
</code></pre>

<hr>
<h2 id='pull_tbl'>Retrieve a table</h2><span id='topic+pull_tbl'></span>

<h3>Description</h3>

<p>This generic has methods for both <code>dm</code> classes:
</p>

<ol>
<li><p> With <code>pull_tbl.dm()</code> you can chose which table of the <code>dm</code> you want to retrieve.
</p>
</li>
<li><p> With <code>pull_tbl.dm_zoomed()</code> you will retrieve the zoomed table in the current state.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>pull_tbl(dm, table, ..., keyed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_tbl_+3A_dm">dm</code></td>
<td>
<p>A <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="pull_tbl_+3A_table">table</code></td>
<td>
<p>One unquoted table name for <code>pull_tbl.dm()</code>, ignored for <code>pull_tbl.dm_zoomed()</code>.</p>
</td></tr>
<tr><td><code id="pull_tbl_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="pull_tbl_+3A_keyed">keyed</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Set to <code>TRUE</code> to return objects of the internal class <code>"dm_keyed_tbl"</code>
that will contain information on primary and foreign keys
in the individual table objects.
This allows using dplyr workflows on those tables and later reconstruct them
into a <code>dm</code> object.
See <code><a href="#topic+dm_deconstruct">dm_deconstruct()</a></code> for a function that generates corresponding code
for an existing dm object, and <code>vignette("tech-dm-keyed")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The requested table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dm_deconstruct">dm_deconstruct()</a></code> to generate code of the form
<code>pull_tbl(..., keyed = TRUE)</code> from an existing <code>dm</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For an unzoomed dm you need to specify the table to pull:
dm_nycflights13() %&gt;%
  pull_tbl(airports)

# If zoomed, pulling detaches the zoomed table from the dm:
dm_nycflights13() %&gt;%
  dm_zoom_to(airports) %&gt;%
  pull_tbl()

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+filter'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+summarise'></span><span id='topic+summarize'></span><span id='topic+select'></span><span id='topic+rename'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+left_join'></span><span id='topic+inner_join'></span><span id='topic+full_join'></span><span id='topic+semi_join'></span><span id='topic+anti_join'></span><span id='topic+right_join'></span><span id='topic+collect'></span><span id='topic+compute'></span><span id='topic+copy_to'></span><span id='topic+src_tbls'></span><span id='topic+tbl'></span><span id='topic+arrange'></span><span id='topic+rows_insert'></span><span id='topic+rows_append'></span><span id='topic+rows_update'></span><span id='topic+rows_patch'></span><span id='topic+rows_upsert'></span><span id='topic+rows_delete'></span><span id='topic+glimpse'></span><span id='topic+tibble'></span><span id='topic+unite'></span><span id='topic+separate'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+filter-joins">anti_join</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+compute">collect</a></code>, <code><a href="dplyr.html#topic+compute">compute</a></code>, <code><a href="dplyr.html#topic+copy_to">copy_to</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+rename">rename</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+rows">rows_append</a></code>, <code><a href="dplyr.html#topic+rows">rows_delete</a></code>, <code><a href="dplyr.html#topic+rows">rows_insert</a></code>, <code><a href="dplyr.html#topic+rows">rows_patch</a></code>, <code><a href="dplyr.html#topic+rows">rows_update</a></code>, <code><a href="dplyr.html#topic+rows">rows_upsert</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+filter-joins">semi_join</a></code>, <code><a href="dplyr.html#topic+src_tbls">src_tbls</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code>, <code><a href="dplyr.html#topic+summarise">summarize</a></code>, <code><a href="dplyr.html#topic+tbl">tbl</a></code>, <code><a href="dplyr.html#topic+transmute">transmute</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+reexports">glimpse</a></code>, <code><a href="tibble.html#topic+tibble">tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+separate">separate</a></code>, <code><a href="tidyr.html#topic+unite">unite</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reunite_parent_child'>Merge two tables that are linked by a foreign key relation</h2><span id='topic+reunite_parent_child'></span><span id='topic+reunite_parent_child_from_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Perform table fusion by combining two tables by a common (key) column, and then removing this column.
</p>
<p><code>reunite_parent_child()</code>: After joining the two tables by the column <code>id_column</code>, this column will be removed.
The transformation is roughly the
inverse of what <code>decompose_table()</code> does.
</p>
<p><code>reunite_parent_child_from_list()</code>: After joining the two tables
by the column <code>id_column</code>, <code>id_column</code> is removed.
</p>
<p>This function is almost exactly the inverse of <code>decompose_table()</code> (the order
of the columns is not retained, and the original row names are lost).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reunite_parent_child(child_table, parent_table, id_column)

reunite_parent_child_from_list(list_of_parent_child_tables, id_column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reunite_parent_child_+3A_child_table">child_table</code></td>
<td>
<p>Table (possibly created by <code>decompose_table()</code>) that references <code>parent_table</code></p>
</td></tr>
<tr><td><code id="reunite_parent_child_+3A_parent_table">parent_table</code></td>
<td>
<p>Table (possibly created by <code>decompose_table()</code>).</p>
</td></tr>
<tr><td><code id="reunite_parent_child_+3A_id_column">id_column</code></td>
<td>
<p>Identical name of referencing / referenced column in <code>child_table</code>/<code>parent_table</code>.</p>
</td></tr>
<tr><td><code id="reunite_parent_child_+3A_list_of_parent_child_tables">list_of_parent_child_tables</code></td>
<td>
<p>Cf arguments <code>child_table</code> and <code>parent_table</code> from
<code>reunite_parent_child()</code>, but both in a named list (as created by <code>decompose_table()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wide table produced by joining the two given tables.
</p>


<h3>Life cycle</h3>

<p>These functions are marked &quot;experimental&quot; because they seem more useful
when applied to a table in a dm object.
Changing the interface later seems harmless because these functions are
most likely used interactively.
</p>


<h3>See Also</h3>

<p>Other table surgery functions: 
<code><a href="#topic+decompose_table">decompose_table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomposed_table &lt;- decompose_table(mtcars, new_id, am, gear, carb)
ct &lt;- decomposed_table$child_table
pt &lt;- decomposed_table$parent_table

reunite_parent_child(ct, pt, new_id)
reunite_parent_child_from_list(decomposed_table, new_id)
</code></pre>

<hr>
<h2 id='rows-dm'>Modifying rows for multiple tables</h2><span id='topic+rows-dm'></span><span id='topic+dm_rows_insert'></span><span id='topic+dm_rows_...'></span><span id='topic+dm_rows_append'></span><span id='topic+dm_rows_update'></span><span id='topic+dm_rows_patch'></span><span id='topic+dm_rows_upsert'></span><span id='topic+dm_rows_delete'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>These functions provide a framework for updating data in existing tables.
Unlike <code><a href="#topic+compute">compute()</a></code>, <code><a href="#topic+copy_to">copy_to()</a></code> or <code><a href="#topic+copy_dm_to">copy_dm_to()</a></code>, no new tables are created
on the database.
All operations expect that both existing and new data are presented
in two compatible <a href="#topic+dm">dm</a> objects on the same data source.
</p>
<p>The functions make sure that the tables in the target dm
are processed in topological order so that parent (dimension)
tables receive insertions before child (fact) tables.
</p>
<p>These operations, in contrast to all other operations,
may lead to irreversible changes to the underlying database.
Therefore, in-place operation must be requested explicitly with <code>in_place = TRUE</code>.
By default, an informative message is given.
</p>
<p><code>dm_rows_insert()</code> adds new records via <code><a href="#topic+rows_insert">rows_insert()</a></code> with <code>conflict = "ignore"</code>.
Duplicate records will be silently discarded.
This operation requires primary keys on all tables, use <code>dm_rows_append()</code>
to insert unconditionally.
</p>
<p><code>dm_rows_append()</code> adds new records via <code><a href="#topic+rows_append">rows_append()</a></code>.
The primary keys must differ from existing records.
This must be ensured by the caller and might be checked by the underlying database.
Use <code>in_place = FALSE</code> and apply <code><a href="#topic+dm_examine_constraints">dm_examine_constraints()</a></code> to check beforehand.
</p>
<p><code>dm_rows_update()</code> updates existing records via <code><a href="#topic+rows_update">rows_update()</a></code>.
Primary keys must match for all records to be updated.
</p>
<p><code>dm_rows_patch()</code> updates missing values in existing records
via <code><a href="#topic+rows_patch">rows_patch()</a></code>.
Primary keys must match for all records to be patched.
</p>
<p><code>dm_rows_upsert()</code> updates existing records and adds new records,
based on the primary key, via <code><a href="#topic+rows_upsert">rows_upsert()</a></code>.
</p>
<p><code>dm_rows_delete()</code> removes matching records via <code><a href="#topic+rows_delete">rows_delete()</a></code>,
based on the primary key.
The order in which the tables are processed is reversed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dm_rows_insert(x, y, ..., in_place = NULL, progress = NA)

dm_rows_append(x, y, ..., in_place = NULL, progress = NA)

dm_rows_update(x, y, ..., in_place = NULL, progress = NA)

dm_rows_patch(x, y, ..., in_place = NULL, progress = NA)

dm_rows_upsert(x, y, ..., in_place = NULL, progress = NA)

dm_rows_delete(x, y, ..., in_place = NULL, progress = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rows-dm_+3A_x">x</code></td>
<td>
<p>Target <code>dm</code> object.</p>
</td></tr>
<tr><td><code id="rows-dm_+3A_y">y</code></td>
<td>
<p><code>dm</code> object with new data.</p>
</td></tr>
<tr><td><code id="rows-dm_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="rows-dm_+3A_in_place">in_place</code></td>
<td>
<p>Should <code>x</code> be modified in place? This argument is only
relevant for mutable backends (e.g. databases, data.tables).
</p>
<p>When <code>TRUE</code>, a modified version of <code>x</code> is returned invisibly;
when <code>FALSE</code>, a new object representing the resulting changes is returned.</p>
</td></tr>
<tr><td><code id="rows-dm_+3A_progress">progress</code></td>
<td>
<p>Whether to display a progress bar, if <code>NA</code> (the default)
hide in non-interactive mode, show in interactive mode. Requires the
'progress' package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dm object of the same <code><a href="#topic+dm_ptype">dm_ptype()</a></code> as <code>x</code>.
If <code>in_place = TRUE</code>, the underlying data is updated as a side effect,
and <code>x</code> is returned, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Establish database connection:
sqlite &lt;- DBI::dbConnect(RSQLite::SQLite())

# Entire dataset with all dimension tables populated
# with flights and weather data truncated:
flights_init &lt;-
  dm_nycflights13() %&gt;%
  dm_zoom_to(flights) %&gt;%
  filter(FALSE) %&gt;%
  dm_update_zoomed() %&gt;%
  dm_zoom_to(weather) %&gt;%
  filter(FALSE) %&gt;%
  dm_update_zoomed()

# Target database:
flights_sqlite &lt;- copy_dm_to(sqlite, flights_init, temporary = FALSE)
print(dm_nrow(flights_sqlite))

# First update:
flights_jan &lt;-
  dm_nycflights13() %&gt;%
  dm_select_tbl(flights, weather) %&gt;%
  dm_zoom_to(flights) %&gt;%
  filter(month == 1) %&gt;%
  dm_update_zoomed() %&gt;%
  dm_zoom_to(weather) %&gt;%
  filter(month == 1) %&gt;%
  dm_update_zoomed()
print(dm_nrow(flights_jan))

# Copy to temporary tables on the target database:
flights_jan_sqlite &lt;- copy_dm_to(sqlite, flights_jan)

# Dry run by default:
dm_rows_append(flights_sqlite, flights_jan_sqlite)
print(dm_nrow(flights_sqlite))

# Explicitly request persistence:
dm_rows_append(flights_sqlite, flights_jan_sqlite, in_place = TRUE)
print(dm_nrow(flights_sqlite))

# Second update:
flights_feb &lt;-
  dm_nycflights13() %&gt;%
  dm_select_tbl(flights, weather) %&gt;%
  dm_zoom_to(flights) %&gt;%
  filter(month == 2) %&gt;%
  dm_update_zoomed() %&gt;%
  dm_zoom_to(weather) %&gt;%
  filter(month == 2) %&gt;%
  dm_update_zoomed()

# Copy to temporary tables on the target database:
flights_feb_sqlite &lt;- copy_dm_to(sqlite, flights_feb)

# Explicit dry run:
flights_new &lt;- dm_rows_append(
  flights_sqlite,
  flights_feb_sqlite,
  in_place = FALSE
)
print(dm_nrow(flights_new))
print(dm_nrow(flights_sqlite))

# Check for consistency before applying:
flights_new %&gt;%
  dm_examine_constraints()

# Apply:
dm_rows_append(flights_sqlite, flights_feb_sqlite, in_place = TRUE)
print(dm_nrow(flights_sqlite))

DBI::dbDisconnect(sqlite)

</code></pre>

<hr>
<h2 id='tidyr_table_manipulation'><span class="pkg">tidyr</span> table manipulation methods for zoomed dm objects</h2><span id='topic+tidyr_table_manipulation'></span><span id='topic+unite.dm_zoomed'></span><span id='topic+unite.dm_keyed_tbl'></span><span id='topic+separate.dm_zoomed'></span><span id='topic+separate.dm_keyed_tbl'></span>

<h3>Description</h3>

<p>Use these methods without the '.dm_zoomed' suffix (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dm_zoomed'
unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)

## S3 method for class 'dm_keyed_tbl'
unite(data, ...)

## S3 method for class 'dm_zoomed'
separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE, ...)

## S3 method for class 'dm_keyed_tbl'
separate(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyr_table_manipulation_+3A_data">data</code></td>
<td>
<p>object of class <code>dm_zoomed</code></p>
</td></tr>
<tr><td><code id="tidyr_table_manipulation_+3A_col">col</code></td>
<td>
<p>For <code>unite.dm_zoomed</code>: see <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>
</p>
<p>For <code>separate.dm_zoomed</code>: see <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code></p>
</td></tr>
<tr><td><code id="tidyr_table_manipulation_+3A_...">...</code></td>
<td>
<p>For <code>unite.dm_zoomed</code>: see <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>
</p>
<p>For <code>separate.dm_zoomed</code>: see <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code></p>
</td></tr>
<tr><td><code id="tidyr_table_manipulation_+3A_sep">sep</code></td>
<td>
<p>For <code>unite.dm_zoomed</code>: see <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>
</p>
<p>For <code>separate.dm_zoomed</code>: see <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code></p>
</td></tr>
<tr><td><code id="tidyr_table_manipulation_+3A_remove">remove</code></td>
<td>
<p>For <code>unite.dm_zoomed</code>: see <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>
</p>
<p>For <code>separate.dm_zoomed</code>: see <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code></p>
</td></tr>
<tr><td><code id="tidyr_table_manipulation_+3A_na.rm">na.rm</code></td>
<td>
<p>see <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code></p>
</td></tr>
<tr><td><code id="tidyr_table_manipulation_+3A_into">into</code></td>
<td>
<p>see <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
zoom_united &lt;- dm_nycflights13() %&gt;%
  dm_zoom_to(flights) %&gt;%
  select(year, month, day) %&gt;%
  unite("month_day", month, day)
zoom_united
zoom_united %&gt;%
  separate(month_day, c("month", "day"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
