<!DOCTYPE html><html><head><title>Help for package NMMIPW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMMIPW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#link_func'><p>This function computes our link function that respects the positivity</p></a></li>
<li><a href='#link_func_grad'><p>This function computes the gradient of our link function that respects the positivity</p></a></li>
<li><a href='#link_func_grad_vec'><p>This function vectorizes link_func_grad</p></a></li>
<li><a href='#link_func_vec'><p>This function vectorizes link_func</p></a></li>
<li><a href='#nmm_fit'><p>Fitting IPW or AIPW Estimators under Nonmonotone Missing at Random Data</p></a></li>
<li><a href='#nmm_preprocessing'><p>This function prepares the user-provided data into the correct format</p></a></li>
<li><a href='#prop_compute'><p>This function computes propensities of entries being fully observed</p></a></li>
<li><a href='#PS'><p>This function prepares necessary list of information for fitting IPW or AIPW</p></a></li>
<li><a href='#regress_fit'><p>This function returns the residuls after fiting a func regression, where func is the user-specified function</p></a></li>
<li><a href='#summary.NMMIPW'><p>Summarizing IPW or AIPW Estimators under Nonmonotone Missing at Random Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inverse Probability Weighting under Non-Monotone Missing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Ying &lt;aying9339@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We fit inverse probability weighting estimator and the augmented inverse probability weighting for non-monotone missing at random data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), lava, nloptr, numDeriv</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-19 06:19:54 UTC; andrewying</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Ying [aut, cre],
  Baoluo Sun [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-20 15:42:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='link_func'>This function computes our link function that respects the positivity</h2><span id='topic+link_func'></span>

<h3>Description</h3>

<p>This function computes our link function that respects the positivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_func(x, sigma_star)
</code></pre>


<h3>Value</h3>

<p>returns results our link function
</p>

<hr>
<h2 id='link_func_grad'>This function computes the gradient of our link function that respects the positivity</h2><span id='topic+link_func_grad'></span>

<h3>Description</h3>

<p>This function computes the gradient of our link function that respects the positivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_func_grad(x, sigma_star)
</code></pre>


<h3>Value</h3>

<p>returns the gradient of our link function
</p>

<hr>
<h2 id='link_func_grad_vec'>This function vectorizes link_func_grad</h2><span id='topic+link_func_grad_vec'></span>

<h3>Description</h3>

<p>This function vectorizes link_func_grad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_func_grad_vec(x, sigma_star)
</code></pre>


<h3>Value</h3>

<p>returns a vector of link_func_grad results
</p>

<hr>
<h2 id='link_func_vec'>This function vectorizes link_func</h2><span id='topic+link_func_vec'></span>

<h3>Description</h3>

<p>This function vectorizes link_func
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_func_vec(x, sigma_star)
</code></pre>


<h3>Value</h3>

<p>returns a vector of link_func results
</p>

<hr>
<h2 id='nmm_fit'>Fitting IPW or AIPW Estimators under Nonmonotone Missing at Random Data</h2><span id='topic+nmm_fit'></span>

<h3>Description</h3>

<p>nmm_fit is the main function used to fit IPW or AIPW estimators under nonmonotone missing at random data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmm_fit(
  data,
  O,
  AIPW = FALSE,
  formula = NULL,
  func = NULL,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmm_fit_+3A_data">data</code></td>
<td>
<p>a data.frame to fit</p>
</td></tr>
<tr><td><code id="nmm_fit_+3A_o">O</code></td>
<td>
<p>missing indicator</p>
</td></tr>
<tr><td><code id="nmm_fit_+3A_aipw">AIPW</code></td>
<td>
<p>indicator if fitting augmented IPW</p>
</td></tr>
<tr><td><code id="nmm_fit_+3A_formula">formula</code></td>
<td>
<p>optional formula specified to fit</p>
</td></tr>
<tr><td><code id="nmm_fit_+3A_func">func</code></td>
<td>
<p>optional fitting function, currently support 'lm' and 'glm'</p>
</td></tr>
<tr><td><code id="nmm_fit_+3A_weights">weights</code></td>
<td>
<p>optional weights used in the estimation</p>
</td></tr>
<tr><td><code id="nmm_fit_+3A_...">...</code></td>
<td>
<p>further arguments passed to func, e.g. family = 'quasibinomial' for glm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NMMIPW returns an object of class &quot;NMMIPW&quot;.
An object of class &quot;NMMIPW&quot; is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the fitted values, only reported when formula and func are given</p>
</td></tr>
<tr><td><code>coef_sd</code></td>
<td>
<p>the standard deviations of coefficients, only reported when formula and func are given</p>
</td></tr>
<tr><td><code>coef_IF</code></td>
<td>
<p>the influnece function of coefficients, only reported when formula and func are given</p>
</td></tr>
<tr><td><code>gamma_para</code></td>
<td>
<p>the first step fitted valus</p>
</td></tr>
<tr><td><code>AIPW</code></td>
<td>
<p>an indicator of whether AIPW is fitted</p>
</td></tr>
<tr><td><code>second_step</code></td>
<td>
<p>an indicator of whether the second step is fitted</p>
</td></tr>
<tr><td><code>second_fit</code></td>
<td>
<p>if second step fitted, we report the fit object</p>
</td></tr>
<tr><td><code>by_prod</code></td>
<td>
<p>a list of by products that might be useful for users, including first step IF, jacobian matrices</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
X = rnorm(n, 0, 1)
Y = rnorm(n, 1 * X, 1)
O1 = rbinom(n, 1, 1/(1 + exp(- 1 - 0.5 * X)))
O2 = rbinom(n, 1, 1/(1 + exp(+ 0.5 + 1 * Y)))
O = cbind(O1, O2)
df &lt;- data.frame(Y = Y, X = X)
fit &lt;- nmm_fit(data = df, O = O, formula = Y ~ X, func = lm)
</code></pre>

<hr>
<h2 id='nmm_preprocessing'>This function prepares the user-provided data into the correct format</h2><span id='topic+nmm_preprocessing'></span>

<h3>Description</h3>

<p>This function prepares the user-provided data into the correct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmm_preprocessing(data, O)
</code></pre>


<h3>Value</h3>

<p>returns a list containing the following components:
</p>
<table>
<tr><td><code>R</code></td>
<td>
<p>the indicator of the missing pattern, where R = 1 is reserved for fully observed</p>
</td></tr>
<tr><td><code>pattern</code></td>
<td>
<p>a matrix recording the pattern</p>
</td></tr>
</table>

<hr>
<h2 id='prop_compute'>This function computes propensities of entries being fully observed</h2><span id='topic+prop_compute'></span>

<h3>Description</h3>

<p>This function computes propensities of entries being fully observed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_compute(para, work_df, R, selection, sigma_star, pattern)
</code></pre>


<h3>Value</h3>

<p>returns propensities of being fully observed
</p>

<hr>
<h2 id='PS'>This function prepares necessary list of information for fitting IPW or AIPW</h2><span id='topic+PS'></span>

<h3>Description</h3>

<p>This function prepares necessary list of information for fitting IPW or AIPW
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PS(data, R, pattern)
</code></pre>


<h3>Value</h3>

<p>returns a list containing the following components:
</p>
<table>
<tr><td><code>gamma_para</code></td>
<td>
<p>the fitted values for the first stage regression</p>
</td></tr>
<tr><td><code>gamma_IF</code></td>
<td>
<p>the influence functions of the fitted values for the first stage regression</p>
</td></tr>
<tr><td><code>sigma_star</code></td>
<td>
<p>the positivity parameter used in the link function</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>the propensities of fully observed for each R = 1 subject</p>
</td></tr>
</table>

<hr>
<h2 id='regress_fit'>This function returns the residuls after fiting a func regression, where func is the user-specified function</h2><span id='topic+regress_fit'></span>

<h3>Description</h3>

<p>This function returns the residuls after fiting a func regression, where func is the user-specified function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regress_fit(
  coefficients,
  regress_func,
  formula,
  data,
  weights,
  R,
  sigma_star,
  pattern,
  ...
)
</code></pre>


<h3>Value</h3>

<p>returns the residuals of the regression by the user-specified function
</p>

<hr>
<h2 id='summary.NMMIPW'>Summarizing IPW or AIPW Estimators under Nonmonotone Missing at Random Data</h2><span id='topic+summary.NMMIPW'></span><span id='topic+print.summary.NMMIPW'></span>

<h3>Description</h3>

<p>summary method for class &quot;NMMIPW&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMMIPW'
summary(object, ...)

## S3 method for class 'summary.NMMIPW'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NMMIPW_+3A_object">object</code></td>
<td>
<p>an object of class &quot;NMMIPW&quot;, usually, a result of a call to NMMIPW.</p>
</td></tr>
<tr><td><code id="summary.NMMIPW_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.NMMIPW_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.NMMIPW&quot;, usually, a result of a call to summary.NMMIPW.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>print.summary.NMMIPW tries to be smart about formatting coefficients, an estimated variance covariance matrix of
the coefficients, Z-values and the corresponding P-values.
</p>


<h3>Value</h3>

<p>The function summary.NMMIPW computes and returns a list of summary statistics of the fitted model given in object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
X = rnorm(n, 0, 1)
Y = rnorm(n, 1 * X, 1)
O1 = rbinom(n, 1, 1/(1 + exp(-1 - 0.5 * X)))
O2 = rbinom(n, 1, 1/(1 + exp(+0.5 + 1 * Y)))
O = cbind(O1, O2)
df &lt;- data.frame(Y = Y, X = X)
fit &lt;- nmm_fit(data = df, O = O, formula = Y ~ X, funct = lm)
summary(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
