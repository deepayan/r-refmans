<!DOCTYPE html><html><head><title>Help for package icmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#get.ab'><p>Hyperparameter estimation for <code>a</code> and <code>b</code>.</p></a></li>
<li><a href='#get.alpha'><p>Hyperparameter estimation for <code>alpha</code>.</p></a></li>
<li><a href='#get.beta'><p>Obtain model coefficient without assuming prior on structure of predictors.</p></a></li>
<li><a href='#get.beta.ising'><p>Obtain a regression coefficient when assuming Ising prior (with structured predictors).</p></a></li>
<li><a href='#get.pseudodata.binomial'><p>Obtain pseudodata based on the binary logistic regression model.</p></a></li>
<li><a href='#get.pseudodata.cox'><p>Obtain pseudodata based on the Cox's regression model.</p></a></li>
<li><a href='#get.sigma'><p>Standard deviation estimation.</p></a></li>
<li><a href='#get.wpost'><p>Estimate posterior probability of mixing weight.</p></a></li>
<li><a href='#get.wprior'><p>Mixing weight estimation.</p></a></li>
<li><a href='#get.zeta'><p>Local posterior probability estimation</p></a></li>
<li><a href='#get.zeta.ising'><p>Local posterior probability estimation.</p></a></li>
<li><a href='#icmm'><p>Empirical Bayes Variable Selection</p></a></li>
<li><a href='#icmm-package'><p>Empirical Bayes Variable Selection via ICM/M</p></a></li>
<li><a href='#initbetaBinomial'><p>Initial values for the regression coefficients used in example for running ICM/M algorithm in binary logistic model</p></a></li>
<li><a href='#initbetaCox'><p>Initial values for the regression coefficients used in example for running ICM/M algorithm in Cox's model</p></a></li>
<li><a href='#initbetaGaussian'><p>Initial values for the regression coefficients used in example for running ICM/M algorithm in normal linear regression  model</p></a></li>
<li><a href='#linearrelation'><p>Linear structure of predictors</p></a></li>
<li><a href='#simBinomial'><p>Simulated data from the binary logistic regression model</p></a></li>
<li><a href='#simCox'><p>Simulated data from Cox's regression model</p></a></li>
<li><a href='#simGaussian'><p>Simulated data from the normal linear regression model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Empirical Bayes Variable Selection via ICM/M Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Vitara Pungpapong [aut, cre],
  Min Zhang [ctb],
  Dabao Zhang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vitara Pungpapong &lt;vitara@cbs.chula.ac.th&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Empirical Bayes variable selection via ICM/M algorithm for normal, binary logistic, and Cox's regression. The basic problem is to fit high-dimensional regression which sparse coefficients. This package allows incorporating the Ising prior to capture structure of predictors in the modeling process. More information can be found in the papers listed in the URL below.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.researchgate.net/publication/279279744_Selecting_massive_variables_using_an_iterated_conditional_modesmedians_algorithm">https://www.researchgate.net/publication/279279744_Selecting_massive_variables_using_an_iterated_conditional_modesmedians_algorithm</a>,
<a href="https://doi.org/10.1089/cmb.2019.0319">https://doi.org/10.1089/cmb.2019.0319</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>EbayesThresh</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-26 04:52:07 UTC; vpungpap</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-26 05:20:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='get.ab'>Hyperparameter estimation for <code>a</code> and <code>b</code>.</h2><span id='topic+get.ab'></span>

<h3>Description</h3>

<p>This function estimates the hyperparameters <code>a</code> and <code>b</code> for the Ising prior. This function is for internal use called by the <code>icmm</code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.ab(beta, structure, edgeind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.ab_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.ab_+3A_structure">structure</code></td>
<td>
<p>a data frame stores the information of structure among predictors.</p>
</td></tr>
<tr><td><code id="get.ab_+3A_edgeind">edgeind</code></td>
<td>
<p>a vector stores primary keys of <code>structure</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate hyperparameters, <code>a</code> and <code>b</code>, using maximum pseudolikelihood estimators.</p>


<h3>Value</h3>

<p>Return a two-dimensional vector where the fist element is <code>a</code> and the second element is <code>b</code>.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
data(linearrelation)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
# Suppose obtain beta from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
edgeind&lt;-sort(unique(linearrelation[,1]))
hyperparameter&lt;-get.ab(beta=beta, structure=linearrelation, edgeind=edgeind)
</code></pre>

<hr>
<h2 id='get.alpha'>Hyperparameter estimation for <code>alpha</code>.</h2><span id='topic+get.alpha'></span>

<h3>Description</h3>

<p>This function estimates a hyperparameter <code>alpha</code>, a scale parameter in Laplace denstiy. This function is for internal use called by the <code>icmm</code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.alpha(beta, scaledfactor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.alpha_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.alpha_+3A_scaledfactor">scaledfactor</code></td>
<td>
<p>a scalar value of multiplicative factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates a hyperparameter <code>alpha</code>, a scale parameter in Laplace density as the mode of its full conditional distribution function.</p>


<h3>Value</h3>

<p>Return a scalar value of <code>alpha</code>.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
n&lt;-dim(X)[1]
# Obtain initial values of beta from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
# Initiate alpha
alpha&lt;-0.5
# Estimate sigma
e&lt;-Y-X%*%beta
nz&lt;-sum(beta[,1]!=0)
sigma&lt;-get.sigma(Y=Y, X=X, beta=beta, alpha=alpha)
# Update alpha as the mode of its full conditional distribution function
alpha&lt;-get.alpha(beta=beta, scaledfactor=1/(sqrt(n-1)*sum(abs(beta))/sigma))
</code></pre>

<hr>
<h2 id='get.beta'>Obtain model coefficient without assuming prior on structure of predictors.</h2><span id='topic+get.beta'></span>

<h3>Description</h3>

<p>Given a sufficient statistic for a regression coefficient, this funciton estimates a regression coefficient without assuming prior on structure of predictors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.beta(SS, w, alpha, scaledfactor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.beta_+3A_ss">SS</code></td>
<td>
<p>a scalar value of sufficient statistic for a regression coefficient.</p>
</td></tr>
<tr><td><code id="get.beta_+3A_w">w</code></td>
<td>
<p>a scalar value of mixing weight.</p>
</td></tr>
<tr><td><code id="get.beta_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value of hyperparameter <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="get.beta_+3A_scaledfactor">scaledfactor</code></td>
<td>
<p>a scalar value of multiplicative factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empirical Bayes thresholding is employed to obtain a posterior median of a regression coefficient.</p>


<h3>Value</h3>

<p>a scalar value of regression coefficient.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
n&lt;-dim(X)[1]
# Obtain initial values from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
# Initiate all other parameters
w&lt;-0.5
alpha&lt;-0.5
sigma&lt;-get.sigma(Y=Y, X=X, beta=beta, alpha=alpha)
# Obtain a sufficient statistic
j&lt;-1
Yres&lt;-Y-X%*%beta+X[,j]*beta[j,1]
sxy&lt;-t(Yres)%*%X[,j]
ssx&lt;-sum(X[,j]^2)
SS&lt;-sqrt(n-1)*sxy/(sigma*ssx)
beta[j,1]&lt;-get.beta(SS=SS, w=w, alpha=alpha, scaledfactor=sigma/sqrt(n-1))
</code></pre>

<hr>
<h2 id='get.beta.ising'>Obtain a regression coefficient when assuming Ising prior (with structured predictors).</h2><span id='topic+get.beta.ising'></span>

<h3>Description</h3>

<p>Given a sufficient statistic for a regression coefficient, this function estimates a coefficient when assuming the Ising model to incorporate the prior of structured predictors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.beta.ising(SS, wpost, alpha, scaledfactor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.beta.ising_+3A_ss">SS</code></td>
<td>
<p>a sufficient statistic for a regression coefficient.</p>
</td></tr>
<tr><td><code id="get.beta.ising_+3A_wpost">wpost</code></td>
<td>
<p>a posterior probability of mixing weight.</p>
</td></tr>
<tr><td><code id="get.beta.ising_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value for hyperparameter <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="get.beta.ising_+3A_scaledfactor">scaledfactor</code></td>
<td>
<p>a scalar value for multiplicative factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a posterior probability of mixing weight, empirical Bayes thresholding is employed to obtain a posterior median of a regression coefficient.</p>


<h3>Value</h3>

<p>a scalar value of regression coefficient.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
n&lt;-dim(X)[1]
data(linearrelation)
edgeind&lt;-sort(unique(linearrelation[,1]))
# Obtain initial values from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
# Initiate all other parameters
alpha&lt;-0.5
sigma&lt;-get.sigma(Y=Y, X=X, beta=beta, alpha=alpha)
hyperparam&lt;-get.ab(beta, linearrelation, edgeind)
# Obtain regression coefficient
j&lt;-1
Yres&lt;-Y-X%*%beta+X[,j]*beta[j,1]
sxy&lt;-t(Yres)%*%X[,j]
ssx&lt;-sum(X[,j]^2)
SS&lt;-sqrt(n-1)*sxy/(sigma*ssx)
wpost&lt;-get.wpost(SS, beta, alpha, hyperparam, linearrelation, edgeind, j)
beta[j,1]&lt;-get.beta.ising(SS=SS, wpost=wpost, alpha=alpha, 
           scaledfactor=sigma/sqrt(n-1))
</code></pre>

<hr>
<h2 id='get.pseudodata.binomial'>Obtain pseudodata based on the binary logistic regression model.</h2><span id='topic+get.pseudodata.binomial'></span>

<h3>Description</h3>

<p>For logistic regression, given the current estimates of regression coefficients, working responses and their corresponding weights are obtained.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pseudodata.binomial(Y, X, beta0, beta, niter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pseudodata.binomial_+3A_y">Y</code></td>
<td>
<p>an (n*1) numeric matrix of responses.</p>
</td></tr>
<tr><td><code id="get.pseudodata.binomial_+3A_x">X</code></td>
<td>
<p>an (n*p) numeric design matrix.</p>
</td></tr>
<tr><td><code id="get.pseudodata.binomial_+3A_beta0">beta0</code></td>
<td>
<p>a scalar value of intercept term.</p>
</td></tr>
<tr><td><code id="get.pseudodata.binomial_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.pseudodata.binomial_+3A_niter">niter</code></td>
<td>
<p>number of iterations in ICM/M algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list including elements
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>an (n*1) matrix of working responses</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>an (n*1) matrix of inverse of weights.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simBinomial)
Y&lt;-as.matrix(simBinomial[,1])
X&lt;-as.matrix(simBinomial[,-1])
p&lt;-dim(X)[2]
# Obtain initial values from lasso
data(initbetaBinomial)
initbeta&lt;-as.matrix(initbetaBinomial)
# Get Pseudodata
pseudodata&lt;-get.pseudodata.binomial(Y=Y, X=X, beta0=0, beta=initbeta, niter=1)
z&lt;-pseudodata$z
sigma&lt;-sqrt(pseudodata$sigma2)
</code></pre>

<hr>
<h2 id='get.pseudodata.cox'>Obtain pseudodata based on the Cox's regression model.</h2><span id='topic+get.pseudodata.cox'></span>

<h3>Description</h3>

<p>For Cox's regression model, given the current estimates of regression coefficients, working responses and their corresponding weights are obtained.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pseudodata.cox(Y, X, event, beta, time, ntime, sumevent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pseudodata.cox_+3A_y">Y</code></td>
<td>
<p>an (n*1) numeric matrix of time response.</p>
</td></tr>
<tr><td><code id="get.pseudodata.cox_+3A_x">X</code></td>
<td>
<p>an (n*p) numeric design matrix.</p>
</td></tr>
<tr><td><code id="get.pseudodata.cox_+3A_event">event</code></td>
<td>
<p>an (n*1) numeric matrix of status: of status indicator: <code>0</code>=right censored, <code>1</code>=event at time.</p>
</td></tr>
<tr><td><code id="get.pseudodata.cox_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.pseudodata.cox_+3A_time">time</code></td>
<td>
<p>a vector or sorted value of <code>Y</code>.</p>
</td></tr>
<tr><td><code id="get.pseudodata.cox_+3A_ntime">ntime</code></td>
<td>
<p>length of the vector <code>time</code>.</p>
</td></tr>
<tr><td><code id="get.pseudodata.cox_+3A_sumevent">sumevent</code></td>
<td>
<p>a vector of size <code>ntime</code> where each element is the sum of event where <code>Y</code> is equal to each value in <code>time</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list including elements
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>an (n*1) matrix of working responses</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>an (n*1) matrix of inverse of weights.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simCox)
Y&lt;-as.matrix(simCox[,1])
event&lt;-as.matrix(simCox[,2])
X&lt;-as.matrix(simCox[,-(1:2)])
time&lt;-sort(unique(Y))
ntime&lt;-length(time)
# sum of event_i where y_i =time_k
sumevent&lt;-rep(0, ntime)
for(j in 1:ntime)
{
  sumevent[j]&lt;-sum(event[Y[,1]==time[j]])
}
# Obtain initial values from lasso
data(initbetaCox)
initbeta&lt;-as.matrix(initbetaCox)
# Get Pseudodata
pseudodata&lt;-get.pseudodata.cox(Y, X, event, initbeta, time, ntime, sumevent)
z&lt;-pseudodata$z
sigma&lt;-sqrt(pseudodata$sigma2)
</code></pre>

<hr>
<h2 id='get.sigma'>Standard deviation estimation.</h2><span id='topic+get.sigma'></span>

<h3>Description</h3>

<p>This function estimates the standard deviation when <code>family="gaussian"</code>. This function is for internal use called by the <code>icmm</code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sigma(Y, X, beta, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sigma_+3A_y">Y</code></td>
<td>
<p>an (n*1) numeric matrix of responses.</p>
</td></tr>
<tr><td><code id="get.sigma_+3A_x">X</code></td>
<td>
<p>an (n*p) numeric design matrix.</p>
</td></tr>
<tr><td><code id="get.sigma_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.sigma_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value of hyperparmeter <code>alpha</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate standard deviation as the mode of its full conditional distribution function when specify <code>family="gaussian"</code>. This function is for internal use called by the <code>icmm</code> function.</p>


<h3>Value</h3>

<p>Return a scalar value of standard deviation.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
alpha&lt;-0.5
# Obtain initial values from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
# Obtain sigma
sigma&lt;-get.sigma(Y=Y, X=X, beta=beta, alpha=alpha)
</code></pre>

<hr>
<h2 id='get.wpost'>Estimate posterior probability of mixing weight.</h2><span id='topic+get.wpost'></span>

<h3>Description</h3>

<p>With the Ising prior on structured predictors, this function gets the posterior probability of mixing weight.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wpost(SS, beta, alpha, hyperparam, structure, edgeind, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.wpost_+3A_ss">SS</code></td>
<td>
<p>a scalar value of sufficient statistic for regression coefficient.</p>
</td></tr>
<tr><td><code id="get.wpost_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.wpost_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value of hyperparameter <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="get.wpost_+3A_hyperparam">hyperparam</code></td>
<td>
<p>a two-dimensional vector of hyperparameters <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code id="get.wpost_+3A_structure">structure</code></td>
<td>
<p>a data frame stores the information of structure among predictors.</p>
</td></tr>
<tr><td><code id="get.wpost_+3A_edgeind">edgeind</code></td>
<td>
<p>a vector stores primary keys of <code>structure</code>.</p>
</td></tr>
<tr><td><code id="get.wpost_+3A_j">j</code></td>
<td>
<p>an index ranges from 1 to p. This function estimates a  posterior probability of a mixing weight corresponding to predictor <code>j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the Ising prior on structured predictors, the problem is transformed into the realm of empirical Bayes thresholding with Laplace prior by estimating the posterior probability of mixing weight. The posterior probability is used to find the posterior median of a regression coefficient.</p>


<h3>Value</h3>

<p>Return a scalar value of a posterior probability of mixing weight for predictor.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
n&lt;-dim(X)[1]
data(linearrelation)
edgeind&lt;-sort(unique(linearrelation[,1]))
# Obtain initial values from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
# Initiate all other parameters
alpha&lt;-0.5
sigma&lt;-get.sigma(Y=Y, X=X, beta=beta, alpha=alpha)
hyperparam&lt;-get.ab(beta, linearrelation, edgeind)
# Estimate the posterior probability of first predictor
j&lt;-1
Yres&lt;-Y-X%*%beta+X[,j]*beta[j,1]
sxy&lt;-t(Yres)%*%X[,j]
ssx&lt;-sum(X[,j]^2)
SS&lt;-sqrt(n-1)*sxy/(sigma*ssx)
wpost&lt;-get.wpost(SS=SS, beta=beta, alpha=alpha, hyperparam=hyperparam, 
       structure=linearrelation, edgeind=edgeind, j=j)
</code></pre>

<hr>
<h2 id='get.wprior'>Mixing weight estimation.</h2><span id='topic+get.wprior'></span>

<h3>Description</h3>

<p>Given other parameters, this function estimates a mixing weight from the mode of its full conditional distribution function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.wprior(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.wprior_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given other parameters, this function estimates a mixing weight from the mode of its full conditional distribution function. This function is called when use the independent prior of predictors (no prior on structured predictors).</p>


<h3>Value</h3>

<p>Return a scalar value of a mixing weight.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
# Obtain initial values from lasso
data(initbetaGaussian)
beta&lt;-as.matrix(initbetaGaussian)
# Estimate the mixing weight
w&lt;-get.wprior(beta)
</code></pre>

<hr>
<h2 id='get.zeta'>Local posterior probability estimation</h2><span id='topic+get.zeta'></span>

<h3>Description</h3>

<p>This function estimates the local posterior probability when assuming no prior on structured predictors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.zeta(SS, w, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.zeta_+3A_ss">SS</code></td>
<td>
<p>a scalar value of sufficient statistic for regression coefficient.</p>
</td></tr>
<tr><td><code id="get.zeta_+3A_w">w</code></td>
<td>
<p>a scalar value of mixing weight.</p>
</td></tr>
<tr><td><code id="get.zeta_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value of hyperparameter <code>alpha</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given all other parameters, this function estimates the local posterior probability or the probability that a regression coefficient is not zero conditional on other parameters. This function is called when assuming no prior on structured predictors.</p>


<h3>Value</h3>

<p>Return a scalar value of local posterior probability.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
n&lt;-dim(X)[1]
# Obtain initial values from lasso
data(initbetaGaussian)
initbeta&lt;-as.matrix(initbetaGaussian)
# Obtain the final output from ebvs
output&lt;-icmm(Y, X, b0.start=0, b.start=initbeta, family = "gaussian", 
        ising.prior = FALSE, estalpha = FALSE, alpha = 0.5, maxiter = 100)
b0&lt;-output$coef[1]
beta&lt;-matrix(output$coef[-1], ncol=1)
# Get all parameters for function arguments
w&lt;-get.wprior(beta)
alpha&lt;-0.5
sigma&lt;-get.sigma(Y,X,beta,alpha)
# Estimate local posterior probability
j&lt;-1
Yres&lt;-Y-b0-X%*%beta+X[,j]*beta[j,1]
sxy&lt;-t(Yres)%*%X[,j]
ssx&lt;-sum(X[,j]^2)
SS&lt;-sqrt(n-1)*sxy/(sigma*ssx)
zeta&lt;-get.zeta(SS=SS, w=w, alpha=alpha)
</code></pre>

<hr>
<h2 id='get.zeta.ising'>Local posterior probability estimation.</h2><span id='topic+get.zeta.ising'></span>

<h3>Description</h3>

<p>This function estimates the local posterior probability when assuming Ising prior on structured predictors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.zeta.ising(SS, beta, alpha, hyperparam, structure, edgeind, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.zeta.ising_+3A_ss">SS</code></td>
<td>
<p>a scalar value of sufficient statistic for regression coefficient.</p>
</td></tr>
<tr><td><code id="get.zeta.ising_+3A_beta">beta</code></td>
<td>
<p>a (p*1) matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get.zeta.ising_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value of hyperparameter <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="get.zeta.ising_+3A_hyperparam">hyperparam</code></td>
<td>
<p>a two-dimensional vector of hyperparameters <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code id="get.zeta.ising_+3A_structure">structure</code></td>
<td>
<p>a data frame stores the information of structure among predictors.</p>
</td></tr>
<tr><td><code id="get.zeta.ising_+3A_edgeind">edgeind</code></td>
<td>
<p>a vector stores primary keys of <code>structure</code>.</p>
</td></tr>
<tr><td><code id="get.zeta.ising_+3A_j">j</code></td>
<td>
<p>an index ranges from 1 to p. This function estimate a local posterior probability of predictor <code>j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given all other parameters, this function estimates the local posterior probability or the probability that a regression coefficient is not zero conditional on other par
ameters. This function is called when assuming Ising prior on structured predictors.</p>


<h3>Value</h3>

<p>Return a scalar value of local posterior probability.</p>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
data(linearrelation)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
n&lt;-dim(X)[1]
# Obtain initial values from lasso
data(initbetaGaussian)
initbeta&lt;-as.matrix(initbetaGaussian)
# Get final output from ebvs
output&lt;-icmm(Y, X, b0.start=0, b.start=initbeta, family = "gaussian", 
        ising.prior = TRUE, structure=linearrelation, estalpha = FALSE, 
        alpha = 0.5, maxiter = 100)
b0&lt;-output$coef[1]
beta&lt;-matrix(output$coef[-1], ncol=1)
# Get all parameters for function arguments
w&lt;-get.wprior(beta)
alpha&lt;-0.5
sigma&lt;-get.sigma(Y,X,beta,alpha)
edgeind&lt;-sort(unique(linearrelation[,1]))
hyperparam&lt;-get.ab(beta, linearrelation, edgeind)
# Estimate local posterior probability
j&lt;-1
Yres&lt;-Y-b0-X%*%beta+X[,j]*beta[j,1]
sxy&lt;-t(Yres)%*%X[,j]
ssx&lt;-sum(X[,j]^2)
SS&lt;-sqrt(n-1)*sxy/(sigma*ssx)
zeta&lt;-get.zeta.ising(SS=SS, beta=beta, alpha=alpha, hyperparam=hyperparam, 
      structure=linearrelation, edgeind=edgeind, j=j)
</code></pre>

<hr>
<h2 id='icmm'>Empirical Bayes Variable Selection</h2><span id='topic+icmm'></span>

<h3>Description</h3>

<p>Empirical Bayes variable selection via the ICM/M algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>icmm(Y, X, event, b0.start, b.start, family = "gaussian", 
     ising.prior = FALSE, structure, estalpha = FALSE, 
     alpha = 0.5, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icmm_+3A_y">Y</code></td>
<td>
<p>an (n*1) numeric matrix of responses.</p>
</td></tr>
<tr><td><code id="icmm_+3A_x">X</code></td>
<td>
<p>an (n*p) numeric design matrix.</p>
</td></tr>
<tr><td><code id="icmm_+3A_event">event</code></td>
<td>
<p>an (n*1) numeric matrix of status for censored data: <code>0</code>=censored data, <code>1</code>=event at time. <code>event</code> is required when <code>family="cox"</code>.</p>
</td></tr>
<tr><td><code id="icmm_+3A_b0.start">b0.start</code></td>
<td>
<p>a starting value of intercept term (optional).</p>
</td></tr>
<tr><td><code id="icmm_+3A_b.start">b.start</code></td>
<td>
<p>a (p*1) matrix of starting values for regression coefficients.</p>
</td></tr>
<tr><td><code id="icmm_+3A_family">family</code></td>
<td>
<p>specification of the model. It can be one of these three models: <code>"gaussian"</code>, <code>"binomial"</code>, <code>"cox"</code>. The default is <code>family="gaussian"</code>.</p>
</td></tr>
<tr><td><code id="icmm_+3A_ising.prior">ising.prior</code></td>
<td>
<p>a logical flag for Ising prior utilization. <code>ising.prior=FALSE</code> assumes no prior on structure among predictors. <code>ising.prior=TRUE</code> indicates incorporation of Ising prior to capture structure among predictors in modeling process.</p>
</td></tr>
<tr><td><code id="icmm_+3A_structure">structure</code></td>
<td>
<p>a data frame stores the information of structured predictors (need to specify when <code>ising.prior=TRUE</code>).</p>
</td></tr>
<tr><td><code id="icmm_+3A_estalpha">estalpha</code></td>
<td>
<p>a logical flag specifying whether to obtain <code>alpha</code> via ICM/M algorithm.</p>
</td></tr>
<tr><td><code id="icmm_+3A_alpha">alpha</code></td>
<td>
<p>a scalar value of scale parameter in Laplace density (non-zero part of prior). The default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="icmm_+3A_maxiter">maxiter</code></td>
<td>
<p>a maximum values of iterations for ICM/M algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main function for empirical Bayes variable selection. Iterative conditional modes/medians (ICM/M) is implemented in this function. The basic problem is to estimate regression coefficients in high-dimensional data (i.e., large p small n) and we assume that most coefficients are zero. This function also allows the prior of structure of covariates to be incorporated in the model.</p>


<h3>Value</h3>

<p>Return a list including elements
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>a vector of model coefficients. The first element is an intercept term when specifying <code>family="gaussian"</code> or <code>family="binomial"</code>.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations of ICM/M.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>a scalar value of <code>alpha</code>.</p>
</td></tr>
<tr><td><code>postprob</code></td>
<td>
<p>a p-vector of local posterior probabilities or zeta.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang</p>


<h3>References</h3>

<p>Pungpapong, V., Zhang, M. and Zhang, D. (2015). Selecting massive variables using an iterated conditional modes/medians algorithm. Electronic Journal of Statistics. 9:1243-1266. &lt;doi:10.1214/15-EJS1034&gt;.<br />
Pungpapong, V., Zhang, M. and Zhang, D. (2020). Integrating Biological Knowledge Into Case-Control Analysis Through Iterated Conditional Modes/Medians Algorithm. Journal of Computational Biology. 27(7): 1171-1179. &lt;doi:10.1089/cmb.2019.0319&gt;.
</p>


<h3>See Also</h3>

<p><code>get.ab</code>, <code>get.alpha</code>, <code>get.beta</code>, <code>get.beta.ising</code>, <code>get.pseudodata.binomial</code>, <br />
<code>get.pseudodata.cox</code>, <code>get.sigma</code>, <code>get.wprior</code>, <code>get.zeta</code>, <code>get.zeta.ising</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal linear regression model
# With no prior on structure among predictors
data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
# Obtain initial values from lasso
data(initbetaGaussian)
initbeta&lt;-as.matrix(initbetaGaussian)
result&lt;-icmm(Y=Y, X=X, b.start=initbeta, family="gaussian", 
        ising.prior=FALSE, estalpha=FALSE, alpha=0.5, maxiter=100)
result$coef
result$iterations
result$alpha
result$wpost

# With prior on structure among predictors
data(linearrelation)
result&lt;-icmm(Y=Y, X=X, b.start=initbeta, family="gaussian", 
        ising.prior=TRUE, structure=linearrelation, 
        estalpha=FALSE, alpha=0.5, maxiter=100)
result$coef
result$iterations
result$alpha
result$wpost

# Binary logistic regression model
data(simBinomial)
Y&lt;-as.matrix(simBinomial[,1])
X&lt;-as.matrix(simBinomial[,-1])
p&lt;-dim(X)[2]
# Obtain initial values from lasso
data(initbetaBinomial)
initbeta&lt;-as.matrix(initbetaBinomial)
result&lt;-icmm(Y=Y, X=X, b0.start=0, b.start=initbeta, family="binomial", 
        ising.prior=TRUE, structure=linearrelation, estalpha=FALSE, 
        alpha=0.5, maxiter=100)
result$coef
result$iterations
result$alpha
result$wpost

# Cox's model
data(simCox)
Y&lt;-as.matrix(simCox[,1])
event&lt;-as.matrix(simCox[,2])
X&lt;-as.matrix(simCox[,-(1:2)])
# Obtain initial values from lasso
data(initbetaCox)
initbeta&lt;-as.matrix(initbetaCox)
result &lt;- icmm(Y=Y, X=X, event=event, b.start=initbeta, family="cox",
          ising.prior=TRUE, structure=linearrelation, estalpha=FALSE,
          alpha=0.5, maxiter=100)
result$coef
result$iterations
result$alpha
result$wpost
</code></pre>

<hr>
<h2 id='icmm-package'>Empirical Bayes Variable Selection via ICM/M</h2><span id='topic+icmm-package'></span>

<h3>Description</h3>

<p>Carries out empirical Bayes variable selection via ICM/M algorithm. The basic problem is to fit a high-dimensional regression which most of the coefficients are assumed to be zero. This package allows incorporating the Ising prior to capture structure of predictors in the modeling process. The current version of this package can handle the normal, binary logistic, and Cox's regression.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> icmm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-5-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Vitara Pungpapong, Min Zhang, Dabao Zhang
</p>
<p>Maintainer: Vitara Pungpapong &lt;vitara@cbs.chula.ac.th&gt;
</p>


<h3>References</h3>

<p>Pungpapong, V., Zhang, M. and Zhang, D. (2015). Selecting massive variables using an iterated conditional modes/medians algorithm. Electronic Journal of Statistics. 9:1243-1266. &lt;doi:10.1214/15-EJS1034&gt;.
<br />
Pungpapong, V., Zhang, M. and Zhang, D. (2020). Integrating Biological Knowledge Into Case-Control Analysis Through Iterated Conditional Modes/Medians Algorithm. Journal of Computational Biology. 27(7): 1171-1179. &lt;doi:10.1089/cmb.2019.0319&gt;.
</p>

<hr>
<h2 id='initbetaBinomial'>Initial values for the regression coefficients used in example for running ICM/M algorithm in binary logistic model</h2><span id='topic+initbetaBinomial'></span>

<h3>Description</h3>

<p>Initial values for the regression coefficients obtained from binary logistic model with lasso regularization for <code>simBinomial</code> data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(initbetaBinomial)</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>a numeric vector of the regression coefficients.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(initbetaBinomial)
</code></pre>

<hr>
<h2 id='initbetaCox'>Initial values for the regression coefficients used in example for running ICM/M algorithm in Cox's model</h2><span id='topic+initbetaCox'></span>

<h3>Description</h3>

<p>Initial values for the regression coefficients obtained from Cox's model with lasso regularization for <code>simCox</code> data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(initbetaCox)</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>a numeric vector of the regression coefficients.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(initbetaCox)
</code></pre>

<hr>
<h2 id='initbetaGaussian'>Initial values for the regression coefficients used in example for running ICM/M algorithm in normal linear regression  model</h2><span id='topic+initbetaGaussian'></span>

<h3>Description</h3>

<p>Initial values for the regression coefficients obtained from normal linear regression model with lasso regularization for <code>simGaussian</code> data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(initbetaGaussian)</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>a numeric vector of the regression coefficients.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(initbetaGaussian)
</code></pre>

<hr>
<h2 id='linearrelation'>Linear structure of predictors</h2><span id='topic+linearrelation'></span>

<h3>Description</h3>

<p>This data frame is used as an example to store the structure of predictors or the edge set of an undirected graph. For this data frame, the linear chain is assumed for each predictor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(linearrelation)</code></pre>


<h3>Format</h3>

<p>A data frame with 400 observations and 2 variables as follows.
</p>

<dl>
<dt><code>Index</code></dt><dd><p>an index of the predictor/node which has at least one edge.</p>
</dd>
<dt><code>EdgeIndices</code></dt><dd><p>a string of all indices having an edge connected to <code>Index</code> separated by semicolon(;).</p>
</dd>
</dl>



<h3>Details</h3>

<p>This structure of predictors assumes a linear chain for each predictor which its immediate neighbors. For example, j-predictor is connected to (j-1)-predictor and (j+1)-predictor. The example for the entry in the data frame is <code>Index="5"</code> and <code>EdgeIndices="4;6"</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(linearrelation)
# To see the format of linearrelation data frame
head(linearrelation)
</code></pre>

<hr>
<h2 id='simBinomial'>Simulated data from the binary logistic regression model</h2><span id='topic+simBinomial'></span>

<h3>Description</h3>

<p>Simulated data from the binary logistic regression model. A data frame with 100 observations and 401 variables. The included variables are <br />
<code>V1</code> A numeric vector of binary responses where each entry is either <code>0</code> or <code>1</code>. <br />
<code>V2-V401</code> 400 vectors of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simBinomial)</code></pre>


<h3>Format</h3>

<p>A data frame of simulated data from the binary logistic regression with 100 observations and 401 variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(simBinomial)
  Y&lt;-as.matrix(simBinomial[,1])
  X&lt;-as.matrix(simBinomial[,-1])
</code></pre>

<hr>
<h2 id='simCox'>Simulated data from Cox's regression model</h2><span id='topic+simCox'></span>

<h3>Description</h3>

<p>Simulated data from Cox's regression model. A data frame with 100 observations and 402 variables. The included variables are <br />
<code>V1</code> A numeric vector of responses for right censored data. <br />
<code>V2</code> A numeric vector of status indicator: <code>0</code>=right censored, <code>1</code>=event at time <code>V1</code>. <br />
<code>V3</code>-<code>V402</code> 400 vectors of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simCox)</code></pre>


<h3>Format</h3>

<p>A data frame of simulated data from Cox's regression model with 100 observations and 402 variables.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(simCox)
  Y&lt;-as.matrix(simCox[,1])
  event&lt;-as.matrix(simCox[,2])
  X&lt;-as.matrix(simCox[,-(1:2)])
</code></pre>

<hr>
<h2 id='simGaussian'>Simulated data from the normal linear regression model</h2><span id='topic+simGaussian'></span>

<h3>Description</h3>

<p>Simulated data from the normal linear regression model. A data frame with 100 observations and 401 variables. The included variables are<br />
<code>V1</code> A numeric vector of responses.<br />
<code>V2-V401</code> 400 vectors of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simGaussian)</code></pre>


<h3>Format</h3>

<p>A data frame of simulated data from the normal linear regression with 100 observations and 401 variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simGaussian)
Y&lt;-as.matrix(simGaussian[,1])
X&lt;-as.matrix(simGaussian[,-1])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
