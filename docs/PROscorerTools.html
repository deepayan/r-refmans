<!DOCTYPE html><html lang="en-US"><head><title>Help for package PROscorerTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PROscorerTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PROscorerTools'><p>PROscorerTools</p></a></li>
<li><a href='#chk_nitems'><p>Checks the number and values of items passed to custom scoring functions</p></a></li>
<li><a href='#get_dfItems'><p>Get a data frame with only items from user input</p></a></li>
<li><a href='#makeFakeData'><p>Make a data frame of fake item data</p></a></li>
<li><a href='#makeItemNames'><p>Quickly create a vector of sequentially numbered item names</p></a></li>
<li><a href='#missTally'><p>Determine the number (or proportion) of missing (or non-missing) items</p>
for each respondent</a></li>
<li><a href='#msgWrap'><p>msgWrap</p></a></li>
<li><a href='#processArgs'><p>Argument Processors for <code>scoreScale</code> Function</p></a></li>
<li><a href='#rerange'><p>Change the range of an item or score</p></a></li>
<li><a href='#revcode'><p>Reverse code an item or score.</p></a></li>
<li><a href='#scoreScale'><p>Flexible function to score a single PRO or other psychometric scale</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools to Score Patient-Reported Outcome (PRO) and Other
Psychometric Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a reliable and flexible toolbox to score 
    patient-reported outcome (PRO), Quality of Life (QOL), and other 
    psychometric measures. The guiding philosophy is that scoring errors can 
    be eliminated by using a limited number of well-tested, well-behaved 
    functions to score PRO-like measures. The workhorse of the package is 
    the 'scoreScale' function, which can be used to score most single-scale 
    measures. It can reverse code items that need to be reversed before 
    scoring and pro-rate scores for missing item data. Currently, three 
    different types of scores can be output: summed item scores, mean item 
    scores, and scores scaled to range from 0 to 100. The 'PROscorerTools' 
    functions can be used to write new functions that score more complex 
    measures. In fact, 'PROscorerTools' functions are the building blocks of 
    the scoring functions in the 'PROscorer' package (which is a repository 
    of functions that score specific commonly-used instruments). Users are 
    encouraged to use 'PROscorerTools' to write scoring functions for their 
    favorite PRO-like instruments, and to submit these functions for 
    inclusion in 'PROscorer' (a tutorial vignette will be added soon). The 
    long-term vision for the 'PROscorerTools' and 'PROscorer' packages is to 
    provide an easy-to-use system to facilitate the incorporation of PRO 
    measures into research studies in a scientifically rigorous and 
    reproducible manner. These packages and their vignettes are intended to 
    help establish and promote "best practices" for scoring and describing 
    PRO-like measures in research. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MSKCC-Epi-Bio/PROscorerTools">https://github.com/MSKCC-Epi-Bio/PROscorerTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MSKCC-Epi-Bio/PROscorerTools/issues">https://github.com/MSKCC-Epi-Bio/PROscorerTools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-17 08:13:04 UTC; rayra</td>
</tr>
<tr>
<td>Author:</td>
<td>Ray Baser [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ray Baser &lt;ray.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PROscorerTools'>PROscorerTools</h2><span id='topic+PROscorerTools'></span><span id='topic+PROscorerTools-package'></span>

<h3>Description</h3>

<p>Tools to score Patient-Reported Outcome (PRO), Quality
of Life (QOL), and other psychometric measures and
questionnaire-based instruments.
</p>


<h3>Details</h3>

<p>Provides a set of reliable and flexible tools to score PRO, QOL, and
other psychometric and psychological measures.  Additionally,
<span class="pkg">PROscorerTools</span> provides the infrastructure for the scoring functions
in the <span class="pkg">PROscorer</span> package.
</p>
<p>The <code><a href="#topic+scoreScale">scoreScale</a></code> function is the workhorse of
<span class="pkg">PROscorerTools</span>, and it can be used to score most single-scale
measures. For example, it can reverse code some or all items before
scoring, and it can generate different types of scores (sum scores, mean
scores, or scores scaled to range from 0 to 100).  It and the other
<span class="pkg">PROscorerTools</span> functions can be used together to flexibly write new
functions that score more complex, multi-scale measures.
</p>
<p>The <code><a href="#topic+scoreScale">scoreScale</a></code> function itself is composed of other
<span class="pkg">PROscorerTools</span> helper functions.  This is an intentional feature of
the <span class="pkg">PROscorerTools</span> and <span class="pkg">PROscorer</span> system.  It represents the
central design philosophy that all scoring functions should be modularly
composed of a small number of well-tested, reliable helper functions.  This
important feature minimizes the possibility of scoring errors and other
unexpected behaviors.  This starts with the <code><a href="#topic+scoreScale">scoreScale</a></code>
function, and the benefits extend to the <span class="pkg">PROscorer</span> functions and any
other scoring function that uses <code><a href="#topic+scoreScale">scoreScale</a></code> as its backbone.
</p>
<p>Scoring procedures represent a major source of error in research studies
that rely upon PRO and similar measures.  These errors typically go
unnoticed, hidden, and/or ignored, eroding the scientific integrity of the
research and hindering progress in the numerous scientific fields that
conduct studies that use these measures.  A seemingly minor scoring error
can compromise measurement validity and reliability, as well as make
research results difficult to reproduce and unlikely to replicate. The
ultimate goal of the <span class="pkg">PROscorerTools</span> and <span class="pkg">PROscorer</span> packages is
to eliminate these serious deficiencies in PRO-based research by providing
a small set of gold-standard scoring tools for PRO-like measures commonly
used in research.
</p>


<h3>Overview of Functions</h3>

<p><strong>Main scoring workhorse:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+scoreScale">scoreScale</a></code>:  Scores a single scale score from a set
of items.  Has flexible arguments allowing almost any type of single
scale to be scored.  Can be used as the primary building block of more
complex scoring functions.  For example, if you are writing a new
function to score an instrument with 4 subscales, you can call
<code><a href="#topic+scoreScale">scoreScale</a></code> 4 times from within your function, once for each
subscale.
</p>
</li></ul>

<p><strong>Functions useful within another scoring function, or on their own:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+missTally">missTally</a></code>:  Count the number or proportion of items missing (or
non-missing) for each subject.
</p>
</li>
<li> <p><code><a href="#topic+rerange">rerange</a></code>:  Linearly rescale a variable to have new min and max values
of the user's choosing.
</p>
</li>
<li> <p><code><a href="#topic+rerange100">rerange100</a></code>:  Like <code><a href="#topic+rerange">rerange</a></code>, but the variable is rescaled
to range from 0 to 100.
</p>
</li>
<li> <p><code><a href="#topic+revcode">revcode</a></code>:  Reverse code the values of an item or score.
</p>
</li>
<li> <p><code><a href="#topic+makeItemNames">makeItemNames</a></code>:  Easily make a vector of item names,
e.g., <code>c("Q1", "Q2", "Q3")</code>.
</p>
</li>
<li> <p><code><a href="#topic+makeFakeData">makeFakeData</a></code>:  Quick and dirty way to generate fake item data to test
scoring functions.
</p>
</li></ul>

<p><strong>Functions mainly useful only within another scoring function:</strong>
</p>
<p>These functions are used to check the arguments supplied to custom-written
scoring functions, and to perform some minimal processing of function input.
<strong>AT THIS TIME, USE WITH CAUTION, IF AT ALL.</strong>  Most of these (if not
all) will likely undergo substantial changes in a near-future version of the
package, and/or be deprecated in favor of a more streamlined system (e.g.,
using the <span class="pkg">assertive</span> package).
</p>

<ul>
<li> <p><code><a href="#topic+msgWrap">msgWrap</a></code>:  Used inside of <code>paste</code> to help line-wrap long error
and warning messages.
</p>
</li>
<li> <p><code><a href="#topic+chk_nitems">chk_nitems</a></code>:  Checks if a data frame has the correct number of items.
</p>
</li>
<li> <p><code><a href="#topic+chkstop_nitems">chkstop_nitems</a></code>:  Checks if a data frame has the correct number of
items, and gives an error message if it does not.
</p>
</li>
<li> <p><code><a href="#topic+chk_values">chk_values</a></code>:  Checks if all item values in a data frame are in the
expected set of possible values.
</p>
</li>
<li> <p><code><a href="#topic+chkstop_values">chkstop_values</a></code>:  Checks if all item values in a data frame are in the
expected set of possible values, and gives an error message if this is
not true.
</p>
</li>
<li> <p><code><a href="#topic+get_dfItems">get_dfItems</a></code>:  Given a data frame and an item index, returns a data
frame containing only the items.
</p>
</li>
<li> <p><code><a href="#topic+get_dfItemsrev">get_dfItemsrev</a></code>:  Like <code><a href="#topic+get_dfItems">get_dfItems</a></code>, but will also reverse code
some or all of the items.
</p>
</li></ul>



<h3>Internal Functions Used by <code><a href="#topic+scoreScale">scoreScale</a></code></h3>

<p>These are internal functions used to make the <code><a href="#topic+scoreScale">scoreScale</a></code>
function more modular, and are used exclusively to check the arguments to
that function.  They will likely be of little use to others, and will
probably change in a near-future version of the package, or be deprecated
altogether in favor of a more streamlined system (e.g., using the
<span class="pkg">assertive</span> package).  They are documented here only for development
purposes.  <strong>NOTE</strong>: The interface and functionality of the
<code><a href="#topic+scoreScale">scoreScale</a></code> function will remain stable, even if/when these
functions change.
</p>

<ul>
<li> <p><code><a href="#topic+chkstop_df">chkstop_df</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chkstop_okmiss">chkstop_okmiss</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chkstop_type">chkstop_type</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chkstop_revitems">chkstop_revitems</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chk_imin">chk_imin</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chk_imax">chk_imax</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chkstop_minmax">chkstop_minmax</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ray Baser <a href="mailto:ray.stats@gmail.com">ray.stats@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/MSKCC-Epi-Bio/PROscorerTools">https://github.com/MSKCC-Epi-Bio/PROscorerTools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MSKCC-Epi-Bio/PROscorerTools/issues">https://github.com/MSKCC-Epi-Bio/PROscorerTools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='chk_nitems'>Checks the number and values of items passed to custom scoring functions</h2><span id='topic+chk_nitems'></span><span id='topic+chkstop_nitems'></span><span id='topic+chk_values'></span><span id='topic+chkstop_values'></span>

<h3>Description</h3>

<p>These functions are designed to used within custom scoring
functions to help check the arguments passed to those functions. Typically,
these argument checkers will be used within the body of a custom scoring
function before calling the <code><a href="#topic+scoreScale">scoreScale</a></code> function to handle the
bulk of the work.  See Details.
</p>

<ul>
<li> <p><code>chk_nitems</code> checks if <code>dfItems</code> contains the correct
number of items (<code>nitems</code>), and <code>chkstop_nitems</code> returns an
error message if this condition is not met.
</p>
</li>
<li> <p><code>chk_values</code> checks if all of the item values in <code>dfItems</code>
are in the set of possible values given to the <code>values</code> argument,
and <code>chkstop_values</code> returns an error message if this condition is
not met.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>chk_nitems(dfItems, nitems)

chkstop_nitems(dfItems, nitems)

chk_values(dfItems, values)

chkstop_values(dfItems, values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chk_nitems_+3A_dfitems">dfItems</code></td>
<td>
<p>A data frame with only the items to be scored.</p>
</td></tr>
<tr><td><code id="chk_nitems_+3A_nitems">nitems</code></td>
<td>
<p>The number of items on the scale to be scored.</p>
</td></tr>
<tr><td><code id="chk_nitems_+3A_values">values</code></td>
<td>
<p>A vector of all of the possible values that the items can take.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions with prefix <code>chk_</code> simply check whether their
argument values meet a condition and return <code>TRUE</code> or <code>FALSE</code>.
Functions with the prefix <code>chkstop_</code> check the arguments and, if
<code>FALSE</code>, stop execution and display an error message to help the user
pinpoint the problem.
</p>
<p>The <code><a href="#topic+scoreScale">scoreScale</a></code> function is a general, all-purpose tool that
can be used to score a scale regardless of the number or values of items on
the scale.  Because of this, however, it does not check that the user has
given it the correct number of items, and it does not check that those item
values are all within the range possible for that scale.  Therefore,
whenever <code><a href="#topic+scoreScale">scoreScale</a></code> is used to write a function to score a
specific instrument (presumably with a known number of items and item
values), the programmer should run some additional checks on the arguments
that are not already built-in to <code><a href="#topic+scoreScale">scoreScale</a></code>.
</p>


<h3>Value</h3>

<p>Functions with prefix <code>chk_</code> return <code>TRUE</code> if the arguments
<strong>pass</strong> the argument checks, or <code>FALSE</code> if the arguments
<strong>fail</strong> the checks. Functions with the prefix <code>chkstop_</code> print
an error message and stop the execution of the function in which they are
embedded.
</p>


<h3>Note</h3>

<p><strong>Use with caution!</strong>  These functions work, but they might be
deprecated in future updates of the package.  I am hoping to come up with a
more streamlined, user-friendly system for checking arguments and input
values.  Until then, these functions get the job done, but not as
gracefully as I would like.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>itemBad &lt;- c(0, 1, 2, 3, 10)
itemGood &lt;- c(0, 1, 2, 3, 0)
dfBad &lt;- data.frame(itemBad, itemGood)
dfGood &lt;- data.frame(itemGood, itemGood)
chk_nitems(dfBad, 1)
chk_nitems(dfGood, 2)
chk_values(dfBad, 0:3)
chk_values(dfGood, 0:3)

</code></pre>

<hr>
<h2 id='get_dfItems'>Get a data frame with only items from user input</h2><span id='topic+get_dfItems'></span><span id='topic+get_dfItemsrev'></span>

<h3>Description</h3>

<p>Given a data frame and an item index, returns a data frame
containing only the items.  These functions are used internally by other
PROscorerTools functions, particularly <code><a href="#topic+scoreScale">scoreScale</a></code>.  Their job
is to return a data frame containing only the items to be scored.  These
functions are also used in the scoring functions in the
<span class="pkg">PROscorer</span> package to help process the user's input.  These
functions will be of interest mainly to developers wishing to contribute to
the <span class="pkg">PROscorer</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dfItems(df, items)

get_dfItemsrev(df, dfItems, revitems, minmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dfItems_+3A_df">df</code></td>
<td>
<p>A data frame given as the argument to <code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="get_dfItems_+3A_items">items</code></td>
<td>
<p>Item index, given as argument to <code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="get_dfItems_+3A_dfitems">dfItems</code></td>
<td>
<p>A data frame with only items, created and used by
<code><a href="#topic+scoreScale">scoreScale</a></code> as an interim step in scoring a scale</p>
</td></tr>
<tr><td><code id="get_dfItems_+3A_revitems">revitems</code></td>
<td>
<p>Items to reverse, given as argument to
<code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="get_dfItems_+3A_minmax">minmax</code></td>
<td>
<p>Minimum and maximum possible item values, given as argument to
<code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions return a data frame containing only the items to be
scored. In the case of <code>get_dfItemsrev</code>, the specified items will be
reverse scored in the returned data frame.
</p>

<hr>
<h2 id='makeFakeData'>Make a data frame of fake item data</h2><span id='topic+makeFakeData'></span>

<h3>Description</h3>

<p><code>makeFakeData</code> creates a data frame containing fake item
data to facilitate the writing and testing of new scoring functions. It is
also used to create data for examples of scoring function usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFakeData(
  n = 20,
  nitems = 9,
  values = 0:4,
  propmiss = 0.2,
  prefix = "q",
  id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeFakeData_+3A_n">n</code></td>
<td>
<p>The number of respondents (rows) in the fake data.  The default is
<code>20</code>.</p>
</td></tr>
<tr><td><code id="makeFakeData_+3A_nitems">nitems</code></td>
<td>
<p>The number of items in the fake data.  The default is
<code>9</code>.</p>
</td></tr>
<tr><td><code id="makeFakeData_+3A_values">values</code></td>
<td>
<p>A vector of all possible values the items can take.  The
default is <code>0:4</code>, or equivalently <code>c(0, 1, 2, 3, 4)</code>.</p>
</td></tr>
<tr><td><code id="makeFakeData_+3A_propmiss">propmiss</code></td>
<td>
<p>The proportion of responses that will be randomly assigned to
be missing.  The default is <code>.20</code>.</p>
</td></tr>
<tr><td><code id="makeFakeData_+3A_prefix">prefix</code></td>
<td>
<p>A quoted character that will be used to prefix the item
numbers.  The default is <code>"q"</code>.</p>
</td></tr>
<tr><td><code id="makeFakeData_+3A_id">id</code></td>
<td>
<p>Logical, if <code>TRUE</code> the first variable in the data frame will
be a unique row <code>"ID"</code>.  The default is <code>FALSE</code>, and the
<code>"ID"</code> variable is omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The item responses in the first row are all the lowest possible
value and never <code>NA</code>, and the responses on the second row are all the
highest possible value and never <code>NA</code>.  This makes it easier to check
if the scoring function is at least getting the scores correct for subjects
with no missing values.  It also makes it easier in some cases to check
that the scoring function is properly reversing the items according to the
<code>itemsrev</code> argument of the scoring function.
</p>
<p>Although the resulting data frame can be customized using the arguments,
the default values are sufficient for most generic testing purposes (see
example).
</p>


<h3>Value</h3>

<p>A data frame with <code>n</code> rows, <code>nitems</code> items, and possibly
with some missing values randomly inserted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeFakeData()
</code></pre>

<hr>
<h2 id='makeItemNames'>Quickly create a vector of sequentially numbered item names</h2><span id='topic+makeItemNames'></span>

<h3>Description</h3>

<p>Takes a prefix (e.g., &quot;Q&quot;) and the number of items you want
(e.g., 3), and returns a vector of item names (e.g., c(&quot;Q1&quot;, &quot;Q2&quot;, &quot;Q3&quot;)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeItemNames(prefix, nitems)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeItemNames_+3A_prefix">prefix</code></td>
<td>
<p>A quoted prefix that will precede the number in the item name
(e.g., the &quot;Q&quot; in &quot;Q1&quot;).</p>
</td></tr>
<tr><td><code id="makeItemNames_+3A_nitems">nitems</code></td>
<td>
<p>The number of items</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of sequentially numbered item names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeItemNames("q", 3)
itemNames &lt;- makeItemNames("item", 7)
itemNames
</code></pre>

<hr>
<h2 id='missTally'>Determine the number (or proportion) of missing (or non-missing) items
for each respondent</h2><span id='topic+missTally'></span>

<h3>Description</h3>

<p>This is a handy helper function that can be used in PRO scoring
functions to determine the number (or proportion) of item responses that
are missing (or valid) for each row in a data frame of items.  This is used
by <code><a href="#topic+scoreScale">scoreScale</a></code> to help determine if a respondent has answered enough
items to be assigned a prorated scale score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missTally(dfItems, what = c("pmiss", "nmiss", "pvalid", "nvalid"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missTally_+3A_dfitems">dfItems</code></td>
<td>
<p>A data frame containing only the items of interest.</p>
</td></tr>
<tr><td><code id="missTally_+3A_what">what</code></td>
<td>
<p>One of four quoted names indicating the value you want for each
respondent (row) in <code>dfItems</code>: (1) <code>"pmiss"</code> (the default), for the
proportion of items that are missing; (2) <code>"nmiss"</code>, for the number of items
that are missing; (3) <code>"pvalid"</code>, for the proportion of items that are valid,
non-missing; and (4) <code>"nvalid"</code> for the number of items that are valid,
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nrow(dfItems)</code> that contains the quantity
requested in <code>what</code> for each row of <code>dfItems</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8675309)
#  Make data frame with 10 respondents, 10 items, and approx 30% missing data
(myItems &lt;- makeFakeData(n = 10, nitems = 10, propmiss = .30))
#  The default is to return "pmiss", the proportion missing for each row.
missTally(myItems)
missTally(myItems, "pvalid")
missTally(myItems, "nmiss")
missTally(myItems, "nvalid")
</code></pre>

<hr>
<h2 id='msgWrap'>msgWrap</h2><span id='topic+msgWrap'></span>

<h3>Description</h3>

<p>Helps format line-wrapping of long error and warning messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msgWrap(msg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msgWrap_+3A_msg">msg</code></td>
<td>
<p>A quoted message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a shorter version of the following that makes my function code
easier to read:
<code>paste(strwrap(msg, exdent = 2, width = 70), collapse = "\n")</code>
It seems to work fine when embedded in <code>warning</code> or <code>stop</code>, but may
give unexpected output if called alone.
</p>


<h3>Value</h3>

<p>It returns <code>msg</code> formatted wrapped nicely for the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt &lt;- "If you use 'itemsrev' to indicate items that
        must be reverse-coded before scoring,
        you must provide a valid numeric range to 'minmax'.
        For example, if your lowest possible item response
        is 0 and your highest possible response is 4,
        you would use 'minmax = c(0, 4)'."

warning(msgWrap(msg = txt))
</code></pre>

<hr>
<h2 id='processArgs'>Argument Processors for <code><a href="#topic+scoreScale">scoreScale</a></code> Function</h2><span id='topic+processArgs'></span><span id='topic+chkstop_df'></span><span id='topic+chkstop_okmiss'></span><span id='topic+chkstop_type'></span><span id='topic+chkstop_revitems'></span><span id='topic+chk_imin'></span><span id='topic+chk_imax'></span><span id='topic+chkstop_minmax'></span>

<h3>Description</h3>

<p>Functions that are used internally within other
<code><a href="#topic+PROscorerTools">PROscorerTools</a></code> functions, namely <code><a href="#topic+scoreScale">scoreScale</a></code>, to
process the arguments passed to them.  Only developers wishing to
contribute to the <code><a href="#topic+PROscorerTools">PROscorerTools</a></code> package should use these
functions. Even developers should avoid using them for anything but
experimentation.  If you use these functions, be warned that they will
likely change in future versions of the package in ways that may not be
compatible with your usage. They will also be made invisible to users in
future version of the <code><a href="#topic+PROscorerTools">PROscorerTools</a></code> package.  The only
reason they are visible to users in these initial versions of the package
is to make the internals of the package more transparent to potential
developers to facilitate the development and improvement of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkstop_df(df)

chkstop_okmiss(okmiss)

chkstop_type(type, minmax)

chkstop_revitems(df, dfItems, revitems, items, minmax)

chk_imin(dfItems, imin)

chk_imax(dfItems, imax)

chkstop_minmax(dfItems, minmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="processArgs_+3A_df">df</code></td>
<td>
<p>A data frame, such as the one given <code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="processArgs_+3A_okmiss">okmiss</code></td>
<td>
<p>Proportion of missing items allows, given as argument to
<code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="processArgs_+3A_type">type</code></td>
<td>
<p>Score type, given as argument to <code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="processArgs_+3A_minmax">minmax</code></td>
<td>
<p>Minimum and maximum possible item values, given as argument to
<code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="processArgs_+3A_dfitems">dfItems</code></td>
<td>
<p>A data frame with only items, created and used by
<code><a href="#topic+scoreScale">scoreScale</a></code> as an interim step in scoring a scale</p>
</td></tr>
<tr><td><code id="processArgs_+3A_revitems">revitems</code></td>
<td>
<p>Items to reverse, given as argument to <code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="processArgs_+3A_items">items</code></td>
<td>
<p>Item index, given as argument to <code><a href="#topic+scoreScale">scoreScale</a></code></p>
</td></tr>
<tr><td><code id="processArgs_+3A_imin">imin</code></td>
<td>
<p>Minimum possible item value</p>
</td></tr>
<tr><td><code id="processArgs_+3A_imax">imax</code></td>
<td>
<p>Maximum possible item value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions with prefix <code>chk_</code> simply check the argument and
return <code>TRUE</code> if the argument is OK, or <code>FALSE</code> if the argument
fails the check.  Functions with the prefix <code>chkstop_</code> check the
argument and, if <code>FALSE</code>, stop execution and display an error message
to help the user pinpoint the problem.
</p>


<h3>Value</h3>

<p>Functions with prefix <code>chk_</code> return <code>TRUE</code> if the argument
is OK, or <code>FALSE</code> if the argument fails the check. Functions with the
prefix <code>chkstop_</code> print an error message and stop the execution of the
function in which they are embedded.
</p>

<hr>
<h2 id='rerange'>Change the range of an item or score</h2><span id='topic+rerange'></span><span id='topic+rerange100'></span>

<h3>Description</h3>


<ul>
<li> <p><code>rerange</code> linearly rescales a numeric variable to have new
minimum and maximum values of the user's choosing.
</p>
</li>
<li> <p><code>rerange100</code> is a simplified version of <code>rerange</code> that
rescales a variable to range from 0 to 100.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>rerange(score, old = NULL, new = c(0, 100), rev = FALSE)

rerange100(score, mn, mx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rerange_+3A_score">score</code></td>
<td>
<p>The variable to be re-ranged.</p>
</td></tr>
<tr><td><code id="rerange_+3A_old">old</code></td>
<td>
<p>A numeric vector of length 2 indicating the old range (e.g.,
<code>c(min, max)</code> <code>score</code>.  This is a required argument.</p>
</td></tr>
<tr><td><code id="rerange_+3A_new">new</code></td>
<td>
<p>A numeric vector of length 2 indicating the new range you want for
<code>score</code>.  The default value is <code>c(0, 100)</code>.</p>
</td></tr>
<tr><td><code id="rerange_+3A_rev">rev</code></td>
<td>
<p>Logical, if <code>TRUE</code> <code>score</code> will will not only be
re-ranged, but it will also be reversed (see Details for more information).
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rerange_+3A_mn">mn</code></td>
<td>
<p>The minimum possible value that <code>score</code> can take.</p>
</td></tr>
<tr><td><code id="rerange_+3A_mx">mx</code></td>
<td>
<p>The maximum possible value that <code>score</code> can take.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rerange</code> function can re-range and reverse code a variable
all at once. If <code>rev = TRUE</code>, <code>score</code> will be reversed using
<code><a href="#topic+revcode">revcode</a></code> after it is re-ranged.  The same could be
accomplished by keeping <code>rev = FALSE</code> and reversing the order of the
range given to <code>new</code>.  For example, the following two calls to
<code>rerange</code> will return the same values:
</p>

<ul>
<li> <p><code>rerange(score, old = c(0, 10), new = c(0, 100), rev = TRUE)</code>
</p>
</li>
<li> <p><code>rerange(score, old = c(0, 10), new = c(100, 0), rev = FALSE)</code>
</p>
</li></ul>

<p>The <code>rerange100</code> function is a short-cut for <code>rerange</code> with the
arguments set to the values typically used when scoring a PRO measure.
Specifically, <code>rerange100</code> is defined as:
</p>

<ul>
<li> <p><code>rerange(score, old = c(mn, mx), new = c(0, 100), rev = FALSE)</code>
</p>
</li></ul>

<p>These functions can produce verbose warning messages.  If you are using this
function within another function, you can suppress these messages by
wrapping your call to <code>rerange</code> in <code>suppressWarnings()</code>.
</p>


<h3>Value</h3>

<p>A re-ranged vector.
</p>
<p>A version of <code>score</code> that is rescaled to range from 0 to 100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qol_score &lt;- c(0:4)

# Default is to rerange to c(0, 100)
rerange(qol_score, old = c(0, 4))
# Below gives same result as above
rerange100(qol_score, 0, 4)

# These two lines are different ways to rerange and reverse code at same time
rerange(qol_score, old = c(0, 4), new = c(0, 100), rev = TRUE)
rerange(qol_score, old = c(0, 4), new = c(100, 0))
</code></pre>

<hr>
<h2 id='revcode'>Reverse code an item or score.</h2><span id='topic+revcode'></span>

<h3>Description</h3>

<p>Given an item (or score) and the minimum and maximum possible
values that the item can take, this helper function reverse codes the item.
For example, it turns <code>c(0, 1, 2, 3, 4)</code> into <code>c(4, 3, 2, 1, 0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revcode(x, mn, mx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="revcode_+3A_x">x</code></td>
<td>
<p>A single item (or score) to reverse code.</p>
</td></tr>
<tr><td><code id="revcode_+3A_mn">mn</code></td>
<td>
<p>The minimum possible value that <code>x</code> can take.</p>
</td></tr>
<tr><td><code id="revcode_+3A_mx">mx</code></td>
<td>
<p>The maximum possible value that <code>x</code> can take.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user must supply the <em>theoretically possible</em> minimum and
maximum values to this function (using <code>mn</code> and <code>mx</code>,
respectively).  Some similar functions do not require users to provide the
minimum and maximum values.  Instead, those functions calculate the
minimum and maximum values from the data.  However, in cases where not all
of the possible item values are contained in the data, this would
incorrectly reverse score the items.  In the interest of scoring accuracy,
these arguments are required for <code>revcode</code>.
</p>


<h3>Value</h3>

<p>A vector the same length as <code>x</code>, but with values reverse coded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>item1 &lt;- c(0, 1, 2, 3, 4)
revcode(item1, 0, 4)
item2 &lt;- c(0, 1, 2, 3, 0)
revcode(item2, 0, 4)
</code></pre>

<hr>
<h2 id='scoreScale'>Flexible function to score a single PRO or other psychometric scale</h2><span id='topic+scoreScale'></span>

<h3>Description</h3>

<p><code>scoreScale</code> is a flexible function that can be used to
calculate a single scale score from a set of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreScale(
  df,
  items = NULL,
  revitems = FALSE,
  minmax = NULL,
  okmiss = 0.5,
  type = c("pomp", "100", "sum", "mean"),
  scalename = "scoredScale",
  keepNvalid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreScale_+3A_df">df</code></td>
<td>
<p>A data frame containing the items you wish to score.  It can
contain only the items, or the items plus other non-scored variables.  If
it contains non-scored variables, then you must use the <code>items</code>
argument to let the function know how to find your items in <code>df</code>.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_items">items</code></td>
<td>
<p>(optional) A character vector with the item names, or a numeric
vector indicating the column numbers of the items in <code>df</code>.  If
<code>items</code> is omitted, then <code>scoreScale</code> will assume that <code>df</code>
contains only the items to be scored and no non-scored variables.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_revitems">revitems</code></td>
<td>
<p>(optional) either <code>TRUE</code>, <code>FALSE</code>, or
a vector indicating which items in <code>df</code> should be reverse coded before
scoring.  If omitted or <code>FALSE</code> (the default), no items are reverse
coded.  If <code>TRUE</code>, all items are reverse coded before scoring.  If
only some of the items should be reverse coded, provide either a character
vector with names of the items or a numeric vector with column numbers of
the items in <code>df</code> that should be reverse coded before scoring.  If
this argument is anything but <code>FALSE</code>, then the <code>minmax</code> argument
is required.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_minmax">minmax</code></td>
<td>
<p>(optional) A vector of 2 integers of the format
<code>c(itemMin, itemMax)</code>, indicating the minimum and maximum possible
item responses, e.g., <code>c(0, 4)</code>.  This argument is required if
<code>type</code> equals <code>"pomp"</code> (the default <code>type</code>) or <code>"100"</code>.
This is also required only <code>revitems</code> is used and not set to
<code>FALSE</code>.  This function assumes that all items have the same response
range.  If this is not the case, then manually reverse code your items in
<code>df</code> before using this function, and omit the <code>revitems</code> and
<code>minmax</code> arguments.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_okmiss">okmiss</code></td>
<td>
<p>The maximum proportion of items that a respondent is allowed to
have missing and still have their non-missing items scored (and prorated).
If the proportion of missing items for a respondent is greater than
<code>okmiss</code>, then the respondent will be assigned a value of <code>NA</code>
for their scale score.  The default value is <code>0.50</code>.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_type">type</code></td>
<td>
<p>The type of score that <code>scoreScale</code> should produce.  Must be
one of either <code>"sum"</code> (for the sum of the item scores), <code>"mean"</code>
(for the mean of the item scores), <code>"100"</code> (for the score transformed
to range from 0 to 100), or <code>"pomp"</code> (for a score representing the
&quot;Percent Of the Maximum Possible&quot;, which is exactly the same as
<code>"100"</code> but with a better name).  The default is <code>"pomp"</code>.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_scalename">scalename</code></td>
<td>
<p>The quoted variable name you want the function to give your
scored scale.  If this argument is omitted, the scale will be named
<code>"scoredScale"</code> by default.</p>
</td></tr>
<tr><td><code id="scoreScale_+3A_keepnvalid">keepNvalid</code></td>
<td>
<p>Logical value indicating whether a variable containing the
number of valid, non-missing items for each respondent should be returned
in a data frame with the scale score.  The default is <code>FALSE</code>.  Set to
<code>TRUE</code> to return this variable, which will be named <code>"scalename_N"</code>
(with whatever name you gave to the <code>scalename</code> argument).  Most users
should probably omit this argument entirely.  This argument might be
removed from future versions of the package, so please let me know if you
think this argument useful and would rather it remain a part of the
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>scoreScale</code> function is the workhorse of the
<span class="pkg"><a href="#topic+PROscorerTools">PROscorerTools</a></span> package, and it is intended to be the building
block of other, more complex scoring functions tailored to specific PRO
measures.  It can handle items that need to be reverse coded before
scoring, and it has options for handling missing item responses.  It can
use three different methods to score the items: (1) sum scoring (the sum of
the item scores), mean scoring (the mean of the item scores), and 0-100
scoring (like sum or mean scoring, except that the scores are rescaled to
range from 0 to 100).  This latter method is also called &quot;POMP&quot; scoring
(Percent Of the Maximum Possible), and is the default scoring method of
<code>scoreScale</code> since it has numerous advantages over other scoring
methods (see References).
</p>
<p>This function assumes that all items have the same numeric response range.
It can still be used to score scales comprised of items with different
response ranges with two caveats:
</p>

<ul>
<li><p> First, if your items have different ranges of possible response
values AND some need to be reverse coded before scoring, you should not
use this function's <code>revitems</code> plus <code>minmax</code> arguments to
reverse your items.  Instead, you should manually reverse code your
items (see <code><a href="#topic+revcode">revcode</a></code>) before using <code>scoreScale</code>, and omit the
<code>revitems</code> and <code>minmax</code> arguments.
</p>
</li>
<li><p> Second, depending on how the different item response options are
numerically coded, some items might contribute more/less to the scale
score than others.  For example, consider a questionnaire where the
first item has responses coded as &quot;0 = No, 1 = Yes&quot; and the rest of the
items are coded as &quot;0 = Never, 1 = Sometimes, 2 = Always&quot;.  The first
item will contribute relatively less weight to the scale score than the
other items because its maximum value is only 1, compared to 2 for the
other items.  This state of affairs is not ideal, and you might want to
reconsider including items with different response ranges in one scale
score (if you have that option).
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with a variable containing the scale score.  Optionally,
the data frame can additionally have a variable containing the number of
valid item responses for each respondent.
</p>


<h3>Further Explanation of Arguments</h3>

<p>The <code>scoreScale</code> function technically has only 1 required argument,
<code>df</code>.  If none of your items need to be reverse coded before scoring,
your items are in a data frame named <code>myData</code>, and <code>myData</code>
contains ONLY the items to be scored and no non-scored variables, then
<code>scoreScale(myData)</code> is sufficient to score your items.
</p>
<p>In most real-world situations, however, you will likely have a data frame
containing a mix of items and other variables.  In this case, you should
additionally use the <code>items</code> argument to indicate which variables in
your data frame are the items to be scored.  For example, assume that
<code>myData</code> contains an ID variable named &quot;ID&quot;, followed by three items
named &quot;Q1&quot;, &quot;Q2&quot;, and &quot;Q3&quot;, none of which need to be reverse coded.  You
can score the scale by providing the <code>items</code> argument with either
<strong>(1)</strong> a numeric vector with the column indexes of the items, like
<code>scoreScale(myData, items = 2:4)</code> or <code>scoreScale(myData, items =
  c(2, 3, 4)</code>, or <strong>(2)</strong> a character vector with the item names, like
<code>scoreScale(myData, items = c("Q1", "Q2", "Q3")</code>.
</p>


<h3>References</h3>

<p>Cohen, P, Cohen, J, Aiken, LS, &amp; West, SG (1999). The problem of units and
the circumstance for POMP. <em>Multivariate Behavioral Research</em>, 34(3),
315-346.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a data frame using default settings of makeFakeData() function
# (20 respondents, 9 items with values 0 to 4, and about 20% missing)
dat &lt;- makeFakeData()

# First "sum" score the items, then "mean" score them
scoreScale(dat, type = "sum")
scoreScale(dat, type = "mean")

# Must use "minmax" argument if the "type" argument is "100"
scoreScale(dat, type = "100", minmax = c(0, 4))
# If you omit "type", the default is "pomp" (which is identical to "100")
scoreScale(dat, minmax = c(0, 4))

# "minmax" is also required if any items need to be reverse coded for scoring
#  Below, the first two items are reverse coded before scoring
scoreScale(dat, type = "sum", revitems = c("q1", "q2"), minmax = c(0, 4))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
