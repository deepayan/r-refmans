<!DOCTYPE html><html><head><title>Help for package TCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#refactor'><p>Sparse principal component analysis using ReFACTor</p></a></li>
<li><a href='#tca'><p>Fitting the TCA model</p></a></li>
<li><a href='#tcareg'><p>Fitting a TCA regression model</p></a></li>
<li><a href='#tcasub'><p>Subsetting features from a TCA model</p></a></li>
<li><a href='#tensor'><p>Extracting hidden 3D signals from 2D input</p></a></li>
<li><a href='#test_data'><p>Generate test data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tensor Composition Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Tensor Composition Analysis (TCA) allows the deconvolution of two-dimensional data (features by observations) coming from a mixture of heterogeneous sources into a three-dimensional matrix of signals (features by observations by sources). The TCA framework further allows to test the features in the data for different statistical relations with an outcome of interest while modeling source-specific effects; particularly, it allows to look for statistical relations between source-specific signals and an outcome. For example, TCA can deconvolve bulk tissue-level DNA methylation data (methylation sites by individuals) into a three-dimensional tensor of cell-type-specific methylation levels for each individual (i.e. methylation sites by individuals by cell types) and it allows to detect cell-type-specific statistical relations (associations) with phenotypes. For more details see Rahmani et al. (2019) &lt;<a href="https://doi.org/10.1038%2Fs41467-019-11052-9">doi:10.1038/s41467-019-11052-9</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>config, data.table, futile.logger, gmodels, matrixcalc,
matrixStats, nloptr, parallel, pbapply, pracma, rsvd, stats,
quadprog, Matrix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.nature.com/articles/s41467-019-11052-9">https://www.nature.com/articles/s41467-019-11052-9</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cozygene/TCA/issues">https://github.com/cozygene/TCA/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-14 17:40:34 UTC; erahmani</td>
</tr>
<tr>
<td>Author:</td>
<td>Elior Rahmani [aut, cre],
  Brandon Jew [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elior Rahmani &lt;elior.rahmani@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-14 21:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='refactor'>Sparse principal component analysis using ReFACTor</h2><span id='topic+refactor'></span>

<h3>Description</h3>

<p>Performs unsupervised feature selection followed by principal component analysis (PCA) under a row-sparse model using the ReFACTor algorithm. For example, in the context of tissue-level bulk DNA methylation data coming from a mixture of cell types (i.e. the input is methylation sites by individuals), <code>refactor</code> allows to capture the variation in cell-type composition, which was shown to be a dominant sparse signal in methylation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refactor(
  X,
  k,
  sparsity = 500,
  C = NULL,
  C.remove = FALSE,
  sd_threshold = 0.02,
  num_comp = NULL,
  rand_svd = FALSE,
  log_file = "TCA.log",
  debug = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refactor_+3A_x">X</code></td>
<td>
<p>An <code>m</code> by <code>n</code> matrix of measurements of <code>m</code> features for <code>n</code> observations. Each column in <code>X</code> is assumed to be a mixture of <code>k</code> sources. Note that <code>X</code> must include row names and column names and that NA values are currently not supported. <code>X</code> should not include features that are constant across all observations.</p>
</td></tr>
<tr><td><code id="refactor_+3A_k">k</code></td>
<td>
<p>A numeric value indicating the dimension of the signal in <code>X</code> (i.e. the number of sources).</p>
</td></tr>
<tr><td><code id="refactor_+3A_sparsity">sparsity</code></td>
<td>
<p>A numeric value indicating the sparsity of the signal in <code>X</code> (the number of signal rows).</p>
</td></tr>
<tr><td><code id="refactor_+3A_c">C</code></td>
<td>
<p>An <code>n</code> by <code>p</code> design matrix of covariates that will be accounted for in the feature selection step. An intercept term will be included automatically. Note that <code>C</code> must include row names and column names and that NA values are currently not supported; set <code>C</code> to be <code>NULL</code> if there are no such covariates.</p>
</td></tr>
<tr><td><code id="refactor_+3A_c.remove">C.remove</code></td>
<td>
<p>A logical value indicating whether the covariates in X should be accounted for not only in the feature selection step, but also in the final calculation of the principal components (i.e. if <code>C.remove == TRUE</code> then the selected features will be adjusted for the covariates in <code>C</code> prior to calculating principal components). Note that setting <code>C.remove</code> to be <code>TRUE</code> is desired when ReFACTor is intended to be used for correction in downstream analysis, whereas setting <code>C.remove</code> to be <code>FALSE</code> is desired when ReFACTor is merely used for capturing the sparse signals in <code>X</code> (i.e. regardless of correction).</p>
</td></tr>
<tr><td><code id="refactor_+3A_sd_threshold">sd_threshold</code></td>
<td>
<p>A numeric value indicating a standard deviation threshold to be used for excluding low-variance features in <code>X</code> (i.e. features with standard deviation lower than <code>sd_threshold</code> will be excluded). Set <code>sd_threshold</code> to be <code>NULL</code> for turning off this filter. Note that removing features with very low variability tends to improve speed and performance.</p>
</td></tr>
<tr><td><code id="refactor_+3A_num_comp">num_comp</code></td>
<td>
<p>A numeric value indicating the number of ReFACTor components to return.</p>
</td></tr>
<tr><td><code id="refactor_+3A_rand_svd">rand_svd</code></td>
<td>
<p>A logical value indicating whether to use random svd for estimating the low-rank structure of the data in the first step of the algorithm; random svd can result in a substantial speedup for large data.</p>
</td></tr>
<tr><td><code id="refactor_+3A_log_file">log_file</code></td>
<td>
<p>A path to an output log file. Note that if the file <code>log_file</code> already exists then logs will be appended to the end of the file. Set <code>log_file</code> to <code>NULL</code> to prevent output from being saved into a file; note that if <code>verbose == FALSE</code> then no output file will be generated regardless of the value of <code>log_file</code>.</p>
</td></tr>
<tr><td><code id="refactor_+3A_debug">debug</code></td>
<td>
<p>A logical value indicating whether to set the logger to a more detailed debug level; set <code>debug</code> to <code>TRUE</code> before reporting issues.</p>
</td></tr>
<tr><td><code id="refactor_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print logs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ReFACTor is a two-step algorithm for sparse principal component analysis (PCA) under a row-sparse model. The algorithm performs an unsupervised feature selection by ranking the features based on their correlation with their values under a low-rank representation of the data, followed by a calculation of principal components using the top ranking features (ReFACTor components).
</p>
<p>Note that ReFACTor is tuned towards capturing sparse signals of the dominant sources of variation in the data. Therefore, in the presence of other potentially dominant factors in the data (i.e. beyond the variation of interest), these factors should be accounted for by including them as covariates (see argument <code>C</code>). In cases where the ReFACTor components are designated to be used as covariates in a downstream analysis alongside the covariates in <code>C</code> (e.g., in a standard regression analysis or in a TCA regression), it is advised to set the argument <code>C.remove</code> to be <code>TRUE</code>. This will adjust the selected features for the information in <code>C</code> prior to the calculation of the ReFACTor components, which will therefore capture only signals that is not present in <code>C</code> (and as a result may benefit the downstream analysis by potentially capturing more signals beyond the information in <code>C</code>).
</p>


<h3>Value</h3>

<p>A list with the estimated components of the ReFACTor model.
</p>
<table>
<tr><td><code>scores</code></td>
<td>
<p>An <code>n</code> by <code>num_comp</code> matrix of the ReFACTor components (the projection scores).</p>
</td></tr>
<tr><td><code>coeffs</code></td>
<td>
<p>A <code>sparsity</code> by <code>num_comp</code> matrix of the coefficients of the ReFACTor components (the projection loadings).</p>
</td></tr>
<tr><td><code>ranked_list</code></td>
<td>
<p>A vector with the features in <code>X</code>, ranked by their scores in the feature selection step of the algorithm; the top scoring features (set according to the argument <code>sparsity</code>) are used for calculating the ReFACTor components. Note that features that were excluded according to <code>sd_threshold</code> will not appear in this <code>ranked_list</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For very large input matrices it is advised to use random svd for speeding up the feature selection step (see argument <code>rand_svd</code>).
</p>


<h3>References</h3>

<p>Rahmani E, Zaitlen N, Baran Y, Eng C, Hu D, Galanter J, Oh S, Burchard EG, Eskin E, Zou J, Halperin E. Sparse PCA corrects for cell type heterogeneity in epigenome-wide association studies. Nature Methods 2016.
</p>
<p>Rahmani E, Zaitlen N, Baran Y, Eng C, Hu D, Galanter J, Oh S, Burchard EG, Eskin E, Zou J, Halperin E. Correcting for cell-type heterogeneity in DNA methylation: a comprehensive evaluation. Nature Methods 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- test_data(100, 200, 3, 0, 0, 0.01)
ref &lt;- refactor(data$X, k = 3, sparsity = 50)

</code></pre>

<hr>
<h2 id='tca'>Fitting the TCA model</h2><span id='topic+tca'></span>

<h3>Description</h3>

<p>Fits the TCA model for an input matrix of features by observations that are coming from a mixture of <code>k</code> sources, under the assumption that each observation is a mixture of unique (unobserved) source-specific values (in each feature in the data). This function further allows to statistically test the effect of covariates on source-specific values. For example, in the context of tissue-level bulk DNA methylation data coming from a mixture of cell types (i.e. the input is methylation sites by individuals), <code>tca</code> allows to model the methylation of each individual as a mixture of cell-type-specific methylation levels that are unique to the individual. In addition, it allows to statistically test the effects of covariates and phenotypes on methylation at the cell-type level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tca(
  X,
  W,
  C1 = NULL,
  C1.map = NULL,
  C2 = NULL,
  refit_W = FALSE,
  refit_W.features = NULL,
  refit_W.sparsity = 500,
  refit_W.sd_threshold = 0.02,
  tau = NULL,
  vars.mle = FALSE,
  constrain_mu = FALSE,
  parallel = FALSE,
  num_cores = NULL,
  max_iters = 10,
  log_file = "TCA.log",
  debug = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tca_+3A_x">X</code></td>
<td>
<p>An <code>m</code> by <code>n</code> matrix of measurements of <code>m</code> features for <code>n</code> observations. Each column in <code>X</code> is assumed to be a mixture of <code>k</code> sources. Note that <code>X</code> must include row names and column names and that NA values are currently not supported. <code>X</code> should not include features that are constant across all observations.</p>
</td></tr>
<tr><td><code id="tca_+3A_w">W</code></td>
<td>
<p>An <code>n</code> by <code>k</code> matrix of weights - the weights of <code>k</code> sources for each of the <code>n</code> mixtures (observations). All the weights must be positive and each row - corresponding to the weights of a single observation - must sum up to 1. Note that <code>W</code> must include row names and column names and that NA values are currently not supported. In cases where only noisy estimates of <code>W</code> are available, <code>tca</code> can be set to re-estimate <code>W</code> (see <code>refit_W</code>).</p>
</td></tr>
<tr><td><code id="tca_+3A_c1">C1</code></td>
<td>
<p>An <code>n</code> by <code>p1</code> design matrix of covariates that may affect the hidden source-specific values (possibly a different effect size in each source). Note that <code>C1</code> must include row names and column names and should not include an intercept term. NA values are currently not supported. Note that each covariate in <code>C1</code> results in <code>k</code> additional parameters in the model of each feature, therefore, in order to alleviate the possibility of model overfitting, it is advised to be mindful of the balance between the size of <code>C1</code> and the sample size in <code>X</code>.</p>
</td></tr>
<tr><td><code id="tca_+3A_c1.map">C1.map</code></td>
<td>
<p>An <code>p1</code> by <code>k</code> matrix of 0/1 values, indicating for each of the <code>p1</code> covariates in <code>C1</code> whether to consider its potential effects on the values of each of the <code>k</code> sources (e.g., if position <code>i,j</code> in <code>C1.map</code> is 1 then the potential effect of the <code>i</code>-th covariate in <code>C1</code> on the j-th source will be considered). If <code>C1.map == NULL</code> then effects for all covariates in <code>C1</code> will be considered in each of the sources. Note that <code>C1.map</code> is available only if <code>constrain_mu == TRUE</code>.</p>
</td></tr>
<tr><td><code id="tca_+3A_c2">C2</code></td>
<td>
<p>An <code>n</code> by <code>p2</code> design matrix of covariates that may affect the mixture (i.e. rather than directly the sources of the mixture; for example, variables that capture biases in the collection of the measurements). Note that <code>C2</code> must include row names and column names and should not include an intercept term. NA values are currently not supported.</p>
</td></tr>
<tr><td><code id="tca_+3A_refit_w">refit_W</code></td>
<td>
<p>A logical value indicating whether to re-estimate the input <code>W</code> under the TCA model.</p>
</td></tr>
<tr><td><code id="tca_+3A_refit_w.features">refit_W.features</code></td>
<td>
<p>A vector with the names of the features in <code>X</code> to consider when re-estimating <code>W</code> (i.e. when <code>refit_W == TRUE</code>). This is useful since in general only a subset of the features in <code>X</code> are expected to be highly informative for estimating <code>W</code>. If <code>refit_W.features == NULL</code> then the ReFACTor algorithm will be used for performing feature selection (see also <code>refit_W.sparsity, refit_W.sd_threshold</code>).</p>
</td></tr>
<tr><td><code id="tca_+3A_refit_w.sparsity">refit_W.sparsity</code></td>
<td>
<p>A numeric value indicating the number of features to select using the ReFACTor algorithm when re-estimating <code>W</code> (activated only if <code>refit_W == TRUE</code> and <code>refit_W.features == NULL</code>). Note that <code>refit_W.sparsity</code> must be lower or equal to the number of features in <code>X</code>. For more information, see the argument <code>sparsity</code> in <a href="#topic+refactor">refactor</a>.</p>
</td></tr>
<tr><td><code id="tca_+3A_refit_w.sd_threshold">refit_W.sd_threshold</code></td>
<td>
<p>A numeric value indicating a standard deviation threshold to be used for excluding low-variance features in <code>X</code> (activated only if <code>refit_W == TRUE</code> and <code>refit_W.features == NULL</code>). For more information, see the argument <code>sd_threshold</code> in <a href="#topic+refactor">refactor</a>.</p>
</td></tr>
<tr><td><code id="tca_+3A_tau">tau</code></td>
<td>
<p>A non-negative numeric value of the standard deviation of the measurement noise (i.e. the i.i.d. component of variation in the model). If <code>tau == NULL</code> then <code>tca</code> will estimate <code>tau</code>.</p>
</td></tr>
<tr><td><code id="tca_+3A_vars.mle">vars.mle</code></td>
<td>
<p>A logical value indicating whether to use maximum likelihood estimation when learning the variances in the model. If <code>vars.mle == FALSE</code> then <code>tca</code> will use a non-negative least-squares optimization for learning the variances. In practice, both approaches appear to provide highly correlated models, however, setting <code>vars.mle == FALSE</code>allows a substantial speedup.</p>
</td></tr>
<tr><td><code id="tca_+3A_constrain_mu">constrain_mu</code></td>
<td>
<p>A logical value indicating whether to constrain the estimates of the mean parameters (i.e. <code class="reqn">\{\mu_{hj}\}</code>; see details below), in which case they will be constrained to the range of the values in <code>X</code>. Note that if <code>constrain_mu == TRUE</code> then <code>tca</code> will not output p-values for the effect sizes of the covariates in <code>C1</code> and in <code>C2</code>.</p>
</td></tr>
<tr><td><code id="tca_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether to use parallel computing (possible when using a multi-core machine).</p>
</td></tr>
<tr><td><code id="tca_+3A_num_cores">num_cores</code></td>
<td>
<p>A numeric value indicating the number of cores to use (activated only if <code>parallel == TRUE</code>). If <code>num_cores == NULL</code> then all available cores except for one will be used.</p>
</td></tr>
<tr><td><code id="tca_+3A_max_iters">max_iters</code></td>
<td>
<p>A numeric value indicating the maximal number of iterations to use in the optimization of the TCA model (<code>max_iters</code> iterations will be used as long as the optimization does not converge earlier).</p>
</td></tr>
<tr><td><code id="tca_+3A_log_file">log_file</code></td>
<td>
<p>A path to an output log file. Note that if the file <code>log_file</code> already exists then logs will be appended to the end of the file. Set <code>log_file</code> to <code>NULL</code> to prevent output from being saved into a file; note that if <code>verbose == FALSE</code> then no output file will be generated regardless of the value of <code>log_file</code>.</p>
</td></tr>
<tr><td><code id="tca_+3A_debug">debug</code></td>
<td>
<p>A logical value indicating whether to set the logger to a more detailed debug level; set <code>debug</code> to <code>TRUE</code> before reporting issues.</p>
</td></tr>
<tr><td><code id="tca_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print logs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TCA model assumes that the hidden source-specific values are random variables. Formally, denote by <code class="reqn">Z_{hj}^i</code> the source-specific value of observation <code class="reqn">i</code> in feature <code class="reqn">j</code> source <code class="reqn">h</code>, the TCA model assumes: </p>
<p style="text-align: center;"><code class="reqn">Z_{hj}^i \sim N(\mu_{hj},\sigma_{hj}^2)</code>
</p>
<p> where <code class="reqn">\mu_{hj},\sigma_{hj}</code> represent the mean and standard deviation that are specific to feature <code class="reqn">j</code>, source <code class="reqn">h</code>. The model further assumes that the observed value of observation <code class="reqn">i</code> in feature <code class="reqn">j</code> is a mixture of <code class="reqn">k</code> different sources: </p>
<p style="text-align: center;"><code class="reqn">X_{ji} =  \sum_{h=1}^k W_{ih}Z_{hj}^i + \epsilon_{ji}</code>
</p>
<p> where <code class="reqn">W_{ih}</code> is the non-negative proportion of source <code class="reqn">h</code> in the mixture of observation <code class="reqn">i</code> such that <code class="reqn">\sum_{h=1}^kW_{ih} = 1</code>, and <code class="reqn">\epsilon_{ji} \sim N(0,\tau^2)</code> is an i.i.d. component of variation that models measurement noise. Note that the mixture proportions in <code class="reqn">W</code> are, in general, unique for each individual, therefore each entry in <code class="reqn">X</code> is coming from a unique distribution (i.e. a different mean and a different variance).
</p>
<p>In cases where the true <code>W</code> is unknown, <code>tca</code> can be provided with noisy estimates of <code>W</code> and then re-estimate <code>W</code> as part of the optimization procedure (see argument <code>refit_W</code>). These initial estimates should not be random but rather capture the information in <code>W</code> to some extent. When the argument <code>refit_W</code> is used, it is typically the case that only a subset of the features should be used for re-estimating <code>W</code>. Therefore, when re-estimating <code>W</code>, <code>tca</code> performs feature selection using the ReFACTor algorithm; alternatively, it can also be provided with a user-specified list of features to be used in the re-estimation, assuming that such list of features that are most informative for estimating <code class="reqn">W</code> exist (see argument <code>refit_W.features</code>).
</p>
<p>Covariates that systematically affect the source-specific values <code class="reqn">Z_{hj}^i</code> can be further considered (see argument <code>C1</code>). In that case, we assume: </p>
<p style="text-align: center;"><code class="reqn">Z_{hj}^i \sim N(\mu_{hj}+c^{(1)}_i \gamma_j^h,\sigma_{hj}^2)</code>
</p>
<p> where <code class="reqn">c^{(1)}_i</code> and <code class="reqn">\gamma_j^h</code> correspond to the <code class="reqn">p_1</code> covariate values of observation <code class="reqn">i</code> (i.e. a row vector from <code>C1</code>) and their effect sizes, respectively.
</p>
<p>Covariates that systematically affect the mixture values <code class="reqn">X_{ji}</code>, such as variables that capture technical biases in the collection of the measurements, can also be considered (see argument <code>C2</code>). In that case, we assume: </p>
<p style="text-align: center;"><code class="reqn">X_{ji} = \sum_{h=1}^k W_{ih}Z_{hj}^i + c^{(2)}_i \delta_j + \epsilon_{ij}</code>
</p>
<p> where <code class="reqn">c^{(2)}_i</code> and <code class="reqn">\delta_j</code> correspond to the <code class="reqn">p_2</code> covariate values of observation <code class="reqn">i</code> (i.e. a row vector from <code>C2</code>) and their effect sizes, respectively.
</p>
<p>Since the standard deviation of <code class="reqn">X_{ji}</code> is specific to observation <code class="reqn">i</code> and feature <code class="reqn">j</code>, we can obtain p-values for the estimates of <code class="reqn">\gamma_j^h</code> and <code class="reqn">\delta_j</code> by dividing each observed data point <code class="reqn">x_{ji}</code> by its estimated standard deviation and calculating T-statistics under a standard linear regression framework.
</p>


<h3>Value</h3>

<p>A list with the estimated parameters of the model. This list can be then used as the input to other functions such as <a href="#topic+tcareg">tcareg</a>.
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>An <code>n</code> by <code>k</code> matrix of weights. If <code>refit_W == TRUE</code> then this is the re-estimated <code>W</code>, and otherwise this is the input <code>W</code></p>
</td></tr>
<tr><td><code>mus_hat</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of estimates for the mean of each source in each feature.</p>
</td></tr>
<tr><td><code>sigmas_hat</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of estimates for the standard deviation of each source in each feature.</p>
</td></tr>
<tr><td><code>tau_hat</code></td>
<td>
<p>An estimate of the standard deviation of the i.i.d. component of variation in <code>X</code>. If an input value was provided for <code>tau</code> (i.e. <code>tau != NULL</code>) then <code>tau_hat == tau</code>.</p>
</td></tr>
<tr><td><code>gammas_hat</code></td>
<td>
<p>An <code>m</code> by <code>k*p1</code> matrix of the estimated effects of the <code>p1</code> covariates in <code>C1</code> on each of the <code>m</code> features in <code>X</code>, where the first <code>p1</code> columns are the source-specific effects of the <code>p1</code> covariates on the first source, the following <code>p1</code> columns are the source-specific effects on the second source and so on.</p>
</td></tr>
<tr><td><code>deltas_hat</code></td>
<td>
<p>An <code>m</code> by <code>p2</code> matrix of the estimated effects of the <code>p2</code> covariates in <code>C2</code> on the mixture values of each of the <code>m</code> features in <code>X</code>.</p>
</td></tr>
<tr><td><code>gammas_hat_pvals</code></td>
<td>
<p>An <code>m</code> by <code>k*p1</code> matrix of p-values for the estimates in <code>gammas_hat</code> (based on a T-test). Note that <code>gammas_hat_pvals</code> is set to NULL if <code>constrain_mu == TRUE</code>.</p>
</td></tr>
<tr><td><code>gammas_hat_pvals.joint</code></td>
<td>
<p>An <code>m</code> by <code>p1</code> matrix of p-values for the joint effects (i.e. across all <code>k</code> sources) of each of the <code>p1</code> covariates in <code>C1</code> on each of the <code>m</code> features in <code>X</code> (based on a partial F-test). In other words, these are p-values for the combined statistical effects of each one of the <code>p1</code> covariates on each of the <code>m</code> features under the TCA model. Note that <code>gammas_hat_pvals.joint</code> is set to NULL if <code>constrain_mu == TRUE</code>.</p>
</td></tr>
<tr><td><code>deltas_hat_pvals</code></td>
<td>
<p>An <code>m</code> by <code>p2</code> matrix of p-values for the estimates in <code>deltas_hat</code> (based on a T-test). Note that <code>deltas_hat_pvals</code> is set to NULL if <code>constrain_mu == TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahmani E, Schweiger R, Rhead B, Criswell LA, Barcellos LF, Eskin E, Rosset S, Sankararaman S, Halperin E. Cell-type-specific resolution epigenetics without the need for cell sorting or single-cell biology. Nature Communications 2019.
</p>
<p>Rahmani E, Zaitlen N, Baran Y, Eng C, Hu D, Galanter J, Oh S, Burchard EG, Eskin E, Zou J, Halperin E. Sparse PCA corrects for cell type heterogeneity in epigenome-wide association studies. Nature Methods 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- test_data(100, 20, 3, 1, 1, 0.01)
tca.mdl &lt;- tca(X = data$X, W = data$W, C1 = data$C1, C2 = data$C2)

</code></pre>

<hr>
<h2 id='tcareg'>Fitting a TCA regression model</h2><span id='topic+tcareg'></span>

<h3>Description</h3>

<p>TCA regression allows to test, under several types of statistical tests, the effects of source-specific values on an outcome of interest (or on mediating components thereof). For example, in the context of tissue-level bulk DNA methylation data coming from a mixture of cell types (i.e. the input is methylation sites by individuals), <code>tcareg</code> allows to test for cell-type-specific effects of methylation on outcomes of interest (or on mediating components thereof).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcareg(
  X,
  tca.mdl,
  y,
  C3 = NULL,
  test = "marginal_conditional",
  null_model = NULL,
  alternative_model = NULL,
  save_results = FALSE,
  fast_mode = TRUE,
  output = "TCA",
  sort_results = FALSE,
  parallel = FALSE,
  num_cores = NULL,
  log_file = "TCA.log",
  features_metadata = NULL,
  debug = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcareg_+3A_x">X</code></td>
<td>
<p>An <code>m</code> by <code>n</code> matrix of measurements of <code>m</code> features for <code>n</code> observations. Each column in <code>X</code> is assumed to be a mixture of <code>k</code> sources. Note that <code>X</code> must include row names and column names and that NA values are currently not supported. <code>X</code> should not include features that are constant across all observations.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_tca.mdl">tca.mdl</code></td>
<td>
<p>The value returned by applying <a href="#topic+tca">tca</a> to <code>X</code>.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_y">y</code></td>
<td>
<p>An <code>n</code> by 1 matrix of an outcome of interest for each of the <code>n</code> observations in <code>X</code>. Note that <code>y</code> must include row names and column names and that NA values are currently not supported.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_c3">C3</code></td>
<td>
<p>An <code>n</code> by <code>p3</code> design matrix of covariates that may affect <code>y</code>. Note that <code>C3</code> must include row names and column names and should not include an intercept term. NA values are currently not supported.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_test">test</code></td>
<td>
<p>A character vector with the type of test to perform on each of the features in <code>X</code>; one of the following options: <code>'marginal'</code>, <code>'marginal_conditional'</code>, <code>'joint'</code>, <code>'single_effect'</code>, or <code>'custom'</code>. Setting <code>'marginal'</code> or <code>'marginal_conditional'</code> corresponds to testing each feature in <code>X</code> for a statistical relation between <code>y</code> and each of the <code>k</code> sources separately; for any particular source under test, the <code>marginal_conditional</code> option further accounts for possible effects of the rest of the <code>k-1</code> sources (<code>'marginal'</code> will therefore tend to be more powerful in discovering truly related features, but at the same time more prone to falsely tagging the correct related sources if sources are highly correlated). Setting <code>'joint'</code> or <code>'single_effect'</code> corresponds to testing each feature for an overall statistical relation with <code>y</code>, while modeling source-specific effects; the latter option further assumes that the source-specific effects are the same within each feature (<code>'single_effect'</code> means only one degree of freedom and will therefore be more powerful when the assumption of a single effect within a feature holds). Finally, <code>'custom'</code> corresponds to testing each feature in <code>X</code> for a statistical relation with <code>y</code> under a user-specified model (alternative model) with respect to a null model (null model); for example, for testing for relation of the combined (potentially different) effects of features 1 and 2 while accounting for the (potentially different) effects of 3 and 4, set the null model to be sources 3, 4 and the alternative model to be sources 1, 2, 3, 4. Indicating that <code>null_model</code> assumes no effect for any of the sources can be done by setting it to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_null_model">null_model</code></td>
<td>
<p>A vector with a subset of the names of the sources in <code>tca.mdl$W</code> to be used as a null model (activated only if <code>test == 'custom'</code>). Note that the null model must be nested within the alternative model; set <code>null_model</code> to be <code>NULL</code> for indicating no effect for any of the sources under the null model.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_alternative_model">alternative_model</code></td>
<td>
<p>A vector with a subset (or all) of the names of the sources in <code>tca.mdl$W</code> to be used as an alternative model (activated only if <code>test == 'custom'</code>).</p>
</td></tr>
<tr><td><code id="tcareg_+3A_save_results">save_results</code></td>
<td>
<p>A logical value indicating whether to save the returned results in a file. If <code>test == 'marginal'</code> or (<code>fast_mode == TRUE</code> and <code>test == 'marginal_conditional'</code>) then <code>k</code> files will be saved (one for the results of each source).</p>
</td></tr>
<tr><td><code id="tcareg_+3A_fast_mode">fast_mode</code></td>
<td>
<p>A logical value indicating whether to use a fast version of TCA regression, in which source-specific-values are first estimated using the <code>tensor</code> function and then tested under a standard regression framework (see more details below).</p>
</td></tr>
<tr><td><code id="tcareg_+3A_output">output</code></td>
<td>
<p>Prefix for output files (activated only if <code>save_results == TRUE</code>).</p>
</td></tr>
<tr><td><code id="tcareg_+3A_sort_results">sort_results</code></td>
<td>
<p>A logical value indicating whether to sort the results by their p-value (i.e. features with lower p-value will appear first in the results). This option is not available if <code>fast_mode == TRUE</code> and <code>test == "marginal_conditional"</code>.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether to use parallel computing (possible when using a multi-core machine).</p>
</td></tr>
<tr><td><code id="tcareg_+3A_num_cores">num_cores</code></td>
<td>
<p>A numeric value indicating the number of cores to use (activated only if <code>parallel == TRUE</code>). If <code>num_cores == NULL</code> then all available cores except for one will be used.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_log_file">log_file</code></td>
<td>
<p>A path to an output log file. Note that if the file <code>log_file</code> already exists then logs will be appended to the end of the file. Set <code>log_file</code> to <code>NULL</code> to prevent output from being saved into a file; note that if <code>verbose == FALSE</code> then no output file will be generated regardless of the value of <code>log_file</code>.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_features_metadata">features_metadata</code></td>
<td>
<p>A path to a csv file containing metadata about the features in <code>X</code> that will be added to the output files (activated only if <code>save_results == TRUE</code>). Each row in the metadata file should correspond to one feature in <code>X</code> (with the row name being the feature identifier, as it appears in the rows of <code>X</code>) and each column should correspond to one metadata descriptor (with an appropriate column name). Features that do not exist in <code>X</code> will be ignored and features in <code>X</code> with missing metadata information will show missing values.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_debug">debug</code></td>
<td>
<p>A logical value indicating whether to set the logger to a more detailed debug level; set <code>debug</code> to <code>TRUE</code> before reporting issues.</p>
</td></tr>
<tr><td><code id="tcareg_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print logs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TCA models <code class="reqn">Z_{hj}^i</code> as the source-specific value of observation <code class="reqn">i</code> in feature <code class="reqn">j</code> coming from source <code class="reqn">h</code> (see <a href="#topic+tca">tca</a> for more details). A TCA regression model tests an outcome <code class="reqn">Y</code> for a linear statistical relation with the source-specific values of a feature <code class="reqn">j</code> by assuming: </p>
<p style="text-align: center;"><code class="reqn">Y_i =  \alpha_{j,0} + \sum_{h=1}^k\beta_{hj} Z_{hj}^i + c_i^{(3)}\alpha_{j}  + e_i</code>
</p>
<p> where <code class="reqn">\alpha_{j,0}</code> is an intercept term, <code class="reqn">\beta_{hj}</code> is the effect of source <code class="reqn">h</code>, <code class="reqn">c_i^{(3)}</code> and <code class="reqn">\alpha_j</code> correspond to the <code class="reqn">p_3</code> covariate values of observation <code class="reqn">i</code> (i.e. a row vector from <code>C3</code>) and their effect sizes, respectively, and <code class="reqn">e_i \sim N(0,\phi^2)</code>. In practice, if <code>fast_mode == FALSE</code> then <code>tcareg</code> fits this model using the conditional distribution <code class="reqn">Y|X</code>, which, effectively, integrates over the random <code class="reqn">Z_{hj}^i</code>. Statistical significance is then calculated using a likelihood ratio test (LRT).
Alternatively, in case <code>fast_mode == TRUE</code> the above model is fitted by first learning point estimates for <code class="reqn">Z_{hj}^i</code> using the <a href="#topic+tensor">tensor</a> function and then assessing statistical significance using T-tests and partial F-tests under a standard regression framework. This alternative provides a substantial boost in speed.
</p>
<p>Note that the null and alternative models will be set automatically, except when <code>test == 'custom'</code>, in which case they will be set according to the user-specified null and alternative hypotheses.
</p>
<p>Under the TCA regression model, several statistical tests can be performed by setting the argument <code>test</code> according to one of the following options:
</p>
<p>1. If <code>test == 'marginal'</code>, <code>tcareg</code> will perform the following for each source <code class="reqn">l</code>. For each feature <code class="reqn">j</code>, <code class="reqn">\beta_{lj}</code> will be estimated and tested for a non-zero effect, while assuming <code class="reqn">\beta_{hj}=0</code> for all other sources <code class="reqn">h\neq l</code>.
</p>
<p>2. If <code>test == 'marginal_conditional'</code>, <code>tcareg</code> will perform the following for each source <code class="reqn">l</code>. For each feature <code class="reqn">j</code>, <code class="reqn">\beta_{lj}</code> will be estimated and tested for a non-zero effect, while also estimating the effect sizes <code class="reqn">\beta_{hj}</code> for all other sources <code class="reqn">h\neq l</code> (thus accounting for covariances between the estimated effects of different sources).
</p>
<p>3. If <code>test == 'joint'</code>, <code>tcareg</code> will estimate for each feature <code class="reqn">j</code> the effect sizes of all <code class="reqn">k</code> sources <code class="reqn">\beta_{1j},…,\beta_{kj}</code> and then test the set of <code class="reqn">k</code> estimates of each feature <code>j</code> for a joint effect.
</p>
<p>4. If <code>test == 'single_effect'</code>, <code>tcareg</code> will estimate for each feature <code class="reqn">j</code> the effect sizes of all <code class="reqn">k</code> sources <code class="reqn">\beta_{1j},…,\beta_{kj}</code>, under the assumption that <code class="reqn">\beta_{1j} = … = \beta_{kj}</code>, and then test the set of <code class="reqn">k</code> estimates of each feature <code>j</code> for a joint effect.
</p>
<p>5. If <code>test == 'custom'</code>, <code>tcareg</code> will estimate for each feature <code class="reqn">j</code> the effect sizes of a predefined set of sources (defined by a user-specified alternative model) and then test their estimates for a joint effect, while accounting for a nested predefined set of sources (defined by a user-specified null model).
</p>


<h3>Value</h3>

<p>A list with the results of applying the TCA regression model to each of the features in <code>X</code>. If <code>test == 'marginal'</code> or (<code>test == 'marginal_conditional'</code> and <code>fast_mode == FALSE</code>) then a list of <code>k</code> such lists of results are returned, one for the results of each source.
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>An estimate of the standard deviation of the i.i.d. component of variation in the TCA regression model.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A matrix of effect size estimates for the source-specific effects, such that each row corresponds to the estimated effect sizes of one feature in <code>X</code>. The number of columns corresponds to the number of estimated effects (e.g., if <code>test</code> is set to <code>marginal</code> then <code>beta</code> will include a single column, if <code>test</code> is set to <code>joint</code> then <code>beta</code> will include <code>k</code> columns etc.).</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>An <code>m</code> by <code>1</code> matrix of estimates for the intercept term of each feature.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>An <code>m</code> by <code>p3</code> matrix of effect size estimates for the <code>p3</code> covariates in <code>C3</code>, such that each row corresponds to the estimated effect sizes of one feature in <code>X</code>.</p>
</td></tr>
<tr><td><code>null_ll</code></td>
<td>
<p>An <code>m</code> by <code>1</code> matrix of the log-likelihood of the model under the null hypothesis. Returned only if <code>fast_mode == FALSE</code>.</p>
</td></tr>
<tr><td><code>alternative_ll</code></td>
<td>
<p>An <code>m</code> by <code>1</code> matrix of the log-likelihood of the model under the alternative hypothesis.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of T statistics for each source in each feature in <code>X</code> assuming <code>test == "marginal_conditional"</code> and <code>fast_mode == TRUE</code>; otherwise, an <code>m</code> by <code>1</code> matrix of an (partial) F statistic (if <code>fast_mode == TRUE</code>) or a likelihood-ratio test statistic (if <code>fast_mode == FALSE</code>) for each feature in <code>X</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom for deriving p-values.</p>
</td></tr>
<tr><td><code>pvals</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of p-values for each source in each feature in <code>X</code> assuming <code>test == "marginal_conditional"</code> and <code>fast_mode == TRUE</code>; otherwise, an <code>m</code> by <code>1</code> matrix of the p-value for each feature in <code>X</code>.</p>
</td></tr>
<tr><td><code>qvals</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of q-values (FDR-adjusted p-values) for each source in each feature in <code>X</code> assuming <code>test == "marginal_conditional"</code> and <code>fast_mode == TRUE</code>; otherwise, an <code>m</code> by <code>1</code> matrix of the q-value for each feature in <code>X</code>. Note that if <code>test == "marginal_conditional"</code> and <code>fast_mode == TRUE</code> then q-values are calculated for each source separately.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rahmani E, Schweiger R, Rhead B, Criswell LA, Barcellos LF, Eskin E, Rosset S, Sankararaman S, Halperin E. Cell-type-specific resolution epigenetics without the need for cell sorting or single-cell biology. Nature Communications 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
m &lt;- 10
k &lt;- 3
p1 &lt;- 1
p2 &lt;- 1
data &lt;- test_data(n, m, k, p1, p2, 0.01)
tca.mdl &lt;- tca(X = data$X, W = data$W, C1 = data$C1, C2 = data$C2)
y &lt;- matrix(rexp(n, rate=.1), ncol=1)
rownames(y) &lt;- rownames(data$W)
# marginal conditional test:
res0 &lt;- tcareg(data$X, tca.mdl, y)
# joint test:
res1 &lt;- tcareg(data$X, tca.mdl, y, test = "joint")
# custom test, testing for a joint effect of sources 1,2 while accounting for source 3
res2 &lt;- tcareg(data$X, tca.mdl, y, test = "custom", null_model = c("3"),
alternative_model = c("1","2","3"))
# custom test, testing for a joint effect of sources 1,2 assuming no effects under the null
res3 &lt;- tcareg(data$X, tca.mdl, y, test = "custom", null_model = NULL,
alternative_model = c("1","2"))

</code></pre>

<hr>
<h2 id='tcasub'>Subsetting features from a TCA model</h2><span id='topic+tcasub'></span>

<h3>Description</h3>

<p>Extracts from a fitted TCA model (i.e. a value returned by the function <code>tca</code>) a subset of the features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcasub(tca.mdl, features, log_file = "TCA.log", debug = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcasub_+3A_tca.mdl">tca.mdl</code></td>
<td>
<p>The value returned by applying the function <code>tca</code> to some data matrix<code>X</code>.</p>
</td></tr>
<tr><td><code id="tcasub_+3A_features">features</code></td>
<td>
<p>A vector with the identifiers of the features to extract (as they appear in the rows of <code>X</code>).</p>
</td></tr>
<tr><td><code id="tcasub_+3A_log_file">log_file</code></td>
<td>
<p>A path to an output log file. Note that if the file <code>log_file</code> already exists then logs will be appended to the end of the file. Set <code>log_file</code> to <code>NULL</code> to prevent output from being saved into a file; note that if <code>verbose == FALSE</code> then no output file will be generated regardless of the value of <code>log_file</code>.</p>
</td></tr>
<tr><td><code id="tcasub_+3A_debug">debug</code></td>
<td>
<p>A logical value indicating whether to set the logger to a more detailed debug level; set <code>debug</code> to <code>TRUE</code> before reporting issues.</p>
</td></tr>
<tr><td><code id="tcasub_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print logs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to extract a subset of the features from a fitted TCA model (i.e. from a value returned by the function <code>tca</code>). This allows, for example, to extract and then perform post-hoc tests on only a small set of candidate features (e.g., using the function <code>tcareg</code>), without the need to run <code>tca</code> again for fitting the model to the candidate features.
</p>


<h3>Value</h3>

<p>A list with the estimated parameters of the model for the given set of features.
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>Equals to <code>tca.mdl$W</code></p>
</td></tr>
<tr><td><code>mus_hat</code></td>
<td>
<p>A <code>q</code> by <code>k</code> matrix which is a subset of the matrix <code>tca.mdl$mus_hat</code>, where <code>q</code> is the number of features in the argument <code>features</code>.</p>
</td></tr>
<tr><td><code>sigmas_hat</code></td>
<td>
<p>A <code>q</code> by <code>k</code> matrix which is a subset of the matrix <code>tca.mdl$sigmas_hat</code>, where <code>q</code> is the number of features in the argument <code>features</code>.</p>
</td></tr>
<tr><td><code>tau_hat</code></td>
<td>
<p>Equals to <code>tca.mdl$tau_hat</code></p>
</td></tr>
<tr><td><code>gammas_hat</code></td>
<td>
<p>A <code>q</code> by <code>k*p1</code>  matrix which is a subset of the matrix <code>tca.mdl$gammas_hat</code>, where <code>q</code> is the number of features in the argument <code>features</code>.</p>
</td></tr>
<tr><td><code>deltas_hat</code></td>
<td>
<p>A <code>q</code> by <code>p2</code> matrix which is a subset of the matrix <code>tca.mdl$deltas_hat</code>, where <code>q</code> is the number of features in the argument <code>features</code>.</p>
</td></tr>
<tr><td><code>gammas_hat_pvals</code></td>
<td>
<p>A <code>q</code> by <code>k*p1</code> matrix which is a subset of the matrix <code>tca.mdl$gammas_hat_pvals</code>, where <code>q</code> is the number of features in the argument <code>features</code>. Note that if <code>tca.mdl$gammas_hat_pvals == NULL</code> then <code>gammas_hat_pvals</code> is also set to NULL.</p>
</td></tr>
<tr><td><code>gammas_hat_pvals.joint</code></td>
<td>
<p>A <code>q</code> by <code>p1</code> matrix which is a subset of the matrix <code>tca.mdl$gammas_hat_pvals.joint</code>, where <code>q</code> is the number of features in the argument <code>features</code>. Note that if <code>tca.mdl$gammas_hat_pvals.joint == NULL</code> then <code>gammas_hat_pvals</code> is also set to NULL.</p>
</td></tr>
<tr><td><code>deltas_hat_pvals</code></td>
<td>
<p>A <code>q</code> by <code>p2</code> matrix which is a subset of the matrix <code>tca.mdl$deltas_hat_pvals</code>, where <code>q</code> is the number of features in the argument <code>features</code>. Note that if <code>tca.mdl$deltas_hat_pvals == NULL</code> then <code>deltas_hat_pvals</code> is also set to NULL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- test_data(50, 20, 3, 0, 0, 0.01)
tca.mdl &lt;- tca(X = data$X, W = data$W)
tca.mdl.subset &lt;- tcasub(tca.mdl, rownames(data$X)[1:10])
y &lt;- matrix(rexp(50, rate=.1), ncol=1)
rownames(y) &lt;- rownames(data$W)
# run tcareg test with an outcome y:
res &lt;- tcareg(data$X[1:10,], tca.mdl.subset, y, test = "joint")

</code></pre>

<hr>
<h2 id='tensor'>Extracting hidden 3D signals from 2D input</h2><span id='topic+tensor'></span>

<h3>Description</h3>

<p>Estimates 3-dimensional signals (features by observations by sources) from input of mixtures (features by observations), under the assumption of the TCA model that each observation is a mixture of unique source-specific values (in each feature in the data). For example, in the context of  tissue-level bulk DNA methylation data coming from a mixture of cell types (i.e. the input is methylation sites by individuals), <code>tensor</code> allows to estimate a tensor of cell-type-specific levels for each individual in each methylation site (i.e. a tensor of methylation sites by individuals by cell types).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tensor(
  X,
  tca.mdl,
  scale = FALSE,
  parallel = FALSE,
  num_cores = NULL,
  log_file = "TCA.log",
  debug = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tensor_+3A_x">X</code></td>
<td>
<p>An <code>m</code> by <code>n</code> matrix of measurements of <code>m</code> features for <code>n</code> observations. Each column in <code>X</code> is assumed to be a mixture of <code>k</code> sources. Note that <code>X</code> must include row names and column names and that NA values are currently not supported. <code>X</code> should not include features that are constant across all observations.</p>
</td></tr>
<tr><td><code id="tensor_+3A_tca.mdl">tca.mdl</code></td>
<td>
<p>The value returned by applying the function <code>tca</code> to <code>X</code>.</p>
</td></tr>
<tr><td><code id="tensor_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether to divide the estimate of each entry in the tensor by its estimated standard deviation.</p>
</td></tr>
<tr><td><code id="tensor_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether to use parallel computing (possible when using a multi-core machine).</p>
</td></tr>
<tr><td><code id="tensor_+3A_num_cores">num_cores</code></td>
<td>
<p>A numeric value indicating the number of cores to use (activated only if <code>parallel == TRUE</code>). If <code>num_cores == NULL</code> then all available cores except for one will be used.</p>
</td></tr>
<tr><td><code id="tensor_+3A_log_file">log_file</code></td>
<td>
<p>A path to an output log file. Note that if the file <code>log_file</code> already exists then logs will be appended to the end of the file. Set <code>log_file</code> to <code>NULL</code> to prevent output from being saved into a file; note that if <code>verbose == FALSE</code> then no output file will be generated regardless of the value of <code>log_file</code>.</p>
</td></tr>
<tr><td><code id="tensor_+3A_debug">debug</code></td>
<td>
<p>A logical value indicating whether to set the logger to a more detailed debug level; set <code>debug</code> to <code>TRUE</code> before reporting issues.</p>
</td></tr>
<tr><td><code id="tensor_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print logs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+tca">tca</a> for notations and details about the TCA model. Given estimates of the parameters of the model (given by <a href="#topic+tca">tca</a>), <code>tensor</code> uses the conditional distribution <code class="reqn">Z_{hj}^i|X_{ji}=x_{ji}</code> for estimating the <code class="reqn">k</code> source-specific levels of each observation <code class="reqn">i</code> in each feature <code class="reqn">j</code>.
</p>


<h3>Value</h3>

<p>A list with the estimated source-specific values. The first element in the list is an <code>m</code> by <code>n</code> matrix (features by observations) corresponding to the estimated values coming from the first source, the second element in the list is another <code>m</code> by <code>n</code> matrix (features by observations) corresponding to the estimated values coming from the second source and so on.
</p>


<h3>References</h3>

<p>Rahmani E, Schweiger R, Rhead B, Criswell LA, Barcellos LF, Eskin E, Rosset S, Sankararaman S, Halperin E. Cell-type-specific resolution epigenetics without the need for cell sorting or single-cell biology. Nature Communications 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- test_data(50, 20, 3, 2, 2, 0.01)
tca.mdl &lt;- tca(X = data$X, W = data$W, C1 = data$C1, C2 = data$C2)
Z_hat &lt;- tensor(data$X, tca.mdl)

</code></pre>

<hr>
<h2 id='test_data'>Generate test data</h2><span id='topic+test_data'></span>

<h3>Description</h3>

<p>Generates simple test data following the TCA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_data(n, m, k, p1, p2, tau, log_file = "TCA.log", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_data_+3A_n">n</code></td>
<td>
<p>The number of observations to simulate.</p>
</td></tr>
<tr><td><code id="test_data_+3A_m">m</code></td>
<td>
<p>The number of features to simulate.</p>
</td></tr>
<tr><td><code id="test_data_+3A_k">k</code></td>
<td>
<p>The number of sources to simulate.</p>
</td></tr>
<tr><td><code id="test_data_+3A_p1">p1</code></td>
<td>
<p>The number of covariates that affect the source-specific values to simulate.</p>
</td></tr>
<tr><td><code id="test_data_+3A_p2">p2</code></td>
<td>
<p>The number of covariates that affect the mixture values to simulate.</p>
</td></tr>
<tr><td><code id="test_data_+3A_tau">tau</code></td>
<td>
<p>The variance of the i.i.d. component of variation to add on top of the simulated mixture values.</p>
</td></tr>
<tr><td><code id="test_data_+3A_log_file">log_file</code></td>
<td>
<p>A path to an output log file. Note that if the file <code>log_file</code> already exists then logs will be appended to the end of the file. Set <code>log_file</code> to <code>NULL</code> to prevent output from being saved into a file; note that if <code>verbose == FALSE</code> then no output file will be generated regardless of the value of <code>log_file</code>.</p>
</td></tr>
<tr><td><code id="test_data_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print logs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+tca">tca</a> for details about the TCA model.
</p>


<h3>Value</h3>

<p>A list with the simulated data and parameters.
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>An <code>m</code> by <code>n</code> matrix of simulated data with <code>m</code> features for <code>n</code> observations.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>A list with the simulated source-specific values, where the first element in the list is an <code>m</code> by <code>n</code> matrix (features by observations) corresponding to the values coming from the first source, the second element in the list is another <code>m</code> by <code>n</code> matrix (features by observations) corresponding to the values coming from the second source and so on.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>An <code>n</code> by <code>k</code> matrix of simulated weights - the weights of the <code>k</code> sources for each of the <code>n</code> mixtures (observations).</p>
</td></tr>
<tr><td><code>mus</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of the mean of each of the <code>m</code> features for each of the <code>k</code> sources.</p>
</td></tr>
<tr><td><code>sigmas</code></td>
<td>
<p>An <code>m</code> by <code>k</code> matrix of the standard variation of each of the <code>m</code> features for each of the <code>k</code> sources.</p>
</td></tr>
<tr><td><code>C1</code></td>
<td>
<p> An <code>n</code> by <code>p1</code> design matrix of simulated covariates that affect the hidden source-specific values.</p>
</td></tr>
<tr><td><code>C2</code></td>
<td>
<p> An <code>n</code> by <code>p2</code> design matrix of simulated covariates that affect the mixture.</p>
</td></tr>
<tr><td><code>gammas</code></td>
<td>
<p>An <code>m</code> by <code>k*p1</code> matrix of the effects of the <code>p1</code> covariates in <code>C1</code> on each of the <code>m</code> features in <code>X</code>, where the first <code>p1</code> columns are the source-specific effects of the <code>p1</code> covariates on the first source, the following <code>p1</code> columns are the source-specific effects on the second source and so on.</p>
</td></tr>
<tr><td><code>deltas</code></td>
<td>
<p>An <code>m</code> by <code>p2</code> matrix of the effects of the <code>p2</code> covariates in <code>C2</code> on the mixture values of each of the <code>m</code> features in <code>X</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- test_data(100, 50, 3, 2, 2, 0.01)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
