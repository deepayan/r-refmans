<!DOCTYPE html><html lang="en"><head><title>Help for package optimParallel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optimParallel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#optimParallel'><p>parallel version of the L-BFGS-B method of <code>optim</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallel Version of the L-BFGS-B Optimization Method</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Gerber &lt;flora.fauna.gerber@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a parallel version of the L-BFGS-B method of optim(). The main function of the package is optimParallel(), which has the same usage and output as optim(). Using optimParallel() can significantly reduce the optimization time.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/florafauna/optimParallel-R">https://github.com/florafauna/optimParallel-R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/florafauna/optimParallel-R/issues">https://github.com/florafauna/optimParallel-R/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), stats, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, roxygen2, spam, microbenchmark, testthat, ggplot2,
numDeriv, lbfgsb3c</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-10 18:53:50 UTC; fl</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Gerber <a href="https://orcid.org/0000-0001-8545-5263"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-11 16:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='optimParallel'>parallel version of the L-BFGS-B method of <code><a href="stats.html#topic+optim">optim</a></code></h2><span id='topic+optimParallel'></span><span id='topic+optimparallel'></span><span id='topic+optimParallel-package'></span><span id='topic+optimParallel-Package'></span><span id='topic+OptimParallel-package'></span><span id='topic+OptimParallel-Package'></span><span id='topic+optimparallel-package'></span><span id='topic+optimparallel-Package'></span>

<h3>Description</h3>

<p>The function provides a parallel version of the L-BFGS-B method of <code><a href="stats.html#topic+optim">optim</a></code>.
If the evaluation time of the objective function <code>fn</code> is more than 0.1 sceconds, <code>optimParallel</code> can significantly reduce the optimization time. 
For a <code class="reqn">p</code>-parameter optimization the speed increase is about factor <code class="reqn">1+2p</code> when no analytic gradient is specified and <code class="reqn">1+2p</code> processor cores are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimParallel(
  par,
  fn,
  gr = NULL,
  ...,
  lower = -Inf,
  upper = Inf,
  control = list(),
  hessian = FALSE,
  parallel = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimParallel_+3A_par">par</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_fn">fn</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_gr">gr</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_...">...</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.
See section 'Notes' for more information.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_lower">lower</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_upper">upper</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_control">control</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_hessian">hessian</code></td>
<td>
<p>see the documentation of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="optimParallel_+3A_parallel">parallel</code></td>
<td>
<p>is a list of additional control parameters and can supply any of the following components:
</p>

<dl>
<dt><code>cl</code></dt><dd><p> an object of class <code>"cluster"</code> specifying the cluster to be used for parallel execution.
See <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> for more information.
If the argument is not specified or <code>NULL</code>, the default cluster is used.
See <code><a href="parallel.html#topic+setDefaultCluster">setDefaultCluster</a></code> for information on how to set up a default cluster.</p>
</dd> 
<dt><code>forward</code></dt><dd><p> logical vector of length 1. If <code>FALSE</code> (default when loading the package), a numeric central difference approximation of the gradient defined as
<code class="reqn">(fn(x+\epsilon)-fn(x-\epsilon))/(2\epsilon)</code> is used, which corresponds to the gradient approximation used in <code><a href="stats.html#topic+optim">optim</a></code>.
If <code>TRUE</code>, a numeric forward difference approximation of the gradient essentially defined as
<code class="reqn">(fn(x+\epsilon)-fn(x))/\epsilon</code> is used. This reduces the number of function calls from <code class="reqn">1+2p</code> to <code class="reqn">1+p</code> and can be useful if the number of available cores is smaller than <code class="reqn">1+2p</code> or if the memory limit is reached. Note that the numeric central difference approximation is more accurate than the numeric forward difference approximation.</p>
</dd>
<dt><code>loginfo</code></dt><dd><p> logical vector of length 1 with default value <code>FALSE</code> when loading the package. If <code>TRUE</code>,
additional log information containing the evaluated parameters as well as return values of <code>fn</code> and <code>gr</code> is returned.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code>optimParallel</code> is a wrapper to <code><a href="stats.html#topic+optim">optim</a></code> and relies on the lexical scoping mechanism of R
and the R package <span class="pkg">parallel</span> to evaluate <code>fn</code>
and its (approximate) gradient in parallel.<br /><br />
Some default values of the argument <code>parallel</code> can be set via<br /><code>options("optimParallel.forward", "optimParallel.loginfo")</code>.
</p>


<h3>Value</h3>

<p>Same as the return value of <code><a href="stats.html#topic+optim">optim</a></code>. See the documentation thereof for more information.<br />
If <code>parallel=list(loginfo=TRUE)</code>, additional log information containing the evaluated parameters as well as
the return values of <code>fn</code> and <code>gr</code> is returned.
</p>


<h3>Notes</h3>


<dl>
<dt>1.</dt><dd><p>If <code>fn</code> or <code>gr</code> depend on functions or methods from loaded packages,
it may be necessary to explicitly load those packages in all processes of the cluster.
For <code>cl</code> of class <code>"cluster"</code> one can use <code>clusterEvalQ(cl, search())</code> to check
whether all required packages are on the search paths of all processes.
If, for example, the R package <span class="pkg">spam</span> is required and missing on those search paths,
it can be added via <code>clusterEvalQ(cl, library("spam"))</code>.</p>
</dd> 
<dt>2.</dt><dd><p>If <code>fn</code> or <code>gr</code> have more than one argument,
it may be necessary to pass those to <code>optimParallel</code> via the <code>...</code> argument.
An illustration is given in the section 'Examples'. </p>
</dd>
<dt>3.</dt><dd><p>We recommend that all R objects used by <code>fn</code> and/or <code>gr</code> are passed to <code>fn</code> and/or <code>gr</code> via arguments.
In certain cases it may also work that <code>fn</code> and/or <code>gr</code> use objects from the <code>.GlobalEnv</code> (without having corresponding arguments).
In that case it can be necessary to pass those objects to all processes of the used cluster via <code><a href="parallel.html#topic+clusterExport">clusterExport</a></code>.
An illustration is given in the section 'Examples'.</p>
</dd> 
<dt>4.</dt><dd><p>Using parallel R code inside <code>fn</code> and <code>gr</code> can work if suitable clusters are setup (one cluster for <code>optimParallel</code> and one for the parallel execution of <code>fn</code> and <code>gr</code>).</p>
</dd>
<dt>5.</dt><dd><p>Using <code>optimParallel</code> with <code class="reqn">n</code> parallel processes increases the memory usage by about factor <code class="reqn">n</code> compared to a call to <code><a href="stats.html#topic+optim">optim</a></code>.
If the memory limit is reached this may severely slowdown the optimization.
Strategies to reduce memory usage are
(1) kill all unused processes on the computer,
(2) revise the code of <code>fn</code> and/or <code>gr</code> to reduce its memory usage, and
(3) reduce the number of parallel processes by specifying the argument <code>parallel=list(forward=TRUE)</code> and/or
setting up a cluster with less parallel processes.</p>
</dd>
</dl>



<h3>Issues and bug report</h3>

<p>A list of known issues of <code>optimParallel</code> can be found at <a href="https://github.com/florafauna/optimParallel-R/issues">https://github.com/florafauna/optimParallel-R/issues</a>.
Please report issues not listed there to<code class="reqn">\,</code> <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>. Do not forget to include
an R script reproducing the issue and the output of <code>sessionInfo()</code>.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>, <a href="https://user.math.uzh.ch/gerber">https://user.math.uzh.ch/gerber</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. Furrer (2019)
optimParallel: An R package providing a parallel version of the L-BFGS-B optimization method.
The R Journal, 11(1):352-358, https://doi.org/10.32614/RJ-2019-030
Also available as vignette of this package <code>vignette("optimParallel")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
<code><a href="parallel.html#topic+setDefaultCluster">setDefaultCluster</a></code>,
<code><a href="parallel.html#topic+stopCluster">stopCluster</a></code>,
<code><a href="parallel.html#topic+detectCores">detectCores</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>negll &lt;- function(par, x, sleep=0, verbose=TRUE){
    if(verbose)
        cat(par, "\n")
   Sys.sleep(sleep)
   -sum(dnorm(x=x, mean=par[1], sd=par[2], log=TRUE))
}
set.seed(13); x &lt;- rnorm(1000, 5, 2)

cl &lt;- makeCluster(2)     # set the number of processor cores
setDefaultCluster(cl=cl) # set 'cl' as default cluster

optimParallel(par=c(1,1), fn=negll, x=x, lower=c(-Inf, .0001))

optimParallel(par=c(1,1), fn=negll, x=x, sleep=0, verbose=TRUE,
              lower=c(-Inf, .0001), parallel=list(loginfo=TRUE))

setDefaultCluster(cl=NULL); stopCluster(cl)

## default values of the argument 'parallel':
options("optimParallel.forward", "optimParallel.loginfo")

## Not run: 
## - use all avilable processor cores
## - return cat() output to R prompt
##   (may have issues on Windows)
if(tolower(.Platform$OS.type) != "windows"){
    cl &lt;- makeCluster(spec=detectCores(), type="FORK", outfile="")  
} else
    cl &lt;- makeCluster(spec=detectCores(), outfile="")
setDefaultCluster(cl=cl)

## return log information
options(optimParallel.loginfo=TRUE)              

## stop if change of f(x) is smaller than 0.01
control &lt;- list(factr=.01/.Machine$double.eps)

optimParallel(par=c(1,1), fn=negll, x=x, sleep=.5, verbose=TRUE,
              verbose=TRUE, lower=c(-Inf, .0001), control=control)
## each step invokes 5 parallel calls to negll()

optimParallel(par=c(1,1), fn=negll, x=x, sleep=.5, verbose=TRUE,
              lower=c(-Inf, .0001), control=control,
              parallel=list(forward=TRUE))
## each step invokes 3 parallel calls to negll()

## passing objects to fn/gr (see section 'Notes')
## ----------------------------------------------
a &lt;- 10
fn &lt;- function(par, b) sum((par-a-b)^2)

## approach 1:
clusterExport(cl, "a")
optimParallel(par=1, fn=fn, b=1)

## approach 2 (recommended):
## rewrite 'fn' such that all necessary objects
## are passed as arguments
fn &lt;- function(par, a, b) sum((par-a-b)^2)
optimParallel(par=1, fn=fn, a=20, b=1)

setDefaultCluster(cl=NULL); stopCluster(cl) 
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
