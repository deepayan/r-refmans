<!DOCTYPE html><html><head><title>Help for package RSAtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSAtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#best.rsa'><p>Compare a list of polynomial models against the data</p></a></li>
<li><a href='#best.rsa2'><p>Compare two polynomial models against the data</p></a></li>
<li><a href='#exportRSA.bootstrap'><p>Export bootstrapped parameters of polynomial model</p></a></li>
<li><a href='#exportRSA.fit'><p>Export fit indices and names of polynomials models</p></a></li>
<li><a href='#ident.ext'><p>Probe extrema in the response surface</p></a></li>
<li><a href='#plotting.ext'><p>Plot extrema in the response surface along the lines of congruence and incongruence</p></a></li>
<li><a href='#plotting.rsa'><p>Plots the response surface of a polynomial model of first, second, or third degree</p></a></li>
<li><a href='#RSA_step1'><p>Simulation data on needs-supplies fit processes (STEP1)</p></a></li>
<li><a href='#RSAmodel'><p>Estimate polynomial models for response surface analysis</p></a></li>
<li><a href='#RSAmodel.auxiliary'><p>Estimate a list of polynomial models for RSA, using auxiliary variables in FIML</p></a></li>
<li><a href='#sim_NSfit'><p>Simulation data on needs-supplies fit processes (illustration)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Advanced Response Surface Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Fernando Núñez-Regueiro
    <a href="https://orcid.org/0000-0003-4784-2021"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jacques Juhel <a href="https://orcid.org/0000-0002-3520-6012"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Felix Schönbrodt <a href="https://orcid.org/0000-0002-8282-3910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sarah Humberg <a href="https://orcid.org/0000-0002-7891-3622"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fernando Núñez-Regueiro &lt;fernando.nr.france@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for response surface analysis, using a comparative framework that identifies best-fitting solutions across 37 families of polynomials. Many of these tools are based upon and extend the 'RSA' package, by testing a larger scope of polynomials (+27 families), more diverse response surface probing techniques (+acceleration points), more plots (+line of congruence, +line of incongruence, both with extrema), and other useful functions for exporting results.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields, rgl, qgraph, tcltk, tkrplot, testthat, covr, psych,
ggpubr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), lavaan (&ge; 0.5.20), semTools (&ge; 0.5-5), RSA
(&ge; 0.10.4), ggplot2, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, RColorBrewer, aplpack, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-19 13:34:51 UTC; FerNR</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-19 14:10:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='best.rsa'>Compare a list of polynomial models against the data</h2><span id='topic+best.rsa'></span>

<h3>Description</h3>

<p>Compares any number of predefined or user-specific polynomial models and extracts their fit indices, thereby establishing best-fitting solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.rsa(RSA_object, order = c("wAIC", "R2adj"), robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best.rsa_+3A_rsa_object">RSA_object</code></td>
<td>
<p>x an object of class &quot;RSA_object&quot; generated by RSAmodel()</p>
</td></tr>
<tr><td><code id="best.rsa_+3A_order">order</code></td>
<td>
<p>Single or vector of fit indices used to determine best-fitting polynomial families. The output matrix is ordered based on this fit index</p>
</td></tr>
<tr><td><code id="best.rsa_+3A_robust">robust</code></td>
<td>
<p>Should robust fit indices should be extracted? (default= TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares models based on information-theoretic criteria and statistical tests. The cubic saturated polynomial provides a benchmark reference for fit, against which predefined polynomial families (37 to date) or user-specific variants of these families are compared for absolute fit (likelihood ratio test), parsimony (wAIC), explained variance (adjusted R2), and ordinary SEM criteria (e.g., CFI, TLI, RMSEA, SRMR).
</p>


<h3>Value</h3>

<p>A table containing fit indices for each model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####ESTIMATE RSA OBJECT
RSA_step1 &lt;-  RSAmodel(engagement ~ needs*supplies,
data= sim_NSfit, model= c("CUBIC","FM8_INCONG","FM9_INCONG","FM20_ASYMCONG",
"FM21_ASYMCONG","FM26_PARALLELASYMWEAK"))
##### COMPARE POLYNOMIAL FAMILIES FROM THE RSA OBJECT
RSA_step1_fit &lt;- best.rsa(RSA_step1,order=c("wAIC"))
names(RSA_step1$models)
#Inspect best-fitting family model
summary(RSA_step1$models$FM26_PARALLELASYMWEAK)
</code></pre>

<hr>
<h2 id='best.rsa2'>Compare two polynomial models against the data</h2><span id='topic+best.rsa2'></span>

<h3>Description</h3>

<p>Compare two polynomial models, for example to test parametric constraints in STEP2 of the 3-step identification strategy (see <code><a href="#topic+RSAmodel">RSAmodel</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.rsa2(RSA_object, m1, m2, order = c("wAIC"), robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best.rsa2_+3A_rsa_object">RSA_object</code></td>
<td>
<p>x an object of class &quot;RSA_object&quot; generated by RSAmodel()</p>
</td></tr>
<tr><td><code id="best.rsa2_+3A_m1">m1</code></td>
<td>
<p>First model to be compared (contained in RSA_object$models)</p>
</td></tr>
<tr><td><code id="best.rsa2_+3A_m2">m2</code></td>
<td>
<p>Second model to be compared (contained in RSA_object$models)</p>
</td></tr>
<tr><td><code id="best.rsa2_+3A_order">order</code></td>
<td>
<p>Fit index used to determine best-fitting model.</p>
</td></tr>
<tr><td><code id="best.rsa2_+3A_robust">robust</code></td>
<td>
<p>A boolean stating whether robust fit indices should be extracted (default= TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table containing fit indices for each model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Test a variant within a family (e.g., FM26_PARALLELASYMWEAK)
##Define variant as constraints
list_variant &lt;- list()
list_variant[["variant1"]] &lt;- c('
####First-order polynomials: variant-specific			
			b1 == -1/4*b2
####Second-order polynomials: variant-specific			
			b5 == b3/2
			b4 == 0
####Third-order polynomials: FM26_PARALLELASYMWEAK			
			b6 == 0
			b7 == 0
			b9 == b8/-3		
')
RSA_NSfit  &lt;- RSAmodel(formula= engagement ~ needs*supplies,
data= sim_NSfit, model= c("FM26_PARALLELASYMWEAK","USER"),
user_model= list_variant)
##Compare variant to best-fitting family (e.g., LRT_pvalue p &gt; .05)
best.rsa2(RSA_NSfit,m1="variant1",m2="FM26_PARALLELASYMWEAK")[2,1:3]
</code></pre>

<hr>
<h2 id='exportRSA.bootstrap'>Export bootstrapped parameters of polynomial model</h2><span id='topic+exportRSA.bootstrap'></span>

<h3>Description</h3>

<p>Utilitary function to export bootstrapped parameters, as part of STEP3 of the 3-step identification strategy (see <code>RSAmodel</code>).
Utilitary function to export bootstrapped parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportRSA.bootstrap(RSAbootstrap_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportRSA.bootstrap_+3A_rsabootstrap_object">RSAbootstrap_object</code></td>
<td>
<p>A matrix output generated by lavaan: <code>bootstrapLavaan(RSA_object$models$name_final, FUN="coef")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of mean values and 95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###### Export 95% CI of bootstrapped estimates of polynomial
#Estimate a model: FM26_PARALLELASYMWEAK (simulation data)
RSA_NSfit  &lt;- RSAmodel(formula= engagement ~ needs*supplies,
data= sim_NSfit, model= c("FM26_PARALLELASYMWEAK"))
#Bootstrapped sampling with lavaan
RSA_NSfit_boot  &lt;- lavaan::bootstrapLavaan(RSA_NSfit$models$FM26_PARALLELASYMWEAK,
 R= 10,FUN="coef")
#Export results in a table
RSA_NSfit_boot_exp &lt;- exportRSA.bootstrap(RSA_NSfit_boot)
RSA_NSfit_boot_exp
</code></pre>

<hr>
<h2 id='exportRSA.fit'>Export fit indices and names of polynomials models</h2><span id='topic+exportRSA.fit'></span>

<h3>Description</h3>

<p>Utilitary function to easily export fit indices of polynomial models (predefined or user-specific), including their proper theoretical names (for predefined polynomial families) and the fit indices used for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportRSA.fit(RSAcompare_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportRSA.fit_+3A_rsacompare_object">RSAcompare_object</code></td>
<td>
<p>A list generated by <code>RSAcompare(RSA_object)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of fit indices and names of polynomial families or user model
</p>

<hr>
<h2 id='ident.ext'>Probe extrema in the response surface</h2><span id='topic+ident.ext'></span>

<h3>Description</h3>

<p>Identify reversal or acceleration points (generically called &quot;extrema&quot;) in the LOC or LOIC of the response surface and test how many of them have outcome observations that significantly differ from what would be expected for predictor combinations on these points (that have the same level)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident.ext(
  RSA_object,
  model = NULL,
  acceleration = c(0, 0),
  alpha = 0.05,
  z_tested = "observed",
  alphacorrection = "none",
  n_sample = NULL,
  verbose = TRUE,
  df_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ident.ext_+3A_rsa_object">RSA_object</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_model">model</code></td>
<td>
<p>The model to be probed for extrema (reversal or acceleration points)</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_acceleration">acceleration</code></td>
<td>
<p>Rates of accelerations along the LOC and LOIC to be inspected (0&lt; abs(rate) &lt; 1). Acceleration points will only appear if reversals do not exist, and if acceleration rates exist (if not, a warning will appear).</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for the one-sided confidence interval of the outcome predictions on the extrema</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_z_tested">z_tested</code></td>
<td>
<p>Should significance tests be conducted on &quot;observed&quot; or &quot;predicted&quot; observation</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_alphacorrection">alphacorrection</code></td>
<td>
<p>Set &quot;Bonferroni&quot; to adjust the alpha level for multiple testing when testing the outcome predictions of all data points behind the extrema</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of random draws to consider to find extrema. This option is used for large samples to increase speed in preliminary analyses, but it is not recommended for published results). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_verbose">verbose</code></td>
<td>
<p>Should extra information be printed?</p>
</td></tr>
<tr><td><code id="ident.ext_+3A_df_out">df_out</code></td>
<td>
<p>Number of random draws to consider to find extrema. This option is used for large samples to increase speed in preliminary analyses, but it is not recommended for published results). Defaults to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When testing for reversals or accelerations in nonlinear response surfaces involving quadratic or cubic polynomial families (FM4 to FM37), the <code>RSAextrema</code> function helps to determine the exact location of reversal or acceleration points along the lines of congruenc (LOC) or incongruence (LOIC), and the number and percentage of observations significantly affected by these reversals or accelerations (for a given probability level, alpha). This points are determined according to derivatives of the function according to rationales for combining polynomials (Núñez-Regueiro &amp; Juhel, 2022, 2024).
</p>


<h3>Value</h3>

<p>A table containing the location and percentages of observations above or below extrema
</p>


<h3>References</h3>

<p>Núñez-Regueiro, F., Juhel, J. (2022). <em>Model-Building Strategies in Response Surface Analysis</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2024). <em>Response Surface Analysis for the Social Sciences II: Combinatory Rationales for Complex Polynomial Models</em> Manuscript submitted for publication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotting.ext">plotting.ext</a></code>, <code><a href="#topic+RSAmodel">RSAmodel</a></code>
</p>

<hr>
<h2 id='plotting.ext'>Plot extrema in the response surface along the lines of congruence and incongruence</h2><span id='topic+plotting.ext'></span>

<h3>Description</h3>

<p>Plots the response surface of an RSA object along the lines of congruence (LOC) and incongruence (LOIC), while indicating the location of reversal or acceleration points in the surface (when they exist).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotting.ext(
  RSA_object,
  model,
  acceleration = c(0, 0),
  n_sample = 100,
  names_xLOC = NULL,
  names_xLOIC = NULL,
  names_z = NULL,
  xlim = NULL,
  zlim = NULL,
  e_label = NULL,
  text_size = 1,
  elabel_size = 5,
  e_size = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotting.ext_+3A_rsa_object">RSA_object</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_model">model</code></td>
<td>
<p>The model to be probed for extrema (reversal or acceleration points)</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_acceleration">acceleration</code></td>
<td>
<p>Rates of accelerations along the LOC and LOIC to be inspected (0&lt; |rate| &lt; 1). Passed on internally to <code>ident.ext</code></p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of random draws to consider to find extrema. This option is used for large samples to increase speed in preliminary analyses, but it is not recommended for published results). Passed on internally to <code>ident.ext</code></p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_names_xloc">names_xLOC</code></td>
<td>
<p>Label of x axis on the LOC plot.</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_names_xloic">names_xLOIC</code></td>
<td>
<p>Label of x axis on the LOIC plot.</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_names_z">names_z</code></td>
<td>
<p>Label of z axis (outcome).</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x axis</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_zlim">zlim</code></td>
<td>
<p>Limits of the z axis</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_e_label">e_label</code></td>
<td>
<p>If &quot;none&quot;, no coordinates are projected. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_text_size">text_size</code></td>
<td>
<p>Text size for titles and labels.</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_elabel_size">elabel_size</code></td>
<td>
<p>Text size for extrema coordinates.</p>
</td></tr>
<tr><td><code id="plotting.ext_+3A_e_size">e_size</code></td>
<td>
<p>Point size of extrema.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lines of congruence (LOC) and incongruence (LOIC) are fundamental to RSA applications. This function allows plotting the response along the LOC and LOIC, thus offering a more precise visualization of the response surface (as a complement to 3d or 2d projections provided by <code>RSAplot</code>). The location of reversal or acceleration points can be provided with x-y-z coordinales or without them (e_label='none').
</p>


<h3>Value</h3>

<p>A list of plot of the lines of congruence (LOC) and incongruence (LOIC)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RSAmodel">RSAmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######PLOT EXTREMA OVER LOC AND LOIC
EXTsim &lt;- plotting.ext(RSA_step1,model="FM26_PARALLELASYMWEAK",
xlim=c(-3,3),zlim=c(-3,3),acceleration=c(0,-0.3),
text_size=0.7,elabel_size=3,e_size=2)
ggpubr::ggarrange(EXTsim[["LOC"]], EXTsim[["LOIC"]],
labels = c("A. Response over LOC", "B. Response over LOIC"),
nrow=1,ncol=2,font.label = list(size = 11))
</code></pre>

<hr>
<h2 id='plotting.rsa'>Plots the response surface of a polynomial model of first, second, or third degree</h2><span id='topic+plotting.rsa'></span><span id='topic+plotting.rsaCOEF'></span>

<h3>Description</h3>

<p>Plots the response surface of a model based on polynomial families (37 families), saturated polynomials, or user-specific polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotting.rsaCOEF(
  x = 0,
  y = 0,
  x2 = 0,
  y2 = 0,
  xy = 0,
  w = 0,
  wx = 0,
  wy = 0,
  x3 = 0,
  xy2 = 0,
  x2y = 0,
  y3 = 0,
  b0 = 0,
  type = "3d",
  model = "CUBIC",
  acceleration = c(0, 0),
  FAST = TRUE,
  n_sample = 100,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  main = "",
  surface = "predict",
  lambda = NULL,
  suppress.surface = FALSE,
  suppress.box = FALSE,
  suppress.grid = FALSE,
  suppress.ticklabels = FALSE,
  rotation = list(x = -63, y = 32, z = 15),
  label.rotation = list(x = 19, y = -40, z = 92),
  gridsize = 21,
  bw = FALSE,
  legend = TRUE,
  param = TRUE,
  coefs = FALSE,
  axes = c("LOC", "LOIC", "r1_LOC", "r2_LOC", "r1_LOIC", "r2_LOIC", "a1_LOC", "a2_LOC",
    "a1_LOIC", "a2_LOIC"),
  axesStyles = list(LOC = list(lty = "solid", lwd = 2, col = ifelse(bw == TRUE,
    "black", "blue")), LOIC = list(lty = "solid", lwd = 2, col = ifelse(bw == TRUE,
    "black", "blue")), PA1 = list(lty = "dotted", lwd = 2, col = ifelse(bw == TRUE,
    "black", "gray30")), PA2 = list(lty = "dotted", lwd = 2, col = ifelse(bw == TRUE,
    "black", "gray30")), r1_LOC = list(lty = "solid", lwd = 2, col = ifelse(bw == TRUE,
    "black", "green")), r2_LOC = list(lty = "solid", lwd = 2, col = ifelse(bw == TRUE,
    "black", "green")), r1_LOIC = list(lty = "solid",      lwd = 2, col = ifelse(bw ==
    TRUE, "black", "red")), r2_LOIC = list(lty = "solid", lwd = 2, col = ifelse(bw ==
    TRUE, "black", "red")), a1_LOC = list(lty = "twodash", lwd = 2, col = ifelse(bw ==
    TRUE, "black", "green")), a2_LOC = list(lty = "twodash", lwd = 2, col = ifelse(bw ==
    TRUE, "black", "green")), a1_LOIC = list(lty = "twodash", lwd = 2, col = ifelse(bw ==
    TRUE, "black", "red")), a2_LOIC = list(lty = "twodash", lwd = 2, col = ifelse(bw ==
    TRUE, "black", "red"))),
  project = c("contour"),
  maxlines = FALSE,
  cex.tickLabel = 1,
  cex.axesLabel = 1,
  cex.main = 1,
  points = list(data = NULL, n_random = NULL, show = NA, value = "raw", jitter = 0,
    color = "black", cex = 0.5, out.mark = FALSE),
  fit = NULL,
  link = "identity",
  tck = c(1.5, 1.5, 1.5),
  distance = c(1.3, 1.3, 1.4),
  border = FALSE,
  contour = list(show = FALSE, color = "grey40", highlight = c()),
  hull = NA,
  showSP = FALSE,
  showSP.CI = FALSE,
  pal = NULL,
  pal.range = "box",
  pad = 0,
  claxes.alpha = 0.05,
  demo = FALSE,
  ...
)

plotting.rsa(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotting.rsa_+3A_x">x</code></td>
<td>
<p>Either an RSA object (returned by the <code>RSAmodel</code> function), or the coefficient for the X predictor</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_y">y</code></td>
<td>
<p>Y coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_x2">x2</code></td>
<td>
<p>X^2 coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_y2">y2</code></td>
<td>
<p>Y^2 coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_xy">xy</code></td>
<td>
<p>XY interaction coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_w">w</code></td>
<td>
<p>W coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_wx">wx</code></td>
<td>
<p>WX coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_wy">wy</code></td>
<td>
<p>WY coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_x3">x3</code></td>
<td>
<p>X^3 coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_xy2">xy2</code></td>
<td>
<p>XY^2 coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_x2y">x2y</code></td>
<td>
<p>X^2Y coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_y3">y3</code></td>
<td>
<p>Y^3 coefficient</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_b0">b0</code></td>
<td>
<p>Intercept</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_type">type</code></td>
<td>
<p><code>3d</code> for 3d surface plot, <code>2d</code> for 2d contour plot, &quot;interactive&quot; for interactive rotatable plot.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_model">model</code></td>
<td>
<p>If x is an RSA object: from which model should the response surface be computed?</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_acceleration">acceleration</code></td>
<td>
<p>Rates of accelerations along the LOC and LOIC to be inspected (0&lt; |rate| &lt; 1). Passed on internally to <code>ident.ext</code></p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_fast">FAST</code></td>
<td>
<p>If FALSE, will also project response over LOC and LOIC. If TRUE, will only project the response surface (faster option).</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of random draws to consider to find extrema. This option is used for large samples to increase speed in preliminary analyses, but it is not recommended for published results). Passed on internally to <code>ident.ext</code></p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x axis</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the y axis</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_zlim">zlim</code></td>
<td>
<p>Limits of the z axis</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_xlab">xlab</code></td>
<td>
<p>Label for x axis</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_zlab">zlab</code></td>
<td>
<p>Label for z axis</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_surface">surface</code></td>
<td>
<p>Method for the calculation of the surface z values. &quot;predict&quot; takes the predicted values from the model, &quot;smooth&quot; uses a thin plate smoother (function <code>Tps</code> from the <code>fields</code> package) of the raw data</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_lambda">lambda</code></td>
<td>
<p>lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_suppress.surface">suppress.surface</code></td>
<td>
<p>Should the surface be suppressed (only for <code>type="3d"</code>)? Useful for only showing the data points, or for didactic purposes (e.g., first show the cube, then fade in the surface).</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_suppress.box">suppress.box</code></td>
<td>
<p>Should the surrounding box be suppressed (only for <code>type="3d"</code>)?</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_suppress.grid">suppress.grid</code></td>
<td>
<p>Should the grid lines be suppressed (only for <code>type="3d"</code>)?</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_suppress.ticklabels">suppress.ticklabels</code></td>
<td>
<p>Should the numbers on the axes be suppressed (only for <code>type="3d"</code>)?</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_rotation">rotation</code></td>
<td>
<p>Rotation of the 3d surface plot (when type == &quot;3d&quot;)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_label.rotation">label.rotation</code></td>
<td>
<p>Rotation of the axis labls (when type == &quot;3d&quot;)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_gridsize">gridsize</code></td>
<td>
<p>Number of grid nodes in each dimension</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_bw">bw</code></td>
<td>
<p>Print surface in black and white instead of colors?</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_legend">legend</code></td>
<td>
<p>Print color legend for z values?</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_param">param</code></td>
<td>
<p>Should the surface parameters a1 to a5 be shown on the plot? In case of a 3d plot a1 to a5 are printed on top of the plot; in case of a contour plot the principal axes are plotted. Surface parameters are not printed for cubic surfaces.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_coefs">coefs</code></td>
<td>
<p>Should the regression coefficients b1 to b5 (b1 to b9 for cubic models) be shown on the plot? (Only for 3d plot)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_axes">axes</code></td>
<td>
<p>*A vector of strings specifying the axes that should be plotted. Can be any combination of c(&quot;LOC&quot;, &quot;LOIC&quot;,&quot;r1_LOC&quot;,&quot;r2_LOC&quot;,&quot;r1_LOIC&quot;,&quot;r2_LOIC&quot;,&quot;a1_LOC&quot;,&quot;a2_LOC&quot;,&quot;a1_LOIC&quot;,&quot;a2_LOIC&quot;). LOC = line of congruence, LOIC = line of incongruence, r1_LOC = first reversal point on LOC,r2_LOC = second reversal point on LOC,r1_LOIC = first reversal point on LOIC,r2_LOIC = second reversal point on LOIC,a1_LOC = first acceleration point on LOC,a2_LOC = second acceleration point on LOC,a1_LOIC = first acceleration point on LOIC,a2_LOIC = second acceleration point on LOIC.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_axesstyles">axesStyles</code></td>
<td>
<p>*Define the visual styles of the axes LOC,LOIC,r1_LOC,r2_LOC,r1_LOIC,r2_LOIC,a1_LOC,a2_LOC,a1_LOIC,a2_LOIC. Provide a named list: <code>axesStyles=list(LOC = list(lty="solid",  lwd=2, col=ifelse(bw==TRUE, "black", "blue"))</code>. It recognizes three parameters: <code>lty</code>, <code>lwd</code>, and <code>col</code>. If you define a style for an axis, you have to provide all three parameters, otherwise a warning will be shown.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_project">project</code></td>
<td>
<p>*A vector of graphic elements that should be projected on the floor of the cube. Can include any combination of c(&quot;LOC&quot;, &quot;LOIC&quot;, &quot;contour&quot;, &quot;points&quot;). Note that projected elements are plotted in the order given in the vector (first elements are plotted first and overplotted by later elements).</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_maxlines">maxlines</code></td>
<td>
<p>Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type=&quot;3d&quot;</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_cex.ticklabel">cex.tickLabel</code></td>
<td>
<p>Font size factor for tick labels</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_cex.axeslabel">cex.axesLabel</code></td>
<td>
<p>Font size factor for axes labels</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_cex.main">cex.main</code></td>
<td>
<p>Factor for main title size</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_points">points</code></td>
<td>
<p>A list of parameters which define the appearance of the raw scatter points: 
</p>

<ul>
<li><p> data: Data frame which contains the coordinates of the raw data points. First column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object
</p>
</li>
<li><p> n_random *Number of randomly drawn data points to be plotted from data. Used to avoid cluttering in large datasets.
</p>
</li>
<li><p> show = TRUE: Should the original data points be overplotted?
</p>
</li>
<li><p> color = &quot;black&quot;: Color of the points. Either a single value for all points, or a vector with the same size as data points provided. If parameter <code>fill</code> is also defined, <code>color</code> refers to the border of the points.
</p>
</li>
<li><p> fill = NULL: Fill of the points. Either a single value for all points, or a vector with the same size as data points provided. As a default, this is set to NULL, which means that all points simply have the color <code>color</code>.
</p>
</li>
<li><p> value=&quot;raw&quot;: Plot the original z value, &quot;predicted&quot;: plot the predicted z value
</p>
</li>
<li><p> jitter = 0: Amount of jitter for the raw data points. For z values, a value of 0.005 is reasonable
</p>
</li>
<li><p> cex = .5: multiplication factor for point size. Either a single value for all points, or a vector with the same size as data points provided.
</p>
</li>
<li><p> stilt: Should stilts be drawn for selected data points (i.e., lines from raw data points to the floor)? A logical vector with the same size as data points provided, indicating which points should get a stilt.
</p>
</li>
<li><p> out.mark = FALSE: If set to TRUE, outliers according to Bollen &amp; Jackman (1980) are printed as red X symbols, but only when they have been removed in the RSA function: <code>RSAmodel(..., out.rm=TRUE)</code>.
</p>

<ul>
<li><p> If out.rm == TRUE (in RSAmodel()) and out.mark == FALSE (in plotting.rsa()), the outlier is removed from the model and *not plotted* in RSAplot.
</p>
</li>
<li><p> If out.rm == TRUE (in RSAmodel()) and out.mark == TRUE (in plotting.rsa()), the outlier is removed from the model but plotted and marked in RSAplot.
</p>
</li>
<li><p> If out.rm == FALSE (in RSAmodel()): Outliers are not removed and cannot be plotted.
</p>
</li>
<li><p> Example syntax: <code>plotting.rsa(r1, points=list(show=TRUE, out.mark=TRUE))</code>
</p>
</li></ul>

</li></ul>

<p>As a shortcut, you can also set <code>points=TRUE</code> to set the defaults.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_fit">fit</code></td>
<td>
<p>Do not change that parameter (internal use only)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_link">link</code></td>
<td>
<p>Link function to transform the z axes. Implemented are &quot;identity&quot; (no transformation; default), &quot;probit&quot;, and &quot;logit&quot;</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_tck">tck</code></td>
<td>
<p>A vector of three values defining the position of labels to the axes (see ?wireframe)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_distance">distance</code></td>
<td>
<p>A vector of three values defining the distance of labels to the axes</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_border">border</code></td>
<td>
<p>Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting <code>border=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_contour">contour</code></td>
<td>
<p>A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for <code>type="3d"</code>). color = &quot;grey40&quot;: Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_hull">hull</code></td>
<td>
<p>Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, &amp; Tukey (1999).</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_showsp">showSP</code></td>
<td>
<p>Plot the stationary point? (only relevant for <code>type="contour"</code>)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_showsp.ci">showSP.CI</code></td>
<td>
<p>Plot the CI of the stationary point? (only relevant for <code>type="contour"</code>)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_pal">pal</code></td>
<td>
<p>A palette for shading.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_pal.range">pal.range</code></td>
<td>
<p>Should the color range be scaled to the box (<code>pal.range = "box"</code>, default), or to the min and max of the surface (<code>pal.range = "surface"</code>)? If set to &quot;box&quot;, different surface plots can be compared along their color, as long as the zlim is the same for both.</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_pad">pad</code></td>
<td>
<p>Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_claxes.alpha">claxes.alpha</code></td>
<td>
<p>Alpha level that is used to determine the axes K1 and K2 that demarcate the regions of significance for the cubic models &quot;CL&quot; and &quot;RRCL&quot;</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_demo">demo</code></td>
<td>
<p>Do not change that parameter (internal use only)</p>
</td></tr>
<tr><td><code id="plotting.rsa_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the plotting function (e.g., sub=&quot;Title&quot;). A useful title might be the R squared of the plotted model: <code>sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="CUBIC"), 3))))</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the response surface in 3D or 2D. The function was adapted from the function plot.RSA (RSA package), by adding features for new polynomial families (+27 families, +user-specific polynomial) and new curvature probing tests (+accelerations, +LOIC extrema; Núñez-Regueiro &amp; Juhel, 2022, 2024b). When curvatures are found, lines are projected that intersect inflection points (i.e., reversal or acceleration points) along the lines of congruence (x=y; in green) and incongruence (x=-y; in red), following derivatives of response curvatures (Núñez-Regueiro &amp; Juhel, 2024a).
</p>


<h3>Value</h3>

<p>A plot of the response surface
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2022). <em>Model-Building Strategies in Response Surface Analysis</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2024a). <em>Response Surface Analysis for the Social Sciences I: Identifying Best-Fitting Polynomial Solutions</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2024b). <em>Response Surface Analysis for the Social Sciences II: Combinatory Rationales for Complex Polynomial Models</em> Manuscript submitted for publication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotting.ext">plotting.ext</a></code>, <code><a href="#topic+RSAmodel">RSAmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######PLOT RESPONSE SURFACE OF FM26_PARALLELASYMWEAK
PLOTsim3D &lt;- plotting.rsa(RSA_step1,model="FM26_PARALLELASYMWEAK",type="3d",
acceleration=c(0,-0.3),points=list(show=TRUE, value="predicted"),
legend = FALSE,distance = c(1.2, 1.2, 1.2),cex.tickLabel = 0.6,
cex.axesLabel = 0.8,xlim=c(-3,3),ylim=c(-3,3),zlim=c(-3,3),hull=FALSE)
PLOTsim3D 
</code></pre>

<hr>
<h2 id='RSA_step1'>Simulation data on needs-supplies fit processes (STEP1)</h2><span id='topic+RSA_step1'></span>

<h3>Description</h3>

<p>An object of class &quot;RSA&quot; containing estimates of all polynomial families, 
obtained by passing the function <code>RSAmodel(formula= engagement ~ needs*supplies,
data= sim_NSfit, model= c("CUBIC","STEP1"))</code>. Used to illustrate functions.
</p>


<h3>Author(s)</h3>

<p>Fernando Núñez-Regueiro 
<a href="mailto:fernando.nr.france@gmail.com">fernando.nr.france@gmail.com</a>
</p>

<hr>
<h2 id='RSAmodel'>Estimate polynomial models for response surface analysis</h2><span id='topic+RSAmodel'></span>

<h3>Description</h3>

<p>Estimates 37 polynomial families (&quot;STEP1&quot;) or user-specific polynomial models (&quot;USER&quot;) for use in response surface analysis, based on a 3-step identification strategy (Núñez-Regueiro &amp; Juhel, 2022, 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSAmodel(
  formula,
  data = NULL,
  center = "none",
  scale = "none",
  na.rm = FALSE,
  out.rm = TRUE,
  breakline = FALSE,
  models = c("CUBIC", "STEP1"),
  user_model = NULL,
  verbose = TRUE,
  add = "",
  estimator = "MLR",
  se = "robust",
  missing = NA,
  control.variables = NULL,
  center.control.variables = FALSE,
  sampling.weights = NULL,
  group_name = NULL,
  cluster = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSAmodel_+3A_formula">formula</code></td>
<td>
<p>A formula in the form <code>z ~ x*y</code>, specifying the variable names used from the data frame, where z is the name of the response variable, and x and y are the names of the predictor variables.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_data">data</code></td>
<td>
<p>A data frame with the variables</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_center">center</code></td>
<td>
<p>Method for centering the predictor variables before the analysis. Default option (&quot;none&quot;) applies no centering. &quot;pooled&quot; centers the predictor variables on their <em>pooled</em> sample mean. &quot;variablewise&quot; centers the predictor variables on <em>their respective</em> sample mean. You should think carefully before applying the &quot;variablewise&quot; option, as centering or reducing the predictor variables on common values (e.g., their grand means and SDs) can affect the commensurability of the predictor scales.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_scale">scale</code></td>
<td>
<p>Method for scaling the predictor variables before the analysis. Default option (&quot;none&quot;) applies no scaling. &quot;pooled&quot; scales the predictor variables on their <em>pooled</em> sample SD, which preserves the commensurability of the predictor scales. &quot;variablewise&quot; scales the predictor variables on <em>their respective</em> sample SD. You should think carefully before applying the &quot;variablewise&quot; option, as scaling the predictor variables at different values (e.g., their respective SDs) can affect the commensurability of the predictor scales.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove missings before proceeding?</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_out.rm">out.rm</code></td>
<td>
<p>Should outliers according to Bollen &amp; Jackman (1980) criteria be excluded from the analyses? In large data sets this analysis is the speed bottleneck. If you are sure that no outliers exist, set this option to FALSE for speed improvements.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_breakline">breakline</code></td>
<td>
<p>Should the breakline in the unconstrained absolute difference model be allowed (the breakline is possible from the model formulation, but empirically rather unrealistic ...). Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_models">models</code></td>
<td>
<p>A vector with names of all models that should be computed. Should be any from <code>c("CUBIC","FM1_ONLYX","FM2_ONLYY","FM3_ADDITIVE","FM4_INTER","FM5_QUADX","FM6_QUADY","FM7_CONG","FM8_INCONG","FM9_CURVCONGX","FM10_CURVCONGY","FM11_CURVINCONGX","FM12_CURVINCONGY","FM13_QUADXQUADY","FM14_ROTCONG","FM15_ROTINCONG","FM16_CUBICX","FM17_CUBICY","FM18_LEVDEPQUADX","FM19_LEVDEPQUADY","FM20_ASYMCONG","FM21_ASYMINCONG","FM22_LEVDEPCONG","FM23_LEVDEPINCONG","FM24_PARALLELASYM","FM25_NONPARALLELASYM","FM26_PARALLELASYMWEAK","FM27_PARALLELASYMSTRONG","FM28_NONPARALLELASYMWEAK","FM29_NONPARALLELASYMSTRONG","FM30_ASYMCONGROTY","FM31_ASYMCONGROTX","FM32_ASYMINCONGROTY","FM33_ASYMINCONGROTX","FM34_LEVDEPCONGROTY","FM35_LEVDEPCONGROTX","FM36_LEVDEPINCONGROTY","FM37_LEVDEPINCONGROTX")</code>. For <code>models="STEP1"</code>, all polynomial families and the saturated cubic are computed (default), for <code>models="USER"</code> all user-specific models defined in the list &quot;user_model&quot; are computed.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_user_model">user_model</code></td>
<td>
<p>A list of user-specified polynomial models, defined by setting constraints on the polynomial parameters b1 to b9, using lavaan syntax (e.g., &quot;b1 == 2*b2&quot;). Only parametric constraints are allowed.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_verbose">verbose</code></td>
<td>
<p>Should additional information during the computation process be printed?</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_add">add</code></td>
<td>
<p>Additional syntax that is added to the lavaan model. Can contain, for example, additional constraints, like &quot;p01 == 0; p11 == 0&quot;</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator that should be used by lavaan. Defaults to &quot;MLR&quot;, which provides robust standard errors, a robust scaled test statistic, and can handle missing values. If you want to reproduce standard OLS estimates, use <code>estimator="ML"</code> and <code>se="standard"</code></p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_se">se</code></td>
<td>
<p>Type of standard errors. This parameter gets passed through to the <code>sem</code> function of the <code>lavaan</code> package. See options there. By default, robust SEs are computed. If you use <code>se="boot"</code>, <code>lavaan</code> provides CIs and p-values based on the bootstrapped standard error. If you use <code>confint(..., method="boot")</code>, in contrast, you get CIs and p-values based on percentile bootstrap.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_missing">missing</code></td>
<td>
<p>Handling of missing values (this parameter is passed to the <code>lavaan</code> <code>sem</code> function). By default (<code>missing=NA</code>), Full Information Maximum Likelihood (FIML) is employed in case of missing values. If cases with missing values should be excluded, use <code>missing = "listwise"</code>.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_control.variables">control.variables</code></td>
<td>
<p>A string vector with variable names from <code>data</code>. These variables are added as linear predictors to the model (in order &quot;to control for them&quot;). No interactions with the other variables are modeled.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_center.control.variables">center.control.variables</code></td>
<td>
<p>Should the control variables be centered before analyses? This can improve interpretability of the intercept, which will then reflect the predicted outcome value at the point (X,Y)=(0,0) when all control variables take their respective <em>average</em> values.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>Name of variable containing sampling weights. Needs to be added here (not in ...) to be included in the analysis dataset.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_group_name">group_name</code></td>
<td>
<p>Name of variable defining groups, for multigroup modeling.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_cluster">cluster</code></td>
<td>
<p>Name of variable for clusters, for cluster-level variance correction.</p>
</td></tr>
<tr><td><code id="RSAmodel_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code><a href="lavaan.html#topic+sem">sem</a> </code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a comparative framework for identifying best-fitting RSA solutions (Núñez-Regueiro &amp; Juhel, 2022, 2024). The default feature (&quot;STEP1&quot;) involves the comparison of 37 polynomial families predefined by parametric constraints, to identify likely candidates for best-fitting solution. Step 2 involves probing variants within the retained best-fitting family, by testing user-specific constraints (&quot;USER&quot;) on lower-order polynomials that do not define the family. Step 3 (optional) can be conducted on the final variant by bootstrapping validation (using <code>bootstrapLavaan(RSA_object$models$name_final, FUN="coef")</code>, see examples) or cross-validation data.
</p>


<h3>Value</h3>

<p>A list of objects containing polynomials models and names of variables
</p>


<h3>References</h3>

<p>Núñez-Regueiro, F., Juhel, J. (2022). <em>Model-Building Strategies in Response Surface Analysis.</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2024). <em>Response Surface Analysis for the Social Sciences I: Identifying Best-Fitting Polynomial Solutions.</em> Manuscript submitted for publication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotting.rsa">plotting.rsa</a></code>, <code><a href="#topic+plotting.ext">plotting.ext</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###Simulation data from RSAtools
summary(sim_NSfit)

##### STEP 1: Estimate and compare polynomial families
##NB: to estimate all families, use "STEP1" in the "model" option
RSA_step1 &lt;-  RSAmodel(engagement ~ needs*supplies,
data= sim_NSfit, model= c("CUBIC","FM20_ASYMCONG",
"FM21_ASYMINCONG","FM26_PARALLELASYMWEAK"))
names(RSA_step1$models)
##Compare solutions according to parsimony (wAIC=Akaike weight)
RSA_step1_fit &lt;- best.rsa(RSA_step1,order=c("wAIC"))
head(RSA_step1_fit)
##Inspect best-fitting family model
summary(RSA_step1$models$FM26_PARALLELASYMWEAK)

##### STEP 2: Test variant within best-fitting family
##Define variant as constraints
list_variant &lt;- list()
list_variant[["variant1"]] &lt;- c('
####First-order polynomials: variant-specific			
			b1 == -1/4*b2
####Second-order polynomials: variant-specific			
			b5 == b3/2
			b4 == 0
####Third-order polynomials: define family FM26			
			b6 == 0
			b7 == 0
			b9 == b8/-3		
')
RSA_NSfit_Step2  &lt;- RSAmodel(formula= engagement ~ needs*supplies,
data= sim_NSfit, model= c("FM26_PARALLELASYMWEAK","USER"),
user_model= list_variant)
##Compare variant to best-fitting family (e.g., LRT_pvalue p &gt; .05)
best.rsa2(RSA_NSfit_Step2,m1="variant1",m2="FM26_PARALLELASYMWEAK")[2,1:3]

######PROBE RESPONSE SURFACE EXTREMA: see ident.ext()

######PLOT RESPONSE SURFACE: see plotting.rsa, plotting.ext

</code></pre>

<hr>
<h2 id='RSAmodel.auxiliary'>Estimate a list of polynomial models for RSA, using auxiliary variables in FIML</h2><span id='topic+RSAmodel.auxiliary'></span>

<h3>Description</h3>

<p>Estimate any number of predefined or user-specific polynomial models, using auxiliary variables for missing data treatment by full information maximum likelihood (Graham, 2003). Based on the semTools function <code>sem.auxiliary</code>. Works in the same way as <code>RSAmodel</code>, only differing by the addition of the auxiliary variable option (&quot;aux&quot; option).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSAmodel.auxiliary(
  formula,
  data = NULL,
  aux = NULL,
  center = "none",
  scale = "none",
  na.rm = FALSE,
  out.rm = TRUE,
  breakline = FALSE,
  models = c("CUBIC", "STEP1"),
  user_model = NULL,
  verbose = TRUE,
  add = "",
  estimator = "MLR",
  se = "robust",
  missing = NA,
  control.variables = NULL,
  center.control.variables = FALSE,
  sampling.weights = NULL,
  group_name = NULL,
  cluster = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSAmodel.auxiliary_+3A_formula">formula</code></td>
<td>
<p>A formula in the form <code>z ~ x*y</code>, specifying the variable names used from the data frame, where z is the name of the response variable, and x and y are the names of the predictor variables.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_data">data</code></td>
<td>
<p>A data frame with the variables</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_aux">aux</code></td>
<td>
<p><code>character</code>. Names of auxiliary variables to add to <code>model</code>. Passed on internally to <code>sem.auxiliary</code> (semTools package)</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_center">center</code></td>
<td>
<p>Method for centering the predictor variables before the analysis. Default option (&quot;none&quot;) applies no centering. &quot;pooled&quot; centers the predictor variables on their <em>pooled</em> sample mean. &quot;variablewise&quot; centers the predictor variables on <em>their respective</em> sample mean. You should think carefully before applying the &quot;variablewise&quot; option, as centering or reducing the predictor variables on common values (e.g., their grand means and SDs) can affect the commensurability of the predictor scales.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_scale">scale</code></td>
<td>
<p>Method for scaling the predictor variables before the analysis. Default option (&quot;none&quot;) applies no scaling. &quot;pooled&quot; scales the predictor variables on their <em>pooled</em> sample SD, which preserves the commensurability of the predictor scales. &quot;variablewise&quot; scales the predictor variables on <em>their respective</em> sample SD. You should think carefully before applying the &quot;variablewise&quot; option, as scaling the predictor variables at different values (e.g., their respective SDs) can affect the commensurability of the predictor scales.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove missings before proceeding?</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_out.rm">out.rm</code></td>
<td>
<p>Should outliers according to Bollen &amp; Jackman (1980) criteria be excluded from the analyses? In large data sets this analysis is the speed bottleneck. If you are sure that no outliers exist, set this option to FALSE for speed improvements.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_breakline">breakline</code></td>
<td>
<p>Should the breakline in the unconstrained absolute difference model be allowed (the breakline is possible from the model formulation, but empirically rather unrealistic ...). Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_models">models</code></td>
<td>
<p>A vector with names of all models that should be computed. Should be any from <code>c("CUBIC","FM1_ONLYX","FM2_ONLYY","FM3_ADDITIVE","FM4_INTER","FM5_QUADX","FM6_QUADY","FM7_CONG","FM8_INCONG","FM9_CURVCONGX","FM10_CURVCONGY","FM11_CURVINCONGX","FM12_CURVINCONGY","FM13_QUADXQUADY","FM14_ROTCONG","FM15_ROTINCONG","FM16_CUBICX","FM17_CUBICY","FM18_LEVDEPQUADX","FM19_LEVDEPQUADY","FM20_ASYMCONG","FM21_ASYMINCONG","FM22_LEVDEPCONG","FM23_LEVDEPINCONG","FM24_PARALLELASYM","FM25_NONPARALLELASYM","FM26_PARALLELASYMWEAK","FM27_PARALLELASYMSTRONG","FM28_NONPARALLELASYMWEAK","FM29_NONPARALLELASYMSTRONG","FM30_ASYMCONGROTY","FM31_ASYMCONGROTX","FM32_ASYMINCONGROTY","FM33_ASYMINCONGROTX","FM34_LEVDEPCONGROTY","FM35_LEVDEPCONGROTX","FM36_LEVDEPINCONGROTY","FM37_LEVDEPINCONGROTX")</code>. For <code>models="STEP1"</code>, all polynomial families and the saturated cubic are computed (default), for <code>models="USER"</code> all user-specific models defined in the list &quot;user_model&quot; are computed.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_user_model">user_model</code></td>
<td>
<p>A list of user-specified polynomial models, defined by setting constraints on the polynomial parameters b1 to b9, using the syntax in lavaan, for example: &quot;b1 == 2*b2&quot;. Only parametric constraints specifications are allowed.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_verbose">verbose</code></td>
<td>
<p>Should additional information during the computation process be printed?</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_add">add</code></td>
<td>
<p>Additional syntax that is added to the lavaan model. Can contain, for example, additional constraints, like &quot;p01 == 0; p11 == 0&quot;</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator that should be used by lavaan. Defaults to &quot;MLR&quot;, which provides robust standard errors, a robust scaled test statistic, and can handle missing values. If you want to reproduce standard OLS estimates, use <code>estimator="ML"</code> and <code>se="standard"</code></p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_se">se</code></td>
<td>
<p>Type of standard errors. This parameter gets passed through to the <code>sem</code> function of the <code>lavaan</code> package. See options there. By default, robust SEs are computed. If you use <code>se="boot"</code>, <code>lavaan</code> provides CIs and p-values based on the bootstrapped standard error. If you use <code>confint(..., method="boot")</code>, in contrast, you get CIs and p-values based on percentile bootstrap.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_missing">missing</code></td>
<td>
<p>Handling of missing values (this parameter is passed to the <code>lavaan</code> <code>sem</code> function). By default (<code>missing=NA</code>), Full Information Maximum Likelihood (FIML) is employed in case of missing values. If cases with missing values should be excluded, use <code>missing = "listwise"</code>.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_control.variables">control.variables</code></td>
<td>
<p>A string vector with variable names from <code>data</code>. These variables are added as linear predictors to the model (in order &quot;to control for them&quot;). No interactions with the other variables are modeled.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_center.control.variables">center.control.variables</code></td>
<td>
<p>Should the control variables be centered before analyses? This can improve interpretability of the intercept, which will then reflect the predicted outcome value at the point (X,Y)=(0,0) when all control variables take their respective <em>average</em> values.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>Name of variable containing sampling weights. Needs to be added here (not in ...) to be included in the analysis dataset.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_group_name">group_name</code></td>
<td>
<p>Name of variable defining groups, for multigroup modeling.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_cluster">cluster</code></td>
<td>
<p>Name of variable for clusters, for cluster-level variance correction.</p>
</td></tr>
<tr><td><code id="RSAmodel.auxiliary_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code><a href="semTools.html#topic+sem.auxiliary">sem.auxiliary</a> </code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a comparative framework for identifying best-fitting RSA solutions (Núñez-Regueiro &amp; Juhel, 2022, 2024). The default feature (&quot;STEP1&quot;) involves the comparison of 37 polynomial families predefined by parametric constraints (against 10 families in the RSA package), to identify likely candidates for best-fitting solution. Step 2 involves probing variants within the retained best-fitting family, by testing user-specific constraints (&quot;USER&quot;) on lower-order polynomials that do not define the family. Step 3 can be conducted on the final variant by parametric bootstrapping using <code>bootstrapLavaan(RSA_object$models$name_final, FUN="coef")</code> or cross-validation data.
</p>


<h3>Value</h3>

<p>A list of objects containing polynomials models and names of variables
</p>


<h3>References</h3>

<p>Graham, J. W. (2003). Adding missing-data-relevant variables to FIML-based structural equation models. <em>Structural Equation Modeling, 10</em>(1), 80-100, DOI:10.1207/S15328007SEM1001_4
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2022). <em>Model-Building Strategies in Response Surface Analysis</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2024). <em>Response Surface Analysis for the Social Sciences I: Identifying Best-Fitting Polynomial Solutions</em> Manuscript submitted for publication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RSAmodel">RSAmodel</a></code>, <code><a href="semTools.html#topic+sem.auxiliary">sem.auxiliary</a></code>
</p>

<hr>
<h2 id='sim_NSfit'>Simulation data on needs-supplies fit processes (illustration)</h2><span id='topic+sim_NSfit'></span>

<h3>Description</h3>

<p>Simulation data on needs-supplies fit processes in the context of student engagement at school (N= 500). For example, this could relate to needs and supplies in teacher autonomy support (Núñez-Regueiro et al., 2024a, 2024b) or in school environment characteristics (Fraser &amp; Rentoul, 1980). The data was simulated to reflect a parallel asymmetric weak congruence and strong incongruence effect (polynomial family 26; Núñez-Regueiro et al., 2022, 2024c)
</p>


<h3>Author(s)</h3>

<p>Fernando Núñez-Regueiro 
<a href="mailto:fernando.nr.france@gmail.com">fernando.nr.france@gmail.com</a>
</p>


<h3>References</h3>

<p>Fraser, B.J., Rentoul, A.J. (1980).  Person-environment fit in open classrooms.<em>The Journal of Educational Research</em>, 73(3), 159-167.  https://doi.org/10.1080/00220671.1980.10885227
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2022). <em>Model-Building Strategies in Response Surface Analysis.</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Juhel, J., Wang, M-T. (2024a). <em>Does Needs Satisfaction Reflect Positive Needs-Supplies Fit or Misfit? A New Look at Autonomy Supportive Contexts Using Cubic Response Surface Analysis.</em> Manuscript submitted for publication.
</p>
<p>Núñez-Regueiro, F., Santana-Monagas, E., Juhel, J. (2024b). <em>How Needs-Supplies Fit With Teachers, Peers, and Parents Relate to Youth Outcomes</em> Manuscript submitted for publication. 
</p>
<p>Núñez-Regueiro, F., Juhel, J. (2024c). <em>Response Surface Analysis for the Social Sciences I: Identifying Best-Fitting Polynomial Solutions.</em> Manuscript submitted for publication.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
